- en: Part 1\. Node fundamentals
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第一部分：Node 基础
- en: Node has an extremely small standard library intended to provide the lowest-level
    API for module developers to build on. Even though it’s relatively easy to find
    third-party modules, many tasks can be accomplished without them. In the chapters
    to follow, we’ll take a deep dive into a number of core modules and explore how
    to put them to practical use.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Node 拥有一个极小的标准库，旨在为模块开发者提供最低级别的 API 以构建。尽管相对容易找到第三方模块，但许多任务可以在没有它们的情况下完成。在接下来的章节中，我们将深入研究多个核心模块，并探讨如何将它们用于实际应用。
- en: By strengthening your understanding of these modules, you’ll in turn become
    a more well-rounded Node programmer. You’ll also be able to dissect third-party
    modules with more confidence and understanding.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 通过加强对这些模块的理解，你将反过来成为一个更加全面的 Node 程序员。你还将能够更有信心和更深入地分析第三方模块。
- en: Chapter 1\. Getting started
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第一章：入门
- en: '*This chapter covers*'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Why Node?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么选择 Node？
- en: Node’s main features
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node 的主要特性
- en: Building a Node application
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建 Node 应用程序
- en: Node has quickly become established as a viable and indeed efficient web development
    platform. Before Node, not only was JavaScript on the server a novelty, but non-blocking
    I/O was something that required special libraries for other scripting languages.
    With Node, this has all changed.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Node 已迅速成为了一个可行且确实高效的 Web 开发平台。在 Node 出现之前，JavaScript 在服务器端还只是一种新颖的技术，而对于其他脚本语言来说，非阻塞
    I/O 则需要特殊的库。有了 Node，这一切都发生了改变。
- en: 'The combination of non-blocking I/O and JavaScript is immensely powerful: we
    can handle reading and writing files, network sockets, and more, all asynchronously
    *in the same process*, with the natural and expressive features of JavaScript
    callbacks.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 非阻塞 I/O 和 JavaScript 的结合非常强大：我们可以在同一个进程中异步地处理文件的读写、网络套接字等，所有这些都具有 JavaScript
    回调的自然和表达性特征。
- en: This book is geared toward intermediate Node developers, so this chapter is
    a quick refresher. If you want a thorough treatment of Node’s basics, then see
    our companion book, *Node.js in Action* (by Mike Cantelon, Marc Harter, TJ Holowaychuk,
    and Nathan Rajlich; Manning Publications, 2013).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本书面向中级 Node 开发者，因此本章是一个快速回顾。如果你想要对 Node 的基础知识进行彻底的了解，那么请参阅我们的配套书籍，*Node.js in
    Action*（由 Mike Cantelon、Marc Harter、TJ Holowaychuk 和 Nathan Rajlich 编写；Manning
    Publications，2013年）。
- en: In this chapter we’ll introduce Node, what it is, how it works, and why it’s
    something you can’t live without. In [chapter 2](kindle_split_011.html#ch02) you’ll
    get to try out some techniques by looking at Node’s globals—the objects and methods
    available to every Node process.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍 Node，它是什么，它是如何工作的，以及为什么它是你无法离开的东西。在 [第 2 章](kindle_split_011.html#ch02)
    中，你将通过查看 Node 的全局变量——每个 Node 进程可用的对象和方法——来尝试一些技术。
- en: '|  |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Preflight check**'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**预飞检查**'
- en: '*Node In Practice* is a recipe-style book, aimed at intermediate and advanced
    Node developers. Although this chapter covers some introductory material, later
    chapters advance quickly. For a beginner’s introduction to Node, see our companion
    book, *Node.js in Action*.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*Node In Practice* 是一本食谱风格的书籍，面向中级和高级 Node 开发者。尽管本章涵盖了一些入门材料，但后续章节会迅速深入。如果你想要对
    Node 的基础知识进行彻底的了解，请参阅我们的配套书籍，*Node.js in Action*。'
- en: '|  |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 1.1\. Getting to know Node
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.1\. 了解 Node
- en: Node is a *platform* for developing network applications. It’s built on V8,
    Google’s JavaScript runtime engine. Node isn’t just V8, though. An important part
    of the Node platform is its core library. This encompasses everything from TCP
    servers to asynchronous and synchronous file management. This book will teach
    you how to use these modules properly.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Node 是一个用于开发网络应用的 *平台*。它基于 V8，即 Google 的 JavaScript 运行时引擎。Node 不仅仅是 V8，Node
    平台的一个重要部分是其核心库。这包括从 TCP 服务器到异步和同步文件管理的一切。本书将教会你如何正确使用这些模块。
- en: 'But first: why use Node, and when should you use it? Let’s look into that question
    by seeing what kinds of scenarios Node excels at.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先：为什么使用 Node，何时应该使用它？让我们通过查看 Node 在哪些场景中表现出色来探讨这个问题。
- en: 1.1.1\. Why Node?
  id: totrans-19
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.1.1\. 为什么选择 Node？
- en: Let’s say you’re building an advertising server and distributing millions of
    adverts per minute. Node’s non-blocking I/O would be an extremely cost-effective
    solution for this, because the server could make the best use of available I/O
    without you needing to write special low-level code. Also, if you already have
    a web team that can write JavaScript, then they should be able to contribute to
    the Node project. A typical, heavier web platform wouldn’t have these advantages,
    which is why companies like Microsoft are contributing to Node despite having
    excellent technology stacks like .NET. Visual Studio users can install Node-specific
    tools^([[1](#ch01fn01)]) that add support for Intelli-Sense, profiling, and even
    npm. Microsoft also developed WebMatrix ([http://www.microsoft.com/web/webmatrix/](http://www.microsoft.com/web/webmatrix/)),
    which directly supports Node and can also be used to deploy Node projects.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在构建一个广告服务器，每分钟分发数百万条广告。Node 的非阻塞 I/O 将是这种情况下极具成本效益的解决方案，因为服务器可以充分利用可用的 I/O，而无需你编写特殊的低级代码。此外，如果你已经有一个能够编写
    JavaScript 的网络团队，那么他们应该能够为 Node 项目做出贡献。一个典型的、更重的网络平台不会有这些优势，这就是为什么像微软这样的公司尽管拥有像
    .NET 这样的优秀技术栈，也会为 Node 做出贡献。Visual Studio 用户可以安装 Node 特定的工具^([[1](#ch01fn01)])，这些工具增加了对
    Intelli-Sense、性能分析甚至 npm 的支持。微软还开发了 WebMatrix ([http://www.microsoft.com/web/webmatrix/](http://www.microsoft.com/web/webmatrix/))，它直接支持
    Node，也可以用来部署 Node 项目。
- en: ¹ See [https://nodejstools.codeplex.com/](https://nodejstools.codeplex.com/).
  id: totrans-21
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹ 查看 [https://nodejstools.codeplex.com/](https://nodejstools.codeplex.com/).
- en: Node embraces non-blocking I/O as a way to improve performance in certain types
    of applications. JavaScript’s traditional event-based implementation means it
    has a relatively convenient and well-understood syntax that suits asynchronous
    programming. In a typical programming language, an I/O operation blocks execution
    until it completes. Node’s asynchronous file and network APIs mean processing
    can still occur while these relatively slow I/O operations finish. [Figure 1.1](#ch01fig01)
    illustrates how different tasks can be performed using asynchronous network and
    file system APIs.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Node 通过拥抱非阻塞 I/O 作为提高某些类型应用程序性能的一种方式。JavaScript 的传统事件驱动实现意味着它具有相对方便且易于理解的语法，适合异步编程。在典型的编程语言中，I/O
    操作会阻塞执行，直到完成。Node 的异步文件和网络 API 意味着在相对较慢的 I/O 操作完成的同时，处理仍然可以发生。[图 1.1](#ch01fig01)
    展示了如何使用异步网络和文件系统 API 执行不同的任务。
- en: Figure 1.1\. An advertising server built with Node
  id: totrans-23
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 1.1\. 使用 Node 构建的广告服务器
- en: '![](01fig01_alt.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](01fig01_alt.jpg)'
- en: In [figure 1.1](#ch01fig01), a new HTTP request has been received and parsed
    by Node’s `http` module ![](1.jpg). The ad server’s application code then makes
    a database query, using an asynchronous API—a callback passed to a database read
    function ![](2.jpg). While Node waits for this to finish, the ad server is able
    to read a template file from the disk ![](3.jpg). This template will be used to
    display a suitable web page. Once the database request has finished, the template
    and database results are used to render the response ![](4.jpg).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [图 1.1](#ch01fig01) 中，一个新的 HTTP 请求已被 Node 的 `http` 模块接收并解析 ![](1.jpg)。然后广告服务器的应用程序代码使用异步
    API（传递给数据库读取函数的回调）进行数据库查询 ![](2.jpg)。当 Node 等待此操作完成时，广告服务器能够从磁盘读取模板文件 ![](3.jpg)。这个模板将用于显示合适的网页。一旦数据库请求完成，模板和数据库结果将用于生成响应
    ![](4.jpg)。
- en: While this is happening, other requests could also be hitting the ad server,
    and they’ll be handled based on the available resources ![](5.jpg). Without having
    to think about threads when developing the ad server, you’re able to push Node
    to use the server’s I/O resources very efficiently, just by using standard JavaScript
    programming techniques.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当这一切发生时，其他请求也可能正在撞击广告服务器，并且它们将根据可用资源进行处理 ![](5.jpg)。在开发广告服务器时无需考虑线程，你只需通过使用标准的
    JavaScript 编程技术，就能使 Node 非常高效地使用服务器的 I/O 资源。
- en: Other scenarios where Node excels are web APIs and web scraping. If you’re downloading
    and extracting content from web pages, then Node is perfect because it can be
    coaxed into simulating the DOM and running client-side JavaScript. Again, Node
    has a performance benefit here, because scrapers and web spiders are costly in
    terms of network and file I/O.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Node 在其他场景中也表现出色，例如网络 API 和网络爬虫。如果你正在下载和提取网页内容，那么 Node 是完美的选择，因为它可以被诱导模拟 DOM
    并运行客户端 JavaScript。同样，Node 在这里也有性能优势，因为爬虫和网络蜘蛛在网络和文件 I/O 方面成本较高。
- en: If you’re producing or consuming JSON APIs, Node is an excellent choice because
    it makes working with JavaScript objects easy. Node’s web frameworks (like Express,
    [http://expressjs.com](http://expressjs.com)) make creating JSON APIs fast and
    friendly. We have full details on this in [chapter 9](kindle_split_019.html#ch09).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在生成或消费JSON API，Node是一个很好的选择，因为它使处理JavaScript对象变得容易。Node的Web框架（如Express，[http://expressjs.com](http://expressjs.com)）使创建JSON
    API变得快速且友好。我们对此有详细的介绍在[第9章](kindle_split_019.html#ch09)。
- en: Node isn’t limited to web development. You can create any kind of TCP/IP server
    that you like. For example, a network game server that broadcasts the game’s state
    to various players over TCP/IP sockets can perform background tasks, perhaps maintaining
    the game world, while it sends data to the players. [Chapter 7](kindle_split_016.html#ch07)
    explores Node’s networking APIs.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Node不仅限于Web开发。你可以创建任何你喜欢的TCP/IP服务器。例如，一个通过网络游戏服务器将游戏状态广播到多个玩家的TCP/IP套接字，可以在发送数据给玩家的同时执行后台任务，比如维护游戏世界。[第7章](kindle_split_016.html#ch07)探讨了Node的网络API。
- en: '|  |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**When to use Node**'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**何时使用Node**'
- en: To get you thinking like a true Nodeist, the table below has examples of applications
    where Node is a good fit.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让你像真正的Node主义者一样思考，下表提供了Node适合的应用程序示例。
- en: '| Node’s strengths |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| Node的优势 |'
- en: '| --- |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| --- |'
- en: '| Scenario | Node’s strengths |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| 场景 | Node的优势 |'
- en: '| --- | --- |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Advertising distribution |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| 广告分发 |'
- en: Efficiently distributes small pieces of information
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高效地分发小块信息
- en: Handles potentially slow network connections
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理可能缓慢的网络连接
- en: Easily scales up to multiple processors or servers
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 易于扩展到多个处理器或服务器
- en: '|'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Game server |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| 游戏服务器 |'
- en: Uses the accessible language of JavaScript to model business logic
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用易于理解的JavaScript语言来模拟业务逻辑
- en: Programs a server catering to specific networking requirements without using
    C
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不使用C语言编写满足特定网络需求的程序
- en: '|'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Content management system, blog |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 内容管理系统，博客 |'
- en: Good for a team with client-side JavaScript experience
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适合有客户端JavaScript经验的团队
- en: Easy to make RESTful JSON APIs
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容易创建RESTful JSON API
- en: Lightweight server, complex browser JavaScript
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 轻量级服务器，复杂的浏览器JavaScript
- en: '|'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|  |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 1.1.2\. Node’s main features
  id: totrans-52
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.1.2\. Node的主要特点
- en: Node’s main features are its standard library, module system, and npm. Of course,
    there’s more to it than that, but in this book we’ll focus on teaching you how
    to use these parts of Node. We’ll use third-party libraries where it’s considered
    best practice, but you’ll see a lot of Node’s built-in features.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Node的主要特点是它的标准库、模块系统和npm。当然，还有更多，但在这本书中，我们将专注于教你如何使用Node的这些部分。我们会使用第三方库，但我们会看到Node的许多内置功能。
- en: 'In fact, Node’s strongest and most powerful feature is its standard library.
    This is really two parts: a set of binary libraries and the core modules. The
    binary libraries include `libuv`, which provides a fast run loop and non-blocking
    I/O for networking and the file system. It also has an HTTP library, so you can
    be sure your HTTP clients and servers are fast.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，Node最强大和最有力的特性是其标准库。这实际上是两部分：一组二进制库和核心模块。二进制库包括`libuv`，它为网络和文件系统提供快速的运行循环和非阻塞I/O。它还有一个HTTP库，所以你可以确信你的HTTP客户端和服务器是快速的。
- en: '[Figure 1.2](#ch01fig02) is a high-level overview of Node’s internals that
    shows how everything fits into place.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '[图1.2](#ch01fig02)是Node内部结构的高级概述，展示了所有东西是如何各就各位的。'
- en: Figure 1.2\. Node’s key parts in context
  id: totrans-56
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.2\. Node在上下文中的关键部分
- en: '![](01fig02_alt.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](01fig02_alt.jpg)'
- en: Node’s core modules are mostly written in JavaScript. That means if there’s
    anything you either don’t understand or want to understand in more detail, then
    you can read Node’s source code. This includes features like networking, high-level
    file system operations, the module system, and streams. It also includes Node-specific
    features like running multiple Node processes at once with the cluster module,
    and wrapping sections of code in event-based error handlers, known as *domains*.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Node的核心模块大多是用JavaScript编写的。这意味着如果你对任何东西不理解或者想更深入地了解，你可以阅读Node的源代码。这包括网络、高级文件系统操作、模块系统和流等特性。还包括Node特有的特性，如使用cluster模块同时运行多个Node进程，以及将代码段包裹在基于事件的错误处理器中，称为*域*。
- en: The next few sections focus on each core module in more detail, starting with
    the `events` API.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 下几节将更详细地介绍每个核心模块，从`events` API开始。
- en: 'EventEmitter: An API for events'
  id: totrans-60
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: EventEmitter：事件API
- en: Sooner or later every Node developer runs into `EventEmitter`. At first it seems
    like something only library authors would need to use, but it’s actually the basis
    for most of Node’s core modules. The streams, networking, and file system APIs
    derive from it.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Node开发者迟早会遇到`EventEmitter`。一开始它似乎只是库作者需要使用的东西，但实际上它是Node大多数核心模块的基础。流、网络和文件系统API都源自它。
- en: You can inherit from `EventEmitter` to make your own event-based APIs. Let’s
    say you’re working on a PayPal payment-processing module. You could make it event-based,
    so instances of `Payment` objects emit events like `paid` and `refund`. By designing
    the class this way, you decouple it from your application logic, so you can reuse
    it in more than one project.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过继承`EventEmitter`来创建自己的基于事件的API。假设你正在开发一个PayPal支付处理模块，你可以使其基于事件，这样`Payment`对象的实例会发出`paid`和`refund`等事件。通过这种方式设计类，你可以将其与应用程序逻辑解耦，这样你就可以在多个项目中重用它。
- en: 'We have a whole chapter dedicated to events: see [chapter 4](kindle_split_013.html#ch04)
    for more. Another interesting part of `EventEmitter` is that it’s used as the
    basis for the `stream` module.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个专门介绍事件的章节：更多内容请参阅[第4章](kindle_split_013.html#ch04)。`EventEmitter`的另一个有趣之处在于它被用作`stream`模块的基础。
- en: 'stream: The basis for scalable I/O'
  id: totrans-64
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 'stream: 可扩展I/O的基础'
- en: 'Streams inherit from `EventEmitter` and can be used to model data with unpredictable
    throughput—like a network connection where data speeds can vary depending on what
    other users on the network are doing. Using Node’s `stream` API allows you to
    create an object that receives events about the connection: `data` for when new
    data comes in, `end` when there’s no more data, and `error` when errors occur.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 流继承自`EventEmitter`，可以用来模拟具有不可预测吞吐量的数据——例如，网络连接，其中数据速度可能会根据网络上其他用户的行为而变化。使用Node的`stream`
    API允许你创建一个接收关于连接事件的对象：当有新数据到来时发出`data`事件，没有更多数据时发出`end`事件，以及发生错误时发出`error`事件。
- en: Rather than passing lots of callbacks to a readable stream constructor function,
    which would be messy, you subscribe to the events you’re interested in. Streams
    can be piped together, so you could have one stream class that reads data from
    the network and then pipe it to a stream that transforms the data into something
    else. This could be data from an XML API that’s transformed into JSON, making
    it easier to work with in JavaScript.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 与将大量回调函数传递给可读流构造函数相比，这样做会变得很混乱，你可以订阅你感兴趣的事件。流可以被管道连接起来，因此你可以有一个流类，它从网络读取数据，然后将数据通过管道传输到另一个流，将其转换成其他形式。这可能是从XML
    API转换成JSON的数据，使得在JavaScript中使用它变得更加容易。
- en: We love streams, so we’ve dedicated a whole chapter to them. Skip to [chapter
    5](kindle_split_014.html#ch05) to dive right in. You might think that events and
    streams sound abstract, and though that’s true, it’s also interesting to note
    that they’re used as a basis for I/O modules, like `fs` and `net`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们非常喜欢流，因此我们专门为它们编写了一整章。跳转到[第5章](kindle_split_014.html#ch05)开始深入了解。你可能认为事件和流听起来很抽象，尽管这是真的，但值得注意的是，它们被用作I/O模块（如`fs`和`net`）的基础。
- en: 'fs: Working with files'
  id: totrans-68
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 'fs: 文件操作'
- en: Node’s file system module is capable of reading and writing files using non-blocking
    I/O, but it also has synchronous methods. You can get information about files
    with `fs.stat`, and the synchronous equivalent is `fs.statSync`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Node的文件系统模块能够使用非阻塞I/O读写文件，但它也提供了同步方法。你可以使用`fs.stat`来获取文件信息，其同步版本是`fs.statSync`。
- en: If you want to use streams to process the contents of a file in a super-efficient
    manner, then use `fs.createReadStream` to return a `ReadableStream` object. There’s
    more about this in [chapter 6](kindle_split_015.html#ch06).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要以超级高效的方式使用流来处理文件内容，那么可以使用`fs.createReadStream`来返回一个`ReadableStream`对象。关于这方面的更多信息，请参阅[第6章](kindle_split_015.html#ch06)。
- en: 'net: Create network clients and servers'
  id: totrans-71
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 'net: 创建网络客户端和服务器'
- en: The networking module is the basis for the `http` module and can be used to
    create generalized network clients and servers. Although Node development is typically
    thought of as web-based, [chapter 7](kindle_split_016.html#ch07) shows you how
    to create TCP and UDP servers, which means you’re not limited to HTTP.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 网络模块是`http`模块的基础，可以用来创建通用的网络客户端和服务器。尽管Node开发通常被认为是基于Web的，但[第7章](kindle_split_016.html#ch07)展示了如何创建TCP和UDP服务器，这意味着你不仅限于HTTP。
- en: Global objects and other modules
  id: totrans-73
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 全局对象和其他模块
- en: If you have some experience making web applications with Node, perhaps with
    the Express framework, then you’ve already been using the `http`, `net`, and `fs`
    core modules without necessarily realizing it. Other built-in features aren’t
    headline-grabbing, but are critical to creating programs with Node.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一些使用Node制作Web应用程序的经验，也许是用Express框架，那么你可能已经在不知不觉中使用了`http`、`net`和`fs`核心模块。其他内置特性可能不是那么引人注目，但对于使用Node创建程序来说却至关重要。
- en: One example is the idea of global objects and methods. The `process` object,
    for example, allows you to pipe data into and out of a Node program by accessing
    the standard I/O streams. Much like Unix and Windows scripting, you can `cat`
    data to a Node program. The ubiquitous `console` object, beloved by JavaScript
    developers everywhere, is also considered a global object.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 一个例子是全球对象和方法的理念。例如，`process`对象允许你通过访问标准I/O流将数据管道输入和输出到Node程序中。就像Unix和Windows脚本一样，你可以将数据`cat`到Node程序中。无处不在的`console`对象，受到所有JavaScript开发者的喜爱，也被视为一个全局对象。
- en: Node’s module system is also part of this global functionality. [Chapter 2](kindle_split_011.html#ch02)
    is packed with techniques that show you how to use these features.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Node的模块系统也是全球功能的一部分。[第2章](kindle_split_011.html#ch02)中包含了展示如何使用这些特性的技术。
- en: Now that you’ve seen some of the core modules, it’s time to see them in action.
    The example will use the `stream` module to generate statistics on streams of
    text, and you’ll be able to use it with files and HTTP connections. If you want
    to learn more about the basics behind streams or HTTP in Node, refer to *Node.js
    in Action*.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到了一些核心模块，是时候看到它们在实际中的应用了。示例将使用`stream`模块生成文本流的统计数据，你将能够用它处理文件和HTTP连接。如果你想了解更多关于Node中流或HTTP的基础知识，请参考《Node.js实战》。
- en: 1.2\. Building a Node application
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2. 构建一个Node应用程序
- en: 'Instead of wading through more theory, we’ll show you how to build a Node application.
    It’s not just any application, though: it uses some of Node’s key features, like
    modules and streams. This will be a fast and intense tour of Node, so start up
    your favorite text editor and terminal and get ready.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会深入更多的理论，而是会展示如何构建一个Node应用程序。但这不仅仅是一个应用程序：它使用了Node的一些关键特性，如模块和流。这将是一次快速而深入的Node之旅，所以请启动你最喜欢的文本编辑器和终端，准备就绪。
- en: 'Here’s what you’ll learn over the next 10 minutes:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的10分钟内，你将学到以下内容：
- en: How to create a new Node project
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建一个新的Node项目
- en: How to write your own stream class
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何编写你自己的流类
- en: How to write a simple test and run it
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何编写一个简单的测试并运行它
- en: Streams are great for processing data, whether you’re reading, writing, or transforming
    it. Imagine you want to convert data from a database into another format, like
    CSV. You could create a stream class that accepts input from a database and outputs
    it as a stream of CSV. The output of this new CSV stream could be connected to
    an HTTP request, so you could stream CSV directly to a browser. The same class
    could even be connected to a writable file stream—you could even fork the stream
    to create a file *and* send it to a web browser.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 流非常适合处理数据，无论是读取、写入还是转换。想象一下，你想将数据库中的数据转换为另一种格式，比如CSV。你可以创建一个流类，它接受来自数据库的输入并将其作为CSV流输出。这个新的CSV流可以连接到HTTP请求，这样你就可以直接将CSV流到浏览器。同一个类甚至可以连接到可写文件流——你甚至可以将流分叉来创建文件并发送到网页浏览器。
- en: In this example, the stream class will accept text input, count word matches
    based on a regular expression, and then emit the results in an event when the
    stream has finished being sent. You could use this to count word matches in a
    text file, or pipe data from a web page and count the number of paragraph tags—it’s
    up to you. First we need to create a new project.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，流类将接受文本输入，根据正则表达式计算单词匹配，然后在流发送完毕时通过事件发出结果。你可以用它来计算文本文件中的单词匹配，或者从网页中读取数据并计算段落标签的数量——这取决于你。首先我们需要创建一个新的项目。
- en: 1.2.1\. Creating a new Node project
  id: totrans-86
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.2.1. 创建一个新的Node项目
- en: 'You might be wondering how a professional Node developer creates a new project.
    This is a straightforward process, thanks to npm. Though you could create a JavaScript
    file and run `node file.js`, we’ll use `npm init` to make a new project with a
    package.json file. Create a new directory ![](1.jpg), `cd` ![](2.jpg) into it,
    and then run `npm init` ![](3.jpg):'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道专业Node开发者是如何创建新项目的。多亏了npm，这个过程非常直接。虽然你可以创建一个JavaScript文件并运行`node file.js`，但我们将使用`npm
    init`来创建一个带有package.json文件的新项目。创建一个新的目录![](1.jpg)，`cd`![](2.jpg)进入它，然后运行`npm init`![](3.jpg)：
- en: '![](009fig01.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](009fig01.jpg)'
- en: 'Get used to typing these commands: you’ll be doing it often! You can press
    Return to accept the defaults when prompted by npm. Before you’ve written a line
    of JavaScript, you’ve already seen how cool one of Node’s major features—npm—is.
    It’s not just for installing modules, but also for managing projects.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 习惯于输入这些命令：您会经常这样做！当 npm 提示时，您可以按 Return 接受默认值。在您写下第一行 JavaScript 代码之前，您已经看到了
    Node 的一个主要特性——npm——是多么酷。它不仅用于安装模块，还用于管理项目。
- en: '|  |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**When to use a package.json file**'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**何时使用 package.json 文件**'
- en: You may have an idea for a small script, and may be wondering if a package.json
    file is really necessary. It isn’t always necessary, but in general you should
    create them as often as possible.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能有一个小脚本的思路，并想知道是否真的需要 package.json 文件。这并不总是必要的，但通常您应该尽可能多地创建它们。
- en: Node developers prefer small modules, and expressing dependencies in package
    .json means your project, no matter how small, is super-easy to install in the
    future, or on another person’s machine.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Node 开发者更喜欢小型模块，在 package.json 中表达依赖关系意味着无论项目多小，将来在您的机器上或在其他人的机器上安装都非常容易。
- en: '|  |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Now it’s time to write some JavaScript. In the next section you’ll create a
    new JavaScript file that implements a stream.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候编写一些 JavaScript 代码了。在下一节中，您将创建一个新的 JavaScript 文件，该文件实现了一个流。
- en: 1.2.2\. Making a stream class
  id: totrans-96
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.2.2\. 创建流类
- en: Create a new file called countstream.js and use `util.inherits` to derive from
    `stream.Writable` and implement the required `_write` method. Too fast? Let’s
    slow down. The full source is in the following listing.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 countstream.js 的新文件，并使用 `util.inherits` 从 `stream.Writable` 继承并实现所需 `_write`
    方法。太快了吗？让我们放慢速度。完整的源代码在下面的列表中。
- en: Listing 1.1\. A writable stream that counts
  id: totrans-98
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 1.1\. 一个计数可写流
- en: '![](010fig01_alt.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图片](010fig01_alt.jpg)'
- en: This example illustrates how subsequent examples in this book work. We present
    a snippet of code, annotated with hints on the underlying code. For example, the
    first part of the class uses the `util.inherits` method to inherit from the `Writable`
    base class ![](1.jpg). This example won’t be fully fleshed-out here—for more on
    writing your own streams, see [technique 30](kindle_split_014.html#ch05lev2sec9)
    in [chapter 5](kindle_split_014.html#ch05). For now, just focus on how regular
    expressions are passed to the constructor ![](2.jpg) and used to count text as
    it flows into instances of the class ![](3.jpg). Node’s `Writable` class calls
    `_write` for us, so we don’t need to worry about that yet.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子说明了本书中后续示例的工作方式。我们展示了一段代码片段，并对其底层代码进行了注释。例如，类的前一部分使用 `util.inherits` 方法从
    `Writable` 基类继承！![图片](1.jpg)。这个例子在这里不会完全展开——关于编写自己的流的更多信息，请参阅第 5 章[技术 30](kindle_split_014.html#ch05lev2sec9)。现在，只需关注正则表达式是如何传递给构造函数！![图片](2.jpg)并用于在类实例中流动文本计数！![图片](3.jpg)。Node
    的 `Writable` 类会为我们调用 `_write`，所以我们目前不需要担心这一点。
- en: '|  |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Streams and events
  id: totrans-102
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 流和事件
- en: In [listing 1.1](#ch01ex01) there was an event, `total`. This is one we made
    up—you can make up your own as well. Streams inherit from `EventEmitter`, so they
    have the same `emit` and `on` methods.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表 1.1](#ch01ex01)中有一个事件，`total`。这是我们编写的——您也可以自己编写。流继承自 `EventEmitter`，因此它们具有相同的
    `emit` 和 `on` 方法。
- en: '|  |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Node’s `Writable` base class will also call `end` when there’s no more data
    ![](4.jpg). This stream can be instantiated and piped as required. In the next
    section you’ll see how to connect it using `pipe`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当没有更多数据时，Node 的 `Writable` 基类也会调用 `end`！![图片](4.jpg)。这个流可以按需实例化和管道连接。在下一节中，您将看到如何使用
    `pipe` 连接它。
- en: 1.2.3\. Using a stream
  id: totrans-106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.2.3\. 使用流
- en: Now that you’ve seen how to make a stream class, you’re probably dying to try
    it out. Make another file, index.js, and add the code shown in the next listing.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经看到了如何创建流类，您可能迫不及待地想尝试一下。创建另一个文件，index.js，并添加下一列表中所示的代码。
- en: Listing 1.2\. Using the `CountStream` class
  id: totrans-108
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 1.2\. 使用 `CountStream` 类
- en: '![](011fig01_alt.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图片](011fig01_alt.jpg)'
- en: 'You can run this example by typing `node index.js`. It should display something
    like `Total matches: 24`. You can experiment with it by changing the URL that
    it fetches.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '您可以通过输入 `node index.js` 来运行此示例。它应该显示类似 `Total matches: 24` 的内容。您可以通过更改它获取的
    URL 来进行实验。'
- en: This example loads the module from [listing 1.1](#ch01ex01) ![](1.jpg) and then
    instantiates it with the text `'book'` ![](2.jpg). It also downloads the text
    from a website using Node’s standard `http` module ![](3.jpg) and then pipes the
    result through our `CountStream` class ![](4.jpg).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子从[列表1.1](#ch01ex01)加载模块，然后使用文本`'book'`实例化它 ![](2.jpg)。它还使用Node的标准`http`模块从网站下载文本
    ![](3.jpg)，然后将结果通过我们的`CountStream`类进行管道传输 ![](4.jpg)。
- en: 'The significant thing here is `res.pipe(countStream)`. When you pipe data,
    it doesn’t matter how big it is or if the network is slow: the `CountStream` class
    will dutifully count matches until the data has been processed. This Node program
    *does not* download the entire file first! It takes the file—piece by piece—and
    processes it. That’s the big thing here, and a critical aspect to Node development.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这里重要的是`res.pipe(countStream)`。当你进行管道传输时，数据的大小或网络是否缓慢并不重要：`CountStream`类将尽职尽责地计数匹配项，直到数据处理完毕。这个Node程序*不会*首先下载整个文件！它是逐块处理文件的。这就是这里的大事，也是Node开发的一个关键方面。
- en: To recap, [figure 1.3](#ch01fig03) summarizes what you’ve done so far to create
    a new Node project. First you created a new directory, and ran `npm init` ![](1.jpg),
    then you created some JavaScript files ![](2.jpg), and finally you ran the code
    ![](3.jpg).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾一下，[图1.3](#ch01fig03)总结了您到目前为止创建新Node项目所做的工作。首先，您创建了一个新目录，并运行了`npm init` ![](1.jpg)，然后创建了JavaScript文件
    ![](2.jpg)，最后运行了代码 ![](3.jpg)。
- en: Figure 1.3\. The three steps to creating a new Node project
  id: totrans-114
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图1.3. 创建新的Node项目的三个步骤
- en: '![](01fig03_alt.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](01fig03_alt.jpg)'
- en: Another important part of Node development is testing. The next section wraps
    up this example by testing `CountStream`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Node开发的重要部分之一是测试。下一节将通过测试`CountStream`来总结这个例子。
- en: 1.2.4\. Writing a test
  id: totrans-117
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.2.4. 编写测试
- en: We can write a short test for `CountStream` without using any third-party modules.
    Node comes with a built-in `assert` module, so we can use that for a quick test.
    Open test.js and add the code shown next.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以不使用任何第三方模块为`CountStream`编写一个简短的测试。Node自带了一个内置的`assert`模块，因此我们可以用它来进行快速测试。打开test.js并添加下面的代码。
- en: Listing 1.3\. Using the `CountStream` class
  id: totrans-119
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表1.3. 使用`CountStream`类
- en: '![](012fig01_alt.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](012fig01_alt.jpg)'
- en: 'This test can be run with `node test.js`, and you should see `Assertions passed:
    1` printed in the console. The test actually reads the current file and passes
    the data through `CountStream`. It might invoke Ouroboros, but it’s a useful example
    because it gives us content that we know something about—we can always be sure
    there is one match for the word *example*.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '这个测试可以用`node test.js`运行，你应该在控制台看到打印出`Assertions passed: 1`。实际上，这个测试读取当前文件并通过`CountStream`传递数据。它可能会调用Ouroboros，但这是一个有用的例子，因为它给我们提供了我们了解的内容——我们可以始终确信有一个匹配的单词*example*。'
- en: '|  |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Assertions
  id: totrans-123
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 断言
- en: Node comes with an assertion library called `assert`. A basic test can be made
    by calling the module directly – `assert(expression)`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Node自带了一个名为`assert`的断言库。可以通过直接调用模块来制作一个基本的测试 – `assert(expression)`。
- en: '|  |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The first thing the test does is listen for the `total` event, which is emitted
    by instances of `CountStream` ![](1.jpg). This is a good place to assert that
    the number of matches should be the same as what is expected ![](2.jpg). A readable
    stream that represents the current file is opened and piped through our class
    ![](3.jpg). Just before the end of the program, we print out how many assertions
    were hit ![](4.jpg).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 测试首先监听`total`事件，该事件由`CountStream`的实例发出 ![](1.jpg)。这是一个很好的地方来断言匹配的数量应该与预期相同 ![](2.jpg)。打开了一个表示当前文件的可读流，并将其通过我们的类进行管道传输
    ![](3.jpg)。在程序结束前，我们打印出触发了多少断言 ![](4.jpg)。
- en: This is important because if the `total` event never fires, then `assert.equal`
    won’t run at all. We have no way of knowing whether tests in callbacks are run,
    so a simple counter has been used to illustrate how Node programming can require
    patterns from the other programming languages and platforms that you might be
    familiar with.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这很重要，因为如果`total`事件从未触发，那么`assert.equal`根本不会运行。我们没有方法知道回调中的测试是否运行，因此使用了一个简单的计数器来展示Node编程可能需要从您可能熟悉的其他编程语言和平台上获取的模式。
- en: 'If you’re getting tired, you can rest here, but there’s a bit of sugar to finish
    off our project. Node developers like to run tests and other scripts using npm
    on the command line. Open package.json and change the `"test"` property to look
    like this:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你感到疲倦，可以在这里休息一下，但我们的项目还有一些甜头。Node开发者喜欢在命令行上使用npm运行测试和其他脚本。打开package.json并将`"test"`属性更改为如下所示：
- en: '[PRE0]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now you can run tests just by typing `npm test`. This comes in handy when you
    have lots of tests and running them is more complicated. Running tests, test runners,
    and asynchronous testing issues are all covered in [chapter 10](kindle_split_020.html#ch10).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你只需输入 `npm test` 就可以运行测试。当你有很多测试且运行它们更复杂时，这非常有用。测试、测试运行器和异步测试问题都在第 10 章（kindle_split_020.html#ch10）中有所涉及。
- en: '|  |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**npm scripts**'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**npm 脚本**'
- en: The `npm test` and `npm start` commands can be configured by editing package.json.
    You can also run arbitrary commands, which are invoked with `npm run command`.
    All you need to do is set a property under `scripts`, just like listing 1.4.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过编辑 package.json 来配置 `npm test` 和 `npm start` 命令。你还可以运行任意命令，这些命令通过 `npm run
    command` 调用。你所需要做的只是设置 `scripts` 下的一个属性，就像列表 1.4 一样。
- en: This is useful for specific types of tests or housekeeping routines—for example
    `npm run integration-tests`, or maybe even `npm run seed-data`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于特定类型的测试或维护程序很有用——例如 `npm run integration-tests`，或者甚至 `npm run seed-data`。
- en: '|  |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Depending on your previous experience with Node, this example might have been
    intense, but it captures how Node developers think and take advantage of the powerful
    resources that come with Node.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你之前对 Node 的经验，这个例子可能有些复杂，但它捕捉了 Node 开发者的思考方式和利用 Node 带来的强大资源的方式。
- en: Now that you’ve seen how a Node project is put together, we’re done with the
    refresher course on Node. The next chapter introduces our first set of techniques,
    which is the bulk of this book’s format. It covers ways of working with the global
    features that are available to all Node programs.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经看到了一个 Node 项目的构建方式，我们已经完成了 Node 的复习课程。下一章介绍了我们的第一套技术，这是本书格式的主要内容。它涵盖了所有
    Node 程序都可以使用的全局功能的工作方式。
- en: 1.3\. Summary
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.3\. 摘要
- en: In this chapter you’ve learned about *Node.js in Practice*—what it covers and
    how it focuses on Node’s impressive built-in core modules like the networking
    module and file system modules.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了关于 *Node.js in Practice* 的内容——它涵盖了什么以及它如何专注于 Node 令人印象深刻的内置核心模块，如网络模块和文件系统模块。
- en: You’ve also learned about what makes Node tick, and how to use it. Some of the
    main points we covered were
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 你还了解到了使 Node 运行的原因以及如何使用它。我们涵盖的一些主要点是
- en: When to use Node, and how Node builds on non-blocking I/O, allowing you to write
    standard JavaScript but get great performance benefits.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 何时使用 Node，以及 Node 如何构建在非阻塞 I/O 之上，允许你编写标准的 JavaScript 但获得出色的性能优势。
- en: Node’s standard library is referred to as its *core modules*.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node 的标准库被称为其 *核心模块*。
- en: What the core modules do—I/O tasks like network protocols, and work with files
    and more generic features like streams.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 核心模块的功能——如网络协议的 I/O 任务，以及与文件和更通用的功能（如流）的工作。
- en: How to quickly start a new Node project, complete with a package.json file so
    dependencies and scripts can be added.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何快速启动一个新的 Node 项目，包括 package.json 文件，以便添加依赖项和脚本。
- en: How to use Node’s powerful `stream` API to process data.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 Node 强大的 `stream` API 处理数据。
- en: Streams inherit from `EventEmitter`, so you can emit and respond to any events
    that you want to use in your application.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流继承自 `EventEmitter`，因此你可以发出并响应你想要在应用程序中使用的任何事件。
- en: How to write small tests just by using npm and the `assert` module—you can test
    out ideas without installing any third-party libraries.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何仅使用 npm 和 `assert` 模块编写小型测试——你可以在不安装任何第三方库的情况下测试想法。
- en: Finally, we hope you learned something from our introductory application. Using
    event-based APIs, non-blocking I/O, and streams is really what Node is all about,
    but it’s also important to take advantage of Node’s unique tools like the package.json
    file and npm.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们希望你能从我们的入门级应用程序中学到一些东西。使用基于事件的 API、非阻塞 I/O 和流确实是 Node 的核心，但利用 Node 的独特工具（如
    package.json 文件和 npm）也同样重要。
- en: 'Now it’s time for techniques. The next chapter introduces the features that
    you don’t even have to load to use: the global objects.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候介绍技术了。下一章介绍了你甚至不需要加载就可以使用的功能：全局对象。
- en: 'Chapter 2\. Globals: Node’s environment'
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第二章\. 全局变量：Node 的环境
- en: '*This chapter covers*'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Using modules
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模块
- en: What you can do without requiring a single module
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不需要任何模块就能做的事情
- en: The process and console objects
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进程和控制台对象
- en: Timers
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定时器
- en: Global objects are available in all modules. They’re universal. Whether you’re
    writing network programs, command-line scripts, or web applications, your program
    will have access to these objects. That means you can always depend on features
    like `console.log` and `__dirname`—both are explained in detail in this chapter.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 全局对象在所有模块中都是可用的。它们是通用的。无论你是在编写网络程序、命令行脚本还是网络应用程序，你的程序都将能够访问这些对象。这意味着你可以始终依赖像
    `console.log` 和 `__dirname` 这样的功能——这两个功能在本章中都有详细解释。
- en: The goal of this chapter is to introduce Node’s global objects and methods to
    help you learn what functionality is available to all Node processes. This will
    help you better understand Node and its relationship to the operating system,
    and how it compares with other JavaScript environments like browsers.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标是介绍 Node 的全局对象和方法，帮助你了解所有 Node 进程可用的功能。这将帮助你更好地理解 Node 以及它与操作系统的关系，以及它与浏览器等其他
    JavaScript 环境的比较。
- en: Node provides some important functionality out of the box, even without loading
    any modules. In addition to the features provided by the ECMAScript language,
    Node has several *host objects*—objects supplied by Node to help programs to execute.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Node 提供了一些重要的内置功能，即使不加载任何模块也是如此。除了 ECMAScript 语言提供的功能外，Node 还包含几个 *宿主对象*——Node
    提供的对象，以帮助程序执行。
- en: A key global object is `process`, which is used to communicate with the operating
    system. Unix programmers will be familiar with standard I/O streams, and these
    are accessible through the `process` object using Node’s streaming API.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 一个关键的全球对象是 `process`，它用于与操作系统通信。Unix 程序员将熟悉标准 I/O 流，并且可以通过 Node 的流式 API 通过 `process`
    对象访问这些流。
- en: Another important global is the `Buffer` class. This is included because JavaScript
    has traditionally lacked support for binary data. As the ECMAScript standards
    evolve, this is being addressed, but for now most Node developers rely on the
    `Buffer` class. For more about buffers, see [chapter 3](kindle_split_012.html#ch03).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的全局对象是 `Buffer` 类。这是因为它包含了 JavaScript 传统的二进制数据支持不足的问题。随着 ECMAScript 标准的发展，这个问题正在得到解决，但到目前为止，大多数
    Node 开发者仍然依赖于 `Buffer` 类。有关缓冲区的更多信息，请参阅第 3 章 [kindle_split_012.html#ch03]。
- en: Some globals are a separate instance for each module. For example, `module`
    is available in every Node program, but is local to the current module. Since
    Node programs may consist of several modules, that means a given program has several
    different `module` objects—they behave like globals, but are in *module scope*.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 一些全局变量是每个模块的独立实例。例如，`module` 在每个 Node 程序中都是可用的，但它是当前模块的局部变量。由于 Node 程序可能由多个模块组成，这意味着给定的程序有多个不同的
    `module` 对象——它们的行为像全局变量，但位于 *模块作用域* 内。
- en: In the next section you’ll learn how to load modules. The objects and methods
    relating to modules are globals, and as such are always available and ready to
    be used.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将学习如何加载模块。与模块相关的对象和方法是全局的，因此它们始终可用并准备好使用。
- en: 2.1\. Modules
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1\. 模块
- en: Modules can be used to organize larger programs and distribute Node projects,
    so it’s important to be familiar with the basic techniques required to install
    and create them.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 模块可以用来组织更大的程序和分发 Node 项目，因此熟悉安装和创建它们的基本技术很重要。
- en: Technique 1 Installing and loading modules
  id: totrans-165
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 技巧 1 安装和加载模块
- en: Whether you’re using a core module provided by Node or a third-party module
    from npm, support for modules is baked right into Node and is always available.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你是在使用 Node 提供的核心模块还是 npm 的第三方模块，模块的支持都内置在 Node 中，并且始终可用。
- en: Problem
  id: totrans-167
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: You want to load a third-party module from npm.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 你想从 npm 加载第三方模块。
- en: Solution
  id: totrans-169
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案
- en: Install the module with the command-line tool, npm, and then load the module
    using `require`. The following listing shows an example of installing the `express`
    module.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 使用命令行工具 npm 安装模块，然后使用 `require` 加载模块。以下列表显示了一个安装 `express` 模块的示例。
- en: Listing 2.1\. Using npm
  id: totrans-171
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.1\. 使用 npm
- en: '![](016fig01_alt.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![图片描述](016fig01_alt.jpg)'
- en: Discussion
  id: totrans-173
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论
- en: The npm command-line tool is distributed with Node, and can be used to search,
    install, and manage packages. The website [https://npmjs.org](https://npmjs.org)
    provides another interface for searching modules, and each module has its own
    page that displays the associated readme file and dependencies.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: npm 命令行工具与 Node 一起分发，可用于搜索、安装和管理包。网站 [https://npmjs.org](https://npmjs.org)
    提供了另一个搜索模块的界面，每个模块都有自己的页面，显示相关的说明文件和依赖项。
- en: 'Once you know the name of a module, installation is easy: type `npm install
    module-name` ![](1.jpg) and it will be installed into ./node_modules. Modules
    can also be “globally” installed—running `npm install -g module_name` will install
    it into a global folder. This is usually /usr/local/lib/node_modules on Unix systems.
    In Windows it should be wherever the `node.exe` binary is located.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦知道了模块的名称，安装就变得简单：键入 `npm install module-name` ![1.jpg](1.jpg) 它将被安装到 ./node_modules
    中。模块也可以“全局”安装——运行 `npm install -g module_name` 将其安装到全局文件夹中。在 Unix 系统上，这通常是 /usr/local/lib/node_modules。在
    Windows 上，它应该在 `node.exe` 二进制文件所在的任何位置。
- en: After a module has been installed, it can be loaded with `require('module-name')`
    ![](2.jpg). The `require` method usually returns an object or a method, depending
    on how the module has been set up.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 模块安装后，可以使用 `require('module-name')` 来加载它 ![2.jpg](2.jpg)。`require` 方法通常会返回一个对象或一个方法，具体取决于模块是如何设置的。
- en: '|  |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Searching npm**'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '**搜索 npm**'
- en: By default, npm searches across several fields in each module’s package.json
    file. This includes the module’s name, description, maintainers, URL, and keywords.
    That means a simple search like `npm` `search express` yields hundreds of results.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，npm 会搜索每个模块的 package.json 文件中的多个字段。这包括模块的名称、描述、维护者、URL 和关键词。这意味着简单的搜索如
    `npm search express` 会产生数百个结果。
- en: 'You can reduce the number of matches by searching with a regular expression.
    Wrap a search term in slashes to trigger npm’s regular expression matching: `npm
    search /^express$/`'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过使用正则表达式来减少匹配的数量。将搜索词用斜杠括起来以触发 npm 的正则表达式匹配：`npm search /^express$/`
- en: However, this is still limited. Fortunately, there are open source modules that
    improve on the built-in search command. For example, `npmsearch` by Gorgi Kosev
    will order results using its own relevance rankings.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这仍然有限。幸运的是，有一些开源模块可以改进内置的搜索命令。例如，Gorgi Kosev 的 `npmsearch` 会使用它自己的相关性排名来排序结果。
- en: '|  |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The question of whether to install a module globally is critical to developing
    maintainable projects. If other people need to work on your project, then you
    should consider adding modules as dependencies to your project’s package.json
    file. Keeping project dependencies tightly managed will make it easier to maintain
    them in the future when new versions of dependencies are released.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 是否全局安装模块的问题对于开发可维护的项目至关重要。如果其他人需要参与您的项目，那么您应该考虑将模块作为依赖项添加到项目 package.json 文件中。保持项目依赖项紧密管理将使得在依赖项的新版本发布时更容易维护它们。
- en: Technique 2 Creating and managing modules
  id: totrans-184
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 技术二：创建和管理模块
- en: In addition to installing and distributing open source modules, “local” modules
    can be used to organize projects.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 除了安装和分发开源模块外，“本地”模块还可以用来组织项目。
- en: Problem
  id: totrans-186
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: You want to break a project up into separate files.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望将项目拆分成单独的文件。
- en: Solution
  id: totrans-188
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use the `exports` object.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `exports` 对象。
- en: Discussion
  id: totrans-190
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论
- en: Node’s module system provides a solution to splitting code across multiple files.
    It’s very different from `include` in C, or even `require` in Ruby and Python.
    The main difference is that `require` in Node returns an object rather than loading
    code into the current namespace, as would occur with a C preprocessor.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: Node 的模块系统为在多个文件之间分割代码提供了一个解决方案。它与 C 中的 `include` 或 Ruby 和 Python 中的 `require`
    非常不同。主要区别在于 Node 中的 `require` 返回一个对象，而不是将代码加载到当前命名空间中，就像 C 预处理器会发生的那样。
- en: In [technique 1](#ch02lev2sec1) you saw how npm can be used to install modules,
    and how `require` is used to load them. npm isn’t the only thing that manages
    modules, though—Node has a built-in module system based on the CommonJS Modules/1.1
    specification ([http://wiki.commonjs.org/wiki/Modules/1.1](http://wiki.commonjs.org/wiki/Modules/1.1)).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [技术 1](#ch02lev2sec1) 中，您看到了如何使用 npm 安装模块，以及如何使用 `require` 来加载它们。尽管 npm 不是唯一管理模块的工具，但
    Node 基于CommonJS Modules/1.1 规范（[http://wiki.commonjs.org/wiki/Modules/1.1](http://wiki.commonjs.org/wiki/Modules/1.1)）提供了一个内置的模块系统。
- en: This allows objects, functions, and variables to be exported from a file and
    used elsewhere. The `exports` object is always present and, although this chapter
    specifically explores global objects, it’s not really a global. It’s more accurate
    to say that the `exports` object is in module scope.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许对象、函数和变量从一个文件导出并在其他地方使用。`exports` 对象始终存在，尽管本章专门探讨了全局对象，但它实际上并不是全局的。更准确地说，`exports`
    对象位于模块作用域内。
- en: When a module is focused around a single class, then users of the module will
    prefer to type `var MyClass = require('myclass');` rather than `var MyClass =
    require('myclass').MyClass`, so you should use `modules.export`. [Listing 2.2](#ch02ex02)
    shows how this works. This is different from using the `exports` object, which
    requires that you set a property to export something.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个模块围绕一个单一类构建时，模块的用户将更喜欢键入 `var MyClass = require('myclass');` 而不是 `var MyClass
    = require('myclass').MyClass`，因此您应该使用 `module.exports`。[列表 2.2](#ch02ex02) 展示了这是如何工作的。这与使用
    `exports` 对象不同，它要求您设置一个属性来导出某些内容。
- en: Listing 2.2\. Exporting modules
  id: totrans-195
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.2\. 导出模块
- en: '![](018fig01.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![](018fig01.jpg)'
- en: '[Listing 2.3](#ch02ex03) shows how to export multiple objects, methods, or
    values, a technique that would typically be used for utility libraries that export
    multiple things.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 2.3](#ch02ex03) 展示了如何导出多个对象、方法或值，这是一种通常用于导出多个内容的实用库技术。'
- en: Listing 2.3\. Exporting multiple objects, methods, and values
  id: totrans-198
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.3\. 导出多个对象、方法和值
- en: '[PRE1]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Finally, [listing 2.4](#ch02ex04) shows how to load these modules with `require`,
    and how to use the functionality they provide.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，[列表 2.4](#ch02ex04) 展示了如何使用 `require` 加载这些模块以及如何使用它们提供的功能。
- en: Listing 2.4\. Loading modules with require
  id: totrans-201
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.4\. 使用 require 加载模块
- en: '![](018fig02.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![](018fig02.jpg)'
- en: Note that loading a local module always requires a path name—in these examples
    the path is just ./. Without it, Node will attempt to find a matching module in
    $NODE_PATH, and then ./node_modules, $HOME/.node_modules, $HOME/.node_libraries,
    or $PREFIX/lib/node.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，加载本地模块始终需要一个路径名——在这些示例中，路径只是 ./. 如果没有它，Node 将尝试在 $NODE_PATH 中找到匹配的模块，然后是
    ./node_modules、$HOME/.node_modules、$HOME/.node_libraries 或 $PREFIX/lib/node。
- en: In [listing 2.4](#ch02ex04) notice that ./myclass is automatically expanded
    to ./myclass.js ![](1.jpg), and ./module-2 is expanded to ./module-2.js ![](2.jpg).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [列表 2.4](#ch02ex04) 中注意，./myclass 会自动展开为 ./myclass.js ![](1.jpg)，而 ./module-2
    会展开为 ./module-2.js ![](2.jpg)。
- en: 'The output from this program would be as follows:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序的输出如下：
- en: '[PRE2]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '|  |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Which module?**'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '**哪个模块？**'
- en: To determine the exact module Node will load, use `require.resolve(id)`. This
    will return a fully expanded filename.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定 Node 将加载的确切模块，请使用 `require.resolve(id)`。这将返回一个完全展开的文件名。
- en: '|  |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Once a module is loaded, it’ll be cached. That means that loading it multiple
    times will return the cached copy. This is generally efficient, and helps you
    heavily reuse modules within a project without worrying about incurring an overhead
    when using `require`. Rather than centrally loading all of the dependencies, you
    can safely call `require` on the same module.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦加载了一个模块，它就会被缓存。这意味着多次加载它将返回缓存的副本。这通常很高效，并有助于在项目中大量重用模块，而无需担心使用 `require` 时产生开销。您不必集中加载所有依赖项，可以安全地对该模块调用
    `require`。
- en: '|  |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Unloading modules**'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '**卸载模块**'
- en: Although automatically caching modules fits many use cases in Node development,
    there may be rare occasions when you want to unload a module. The `require.cache`
    object makes this possible.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然自动缓存模块适合 Node 开发中的许多用例，但可能存在一些罕见的情况，您可能想要卸载一个模块。`require.cache` 对象使这成为可能。
- en: 'To remove a module from the cache, use the `delete` keyword. The full path
    of the module is required, which you can obtain with `require.resolve`. For example:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 要从缓存中删除一个模块，请使用 `delete` 关键字。需要模块的完整路径，您可以使用 `require.resolve` 获取。例如：
- en: '[PRE3]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This should return `true`, which means the module was unloaded.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该返回 `true`，这意味着模块已被卸载。
- en: '|  |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: In the next technique you’ll learn how to group related modules together and
    load them in one go.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个技巧中，您将学习如何将相关模块分组并一次性加载它们。
- en: Technique 3 Loading a group of related modules
  id: totrans-220
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 技巧 3 加载一组相关模块
- en: Node can treat directories as modules, offering opportunities for logically
    grouping related modules together.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: Node 可以将目录视为模块，这为逻辑上分组相关模块提供了机会。
- en: Problem
  id: totrans-222
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: You want to group related files together under a directory, and only have to
    load it with one call to `require`.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望将相关文件分组在目录下，并且只需通过一次 `require` 调用即可加载。
- en: Solution
  id: totrans-224
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案
- en: Create a file called index.js to load each module and export them as a group,
    or add a package.json file to the directory.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 index.js 的文件来加载每个模块并将它们作为一组导出，或者在该目录中添加一个 package.json 文件。
- en: Discussion
  id: totrans-226
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论
- en: Sometimes a module is logically self-contained, but it still makes sense to
    separate it into several files. Most of the modules you’ll find on npm will be
    written this way. Node’s module system supports this by allowing directories to
    act as modules. The easiest way to do this is to create a file called index.js
    that has a `require` statement to load each file. The following listing demonstrates
    how this works.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，一个模块在逻辑上可能是自包含的，但将其分成几个文件仍然是有意义的。你将在 npm 上找到的大多数模块都是这样编写的。Node 的模块系统通过允许目录作为模块来支持这一点。最简单的方法是创建一个名为
    index.js 的文件，该文件包含一个 `require` 语句来加载每个文件。下面的列表演示了这是如何工作的。
- en: Listing 2.5\. The group/index.js file
  id: totrans-228
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.5\. group/index.js 文件
- en: '![](020fig01.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![](020fig01.jpg)'
- en: The group/one.js and group/two.js files can then export values or methods ![](1.jpg)
    as required. The next listing shows an example of such a file.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: group/one.js 和 group/two.js 文件可以随后按需导出值或方法 ![1](1.jpg)。下面的列表显示了此类文件的示例。
- en: Listing 2.6\. The group/one.js file
  id: totrans-231
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.6\. group/one.js 文件
- en: '[PRE4]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Code that needs to use a folder as a module can then use a single `require`
    statement to load everything in one go. The following listing demonstrates this.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 需要使用文件夹作为模块的代码可以使用单个 `require` 语句一次性加载所有内容。下面的列表演示了这一点。
- en: Listing 2.7\. A file loading the group of modules
  id: totrans-234
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.7\. 加载模块组的文件
- en: '![](020fig02_alt.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![](020fig02_alt.jpg)'
- en: 'The output of [listing 2.7](#ch02ex07) should look like this:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 2.7](#ch02ex07) 的输出应如下所示：'
- en: '[PRE5]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This approach is often used as an architectural technique to structure web applications.
    Related items, like controllers, models, and views, can be kept in separate folders
    to help separate concerns within the application. [Figure 2.1](#ch02fig01) shows
    how to structure applications following this style.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法通常用作架构技术来构建 Web 应用程序。相关项目，如控制器、模型和视图，可以保存在不同的文件夹中，以帮助在应用程序中分离关注点。[图 2.1](#ch02fig01)
    展示了按照这种风格构建应用程序的方法。
- en: Figure 2.1\. Folders as modules
  id: totrans-239
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 2.1\. 作为模块的文件夹
- en: '![](02fig01_alt.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![](02fig01_alt.jpg)'
- en: Node also offers an alternative technique that supports this pattern. Adding
    a package.json file to a directory can help the module system figure out how to
    load all of the files in the directory at once. The JSON file should include a
    `main` property to point to a JavaScript file. This is actually the default file
    Node looks for when loading modules—if no package.json is present, it’ll then
    look for index.js. The next listing shows an example of a package.json file.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: Node 还提供了一种支持此模式的替代技术。将一个 package.json 文件添加到目录中可以帮助模块系统一次性确定如何加载目录中的所有文件。该 JSON
    文件应包含一个 `main` 属性，指向一个 JavaScript 文件。这实际上是 Node 在加载模块时默认查找的文件——如果没有 package.json，它将接着查找
    index.js。下面的列表显示了 package.json 文件的示例。
- en: Listing 2.8\. A package.json file for a directory containing a module
  id: totrans-242
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.8\. 包含模块的目录的 package.json 文件
- en: '![](021fig01.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![](021fig01.jpg)'
- en: '|  |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**File extensions**'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '**文件扩展名**'
- en: When loading a file, Node is configured to search for files with the .js, .json,
    and .node extensions. The `require.extensions` array can be used to tell `require`
    to load files with other extensions. Node’s module system will take this into
    account when treating directories as modules, as well.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 当加载文件时，Node 配置为搜索具有 .js、.json 和 .node 扩展名的文件。可以使用 `require.extensions` 数组来告诉
    `require` 加载具有其他扩展名的文件。当 Node 的模块系统将目录视为模块时，也会考虑这一点。
- en: This feature is marked as deprecated in Node’s documentation, but the module
    system is also marked as “locked” so it shouldn’t go away. If you want to use
    it, you should check Node’s documentation first.^([[1](#ch02fn01)]) If you’re
    just trying to load a JavaScript file from a legacy system that has an unusual
    extension, then it might be suitable for experimentation.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 此功能在 Node 的文档中被标记为已弃用，但模块系统也被标记为“锁定”，因此它不应该消失。如果你想使用它，你应该首先检查 Node 的文档。^([[1](#ch02fn01)])
    如果你只是尝试从具有不寻常扩展名的旧系统加载 JavaScript 文件，那么它可能适合实验。
- en: ¹ See [http://nodejs.org/api/globals.html#globals_require_extensions](http://nodejs.org/api/globals.html#globals_require_extensions).
  id: totrans-248
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹ 查看 [http://nodejs.org/api/globals.html#globals_require_extensions](http://nodejs.org/api/globals.html#globals_require_extensions)。
- en: '|  |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The `require` API provides many ways to manage files. But what about when you
    want to load something relative to the current module, or the directory where
    the module is saved? Read on for an explanation in [technique 4](#ch02lev2sec4).
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`require` API 提供了许多管理文件的方法。但当你想要加载相对于当前模块或模块保存的目录中的内容时怎么办？请继续阅读以了解 [技巧 4](#ch02lev2sec4)
    的解释。'
- en: Technique 4 Working with paths
  id: totrans-251
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 技巧 4：处理路径
- en: Sometimes you need to open files based on the relative location. Node provides
    tools for determining the path to the current file, directory, and module.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你需要根据相对位置打开文件。Node 提供了确定当前文件、目录和模块路径的工具。
- en: Problem
  id: totrans-253
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: You want to access a file that isn’t handled by the module system.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 你想访问一个不由模块系统处理的文件。
- en: Solution
  id: totrans-255
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use `__dirname` or `__filename` to determine the location of the file.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `__dirname` 或 `__filename` 确定文件的路径。
- en: Discussion
  id: totrans-257
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论
- en: Sometimes you need to load data from a file that clearly shouldn’t be handled
    by Node’s module system, but you need to take the path of the current script into
    account—for example, a template in a web application. The `__dirname` and `__filename`
    variables are extremely useful in such cases.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你需要从文件中加载数据，这些文件显然不应该由 Node 的模块系统处理，但你需要考虑当前脚本的路径——例如，一个 Web 应用程序中的模板。在这种情况下，`__dirname`
    和 `__filename` 变量非常有用。
- en: Running the following listing will print the output of these values.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下列表将打印这些值的输出。
- en: Listing 2.9\. Path variables
  id: totrans-260
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.9\. 路径变量
- en: '![](022fig01_alt.jpg)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![图片描述](022fig01_alt.jpg)'
- en: 'Most developers join these variables with path fragments using simple string
    concatenation: `var view = __dirname + ''/views/view.html'';`. This works with
    both Windows and Unix—the Windows APIs are clever enough to automatically switch
    the slashes to the native format, so you don’t need special handling to support
    both operating systems.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数开发者使用简单的字符串连接将这两个变量与路径片段连接起来：`var view = __dirname + '/views/view.html';`。这在
    Windows 和 Unix 上都适用——Windows API 足够智能，可以自动将反斜杠转换为本地格式，因此你不需要特殊处理来支持这两个操作系统。
- en: 'If you really want to ensure paths are joined correctly, you can use the `path.join`
    method from Node’s `path` module: `path.join(__dirname, ''views'', ''view.html'');`.'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你确实想确保路径正确连接，可以使用 Node 的 `path` 模块中的 `path.join` 方法：`path.join(__dirname,
    'views', 'view.html');`。
- en: Apart from module management, there are globally available objects for writing
    to the standard I/O streams. The next set of techniques explores `process.stdout`
    and the `console` object.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 除了模块管理之外，还有全局可用的对象用于写入标准 I/O 流。下一组技巧将探讨 `process.stdout` 和 `console` 对象。
- en: 2.2\. Standard I/O and the console object
  id: totrans-265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.2\. 标准I/O和console对象
- en: Text can be piped to a Node process by using command-line tools in Unix or Windows.
    This section includes techniques for working with these standard I/O streams,
    and also how to correctly use the `console` object for a wide range of logging-related
    tasks.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 Unix 或 Windows 的命令行工具将文本导入到 Node 进程中。本节包括处理这些标准 I/O 流的技术，以及如何正确使用 `console`
    对象来完成各种与日志记录相关的任务。
- en: Technique 5 Reading and writing to standard I/O
  id: totrans-267
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 技巧 5 读取和写入标准 I/O
- en: Whenever you need to get data into and out of a program, one useful technique
    is using the `process` object to read and write to standard I/O streams.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你需要将数据输入和输出到程序中时，一个有用的技巧是使用 `process` 对象来读取和写入标准 I/O 流。
- en: Problem
  id: totrans-269
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: You want to pipe data to and from a Node program.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 你想将数据从 Node 程序中导入导出。
- en: Solution
  id: totrans-271
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use `process.stdout` and `process.stdin`.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `process.stdout` 和 `process.stdin`。
- en: Discussion
  id: totrans-273
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论
- en: The `process.stdout` object is a writable stream to `stdout`. We’ll look at
    streams in more detail in [chapter 5](kindle_split_014.html#ch05), but for now
    you just need to know it’s part of the `process` object that every Node program
    has access to, and is helpful for displaying and receiving text input.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '`process.stdout` 对象是一个可写流，用于 `stdout`。我们将在第 5 章（kindle_split_014.html#ch05）中更详细地介绍流，但就目前而言，你需要知道它是每个
    Node 程序都可以访问的 `process` 对象的一部分，并且对于显示和接收文本输入非常有用。'
- en: The next listing shows how to pipe text from another command, process it, and
    output it again.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表显示了如何从另一个命令中读取文本，处理它，然后再输出。
- en: Listing 2.10\. Path variables
  id: totrans-276
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.10\. 路径变量
- en: '![](023fig01_alt.jpg)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![图片描述](023fig01_alt.jpg)'
- en: Every time a chunk of text is read from the input stream, it’ll be transformed
    with `toUpperCase()` and then written to the output stream. [Figure 2.2](#ch02fig02)
    shows how data flows from one operating system process, through your Node program,
    and then out through another program. In the terminal, these programs would be
    linked together with the pipe (`|`) symbol.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 每次从输入流中读取一段文本时，它都会通过 `toUpperCase()` 转换，然后写入输出流。![图 2.2](#ch02fig02) 显示了数据如何从一个操作系统进程流过你的
    Node 程序，然后流出到另一个程序。在终端中，这些程序将通过管道（`|`）符号连接起来。
- en: Figure 2.2\. Data flows in a simple program that uses `stdio`.
  id: totrans-279
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 2.2\. 使用 `stdio` 的简单程序中的数据流。
- en: '![](02fig02_alt.jpg)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![图片描述](02fig02_alt.jpg)'
- en: This *pipe*-based approach works well when dealing with input in Unix, because
    many other commands are designed to work this way. That brings a LEGO-like modularity
    to Node programs that facilitates reuse.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这种基于 *管道* 的方法在处理 Unix 中的输入时效果很好，因为许多其他命令都是设计成这样工作的。这给 Node 程序带来了类似乐高积木的模块化，从而促进了重用。
- en: If you just want to print out messages or errors, Node provides an easier API
    specifically tailored for this purpose through the `console` object. The next
    technique explains how to use it, and some of its less obvious features.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只想打印消息或错误，Node 通过 `console` 对象提供了一个专门为此目的而设计的更简单的 API。下一技术将解释如何使用它，以及一些不太明显的功能。
- en: Technique 6 Logging messages
  id: totrans-283
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 技巧 6 记录消息
- en: The easiest way to log information and errors from a program is by using the
    `console` object.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 从程序中记录信息和错误的最简单方法是通过使用 `console` 对象。
- en: Problem
  id: totrans-285
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: You want to log different types of messages to the console.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望将不同类型的消息记录到控制台。
- en: Solution
  id: totrans-287
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use `console.log`, `console.info`, `console.error`, and `console.warn`. Be sure
    to take advantage of the built-in formatting facilities provided by these methods.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `console.log`、`console.info`、`console.error` 和 `console.warn`。务必利用这些方法提供的内置格式化功能。
- en: Discussion
  id: totrans-289
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论
- en: The `console` object has several methods that can be used to output different
    types of messages. They’ll be written to the relevant output stream, which means
    you can pipe them accordingly on a Unix system.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '`console` 对象有几种方法可以用来输出不同类型的消息。它们将被写入相关的输出流，这意味着你可以在 Unix 系统上相应地管道化它们。'
- en: Although the basic usage is `console.log('message')`, more functionality is
    packed in. Variables can be interpolated, or simply appended alongside string
    literals. This makes it extremely easy to log messages that display the contents
    of primitive values or objects. The following listing demonstrates these features.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管基本用法是 `console.log('message')`，但其中还包含了更多功能。变量可以被插入，或者简单地与字符串字面量一起追加。这使得记录显示原始值或对象内容的消息变得极其容易。以下列表演示了这些功能。
- en: Listing 2.11\. Path variables
  id: totrans-292
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.11\. 路径变量
- en: '![](024fig01_alt.jpg)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![](024fig01_alt.jpg)'
- en: 'The output of [listing 2.11](#ch02ex11) looks like this:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 2.11](#ch02ex11) 的输出如下所示：'
- en: '![](024fig02.jpg)'
  id: totrans-295
  prefs: []
  type: TYPE_IMG
  zh: '![](024fig02.jpg)'
- en: When message strings are formatted, `util.format` is used. [Table 2.1](#ch02table01)
    shows the supported formatting placeholders.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 当消息字符串被格式化时，使用 `util.format`。[表 2.1](#ch02table01) 显示了支持的格式化占位符。
- en: Table 2.1\. Formatting placeholders
  id: totrans-297
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 2.1\. 格式化占位符
- en: '| Placeholder | Type | Example |'
  id: totrans-298
  prefs: []
  type: TYPE_TB
  zh: '| 占位符 | 类型 | 示例 |'
- en: '| --- | --- | --- |'
  id: totrans-299
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| %s | String | ''%s'', ''value'' |'
  id: totrans-300
  prefs: []
  type: TYPE_TB
  zh: '| %s | 字符串 | ''%s'', ''value'' |'
- en: '| %d | Number | ''%f'', 3.14 |'
  id: totrans-301
  prefs: []
  type: TYPE_TB
  zh: '| %d | 数字 | ''%f'', 3.14 |'
- en: '| %j | JSON | ''%j'', { name: ''alex'' } |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
  zh: '| %j | JSON | ''%j'', { name: ''alex'' } |'
- en: These formatting placeholders are convenient, but just being able to simply
    include objects in `console.log` messages without manually appending strings is
    a handy way to log messages.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 这些格式化占位符很方便，但仅仅能够简单地在 `console.log` 消息中包含对象，而不需要手动追加字符串，这也是记录消息的一个方便方法。
- en: The `info` and `warn` methods are synonyms for `log` and `error`. The difference
    between `log` and `error` is the output stream used. In [technique 5](#ch02lev2sec5),
    you saw how Node makes standard input and output streams available to all programs.
    It also exposes the standard error stream through `process.stderr`. The `console.error`
    method will write to this stream, rather than `process.stdout`. This means you
    can redirect a Node process’s `error` messages in the terminal or in a shell script.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '`info` 和 `warn` 方法是 `log` 和 `error` 的同义词。`log` 和 `error` 之间的区别在于使用的输出流。在 [技巧
    5](#ch02lev2sec5) 中，你看到了 Node 如何使标准输入和输出流对所有程序可用。它还通过 `process.stderr` 暴露标准错误流。`console.error`
    方法将写入此流，而不是 `process.stdout`。这意味着你可以在终端或 shell 脚本中重定向 Node 进程的 `error` 消息。'
- en: 'If you ran the previous listing with `2> error-file.log`, the error messages
    would be redirected to `error-file.log`. The other messages would be printed to
    the console as usual:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你以前面的列表使用 `2> error-file.log` 运行，错误消息将被重定向到 `error-file.log`。其他消息将像往常一样打印到控制台：
- en: '[PRE6]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `2` handle refers to the error stream; `1` is standard output. That means
    you could redirect errors to a log file without having to open files within your
    Node program, or use a specific logging module. Good old-fashioned shell redirection
    is good enough for many projects.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '`2` 处理器指向错误流；`1` 是标准输出。这意味着你可以将错误重定向到日志文件，而无需在 Node 程序中打开文件，或者使用特定的日志模块。传统的
    shell 重定向对于许多项目来说已经足够好了。'
- en: '|  |'
  id: totrans-308
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Standard streams**'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '**标准流**'
- en: 'Standard streams come in three flavors: stdin, stdout, and stderr. In Unix
    terminals, these are referred to with numbers. `0` is used for standard input,
    `1` is standard output, and `2` is standard error.'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 标准流有三种类型：stdin、stdout 和 stderr。在 Unix 终端中，这些通过数字来引用。`0` 用于标准输入，`1` 用于标准输出，`2`
    用于标准错误。
- en: 'The same applies to Windows: running a program from the command prompt and
    adding `2> errors-file.log` will send the error messages to `errors-file.log`,
    just like Unix.'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Windows 系统也是如此：从命令提示符运行程序并添加 `2> errors-file.log` 将会将错误信息发送到 `errors-file.log`，就像
    Unix 一样。
- en: '|  |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Stack traces
  id: totrans-313
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 堆栈跟踪
- en: Another feature of the `console` object is `console.trace()`. This method generates
    a stack trace at the current point of execution. The generated stack trace includes
    line numbers for the code that invokes asynchronous callbacks, which can help
    when reporting errors that would otherwise be difficult to track down. For example,
    a trace generated inside an event listener will show where the event was triggered
    from. [Technique 28](kindle_split_014.html#ch05lev2sec7) in [chapter 5](kindle_split_014.html#ch05)
    explores this in more detail.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '`console` 对象的另一个特性是 `console.trace()`。此方法在当前执行点生成堆栈跟踪。生成的堆栈跟踪包括调用异步回调的代码的行号，这有助于报告那些否则难以追踪的错误。例如，在事件监听器内部生成的跟踪将显示事件是从哪里触发的。[第
    5 章](kindle_split_014.html#ch05) 中的[技巧 28](kindle_split_014.html#ch05lev2sec7)
    详细探讨了这一点。'
- en: Another slightly more advanced use of `console` is its benchmarking feature.
    Continue reading for a detailed look.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '`console` 的另一个稍微高级一些的用法是其基准测试功能。继续阅读以详细了解。'
- en: Technique 7 Benchmarking a program
  id: totrans-316
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 技巧 7：基准测试程序
- en: Node makes it possible to benchmark programs without any additional tools.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: Node 使得无需任何额外工具即可进行程序基准测试。
- en: Problem
  id: totrans-318
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: You need to benchmark a slow operation.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要基准测试一个运行缓慢的操作。
- en: Solution
  id: totrans-320
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use `console.time()` and `console.timeEnd()`.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `console.time()` 和 `console.timeEnd()`。
- en: Discussion
  id: totrans-322
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论
- en: In your career as a Node programmer, there will come a time when you’re trying
    to determine why a particular operation is slow. Fortunately, the `console` object
    comes with some built-in benchmarking features.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在你作为 Node 程序员职业生涯中，你将会有这样的时刻：试图确定某个特定操作为何运行缓慢。幸运的是，`console` 对象自带一些内置的基准测试功能。
- en: Invoking `console.time('label')` records the current time in milliseconds, and
    then later calling `console.timeEnd('label')` displays the duration from that
    point. The time in milliseconds will be automatically printed alongside the label,
    so you don’t have to make a separate call to `console.log` to print a label.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `console.time('label')` 记录当前时间（以毫秒为单位），然后稍后调用 `console.timeEnd('label')`
    显示从该点开始的时间长度。时间（以毫秒为单位）将自动打印在标签旁边，因此您不需要单独调用 `console.log` 来打印标签。
- en: '[Listing 2.12](#ch02ex12) is a short program that accepts command-line arguments
    (see [technique 9](#ch02lev2sec9) for more on handling arguments), with benchmarking
    to see how fast the file input is read.'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 2.12](#ch02ex12) 是一个接受命令行参数的简短程序（有关处理参数的更多信息，请参阅[技巧 9](#ch02lev2sec9)），其中包含基准测试以查看文件输入读取的速度。'
- en: Listing 2.12\. Benchmarking a function
  id: totrans-326
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.12\. 基准测试一个函数
- en: '![](026fig01_alt.jpg)'
  id: totrans-327
  prefs: []
  type: TYPE_IMG
  zh: '![](026fig01_alt.jpg)'
- en: Using several interleaved calls to `console.time` with different labels allows
    multiple benchmarks to be performed, which is perfect for exploring the performance
    of complex, nested asynchronous programs.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 使用多个带有不同标签的 `console.time` 交错调用，可以执行多个基准测试，这对于探索复杂、嵌套的异步程序的性能非常完美。
- en: These functions calculate duration based on `Date.now()`, which gives accuracy
    in milliseconds. To get more accurate benchmarks, the third-party `benchmark`
    module ([https://npmjs.org/package/benchmark](https://npmjs.org/package/benchmark))
    can be used in conjunction with `microtime` ([https://npmjs.org/package/microtime](https://npmjs.org/package/microtime)).
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数基于 `Date.now()` 计算持续时间，提供毫秒级的精度。为了获得更精确的基准测试，可以使用第三方 `benchmark` 模块（[https://npmjs.org/package/benchmark](https://npmjs.org/package/benchmark)）与
    `microtime` 模块（[https://npmjs.org/package/microtime](https://npmjs.org/package/microtime)）一起使用。
- en: The `process` object is used for working with standard I/O streams, and used
    correctly, `console` handles many of the tasks that the uninitiated may tackle
    with third-party modules. In the next section we’ll further explore the `process`
    object to look at how it helps integrate with the wider operating system.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '`process` 对象用于处理标准 I/O 流，并且使用得当，`console` 可以处理许多初学者可能会用第三方模块解决的问题。在下一节中，我们将进一步探讨
    `process` 对象，看看它是如何帮助与更广泛的操作系统集成的。'
- en: 2.3\. Operating system and command-line integration
  id: totrans-331
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.3\. 操作系统和命令行集成
- en: The `process` object can be used to obtain information about the operating system,
    and also communicate with other processes using exit codes and signal listeners.
    This section contains some more-advanced techniques for using these features.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `process` 对象获取有关操作系统的信息，并使用退出代码和信号监听器与其他进程通信。本节包含一些更高级的技术，用于使用这些功能。
- en: Technique 8 Getting platform information
  id: totrans-333
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 技巧 8 获取平台信息
- en: Node has some built-in methods for querying operating system functionality.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 节点提供了一些内置方法用于查询操作系统功能。
- en: Problem
  id: totrans-335
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: You need to run platform-specific code based on the operating system or processor
    architecture.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要根据操作系统或处理器架构运行特定平台的代码。
- en: Solution
  id: totrans-337
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use the `process.arch` and `process.platform` properties.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `process.arch` 和 `process.platform` 属性。
- en: Discussion
  id: totrans-339
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论
- en: Node JavaScript is generally portable, so it’s unlikely that you’ll need to
    branch based on the operating system or process architecture. But you may want
    to tailor projects to take advantage of operating system–specific features, or
    simply collect statistics on what systems a script is executing on. Certain Windows-based
    modules that include bindings to binary libraries could switch between running
    a 32- or 64-bit version of a binary. The next listing shows how this could be
    supported.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: Node JavaScript 通常具有可移植性，因此您不太可能需要根据操作系统或进程架构进行分支。但您可能希望针对特定操作系统功能定制项目，或者简单地收集有关脚本在哪些系统上执行的统计数据。某些包含对二进制库绑定绑定的基于
    Windows 的模块可以在 32 位和 64 位版本的二进制之间切换。下一个列表显示了如何支持这一点。
- en: Listing 2.13\. Branching based on architecture
  id: totrans-341
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.13\. 基于架构的分支
- en: '[PRE7]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Other information from the system can also be gleaned through the `process`
    module. One such method is `process.memoryUsage()`—it returns an object with three
    properties that describe the process’s current memory usage:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `process` 模块也可以从系统中获取其他信息。其中一个方法是 `process.memoryUsage()`—它返回一个对象，包含三个属性，描述了进程当前的内存使用情况：
- en: '**`rss`** —The *resident set size*, which is the portion of the process’s memory
    that is held in RAM'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`rss`** —常驻集大小，即进程在 RAM 中持有的内存部分'
- en: '**`heapTotal`** —Available memory for dynamic allocations'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`heapTotal`** —动态分配可用内存'
- en: '**`heapUsed`** —Amount of heap used'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`heapUsed`** —已使用的堆内存量'
- en: The next technique explores handling command-line arguments in more detail.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个技术将更详细地探讨处理命令行参数。
- en: Technique 9 Passing command-line arguments
  id: totrans-348
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 技巧 9 传递命令行参数
- en: Node provides a simple API to command-line arguments that you can use to pass
    options to programs.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: Node 提供了一个简单的 API 用于命令行参数，您可以使用它将选项传递给程序。
- en: Problem
  id: totrans-350
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: You’re writing a program that needs to receive simple arguments from the command
    line.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 您正在编写一个需要从命令行接收简单参数的程序。
- en: Solution
  id: totrans-352
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use `process.argv`.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `process.argv`。
- en: Discussion
  id: totrans-354
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论
- en: The `process.argv` array allows you to check if any arguments were passed to
    your script. Because it’s an array, you can use it to see how many arguments were
    passed, if any. The first two arguments are `node` and the name of the script.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '`process.argv` 数组允许您检查是否向您的脚本传递了任何参数。因为它是一个数组，您可以使用它来查看传递了多少参数，如果有。前两个参数是 `node`
    和脚本的名称。'
- en: '[Listing 2.14](#ch02ex14) shows just one way of working with `process.argv`.
    This example loops over `process.argv` and then slices it to “parse” argument
    flags with options. You could run this script with `node arguments.js -r arguments.js`
    and it would print out its own source.'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 2.14](#ch02ex14) 展示了使用 `process.argv` 的一种方法。此示例遍历 `process.argv` 并将其切片以“解析”带有选项的参数标志。您可以使用
    `node arguments.js -r arguments.js` 运行此脚本，并且它会打印出其自身的源代码。'
- en: Listing 2.14\. Manipulating command-line arguments
  id: totrans-357
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.14\. 操作命令行参数
- en: '![](028fig01_alt.jpg)'
  id: totrans-358
  prefs: []
  type: TYPE_IMG
  zh: '![图片](028fig01_alt.jpg)'
- en: The `args` object ![](1.jpg) holds each switch that the script supports. Then
    `createReadStream` is used ![](2.jpg) to `pipe` the file to the standard output
    stream. Finally, the function referenced by the command-line switch in `args`
    is executed using `Function.prototype.apply` ![](3.jpg).
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '`args` 对象 ![图片](1.jpg) 包含脚本支持的每个开关。然后使用 `createReadStream` ![图片](2.jpg) 将文件
    `pipe` 到标准输出流。最后，使用 `Function.prototype.apply` ![图片](3.jpg) 执行 `args` 中命令行开关引用的函数。'
- en: 'Although this is a toy example, it illustrates how handy `process.argv` can
    be without relying on a third-party module. Since it’s a JavaScript `Array`, it’s
    extremely easy to work with: you can use methods like `map`, `forEach`, and `slice`
    to process arguments with little effort.'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这是一个玩具示例，但它说明了在不依赖第三方模块的情况下，`process.argv` 可以多么方便。由于它是一个 JavaScript `Array`，因此它非常容易处理：您可以使用
    `map`、`forEach` 和 `slice` 等方法轻松处理参数。
- en: '|  |'
  id: totrans-361
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Complex arguments**'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '**复杂参数**'
- en: 'For more complex programs, use an option parsing module. The two most popular
    are `optimist` ([https://npmjs.org/package/optimist](https://npmjs.org/package/optimist))
    and `commander` ([https://npmjs.org/package/commander](https://npmjs.org/package/commander)).
    `optimist` converts arguments into an `Object`, which makes them easier to manipulate.
    It also supports default values, automatic usage generation, and simple validation
    to ensure certain arguments have been provided. `commander` is slightly different:
    it uses an abstracted notion of a *program* that allows you to specify your program’s
    accepted arguments using a chainable API.'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更复杂的程序，请使用选项解析模块。最流行的两个是 `optimist` ([https://npmjs.org/package/optimist](https://npmjs.org/package/optimist))
    和 `commander` ([https://npmjs.org/package/commander](https://npmjs.org/package/commander))。`optimist`
    将参数转换为 `Object`，这使得它们更容易操作。它还支持默认值、自动使用生成和简单的验证，以确保已提供某些参数。`commander` 略有不同：它使用一个抽象的
    *程序* 概念，允许您使用链式 API 指定程序接受的参数。
- en: '|  |'
  id: totrans-364
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Good Unix programs handle arguments when needed, and they also exit by returning
    a suitable status code. The next technique presents how and when to use `process.exit`
    to signal the successful—or unsuccessful—completion of a program.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 良好的 Unix 程序在需要时处理参数，并且它们也会通过返回合适的状态码来退出。下一个技巧将展示如何以及何时使用 `process.exit` 来表示程序的完成成功或失败。
- en: Technique 10 Exiting a program
  id: totrans-366
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 技巧 10 退出程序
- en: Node allows you to specify an exit code when a program terminates.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: Node 允许您在程序终止时指定退出码。
- en: Problem
  id: totrans-368
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: Your Node program needs to exit with specific status codes.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 您的 Node 程序需要以特定的状态码退出。
- en: Solution
  id: totrans-370
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use `process.exit()`.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `process.exit()`。
- en: Discussion
  id: totrans-372
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论
- en: Exit status codes are significant in both Windows and Unix. Other programs will
    examine the exit status to determine whether a program ran correctly. This becomes
    more important when writing Node programs that take part in larger systems, and
    helps with monitoring and debugging later on.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 退出状态码在 Windows 和 Unix 中都具有重要意义。其他程序会检查退出状态以确定程序是否正确运行。当编写参与更大系统的 Node 程序时，这一点尤为重要，并且有助于后续的监控和调试。
- en: By default, a Node program returns a `0` exit status. This means the program
    ran and terminated correctly. Any non-zero status is considered an error. In Unix,
    this status code is generally accessed by using `$?` in a shell. The Windows equivalent
    is `%errorlevel%`.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Node 程序返回 `0` 退出状态。这意味着程序已正确运行并终止。任何非零状态都被视为错误。在 Unix 中，通常使用 `$?` 在 shell
    中访问此状态码。Windows 的等效项是 `%errorlevel%`。
- en: '[Listing 2.15](#ch02ex15) shows a modification to [listing 2.14](#ch02ex14)
    that causes the program to exit cleanly with a relevant status code when no filename
    is specified with the `-r` option.'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 2.15](#ch02ex15) 展示了对 [列表 2.14](#ch02ex14) 的修改，当未指定 `-r` 选项的文件名时，程序会以相关的状态码干净地退出。'
- en: Listing 2.15\. Returning meaningful exit status codes
  id: totrans-376
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.15\. 返回有意义的退出状态码
- en: '![](029fig01_alt.jpg)'
  id: totrans-377
  prefs: []
  type: TYPE_IMG
  zh: '![](029fig01_alt.jpg)'
- en: After running [listing 2.15](#ch02ex15), typing `echo $?` in a Unix terminal
    will display `1`. Also note that `console.error` ![](1.jpg) is used to output
    an error message. This will cause the message to be written to `process.stderr`,
    which allows users of the script to easily pipe error messages somewhere.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 [列表 2.15](#ch02ex15) 后，在 Unix 终端中键入 `echo $?` 将显示 `1`。请注意，`console.error`
    ![](1.jpg) 用于输出错误消息。这将导致消息被写入 `process.stderr`，这使得脚本的用户可以轻松地将错误消息管道到某个地方。
- en: '|  |'
  id: totrans-379
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Exit codes with special meanings**'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '**具有特殊含义的退出码**'
- en: In the Advanced Bash-Scripting Guide ([http://tldp.org/LDP/abs/html/index.html](http://tldp.org/LDP/abs/html/index.html)),
    a page is dedicated to status codes called Exit Codes With Special Meanings ([http://tldp.org/LDP/abs/html/exitcodes.html](http://tldp.org/LDP/abs/html/exitcodes.html)).
    This attempts to generalize error codes, although there’s no standard list of
    status codes for scripting languages, outside of non-zero indicating an error
    occurred.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 在《高级 Bash 脚本指南》（[http://tldp.org/LDP/abs/html/index.html](http://tldp.org/LDP/abs/html/index.html)）中，有一个专门讨论带有特殊含义的退出状态码的页面，称为带有特殊含义的退出状态码（[http://tldp.org/LDP/abs/html/exitcodes.html](http://tldp.org/LDP/abs/html/exitcodes.html)）。这试图概括错误代码，尽管在脚本语言之外没有标准的状态码列表，非零表示发生了错误。
- en: '|  |'
  id: totrans-382
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Because many Node programs are asynchronous, there are times when you may need
    to specifically call `process.exit()` or close down an I/O connection to cause
    the Node process to end gracefully. For example, scripts that use the Mongoose
    database library ([http://mongoosejs.com/](http://mongoosejs.com/)) need to call
    `mongoose.connection.close()` before the Node process will be able to exit.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 由于许多 Node 程序是异步的，有时您可能需要显式调用`process.exit()`或关闭 I/O 连接，以使 Node 进程优雅地结束。例如，使用
    Mongoose 数据库库（[http://mongoosejs.com/](http://mongoosejs.com/)）的脚本需要在 Node 进程能够退出之前调用`mongoose.connection.close()`。
- en: You may need to track the number of pending asynchronous operations in order
    to determine when it’s safe to call `mongoose.connection.close()`, or the equivalent
    for another database module. Most people do this using a simple counter variable,
    incrementing it just before asynchronous operations start, and then decrementing
    it once their callbacks fire. Once it reaches `0`, it’ll be safe to close the
    connection.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能需要跟踪挂起的异步操作的数量，以确定何时调用`mongoose.connection.close()`或另一个数据库模块的等效操作是安全的。大多数人使用一个简单的计数器变量来做这件事，在异步操作开始之前增加它，然后在它们的回调触发后减少它。一旦它达到`0`，关闭连接就是安全的。
- en: Another important facet to developing correct programs is creating signal handlers.
    Continue reading to learn how Node implements signal handlers and when to use
    them.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 开发正确程序的一个重要方面是创建信号处理程序。继续阅读以了解 Node 如何实现信号处理程序以及何时使用它们。
- en: Technique 11 Responding to signals
  id: totrans-386
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 技巧 11 响应信号
- en: Node programs can respond to signals sent by other processes.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 节点程序可以响应其他进程发送的信号。
- en: Problem
  id: totrans-388
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: You need to respond to signals sent by other processes.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要响应其他进程发送的信号。
- en: Solution
  id: totrans-390
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use the signal events that are sent to the `process` object.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 使用发送到`process`对象的信号事件。
- en: Discussion
  id: totrans-392
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论
- en: Most modern operating systems use signals as a way of sending a simple message
    to a program. Signal handlers are typically used in programs that run in the background,
    because it might be the only way of communicating with them. There are other cases
    where they can be useful in the kinds of programs you’re most likely write—consider
    a web application that cleanly closes its connection to a database when it receives
    `SIGTERM`.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数现代操作系统使用信号作为向程序发送简单消息的一种方式。信号处理程序通常用于在后台运行的程序中，因为这可能是在它们之间通信的唯一方式。在其他情况下，它们也可以在您最可能编写的程序类型中很有用——考虑一个在接收到`SIGTERM`时干净地关闭其数据库连接的
    Web 应用程序。
- en: The `process` object is an `EventEmitter`, which means you can add event listeners
    to it. Adding a listener for a POSIX signal name should work—on a Unix system,
    you can type `man sigaction` to see the names of all of the signals.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '`process`对象是一个`EventEmitter`，这意味着您可以向其添加事件监听器。为 POSIX 信号名称添加监听器应该可以工作——在 Unix
    系统上，您可以通过输入`man sigaction`来查看所有信号的名字。'
- en: Signal listeners enable you to cater to the expected behavior of Unix programs.
    For example, many servers and daemons will reload configuration files when they
    receive a `SIGHUP` signal. The next listing shows how to attach a listener to
    `SIGHUP`.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 信号监听器使您能够满足 Unix 程序的预期行为。例如，许多服务器和守护进程在接收到`SIGHUP`信号时会重新加载配置文件。下一个列表显示了如何将监听器附加到`SIGHUP`。
- en: Listing 2.16\. Adding a listener for a POSIX signal
  id: totrans-396
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.16\. 为 POSIX 信号添加监听器
- en: '![](031fig01_alt.jpg)'
  id: totrans-397
  prefs: []
  type: TYPE_IMG
  zh: '![](031fig01_alt.jpg)'
- en: Before doing anything with standard input, `resume` should be called ![](1.jpg)
    to prevent Node from exiting straight away. Next, a listener is added to the `SIGHUP`
    event on the `process` object ![](2.jpg). Finally, the PID is displayed for the
    current process ![](3.jpg).
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 在对标准输入进行任何操作之前，应该调用`resume`以防止 Node 立即退出。接下来，在`process`对象上添加对`SIGHUP`事件的监听器！[](2.jpg)。最后，显示当前进程的
    PID！[](3.jpg)。
- en: Once the program in [listing 2.16](#ch02ex16) is running, it’ll display the
    process’s PID. The PID can be used with the `kill` command to send the process
    signals. For example, `kill-HUP 94962` will send the `HUP` signal to PID `94962`.
    If you send another signal, or just type `kill 94962`, then the process will exit.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦[代码清单2.16](#ch02ex16)中的程序开始运行，它将显示进程的PID。可以使用`kill`命令与PID一起发送进程信号。例如，`kill-HUP
    94962`将向PID `94962`发送`HUP`信号。如果你发送另一个信号，或者只输入`kill 94962`，那么进程将退出。
- en: It’s important to realize that signals can be sent from any process to any other,
    permissions notwithstanding. Your Node process can send another process a signal
    by using `process.kill(pid, [signal])`—in this case `kill` doesn’t mean the process
    will be “killed,” but simply sent a given signal. The method is named `kill` after
    the C standard library function in `signal.h`.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要意识到，信号可以从任何进程发送到任何其他进程，无论权限如何。你的Node进程可以通过使用`process.kill(pid, [signal])`向另一个进程发送信号——在这种情况下，“kill”并不意味着进程将被“杀死”，而只是发送了一个特定的信号。这个方法是以C标准库中`signal.h`函数的名称命名的。
- en: '[Figure 2.3](#ch02fig03) shows a broad overview of how signals originate from
    any process in an operating system and can be received by your Node processes.'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2.3](#ch02fig03)展示了信号如何在操作系统中从任何进程产生，并且可以被你的Node进程接收。'
- en: Figure 2.3\. Signals originate from a process, and are handled with an event
    listener.
  id: totrans-402
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.3. 信号从进程产生，并通过事件监听器处理。
- en: '![](02fig03_alt.jpg)'
  id: totrans-403
  prefs: []
  type: TYPE_IMG
  zh: '![图片描述](02fig03_alt.jpg)'
- en: You don’t have to respond to signals in your Node programs, but if you’re writing
    a long-running network server, then signal listeners can be extremely useful.
    Supporting signals like `SIGHUP` will make your program fit into existing systems
    more naturally.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 你不必在Node程序中响应信号，但如果你正在编写一个长时间运行的网络服务器，那么信号监听器可以非常有用。支持像`SIGHUP`这样的信号将使你的程序更自然地融入现有系统。
- en: A large part of Node’s appeal is its asynchronous APIs and non-blocking I/O
    features. Sometimes it’s desirable to fake this behavior—perhaps in automated
    tests—or simply to just force code to execute later on. In the next section we’ll
    look at how Node implements JavaScript timers, which support this type of functionality.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: Node的吸引力很大一部分在于其异步API和非阻塞I/O特性。有时可能需要模拟这种行为——比如在自动化测试中——或者简单地强制代码稍后执行。在下一节中，我们将探讨Node如何实现JavaScript定时器，这些定时器支持此类功能。
- en: 2.4\. Delaying execution with timers
  id: totrans-406
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.4. 使用定时器延迟执行
- en: Node implements the JavaScript timer functions `setTimeout`, `setInterval`,
    `clear-Timeout`, and `clearInterval`. These functions are globally available.
    Although they’re part of JavaScript as defined by Mozilla, they’re not defined
    in the ECMAScript standard. Instead, timers are part of the HTML DOM Level 0 specification.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: Node实现了JavaScript定时器函数`setTimeout`、`setInterval`、`clearTimeout`和`clearInterval`。这些函数是全局可用的。尽管它们是Mozilla定义的JavaScript的一部分，但它们并未在ECMAScript标准中定义。相反，定时器是HTML
    DOM Level 0规范的一部分。
- en: Technique 12 Executing functions after a delay with setTimeout
  id: totrans-408
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 技巧12 使用`setTimeout`延迟执行函数
- en: It’s possible to run code once after a delay using Node’s `setTimeout` global
    method.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Node的`setTimeout`全局方法可以在延迟后运行代码一次。
- en: Problem
  id: totrans-410
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: You want to execute a function after a delay.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 你想在延迟后执行一个函数。
- en: Solution
  id: totrans-412
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use `setTimeout`, and use `Function.prototype.bind` if necessary.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`setTimeout`，并在必要时使用`Function.prototype.bind`。
- en: Discussion
  id: totrans-414
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论
- en: 'The most basic usage of `setTimeout` is simple: pass it a function to execute
    and a delay in milliseconds:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '`setTimeout`最基本的使用很简单：传递一个要执行的函数和延迟（以毫秒为单位）：'
- en: '[PRE8]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This seems simple and contrived, but you’ll see it used most commonly in tests
    where asynchronous APIs are being tested and a small delay is necessary to simulate
    real-world behavior. Node supports JavaScript timers for just such cases.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来很简单且人为，但你会在测试中看到它被最常使用，在这些测试中，正在测试异步API，并且需要一个小延迟来模拟现实世界的行为。Node支持JavaScript定时器，正是为了应对这种情况。
- en: Methods can also easily be passed to `setTimeout` by using `Function.prototype
    .bind`. This can be used to bind the first argument to `this`, or more often the
    object that the method belongs to. The following listing shows how `bind` can
    be used with a simple object.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过使用`Function.prototype.bind`轻松地将方法传递给`setTimeout`。这可以用来绑定第一个参数到`this`，或者更常见的是，绑定方法所属的对象。以下列表展示了如何使用`bind`与一个简单的对象结合使用。
- en: Listing 2.17\. Combining `setTimeout` with `Function.prototype.bind`
  id: totrans-419
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 代码清单2.17. 将`setTimeout`与`Function.prototype.bind`结合使用
- en: '![](033fig01_alt.jpg)'
  id: totrans-420
  prefs: []
  type: TYPE_IMG
  zh: '![图片描述](033fig01_alt.jpg)'
- en: Binding ensures that the code inside the method can access the object’s internal
    properties. Otherwise, `setTimeout` would cause the method to run with `this`
    bound to the global object. Binding a method can be more readable than creating
    a new anonymous function.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定确保方法内部的代码可以访问对象的内部属性。否则，`setTimeout` 将导致方法以 `this` 绑定到全局对象的方式运行。绑定方法可能比创建新的匿名函数更易于阅读。
- en: To cancel scheduled functions, retain a reference to the `timeoutId` returned
    by `setTimeout` and then call `clearTimeout(timeoutId)`![](1.jpg). The next listing
    demonstrates `clearTimeout`.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 要取消计划中的函数，保留由 `setTimeout` 返回的 `timeoutId` 引用，然后调用 `clearTimeout(timeoutId)`![1.jpg]。下面的列表展示了
    `clearTimeout`。
- en: Listing 2.18\. Using `clearTimeout` to prevent scheduled functions
  id: totrans-423
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.18\. 使用 `clearTimeout` 来防止计划中的函数
- en: '![](033fig02_alt.jpg)'
  id: totrans-424
  prefs: []
  type: TYPE_IMG
  zh: '![033fig02_alt.jpg]'
- en: '|  |'
  id: totrans-425
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**When exactly does the callback run?**'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: '**回调函数何时运行？**'
- en: Although you can specify when a callback runs in milliseconds, Node isn’t quite
    *that* precise. It can guarantee that the callback will run *after* the specified
    time, but it may be slightly late.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你可以指定回调在毫秒级的时间运行，但 Node 并不完全 *那么* 精确。它可以保证回调将在指定时间后运行，但可能会稍微晚一些。
- en: '|  |'
  id: totrans-428
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: As well as delaying execution, you can also call functions periodically. The
    next technique discusses how to achieve this by using `setInterval`.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 除了延迟执行外，你还可以定期调用函数。下一技术将讨论如何通过使用 `setInterval` 来实现这一点。
- en: Technique 13 Running callbacks periodically with timers
  id: totrans-430
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 技术第 13 条：使用计时器定期运行回调
- en: Node can also run callbacks at regular intervals using `setInterval`, which
    works in a fashion similar to `setTimeout`.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: Node 也可以使用 `setInterval` 定期运行回调，其工作方式与 `setTimeout` 类似。
- en: Problem
  id: totrans-432
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: You want to run a callback at a regular interval.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要以固定的时间间隔运行一个回调函数。
- en: Solution
  id: totrans-434
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use `setInterval`, and `clearInterval` to stop the timer.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `setInterval` 和 `clearInterval` 来停止计时器。
- en: Discussion
  id: totrans-436
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论
- en: The `setInterval` method has been around for years in browsers, and it behaves
    in Node much like the client-side counterparts. The callback will be executed
    on or just after the specified delay, and will run in the event loop just after
    I/O (and any calls to `setImmediate`, as detailed in [technique 14](#ch02lev2sec14)).
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: '`setInterval` 方法在浏览器中已经存在多年，在 Node 中与客户端类似。回调将在指定的延迟后或稍后执行，并在 I/O 之后的事件循环中运行（以及任何对
    `setImmediate` 的调用，如第 14 技术所述[技术 14](#ch02lev2sec14)）。'
- en: The next listing shows how to combine `setInterval` with `setTimeout` to schedule
    two functions to execute in a sequence.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表展示了如何将 `setInterval` 与 `setTimeout` 结合起来，以按顺序调度两个函数执行。
- en: Listing 2.19\. Using `setInterval` and `setTimeout` together
  id: totrans-439
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.19\. 使用 `setInterval` 和 `setTimeout` 结合
- en: '![](034fig01.jpg)'
  id: totrans-440
  prefs: []
  type: TYPE_IMG
  zh: '![034fig01.jpg]'
- en: The `setInterval` method itself returns a reference to the timer, which can
    be stopped by calling `clearInterval` and passing the reference. [Listing 2.19](#ch02ex19)
    uses a second call to `setTimeout` ![](1.jpg) to trigger a second interval timer
    that runs 500 milliseconds after the first.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: '`setInterval` 方法本身返回计时器的引用，可以通过调用 `clearInterval` 并传递引用来停止计时器。[列表 2.19](#ch02ex19)
    使用第二次调用 `setTimeout` ![1.jpg] 来触发一个在第一个计时器之后 500 毫秒运行的第二个间隔计时器。'
- en: Because `setInterval` prevents a program from exiting, there are cases where
    you might want to exit a program if it isn’t doing anything else. For example,
    let’s say you’re running a program that should exit when a complex operation has
    finished, and you’d like to monitor it at regular intervals using `setInterval`.
    Once the complex operation has finished, you don’t want to monitor it any more.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `setInterval` 阻止程序退出，在某些情况下，你可能希望在程序没有做其他事情时退出程序。例如，假设你正在运行一个程序，该程序应该在复杂操作完成后退出，并且你希望使用
    `setInterval` 定期监控它。一旦复杂操作完成，你就不想再监控它了。
- en: Rather than calling `clearInterval`, Node 0.10 allows you to call `timerRef
    .unref()` at any time before the complex operation has finished. This means you
    can use `setTimeout` or `setInterval` with operations that don’t signal their
    completion.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是调用 `clearInterval`，Node 0.10 允许你在复杂操作完成之前任何时候调用 `timerRef.unref()`。这意味着你可以使用
    `setTimeout` 或 `setInterval` 来执行不发出完成信号的操作。
- en: '[Listing 2.20](#ch02ex20) uses `setTimeout` to simulate a long-running operation
    that will keep the program running while the timer displays the process’s memory
    usage. Once the timeout’s delay has been reached, the program will exit *without*
    calling `clearTimeout`.'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 2.20](#ch02ex20) 使用 `setTimeout` 来模拟一个长时间运行的操作，该操作将在计时器显示进程内存使用情况时保持程序运行。一旦达到超时延迟，程序将退出
    *而不* 调用 `clearTimeout`。'
- en: Listing 2.20\. Keeping a timer alive until the program cleanly exits
  id: totrans-445
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.20\. 保持计时器活动直到程序干净退出
- en: '![](035fig01_alt.jpg)'
  id: totrans-446
  prefs: []
  type: TYPE_IMG
  zh: '![图片](035fig01_alt.jpg)'
- en: This is extremely useful in situations where there isn’t a good place to call
    `clearInterval`.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有合适的地方调用 `clearInterval` 的情况下，这非常有用。
- en: Once you’ve mastered timers, you’ll encounter cases where it’s useful to run
    a callback after the briefest possible delay. Using `setTimeout` with a delay
    of zero isn’t the optimum solution, even though it seems like the obvious strategy.
    In the next technique you’ll see how to do this correctly in Node by using `process.nextTick`.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你掌握了计时器，你将遇到需要以尽可能短的时间延迟运行回调的情况。使用延迟为零的 `setTimeout` 不是一个最佳解决方案，尽管这似乎是明显的策略。在下一个技巧中，你将看到如何在
    Node 中使用 `process.nextTick` 正确地做到这一点。
- en: Technique 14 Safely managing asynchronous APIs
  id: totrans-449
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 技巧 14 安全地管理异步 API
- en: 'Sometimes you want to delay an operation just slightly. In traditional JavaScript,
    it might be acceptable to use `setTimeout` with a small delay value. Node provides
    a more efficient solution: `process.nextTick`.'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你只想稍微延迟一个操作。在传统的 JavaScript 中，使用带有小延迟值的 `setTimeout` 可能是可以接受的。Node 提供了一个更有效的解决方案：`process.nextTick`。
- en: Problem
  id: totrans-451
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: You want to write a method that returns an instance of `EventEmitter` or accepts
    a callback that *sometimes* makes an asynchronous API call, but not in all cases.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 你想编写一个返回 `EventEmitter` 实例的方法或接受一个回调，该回调有时会调用异步 API，但并非在所有情况下。
- en: Solution
  id: totrans-453
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use `process.nextTick` to wrap the synchronous operation.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `process.nextTick` 包装同步操作。
- en: Discussion
  id: totrans-455
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论
- en: The `process.nextTick` method allows you to place a callback at the head of
    the next cycle of the run loop. That means it’s a way of *slightly* delaying something,
    and as a result it’s more efficient than just using `setTimeout` with a zero delay
    argument.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: '`process.nextTick` 方法允许你将回调放置在运行循环的下一个周期的开头。这意味着这是一种轻微延迟某种方法的方式，因此它比仅仅使用延迟为零的
    `setTimeout` 更有效率。'
- en: It can be difficult to visualize why this is useful, but consider the following
    example. [Listing 2.21](#ch02ex21) shows a function that returns an `EventEmitter`.
    The idea is to provide an event-oriented API, allowing users of the API to subscribe
    to events as needed, while being able to run asynchronous calls internally.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能很难想象为什么这很有用，但考虑以下示例。[列表 2.21](#ch02ex21) 展示了一个返回 `EventEmitter` 的函数。想法是提供一个以事件为中心的
    API，允许 API 的用户根据需要订阅事件，同时能够内部运行异步调用。
- en: Listing 2.21\. Incorrectly triggering asynchronous methods with events
  id: totrans-458
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.21\. 使用事件错误地触发异步方法
- en: '![](035fig02_alt.jpg)'
  id: totrans-459
  prefs: []
  type: TYPE_IMG
  zh: '![图片](035fig02_alt.jpg)'
- en: Running this example will fail to trigger the `success` listener ![](1.jpg)
    at the end of the example. Why is this the case? Well, the event is emitted before
    the listener has been subscribed. In most cases, events would be emitted inside
    callbacks for some asynchronous operation or another, but there are times when
    it makes sense to emit events early—perhaps in cases where arguments are validated
    and found to contain errors, so `error` can be emitted very quickly.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此示例将无法在示例末尾触发 `success` 监听器 ![图片](1.jpg)。为什么会出现这种情况？嗯，事件是在监听器订阅之前发出的。在大多数情况下，事件会在某些异步操作的回调内部发出，但有时提前发出事件是有意义的——例如，在验证参数并发现包含错误时，这样
    `error` 可以非常快速地发出。
- en: To correct this subtle flaw, any sections of code that emit events can be wrapped
    in `process.nextTick`. The following listing demonstrates this by using a function
    that returns an instance of `EventEmitter`, and then emits an event.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 为了纠正这个微妙的缺陷，任何发出事件的代码部分都可以用 `process.nextTick` 包装。以下列表通过使用返回 `EventEmitter`
    实例的函数，然后发出一个事件来演示这一点。
- en: Listing 2.22\. Triggering events inside `process.nextTick`
  id: totrans-462
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 2.22\. 在 `process.nextTick` 内部触发事件
- en: '![](036fig01.jpg)'
  id: totrans-463
  prefs: []
  type: TYPE_IMG
  zh: '![图片](036fig01.jpg)'
- en: Node’s documentation recommends that APIs should always be 100% asynchronous
    or synchronous. That means if you have a method that accepts a callback and *may*
    call it asynchronously, then you should wrap the synchronous case in `process.nextTick`
    so users can rely on the order of execution.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: Node 的文档建议 API 应始终是 100% 异步或同步。这意味着如果你有一个接受回调并可能异步调用它的方法，那么你应该在 `process.nextTick`
    中包装同步情况，这样用户就可以依赖执行顺序。
- en: '[Listing 2.23](#ch02ex23) uses an asynchronous call to read a file from the
    disk. Once it has read the file, it’ll keep a cached version in memory. Subsequent
    calls will return the cached version. When returning the cached version, `process.nextTick`
    is used so the API still behaves asynchronously. That makes the output in the
    terminal read in the expected order.'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表2.23](#ch02ex23)使用异步调用来从磁盘读取文件。一旦读取了文件，它会在内存中保留一个缓存版本。后续调用将返回缓存版本。在返回缓存版本时，使用`process.nextTick`以确保API仍然表现出异步行为。这使得在终端中的输出按照预期的顺序读取。'
- en: Listing 2.23\. Creating the illusion of an always asynchronous API
  id: totrans-466
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表2.23\. 创建始终异步API的错觉
- en: '![](037fig01_alt.jpg)'
  id: totrans-467
  prefs: []
  type: TYPE_IMG
  zh: '![](037fig01_alt.jpg)'
- en: In this example, a file is cached to memory by using `fs.readFile` to read it
    ![](1.jpg), and then return a copy of it ![](2.jpg) for every subsequent call.
    This is wrapped in a process that’s called multiple times ![](3.jpg) so you can
    compare the behavior of the non-blocking file system operation to `process.nextTick`.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，通过使用`fs.readFile`读取文件并将其缓存到内存中，然后为每个后续调用返回它的一个副本！[](1.jpg)，这是通过多次调用一个过程来实现的！[](3.jpg)，这样您就可以比较非阻塞文件系统操作与`process.nextTick`的行为。
- en: 'Visualizing the event loop: setImmediate and process.maxTickDepth'
  id: totrans-469
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 可视化事件循环：setImmediate和process.maxTickDepth
- en: The `setImmediate` and `clearImmediate` global functions accept a callback and
    optional arguments, and will run *after* any upcoming I/O events but *before*
    `setTimeout` and `setInterval`.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: '`setImmediate`和`clearImmediate`全局函数接受一个回调和可选参数，并且会在任何即将到来的I/O事件之后、`setTimeout`和`setInterval`之前运行。'
- en: Callbacks added this way are pushed onto a queue, and one callback will be executed
    per run loop. This is different from `process.nextTick`, which causes `process.maxTickDepth`
    callbacks to run per iteration of the run loop.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式添加的回调会被推送到队列中，并且每次运行循环只会执行一个回调。这与`process.nextTick`不同，后者会在运行循环的每次迭代中触发`process.maxTickDepth`个回调。
- en: The callbacks that have been passed with `process.nextTick` are usually run
    at the end of the current event loop. The number of callbacks that can be safely
    run is controlled by `process.maxTickDepth`, which is 1000 by default to allow
    I/O operations to continue to be handled.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`process.nextTick`传递的回调通常在当前事件循环的末尾运行。可以安全运行的回调数量由`process.maxTickDepth`控制，默认值为1000，以允许I/O操作继续处理。
- en: '[Figure 2.4](#ch02fig04) illustrates how each of the timer functions is positioned
    within a single iteration of the event loop.'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2.4](#ch02fig04)说明了每个定时函数在事件循环的单次迭代中的位置。'
- en: Figure 2.4\. Scheduling `nextTick` on the event loop
  id: totrans-474
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图2.4\. 在事件循环上调度`nextTick`
- en: '![](02fig04_alt.jpg)'
  id: totrans-475
  prefs: []
  type: TYPE_IMG
  zh: '![](02fig04_alt.jpg)'
- en: When you’re creating your own classes and methods that behave asynchronously,
    keep behavior consistent and predictable by using `process.nextTick`.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 当您创建自己的类和方法，并且它们的行为是异步的，请使用`process.nextTick`来保持行为的一致性和可预测性。
- en: Node’s implementation of the standard browser-based JavaScript timers fits in
    well with its event loop and non-blocking I/O. Although these functions are typically
    used for testing asynchronous code, a deep understanding of when `setTimeout`,
    `setImmediate`, and `process.nextTick` will be executed provides mastery over
    the event loop.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: Node对基于浏览器的JavaScript定时器的实现与它的事件循环和非阻塞I/O很好地结合在一起。尽管这些函数通常用于测试异步代码，但深入了解`setTimeout`、`setImmediate`和`process.nextTick`何时执行将提供对事件循环的掌握。
- en: 2.5\. Summary
  id: totrans-478
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.5\. 摘要
- en: In this chapter you’ve seen some of the surprisingly powerful things that are
    built into Node programs without going to the trouble of loading a module. The
    next time you want to group related modules together, you can create an index.js
    file, as described in [technique 3](#ch02lev2sec3). And if you need to read standard
    input, you can use the `process` object’s `stdin` property ([technique 5](#ch02lev2sec5)).
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您已经看到了一些内置在Node程序中而无需加载模块的令人惊讶的强大功能。下次您想要将相关的模块组合在一起时，您可以创建一个index.js文件，如[技术3](#ch02lev2sec3)所述。如果您需要读取标准输入，可以使用`process`对象的`stdin`属性（[技术5](#ch02lev2sec5)）。
- en: In addition to the `process` object, there’s also the often overlooked `console`
    object, which will help you debug and maintain programs ([technique 6](#ch02lev2sec6)).
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`process`对象之外，还有一个经常被忽视的`console`对象，它将帮助您调试和维护程序（[技术6](#ch02lev2sec6)）。
- en: In the next chapter you’ll learn about buffers. Buffers are great for working
    with binary data, which has traditionally been seen as a weakness of JavaScript.
    Buffers also underpin some of Node’s powerful features such as streams.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习有关缓冲区的内容。缓冲区非常适合处理二进制数据，这在传统上被视为JavaScript的弱点。缓冲区还支撑了Node的一些强大功能，如流。
- en: 'Chapter 3\. Buffers: Working with bits, bytes, and encodings'
  id: totrans-482
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第3章：缓冲区：处理位、字节和编码
- en: '*This chapter covers*'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Introduction to the Buffer data type
  id: totrans-484
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓冲数据类型的介绍
- en: Changing data encodings
  id: totrans-485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改变数据编码
- en: Converting binary files to JSON
  id: totrans-486
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将二进制文件转换为JSON
- en: Creating your own binary protocol
  id: totrans-487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自己的二进制协议
- en: JavaScript has historically had subpar binary support. Typically, parsing binary
    data would involve various tricks with strings to extract the data you want. Not
    having a good mechanism to work with raw memory in JavaScript was one of the problems
    Node core developers had to tackle when the project started getting traction.
    This was mostly for performance reasons. All of the raw memory accumulated in
    the `Buffer` data type.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript在历史上对二进制支持不佳。通常，解析二进制数据会涉及各种字符串技巧来提取所需的数据。没有良好的机制在JavaScript中处理原始内存是Node核心开发者在项目开始获得动力时必须解决的问题之一。这主要是出于性能原因。所有原始内存都累积在`Buffer`数据类型中。
- en: 'Buffers are raw allocations of the heap, exposed to JavaScript in an array-like
    manner. They’re exposed globally and therefore don’t need to be required, and
    can be thought of as just another JavaScript type (like `String` or `Number`):'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 缓冲区是堆的原始分配，以类似数组的方式暴露给JavaScript。它们是全局暴露的，因此不需要导入，可以将其视为另一种JavaScript类型（如`String`或`Number`）：
- en: '![](040fig01_alt.jpg)'
  id: totrans-490
  prefs: []
  type: TYPE_IMG
  zh: '![图片](040fig01_alt.jpg)'
- en: 'If you haven’t worked much with binary data, don’t worry; this chapter is designed
    to be friendly to newcomers but also equip those who are more familiar with the
    concept. We’ll cover simple and more advanced techniques:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有太多处理二进制数据的经验，不要担心；这一章旨在对新手友好，同时也为那些对概念更熟悉的人提供帮助。我们将涵盖简单和更高级的技术：
- en: Converting a `Buffer` to different encodings
  id: totrans-492
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`Buffer`转换为不同的编码
- en: Using the `Buffer` API to transform a binary file to JSON
  id: totrans-493
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Buffer` API将二进制文件转换为JSON
- en: Encoding and decoding your own binary protocol
  id: totrans-494
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编码和解码自己的二进制协议
- en: Let’s look first at changing encodings for buffers.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看如何更改缓冲区的编码。
- en: 3.1\. Changing data encodings
  id: totrans-496
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1. 改变数据编码
- en: 'If no encoding is given, file operations and many network operations will return
    data as a `Buffer`. Take this `fs.readFile` as an example:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有指定编码，文件操作和许多网络操作将返回`Buffer`数据。以下`fs.readFile`为例：
- en: '![](040fig02_alt.jpg)'
  id: totrans-498
  prefs: []
  type: TYPE_IMG
  zh: '![图片](040fig02_alt.jpg)'
- en: But many times you already know a file’s encoding, and it’s more useful to get
    the data as an encoded string instead. We’ll look at converting between `Buffer`s
    and other formats in this section.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 但很多时候你已经知道文件的编码，将数据作为编码字符串获取更有用。在本节中，我们将探讨在`Buffer`和其他格式之间进行转换。
- en: Technique 15 Converting buffers into other formats
  id: totrans-500
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 技巧15：将缓冲区转换为其他格式
- en: By default, Node’s core APIs return a buffer unless an encoding is specified.
    But buffers easily convert to other formats. In this next technique we’ll look
    at how to convert buffers.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Node的核心API返回一个缓冲区，除非指定了编码。但缓冲区可以轻松转换为其他格式。在接下来的技术中，我们将探讨如何转换缓冲区。
- en: Problem
  id: totrans-502
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: You want to turn a `Buffer` into plain text.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 你想将一个`Buffer`转换为纯文本。
- en: Solution
  id: totrans-504
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案
- en: The `Buffer` API allows you to convert a `Buffer` into a string value.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: '`Buffer` API允许你将`Buffer`转换为字符串值。'
- en: Discussion
  id: totrans-506
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论
- en: 'Let’s say we have a file that we know is just plain text. For our purposes
    we’ll call this file names.txt and it will include a person’s name on each line
    of the file:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个我们知道是纯文本的文件。为了我们的目的，我们将称这个文件为names.txt，并且它将在文件的每一行包含一个人的名字：
- en: '[PRE9]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If we were to load the file using a method from the file system (`fs`) API,
    we’d get a `Buffer` (`buf`) by default
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用文件系统（`fs`）API中的方法来加载文件，我们默认会得到一个`Buffer`（`buf`）
- en: '[PRE10]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'which, when logged out, is shown as a list of octets (using hex notation):'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 当输出日志时，它显示为一系列八位字节（使用十六进制表示）：
- en: '[PRE11]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This isn’t very useful since we know that the file is plain text. The `Buffer`
    class provides a method called `toString` to convert our data into a UTF-8 encoded
    string:'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不很有用，因为我们知道文件是纯文本。`Buffer`类提供了一个名为`toString`的方法，可以将我们的数据转换为UTF-8编码的字符串：
- en: '![](041fig01_alt.jpg)'
  id: totrans-514
  prefs: []
  type: TYPE_IMG
  zh: '![图片](041fig01_alt.jpg)'
- en: 'This will yield the same output as our original file:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生与我们的原始文件相同的输出：
- en: '[PRE12]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'But since we know that this data is only comprised of ASCII characters,^([[1](#ch03fn01)])
    we could also get a performance benefit by changing the encoding to ASCII rather
    than UTF-8\. To do this, we provide the type of encoding as the first argument
    for `toString`:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 但因为我们知道这些数据仅由 ASCII 字符组成，^([[1](#ch03fn01))) 我们也可以通过将编码更改为 ASCII 而不是 UTF-8 来获得性能上的好处。为此，我们将编码类型作为
    `toString` 的第一个参数提供：
- en: ¹ See [http://en.wikipedia.org/wiki/ASCII](http://en.wikipedia.org/wiki/ASCII).
  id: totrans-518
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹ 查看 [http://en.wikipedia.org/wiki/ASCII](http://en.wikipedia.org/wiki/ASCII)。
- en: '![](041fig02_alt.jpg)'
  id: totrans-519
  prefs: []
  type: TYPE_IMG
  zh: '![](041fig02_alt.jpg)'
- en: The `Buffer` API provides other encodings such as `utf16le`, `base64`, and `hex`,
    which you can learn more about by viewing the `Buffer` API online documentation.^([[2](#ch03fn02)])
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: '`Buffer` API 提供了其他编码，如 `utf16le`、`base64` 和 `hex`，你可以通过查看 `Buffer` API 在线文档了解更多信息.^([[2](#ch03fn02)])'
- en: ² See [http://nodejs.org/api/buffer.html](http://nodejs.org/api/buffer.html).
  id: totrans-521
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ² 查看 [http://nodejs.org/api/buffer.html](http://nodejs.org/api/buffer.html)。
- en: Technique 16 Changing string encodings using buffers
  id: totrans-522
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 技巧 16 使用缓冲区更改字符串编码
- en: In addition to converting buffers, you can also utilize buffers to turn one
    string encoding into another.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 除了转换缓冲区，你还可以利用缓冲区将一种字符串编码转换为另一种编码。
- en: Problem
  id: totrans-524
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: You want to change from one string encoding to another.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要将一个字符串编码转换为另一个编码。
- en: Solution
  id: totrans-526
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案
- en: The Node `Buffer` API provides a mechanism to change encodings.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: Node `Buffer` API 提供了一种更改编码的机制。
- en: Discussion
  id: totrans-528
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论
- en: 'Example 1: Creating a Basic authentication header'
  id: totrans-529
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 1：创建基本身份验证头
- en: 'Sometimes it’s helpful to build a string of data and then change its encoding.
    For example, if you wanted to request data from a server that uses Basic authentication,^([[3](#ch03fn03)])
    you’d need to send the username and password encoded using Base64:'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 有时构建一个数据字符串并更改其编码是有帮助的。例如，如果你想要从使用基本身份验证的服务器请求数据，^([[3](#ch03fn03)))，你需要使用 Base64
    编码发送用户名和密码：
- en: ³ See [http://en.wikipedia.org/wiki/Basic_access_authentication](http://en.wikipedia.org/wiki/Basic_access_authentication).
  id: totrans-531
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ³ 查看 [http://en.wikipedia.org/wiki/Basic_access_authentication](http://en.wikipedia.org/wiki/Basic_access_authentication)。
- en: '![](041fig03_alt.jpg)'
  id: totrans-532
  prefs: []
  type: TYPE_IMG
  zh: '![](041fig03_alt.jpg)'
- en: 'Before Base64 encoding is applied, Basic authentication credentials combine
    the username and password, separating the two using a `:` (colon). For our example,
    we’ll use `johnny` as the username and `c-bad` as the password:'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用 Base64 编码之前，基本身份验证凭据将用户名和密码组合在一起，使用冒号 `:` 分隔。在我们的例子中，我们将使用 `johnny` 作为用户名，`c-bad`
    作为密码：
- en: '![](042fig01_alt.jpg)'
  id: totrans-534
  prefs: []
  type: TYPE_IMG
  zh: '![](042fig01_alt.jpg)'
- en: 'Now we have to convert this into a `Buffer` in order to change it into another
    encoding. Buffers can be allocated by bytes, as we’ve seen already by simply passing
    in a number (for example, `new Buffer(255)`). They also can be allocated by passing
    in string data:'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们必须将其转换为 `Buffer`，以便将其转换为另一种编码。缓冲区可以通过字节分配，正如我们之前通过简单地传递一个数字（例如，`new Buffer(255)`）所看到的。它们也可以通过传递字符串数据来分配：
- en: '![](042fig02_alt.jpg)'
  id: totrans-536
  prefs: []
  type: TYPE_IMG
  zh: '![](042fig02_alt.jpg)'
- en: '|  |'
  id: totrans-537
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Specifying an encoding**'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: '**指定编码**'
- en: 'When strings are used to allocate a `Buffer`, they’re assumed to be UTF-8 strings,
    which is typically what you want. But you can specify the encoding of the incoming
    data using a second, optional, encoding argument:'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用字符串分配 `Buffer` 时，它们被认为是 UTF-8 字符串，这通常是您想要的。但您可以使用第二个可选的编码参数指定传入数据的编码：
- en: '[PRE13]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '|  |'
  id: totrans-541
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Now that we have our data as a `Buffer`, we can turn it back into a Base64-encoded
    string by using `toString(''base64'')`:'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将数据作为 `Buffer`，我们可以通过使用 `toString('base64')` 将其转换回 Base64 编码的字符串：
- en: '![](042fig03_alt.jpg)'
  id: totrans-543
  prefs: []
  type: TYPE_IMG
  zh: '![](042fig03_alt.jpg)'
- en: 'This process can be compacted as well, since instance methods can be called
    on the returned `Buffer` instance right away and the `new` keyword can be omitted:'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程也可以被压缩，因为可以直接在返回的 `Buffer` 实例上调用实例方法，并且可以省略 `new` 关键字：
- en: '[PRE14]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Example 2: Working with data URIs'
  id: totrans-546
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 2：处理数据 URI
- en: 'Data URIs^([[4](#ch03fn04)]) are another example of when using the `Buffer`
    API can be helpful. Data URIs allow a resource to be embedded inline on a web
    page using the following scheme:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 数据 URI^([[4](#ch03fn04)]) 是使用 `Buffer` API 有帮助的另一个例子。数据 URI 允许资源使用以下方案内联嵌入到网页中：
- en: ⁴ See [http://en.wikipedia.org/wiki/Data_URI_scheme](http://en.wikipedia.org/wiki/Data_URI_scheme).
  id: totrans-548
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁴ 查看 [http://en.wikipedia.org/wiki/Data_URI_scheme](http://en.wikipedia.org/wiki/Data_URI_scheme)。
- en: '[PRE15]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'For example, this PNG image of a monkey can be represented as a data URI:'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这张猴子的 PNG 图像可以表示为一个数据 URI：
- en: '[PRE16]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: And when read in the browser, the data URI will display our primate as shown
    in [figure 3.1](#ch03fig01).
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 当在浏览器中读取时，数据 URI 将显示如图 3.1 所示的我们的灵长类动物。
- en: Figure 3.1\. Data URI read in a browser displays the monkey as an image
  id: totrans-553
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.1\. 浏览器中读取的数据URI显示猴子图像
- en: '![](03fig01.jpg)'
  id: totrans-554
  prefs: []
  type: TYPE_IMG
  zh: '![图片](03fig01.jpg)'
- en: 'Let’s look at how we can create a data URI using the `Buffer` API. In our primate
    example, we were using a PNG image that has the MIME type of `image/png`:'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用`Buffer` API创建数据URI。在我们的灵长类例子中，我们使用了一个MIME类型为`image/png`的PNG图像：
- en: '[PRE17]'
  id: totrans-556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Binary files can be represented in data URIs using Base64 encoding, so let’s
    set up a variable for that:'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制文件可以使用Base64编码表示，所以让我们为这个设置一个变量：
- en: '[PRE18]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'With our MIME type and encoding, we can construct the start of our data URI:'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们的MIME类型和编码，我们可以构建数据URI的开始部分：
- en: '[PRE19]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We need to add the actual data next. We can use `fs.readFileSync` to read in
    our data synchronously and return the data inline. `fs.readFileSync` will return
    a `Buffer`, so we can then convert that to a Base64 string:'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要添加实际的数据。我们可以使用`fs.readFileSync`来同步读取我们的数据并返回内联数据。`fs.readFileSync`将返回一个`Buffer`，然后我们可以将其转换为Base64字符串：
- en: '[PRE20]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let’s put this all together and make a program that will output our data URI:'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把所有这些放在一起，编写一个输出数据URI的程序：
- en: '![](043fig01_alt.jpg)'
  id: totrans-564
  prefs: []
  type: TYPE_IMG
  zh: '![图片](043fig01_alt.jpg)'
- en: The output of this program will be
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序的输出将是
- en: '[PRE21]'
  id: totrans-566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Let’s flip the scenario around. What if you have a data URI but you want to
    write it out to an actual file? Again, we’ll work with our monkey example. First,
    we `split` the array to grab only the data:^([[5](#ch03fn05)])
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们改变一下场景。如果你有一个数据URI但想将其写入实际文件，我们会再次使用我们的猴子例子。首先，我们`split`数组以仅获取数据：^([[5](#ch03fn05)])
- en: ⁵ This is not prescriptive for all data URIs, as commas could appear elsewhere.
  id: totrans-568
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁵ 这并不是对所有数据URI都有规定性的，因为逗号可能出现在其他地方。
- en: '[PRE22]'
  id: totrans-569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We can then create a `Buffer` using our `data` string and specifying the encoding:'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用我们的`data`字符串并指定编码来创建一个`Buffer`：
- en: '[PRE23]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Next, we use `fs.writeFileSync` to write this synchronously to disk, giving
    it a file name and the `Buffer`:'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用`fs.writeFileSync`将此同步写入磁盘，指定文件名和`Buffer`：
- en: '[PRE24]'
  id: totrans-573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Putting this example all together looks like this:'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 将这个例子全部放在一起看起来是这样的：
- en: '![](043fig02_alt.jpg)'
  id: totrans-575
  prefs: []
  type: TYPE_IMG
  zh: '![图片](043fig02_alt.jpg)'
- en: When opened in our default image viewer, this gives us our monkey, as shown
    in [figure 3.2](#ch03fig02).
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的默认图像查看器中打开，这将给我们猴子，如图[图3.2](#ch03fig02)所示。
- en: Figure 3.2\. Generated secondmonkey.png file from a data URI
  id: totrans-577
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.2\. 从数据URI生成的secondmonkey.png文件
- en: '![](03fig02.jpg)'
  id: totrans-578
  prefs: []
  type: TYPE_IMG
  zh: '![图片](03fig02.jpg)'
- en: Most of the time, when you deal with `Buffer` objects in Node, it will be to
    convert them to other formats, and sometimes you’ll change encodings. But you
    may find yourself having to deal with a binary file format, and the `Buffer` API—which
    we’ll look at next—provides a rich set of tools to work with that as well.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，当你处理Node中的`Buffer`对象时，你会将其转换为其他格式，有时你会更改编码。但你也可能发现自己必须处理二进制文件格式，而`Buffer`
    API（我们将在下一节中探讨）提供了一套丰富的工具来处理这种格式。
- en: 3.2\. Converting binary files to JSON
  id: totrans-580
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2\. 将二进制文件转换为JSON
- en: Working with binary data is kind of like solving a puzzle. You’re given clues
    by reading a specification of what the data means and then you have to go out
    and turn that data into something usable in your application.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 与二进制数据打交道有点像解谜。通过阅读数据含义的规范来获取线索，然后你必须外出将那些数据转换成你应用中可用的东西。
- en: Technique 17 Using buffers to convert raw data
  id: totrans-582
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 技巧17 使用缓冲区转换原始数据
- en: What if you could utilize a binary format to do something useful in your Node
    program? In this technique we’ll cover, in depth, working with binary data to
    convert a common file format into JSON.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你能利用二进制格式在Node程序中做些有用的事情会怎样？在本技巧中，我们将深入探讨如何使用二进制数据将常见的文件格式转换为JSON。
- en: Problem
  id: totrans-584
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: You want to convert a binary file into a more usable format.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 你想将二进制文件转换为更易用的格式。
- en: Solution
  id: totrans-586
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案
- en: The Node API extends JavaScript with a `Buffer` class, exposing an API for raw
    binary data access and tools for dealing more easily with binary data.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: Node API通过`Buffer`类扩展了JavaScript，提供了一个用于原始二进制数据访问的API以及处理二进制数据的工具。
- en: Discussion
  id: totrans-588
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论
- en: For the purposes of our example, namely, file conversion, you can think of the
    process in terms of [figure 3.3](#ch03fig03).
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 为了我们示例的目的，即文件转换，你可以将这个过程视为[图3.3](#ch03fig03)。
- en: Figure 3.3\. The transformation of binary data into a more usable/programmable
    format
  id: totrans-590
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.3\. 将二进制数据转换为更易用/可编程的格式
- en: '![](03fig03_alt.jpg)'
  id: totrans-591
  prefs: []
  type: TYPE_IMG
  zh: '![图片](03fig03_alt.jpg)'
- en: Binary data is read, processed, and written out in a more usable format using
    the binary specification as a guide and the binary API as the mechanism for accomplishing
    the transformation. This is not the only use of binary data. For example, you
    could do processing on a binary protocol to pass messages back and forth and the
    diagram would look different.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 使用二进制规范作为指南和二进制 API 作为实现转换的机制，以更可用的格式读取、处理和写入二进制数据。这并不是二进制数据的唯一用途。例如，你可以对二进制协议进行处理，以传递消息，图表将有所不同。
- en: For our technique, the binary file format we’ll work with is DBase 5.0 (.dbf).
    That format may sound obscure, but (to put it into context) it was a popular database
    format that’s still heavily in use for attribution of geospatial data. You could
    think of it as a simplified Excel spreadsheet. The sample we’ll work with is located
    at buffers/world.dbf.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的技术，我们将要处理的二进制文件格式是 DBase 5.0 (.dbf)。这种格式可能听起来有些陌生，但（为了将其置于上下文中）它曾经是一种流行的数据库格式，现在仍然被广泛用于地理空间数据的归属。你可以将其视为一个简化的
    Excel 电子表格。我们将要使用的样本位于 buffers/world.dbf。
- en: The file contains geospatial information for the countries of the world. Unfortunately,
    if you were to open it in your text editor, it wouldn’t be very useful.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件包含世界各国的地理空间信息。不幸的是，如果你在文本编辑器中打开它，它将不会很有用。
- en: '|  |'
  id: totrans-595
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Why are we covering in depth a binary format that I may never use?
  id: totrans-596
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 为什么我们要深入探讨一个我可能永远不会使用的二进制格式？
- en: Although we could’ve picked a number of binary formats, DBase 5.0 is one that
    will teach you a lot of different ways of approaching problems with reading binary
    files that are common to many other formats. In addition, binary formats are unfamiliar
    to many coming from a web development background, so we’re taking some time to
    focus on reading binary specifications. Please feel free to skim if you’re already
    familiar.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们可以选择许多二进制格式，但 DBase 5.0 是一种可以教会你许多不同方法来处理读取二进制文件的问题的格式，这些问题在许多其他格式中都很常见。此外，对于来自网络开发背景的人来说，二进制格式可能不太熟悉，所以我们花了一些时间来专注于读取二进制规范。如果你已经熟悉，请随意浏览。
- en: '|  |'
  id: totrans-598
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Since we want to use it in our Node application, JSON would be a good format
    choice because it can be natively parsed in JavaScript and resembles native JavaScript
    objects. This is illustrated in [figure 3.4](#ch03fig04).
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们想在 Node 应用程序中使用它，JSON 将是一个好的格式选择，因为它可以在 JavaScript 中原生解析，并且类似于原生 JavaScript
    对象。这如图 3.4 所示。
- en: Figure 3.4\. Binary data is read using `FileSystem` API into Node.js, transformed
    using the `Buffer` API into an easier-to-use JSON format.
  id: totrans-600
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 3.4\. 使用 `FileSystem` API 读取二进制数据到 Node.js，使用 `Buffer` API 转换为更易用的 JSON 格式。
- en: '![](03fig04_alt.jpg)'
  id: totrans-601
  prefs: []
  type: TYPE_IMG
  zh: '![](03fig04_alt.jpg)'
- en: '[Figure 3.5](#ch03fig05) shows an example of the transformation we want to
    make: on the left is the raw binary opened in a text editor, and on the right
    is the converted JSON format.'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 3.5](#ch03fig05) 展示了我们想要进行的转换示例：左侧是在文本编辑器中打开的原始二进制文件，右侧是转换后的 JSON 格式。'
- en: Figure 3.5\. Final result of our transformation
  id: totrans-603
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 3.5\. 我们转换的最终结果
- en: '![](03fig05_alt.jpg)'
  id: totrans-604
  prefs: []
  type: TYPE_IMG
  zh: '![](03fig05_alt.jpg)'
- en: The header
  id: totrans-605
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 文件头
- en: Before we can start tackling this problem, we’ll need to do some research to
    find out the specification for the binary format we want to deal with. In our
    case, a number of similar specifications were found online from search engine
    queries. For DBase 5.0, the primary specification we’ll use for this example is
    found at [http://mng.bz/i7K4](http://mng.bz/i7K4).
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始解决这个问题之前，我们需要进行一些研究，以找出我们想要处理的二进制格式的规范。在我们的案例中，从搜索引擎查询中找到了一些类似的规范。对于 DBase
    5.0，我们将使用的主要规范可以在 [http://mng.bz/i7K4](http://mng.bz/i7K4) 找到。
- en: The first portion of the specification is called the *header*. Many binary formats
    will use a header as a place to store metadata about the file; [table 3.1](#ch03table01)
    shows what the specification looks like for DBase 5.0.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 规范的第一部分被称为 *头*。许多二进制格式将使用头作为存储文件元数据的地方；[表 3.1](#ch03table01) 显示了 DBase 5.0 的规范看起来是什么样子。
- en: Table 3.1\. DBase 5.0 header specification
  id: totrans-608
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 3.1\. DBase 5.0 文件头规范
- en: '| Byte | Contents | Description |'
  id: totrans-609
  prefs: []
  type: TYPE_TB
  zh: '| 字节 | 内容 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-610
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 0 | 1 byte | Valid dBASE for Windows table file; bits 0-2 indicate version
    number ... |'
  id: totrans-611
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1字节 | 有效的 dBASE for Windows 表格文件；位0-2指示版本号... |'
- en: '| 1-3 | 3 bytes | Date of last update; in YYMMDD format |'
  id: totrans-612
  prefs: []
  type: TYPE_TB
  zh: '| 1-3 | 3字节 | 最后更新的日期；采用 YYMMDD 格式 |'
- en: '| 4-7 | 32-bit number | Number of records in the table |'
  id: totrans-613
  prefs: []
  type: TYPE_TB
  zh: '| 4-7 | 32位数字 | 表中的记录数 |'
- en: '| 8-9 | 16-bit number | Number of bytes in the header |'
  id: totrans-614
  prefs: []
  type: TYPE_TB
  zh: '| 8-9 | 16位数字 | 文件头中的字节数 |'
- en: '| 10-11 | 16-bit number | Number of bytes in the record |'
  id: totrans-615
  prefs: []
  type: TYPE_TB
  zh: '| 10-11 | 16 位数字 | 记录中的字节数 |'
- en: '| ... | ... | ... |'
  id: totrans-616
  prefs: []
  type: TYPE_TB
  zh: '| ... | ... | ... |'
- en: '| 32-n each | 32 bytes | Field descriptor array |'
  id: totrans-617
  prefs: []
  type: TYPE_TB
  zh: '| 32-n 每个字节 | 32 字节 | 字段描述符数组 |'
- en: '| n+1 | 1 byte | 0Dh stored as the field terminator |'
  id: totrans-618
  prefs: []
  type: TYPE_TB
  zh: '| n+1 | 1 字节 | 0Dh 存储为字段终止符 |'
- en: Let’s take a peek at the first row.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下第一行。
- en: '| Byte | Contents | Description |'
  id: totrans-620
  prefs: []
  type: TYPE_TB
  zh: '| 字节 | 内容 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-621
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 0 | 1 byte | Valid dBASE for Windows table file; bits 0-2 indicate version
    number ... |'
  id: totrans-622
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1 字节 | 有效的 dBASE for Windows 表文件；位 0-2 表示版本号 ... |'
- en: This row tells us the byte located at position 0 contains the information specified
    in the description. So how do we access the byte at position 0? Thankfully, this
    is really simple with buffers.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 这一行告诉我们位于位置 0 的字节包含描述中指定的信息。那么我们如何访问位置 0 的字节呢？幸运的是，使用缓冲区这非常简单。
- en: 'In Node, *unless you specify a particular encoding* for the data you’re reading
    in, you’ll get back a Node `Buffer`, as seen in this example:'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Node 中，*除非您为读取的数据指定特定的编码*，否则您将得到一个 Node `Buffer`，如本例所示：
- en: '[PRE25]'
  id: totrans-625
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '`fs.readFile` isn’t the only way to get back a buffer but, for the sake of
    simplicity, we’ll use that method so we get the entire buffer back as an object
    after it’s read. This method may not be ideal for large binary files where you
    wouldn’t want to load the whole buffer into memory at once. In that case, you
    could stream the data with `fs.createReadStream` or manually read in parts of
    the file at a time with `fs.read`. It should also be noted that buffers aren’t
    available only for files; they exist pretty much anywhere you can get streams
    of data (for example, post data on an HTTP request).'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: '`fs.readFile` 不是获取缓冲区回显的唯一方法，但为了简单起见，我们将使用该方法，以便在读取后以对象的形式获取整个缓冲区。这种方法可能不适合大型二进制文件，您可能不希望一次性将整个缓冲区加载到内存中。在这种情况下，您可以使用
    `fs.createReadStream` 流式传输数据，或者使用 `fs.read` 手动一次读取文件的一部分。还应注意的是，缓冲区不仅限于文件；它们几乎存在于您可以从数据流中获取数据的地方（例如，HTTP
    请求上的请求数据）。'
- en: 'If you wanted to view a string representation of a buffer, a simple `buf.toString()`
    call would suffice (this defaults to UTF-8 encoding). This is nice if you’re pulling
    in data that you know is just text:'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想查看缓冲区的字符串表示形式，简单的 `buf.toString()` 调用就足够了（默认为 UTF-8 编码）。如果您知道要拉取的数据只是文本，这会很好：
- en: '![](048fig01_alt.jpg)'
  id: totrans-628
  prefs: []
  type: TYPE_IMG
  zh: '![](048fig01_alt.jpg)'
- en: 'In our case, `buf.toString()` would be just as bad as opening up the world.dbf
    file in a text editor: unusable. We need to make sense of the binary data first.'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，`buf.toString()` 会和用文本编辑器打开 world.dbf 文件一样糟糕：不可用。我们首先需要理解二进制数据。
- en: '|  |'
  id: totrans-630
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-631
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: From here forward, whenever you see our variable `buf`, it refers to an instance
    of a `Buffer`, therefore part of the Node `Buffer` API.
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，每当您看到我们的变量 `buf`，它指的是一个 `Buffer` 实例，因此是 Node `Buffer` API 的一部分。
- en: '|  |'
  id: totrans-633
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: In the table we talked about byte position 0\. Buffers in Node act very similar
    to JavaScript arrays *but the indices are byte positions in memory*. So byte position
    0 is `buf[0]`. In `Buffer` syntax, `buf[0]` is synonymous with the byte, the octet,
    the unsigned 8-bit integer, or positive signed 8-bit integer at position 0.
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论的表中，我们提到了字节位置 0。Node 中的缓冲区与 JavaScript 数组非常相似，但索引是内存中的字节位置。因此，字节位置 0 是
    `buf[0]`。在 `Buffer` 语法中，`buf[0]` 与位置 0 的字节、八位字节、无符号 8 位整数或正有符号 8 位整数同义。
- en: For this example, we don’t really care about storing information about this
    particular byte. Let’s move on to the next byte definition.
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我们并不真正关心存储关于这个特定字节的任何信息。让我们继续到下一个字节定义。
- en: '| Byte | Contents | Description |'
  id: totrans-636
  prefs: []
  type: TYPE_TB
  zh: '| 字节 | 内容 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-637
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 1-3 | 3 bytes | Date of last update; in YYMMDD format |'
  id: totrans-638
  prefs: []
  type: TYPE_TB
  zh: '| 1-3 | 3 字节 | 最后更新的日期；YYMMDD 格式 |'
- en: 'Here’s something interesting: the date of the last update. But this spec doesn’t
    tell us anything more than that it’s 3 bytes and in YYMMDD format. All this is
    to say that you may not find all you’re looking for in one spot. Subsequent web
    searches landed this information:'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些有趣的东西：最后更新的日期。但这个规范并没有告诉我们更多，只是它有 3 个字节，并且是 YYMMDD 格式。所有这些都是说，您可能不会在一个地方找到您想要的所有东西。随后的网络搜索得到了以下信息：
- en: '*Each byte contains the number as a binary. YY is added to a base of 1900 decimal
    to determine the actual year. Therefore, YY has possible values from 0x00-0xFF,
    which allows for a range from 1900-2155.*^([[6](#ch03fn06)])'
  id: totrans-640
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*每个字节都包含一个二进制数。YY 被加到一个 1900 十进制基数上，以确定实际年份。因此，YY 的可能值从 0x00-0xFF，这允许从 1900-2155
    的范围。*^([[6](#ch03fn06)])'
- en: ''
  id: totrans-641
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ⁶ See [http://www.dbase.com/Knowledgebase/INT/db7_file_fmt.htm](http://www.dbase.com/Knowledgebase/INT/db7_file_fmt.htm).
  id: totrans-642
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁶参见[http://www.dbase.com/Knowledgebase/INT/db7_file_fmt.htm](http://www.dbase.com/Knowledgebase/INT/db7_file_fmt.htm)。
- en: 'That’s more helpful. Let’s look at parsing this in Node:'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 这更有帮助。让我们看看如何在Node中解析它：
- en: '![](048fig02_alt.jpg)'
  id: totrans-644
  prefs: []
  type: TYPE_IMG
  zh: '![](048fig02_alt.jpg)'
- en: Here we use a JavaScript `Date` object and set its year to 1900 plus the integer
    we pulled out of `buf[1]`. We use integers at positions 2 and 3 to set the month
    and date. Since JSON doesn’t store JavaScript `Date` types, we’ll store it as
    a UTC `Date` string.
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用一个JavaScript `Date`对象，并将其年份设置为1900加上从`buf[1]`中提取的整数。我们使用位置2和3的整数来设置月份和日期。由于JSON不存储JavaScript
    `Date`类型，我们将它存储为一个UTC `Date`字符串。
- en: Let’s pause to recap. “Sat Aug 26 1995...” as shown here is the result of parsing
    a portion of world.dbf binary data into a JavaScript string. We’ll see more examples
    of this as we continue.
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们暂停一下，回顾一下。正如这里所示，“Sat Aug 26 1995...”是解析world.dbf二进制数据的一部分到JavaScript字符串的结果。随着我们继续，我们将看到更多这样的例子。
- en: '| Byte | Contents | Description |'
  id: totrans-647
  prefs: []
  type: TYPE_TB
  zh: '| 字节 | 内容 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-648
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 4-7 | 32-bit number | Number of records in the table |'
  id: totrans-649
  prefs: []
  type: TYPE_TB
  zh: '| 4-7 | 32位数字 | 表中的记录数 |'
- en: 'This next definition gives us two clues. We know the byte starts at offset
    4 and it’s a 32-bit number with the least significant byte first. Since we know
    the number shouldn’t be negative, we can assume either a positive signed integer
    or an unsigned integer. Both are accessed the same way in the `Buffer` API:'
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个定义给我们提供了两个线索。我们知道字节从偏移量4开始，它是一个32位数字，最低有效字节在前。由于我们知道这个数字不应该是负数，我们可以假设它是一个正的有符号整数或无符号整数。在`Buffer`
    API中，两者都以相同的方式访问：
- en: '![](049fig01.jpg)'
  id: totrans-651
  prefs: []
  type: TYPE_IMG
  zh: '![](049fig01.jpg)'
- en: '`buf.readUInt32LE` will read an unsigned 32-bit integer with little-endian
    format from the offset of 4, which matches our description from earlier.'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: '`buf.readUInt32LE`将从偏移量4处读取一个无符号32位整数，采用小端格式，这与我们之前描述的相符。'
- en: The next two definitions follow a similar pattern except they’re 16-bit integers.
    Following are their definitions.
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 下两个定义遵循类似的模式，但它们是16位整数。以下是它们的定义。
- en: '| Byte | Contents | Description |'
  id: totrans-654
  prefs: []
  type: TYPE_TB
  zh: '| 字节 | 内容 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-655
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 8-9 | 16-bit number | Number of bytes in the header |'
  id: totrans-656
  prefs: []
  type: TYPE_TB
  zh: '| 8-9 | 16位数字 | 头部中的字节数 |'
- en: '| 10-11 | 16-bit number | Number of bytes in the record |'
  id: totrans-657
  prefs: []
  type: TYPE_TB
  zh: '| 10-11 | 16位数字 | 记录中的字节数 |'
- en: 'And here’s the corresponding code:'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是对应的代码：
- en: '![](049fig02_alt.jpg)'
  id: totrans-659
  prefs: []
  type: TYPE_IMG
  zh: '![](049fig02_alt.jpg)'
- en: The transformation that has taken place between the specification and the code
    for this header section is illustrated in [figure 3.6](#ch03fig06).
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 本节头文件规范与代码之间的转换在[图3.6](#ch03fig06)中展示。
- en: 'Figure 3.6\. The header: transformation from the specification to code using
    the Node `Buffer` API'
  id: totrans-661
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.6。头部：使用Node `Buffer` API从规范到代码的转换
- en: '![](03fig06_alt.jpg)'
  id: totrans-662
  prefs: []
  type: TYPE_IMG
  zh: '![](03fig06_alt.jpg)'
- en: The field descriptor array
  id: totrans-663
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 字段描述符数组
- en: Only one more relevant piece of information for this example remains in the
    header of the world.dbf file. It’s the definitions for the fields, including type
    and name information, seen in the following lines.
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，在world.dbf文件的头文件中只剩下一个相关的信息。它是以下行中看到的字段定义，包括类型和名称信息。
- en: '| Byte | Contents | Description |'
  id: totrans-665
  prefs: []
  type: TYPE_TB
  zh: '| 字节 | 内容 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-666
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 32-n each | 32 bytes | Field descriptor array |'
  id: totrans-667
  prefs: []
  type: TYPE_TB
  zh: '| 32-n each | 32字节 | 字段描述符数组 |'
- en: '| n+1 | 1 byte | 0Dh stored as the field terminator |'
  id: totrans-668
  prefs: []
  type: TYPE_TB
  zh: '| n+1 | 1字节 | 以0Dh存储的字段终止符 |'
- en: 'From this we know that each field description is stored as 32 bytes of information.
    Since this database could have one or more fields for data, we’ll know it’s finished
    when we hit the 1 byte field terminator (0Dh) shown in the second row. Let’s write
    a structure to handle this:'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里我们知道每个字段描述都是以32字节的信息存储的。由于这个数据库可能有一个或多个数据字段，我们将知道它何时结束，当我们遇到第二行中显示的1字节字段终止符（0Dh）时。让我们编写一个结构来处理这个问题：
- en: '![](050fig01.jpg)'
  id: totrans-670
  prefs: []
  type: TYPE_IMG
  zh: '![](050fig01.jpg)'
- en: Here we loop through the buffer 32 bytes at a time until we hit the `fieldTerminator`,
    which is represented in hexadecimal notation.
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们以32字节为单位循环缓冲区，直到我们遇到表示为十六进制记法的`fieldTerminator`。
- en: Now we need to handle the information concerning each field descriptor. The
    specification has another table specifically for this; the relevant information
    for our example is shown in [table 3.2](#ch03table02).
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要处理每个字段描述符的信息。规范中还有一个专门为此目的的表格；我们例子的相关信息在[表3.2](#ch03table02)中展示。
- en: Table 3.2\. DBase 5.0 field descriptor array specification
  id: totrans-673
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表3.2。DBase 5.0字段描述符数组规范
- en: '| Byte | Contents | Description |'
  id: totrans-674
  prefs: []
  type: TYPE_TB
  zh: '| 字节 | 内容 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-675
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 0-10 | 11 bytes | Field name in ASCII (zero-filled) |'
  id: totrans-676
  prefs: []
  type: TYPE_TB
  zh: '| 0-10 | 11 字节 | 字段名称（ASCII，零填充）|'
- en: '| 11 1 | byte | Field type in ASCII (C, N, ...) |'
  id: totrans-677
  prefs: []
  type: TYPE_TB
  zh: '| 11 1 | 字节 | 字段类型（ASCII，C，N等）|'
- en: '| ... | ... | ... |'
  id: totrans-678
  prefs: []
  type: TYPE_TB
  zh: '| ... | ... | ... |'
- en: '| 16 | 1 byte | Field length in binary |'
  id: totrans-679
  prefs: []
  type: TYPE_TB
  zh: '| 16 | 1 字节 | 字段长度（二进制）|'
- en: 'Note that the indexing for the bytes starts over at 0, even though we’re well
    past byte position 0 in our reading of the file. It would be nice to start over
    at each record so we could follow the specification more closely. `Buffer` provides
    a `slice` method for us to do just that:'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，字节的索引从0开始，即使我们在读取文件时已经远远超过了字节位置0。如果我们从每个记录开始重新开始，那将很棒，这样我们就可以更紧密地遵循规范。`Buffer`提供了一个`slice`方法，我们可以用它来做这件事：
- en: '[PRE26]'
  id: totrans-681
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '`buf.slice(start, end)` is very similar to a standard array slice method in
    that it returns a buffer indexed at `start` to `end`. But it differs in that it
    doesn’t return a new copy of the data. It returns just a snapshot of the data
    at those points. So if you manipulate the data in the sliced buffer in any way,
    *it will also be manipulated in the original buffer*.'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: '`buf.slice(start, end)`与标准数组切片方法非常相似，因为它返回从`start`到`end`的缓冲区索引。但它不同之处在于它不返回数据的新副本。它只返回那些点的数据快照。所以如果你以任何方式在切片缓冲区中操作数据，*它也会在原始缓冲区中被操作*。'
- en: With our new `fieldBuf` indexed at zero for each iteration, we can approach
    the specification without doing extra math in our heads. Let’s look at the first
    line.
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们新的`fieldBuf`在每个迭代中从零开始索引，我们可以不进行额外的头脑数学运算来接近规范。让我们看看第一行。
- en: '| Byte | Contents | Description |'
  id: totrans-684
  prefs: []
  type: TYPE_TB
  zh: '| 字节 | 内容 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-685
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 0-10 | 11 bytes | Field name in ASCII (zero-filled) |'
  id: totrans-686
  prefs: []
  type: TYPE_TB
  zh: '| 0-10 | 11 字节 | 字段名称（ASCII，零填充）|'
- en: 'Here’s the code to extract the field name:'
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: 这是提取字段名称的代码：
- en: '![](051fig01_alt.jpg)'
  id: totrans-688
  prefs: []
  type: TYPE_IMG
  zh: '![](051fig01_alt.jpg)'
- en: By default, `buf.toString()` assumes `utf8`, but Node `Buffer`s support other
    encodings as well,^([[7](#ch03fn07)]) including `ascii`, which is what our spec
    calls for. `buf.toString()` also allows you to pass in the range that you want
    converted. We also have to `replace()` the zero-filled characters with empty strings
    if the field was shorter than 11 bytes so we don’t end up with zero-filled characters
    (\u0000) in our names.
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`buf.toString()`假设`utf8`，但Node `Buffer`s也支持其他编码，包括`ascii`，这正是我们的规范所要求的。`buf.toString()`还允许你传入你想要转换的范围。我们还必须`replace()`掉如果字段小于11字节则填充的零字符，这样我们就不会在我们的名称中结束于零填充字符（\u0000）。
- en: ⁷ See [http://nodejs.org/api/buffer.html#buffer_buffer](http://nodejs.org/api/buffer.html#buffer_buffer).
  id: totrans-690
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁷参见[http://nodejs.org/api/buffer.html#buffer_buffer](http://nodejs.org/api/buffer.html#buffer_buffer)。
- en: The next relevant field is a field data type.
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个相关的字段是字段数据类型。
- en: '| Byte | Contents | Description |'
  id: totrans-692
  prefs: []
  type: TYPE_TB
  zh: '| 字节 | 内容 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-693
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 11 | 1 byte | Field type in ASCII (C, N, ...) |'
  id: totrans-694
  prefs: []
  type: TYPE_TB
  zh: '| 11 | 1 字节 | 字段类型（ASCII，C，N等）|'
- en: But the characters C and N don’t really mean anything to us yet. Further down
    the specification, we get definitions for these types, as shown in [table 3.3](#ch03table03).
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 但字符C和N对我们来说还没有实际意义。在规范的下文中，我们将得到这些类型的定义，如[表3.3](#ch03table03)所示。
- en: Table 3.3\. Field types specification
  id: totrans-696
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表3.3\. 字段类型规范
- en: '| Data type | Data input |'
  id: totrans-697
  prefs: []
  type: TYPE_TB
  zh: '| 数据类型 | 数据输入 |'
- en: '| --- | --- |'
  id: totrans-698
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| C (Character) | All OEM code page characters |'
  id: totrans-699
  prefs: []
  type: TYPE_TB
  zh: '| C（字符）| 所有OEM代码页字符|'
- en: '| N (Numeric) | - . 0 1 2 3 4 5 6 7 8 9 |'
  id: totrans-700
  prefs: []
  type: TYPE_TB
  zh: '| N（数字）| - . 0 1 2 3 4 5 6 7 8 9 |'
- en: 'It would be nice to convert this data to relevant types for our application.
    JavaScript doesn’t use the language *character* or *numeric*, but it does have
    *String* and *Number*; let’s keep that in mind when we parse the actual records.
    For now we can store this in a little lookup object to do the conversion later:'
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些数据转换为我们的应用程序相关的类型会很好。JavaScript不使用语言*字符*或*数字*，但它确实有*String*和*Number*；在我们解析实际记录时，让我们记住这一点。目前，我们可以将其存储在一个小的查找对象中，稍后进行转换：
- en: '[PRE27]'
  id: totrans-702
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now that we have a lookup table, we can pull out the relevant information as
    we continue converting the binary data:'
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了查找表，我们可以在继续转换二进制数据时提取相关信息：
- en: '![](052fig01_alt.jpg)'
  id: totrans-704
  prefs: []
  type: TYPE_IMG
  zh: '![](052fig01_alt.jpg)'
- en: '`buf.toString()` will give us our one ASCII character that we then look up
    in the hash to get the full type name.'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: '`buf.toString()`将给我们一个ASCII字符，然后我们在哈希中查找以获取完整的类型名称。'
- en: There’s only one other bit of information we need to parse the remaining file
    from each field description—the field size.
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 解析剩余文件中每个字段描述所需解析的唯一其他信息是字段大小。
- en: '| Byte | Contents | Description |'
  id: totrans-707
  prefs: []
  type: TYPE_TB
  zh: '| 字节 | 内容 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-708
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 16 | 1 byte | Field length in binary |'
  id: totrans-709
  prefs: []
  type: TYPE_TB
  zh: '| 16 | 1 字节 | 字段长度（二进制）|'
- en: 'We write this now-familiar code:'
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在写下这个熟悉的代码：
- en: '![](052fig02.jpg)'
  id: totrans-711
  prefs: []
  type: TYPE_IMG
  zh: '![图片](052fig02.jpg)'
- en: The transformation that has taken place between the specification and the code
    for this field descriptor array section is illustrated in [figure 3.7](#ch03fig07).
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 该字段描述符数组部分规范和代码之间的转换在[图3.7](#ch03fig07)中得到了说明。
- en: 'Figure 3.7\. The field descriptor array: transformation from the specification
    to code using the Node `Buffer` API'
  id: totrans-713
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.7. 字段描述符数组：使用Node `Buffer` API从规范到代码的转换
- en: '![](03fig07_alt.jpg)'
  id: totrans-714
  prefs: []
  type: TYPE_IMG
  zh: '![图片](03fig07_alt.jpg)'
- en: The records
  id: totrans-715
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 记录
- en: 'Now that we’ve parsed the header, including the field descriptors, we have
    one more part to process: the actual record data. The specification tells us this:'
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经解析了头部，包括字段描述符，我们还有另一部分要处理：实际的记录数据。规范告诉我们这一点：
- en: '*The records follow the header in the table file. Data records are preceded
    by one byte, that is, a space (20h) if the record is not deleted, an asterisk
    (2Ah) if the record is deleted. Fields are packed into records without field separators
    or record terminators. The end of the file is marked by a single byte, with the
    end-of-file marker, an OEM code page character value of 26 (1Ah).*'
  id: totrans-717
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*记录在表文件中跟随头部。如果记录未被删除，则数据记录之前有一个字节，即空格（20h）；如果记录被删除，则有一个星号（2Ah）。字段没有字段分隔符或记录终止符地打包到记录中。文件的末尾由一个字节标记，即文件结束标记，OEM代码页字符值为26（1Ah）。*'
- en: 'Let’s break this down for discussion:'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将其分解以进行讨论：
- en: '*The records follow the header in the table file.*'
  id: totrans-719
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*记录在表文件中跟随头部。*'
- en: 'Although we could’ve kept track of the byte position after the `fieldOffset`,
    the header had a field for number of bytes in the header, which we stored as `header.bytesInHeader`.
    So we know we need to start there:'
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以在`fieldOffset`之后跟踪字节位置，但头部有一个表示头部字节数的字段，我们将其存储为`header.bytesInHeader`。因此，我们知道我们需要从这里开始：
- en: '[PRE28]'
  id: totrans-721
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We also learned a couple other things from our parsing of the header. The first
    is how many records exist in the data, which we stored as `header.totalRecords`.
    The second is how many bytes are allocated for each record, which was stored as
    `header.bytesPerRecord`. Knowing where to start, how many to iterate, and how
    much of a jump per iteration helps us set up a nice `for` loop for handling each
    record:'
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们对头部的解析中，我们还学到了一些其他东西。第一点是数据中存在多少条记录，我们将其存储为`header.totalRecords`。第二点是每条记录分配了多少字节，我们将其存储为`header.bytesPerRecord`。知道从哪里开始，迭代多少次，以及每次迭代跳多少有助于我们设置一个处理每个记录的优雅的`for`循环：
- en: '[PRE29]'
  id: totrans-723
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, at the beginning of each iteration, we know the byte position we want
    to start at is stored as `recordOffset`. Let’s continue reading the specification:'
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在每次迭代的开始，我们知道我们想要开始的字节位置存储为`recordOffset`。让我们继续阅读规范：
- en: '*Data records are preceded by one byte, that is, a space (20h) if the record
    is not deleted, an asterisk (2Ah) if the record is deleted.*'
  id: totrans-725
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*如果记录未被删除，则数据记录之前有一个字节，即空格（20h）；如果记录被删除，则有一个星号（2Ah）。*'
- en: 'Next we have to check that first byte to see if the record was deleted:'
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须检查第一个字节以查看记录是否被删除：
- en: '![](054fig01_alt.jpg)'
  id: totrans-727
  prefs: []
  type: TYPE_IMG
  zh: '![图片](054fig01_alt.jpg)'
- en: 'Similar to when we tested for the `fieldTerminator` in our header file, here
    we test to see if the integer matches `0x2A` or the ASCII “asterisk” character.
    Let’s continue reading:'
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们在头部文件中测试`fieldTerminator`类似，这里我们测试整数是否匹配`0x2A`或ASCII的“星号”字符。让我们继续阅读：
- en: '*Fields are packed into records without field separators or record terminators.*'
  id: totrans-729
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*字段没有字段分隔符或记录终止符地打包到记录中。*'
- en: 'Lastly, we can pull in the actual record data. This pulls in the information
    we learned from parsing the field descriptor array. We stored a `field.type`,
    `field.name`, and `field.length` (in bytes) for each field. We want to store the
    name as a key in the record where the value is the data for that length of bytes
    converted to the correct type. Let’s look at it in simple pseudo code:'
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以提取实际的记录数据。这提取了从解析字段描述符数组中学到的信息。我们为每个字段存储了`field.type`、`field.name`和`field.length`（以字节为单位）。我们希望将名称作为记录中的键，其值是转换到正确类型的该长度字节数据。让我们用简单的伪代码来看看：
- en: '[PRE30]'
  id: totrans-731
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We also want to do this type conversion for every field per record, so we use
    another `for` loop:'
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望对每条记录的每个字段进行此类类型转换，因此我们使用另一个`for`循环：
- en: '[PRE31]'
  id: totrans-733
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We loop through each of the fields:'
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: 我们遍历每个字段：
- en: '**1**.  First, we find out which JavaScript type we want to cast the value
    to and store it in a variable `Type`.'
  id: totrans-735
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**. 首先，我们找出要将值转换为哪种JavaScript类型，并将其存储在变量`Type`中。'
- en: '**2**.  Then, we use `buf.toString` to pull out the characters from `recordOffset`
    to the next `field.length`. We also have to `trim()` the data because we don’t
    know if all the bytes were used to store relevant data or just filled with spaces.'
  id: totrans-736
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**. 然后，我们使用`buf.toString`从`recordOffset`到下一个`field.length`提取字符。我们还需要`trim()`数据，因为我们不知道是否所有字节都用于存储相关数据，或者只是填充了空格。'
- en: '**3**.  Lastly, we increment the `recordOffset` with the `field.length` so
    that we keep the location to start at for the next field when we go around the
    `for` loop again.'
  id: totrans-737
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**3**. 最后，我们将`recordOffset`增加`field.length`，以便在再次进入`for`循环时，我们保持下一个字段的起始位置。'
- en: The transformation that has taken place between the specification and the code
    for this records section is illustrated in [figure 3.8](#ch03fig08).
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: 本记录部分的规范与代码之间的转换在[图3.8](#ch03fig08)中得到了说明。
- en: 'Figure 3.8\. The records: transformation from the specification to code using
    the Node `Buffer` API'
  id: totrans-739
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.8. 记录：使用Node `Buffer` API将规范转换为代码
- en: '![](03fig08_alt.jpg)'
  id: totrans-740
  prefs: []
  type: TYPE_IMG
  zh: '![](03fig08_alt.jpg)'
- en: Still with me? I hope so. The complete code sample is shown in [figure 3.9](#ch03fig09).
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 你还在吗？我希望如此。完整的代码示例在[图3.9](#ch03fig09)中展示。
- en: Figure 3.9\. The full set of code for parsing a DBF file into JSON
  id: totrans-742
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图3.9. 将DBF文件解析为JSON的完整代码
- en: '![](03fig09_alt.jpg)'
  id: totrans-743
  prefs: []
  type: TYPE_IMG
  zh: '![](03fig09_alt.jpg)'
- en: 'Using the Node `Buffer` API, we were able to turn a binary file into a usable
    JSON format. The output of running this application is shown next:'
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Node的`Buffer` API，我们能够将二进制文件转换为可用的JSON格式。运行此应用程序的输出如下所示：
- en: '[PRE32]'
  id: totrans-745
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: And almost magically a binary file that wasn’t human-readable is turned into,
    not only a readable format, but also a usable data format to work with and do
    more transformations with. Of course, it isn’t magic, but rather investing the
    time to learn a binary format and using the tools available to do a conversion.
    The `Buffer` API provides good tools to do this.
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎神奇的是，一个不可读的二进制文件被转换成了一个不仅可读，而且可用的数据格式，可以用来进行更多转换。当然，这并不是魔法，而是投入时间学习二进制格式并使用可用的工具进行转换。`Buffer`
    API提供了很好的工具来完成这项工作。
- en: '|  |'
  id: totrans-747
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Using fs methods**'
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用fs方法**'
- en: 'We could’ve also chosen to write the resulting code out to a file using `fs.writeFile`
    and friends.^([[a](#ch03fn01a)]) Just like most APIs in Node can read in a buffer
    object, most also can write out a buffer object. In our case we didn’t end up
    with a buffer but rather a JSON object, so we could’ve used `JSON.stringify` in
    conjunction with `fs.writeFile` to write that data out:'
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以选择使用`fs.writeFile`及其相关方法将生成的代码写入文件。[^a](#ch03fn01a)就像Node中的大多数API可以读取缓冲区对象一样，大多数也可以写入缓冲区对象。在我们的情况下，我们没有得到一个缓冲区，而是一个JSON对象，因此我们可以使用`JSON.stringify`结合`fs.writeFile`将数据写入：
- en: ^a See [http://nodejs.org/api/fs.html](http://nodejs.org/api/fs.html).
  id: totrans-750
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^a参见[http://nodejs.org/api/fs.html](http://nodejs.org/api/fs.html)。
- en: '[PRE33]'
  id: totrans-751
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '|  |'
  id: totrans-752
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Binary file formats can be a lot of fun to crack. Another fun but practical
    use for `Buffer`s is working binary protocols, which we’ll tackle next.
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制文件格式可以很有趣去破解。`Buffer`的另一个有趣且实用的用途是处理二进制协议，我们将在下一部分探讨。
- en: 3.3\. Creating your own binary protocol
  id: totrans-754
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3. 创建自己的二进制协议
- en: It feels like you’ve cracked a code when you read a binary file and make sense
    out of it. It can be just as fun to write your own puzzles and decode them. Of
    course, this isn’t just for fun. Using a well-defined binary protocol can be a
    compact and efficient way to transfer data.
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 当你阅读二进制文件并从中理解其含义时，感觉就像破解了一道代码。编写自己的谜题并解码它们同样有趣。当然，这不仅仅是为了乐趣。使用一个定义良好的二进制协议可以是一种紧凑且高效的数据传输方式。
- en: Technique 18 Creating your own network protocol
  id: totrans-756
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 技巧18：创建自己的网络协议
- en: In this technique we’ll cover some additional aspects of working with binary
    data, like bit masks and protocol design. We’ll also look into compressing binary
    data.
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个技术中，我们将涵盖一些处理二进制数据的额外方面，例如位掩码和协议设计。我们还将探讨压缩二进制数据。
- en: Problem
  id: totrans-758
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: You want create an efficient transport of messages across the network or in
    process.
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要创建一个高效的消息传输方式，无论是在网络中还是在进程中。
- en: Solution
  id: totrans-760
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案
- en: JavaScript and the Node `Buffer` API give you tools to create your own binary
    protocol.
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript和Node的`Buffer` API为你提供了创建自己的二进制协议的工具。
- en: Discussion
  id: totrans-762
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论
- en: To create a binary protocol, you first have to define what kind of information
    you want to send across the wire and how you’ll represent that information. Like
    you learned in the last technique, a specification provides a good roadmap for
    this.
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个二进制协议，你首先必须定义你想要通过网络或进程发送的信息类型以及你将如何表示这些信息。就像你在上一技巧中学到的那样，一个规范为这一过程提供了一个很好的路线图。
- en: For this technique, we’ll develop a simple and compact database protocol. Our
    protocol will involve
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这种技术，我们将开发一个简单且紧凑的数据库协议。我们的协议将包括
- en: Using a bitmask to determine which database(s) to store the message in
  id: totrans-765
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用位掩码来确定将消息存储在哪个数据库中
- en: Writing data to a particular key that will be an unsigned integer between 0-255
    (one byte)
  id: totrans-766
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数据写入特定的键，该键将是一个介于0-255（一个字节）的无符号整数
- en: Storing a message that is compressed data of any length using zlib
  id: totrans-767
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用zlib压缩任何长度的消息
- en: '[Table 3.4](#ch03table04) shows how we could write the specification.'
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: '[表3.4](#ch03table04)显示了我们可以如何编写规范。'
- en: Table 3.4\. Simple key-value database protocol
  id: totrans-769
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表3.4\. 简单键值数据库协议
- en: '| Byte | Contents | Description |'
  id: totrans-770
  prefs: []
  type: TYPE_TB
  zh: '| 字节 | 内容 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-771
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 0 | 1 byte | Determines which database(s) to write the data to based on which
    bits are toggled on. Each bit position represents a database from 1–8. |'
  id: totrans-772
  prefs: []
  type: TYPE_TB
  zh: '| 0 | 1字节 | 根据哪些位被激活，确定将数据写入哪个数据库。每个位位置代表一个从1到8的数据库。 |'
- en: '| 1 | 1 byte | An unsigned integer of one byte (0–255) used as the database
    key to store the data in. |'
  id: totrans-773
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1字节 | 一个字节的未签名整数（0-255），用作数据库键，以存储数据。 |'
- en: '| 2-n | 0-n bytes | The data to store, which can be any amount of bytes that
    have been compressed using deflate (zlib). |'
  id: totrans-774
  prefs: []
  type: TYPE_TB
  zh: '| 2-n | 0-n字节 | 要存储的数据，可以是使用deflate（zlib）压缩的任意数量的字节。 |'
- en: Playing with bits to select databases
  id: totrans-775
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 通过操作位来选择数据库
- en: 'Our protocol states that the first byte will be used to represent which databases
    should record the information transferred. On the receiving end, our main database
    will be a simple multidimensional array that will hold spots for eight databases
    (since there are eight bits in a byte). This can be simply represented using array
    literals in JavaScript:'
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的协议规定，第一个字节将用于表示哪些数据库应该记录传输的信息。在接收端，我们的主要数据库将是一个简单的多维数组，将包含八个数据库的位置（因为一个字节中有八个位）。这可以用JavaScript中的数组字面量简单地表示：
- en: '[PRE34]'
  id: totrans-777
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Whatever bits are turned on will indicate which database or databases will store
    the message received. For example, the number `8` is represented as `00001000`
    in binary. In this case we’d store the information in database 4, since the fourth
    bit is on (bits are read from right to left).
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: 无论哪些位被激活，都将指示哪些数据库或数据库将存储接收到的消息。例如，数字`8`在二进制中表示为`00001000`。在这种情况下，我们将信息存储在数据库4中，因为第四位是开启的（位是从右到左读取的）。
- en: '|  |'
  id: totrans-779
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Zero-indexed arrays
  id: totrans-780
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 零索引数组
- en: Arrays are zero-indexed in JavaScript, so database 4 is in array position 3,
    but to avoid complicating things, we’re intentionally calling our databases 1
    through 8 instead of 0 through 7 to match our language more closely when talking
    about bits in a byte.
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，数组是零索引的，所以数据库4在数组位置3，但为了避免复杂化，我们故意将我们的数据库称为1到8，而不是0到7，以更接近我们的语言在讨论字节的位时。
- en: '|  |'
  id: totrans-782
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'If you’re ever curious about a number’s binary representation in JavaScript,
    you can use the built-in `toString` method, giving it a base `2` as the first
    argument:'
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你好奇一个数字在JavaScript中的二进制表示，你可以使用内置的`toString`方法，将其第一个参数设置为`2`：
- en: '![](059fig01_alt.jpg)'
  id: totrans-784
  prefs: []
  type: TYPE_IMG
  zh: '![](059fig01_alt.jpg)'
- en: Numbers can have more than one bit turned on as well; for example, 20 is `00010100`
    in binary, and for our application that would mean we wanted to store the message
    in databases 3 and 5.
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 数字可以有多个位被激活；例如，20在二进制中表示为`00010100`，对于我们的应用程序来说，这意味着我们想要在数据库3和5中存储消息。
- en: So how do we test to see which bits are turned on for any given number? To solve
    this, we can use a *bitmask*. A bitmask represents the bit pattern we’re interested
    in testing. For example, if we were interested in finding out whether we should
    store some data in database 5, we could create a bitmask that has the fifth bit
    turned on. In binary, this would look like `00010000`, which is the number 32
    (or `0x20` in hex notation).
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何测试任何给定数字的哪些位被激活了呢？为了解决这个问题，我们可以使用一个位掩码。位掩码代表我们感兴趣的测试的位模式。例如，如果我们想知道是否应该在数据库5中存储一些数据，我们可以创建一个第五位被激活的位掩码。在二进制中，这将看起来像`00010000`，这是数字32（或十六进制表示为`0x20`）。
- en: 'We then have to test our bitmask against a value, and JavaScript includes various
    bitwise operators^([[8](#ch03fn08)]) to do this. One is the `&` (bitwise AND)
    operator. The `&` operator behaves similarly to the `&&` operator, but instead
    of testing for two conditions to be true, it tests for two bits to be on (have
    ones and not zeros) and keeps the bits on (or one) where that’s the case:'
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来必须测试我们的位掩码与一个值，JavaScript 包含各种位运算符^([[8](#ch03fn08)]) 来完成这个任务。其中一个是 `&`（位与）运算符。`&`
    运算符的行为类似于 `&&` 运算符，但它不是测试两个条件都为真，而是测试两个位都打开（有 1 而不是 0）并且在该情况下保持位打开（或 1）：
- en: ⁸ See [https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Operators/Bitwise_Operators](https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Operators/Bitwise_Operators).
  id: totrans-788
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁸ 查看 [https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Operators/Bitwise_Operators](https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Operators/Bitwise_Operators)。
- en: '[PRE35]'
  id: totrans-789
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Bit position 5 was on for both values, so it remains when using `&`. Armed
    with this knowledge, we can see that a value compared with the bitmask *will be
    the bitmask* if it has the same bit or bits turned on. With this information,
    we can set up a simple conditional to test:'
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: 两个值都打开了位位置 5，所以使用 `&` 时它仍然保持打开状态。有了这个知识，我们可以看到，如果一个值与位掩码进行比较，并且它有相同的位或位打开，那么它将是位掩码。有了这个信息，我们可以设置一个简单的条件来测试：
- en: '[PRE36]'
  id: totrans-791
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: It’s important that the `&` expression be surrounded by parentheses; otherwise,
    the equality of the bitmasks would be checked first because of operator precedence.^([[9](#ch03fn09)])
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: 很重要，`&` 表达式必须被括号包围；否则，由于操作符优先级，会首先检查位掩码的相等性.^([[9](#ch03fn09)])
- en: ⁹ See [https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Operators/Operator_Precedence](https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Operators/Operator_Precedence).
  id: totrans-793
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ⁹ 查看 [https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Operators/Operator_Precedence](https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Operators/Operator_Precedence)。
- en: To test the first byte received in our binary protocol, we’ll want to set up
    a list of bitmasks that correspond with the indexes of our databases. If the bitmask
    matches, we know the database at that index will need the data written to it.
    The “on” bits for every position are an array
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试我们二进制协议中接收到的第一个字节，我们想要设置一个与我们的数据库索引相对应的位掩码列表。如果位掩码匹配，我们知道该索引的数据库将需要写入数据。每个位置的“打开”位是一个数组
- en: '[PRE37]'
  id: totrans-795
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'which corresponds to this:'
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: 这对应于：
- en: '[PRE38]'
  id: totrans-797
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now we know that if a byte matches `1` in our bitmasks array, it will match
    database 1 or array position 0\. We can set up a simple loop to test each bitmask
    against the value of the first byte:'
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道，如果一个字节在我们的位掩码数组中匹配 `1`，它将匹配数据库 1 或数组位置 0。我们可以设置一个简单的循环来测试每个位掩码与第一个字节的值：
- en: '![](060fig01_alt.jpg)'
  id: totrans-799
  prefs: []
  type: TYPE_IMG
  zh: '![](060fig01_alt.jpg)'
- en: Working with bits can be tricky at first, but once you understand more about
    how they work, they become more manageable. So far all of what we’ve covered is
    available not only in Node, but in browser JavaScript too. We’ve made it far enough
    to determine which database we should put our incoming data in; we still have
    to find out which key to store the data in.
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: 在一开始处理位可能很棘手，但一旦你更了解它们是如何工作的，它们就变得更容易管理。到目前为止，我们所涵盖的所有内容不仅可在 Node 中使用，也可在浏览器
    JavaScript 中使用。我们已经足够远，可以确定我们应该将我们的传入数据放在哪个数据库中；我们仍然需要找出应该将数据存储在哪个键中。
- en: Looking up the key to store the data
  id: totrans-801
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 查找存储数据的键
- en: This is the easiest part of our example, because you’ve already learned this
    from the previous technique. Before we begin, let’s look at the relevant part
    of the specification defined earlier in [table 3.4](#ch03table04).
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的例子中最简单的一部分，因为你已经从之前的技术中学到了这一点。在我们开始之前，让我们看看之前在 [表 3.4](#ch03table04) 中定义的规范的相关部分。
- en: '| Byte | Contents | Description |'
  id: totrans-803
  prefs: []
  type: TYPE_TB
  zh: '| 字节 | 内容 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-804
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| 1 | 1 byte | An unsigned integer of one byte (0–255) used as the database
    key to store the data in. |'
  id: totrans-805
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1 字节 | 一个字节的未签名整数（0–255），用作数据库键来存储数据。|'
- en: 'We know we’ll be receiving at byte position 1 an unsigned integer of one byte
    (0-255) that will be used as a database key to store the data in. We purposely
    set up the database to be a multidimensional array where the first dimension is
    the databases. Now we can use the second dimension as a place to store the keys
    and values, and since the keys are numbers, an array will work.^([[10](#ch03fn10)])
    Let’s illustrate to make this more concrete. Here’s what storing the value `''foo''`
    inside the first and third databases at key `0` would look like:'
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道我们将在字节位置1接收到一个字节的无符号整数（0-255），它将被用作数据库键来存储数据。我们故意将数据库设置为一个多维数组，其中第一个维度是数据库。现在我们可以使用第二个维度作为存储键和值的地方，因为键是数字，所以数组可以工作.^([10])让我们通过一个例子来说明这一点，以下是存储在第一个和第三个数据库中键`0`的值`'foo'`的情况：
- en: ^(10) Although there are more-ideal alternatives coming in ECMAScript 6.
  id: totrans-807
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([10])尽管在ECMAScript 6中出现了更理想的替代方案。
- en: '[PRE39]'
  id: totrans-808
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'To get the key value out of position 1, we can use the hopefully now familiar
    `readUInt8` method:'
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: 要从位置1获取键值，我们可以使用现在可能已经熟悉的`readUInt8`方法：
- en: '![](061fig01.jpg)'
  id: totrans-810
  prefs: []
  type: TYPE_IMG
  zh: '![](061fig01.jpg)'
- en: 'Let’s add that to our previous main code sample we’re building:'
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将其添加到我们之前构建的主要代码示例中：
- en: '![](061fig02_alt.jpg)'
  id: totrans-812
  prefs: []
  type: TYPE_IMG
  zh: '![](061fig02_alt.jpg)'
- en: Now that we’re able to parse the database(s) and the keys within those database(s),
    we can get to parsing the actual data to store.
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够解析数据库及其中的键，我们可以开始解析实际要存储的数据。
- en: Inflating data with zlib
  id: totrans-814
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用zlib解压缩数据
- en: It’s a smart idea to compress string/ASCII/UTF-8 data when sending it across
    the wire, as compression can really cut down on bandwidth usage. In our simple
    database protocol, we assume that the data we get to store has been compressed;
    let’s look at the specification to see the relevant description.
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: 在通过网络发送字符串/ASCII/UTF-8数据时进行压缩是一个明智的想法，因为压缩可以真正减少带宽的使用。在我们的简单数据库协议中，我们假设要存储的数据已经被压缩了；让我们查看规范以了解相关描述。
- en: 'Node includes a built-in `zlib` module that exposes `deflate` (compress) and
    `inflate` (uncompress) methods. It also includes gzip compression. To avoid getting
    malformed messages, we can check that the received message was indeed properly
    compressed, and if not, we’ll refuse to inflate it. Typically, the first byte
    of zlib “deflated” data is `0x78`,^([[11](#ch03fn11)]) so we can test for that
    accordingly:'
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: Node包含一个内置的`zlib`模块，该模块公开了`deflate`（压缩）和`inflate`（解压缩）方法。它还包括gzip压缩。为了避免接收到格式不正确的消息，我们可以检查接收到的消息确实已经正确压缩，如果没有，我们将拒绝解压缩它。通常，zlib“deflated”数据的第一个字节是`0x78`^([11](#ch03fn11))，因此我们可以相应地进行测试：
- en: ^(11) A more robust implementation should do more checks; see [http://tools.ietf.org/html/rfc6713](http://tools.ietf.org/html/rfc6713).
  id: totrans-817
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ^([11])一个更健壮的实现应该进行更多的检查；请参阅[http://tools.ietf.org/html/rfc6713](http://tools.ietf.org/html/rfc6713)。
- en: '![](062fig01_alt.jpg)'
  id: totrans-818
  prefs: []
  type: TYPE_IMG
  zh: '![](062fig01_alt.jpg)'
- en: 'Now that we know that we’re most likely dealing with deflated data, we can
    inflate it using `zlib.inflate`. We’ll also need to use `buf.slice()` to get just
    the data portion of our message (since leaving the first two bytes would cause
    an error):'
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道我们很可能会处理压缩数据，我们可以使用`zlib.inflate`来解压缩它。我们还需要使用`buf.slice()`来获取消息的数据部分（因为留下前两个字节会导致错误）：
- en: '![](062fig02_alt.jpg)'
  id: totrans-820
  prefs: []
  type: TYPE_IMG
  zh: '![](062fig02_alt.jpg)'
- en: 'We have everything we need to store some data in our database using our simple
    database protocol. Let’s put all the components together:'
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经拥有了使用我们的简单数据库协议在数据库中存储数据的所有必要条件。让我们将所有组件组合起来：
- en: '![](062fig03_alt.jpg)'
  id: totrans-822
  prefs: []
  type: TYPE_IMG
  zh: '![](062fig03_alt.jpg)'
- en: 'Now we have the code in place to store some data. We could generate a message
    by using the following:'
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了存储一些数据的代码。我们可以通过以下方式生成消息：
- en: '![](063fig01_alt.jpg)'
  id: totrans-824
  prefs: []
  type: TYPE_IMG
  zh: '![](063fig01_alt.jpg)'
- en: We could write an example that sends messages over TCP and do more error handling.
    But let’s leave that as an exercise for you to tackle as you learn about networking
    in Node in a later chapter.
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以编写一个示例，通过TCP发送消息并进行更多的错误处理。但让我们把这留给你在后面的章节中学习Node网络时作为练习来处理。
- en: 3.4\. Summary
  id: totrans-826
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4. 摘要
- en: In this chapter you learned about buffers and how to turn buffers into different
    encoded strings using the `toString` method. We dove into the complicated task
    of turning a binary file into something more usable using the `Buffer` API. Lastly,
    we had some fun creating our own protocol and learning about bitmasks and compression.
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了关于缓冲区的内容以及如何使用`toString`方法将缓冲区转换为不同的编码字符串。我们深入探讨了使用`Buffer` API将二进制文件转换为更易用的事物这一复杂任务。最后，我们通过创建自己的协议并学习位掩码和压缩来享受了一些乐趣。
- en: We covered some common uses of buffers in Node, varying in difficulty to hopefully
    make you more comfortable using them and making the most of them. Go forth and
    tackle a binary format conversion and publish your work on NPM, or maybe a protocol
    that better fits your business needs is waiting to be written.
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在Node中介绍了缓冲区的一些常见用法，难度各异，希望这能让你更舒适地使用它们，并充分利用它们。去尝试进行二进制格式转换，并在NPM上发布你的作品，或者可能有一个更适合你业务需求的协议正在等待被编写。
- en: In the next chapter we’ll look at another core part of Node—events.
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨Node的另一个核心部分——事件。
- en: 'Chapter 4\. Events: Mastering EventEmitter and beyond'
  id: totrans-830
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第四章：事件：精通`EventEmitter`及其他
- en: '*This chapter covers*'
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Using Node’s EventEmitter module
  id: totrans-832
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Node的`EventEmitter`模块
- en: Managing errors
  id: totrans-833
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理错误
- en: How third-party modules use EventEmitter
  id: totrans-834
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三方模块如何使用`EventEmitter`
- en: How to use domains with events
  id: totrans-835
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用事件与域
- en: Alternatives to EventEmitter
  id: totrans-836
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EventEmitter`的替代方案'
- en: 'Node’s `events` module currently includes just a single class: `EventEmitter`.
    This class is used throughout both Node’s built-in modules and third-party modules.
    It contributes to the overall architecture of many Node programs. Therefore it’s
    important to understand `EventEmitter` and how to use it.'
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: Node的`events`模块目前只包含一个类：`EventEmitter`。这个类在Node的内置模块和第三方模块中都被使用。它对许多Node程序的整体架构做出了贡献。因此，理解`EventEmitter`及其使用方法非常重要。
- en: It’s a simple class, and if you’re familiar with DOM or jQuery events, then
    you shouldn’t have much trouble understanding it. The major consideration when
    using Node is in error handling, and we’ll look at this in [technique 21](#ch04lev2sec3).
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的类，如果你熟悉DOM或jQuery事件，那么你理解起来应该不会有太多困难。在使用Node时，主要考虑的是错误处理，我们将在[技术21](#ch04lev2sec3)中探讨这一点。
- en: '`EventEmitter` can be used in various ways—it’s generally used as a base class
    for solving a wide range of problems, from building network servers to architecting
    application logic. In view of the fact that it’s used as the basis for key classes
    in popular Node modules like Express, learning how it works can be useful for
    writing idiomatic code that plays well alongside existing modules.'
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: '`EventEmitter`可以用各种方式使用——它通常用作解决各种问题的基类，从构建网络服务器到构建应用程序逻辑。鉴于它被用作Express等流行Node模块中关键类的基础，了解它的工作原理对于编写与现有模块良好协作的惯用代码非常有用。'
- en: In this chapter you’ll learn how to use `EventEmitter` to make custom classes,
    and how it’s used within Node and open source modules. You’ll also learn how to
    solve problems found when using `EventEmitter`, and see some alternatives to it.
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何使用`EventEmitter`创建自定义类，以及它在Node和开源模块中的使用方式。你还将学习在使用`EventEmitter`时遇到的问题，并了解一些替代方案。
- en: 4.1\. Basic usage
  id: totrans-841
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1. 基本用法
- en: To use `EventEmitter`, the base class must be inherited from. This section includes
    techniques for inheriting from `EventEmitter` and mixing it into other classes
    that already inherit from another base class.
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`EventEmitter`，必须从基类继承。本节包括从`EventEmitter`继承的技术，以及将其混合到已经从另一个基类继承的其他类中的技术。
- en: Technique 19 Inheriting from EventEmitter
  id: totrans-843
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 技术第19章：从`EventEmitter`继承
- en: This technique demonstrates how to create custom classes based on `EventEmitter`.
    By understanding the principles in this technique, you’ll learn how to use `EventEmitter`,
    and how to better use modules that are built with it.
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术演示了如何基于`EventEmitter`创建自定义类。通过理解这个技术中的原则，你将学会如何使用`EventEmitter`，以及如何更好地使用基于它的模块。
- en: Problem
  id: totrans-845
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: You want to use an event-based approach to solve a problem. You have a class
    that you’d like to operate when asynchronous events occur.
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: 你想使用基于事件的方法来解决一个问题。你有一个类，你希望它在异步事件发生时进行操作。
- en: 'Web, desktop, and mobile user interfaces have one thing in common: they’re
    event-based. Events are a great paradigm for dealing with something inherently
    asynchronous: the input from human beings. To show how `EventEmitter` works, we’ll
    use a music player as an example. It won’t really play music, but the underlying
    concept is a great way to learn how to use events.'
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: Web、桌面和移动用户界面有一个共同点：它们都是基于事件的。事件是处理本质上异步的输入（人类输入）的一个很好的范例。为了展示`EventEmitter`的工作原理，我们将以音乐播放器为例。它实际上不会播放音乐，但这个底层概念是学习如何使用事件的一个很好的方式。
- en: Solution
  id: totrans-848
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案
- en: The canonical example of using events in Node is inheriting from `EventEmitter`.
    This can be done by using a simple prototype class—just remember to call `EventEmitter`’s
    constructor from within your new constructor.
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Node 中使用事件的一个典型例子是从 `EventEmitter` 继承。这可以通过使用一个简单的原型类来实现——只需记住在您的新的构造函数中调用
    `EventEmitter` 的构造函数。
- en: The first listing shows how to inherit from `EventEmitter`.
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
  zh: 第一段代码展示了如何从 `EventEmitter` 继承。
- en: Listing 4.1\. Inheriting from `EventEmitter`
  id: totrans-851
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.1\. 从 `EventEmitter` 继承
- en: '![](065fig01_alt.jpg)'
  id: totrans-852
  prefs: []
  type: TYPE_IMG
  zh: '![图片](065fig01_alt.jpg)'
- en: Discussion
  id: totrans-853
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论部分
- en: The combination of a simple constructor function and `util.inherits` is the
    easiest and most common way to create customized event-based classes. The next
    listing extends the previous listing to show how to emit and bind listeners using
    on.
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
  zh: 简单构造函数和 `util.inherits` 的组合是创建定制事件类最简单、最常见的方式。下一段代码扩展了前面的列表，展示了如何使用 `on` 方法来发射和绑定监听器。
- en: Listing 4.2\. Inheriting from `EventEmitter`
  id: totrans-855
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.2\. 从 `EventEmitter` 继承
- en: '![](ch04ex02-0.jpg)'
  id: totrans-856
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch04ex02-0.jpg)'
- en: '![](ch04ex02-1.jpg)'
  id: totrans-857
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch04ex02-1.jpg)'
- en: This might not seem like much, but suppose we need to do something else when
    `play` is triggered—perhaps the user interface needs to be updated. This can be
    supported simply by adding another listener to the `play` event. The following
    listing shows how to add more listeners.
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来不多，但假设我们需要在 `play` 触发时做其他事情——也许用户界面需要更新。这可以通过简单地向 `play` 事件添加另一个监听器来支持。以下列表展示了如何添加更多监听器。
- en: Listing 4.3\. Adding multiple listeners
  id: totrans-859
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.3\. 添加多个监听器
- en: '![](066fig02_alt.jpg)'
  id: totrans-860
  prefs: []
  type: TYPE_IMG
  zh: '![图片](066fig02_alt.jpg)'
- en: Listeners can be removed as well. emitter.removeListener removes a listener
    for a specific event, whereas emitter.removeAllListeners removes all of them.
    You’ll need to store the listener in a variable to be able to reference it when
    removing a specific listener, which is similar to removing timers with clearTimeout.
    The next listing shows this in action.
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
  zh: 监听器也可以被移除。`emitter.removeListener` 用于移除特定事件的监听器，而 `emitter.removeAllListeners`
    则移除所有监听器。您需要将监听器存储在一个变量中，以便在移除特定监听器时能够引用它，这与使用 `clearTimeout` 移除定时器类似。下一段代码展示了这一过程。
- en: Listing 4.4\. Removing listeners
  id: totrans-862
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.4\. 移除监听器
- en: '![](067fig01.jpg)'
  id: totrans-863
  prefs: []
  type: TYPE_IMG
  zh: '![图片](067fig01.jpg)'
- en: util.inherits works by wrapping around the ES5 method Object.create, which inherits
    the properties from one prototype into another. Node’s implementation also sets
    the superconstructor in the `super_` property. This makes accessing the original
    constructor a lot easier—after using `util.inherits`, your prototype class will
    have access to `EventEmitter` through `YourClass.super_`.
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
  zh: '`util.inherits` 通过包装 ES5 方法 `Object.create` 来工作，它将一个原型中的属性继承到另一个原型中。Node 的实现还设置了
    `super_` 属性中的超构造函数。这使得访问原始构造函数变得容易得多——在 `util.inherits` 使用后，您的原型类将通过 `YourClass.super_`
    访问 `EventEmitter`。'
- en: 'You can also respond to an event once, rather than every time it fires. To
    do that, attach a listener with the once method. This is useful where an event
    can be emitted multiple times, but you only care about it happening a single time.
    For example, you could update [listing 4.3](#ch04ex03) to track if the play event
    has ever been triggered:'
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以只响应一次事件，而不是每次事件触发时都响应。为此，请使用 `once` 方法附加一个监听器。当事件可以多次触发，但您只关心它发生一次时，这很有用。例如，您可以将
    [列表 4.3](#ch04ex03) 更新为跟踪播放事件是否已被触发：
- en: '[PRE40]'
  id: totrans-866
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: When inheriting from `EventEmitter`, it’s a good idea to use `events.EventEmitter
    .call(this)` in your constructor to run `EventEmitter`’s constructor. The reason
    for this is because it’ll attach the instance to a `domain` if domains are being
    used. To learn more about domains, see [technique 22](#ch04lev2sec4).
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: 当从 `EventEmitter` 继承时，在构造函数中使用 `events.EventEmitter.call(this)` 是一个好主意，以运行 `EventEmitter`
    的构造函数。这样做的原因是，如果正在使用域，它将实例附加到 `domain` 上。要了解更多关于域的信息，请参阅[技巧 22](#ch04lev2sec4)。
- en: 'The methods we’ve covered here—on, emit, and removeListener—are fundamental
    to Node development. Once you’ve mastered `EventEmitter`, you’ll find it cropping
    up everywhere: in Node’s built-in modules and beyond. Creating TCP/IP servers
    with `net.createServer` will return a server based on `EventEmitter`, and even
    the `process` global object is an instance of `EventEmitter`. In addition, popular
    modules like `Express` are based around `EventEmitter`—you can actually create
    an Express `app` object and call `app.emit` to send messages around an Express
    project.'
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里介绍的方法——on、emit 和 removeListener——是 Node 开发的基石。一旦你掌握了`EventEmitter`，你会发现它在各个地方都有出现：在
    Node 的内置模块中，以及更远的地方。使用`net.createServer`创建 TCP/IP 服务器将返回一个基于`EventEmitter`的服务器，甚至全局的`process`对象也是一个`EventEmitter`的实例。此外，像`Express`这样的流行模块也是基于`EventEmitter`的——你实际上可以创建一个
    Express 的`app`对象，并调用`app.emit`来在 Express 项目中发送消息。
- en: Technique 20 Mixing in EventEmitter
  id: totrans-869
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 技巧 20 混入 EventEmitter
- en: Sometimes inheritance isn’t the right way to use `EventEmitter`. In these cases,
    mixing in `EventEmitter` may work.
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
  zh: 有时继承并不是使用`EventEmitter`的正确方式。在这些情况下，混合`EventEmitter`可能有效。
- en: Problem
  id: totrans-871
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: This is an alternative option to [technique 19](#ch04lev2sec1). Rather than
    using `EventEmitter` as a base class, it’s possible to copy its methods into another
    class. This is useful when you have an existing class and can’t easily rework
    it to inherit directly from `EventEmitter`.
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: 这是[技巧 19](#ch04lev2sec1)的另一种选择。而不是使用`EventEmitter`作为基类，你可以将其方法复制到另一个类中。当你有一个现有的类并且不能轻易地重新设计它以直接继承自`EventEmitter`时，这很有用。
- en: Solution
  id: totrans-873
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案
- en: Using a for-in loop is sufficient for copying the properties from one `prototype`
    to another. In this way you can copy the necessary properties from `EventEmitter`.
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
  zh: 使用for-in循环足以从`prototype`的一个复制属性到另一个。这样，你可以从`EventEmitter`复制必要的属性。
- en: Discussion
  id: totrans-875
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论
- en: This example might seem a little contrived, but sometimes it really is useful
    to copy `EventEmitter`’s properties rather than inherit from it in the usual way.
    This approach is more akin to a mixin, or multiple inheritance; see this demonstrated
    in the following listing.
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子可能看起来有些牵强，但有时确实有必要复制`EventEmitter`的属性，而不是以通常的方式从它继承。这种方法更类似于混入，或多重继承；如下一列表所示进行演示。
- en: Listing 4.5\. Mixing in `EventEmitter`
  id: totrans-877
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.5. 混入 `EventEmitter`
- en: '![](068fig01_alt.jpg)'
  id: totrans-878
  prefs: []
  type: TYPE_IMG
  zh: '![](068fig01_alt.jpg)'
- en: One example of multiple inheritance in the wild is the Connect framework.^([[1](#ch04fn01)])
    The core `Server` class inherits from multiple sources, and in this case the Connect
    authors have decided to make their own property copying method, shown in the next
    listing.
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
  zh: 野外的多重继承的一个例子是 Connect 框架.^([[1](#ch04fn01)]) 核心的`Server`类从多个来源继承，在这种情况下，Connect
    作者决定创建他们自己的属性复制方法，如下一列表所示。
- en: ¹ See [http://www.senchalabs.org/connect/](http://www.senchalabs.org/connect/).
  id: totrans-880
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹ 查看 [http://www.senchalabs.org/connect/](http://www.senchalabs.org/connect/)。
- en: Listing 4.6\. utils.merge from Connect
  id: totrans-881
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.6. Connect 的 utils.merge
- en: '[PRE41]'
  id: totrans-882
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This technique may be useful when you already have a well-established class
    that could benefit from events, but can’t easily be a direct descendant of `EventEmitter`.
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: 当你已经有了一个可以受益于事件但不容易成为`EventEmitter`直接后代的成熟类时，这种技术可能很有用。
- en: Once you’ve inherited from `EventEmitter` you’ll need to handle errors. The
    next section explores techniques for handling errors generated by `EventEmitter`
    classes.
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你从`EventEmitter`继承，你将需要处理错误。下一节将探讨处理由`EventEmitter`类生成的错误的技术。
- en: 4.2\. Error handling
  id: totrans-885
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2. 错误处理
- en: 'Although most events are treated equally, `error` events are a special case
    and are therefore treated differently. This section looks at two ways of handling
    errors: one attaches a listener to the `error` event, and the other uses domains
    to collect errors from groups of `EventEmitter` instances.'
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管大多数事件都同等对待，但`error`事件是一个特殊情况，因此被不同对待。本节探讨了处理错误的两种方式：一种是将监听器附加到`error`事件上，另一种是使用域从一组`EventEmitter`实例中收集错误。
- en: Technique 21 Managing errors
  id: totrans-887
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 技巧 21 管理错误
- en: Error handling with `EventEmitter` has its own special rules that must be adhered
    to. This technique explains how error handling works.
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`EventEmitter`的错误处理有其自己的特殊规则，必须遵守。这项技术解释了错误处理是如何工作的。
- en: Problem
  id: totrans-889
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: You’re using an `EventEmitter` and want to gracefully handle when errors occur,
    but it keeps raising exceptions.
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
  zh: 你正在使用`EventEmitter`，并希望优雅地处理错误发生的情况，但它不断抛出异常。
- en: Solution
  id: totrans-891
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案
- en: To prevent `EventEmitter` from throwing exceptions whenever an `error` event
    is emitted, add a listener to the `error` event. This can be done with custom
    classes or any standard class that inherits from `EventEmitter`.
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: 要防止 `EventEmitter` 在发出 `error` 事件时抛出异常，请向 `error` 事件添加监听器。这可以通过自定义类或任何继承自 `EventEmitter`
    的标准类来完成。
- en: Discussion
  id: totrans-893
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论
- en: To handle errors, bind a listener to the `error` event. The following listing
    demonstrates this by building on the music player example.
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: 要处理错误，将监听器绑定到 `error` 事件。以下列表通过构建音乐播放器示例来演示这一点。
- en: Listing 4.7\. Event-based errors
  id: totrans-895
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.7\. 基于事件的错误
- en: '![](070fig01_alt.jpg)'
  id: totrans-896
  prefs: []
  type: TYPE_IMG
  zh: '![](070fig01_alt.jpg)'
- en: 'This example is perhaps simple, but it’s useful because it should help you
    realize how `EventEmitter` handles errors. It feels like a special case, and that’s
    because it is. The following excerpt is from the Node documentation:'
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子可能很简单，但它很有用，因为它应该能帮助你意识到 `EventEmitter` 如何处理错误。它感觉像是一个特殊情况，确实如此。以下摘录来自 Node
    文档：
- en: '*When an `EventEmitter` instance experiences an error, the typical action is
    to emit an `error` event. Error events are treated as a special case in Node.
    If there is no listener for it, then the default action is to print a stack trace
    and exit the program.*'
  id: totrans-898
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*当 `EventEmitter` 实例遇到错误时，典型的操作是发出一个 `error` 事件。错误事件在 Node 中被视为特殊情况。如果没有监听器，则默认操作是打印堆栈跟踪并退出程序。*'
- en: You can try this out by removing the `'error'` handler from [listing 4.7](#ch04ex07).
    A stack trace should be displayed in the console.
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过从 [列表 4.7](#ch04ex07) 中移除 `'error'` 处理程序来尝试这个方法。应该在控制台显示堆栈跟踪。
- en: This makes sense semantically—otherwise the absence of an error handler would
    lead to potentially dangerous activity going unnoticed. The event name, or *type*
    as it’s referred to internally, has to appear exactly as `error`—extra spaces,
    punctuation, or uppercase letters won’t be considered an `error` event.
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
  zh: 从语义上看，这样做是有意义的——否则，如果没有错误处理程序，可能会出现潜在危险的活动而未被注意到。事件名称，或称为内部所提到的 *type*，必须恰好为
    `error`——额外的空格、标点符号或大写字母都不会被视为 `error` 事件。
- en: This convention means there’s a great deal of consistency across event-based
    error-handling code. It might be a special case, but it’s one worth paying attention
    to.
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
  zh: 这种约定意味着基于事件的错误处理代码具有很高的一致性。它可能是一个特殊情况，但这是一个值得注意的情况。
- en: Technique 22 Managing errors with domains
  id: totrans-902
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 技巧 22 使用域管理错误
- en: Dealing with errors from multiple instances of `EventEmitter` can feel like
    hard work ... unless domains are used!
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
  zh: 处理多个 `EventEmitter` 实例的错误可能感觉像是一项艰巨的工作 ... 除非使用域！
- en: Problem
  id: totrans-904
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: You’re dealing with multiple non-blocking APIs, but are struggling to effectively
    handle errors.
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
  zh: 你正在处理多个非阻塞 API，但难以有效地处理错误。
- en: Solution
  id: totrans-906
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案
- en: Node’s `domain` module can be used to centralize error handling for a set of
    asynchronous operations, and this includes `EventEmitter` instances that emit
    unhandled `error` events.
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
  zh: Node 的 `domain` 模块可用于集中处理一组异步操作的错误，包括发出未处理的 `error` 事件的 `EventEmitter` 实例。
- en: Discussion
  id: totrans-908
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论
- en: Node’s `domain` API provides a way of wrapping existing non-blocking APIs and
    exceptions with error handlers. This helps centralize error handling, and is particularly
    useful in cases where multiple interdependent I/O operations are being used.
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
  zh: Node 的 `domain` API 提供了一种将现有非阻塞 API 和异常包装在错误处理程序中的方法。这有助于集中处理错误，并在使用多个相互依赖的
    I/O 操作的情况下特别有用。
- en: '[Listing 4.8](#ch04ex08) builds on the music player example by using two `EventEmitter`
    descendants to show how a single error handler can be used to handle errors for
    separate objects.'
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 4.8](#ch04ex08) 通过使用两个 `EventEmitter` 后代构建在音乐播放器示例之上，展示了如何使用单个错误处理程序来处理不同对象的错误。'
- en: Listing 4.8\. Managing errors with `domain`
  id: totrans-911
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.8\. 使用 `domain` 管理错误
- en: '![](ch04ex08-0.jpg)'
  id: totrans-912
  prefs: []
  type: TYPE_IMG
  zh: '![](ch04ex08-0.jpg)'
- en: '![](ch04ex08-1.jpg)'
  id: totrans-913
  prefs: []
  type: TYPE_IMG
  zh: '![](ch04ex08-1.jpg)'
- en: Domains can be used with `EventEmitter` descendants, networking code, and also
    the asynchronous file system methods.
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
  zh: 域可以与 `EventEmitter` 后代、网络代码以及异步文件系统方法一起使用。
- en: To visualize how domains work, imagine that the `domain.run` callback wraps
    around your code, even when the code inside the callback triggers events that
    occur outside of it. Any errors that are thrown will still be caught by the domain.
    [Figure 4.1](#ch04fig01) illustrates this process.
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
  zh: 为了可视化域的工作方式，想象一下 `domain.run` 回调围绕你的代码，即使回调内部的代码触发的事件发生在它之外。任何抛出的错误仍然会被域捕获。[图
    4.1](#ch04fig01) 说明了这个过程。
- en: Figure 4.1\. Domains help catch errors and handle them with an `EventEmitter-style`
    API.
  id: totrans-916
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 4.1\. 域帮助捕获错误并以 `EventEmitter-style` API 处理它们。
- en: '![](04fig01.jpg)'
  id: totrans-917
  prefs: []
  type: TYPE_IMG
  zh: '![图片 04fig01](04fig01.jpg)'
- en: Without a domain, any errors raised using throw could potentially place the
    interpreter in an unknown state. Domains avoid this and help you handle errors
    more gracefully.
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
  zh: 没有域名，使用 `throw` 抛出的任何错误都可能使解释器处于未知状态。域名避免了这种情况，并有助于你更优雅地处理错误。
- en: Now that you know how to inherit from `EventEmitter` and handle errors, you
    should be starting to see all kinds of useful ways that it can be used. The next
    section broadens these techniques by introducing some advanced usage patterns
    and higher-level solutions to program structure issues relating to events.
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了如何从 `EventEmitter` 继承并处理错误，你应该开始看到它可以用到的各种有用的方式。下一节通过介绍一些高级使用模式和解决与事件相关的程序结构问题的更高级解决方案来扩展这些技术。
- en: 4.3\. Advanced patterns
  id: totrans-920
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3\. 高级模式
- en: This section offers some best practice techniques for solving structural issues
    found when using `EventEmitter`.
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
  zh: 本节提供了一些最佳实践技术，用于解决在使用 `EventEmitter` 时发现的结构问题。
- en: Technique 23 Reflection
  id: totrans-922
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 技巧 23 反射
- en: Sometimes you need to dynamically respond to changes to an instance of an `EventEmitter`,
    or query its listeners. This technique explains how to do this.
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你需要动态地响应 `EventEmitter` 实例的变化，或者查询其监听者。这项技术解释了如何做到这一点。
- en: Problem
  id: totrans-924
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: You need to either catch when a listener has been added to an emitter, or query
    the existing listeners.
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要捕获监听者被添加到发射器时的时刻，或者查询现有的监听者。
- en: Solution
  id: totrans-926
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案
- en: To track when listeners are added, `EventEmitter` emits a special event called
    `new-Listener`. Listeners added to this event will receive the event name and
    the listener function.
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟踪监听者的添加，`EventEmitter` 会发出一个特殊事件，称为 `new-Listener`。添加到该事件的监听者将接收到事件名称和监听者函数。
- en: Discussion
  id: totrans-928
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论
- en: In some ways, the difference between writing good Node code and *great* Node
    code comes down to a deep understanding of `EventEmitter`. Being able to correctly
    reflect on `EventEmitter` objects gives rise to a whole range of opportunities
    for creating more flexible and intuitive APIs. One dynamic way of doing this is
    through the `new-Listener` event, emitted when listeners are added using the on
    method. Interestingly, this event is emitted by using `EventEmitter` itself—it’s
    implemented by using emit.
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些方面，编写好的 Node 代码和 *优秀的* Node 代码之间的区别在于对 `EventEmitter` 的深入理解。能够正确地反射 `EventEmitter`
    对象会带来一系列创建更灵活和直观 API 的机会。实现这一点的动态方式之一是通过 `new-Listener` 事件，当使用 `on` 方法添加监听者时发出。有趣的是，这个事件是通过
    `EventEmitter` 本身发出的——它是通过使用 `emit` 实现的。
- en: The next listing shows how to track `newListener` events.
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表展示了如何跟踪 `newListener` 事件。
- en: Listing 4.9\. Keeping tabs on new listeners
  id: totrans-931
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.9\. 跟踪新监听者
- en: '![](073fig01_alt.jpg)'
  id: totrans-932
  prefs: []
  type: TYPE_IMG
  zh: '![图片 073fig01_alt](073fig01_alt.jpg)'
- en: Even though `'a listener'` is never explicitly emitted in this example, the
    `newListener` event will still fire. Since the listener’s callback function is
    passed as well as the event name, this is a great way to create simplified public
    APIs for things that require access to the original listener function. [Listing
    4.10](#ch04ex10) demonstrates this concept by automatically starting a timer when
    listeners for `pulse` events are added.
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在这个例子中 `'a listener'` 没有被明确发出，但 `newListener` 事件仍然会触发。由于监听者的回调函数以及事件名称都被传递，这是为需要访问原始监听函数的事物创建简化公共
    API 的绝佳方式。[列表 4.10](#ch04ex10) 通过在添加 `pulse` 事件的监听者时自动启动计时器来演示这个概念。
- en: Listing 4.10\. Automatically triggering events based on new listeners
  id: totrans-934
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.10\. 基于新监听者自动触发事件
- en: '![](074fig01.jpg)'
  id: totrans-935
  prefs: []
  type: TYPE_IMG
  zh: '![图片 074fig01](074fig01.jpg)'
- en: We can go a step further and query `EventEmitter` objects about their listeners
    by calling `emitter.listeners(event)`. A list of *all* listeners can’t be returned
    in one go, though. The entire list is technically available within the `this._events`
    object, but this property should be considered private. The listeners method currently
    returns an `Array` instance. This could be used to iterate over multiple listeners
    if several have been added to a given event—perhaps to remove them at the end
    of an asynchronous process, or simply to check if any listeners have been added.
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以更进一步，通过调用 `emitter.listeners(event)` 来查询 `EventEmitter` 对象的监听者。一次无法返回所有监听者列表。整个列表在技术上在
    `this._events` 对象中是可用的，但这个属性应被视为私有。监听者方法目前返回一个 `Array` 实例。如果给定的事件添加了多个监听者，这可以用来迭代多个监听者——可能是为了在异步过程结束时移除它们，或者简单地检查是否添加了任何监听者。
- en: In cases where an array of events is available, the listeners method will effectively
    return `this._events[type].slice(0)`. Calling slice on an array is a JavaScript
    shortcut for creating a *copy* of an array. The documentation states that this
    behavior may change in the future, so if you really want to create a copy of attached
    listeners, then call slice yourself to ensure you really get a copy and not a
    reference to a data structure within the emitter instance.
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
  zh: 在有事件数组可用的情况下，`listeners` 方法将有效地返回 `this._events[type].slice(0)`。在数组上调用 slice
    是创建数组 *副本* 的 JavaScript 快捷方式。文档中提到，这种行为可能会在未来改变，所以如果你真的想创建附加监听器的副本，那么请自己调用 slice
    以确保你真的得到一个副本，而不是发射器实例中的数据结构的引用。
- en: '[Listing 4.11](#ch04ex11) adds a stop method to the `Pulsar` class. When `stop`
    is called, it checks to see if there are any listeners; otherwise, it raises an
    error. Checking for listeners is a good way to prevent incorrect usage, but you
    don’t have to do this in your own code.'
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 4.11](#ch04ex11) 为 `Pulsar` 类添加了一个 `stop` 方法。当调用 `stop` 时，它会检查是否有任何监听器；如果没有，则抛出错误。检查监听器是防止错误使用的好方法，但你不必在自己的代码中这样做。'
- en: Listing 4.11\. Querying listeners
  id: totrans-939
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.11\. 查询监听器
- en: '[PRE42]'
  id: totrans-940
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Technique 24 Detecting and exploiting EventEmitter
  id: totrans-941
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 技巧 24 检测和利用 EventEmitter
- en: A lot of successful open source Node modules are built on `EventEmitter`. It’s
    useful to spot where `EventEmitter` is being used and to know how to take advantage
    of it.
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
  zh: 许多成功的开源 Node 模块都是基于 `EventEmitter` 构建的。了解 `EventEmitter` 被使用的地方以及如何利用它是有用的。
- en: Problem
  id: totrans-943
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: You’re working on a large project with several components and want to communicate
    between them.
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
  zh: 你正在处理一个包含多个组件的大型项目，并希望在它们之间进行通信。
- en: Solution
  id: totrans-945
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案
- en: Look for the emit and on methods whenever you’re using either Node’s standard
    modules or open source libraries. For example, the Express `app` object has these
    methods, and they’re great for sending messages within an application.
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 Node 的标准模块或开源库时，寻找 emit 和 on 方法。例如，Express 的 `app` 对象有这些方法，它们非常适合在应用程序内发送消息。
- en: Discussion
  id: totrans-947
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论
- en: Usually when you’re working on a large project, there’s a major component that’s
    central to your problem domain. If you’re building a web application with Express,
    then the `app` object is one such component. A quick check of the source shows
    that this object mixes in `EventEmitter`, so you can take advantage of events
    to communicate between the disparate components within your project.
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
  zh: 通常当你在一个大型项目中工作时，有一个主要组件是问题域的核心。如果你使用 Express 构建一个 Web 应用程序，那么 `app` 对象就是这样一种组件。快速检查源代码显示，该对象混合了
    `EventEmitter`，因此你可以利用事件在项目中的不同组件之间进行通信。
- en: '[Listing 4.12](#ch04ex12) shows an Express-based example where a listener is
    bound to an event, and then the event is emitted when a specific route is accessed.'
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 4.12](#ch04ex12) 展示了一个基于 Express 的示例，其中监听器绑定到事件上，然后当访问特定路由时，事件被触发。'
- en: Listing 4.12\. Reusing `EventEmitter` in Express
  id: totrans-950
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.12\. 在 Express 中重用 `EventEmitter`
- en: '![](075fig01.jpg)'
  id: totrans-951
  prefs: []
  type: TYPE_IMG
  zh: '![](075fig01.jpg)'
- en: This might seem contrived, but what if the route were defined in another file?
    In this case, you wouldn’t have access to the `app` object, unless it was defined
    as a global.
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来有些牵强，但如果路由定义在另一个文件中呢？在这种情况下，除非它被定义为全局变量，否则你无法访问 `app` 对象。
- en: Another example of a popular project built on `EventEmitter` is the Node Redis
    client ([https://npmjs.org/package/redis](https://npmjs.org/package/redis)). Instances
    of `RedisClient` inherit from `EventEmitter`. This allows you to hook into useful
    events, like the `error` event, as shown in the next listing.
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
  zh: 基于 `EventEmitter` 的另一个流行项目是 Node Redis 客户端 ([https://npmjs.org/package/redis](https://npmjs.org/package/redis))。`RedisClient`
    实例继承自 `EventEmitter`。这允许你挂钩到有用的事件，如 `error` 事件，如下一列表所示。
- en: Listing 4.13\. Reusing `EventEmitter` in the `redis` module
  id: totrans-954
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.13\. 在 `redis` 模块中重用 `EventEmitter`
- en: '![](076fig01_alt.jpg)'
  id: totrans-955
  prefs: []
  type: TYPE_IMG
  zh: '![](076fig01_alt.jpg)'
- en: In cases where the route separation technique has been used to store routes
    in several files, you can actually send events by calling `res.app.emit(event)`.
    This allows route handlers to communicate back to the `app` object itself.
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用路由分离技术将路由存储在几个文件中的情况下，你实际上可以通过调用 `res.app.emit(event)` 来发送事件。这允许路由处理程序将消息发送回
    `app` 对象本身。
- en: This might seem like a highly specific Express example, but other popular open
    source modules are also built on `EventEmitter`—just look for the emit and on
    methods. Remember that Node’s internal modules like the `process` object and net.create-Server
    inherit from `EventEmitter`, and well-written open source modules tend to inherit
    from these modules as well. This means there’s a huge amount of scope for event-based
    solutions to architectural problems.
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来像一个非常具体的 Express 示例，但其他流行的开源模块也是基于 `EventEmitter` 构建的——只需寻找 emit 和 on
    方法。记住，Node 的内部模块，如 `process` 对象和 net.create-Server 继承自 `EventEmitter`，而编写良好的开源模块通常也会从这些模块继承。这意味着基于事件解决架构问题的范围非常广泛。
- en: This example also highlights another benefit of building projects around `EventEmitter`—asynchronous
    processes can respond as soon as possible. If the `hello-alert` event performs
    a very slow operation like sending an email, the person browsing the page might
    not want to wait for this process to finish. In this case, you can render the
    requested page while effectively performing a slower operation in the background.
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子还突出了围绕 `EventEmitter` 构建项目的另一个好处——异步过程可以尽快响应。如果 `hello-alert` 事件执行一个非常慢的操作，比如发送电子邮件，那么浏览页面的用户可能不想等待这个过程完成。在这种情况下，你可以在后台有效地执行较慢的操作的同时渲染请求的页面。
- en: The Node Redis client makes excellent use of `EventEmitter` and the author has
    written documentation for what each of the methods do. This is a good idea—if
    somebody joins your project, they may find it hard to get an overall picture of
    the events that are being used.
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
  zh: Node Redis 客户端对 `EventEmitter` 的使用非常出色，作者为每个方法编写了文档，说明了它们的功能。这是一个好主意——如果有人加入你的项目，他们可能会发现很难全面了解正在使用的事件。
- en: Technique 25 Categorizing event names
  id: totrans-960
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 技巧 25 对事件名称进行分类
- en: Some projects just have too many events. This technique shows how to deal with
    bugs caused by mistyped event names.
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
  zh: 一些项目的事件实在太多了。这个技巧展示了如何处理由输入错误的事件名称引起的错误。
- en: Problem
  id: totrans-962
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: You’re losing track of the events in your program, and are concerned that it
    may be too easy to write an incorrect event name somewhere causing a difficult-to-track
    bug.
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
  zh: 你正在失去对程序中事件的跟踪，并且担心可能太容易在某个地方写错事件名称，从而造成难以追踪的错误。
- en: Solution
  id: totrans-964
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案
- en: The easiest way to solve this problem is to use an object to act as a central
    dictionary for all of the event names. This creates a centralized location of
    each event in the project.
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的最简单方法就是使用一个对象作为所有事件名称的中心字典。这为项目中的每个事件创建了一个集中位置。
- en: Discussion
  id: totrans-966
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论
- en: It’s hard to keep track of event names littered throughout a project. One way
    to manage this is to keep each event name in one place. [Listing 4.14](#ch04ex14)
    demonstrates using an object to categorize event names, based on the previous
    examples in this chapter.
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
  zh: 跟踪散布在整个项目中的事件名称很困难。一种管理方法是保持每个事件名称在一个地方。[列表 4.14](#ch04ex14) 展示了如何使用对象根据本章前面的示例对事件名称进行分类。
- en: Listing 4.14\. Categorizing event names using an object
  id: totrans-968
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.14\. 使用对象对事件名称进行分类
- en: '![](077fig01_alt.jpg)'
  id: totrans-969
  prefs: []
  type: TYPE_IMG
  zh: '![图片](077fig01_alt.jpg)'
- en: Although `EventEmitter` is an integral part of Node’s standard library, and
    an elegant solution to many problems, it can be the source of a lot of bugs in
    larger projects where people may forget the name of a given event. One way around
    this is to avoid writing events as strings. Instead, an object can be used with
    properties that refer to the event name strings.
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `EventEmitter` 是 Node 标准库的一个基本组成部分，并且是许多问题的优雅解决方案，但它可能是大型项目中许多错误的来源，因为人们可能会忘记特定事件的名称。一种解决方法是避免将事件作为字符串编写。相反，可以使用一个对象，其属性引用事件名称字符串。
- en: If you’re writing a reusable, open source module, you should consider making
    this part of the public API so it’s easy for people to get a centralized list
    of event names.
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在编写可重用的开源模块，你应该考虑将其作为公共 API 的一部分，这样人们就可以轻松地获得事件名称的集中列表。
- en: There are other observer pattern implementations that avoid using string event
    names to effectively type check events. In the next technique we’ll look at a
    few that are available through npm.
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
  zh: 有其他观察者模式实现避免了使用字符串事件名称来有效地进行事件类型检查。在下一个技巧中，我们将探讨一些通过 npm 可用的实现。
- en: Although `EventEmitter` provides a wide array of solutions when working on Node
    projects, there are alternative implementations out there. The next section includes
    some popular alternatives.
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `EventEmitter` 在 Node 项目中提供了广泛的解决方案，但还有其他实现。下一节将介绍一些流行的替代方案。
- en: 4.4\. Third-party modules and extensions
  id: totrans-974
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.4\. 第三方模块和扩展
- en: '`EventEmitter` is essentially an *observer pattern* implementation. There are
    other interpretations of this pattern, which can help scale Node programs to run
    across several processes or over a network. The next technique introduces some
    of the more popular alternatives created by the Node community.'
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
  zh: '`EventEmitter` 实质上是一个 *观察者模式* 实现。这个模式还有其他解释，可以帮助将 Node 程序扩展到多个进程或网络中运行。接下来的技巧介绍了
    Node 社区创建的一些更流行的替代方案。'
- en: Technique 26 Alternatives to EventEmitter
  id: totrans-976
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 技巧 26 替代 EventEmitter
- en: '`EventEmitter` has a great API and works well in Node programs, but sometimes
    a problem requires a slightly different solution. This technique explores some
    alternatives to `EventEmitter`.'
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
  zh: '`EventEmitter` 拥有一个优秀的 API，并且在 Node 程序中运行良好，但有时一个问题需要稍微不同的解决方案。这项技术探讨了 `EventEmitter`
    的几种替代方案。'
- en: Problem
  id: totrans-978
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: You’re trying to solve a problem that doesn’t quite fit `EventEmitter`.
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
  zh: 你正在尝试解决的问题并不完全适合 `EventEmitter`。
- en: Solution
  id: totrans-980
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Depending on the exact nature of the problem you’re trying to solve, there
    are several alternatives to `EventEmitter`: publish/subscribe, AMQP, and `js-signals`
    are some popular alternatives with good support in Node.'
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你试图解决的问题的确切性质，有几种 `EventEmitter` 的替代方案：发布/订阅、AMQP 和 `js-signals` 是一些在 Node
    中有良好支持的流行替代方案。
- en: Discussion
  id: totrans-982
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论
- en: The `EventEmitter` class is an implementation of the *observer pattern*. A related
    pattern is publish/subscribe, where publishers send messages that are characterized
    into classes to subscribers without knowing the details of the subscribers themselves.
  id: totrans-983
  prefs: []
  type: TYPE_NORMAL
  zh: '`EventEmitter` 类是 *观察者模式* 的一个实现。一个相关的模式是发布/订阅，其中发布者发送消息，这些消息被分类到类中，发送给订阅者，而无需知道订阅者的详细信息。'
- en: The publish/subscribe pattern is often useful in cases where horizontal scaling
    is required. If you need to run multiple Node processes on multiple servers, then
    technologies like AMQP and ØMQ can help implement this. They’re both specifically
    designed to solve this class of problem, but may not be as convenient as using
    the Redis publish/subscribe API if you’re already using Redis.
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
  zh: 发布/订阅模式在需要横向扩展的情况下通常很有用。如果你需要在多台服务器上运行多个 Node 进程，那么像 AMQP 和 ØMQ 这样的技术可以帮助实现这一点。它们都是专门设计来解决这个问题类的，但如果你已经在使用
    Redis，那么可能不如使用 Redis 发布/订阅 API 方便。
- en: If you need to horizontally scale across a distributed cluster, then an AMQP
    implementation like RabbitMQ ([http://www.rabbitmq.com/](http://www.rabbitmq.com/))
    will work well. The `rabbitmq-nodejs-client` ([https://github.com/adrai/rabbitmq-nodejs-client](https://github.com/adrai/rabbitmq-nodejs-client))
    module has a publish/subscribe API. The following listing shows a simple example
    of RabbitMQ in Node.
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要在分布式集群中进行横向扩展，那么像 RabbitMQ ([http://www.rabbitmq.com/](http://www.rabbitmq.com/))
    这样的 AMQP 实现将运行良好。`rabbitmq-nodejs-client` ([https://github.com/adrai/rabbitmq-nodejs-client](https://github.com/adrai/rabbitmq-nodejs-client))
    模块提供了一个发布/订阅 API。下面的列表展示了 Node 中 RabbitMQ 的一个简单示例。
- en: Listing 4.15\. Using RabbitMQ with Node
  id: totrans-986
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.15\. 在 Node 中使用 RabbitMQ
- en: '![](079fig01_alt.jpg)'
  id: totrans-987
  prefs: []
  type: TYPE_IMG
  zh: '![](079fig01_alt.jpg)'
- en: ØMQ ([http://www.zeromq.org/](http://www.zeromq.org/)) is more popular in the
    Node community. Justin Tulloss and TJ Holowaychuk’s `zeromq.node` module ([https://github.com/JustinTulloss/zeromq.node](https://github.com/JustinTulloss/zeromq.node))
    is a popular binding. The next listing shows just how simple this API is.
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
  zh: ØMQ ([http://www.zeromq.org/](http://www.zeromq.org/)) 在 Node 社区中更为流行。Justin
    Tulloss 和 TJ Holowaychuk 的 `zeromq.node` 模块 ([https://github.com/JustinTulloss/zeromq.node](https://github.com/JustinTulloss/zeromq.node))
    是一个流行的绑定。下面的列表展示了这个 API 的简单性。
- en: Listing 4.16\. Using ØMQ with Node
  id: totrans-989
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.16\. 在 Node 中使用 ØMQ
- en: '[PRE43]'
  id: totrans-990
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: If you’re already using Redis with Node, then it’s worth trying out the Pub/Sub
    API ([http://redis.io/topics/pubsub](http://redis.io/topics/pubsub)). [Listing
    4.17](#ch04ex17) shows an example of this using the Node Redis client ([https://github.com/mranney/node_redis](https://github.com/mranney/node_redis)).
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经在 Node 中使用 Redis，那么尝试一下 Pub/Sub API ([http://redis.io/topics/pubsub](http://redis.io/topics/pubsub))
    是值得的。[列表 4.17](#ch04ex17) 展示了使用 Node Redis 客户端 ([https://github.com/mranney/node_redis](https://github.com/mranney/node_redis))
    的一个示例。
- en: Listing 4.17\. Using Redis Pub/Sub with Node
  id: totrans-992
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 4.17\. 在 Node 中使用 Redis Pub/Sub
- en: '![](079fig02_alt.jpg)'
  id: totrans-993
  prefs: []
  type: TYPE_IMG
  zh: '![](079fig02_alt.jpg)'
- en: Finally, if publish/subscribe isn’t what you’re looking for, then you may want
    to take a look at `js-signals` ([https://github.com/millermedeiros/js-signals](https://github.com/millermedeiros/js-signals)).
    This module is a messaging system that doesn’t use strings for the signal names,
    and dispatching or listening to events that don’t yet exist will raise errors.
  id: totrans-994
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果你不寻找发布/订阅，那么你可能想看看`js-signals`([https://github.com/millermedeiros/js-signals](https://github.com/millermedeiros/js-signals))。此模块是一个不使用字符串作为信号名的消息系统，对尚未存在的事件进行分发或监听将引发错误。
- en: '[Listing 4.18](#ch04ex18) shows how `js-signals` sends and receives messages.
    Notice how signals are properties of an object, rather than strings, and that
    listeners can receive an arbitrary number of arguments.'
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表4.18](#ch04ex18)显示了`js-signals`如何发送和接收消息。注意信号是对象的属性，而不是字符串，并且监听器可以接收任意数量的参数。'
- en: Listing 4.18\. Using Redis Pub/Sub with Node
  id: totrans-996
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表4.18\. 使用Redis Pub/Sub与Node
- en: '![](080fig01_alt.jpg)'
  id: totrans-997
  prefs: []
  type: TYPE_IMG
  zh: '![](080fig01_alt.jpg)'
- en: '`js-signals` provides a way of using properties for signal names, as mentioned
    in [technique 25](#ch04lev2sec7), but in this case the module will raise an error
    if an unregistered listener is dispatched or bound to. This approach is more like
    “strongly typed” events, and is very different from most publish/subscribe and
    event observer implementations.'
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
  zh: 如第25项技术[technique 25](#ch04lev2sec7)中提到的，`js-signals`提供了一种使用属性作为信号名的方法，但在此情况下，如果未注册的监听器被分发或绑定，模块将引发错误。这种方法更像是“强类型”事件，与大多数发布/订阅和事件观察器实现非常不同。
- en: 4.5\. Summary
  id: totrans-999
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.5\. 摘要
- en: In this chapter you’ve learned how `EventEmitter` is used through inheritance
    and multiple inheritance, and how to manage errors with and without domains. You’ve
    also seen how to centralize event names, how open source modules build on `EventEmitter`,
    and some alternative solutions.
  id: totrans-1000
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何通过继承和多继承使用`EventEmitter`，以及如何在有和无域的情况下管理错误。你还看到了如何集中管理事件名，开源模块如何建立在`EventEmitter`之上，以及一些替代方案。
- en: What you should take away from this chapter is that although `EventEmitter`
    is usually used as a base class for inheritance, it’s also possible to mix it
    into existing classes. Also, although `EventEmitter` is a great solution to many
    problems and used throughout Node’s internals, sometimes other solutions are more
    optimal. For example, if you’re using Redis, then you can take advantage of its
    publish/subscribe implementation. Finally, `EventEmitter` isn’t without its problems;
    managing large amounts of event names can cause bugs, and now you know how to
    avoid this by using an object with properties that act as event names.
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该从本章中吸取的教训是，尽管`EventEmitter`通常用作继承的基类，但它也可以混合到现有类中。此外，尽管`EventEmitter`是许多问题的绝佳解决方案，并在Node的内部结构中得到广泛应用，但有时其他解决方案可能更优。例如，如果你使用Redis，那么你可以利用其发布/订阅实现。最后，`EventEmitter`并非没有问题；管理大量事件名可能导致错误，而现在你知道如何通过使用作为事件名的属性的对象来避免这种情况。
- en: 'In the next chapter we’ll look at a related topic: streams. Streams are built
    around an event-based API, so you’ll be able to use some of these `EventEmitter`
    techniques there as well.'
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨一个相关主题：流。流是基于事件驱动的API构建的，因此你将能够在那里使用一些这些`EventEmitter`技术。
- en: 'Chapter 5\. Streams: Node’s most powerful and misunderstood feature'
  id: totrans-1003
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第5章\. 流：节点最强大且最被误解的功能
- en: '*This chapter covers*'
  id: totrans-1004
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: What streams are and how to use them
  id: totrans-1005
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流是什么以及如何使用它们
- en: How to use Node’s built-in streaming APIs
  id: totrans-1006
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用Node的内置流API
- en: The stream API used in Node 0.8 and below
  id: totrans-1007
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node 0.8及以下版本中使用的流API
- en: The stream primitive classes bundled since Node 0.10
  id: totrans-1008
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自Node 0.10以来捆绑的流原始类
- en: Strategies for testing streams
  id: totrans-1009
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试流的策略
- en: Streams are an event-based API for managing and modeling data, and are wonderfully
    efficient. By leveraging `EventEmitter` and Node’s non-blocking I/O libraries,
    the `stream` module allows data to be dynamically processed when it’s available,
    and then released when it’s no longer needed.
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
  zh: 流是用于管理和建模数据的事件驱动API，并且非常高效。通过利用`EventEmitter`和Node的非阻塞I/O库，`stream`模块允许在数据可用时动态处理数据，并在不再需要时释放它。
- en: The idea of a stream of data isn’t new, but it’s an important concept and integral
    to Node. After [chapter 4](kindle_split_013.html#ch04), mastering streams is the
    next step on the path to becoming truly competent at Node development.
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
  zh: 数据流的概念并不新鲜，但它是一个重要的概念，并且对Node至关重要。在[第4章](kindle_split_013.html#ch04)之后，掌握流是成为真正Node开发高手道路上的下一步。
- en: 'The `stream` core module provides abstract tools for building event-based stream
    classes. It’s likely that you’ll use modules that implement streams, rather than
    creating your own. But to exploit streams to their fullest, it’s important to
    understand how they really work. This chapter has been designed with that goal
    in mind: understanding streams, working with Node’s built-in streaming APIs, and
    finally creating and testing your own streams. Despite the conceptually abstract
    nature of the `stream` module, once you’ve mastered the major concepts, you’ll
    start to see uses for streams everywhere.'
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
  zh: '`stream` 核心模块提供了构建基于事件的流类的抽象工具。你可能会使用实现流的模块，而不是自己创建。但为了充分利用流，了解它们真正的工作方式非常重要。本章的设计目标就是理解流、使用
    Node 的内置流 API，以及最终创建和测试你自己的流。尽管 `stream` 模块在概念上具有抽象性质，但一旦你掌握了主要概念，你将开始看到流在各个方面的应用。'
- en: The next section provides a high-level overview of streams and addresses the
    two APIs that Node supports as of Node 0.10.
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节提供了对流的概述，并讨论了 Node 0.10 版本支持的两种 API。
- en: 5.1\. Introduction to streams
  id: totrans-1014
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1\. 流简介
- en: In Node, streams are an *abstract interface* adhered to by several different
    objects. When we talk about streams, we’re referring to a way of doing things—in
    a sense, they’re a protocol. Streams can be readable or writable, and are implemented
    with instances of `EventEmitter`—see [chapter 4](kindle_split_013.html#ch04) for
    more on events. Streams provide the means for creating data flows between objects,
    and can be composed with LEGO-like modularity.
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Node 中，流是一个由多个不同对象遵循的 *抽象接口*。当我们谈论流时，我们指的是一种做事的方式——在某种程度上，它们是一种协议。流可以是可读的或可写的，并且使用
    `EventEmitter` 的实例实现——有关事件的内容，请参阅[第 4 章](kindle_split_013.html#ch04)。流提供了在对象之间创建数据流的方法，并且可以像乐高积木一样模块化组合。
- en: 5.1.1\. Types of streams
  id: totrans-1016
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.1.1\. 流的类型
- en: 'Streams always involve I/O of some kind, and they can be classified into groups
    based on the type of I/O they deal with. The following types of streams were taken
    from James Halliday’s `stream-handbook` ([https://github.com/substack/stream-handbook/](https://github.com/substack/stream-handbook/)),
    and will give you an idea of the wide array of things you can do with streams:'
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
  zh: 流总是涉及某种类型的 I/O，并且可以根据它们处理的 I/O 类型进行分组。以下类型的流来自 James Halliday 的 `stream-handbook`
    ([https://github.com/substack/stream-handbook/](https://github.com/substack/stream-handbook/))，将给你一个关于你可以用流做什么的广泛概念：
- en: '***Built-in*** —Many of Node’s core modules implement streaming interfaces;
    for example, `fs.createReadStream`.'
  id: totrans-1018
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***内置*** —Node 的许多核心模块实现了流接口；例如，`fs.createReadStream`。'
- en: '***HTTP*** —Although technically network streams, there are streaming modules
    designed to work with various web technologies.'
  id: totrans-1019
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***HTTP*** —虽然技术上属于网络流，但有一些流模块旨在与各种网络技术一起工作。'
- en: '***Parsers*** —Historically parsers have been implemented using streams. Popular
    third-party modules for Node include XML and JSON parsers.'
  id: totrans-1020
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***解析器*** —历史上解析器一直是使用流实现的。Node 的流行第三方模块包括 XML 和 JSON 解析器。'
- en: '***Browser*** —Node’s event-based streams have been extended to work in browsers,
    offering some unique opportunities for interfacing with client-side code.'
  id: totrans-1021
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***浏览器*** —Node 的事件驱动流已扩展到浏览器中，为与客户端代码的接口提供了独特的机会。'
- en: '***Audio*** —James Halliday has written some novel audio modules that have
    streamable interfaces.'
  id: totrans-1022
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***音频*** —James Halliday 编写了一些具有流接口的创新音频模块。'
- en: '***RPC (Remote Procedure Call)*** —Sending streams over the network is a useful
    way to implement interprocess communication.'
  id: totrans-1023
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***RPC (远程过程调用)*** —通过网络发送流是实现进程间通信的有用方式。'
- en: '***Test*** —There are stream-friendly test libraries, and tools for testing
    streams themselves.'
  id: totrans-1024
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***测试*** —有流友好的测试库，以及用于测试流本身的工具。'
- en: '***Control, meta, and state*** —There are also more abstract uses of streams,
    and modules designed purely for manipulating and managing other streams.'
  id: totrans-1025
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***控制、元数据和状态*** —流还有更抽象的用途，以及专为操作和管理其他流而设计的模块。'
- en: The best way to understand why streams are important is to first consider what
    happens when data is processed without them. Let’s look at this in more detail
    by comparing Node’s asynchronous, synchronous, and stream-based APIs.
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解流为什么重要，首先考虑在没有流的情况下处理数据会发生什么。让我们通过比较 Node 的异步、同步和基于流的 API 来更详细地探讨这一点。
- en: 5.1.2\. When to use streams
  id: totrans-1027
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.1.2\. 何时使用流
- en: When reading a file synchronously with `fs.readFileSync`, the program will block,
    and all of the data will be read to memory. Using `fs.readFile` will prevent the
    program from blocking because it’s an asynchronous method, but it’ll still read
    the entire file into memory.
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`fs.readFileSync`以同步方式读取文件时，程序将会阻塞，并且所有数据都将被读入内存。使用`fs.readFile`将防止程序阻塞，因为它是一个异步方法，但它仍然会将整个文件读入内存。
- en: What if there were a way to tell `fs.readFile` to read a chunk of data into
    memory, process it, and then ask for more data? That’s where streams come in.
  id: totrans-1029
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有一种方法可以告诉`fs.readFile`将数据块读入内存，处理它，然后请求更多数据，那将是溪流的作用所在。
- en: Memory becomes an issue when working with large files—compressed backup archives,
    media files, large log files, and so on. Instead of reading the entire file into
    memory, you could use `fs.read` with a suitable buffer, reading in a specific
    length at a time. Or, preferably, you could use the streams API provided by `fs.createReadStream`.
    [Figure 5.1](#ch05fig01) illustrates how only a chunk of a file is read at a time
    with `fs.createReadStream`, compared to the entire file with `fs.readFile`.
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理大文件时，内存会成为一个问题——例如压缩的备份存档、媒体文件、大型日志文件等。您可以使用带有合适缓冲区的`fs.read`来读取整个文件，一次读取特定长度的数据。或者，更理想的是，您可以使用`fs.createReadStream`提供的流式API。图5.1（[#ch05fig01](#ch05fig01)）说明了使用`fs.createReadStream`一次只读取文件的一部分，与使用`fs.readFile`读取整个文件相比。
- en: Figure 5.1\. Using streamable APIs means I/O operations potentially use less
    memory.
  id: totrans-1031
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.1\. 使用可流式API意味着I/O操作可能使用更少的内存。
- en: '![](05fig01_alt.jpg)'
  id: totrans-1032
  prefs: []
  type: TYPE_IMG
  zh: '![图5.1](05fig01_alt.jpg)'
- en: Streams are asynchronous by design. Rather than reading that entire file into
    memory, a buffer’s worth will be read, the desired operations will be performed,
    and then the result will be written to the output stream. This approach is as
    close to idiomatic Node as you can get. What’s more, streams are implemented with
    plain old JavaScript. Take `fs.createReadStream`—it offers a more scalable solution,
    but ultimately just wraps simple file system operations with a better API.
  id: totrans-1033
  prefs: []
  type: TYPE_NORMAL
  zh: 溪流的设计本身就是异步的。而不是将整个文件读入内存，只会读取一定量的数据（即缓冲区的大小），执行所需的操作，然后将结果写入输出溪流。这种方法几乎可以与Node的惯用方法相媲美。更重要的是，溪流是用普通的JavaScript实现的。以`fs.createReadStream`为例——它提供了一个更可扩展的解决方案，但最终只是用更好的API封装了简单的文件系统操作。
- en: Node’s streaming APIs feel idiomatic, yet streams have been around in computer
    science for a long time. This history is examined briefly in the next section
    to give you some background on where streams come from and where they’re used.
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
  zh: Node的流式API感觉非常符合惯用方法，但溪流在计算机科学中已经存在很长时间了。在下一节中，我们将简要地考察这一历史，以便为您了解溪流的起源和用途提供一些背景信息。
- en: 5.1.3\. History
  id: totrans-1035
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.1.3\. 历史
- en: So where did streams originate? Historically, streams in computer science have
    been used to solve problems similar to streams in Node. For example, in C the
    standard way to represent a file is by using a stream. When a C program starts,
    it has access to the standard I/O streams. The standard I/O streams are also available
    in Node, and can be used to allow programs to work well with large amounts of
    data in the shell.
  id: totrans-1036
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，溪流是从哪里起源的呢？在历史上，计算机科学中的溪流（stream）被用来解决与Node中的溪流类似的问题。例如，在C语言中，表示文件的标准方式是通过使用溪流。当一个C程序启动时，它可以访问标准输入输出溪流。在Node中，标准输入输出溪流也是可用的，并且可以用来允许程序在shell中处理大量数据。
- en: 'Traditionally, streams have been used to implement efficient parsers. This
    has also been the case in Node: the `node-formidable` module ([https://github.com/felixge/node-formidable](https://github.com/felixge/node-formidable))
    is used by Connect to efficiently parse form data with streams, and database modules
    like the Node `redis` module ([https://npmjs.org/package/redis](https://npmjs.org/package/redis))
    use streams to represent the connection to the server and respond by parsing on
    demand.'
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，溪流被用来实现高效的解析器。在Node中也是如此：`node-formidable`模块（[https://github.com/felixge/node-formidable](https://github.com/felixge/node-formidable)）被Connect用来通过溪流高效地解析表单数据，而像Node的`redis`模块（[https://npmjs.org/package/redis](https://npmjs.org/package/redis)）这样的数据库模块则使用溪流来表示与服务器的连接，并通过按需解析来响应。
- en: If you’re familiar with Unix, you’re probably already aware of streams. If you’ve
    used pipes or I/O redirection, then you’ve used streams. You can literally think
    about Node streams as you would Unix pipes—except data is filtered through functions
    instead of command-line programs. The next section explains how streams have evolved
    in Node, up until version 0.10 when they changed significantly.
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉Unix，你可能已经知道流了。如果你使用过管道或I/O重定向，那么你已经使用过流了。你可以将Node流想象成Unix管道——除了数据是通过函数而不是命令行程序过滤外。下一节将解释Node中流的演变，直到0.10版本，那时它们发生了重大变化。
- en: Streams old and new
  id: totrans-1039
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 旧流与新流
- en: Streams are part of Node’s core modules, and as such remain backward compatible
    with earlier versions. As of this writing, Node is at version 0.10, which has
    seen significant changes in the streams API. Though it remains backward compatible,
    the new streams syntax is in some ways stricter than earlier versions, yet ultimately
    more flexible. This boils down to the behavior of `pipe`—pipes must now originate
    from a `Readable` stream and end at a `Writable` stream. The `util.pump` method,
    found in earlier versions of Node, has now been deprecated in favor of the new
    `pipe` semantics.
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
  zh: 流是Node的核心模块的一部分，因此与早期版本保持向后兼容。截至本文撰写时，Node的版本为0.10，其流API已经发生了重大变化。尽管它仍然保持向后兼容，但新的流语法在某些方面比早期版本更严格，但最终更灵活。这归结为`pipe`的行为——管道现在必须从`Readable`流开始，并在`Writable`流结束。在Node早期版本中发现的`util.pump`方法现在已被弃用，转而采用新的`pipe`语义。
- en: The evolution of streams in Node came from a desire to use the event-based APIs
    to solve non-blocking I/O problems in an efficient way. Older solutions like `util.pump`
    sought to find efficiency in intelligent uses of “drain” events—this is emitted
    when a writable stream has emptied and it’s safe to write again. This sounds a
    lot like pausing a stream, and the handling of paused streams was something the
    pre-0.10 streams API couldn’t handle effectively.
  id: totrans-1041
  prefs: []
  type: TYPE_NORMAL
  zh: Node中流的演变源于使用基于事件的API以高效方式解决非阻塞I/O问题的愿望。像`util.pump`这样的旧解决方案试图在智能使用“drain”事件中找到效率——这是可写流清空且可以再次安全写入时发出的。这听起来很像暂停流，而处理暂停流是0.10之前的流API无法有效处理的事情。
- en: Now Node has reached a point where the core developers have seen the types of
    problems people are tackling with streams, so the new API is richer thanks to
    the new stream primitive classes. [Table 5.1](#ch05table01) shows a summary of
    the classes available from Node 0.10 onward.
  id: totrans-1042
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Node已经达到一个核心开发者已经看到人们使用流解决的问题类型的点，因此新的API由于新的流原语类而更加丰富。[表5.1](#ch05table01)显示了从Node
    0.10开始可用的类摘要。
- en: Table 5.1\. A summary of the classes available in *streams2*
  id: totrans-1043
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表5.1. *streams2*中可用的类摘要
- en: '| Name | User methods | Description |'
  id: totrans-1044
  prefs: []
  type: TYPE_TB
  zh: '| 名称 | 用户方法 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-1045
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| stream.Readable | _read(size) | Used for I/O sources that generate data |'
  id: totrans-1046
  prefs: []
  type: TYPE_TB
  zh: '| stream.Readable | _read(size) | 用于生成数据的I/O源 |'
- en: '| stream.Writable | _write(chunk, encoding, callback) | Used to write to an
    underlying output destination |'
  id: totrans-1047
  prefs: []
  type: TYPE_TB
  zh: '| stream.Writable | _write(chunk, encoding, callback) | 用于写入底层输出目标 |'
- en: '| stream.Duplex | _read(size), _write(chunk, encoding, callback) | A readable
    *and* writable stream, like a network connection |'
  id: totrans-1048
  prefs: []
  type: TYPE_TB
  zh: '| stream.Duplex | _read(size), _write(chunk, encoding, callback) | 可读且可写的流，如网络连接
    |'
- en: '| stream.Transform | _flush(size), _transform(chunk, encoding, callback) |
    A duplex stream that changes data in some way, with no limitation on matching
    input data size with the output |'
  id: totrans-1049
  prefs: []
  type: TYPE_TB
  zh: '| stream.Transform | _flush(size), _transform(chunk, encoding, callback) |
    一种双工流，以某种方式更改数据，对匹配输入数据大小与输出大小没有限制 |'
- en: Learning to take advantage of streams will pay dividends when it comes to working
    with third-party modules that implement streams. In the next section, a selection
    of popular stream-oriented modules is examined.
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
  zh: 学习如何利用流，当与实现流的第三方模块一起工作时，将带来回报。在下一节中，将检查一些流行的面向流的模块。
- en: 5.1.4\. Streams in third-party modules
  id: totrans-1051
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.1.4. 第三方模块中的流
- en: The main use of streams in Node is for creating event-based APIs for I/O-like
    sources; parsers, network protocols, and database modules are the key examples.
    A network protocol implemented with streams can be convenient when composition
    is desired—think about how easy it would be to add data compression to a network
    protocol if the data could be passed through the `gzip` module with a single call
    to `pipe`.
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Node 中，流的主要用途是为类似 I/O 的源创建基于事件的 API；解析器、网络协议和数据库模块是关键示例。当需要组合时，使用流实现网络协议可能很方便——想想如果数据可以通过
    `gzip` 模块的单次调用通过 `pipe` 传递，向网络协议添加数据压缩会有多容易。
- en: Similarly, database libraries that stream data can handle large result sets
    more efficiently; rather than collecting all results into an array, a single item
    at a time can be streamed.
  id: totrans-1053
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，可以流式传输数据的数据库库可以更有效地处理大量结果集；而不是将所有结果收集到一个数组中，一次可以流式传输一个项目。
- en: The Mongoose MongoDB module ([http://mongoosejs.com/](http://mongoosejs.com/))
    has an object called `QueryStream` that can be used to stream documents. The `mysql`
    module ([https://npmjs.org/package/mysql](https://npmjs.org/package/mysql)) can
    also stream query results, although this implementation doesn’t currently implement
    the `stream.Readable` class.
  id: totrans-1054
  prefs: []
  type: TYPE_NORMAL
  zh: Mongoose MongoDB 模块 ([http://mongoosejs.com/](http://mongoosejs.com/)) 有一个名为
    `QueryStream` 的对象，可以用来流式传输文档。`mysql` 模块 ([https://npmjs.org/package/mysql](https://npmjs.org/package/mysql))
    也可以流式传输查询结果，尽管这个实现目前还没有实现 `stream.Readable` 类。
- en: 'You can also find more creative uses of streams out there. The `baudio` module
    (see [figure 5.2](#ch05fig02)) by James Halliday can be used to generate audio
    streams that behave just like any other stream—audio data can be routed to other
    streams with `pipe`, and recorded for playback by standard audio software:'
  id: totrans-1055
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以在其他地方找到更多关于流的创造性用法。James Halliday 的 `baudio` 模块（参见 [图 5.2](#ch05fig02)）可以用来生成行为就像任何其他流的音频流——音频数据可以通过
    `pipe` 路由到其他流，并通过标准音频软件进行录音回放：
- en: Figure 5.2\. The `baudio` module by James Halliday (substack) supports the generation
    of audio streams (from [https://github.com/substack/baudio](https://github.com/substack/baudio)).
  id: totrans-1056
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.2\. James Halliday（substack）的 `baudio` 模块支持音频流的生成（来自 [https://github.com/substack/baudio](https://github.com/substack/baudio)）。
- en: '![](05fig02.jpg)'
  id: totrans-1057
  prefs: []
  type: TYPE_IMG
  zh: '![](05fig02.jpg)'
- en: '[PRE44]'
  id: totrans-1058
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: When selecting a network or database library for your Node projects, we strongly
    recommend ensuring it has a streamable API, because it’ll help you write more
    elegant code while also potentially offering performance benefits.
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
  zh: 当选择用于你的 Node 项目的网络或数据库库时，我们强烈建议确保它有一个可流式传输的 API，因为它将帮助你编写更优雅的代码，同时可能提供性能优势。
- en: One thing all stream classes have in common is they inherit from `EventEmitter`.
    The significance of this is investigated in the next section.
  id: totrans-1060
  prefs: []
  type: TYPE_NORMAL
  zh: 所有流类共同的一点是它们都继承自 `EventEmitter`。这一点将在下一节中探讨。
- en: 5.1.5\. Streams inherit from EventEmitter
  id: totrans-1061
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 5.1.5\. 流继承自 EventEmitter
- en: Each of the `stream` module base classes emits various events, which depend
    on whether the base class is readable, writable, or both. The fact that streams
    inherit from `EventEmitter` means you can bind to various standard events to manage
    streams, or create your own custom events to represent more domain-specific behavior.
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 `stream` 模块基类都会发出各种事件，这些事件取决于基类是否是可读的、可写的或两者都是。流继承自 `EventEmitter` 的这一事实意味着你可以绑定到各种标准事件来管理流，或者创建你自己的自定义事件来表示更特定于领域的操作。
- en: When working with `stream.Readable` instances (see [table 5.2](#ch05table02)
    for guidance on selecting a stream base class), the `readable` event is important
    because it signifies that the stream is ready for calls to `stream.read()`.
  id: totrans-1063
  prefs: []
  type: TYPE_NORMAL
  zh: 当与 `stream.Readable` 实例一起工作时（参见 [表 5.2](#ch05table02) 以获取选择流基类的指导），`readable`
    事件很重要，因为它表示流已准备好调用 `stream.read()`。
- en: Table 5.2\. Selecting a streams base class
  id: totrans-1064
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 5.2\. 选择流基类
- en: '| Problem | Solution |'
  id: totrans-1065
  prefs: []
  type: TYPE_TB
  zh: '| 问题 | 解决方案 |'
- en: '| --- | --- |'
  id: totrans-1066
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| You want to wrap around an underlying I/O source with a streamable API. |
    Readable |'
  id: totrans-1067
  prefs: []
  type: TYPE_TB
  zh: '| 你想要包装一个具有可流式传输 API 的底层 I/O 源。 | Readable |'
- en: '| You want to get output from a program to use elsewhere, or send data elsewhere
    within a program. | Writable |'
  id: totrans-1068
  prefs: []
  type: TYPE_TB
  zh: '| 你想要将程序输出用于其他地方，或在程序内部的其他地方发送数据。 | Writable |'
- en: '| You want to change data in some way by parsing it. | Transform |'
  id: totrans-1069
  prefs: []
  type: TYPE_TB
  zh: '| 你想要以某种方式通过解析来更改数据。 | Transform |'
- en: '| You want to wrap a data source that can also receive messages. | Duplex |'
  id: totrans-1070
  prefs: []
  type: TYPE_TB
  zh: '| 你想要包装一个可以接收消息的数据源。 | Duplex |'
- en: '| You want to extract data from streams without changing it, from testing to
    analysis. | PassThrough |'
  id: totrans-1071
  prefs: []
  type: TYPE_TB
  zh: '| 你想要从流中提取数据而不改变它，从测试到分析。 | PassThrough |'
- en: Attaching a listener to `data` will cause the stream to behave like the old
    streams API, where data is passed to `data` listeners when it’s available, rather
    than through calls to `stream.read()`.
  id: totrans-1072
  prefs: []
  type: TYPE_NORMAL
  zh: 将监听器附加到 `data` 将使流的行为类似于旧的流 API，其中当数据可用时，数据会传递给 `data` 监听器，而不是通过调用 `stream.read()`。
- en: The `error` event is covered in detail in [technique 28](#ch05lev2sec7). It’ll
    be emitted if the stream encounters an error when receiving data.
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
  zh: '`error` 事件在 [技巧 28](#ch05lev2sec7) 中有详细说明。如果流在接收数据时遇到错误，将会发出此事件。'
- en: The `end` event signifies that the stream has received an equivalent of the
    end-of-file character, and won’t receive more data. There’s also a `close` event
    that represents the case where the underlying resource has been closed, which
    is distinct from `end`, and the Node API documentation notes that not all streams
    will emit this event, so a rule of thumb is to bind to `end`.
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
  zh: '`end` 事件表示流已接收到文件结束字符的等效字符，并且不会接收更多数据。还有一个 `close` 事件表示底层资源已被关闭，这与 `end` 不同，Node
    API 文档指出并非所有流都会发出此事件，因此一个经验法则是绑定到 `end`。'
- en: The `stream.Writable` class changes the semantics for signifying the end of
    a stream to `close` and `finish`. The distinction between the two is that `finish`
    is emitted when `writable.end()` is called, whereas `close` means the underlying
    I/O resource has been closed, which isn’t always required, depending on the nature
    of the underlying stream.
  id: totrans-1075
  prefs: []
  type: TYPE_NORMAL
  zh: '`stream.Writable` 类将表示流结束的语义更改为 `close` 和 `finish`。这两个之间的区别在于，当调用 `writable.end()`
    时会发出 `finish` 事件，而 `close` 表示底层 I/O 资源已被关闭，这并不总是必需的，这取决于底层流的性质。'
- en: The `pipe` and `unpipe` events are emitted when passing a stream to the `stream.Readable.prototype.pipe`
    method. This can be used to adapt the way a stream behaves when it’s piped. The
    listener receives the destination stream as the first argument, so this value
    could be inspected to change the behavior of the stream. This is a more advanced
    technique that’s covered in [technique 37](#ch05lev2sec16).
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
  zh: 当将流传递给 `stream.Readable.prototype.pipe` 方法时，会发出 `pipe` 和 `unpipe` 事件。这可以用来调整流在
    `pipe` 时的行为。监听器将目标流作为第一个参数接收，因此可以检查此值以改变流的行为。这是一个更高级的技术，在 [技巧 37](#ch05lev2sec16)
    中有介绍。
- en: '|  |'
  id: totrans-1077
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**About the techniques in this chapter**'
  id: totrans-1078
  prefs: []
  type: TYPE_NORMAL
  zh: '**关于本章的技术**'
- en: The techniques in this chapter all use the *streams2* API. This is the nickname
    of the newer API style found in Node 0.10 and 0.12\. If you’re using Node 0.8,
    forward compatibility is supported through the `readable-stream` module ([https://github.com/isaacs/readable-stream](https://github.com/isaacs/readable-stream)).
  id: totrans-1079
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有技术都使用 *streams2* API。这是 Node 0.10 和 0.12 中找到的新 API 风格的昵称。如果你使用 Node 0.8，可以通过
    `readable-stream` 模块支持向前兼容性 ([https://github.com/isaacs/readable-stream](https://github.com/isaacs/readable-stream))。
- en: '|  |'
  id: totrans-1080
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: In the next section you’ll learn how to solve real-world problems using streams.
    First we’ll discuss some of Node’s built-in streams, and then we’ll move on to
    creating entirely new streams and testing them.
  id: totrans-1081
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将学习如何使用流解决实际问题。首先，我们将讨论一些 Node 的内置流，然后我们将继续创建全新的流并进行测试。
- en: 5.2\. Built-in streams
  id: totrans-1082
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2\. 内置流
- en: Node’s core modules themselves are implemented using the `stream` module, so
    it’s easy to start using streams without having to build your own classes. The
    next technique introduces some of this functionality through file system and network
    streaming APIs.
  id: totrans-1083
  prefs: []
  type: TYPE_NORMAL
  zh: Node 的核心模块本身是使用 `stream` 模块实现的，因此很容易开始使用流而无需构建自己的类。下一个技巧将通过文件系统和网络流 API 介绍一些这种功能。
- en: Technique 27 Using built-in streams to make a static web server
  id: totrans-1084
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 技巧 27 使用内置流创建静态 Web 服务器
- en: Node’s core modules often have streamable interfaces. They can be used to solve
    many problems more efficiently than their synchronous alternatives.
  id: totrans-1085
  prefs: []
  type: TYPE_NORMAL
  zh: Node 的核心模块通常具有可流式接口。它们可以比它们的同步替代方案更有效地解决许多问题。
- en: Problem
  id: totrans-1086
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: You want to send a file from a web server to a client in an efficient manner
    that will scale up to large files.
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望以高效的方式将文件从网络服务器发送到客户端，并且这种方式能够扩展到大型文件。
- en: Solution
  id: totrans-1088
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use `fs.createReadStream` to open a file and *stream* it to the client. Optionally,
    `pipe` the resulting `stream.Readable` through another stream to handle features
    like compression.
  id: totrans-1089
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `fs.createReadStream` 打开文件并将其 *stream* 发送到客户端。可选地，可以通过另一个流将结果 `stream.Readable`
    进行 `pipe` 操作以处理如压缩等功能。
- en: Discussion
  id: totrans-1090
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论
- en: Node’s core modules for file system and network operations, `fs` and `net`,
    both provide streamable interfaces. The `fs` module has helper methods to automatically
    create instances of the streamable classes. This makes using streams for some
    I/O-based problems fairly straightforward.
  id: totrans-1091
  prefs: []
  type: TYPE_NORMAL
  zh: Node的核心模块`fs`和`net`都提供了可流式接口。`fs`模块有辅助方法来自动创建可流式类的实例。这使得使用流来解决一些基于I/O的问题相当直接。
- en: 'To understand why streams are important and compare them to nonstreaming code,
    consider the following example of a simple static file web server made with Node’s
    core modules:'
  id: totrans-1092
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解流的重要性并将其与非流代码进行比较，请考虑以下使用Node核心模块制作的简单静态文件Web服务器的示例：
- en: '[PRE45]'
  id: totrans-1093
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Even though this code uses the `fs.readFile` method, which is non-blocking,
    it can easily be improved on by using `fs.createReadStream`. The reason is because
    it’ll read the entire file into memory. This might seem acceptable with small
    files, but what if you don’t know how large the file is? Static web servers often
    have to serve up potentially large binary assets, so a more adaptable solution
    is desirable.
  id: totrans-1094
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管此代码使用了非阻塞的`fs.readFile`方法，但它可以通过使用`fs.createReadStream`来轻松改进。原因是它会将整个文件读入内存。这在小文件中可能看起来是可以接受的，但如果你不知道文件有多大呢？静态Web服务器通常需要提供可能很大的二进制资产，因此需要一个更灵活的解决方案。
- en: The following listing demonstrates a streaming static web server.
  id: totrans-1095
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表演示了一个流式静态Web服务器。
- en: Listing 5.1\. A simple static web server that uses streams
  id: totrans-1096
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.1。一个使用流的简单静态Web服务器
- en: '![](089fig01_alt.jpg)'
  id: totrans-1097
  prefs: []
  type: TYPE_IMG
  zh: '![图片](089fig01_alt.jpg)'
- en: This example uses less code than the first version, and improves its efficiency.
    Now instead of reading the entire file into memory, a buffer’s worth will be read
    at a time and sent to the client. If the client is on a slow connection, the network
    stream will signal this by requesting that the I/O source pauses until the client
    is ready for more data. This is known as *backpressure*, and is one of the additional
    benefits using streams brings to your Node programs.
  id: totrans-1098
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子使用的代码比第一个版本少，并且提高了效率。现在，而不是将整个文件读入内存，一次只读取一个缓冲区并将其发送到客户端。如果客户端连接速度慢，网络流将通过请求I/O源暂停，直到客户端准备好更多数据来表示这一点。这被称为*背压*，是使用流为您的Node程序带来的额外好处之一。
- en: We can take this example a step further. Streams aren’t just efficient and potentially
    more syntactically elegant, they’re also extensible. Static web servers often
    compress files with gzip. The next listing adds that to the previous example,
    using streams.
  id: totrans-1099
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这个例子进一步扩展。流不仅高效且可能更具有语法上的优雅，而且它们也是可扩展的。静态Web服务器通常使用gzip压缩文件。下一个列表将此功能添加到之前的示例中，使用流。
- en: Listing 5.2\. A static web server with gzip
  id: totrans-1100
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.2。一个使用gzip的静态Web服务器
- en: '![](089fig02_alt.jpg)'
  id: totrans-1101
  prefs: []
  type: TYPE_IMG
  zh: '![图片](089fig02_alt.jpg)'
- en: Now if you open http://localhost:8000 in a browser and use its debugging tools
    to look at the network operations, you should see that the content was transferred
    using gzip. [Figure 5.3](#ch05fig03) shows what our browser reported after running
    the example.
  id: totrans-1102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果您在浏览器中打开 http://localhost:8000 并使用其调试工具查看网络操作，您应该会看到内容是通过gzip进行传输的。[图5.3](#ch05fig03)
    展示了运行示例后浏览器报告的内容。
- en: Figure 5.3\. The network inspector confirms the content was compressed.
  id: totrans-1103
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.3。网络检查器确认内容已被压缩。
- en: '![](05fig03_alt.jpg)'
  id: totrans-1104
  prefs: []
  type: TYPE_IMG
  zh: '![图片](05fig03_alt.jpg)'
- en: This could be expanded in several other ways—you can use as many calls to `pipe`
    as required. For example, the file could be piped through an HTML templating engine
    and then compressed. Just remember that the general pattern is `readable.pipe(writable)`.
  id: totrans-1105
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过几种其他方式来扩展——您可以使用所需的任何数量的`pipe`调用。例如，文件可以通过HTML模板引擎进行管道传输，然后压缩。只需记住，一般模式是`readable.pipe(writable)`。
- en: Note that this example is simplified to illustrate how streams work and isn’t
    sufficient for implementing a production HTTP asset server.
  id: totrans-1106
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个例子被简化了，以说明流的工作原理，但不足以实现一个生产级的HTTP资产服务器。
- en: 'Now that you’ve seen a fleshed-out example of how streams are used to solve
    a common problem, it’s time to look at another piece of the puzzle: error handling.'
  id: totrans-1107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经看到了如何使用流来解决常见问题的详细示例，是时候看看拼图中的另一部分：错误处理。
- en: Technique 28 Stream error handling
  id: totrans-1108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 技巧28 流错误处理
- en: The stream classes inherit from `EventEmitter`, which means sane error handling
    comes as standard. This technique explains how to handle errors generated by a
    stream.
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
  zh: 流类继承自`EventEmitter`，这意味着合理的错误处理是标准配置。这项技术解释了如何处理由流生成的错误。
- en: Problem
  id: totrans-1110
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: You want to catch errors generated by a stream.
  id: totrans-1111
  prefs: []
  type: TYPE_NORMAL
  zh: 您想捕获由流生成的错误。
- en: Solution
  id: totrans-1112
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案
- en: Add an `error` listener.
  id: totrans-1113
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个`error`监听器。
- en: Discussion
  id: totrans-1114
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论
- en: The standard behavior of `EventEmitter` is to throw an exception when an `error`
    event is emitted—unless there’s a listener attached to the `error` event. The
    first argument to the listener will be the error that was raised, a descendent
    of the `Error` object.
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
  zh: '`EventEmitter`的标准行为是在发出`error`事件时抛出异常——除非有监听器附加到`error`事件上。监听器的第一个参数将是引发错误的错误，它是`Error`对象的一个后代。'
- en: The following listing shows an example of an intentionally generated error with
    a suitable `error` listener.
  id: totrans-1116
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了一个故意生成的错误及其合适的`error`监听器示例。
- en: Listing 5.3\. Catching errors during streaming
  id: totrans-1117
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.3\. 在流中捕获错误
- en: '![](091fig01_alt.jpg)'
  id: totrans-1118
  prefs: []
  type: TYPE_IMG
  zh: '![091fig01_alt.jpg](091fig01_alt.jpg)'
- en: Here we attempt to open a file that doesn’t exist ![](1.jpg), causing an `'error'`
    event to be triggered. The error object passed to the handler ![](2.jpg) will
    usually have extra information to aid in tracking down the error. For example,
    the `stack` property may have line number information, and `console.trace()` can
    be called to generate a full stack trace. In [listing 5.3](#ch05ex03) `console.trace()`
    will show a trace up to the `ReadStream` implementation in Node’s `events.js`
    core module. That means you can see exactly where the error was originally emitted.
  id: totrans-1119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们尝试打开一个不存在的文件 ![1.jpg](1.jpg)，这会触发一个`'error'`事件。传递给处理器的错误对象 ![2.jpg](2.jpg)
    通常会有额外的信息来帮助追踪错误。例如，`stack`属性可能包含行号信息，并且可以调用`console.trace()`来生成完整的堆栈跟踪。在[列表5.3](#ch05ex03)中，`console.trace()`将显示跟踪到Node的`events.js`核心模块中的`ReadStream`实现。这意味着你可以看到错误最初是在哪里发出的。
- en: Now that you’ve seen how some of Node’s core modules use streams, the next section
    explores how third-party modules use them.
  id: totrans-1120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到了Node的一些核心模块是如何使用流的，下一节将探讨第三方模块是如何使用它们的。
- en: 5.3\. Third-party modules and streams
  id: totrans-1121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3\. 第三方模块和流
- en: Streams are about as idiomatic Node as you can get, so it’s no surprise that
    streamable interfaces crop up all over the open source Node landscape. In the
    next technique you’ll learn how to use streamable interfaces found in some popular
    Node modules.
  id: totrans-1122
  prefs: []
  type: TYPE_NORMAL
  zh: 流是Node中最典型的特性之一，因此，在开源的Node环境中，几乎到处都能看到可流式接口的应用。在接下来的技术中，你将学习如何使用一些流行Node模块中找到的可流式接口。
- en: Technique 29 Using streams from third-party modules
  id: totrans-1123
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 技术第29章：使用第三方模块中的流
- en: Many open source developers have recognized the importance of streams and incorporated
    streamable interfaces into their modules. In this technique you’ll learn how to
    identify such implementations and use them to solve problems more efficiently.
  id: totrans-1124
  prefs: []
  type: TYPE_NORMAL
  zh: 许多开源开发者已经认识到流的重要性，并将流式接口集成到他们的模块中。在这个技术中，你将学习如何识别这样的实现，并使用它们更有效地解决问题。
- en: Problem
  id: totrans-1125
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: You want to know how to use streams with a popular third-party module that you’ve
    downloaded with npm.
  id: totrans-1126
  prefs: []
  type: TYPE_NORMAL
  zh: 你想知道如何使用npm下载的流行第三方模块中的流。
- en: Solution
  id: totrans-1127
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案
- en: Look at the module’s documentation or source code to figure out if it implements
    a streamable API, and if so, how to use it.
  id: totrans-1128
  prefs: []
  type: TYPE_NORMAL
  zh: 查看模块的文档或源代码，以确定它是否实现了可流式API，以及如何使用它。
- en: Discussion
  id: totrans-1129
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论
- en: We’ve picked three popular modules as examples of third-party modules that implement
    streamable interfaces. This guided tour of streams in the wild should give you
    a good idea of how developers are using streams, and how you can exploit streams
    in your own projects.
  id: totrans-1130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择了三个流行的模块作为实现流式接口的第三方模块的示例。这次对野外的流的引导应该能给你一个很好的想法，了解开发者是如何使用流的，以及你如何在你的项目中利用流。
- en: In the next section you’ll discover some key ways to use streams with the popular
    web framework, Express.
  id: totrans-1131
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将发现一些使用流行的Web框架Express的关键方法。
- en: Using streams with Express
  id: totrans-1132
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用Express中的流
- en: The Express web framework ([http://expressjs.com/](http://expressjs.com/)) actually
    provides a relatively lightweight wrapper around Node’s core HTTP module. This
    includes the `Request` and `Response` objects. Express decorates these objects
    with some of its own methods and values, but the underlying objects are the same.
    That means everything you learned about streaming data to browsers in [technique
    27](#ch05lev2sec6) can be reused here.
  id: totrans-1133
  prefs: []
  type: TYPE_NORMAL
  zh: Express Web框架([http://expressjs.com/](http://expressjs.com/))实际上在Node的核心HTTP模块周围提供了一个相对轻量级的包装。这包括`Request`和`Response`对象。Express使用它自己的方法和值装饰这些对象，但底层对象是相同的。这意味着你在[技术27](#ch05lev2sec6)中学到的关于向浏览器流式传输数据的一切都可以在这里重用。
- en: 'A simple example of an Express *route*—a callback that runs for a given HTTP
    method and URL—uses `res.send` to respond with some data:'
  id: totrans-1134
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的Express *路由*示例——一个为特定的HTTP方法和URL运行的回调——使用`res.send`来响应一些数据：
- en: '[PRE46]'
  id: totrans-1135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The `res` object is actually a *response* object, and inherits from Node’s `http.Server-Response`.
    In [technique 27](#ch05lev2sec6) you saw that HTTP requests can be streamed to
    by using the `pipe` method. Express is built in a way that allows buffers and
    objects to work with the `res.send` method, and for streams you can still use
    the `pipe` method.
  id: totrans-1136
  prefs: []
  type: TYPE_NORMAL
  zh: '`res` 对象实际上是一个 *响应* 对象，它继承自 Node 的 `http.Server-Response`。在 [技术 27](#ch05lev2sec6)
    中您看到，可以使用 `pipe` 方法将 HTTP 请求流式传输。Express 以一种允许缓冲区和对象与 `res.send` 方法一起工作，并且对于流，您仍然可以使用
    `pipe` 方法的方式构建。'
- en: '[Listing 5.4](#ch05ex04) is an Express web application that will run with Express
    3 and streams content from a custom-readable stream by using `pipe`.'
  id: totrans-1137
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 5.4](#ch05ex04) 是一个 Express 网络应用程序，它将使用 Express 3 运行，并通过使用 `pipe` 从自定义可读流中流式传输内容。'
- en: Listing 5.4\. An Express application that uses streams
  id: totrans-1138
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.4\. 使用流的 Express 应用程序
- en: '![](092fig01_alt.jpg)'
  id: totrans-1139
  prefs: []
  type: TYPE_IMG
  zh: '![092fig01_alt.jpg](092fig01_alt.jpg)'
- en: Our custom readable stream, `StatStream`, inherits from `stream.Readable` ![](1.jpg)
    and implements the `_read` method, which just sends memory usage data ![](2.jpg).
    The `_read` method must be implemented whenever you want to make a readable stream.
    When sending the response back to the browser, the stream can be piped to the
    `res` object ![](3.jpg) provided by Express without any extra work.
  id: totrans-1140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的定制可读流 `StatStream` 继承自 `stream.Readable` ![1.jpg](1.jpg) 并实现了 `_read` 方法，该方法仅发送内存使用数据
    ![2.jpg](2.jpg)。每当您想要创建一个可读流时，都必须实现 `_read` 方法。当将响应发送回浏览器时，流可以被管道传输到 Express 提供的
    `res` 对象 ![3.jpg](3.jpg) 而无需额外的工作。
- en: 'The implementation of the `send` module that comes with Express 3 uses `fs.createReadStream`,
    as described in [technique 27](#ch05lev2sec6). The following sample code is taken
    from the source to `send`:'
  id: totrans-1141
  prefs: []
  type: TYPE_NORMAL
  zh: Express 3 中附带 `send` 模块的实现使用了 `fs.createReadStream`，如 [技术 27](#ch05lev2sec6)
    中所述。以下示例代码取自 `send` 的源代码：
- en: '[PRE47]'
  id: totrans-1142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: It takes a lot more work to correctly deal with things like HTTP `Content-Range`
    headers, but this snippet demonstrates that leveraging the built-in streaming
    APIs like `fs.createReadStream` can lead to solutions powerful enough to underpin
    major open source projects.
  id: totrans-1143
  prefs: []
  type: TYPE_NORMAL
  zh: 正确处理像 HTTP `Content-Range` 头部这样的东西需要更多的工作，但这个片段展示了利用内置的流式 API，如 `fs.createReadStream`，可以导致足够强大的解决方案，足以支撑主要开源项目。
- en: Using streams with Mongoose
  id: totrans-1144
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用 Mongoose 与流结合
- en: 'The Mongoose module ([http://mongoosejs.com/](http://mongoosejs.com/)) for
    the MongoDB database server ([http://www.mongodb.org/](http://www.mongodb.org/))
    has an interface called `QueryStream` that provides Node 0.8-style streams for
    query results. This class is used internally to allow query results to be streamed
    using the `stream` method. The following code shows a query that has its results
    piped through a hypothetical writable stream:'
  id: totrans-1145
  prefs: []
  type: TYPE_NORMAL
  zh: Mongoose 模块（[http://mongoosejs.com/](http://mongoosejs.com/））为 MongoDB 数据库服务器（[http://www.mongodb.org/](http://www.mongodb.org/））提供了一个名为
    `QueryStream` 的接口，该接口提供了类似 Node 0.8 风格的流式查询结果。这个类在内部使用，允许使用 `stream` 方法进行结果流式传输。以下代码展示了将查询结果通过一个假设的可写流进行管道传输的示例：
- en: '[PRE48]'
  id: totrans-1146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This pattern—using a class to wrap an external I/O source’s streamable behavior,
    and then exposing streams through simple method calls—is the style employed by
    Node’s core modules, and is popular with third-party module authors. This has
    been made clearer by the streams2 API’s use of simple abstract classes that can
    be inherited from.
  id: totrans-1147
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式——使用一个类来封装外部 I/O 源的流式行为，然后通过简单的调用暴露流——是 Node 核心模块所采用的风格，并且受到第三方模块作者的欢迎。通过
    streams2 API 使用可继承的简单抽象类，这一点已经变得更加清晰。
- en: Using streams with MySQL
  id: totrans-1148
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用 MySQL 与流结合
- en: 'The third-party `mysql` module ([https://npmjs.org/package/mysql](https://npmjs.org/package/mysql))
    is often seen by Node developers as something low-level that should be built on
    with more complex libraries, like the Sequelize ([http://www.sequelizejs.com/](http://www.sequelizejs.com/))
    object-relational mapper (ORM). But the `mysql` module itself shouldn’t be underestimated,
    and supports streaming results with `pause` and `resume`. Here’s an example of
    the basic API style:'
  id: totrans-1149
  prefs: []
  type: TYPE_NORMAL
  zh: 第三方 `mysql` 模块（[https://npmjs.org/package/mysql](https://npmjs.org/package/mysql)）通常被
    Node 开发者视为一个低级模块，应该与更复杂的库（如 Sequelize [http://www.sequelizejs.com/](http://www.sequelizejs.com/)
    对象关系映射器（ORM））一起构建。但 `mysql` 模块本身不应被低估，并且支持使用 `pause` 和 `resume` 进行流式传输结果。以下是一个基本
    API 风格的示例：
- en: '[PRE49]'
  id: totrans-1150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This streaming API uses domain-specific event names—there’s also a `'fields'`
    event. To pause the result stream, `connection.pause` must be called. This signals
    to the underlying connection to MySQL that results should stop briefly until the
    receiver is ready for more data.
  id: totrans-1151
  prefs: []
  type: TYPE_NORMAL
  zh: 这个流式 API 使用特定领域的事件名称——还有一个 `'fields'` 事件。要暂停结果流，必须调用 `connection.pause`。这会向底层的
    MySQL 连接发出信号，表示结果应暂时停止，直到接收者准备好接收更多数据。
- en: Summary
  id: totrans-1152
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 摘要
- en: In this technique you’ve seen how some popular third-party modules use streams.
    They’re all characterized by the fact they deal with I/O—both HTTP and database
    connections are network- or file-based protocols, and both can involve network
    connections and file system operations. In general, it’s a good idea to look for
    Node network and database modules that implement streamable interfaces, because
    they help scale programs and also write them in a readable, idiomatic style.
  id: totrans-1153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个技巧中，你看到了一些流行的第三方模块如何使用流。它们的特点是处理 I/O——HTTP 和数据库连接都是基于网络或文件的协议，两者都可能涉及网络连接和文件系统操作。一般来说，寻找实现流式接口的
    Node 网络和数据库模块是个好主意，因为它们有助于扩展程序，并以可读、惯用的风格编写代码。
- en: Now that you’ve seen how to use streams, you’re probably itching to learn how
    to create your own. The next section has a technique for using each base stream
    class, and also shows how to correctly inherit from them.
  id: totrans-1154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了如何使用流，你可能迫不及待地想学习如何创建自己的流。下一节将介绍使用每个基流类的方法，并展示如何正确地从它们继承。
- en: 5.4\. Using the stream base classes
  id: totrans-1155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.4. 使用流基类
- en: Node’s base stream classes provide templates for solving the kinds of problems
    that streams are best at. For example, `stream.Transform` is great for parsing
    data, and `stream.Readable` is perfect for wrapping lower-level APIs with a streamable
    interface.
  id: totrans-1156
  prefs: []
  type: TYPE_NORMAL
  zh: Node 的基流类为解决流最擅长的那些问题提供了模板。例如，`stream.Transform` 非常适合解析数据，而 `stream.Readable`
    则非常适合将底层 API 封装成流式接口。
- en: The next technique explains how to inherit from the stream base classes, and
    then further techniques go into detail about how to use each base class.
  id: totrans-1157
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个技巧解释了如何从流基类继承，然后进一步的技巧将详细介绍如何使用每个基类。
- en: Technique 30 Correctly inheriting from the stream base classes
  id: totrans-1158
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 技巧 30 正确地从流基类继承
- en: Node’s base classes for streams can be used as a starting point for new modules
    and subclasses. It’s important to understand what problems each solves, and how
    to correctly inherit from them.
  id: totrans-1159
  prefs: []
  type: TYPE_NORMAL
  zh: Node 的流基类可以用作创建新模块和子类的起点。了解每个基类解决的问题以及如何正确地从它们继承是很重要的。
- en: Problem
  id: totrans-1160
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: You want to solve a problem by creating a streamable API, but you’re not sure
    which base class to use and how to use it.
  id: totrans-1161
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望通过创建流式 API 来解决问题，但不确定使用哪个基类以及如何使用它。
- en: Solution
  id: totrans-1162
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案
- en: Decide on which base class closely matches the problem at hand, and inherit
    from it using `Object.prototype.call` and `util.inherits`.
  id: totrans-1163
  prefs: []
  type: TYPE_NORMAL
  zh: 确定与当前问题最接近的基类，并使用 `Object.prototype.call` 和 `util.inherits` 从它继承。
- en: Discussion
  id: totrans-1164
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论
- en: Node’s base classes for streams, already summarized in [table 5.1](#ch05table01),
    should be used as the basis for your own streamable classes or modules. They’re
    *abstract classes*, which means they’re methods that you must implement before
    they can be used. This is usually done through inheritance.
  id: totrans-1165
  prefs: []
  type: TYPE_NORMAL
  zh: Node 的流基类（已在表 5.1 中总结），应作为创建自己的流式类或模块的基础。它们是 *抽象类*，这意味着在使用之前你必须实现它们的方法。这通常通过继承来完成。
- en: All of the stream base classes are found in the `stream` core module. The five
    base classes are `Readable`, `Writable`, `Duplex`, `Transform`, and `PassThrough`.
    Fundamentally, streams are either readable or writable, but `Duplex` streams are
    both. This makes sense if you consider the behavior of I/O interfaces—a network
    connection can be both readable and writable. It wouldn’t be particularly useful,
    for example, if `ssh` were only able to send data.
  id: totrans-1166
  prefs: []
  type: TYPE_NORMAL
  zh: 所有流基类都位于 `stream` 核心模块中。这五个基类是 `Readable`、`Writable`、`Duplex`、`Transform` 和
    `PassThrough`。从根本上说，流要么是可读的，要么是可写的，但 `Duplex` 流两者都是。如果你考虑 I/O 接口的行为——网络连接可以是可读的也可以是可写的。例如，如果
    `ssh` 只能发送数据，那就特别没有用。
- en: '`Transform` streams build on `Duplex` streams, but also change the data in
    some way. Some of Node’s built-in modules use `Transform` streams, so they’re
    fundamentally important. An example of this is the `crypto` module.'
  id: totrans-1167
  prefs: []
  type: TYPE_NORMAL
  zh: '`Transform` 流建立在 `Duplex` 流之上，但也会以某种方式改变数据。一些 Node 内置模块使用 `Transform` 流，因此它们在本质上很重要。一个例子是
    `crypto` 模块。'
- en: '[Table 5.2](#ch05table02) offers some hints to help you choose which base class
    to use.'
  id: totrans-1168
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 5.2](#ch05table02) 提供了一些提示，帮助你选择要使用哪个基类。'
- en: Inheriting from the base classes
  id: totrans-1169
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 从基类继承
- en: If you’ve learned about inheritance in JavaScript, you might be tempted to inherit
    from the stream base classes by using `MyStream.prototype = new stream.Readable();`.
    This is considered bad practice, and it’s better to use the ECMAScript 5 `Object.create`
    pattern instead. Also, the base class’s constructor must be run, because it provides
    essential setup code. The pattern for this is shown next.
  id: totrans-1170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经了解了 JavaScript 中的继承，你可能想通过使用 `MyStream.prototype = new stream.Readable();`
    来从流基类继承。这被认为是一种不良做法，更好的做法是使用 ECMAScript 5 的 `Object.create` 模式。此外，必须运行基类的构造函数，因为它提供了必要的设置代码。下一个示例展示了这种模式。
- en: Listing 5.5\. Inheriting from the `stream.Readable` base class
  id: totrans-1171
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.5\. 从 `stream.Readable` 基类继承
- en: '![](095fig01_alt.jpg)'
  id: totrans-1172
  prefs: []
  type: TYPE_IMG
  zh: '![](095fig01_alt.jpg)'
- en: Node includes a utility method called `util.inherits` that can be used instead
    of `Object.create`, but both approaches are widely used by Node developers. This
    example uses the `Object.create` method ![](1.jpg) instead so you can see what
    `util.inherits` does.
  id: totrans-1173
  prefs: []
  type: TYPE_NORMAL
  zh: Node 包含一个名为 `util.inherits` 的实用方法，它可以替代 `Object.create` 使用，但两种方法都被 Node 开发者广泛使用。这个例子使用
    `Object.create` 方法 ![](1.jpg) 而不是 `util.inherits`，这样你可以看到 `util.inherits` 是如何工作的。
- en: 'Note that in [listing 5.5](#ch05ex05) the `options` argument ![](2.jpg) is
    passed to the original `Readable` constructor. This is important because there’s
    a standard set of options that Node supports for configuring streams. In the case
    of `Readable`, the options are as follows:'
  id: totrans-1174
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在 [列表 5.5](#ch05ex05) 中，`options` 参数 ![](2.jpg) 被传递给原始的 `Readable` 构造函数。这很重要，因为
    Node 支持一组标准的选项来配置流。对于 `Readable`，选项如下：
- en: '***`highWaterMark`*** —The number of bytes to store in the internal buffer
    before pausing reading from the underlying data source.'
  id: totrans-1175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***`highWaterMark`*** — 在暂停从底层数据源读取之前，存储在内部缓冲区中的字节数。'
- en: '***`encoding`*** —Causes the buffer to be automatically decoded. Possible values
    include `utf8` and `ascii`.'
  id: totrans-1176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***`encoding`*** — 导致缓冲区自动解码。可能的值包括 `utf8` 和 `ascii`。'
- en: '***`objectMode`*** —Allows the stream to behave as a stream of objects, rather
    than bytes.'
  id: totrans-1177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***`objectMode`*** — 允许流以对象流的形式行为，而不是字节流。'
- en: The `objectMode` option allows JavaScript objects to be handled by streams.
    An example of this has been provided in [technique 31](#ch05lev2sec10).
  id: totrans-1178
  prefs: []
  type: TYPE_NORMAL
  zh: '`objectMode` 选项允许 JavaScript 对象由流处理。[技术31](#ch05lev2sec10) 中提供了一个示例。'
- en: Summary
  id: totrans-1179
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 摘要
- en: In this technique you’ve seen how to use Node’s stream base classes to create
    your own stream implementations. This involves using `util.inherits` to set up
    the class, and then `.call` to call the original constructor. We also covered
    some of the options that these base classes use.
  id: totrans-1180
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个技术中，你已经看到了如何使用 Node 的流基类来创建自己的流实现。这涉及到使用 `util.inherits` 来设置类，然后使用 `.call`
    来调用原始构造函数。我们还介绍了一些这些基类使用的选项。
- en: Properly inheriting from the base classes is one thing, but what about actually
    implementing a stream class? [Technique 31](#ch05lev2sec10) explains this in more
    detail for the `Readable` base class, but in that specific case it involves implementing
    a method called `_read` to read data from the underlying data source and `push`
    it onto an internal queue managed by the base class itself.
  id: totrans-1181
  prefs: []
  type: TYPE_NORMAL
  zh: 正确地从基类继承是一回事，但实际实现一个流类又是另一回事。[技术31](#ch05lev2sec10) 详细解释了对于 `Readable` 基类的实现，但在这个特定情况下，它涉及到实现一个名为
    `_read` 的方法，用于从底层数据源读取数据并将其 `push` 到由基类本身管理的内部队列中。
- en: Technique 31 Implementing a readable stream
  id: totrans-1182
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 技术编号 31 实现可读流
- en: Readable streams can be used to provide a flexible API around I/O sources, and
    can also act as parsers.
  id: totrans-1183
  prefs: []
  type: TYPE_NORMAL
  zh: 可读流可以用来提供围绕 I/O 源的灵活 API，也可以作为解析器。
- en: Problem
  id: totrans-1184
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: You’d like to wrap an I/O source with a streamable API that provides a higher-level
    interface than would otherwise be possible with the underlying data.
  id: totrans-1185
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望使用可流式 API 包装 I/O 源，该 API 提供了一个比底层数据可能的更高层次的接口。
- en: Solution
  id: totrans-1186
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案
- en: Implement a readable stream by inheriting from the `stream.Readable` class and
    creating a `_read(size)` method.
  id: totrans-1187
  prefs: []
  type: TYPE_NORMAL
  zh: 通过从 `stream.Readable` 类继承并创建一个 `_read(size)` 方法来实现可读流。
- en: Discussion
  id: totrans-1188
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论
- en: Implementing a custom `stream.Readable` class can be useful when a higher level
    of abstraction around an underlying data source is required. For example, I (Alex)
    was working on a project where the client had sent in JSON files that contained
    millions of records separated by newlines. I decided to write a quick `stream.Readable`
    class that read a buffer’s worth of data, and whenever a newline was encountered,
    `JSON.parse` was used to parse the record.
  id: totrans-1189
  prefs: []
  type: TYPE_NORMAL
  zh: 实现一个自定义的 `stream.Readable` 类在需要围绕底层数据源的高级抽象时非常有用。例如，我（亚历克斯）正在做一个项目，客户发送了包含数百万条记录的
    JSON 文件，这些记录通过换行符分隔。我决定编写一个快速的 `stream.Readable` 类，该类读取缓冲区中的数据，每当遇到换行符时，使用 `JSON.parse`
    来解析记录。
- en: One way of using `stream.Readable` to parse newline-separated JSON records is
    shown next.
  id: totrans-1190
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例展示了如何使用 `stream.Readable` 来解析以换行符分隔的 JSON 记录。
- en: Listing 5.6\. A JSON line parser
  id: totrans-1191
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.6\. JSON 行解析器
- en: '![](ch05ex06-0.jpg)'
  id: totrans-1192
  prefs: []
  type: TYPE_IMG
  zh: '![ch05ex06-0.jpg](ch05ex06-0.jpg)'
- en: '![](ch05ex06-1.jpg)'
  id: totrans-1193
  prefs: []
  type: TYPE_IMG
  zh: '![ch05ex06-1.jpg](ch05ex06-1.jpg)'
- en: '[Listing 5.6](#ch05ex06) uses a constructor function, `JSONLineReader` ![](1.jpg),
    that inherits from `stream.Readable` ![](3.jpg) to read and parse lines of JSON
    from a file. The source for `JSONLineReader` will be a readable stream as well,
    so a listener for the `readable` event is bound to, so instances of `JSONLineReader`
    know when to start reading data ![](2.jpg).'
  id: totrans-1194
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 5.6](#ch05ex06) 使用了一个构造函数，`JSONLineReader` ![1.jpg](1.jpg)，它继承自 `stream.Readable`
    ![3.jpg](3.jpg)，以从文件中读取和解析 JSON 行。`JSONLineReader` 的源也将是一个可读流，因此绑定了一个 `readable`
    事件的监听器，这样 `JSONLineReader` 的实例就知道何时开始读取数据 ![2.jpg](2.jpg)。'
- en: The `_read` method ![](4.jpg) checks whether the buffer is empty ![](5.jpg)
    and, if so, reads more data from the source and adds it to the internal buffer.
    Then the current line index is incremented, and if a line ending is found, the
    first line is sliced from the buffer ![](6.jpg). Once a complete line has been
    found, it’s parsed and emitted using the `object` event ![](7.jpg)—users of the
    class can bind to this event to receive each line of JSON that’s found in the
    source stream.
  id: totrans-1195
  prefs: []
  type: TYPE_NORMAL
  zh: '`_read` 方法 ![4.jpg](4.jpg) 检查缓冲区是否为空 ![5.jpg](5.jpg)，如果是，则从源读取更多数据并将其添加到内部缓冲区。然后当前行索引递增，如果找到行结束符，则从缓冲区中裁剪出第一行
    ![6.jpg](6.jpg)。一旦找到完整的行，它将使用 `object` 事件进行解析和发射 ![7.jpg](7.jpg)——类的用户可以绑定到这个事件以接收在源流中找到的每一行
    JSON。'
- en: When this example is run, data from a file will flow through an instance of
    the class. Internally, data will be queued. Whenever `source.read` is executed,
    the latest “chunk” of data will be returned, so it can be processed when `JSONLineReader`
    is ready for it. Once enough data has been read and a newline has been found,
    the data will be split *up to the first newline*, and then the result will be
    collected by calling `this.push` ![](8.jpg).
  id: totrans-1196
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行此示例时，文件中的数据将通过类的实例流动。内部，数据将被排队。每当执行 `source.read` 时，将返回最新的“数据块”，这样就可以在 `JSONLineReader`
    准备好时对其进行处理。一旦读取了足够的数据并找到换行符，数据将被分割到第一个换行符，然后通过调用 `this.push` ![8.jpg](8.jpg) 收集结果。
- en: Once `this.push` is called, `stream.Readable` will queue the result and forward
    it on to a consuming stream. This allows the stream to be further processed by
    a writable stream using `pipe`. In this example JSON objects are emitted using
    a custom `object` event. The last few lines of this example attach an event listener
    for this event and process the results ![](9.jpg).
  id: totrans-1197
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦调用 `this.push`，`stream.Readable` 将排队结果并将其转发到消费流。这允许流通过使用 `pipe` 进一步由可写流处理。在这个例子中，使用自定义的
    `object` 事件发射 JSON 对象。此示例的最后几行附加了一个事件监听器来处理这些结果 ![9.jpg](9.jpg)。
- en: The `size` argument to `Readable.prototype._read` is *advisory*. That means
    the underlying implementation can use it to know how much data to fetch—this isn’t
    always needed so you don’t always implement it. In the previous example we parsed
    the entire line, but some data formats could be parsed in chunks, in which case
    the size argument would be useful.
  id: totrans-1198
  prefs: []
  type: TYPE_NORMAL
  zh: '`Readable.prototype._read` 方法的 `size` 参数是**建议性的**。这意味着底层实现可以使用它来知道要获取多少数据——这并不总是需要的，所以你不必总是实现它。在先前的例子中，我们解析了整行，但某些数据格式可以分块解析，在这种情况下，大小参数将很有用。'
- en: In the original code that I based this example on, I used the resulting JSON
    objects to populate a database. The data was also redirected and gzipped into
    another file. Using streams made this both easy to write and easy to read in the
    final project.
  id: totrans-1199
  prefs: []
  type: TYPE_NORMAL
  zh: 在我基于此示例的原始代码中，我使用生成的 JSON 对象来填充数据库。数据还被重定向并压缩到另一个文件中。使用流使得在最终项目中编写和读取都变得既简单又方便。
- en: The example in [listing 5.6](#ch05ex06) used strings, but what about objects?
    Most streams that deal directly with I/O—files, network protocols, and so on—will
    use raw bytes or strings of characters. But sometimes it’s useful to create streams
    of JavaScript objects. [Listing 5.7](#ch05ex07) shows how to safely inherit from
    `stream.Readable` and pass the `objectMode` option to set up a stream that deals
    with JavaScript objects.
  id: totrans-1200
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 5.6](#ch05ex06) 中的示例使用了字符串，但对象呢？大多数直接处理 I/O 的流（如文件、网络协议等）将使用原始字节或字符字符串。但有时创建
    JavaScript 对象的流很有用。[列表 5.7](#ch05ex07) 展示了如何安全地继承自 `stream.Readable` 并传递 `objectMode`
    选项来设置处理 JavaScript 对象的流。'
- en: Listing 5.7\. A stream configured to use `objectMode`
  id: totrans-1201
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.7\. 配置为使用 `objectMode` 的流
- en: '![](098fig01_alt.jpg)'
  id: totrans-1202
  prefs: []
  type: TYPE_IMG
  zh: '![098fig01_alt.jpg](098fig01_alt.jpg)'
- en: The `MemoryStream` example in [listing 5.7](#ch05ex07) uses objects for data,
    so `objectMode` is passed to the `Readable` constructor as an option ![](1.jpg).
    Then `process.memoryUsage` is used to generate some suitable data ![](2.jpg).
    When an instance of this class emits `readable` ![](3.jpg), indicating that it’s
    ready to be read from, then the memory usage data is logged to the console.
  id: totrans-1203
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 5.7](#ch05ex07) 中的 `MemoryStream` 示例使用对象作为数据，因此将 `objectMode` 作为选项传递给 `Readable`
    构造函数 ![1.jpg](1.jpg)。然后使用 `process.memoryUsage` 生成一些合适的数据 ![2.jpg](2.jpg)。当这个类的实例发出
    `readable` 信号 ![3.jpg](3.jpg)，表示它已准备好被读取时，内存使用数据就会被记录到控制台。'
- en: When using `objectMode`, the underlying behavior of the stream is changed to
    remove the internal buffer merge and length checks, and to ignore the size argument
    when reading and writing.
  id: totrans-1204
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 `objectMode` 时，流的底层行为会改变，以移除内部缓冲区合并和长度检查，并在读取和写入时忽略大小参数。
- en: Technique 32 Implementing a writable stream
  id: totrans-1205
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 技巧 32 实现可写流
- en: Writable streams can be used to output data to underlying I/O sinks.
  id: totrans-1206
  prefs: []
  type: TYPE_NORMAL
  zh: 可写流可以用来将数据输出到底层的 I/O 溢出。
- en: Problem
  id: totrans-1207
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: You want to output data from a program using an I/O destination that you want
    to wrap with a streamable interface.
  id: totrans-1208
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想要使用一个你想要用流式接口包装的 I/O 目标来输出程序数据。
- en: Solution
  id: totrans-1209
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案
- en: Inherit from `stream.Writable` and implement a `_write` method to send data
    to the underlying resource.
  id: totrans-1210
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `stream.Writable` 继承并实现一个 `_write` 方法，以将数据发送到底层资源。
- en: Discussion
  id: totrans-1211
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论
- en: As you saw in [technique 29](#ch05lev2sec8), many third-party modules offer
    streamable interfaces for network services and databases. Following this trend
    is advantageous because it allows your classes to be used with the `pipe` API,
    which helps keep chunks of code reusable and decoupled.
  id: totrans-1212
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在 [技巧 29](#ch05lev2sec8) 中看到的，许多第三方模块为网络服务和数据库提供了流式接口。遵循这一趋势是有利的，因为它允许你的类与
    `pipe` API 一起使用，这有助于保持代码块的可重用性和解耦。
- en: You might be simply looking to implement a writable stream to act as the destination
    of a `pipe` chain, or to implement an unsupported I/O resource. In general, all
    you need to do is correctly inherit from `stream.Writable`—for more on the recommended
    way to do this, see [technique 30](#ch05lev2sec9)—and then add a `_write` method.
  id: totrans-1213
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能只是想实现一个可写流作为 `pipe` 链的终点，或者实现一个不受支持的 I/O 资源。一般来说，你需要正确地继承自 `stream.Writable`——有关推荐的实现方式，请参阅
    [技巧 30](#ch05lev2sec9)，然后添加一个 `_write` 方法。
- en: 'All the `_write` method needs to do is call a supplied callback when the data
    has been written. The following code shows the method’s arguments and the overall
    structure of a sample `_write` implementation:'
  id: totrans-1214
  prefs: []
  type: TYPE_NORMAL
  zh: '`_write` 方法需要做的只是当数据被写入时调用一个提供的回调。以下代码显示了方法参数和示例 `_write` 实现的整体结构：'
- en: '![](099fig01_alt.jpg)'
  id: totrans-1215
  prefs: []
  type: TYPE_IMG
  zh: '![099fig01_alt.jpg](099fig01_alt.jpg)'
- en: A `_write` method supplies a callback ![](1.jpg) that you can call when writing
    has finished. This allows `_write` to be asynchronous. This `customWriteOperation`
    method ![](2.jpg) is simply used as an example here—in a real implementation it
    would perform the underlying I/O. This could involve talking to a database using
    sockets, or writing to a file. The first argument provided to the callback should
    be an error ![](3.jpg), allowing `_write` to propagate errors if needed.
  id: totrans-1216
  prefs: []
  type: TYPE_NORMAL
  zh: '`_write` 方法提供一个回调 ![1.jpg](1.jpg)，你可以在写入完成后调用它。这允许 `_write` 是异步的。这里简单使用的 `customWriteOperation`
    方法 ![2.jpg](2.jpg) 仅作为示例——在实际实现中，它将执行底层的 I/O。这可能涉及通过套接字与数据库通信，或将数据写入文件。提供给回调的第一个参数应该是一个错误
    ![3.jpg](3.jpg)，这样 `_write` 就可以在需要时传播错误。'
- en: Node’s `stream.Writable` base class doesn’t need to know *how* the data was
    written, it just cares whether the operation succeeded or failed. Failures can
    be reported by passing an `Error` object to `callback`. This will cause an `error`
    event to be emitted. Remember that these `stream` base classes descend from `EventEmitter`,
    so you should usually add a listener to `error` to catch and gracefully handle
    any errors.
  id: totrans-1217
  prefs: []
  type: TYPE_NORMAL
  zh: Node的`stream.Writable`基类不需要知道数据是如何被写入的，它只关心操作是否成功。可以通过传递一个`Error`对象到`callback`来报告失败。这将导致`error`事件被触发。记住，这些`stream`基类是从`EventEmitter`继承的，所以您通常应该添加一个监听器到`error`来捕获并优雅地处理任何错误。
- en: The next listing shows a complete implementation of a `stream.Writable` class.
  id: totrans-1218
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表展示了一个`stream.Writable`类的完整实现。
- en: Listing 5.8\. An example implementation of a writable stream
  id: totrans-1219
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.8\. 可写流的示例实现
- en: '![](100fig01_alt.jpg)'
  id: totrans-1220
  prefs: []
  type: TYPE_IMG
  zh: '![](100fig01_alt.jpg)'
- en: This short example changes input text into green text. It can be used by running
    it with `node writable.js`, or by piping text through it with `cat file.txt |
    node writable.js`.
  id: totrans-1221
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简短的例子将输入文本转换为绿色文本。可以通过运行`node writable.js`或通过管道将文本通过它来使用`cat file.txt | node
    writable.js`。
- en: Although this is a trivial example, it illustrates how easy it is to implement
    streamable classes, so you should consider doing this the next time you want to
    make something that stores data work with `pipe`.
  id: totrans-1222
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是一个简单的例子，但它说明了实现流式类是多么容易，所以您下次想要使存储数据的某个东西与`pipe`一起工作时应该考虑这样做。
- en: '|  |'
  id: totrans-1223
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Chunks and encodings**'
  id: totrans-1224
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据块和编码**'
- en: The `encoding` argument to write is only relevant when strings are being used
    instead of buffers. Strings can be used by setting `decodeStrings` to `false`
    in the options that are passed when instantiating a writable stream.
  id: totrans-1225
  prefs: []
  type: TYPE_NORMAL
  zh: '`write`函数的`encoding`参数仅在字符串而不是缓冲区被使用时相关。可以通过在实例化可写流时传递的选项中将`decodeStrings`设置为`false`来使用字符串。'
- en: Streams don’t always deal with `Buffer` objects because some implementations
    have optimized handling for strings, so dealing directly with strings can be more
    efficient in certain cases.
  id: totrans-1226
  prefs: []
  type: TYPE_NORMAL
  zh: 流并不总是处理`Buffer`对象，因为某些实现已经优化了字符串的处理，所以在某些情况下直接处理字符串可能更有效。
- en: '|  |'
  id: totrans-1227
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Technique 33 Transmitting and receiving data with duplex streams
  id: totrans-1228
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 技术33 使用双向流进行数据传输和接收
- en: Duplex streams allow data to be transmitted and received. This technique shows
    you how to create your own duplex streams.
  id: totrans-1229
  prefs: []
  type: TYPE_NORMAL
  zh: 双向流允许数据传输和接收。这项技术将向您展示如何创建自己的双向流。
- en: Problem
  id: totrans-1230
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: You want to create a streamable interface to an I/O source that needs to be
    both readable *and* writable.
  id: totrans-1231
  prefs: []
  type: TYPE_NORMAL
  zh: 您想要创建一个可读可写的I/O源的可流式接口。
- en: Solution
  id: totrans-1232
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案
- en: Inherit from `stream.Duplex` and implement `_read` and `_write` methods.
  id: totrans-1233
  prefs: []
  type: TYPE_NORMAL
  zh: 从`stream.Duplex`继承并实现`_read`和`_write`方法。
- en: Discussion
  id: totrans-1234
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论
- en: Duplex streams are a combination of the `Writable` and `Readable` streams, which
    are explained in [techniques 31](#ch05lev2sec10) and [32](#ch05lev2sec11). As
    such, Duplex streams require inheriting from `stream.Duplex` and implementations
    for the `_read` and `_write` methods. Refer to [technique 30](#ch05lev2sec9) for
    an explanation of how to inherit from the stream base classes.
  id: totrans-1235
  prefs: []
  type: TYPE_NORMAL
  zh: 双向流是`Writable`和`Readable`流的组合，这些流在[技术31](#ch05lev2sec10)和[32](#ch05lev2sec11)中进行了解释。因此，双向流需要从`stream.Duplex`继承，并为`_read`和`_write`方法提供实现。请参阅[技术30](#ch05lev2sec9)以了解如何从流基类继承。
- en: '[Listing 5.9](#ch05ex09) shows a small `stream.Duplex` class that reads and
    writes data from `stdin` and `stdout`. It prompts for data and then writes it
    back out with ANSI escape codes for colors.'
  id: totrans-1236
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表5.9](#ch05ex09)展示了一个小的`stream.Duplex`类，它从`stdin`和`stdout`读取和写入数据。它提示输入数据，然后使用ANSI转义码为颜色写入数据。'
- en: Listing 5.9\. A duplex stream
  id: totrans-1237
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.9\. 一个双向流
- en: '![](ch05ex09-0.jpg)'
  id: totrans-1238
  prefs: []
  type: TYPE_IMG
  zh: '![](ch05ex09-0.jpg)'
- en: '![](ch05ex09-1.jpg)'
  id: totrans-1239
  prefs: []
  type: TYPE_IMG
  zh: '![](ch05ex09-1.jpg)'
- en: The `HungryStream` class in [listing 5.9](#ch05ex09) will display a prompt,
    wait for input, and then return the input with ANSI color codes. To track the
    state of the prompt, an internal property called `waiting` ![](1.jpg) is used.
    The `_write` method, which will be called by Node automatically, sets the `waiting`
    property to `false`, indicating that input has been received, and then the data
    is pushed to the internal buffer with color codes attached. Finally, the callback
    that gets automatically passed to `_write` is executed ![](2.jpg).
  id: totrans-1240
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表 5.9](#ch05ex09)中的`HungryStream`类将显示一个提示，等待输入，然后返回带有ANSI颜色代码的输入。为了跟踪提示的状态，使用了一个名为`waiting`的内部属性![1.jpg](1.jpg)。当Node自动调用`_write`方法时，将`waiting`属性设置为`false`，表示已收到输入，然后将带有颜色代码的数据推送到内部缓冲区。最后，自动传递给`_write`的回调函数被执行![2.jpg](2.jpg)。
- en: When the class is waiting for data, the `_read` method pushes a message that
    acts as the prompt ![](3.jpg). This can be made interactive by piping the standard
    input stream through an instance of `HungryStream` and then back out through the
    standard output stream ![](4.jpg).
  id: totrans-1241
  prefs: []
  type: TYPE_NORMAL
  zh: 当类等待数据时，`_read`方法推送一条充当提示的消息![3.jpg](3.jpg)。可以通过将标准输入流通过`HungryStream`的一个实例管道化，然后再通过标准输出流返回来使其交互式![4.jpg](4.jpg)。
- en: The great thing about duplex streams is they can sit in the middle of pipes.
    A simpler way to do this is to use the `stream.PassThrough` base class, which
    only relays data, allowing you to plug into the middle of a pipe and track data
    as it flows through it. The diagram in [figure 5.4](#ch05fig04) shows how chunks
    of data flow through the duplex stream object, from the input to the output stream.
  id: totrans-1242
  prefs: []
  type: TYPE_NORMAL
  zh: 双工流的好处是它们可以位于管道的中间。一个更简单的方法是使用`stream.PassThrough`基类，它只传递数据，允许你插入管道的中间并跟踪数据流过时的状态。图[图
    5.4](#ch05fig04)显示了数据块如何通过双工流对象从输入流流向输出流。
- en: Figure 5.4\. A duplex stream
  id: totrans-1243
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.4\. 一个双工流
- en: '![](05fig04_alt.jpg)'
  id: totrans-1244
  prefs: []
  type: TYPE_IMG
  zh: '![05fig04_alt.jpg](05fig04_alt.jpg)'
- en: Several `stream.Duplex` implementations in the wild implement a `_write` method
    but keep the `_read` method as a blank stub. This is purely to take advantage
    of duplex streams as something that can enhance the behavior of other streams
    through pipes. For example, `hiccup` by Naomi Kyoto ([https://github.com/naomik/hiccup](https://github.com/naomik/hiccup))
    can be used to simulate slow or sporadic behavior of underlying I/O sources. This
    novel use of streams comes in handy when you’re writing automated tests.
  id: totrans-1245
  prefs: []
  type: TYPE_NORMAL
  zh: 野外的几个`stream.Duplex`实现实现了`_write`方法，但将`_read`方法保留为空白占位符。这纯粹是为了利用双工流作为可以通过管道增强其他流行为的工具。例如，Naomi
    Kyoto的`hiccup`([https://github.com/naomik/hiccup](https://github.com/naomik/hiccup))可以用来模拟底层I/O源的缓慢或不规则行为。这种流的新颖用法在编写自动化测试时非常有用。
- en: Duplex streams are useful for piping readable streams to writable streams and
    analyzing the data. Transform streams are specifically designed for changing data;
    the next technique introduces `stream.Transform` and the `_transform` method.
  id: totrans-1246
  prefs: []
  type: TYPE_NORMAL
  zh: 双工流对于将可读流管道连接到可写流并分析数据非常有用。转换流专门设计用于更改数据；接下来介绍`stream.Transform`和`_transform`方法。
- en: Technique 34 Parsing data with transform streams
  id: totrans-1247
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 技巧 34 使用转换流解析数据
- en: Streams have long been used as a way to create efficient parsers. The `stream.Transform`
    base class can be used to do this in Node.
  id: totrans-1248
  prefs: []
  type: TYPE_NORMAL
  zh: 流长期以来一直被用作创建高效解析器的方法。在Node中可以使用`stream.Transform`基类来完成此操作。
- en: Problem
  id: totrans-1249
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: You want to use streams to change data into another format in a memory-efficient
    manner.
  id: totrans-1250
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望使用流以内存高效的方式将数据转换为另一种格式。
- en: Solution
  id: totrans-1251
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案
- en: Inherit from `stream.Transform` and implement the `_transform` method.
  id: totrans-1252
  prefs: []
  type: TYPE_NORMAL
  zh: 继承自`stream.Transform`并实现`_transform`方法。
- en: Discussion
  id: totrans-1253
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论
- en: On the surface, transform streams sound a little bit like duplex streams. They
    can also sit in the middle of a pipe chain. The difference is that they’re expected
    to transform data, and they’re implemented by writing a `_transform` method. This
    method’s signature is similar to `_write`—it takes three arguments, `chunk`, `encoding`,
    and `callback`. The callback should be executed when the data has been transformed,
    which allows transform streams to parse data asynchronously.
  id: totrans-1254
  prefs: []
  type: TYPE_NORMAL
  zh: 表面上，转换流听起来有点像双工流。它们也可以位于管道链的中间。区别在于，它们预期会转换数据，并且通过编写`_transform`方法来实现。此方法的签名与`_write`类似——它接受三个参数，`chunk`、`encoding`和`callback`。当数据被转换后，应执行回调，这允许转换流异步解析数据。
- en: '[Listing 5.10](#ch05ex10) shows a transform stream that parses (albeit simplified)
    CSV data. The CSV is expected to contain comma-separated values without extra
    spaces or quotes, and should use Unix line endings.'
  id: totrans-1255
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表5.10](#ch05ex10) 展示了一个转换流，它可以解析（尽管是简化的）CSV数据。CSV应包含逗号分隔的值，没有额外的空格或引号，并应使用Unix行结束符。'
- en: Listing 5.10\. A CSV parser implemented using a transform stream
  id: totrans-1256
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.10\. 使用转换流实现的CSV解析器
- en: '![](ch05ex10-0.jpg)'
  id: totrans-1257
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch05ex10-0.jpg)'
- en: '![](ch05ex10-1.jpg)'
  id: totrans-1258
  prefs: []
  type: TYPE_IMG
  zh: '![图片](ch05ex10-1.jpg)'
- en: Parsing CSV involves tracking several variables—the current value, the headers
    for the file, and the current line number ![](1.jpg). To do this, a `stream.Transform`
    descendent with suitable properties can be used. The `_transform` implementation
    ![](2.jpg) is the most complex part of this example. It receives a chunk of data,
    which is iterated over one character at a time using a `for` loop ![](3.jpg).
    If the character is a comma, the current value is saved ![](4.jpg) (if there is
    one). If the current character is a newline, the line is transformed into a JSON
    representation ![](5.jpg). This example is synchronous, so it’s safe to execute
    the callback supplied to `_transform` at the end of the method ![](6.jpg). A `toObject`
    method has been included to make it easier to change the internal representation
    of the headers and values into a JavaScript object ![](7.jpg).
  id: totrans-1259
  prefs: []
  type: TYPE_NORMAL
  zh: 解析CSV涉及跟踪几个变量——当前值、文件的标题和当前行号 ![图片](1.jpg)。为此，可以使用具有合适属性的`stream.Transform`子类。`_transform`实现
    ![图片](2.jpg) 是此示例中最复杂的一部分。它接收一块数据，使用`for`循环逐字符迭代 ![图片](3.jpg)。如果字符是逗号，则保存当前值（如果有的话）
    ![图片](4.jpg)。如果当前字符是换行符，则将行转换为JSON表示 ![图片](5.jpg)。此示例是同步的，因此可以在方法末尾安全地执行提供给`_transform`的回调
    ![图片](6.jpg)。已包含`toObject`方法，以便更容易地将标题和值的内部表示转换为JavaScript对象 ![图片](7.jpg)。
- en: The last line in the example creates a readable file stream of CSV data and
    pipes it through the CSV parser, and that output is piped again back through `stdout`
    so the results can be viewed ![](8.jpg). This could also be piped through a compression
    module to directly support compressed CSV files, or anything else you can think
    of doing with `pipe` and streams.
  id: totrans-1260
  prefs: []
  type: TYPE_NORMAL
  zh: 示例中的最后一行创建了一个可读的CSV数据文件流，并将其通过CSV解析器，然后该输出再次通过`stdout`管道传输，以便可以查看结果 ![图片](8.jpg)。这也可以通过压缩模块直接支持压缩CSV文件，或者你可以想到使用`pipe`和流进行任何其他操作。
- en: This example doesn’t implement all of the things real-world CSV files can contain,
    but it does show that building streaming parsers with `stream.Transform` isn’t
    too complicated, depending on the file format or protocol.
  id: totrans-1261
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例并未实现现实世界中CSV文件可能包含的所有内容，但它确实展示了使用`stream.Transform`构建流式解析器并不复杂，这取决于文件格式或协议。
- en: Now that you’ve learned how to use the base classes, you’re probably wondering
    what the `options` argument in [listing 5.10](#ch05ex10) was used for. The next
    section includes some details on how to use options to optimize stream throughput,
    and details some more advanced techniques.
  id: totrans-1262
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经学会了如何使用基类，你可能想知道[列表5.10](#ch05ex10)中的`options`参数是用来做什么的。下一节将详细介绍如何使用选项来优化流吞吐量，并详细说明一些更高级的技术。
- en: 5.5\. Advanced patterns and optimization
  id: totrans-1263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.5\. 高级模式和优化
- en: The stream base classes accept various options for tailoring their behavior,
    and some of these options can be used to tune performance. This section has techniques
    for optimizing streams, using the older streams API, adapting streams based on
    input, and testing streams.
  id: totrans-1264
  prefs: []
  type: TYPE_NORMAL
  zh: 流基类接受各种选项来定制其行为，其中一些选项可用于调整性能。本节包含优化流的技巧，使用较旧的流API，根据输入调整流，以及测试流。
- en: Technique 35 Optimizing streams
  id: totrans-1265
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 技巧35 优化流
- en: Built-in streams and the classes used to build custom streams allow the internal
    buffer size to be configured. It’s useful to know how to optimize this value to
    attain the desired performance characteristics.
  id: totrans-1266
  prefs: []
  type: TYPE_NORMAL
  zh: 内置流和用于构建自定义流的类允许配置内部缓冲区大小。了解如何优化此值以获得所需性能特性是有用的。
- en: Problem
  id: totrans-1267
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: You want to read data from a file, but are concerned about either speed or memory
    performance.
  id: totrans-1268
  prefs: []
  type: TYPE_NORMAL
  zh: 你想从文件中读取数据，但担心速度或内存性能。
- en: Solution
  id: totrans-1269
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案
- en: Optimize the stream’s buffer size to suit your application’s requirements.
  id: totrans-1270
  prefs: []
  type: TYPE_NORMAL
  zh: 优化流缓冲区大小以适应应用程序的需求。
- en: Discussion
  id: totrans-1271
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论
- en: The built-in stream functions take a buffer size parameter, which allows the
    performance characteristics to be tailored to a given application. The `fs.createReadStream`
    method takes an `options` argument that can include a `bufferSize` property. This
    option is passed to `stream.Readable`, so it’ll control the internal buffer used
    to temporarily store file data before it’s used elsewhere.
  id: totrans-1272
  prefs: []
  type: TYPE_NORMAL
  zh: 内置的流函数接受一个缓冲区大小参数，这使得可以根据给定的应用程序调整性能特征。`fs.createReadStream` 方法接受一个 `options`
    参数，它可以包含一个 `bufferSize` 属性。此选项传递给 `stream.Readable`，因此它将控制用于在文件被用于其他地方之前临时存储文件数据的内部缓冲区。
- en: The stream created by `zlib.createGzip` is an instance of `streams.Transform`,
    and the `Zlib` class creates its own internal buffer object for storing data.
    Controlling the size of this buffer is also possible, but this time the options
    property is `chunkSize`. Node’s documentation has a section on optimizing the
    memory usage of zlib,^([[1](#ch05fn01)]) based on the documentation in the zlib/zconf.h
    header file, which is part of the low-level source code used to implement zlib
    itself.
  id: totrans-1273
  prefs: []
  type: TYPE_NORMAL
  zh: 由 `zlib.createGzip` 创建的流是 `streams.Transform` 的一个实例，而 `Zlib` 类为其存储数据创建了自己的内部缓冲区对象。控制这个缓冲区的大小也是可能的，但这次选项属性是
    `chunkSize`。Node 的文档有一个关于优化 zlib 内存使用的部分，^([[1](#ch05fn01)]) 基于zlib/zconf.h头文件中的文档，这是实现
    zlib 本身所使用的低级源代码的一部分。
- en: ¹ See “Memory Usage Tuning”—[http://nodejs.org/docs/latest/api/all.html#all_process_memoryusage](http://nodejs.org/docs/latest/api/all.html#all_process_memoryusage).
  id: totrans-1274
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹ 请参阅“内存使用调整”——[http://nodejs.org/docs/latest/api/all.html#all_process_memoryusage](http://nodejs.org/docs/latest/api/all.html#all_process_memoryusage).
- en: In practice it’s quite difficult to push Node’s streams to exhibit different
    CPU performance characteristics based on buffer size. But to illustrate the concept,
    we’ve included a small benchmarking script that includes some interesting ideas
    about measuring stream performance. The next listing attempts to gather statistics
    on memory and elapsed time.
  id: totrans-1275
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，根据缓冲区大小推动 Node 的流以展示不同的 CPU 性能特征相当困难。但为了说明这个概念，我们包含了一个小的基准测试脚本，其中包含了一些关于测量流性能的有趣想法。接下来的列表尝试收集关于内存和经过时间的统计数据。
- en: Listing 5.11\. Benchmarking streams
  id: totrans-1276
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.11\. 流的基准测试
- en: '![](ch05ex11-0.jpg)'
  id: totrans-1277
  prefs: []
  type: TYPE_IMG
  zh: '![](ch05ex11-0.jpg)'
- en: '![](ch05ex11-1.jpg)'
  id: totrans-1278
  prefs: []
  type: TYPE_IMG
  zh: '![](ch05ex11-1.jpg)'
- en: This is a long example, but it just uses some of Node’s built-in functionality
    to gather memory statistics over time for streams designed to use different buffer
    sizes. The `benchStream` function performs most of the work and is executed several
    times. It records the current time using `hrtime` ![](1.jpg), which returns more
    precise measurements than `Date.now()` would. The input stream is the Unix dictionary
    file, which is piped through a gzip stream and then out to a file ![](5.jpg).
    Then `benchStream` uses `setInterval` to run a periodic check on the memory usage
    ![](2.jpg). When the input stream ends ![](3.jpg), the memory usage is calculated
    based on the values before and after the input file was gzipped.
  id: totrans-1279
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很长的例子，但它只是使用了一些 Node 内置的功能来收集不同缓冲区大小的流随时间变化的内存统计数据。`benchStream` 函数执行了大部分工作，并多次执行。它使用
    `hrtime` 记录当前时间 ![](1.jpg)，这比 `Date.now()` 返回的测量更精确。输入流是 Unix 字典文件，它通过 gzip 流管道传输，然后输出到文件
    ![](5.jpg)。然后 `benchStream` 使用 `setInterval` 对内存使用进行周期性检查 ![](2.jpg)。当输入流结束时 ![](3.jpg)，将根据压缩前后的值计算内存使用量。
- en: The `run` function doubles the input file’s buffer and gzip buffer ![](6.jpg)
    to show the impact on memory and the time taken to read the streams over time.
    When the reading of the input file completes, the memory usage and elapsed time
    will be printed ![](4.jpg). The input file is returned by the `benchStream` function
    so `run` can easily be called when benchmarking has finished. The `run` function
    will be called repeatedly ![](7.jpg), depending on the first argument passed to
    it ![](8.jpg).
  id: totrans-1280
  prefs: []
  type: TYPE_NORMAL
  zh: '`run` 函数将输入文件的缓冲区和 gzip 缓冲区加倍 ![](6.jpg) 以展示对内存和随时间读取流所需时间的影響。当输入文件的读取完成时，将打印内存使用量和经过时间
    ![](4.jpg)。输入文件由 `benchStream` 函数返回，这样 `run` 就可以在基准测试完成后轻松调用。`run` 函数将被反复调用 ![](7.jpg)，具体取决于传递给它的第一个参数
    ![](8.jpg)。'
- en: Note that `process.hrtime` has been used to accurately benchmark the elapsed
    time. This method can be used for benchmarking because it’s precise, and also
    accepts a `time` argument for automatically calculating the elapsed time.
  id: totrans-1281
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，已经使用了 `process.hrtime` 来准确基准测试经过时间。此方法可用于基准测试，因为它很精确，并且接受一个 `time` 参数来自动计算经过时间。
- en: I (Alex) ran this program with a 20 MB file to try to generate more interesting
    results than /usr/share/dict/words, and I’ve included a graph of the results in
    [figure 5.5](#ch05fig05).
  id: totrans-1282
  prefs: []
  type: TYPE_NORMAL
  zh: 我（亚历克斯）用20MB的文件运行了这个程序，试图产生比 /usr/share/dict/words 更有趣的结果，并且我已经包括了结果的图表在 [图5.5](#ch05fig05)
    中。
- en: Figure 5.5\. A graphical representation of the memory usage of streams
  id: totrans-1283
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.5. 流的内存使用图形表示
- en: '![](05fig05.jpg)'
  id: totrans-1284
  prefs: []
  type: TYPE_IMG
  zh: '![图5.5](05fig05.jpg)'
- en: I found when I experimented with various files that the results indicated that
    elapsed time was far less affected than the memory usage. That indicates that
    it’s generally desirable to use smaller buffers and be more conservative about
    memory usage, although this test should be repeated with a load-testing benchmark
    to really see how long it takes Node to process those buffers.
  id: totrans-1285
  prefs: []
  type: TYPE_NORMAL
  zh: 我发现当我尝试各种文件时，结果表明经过的时间远不如内存使用受影响大。这表明，通常使用较小的缓冲区并对内存使用更加谨慎是可取的，尽管这个测试应该与负载测试基准一起重复进行，才能真正看到Node处理这些缓冲区需要多长时间。
- en: Node had an older API for streams that had different semantics for pausing a
    stream. Although the newer API should be used where possible, it’s possible to
    use the older API alongside the newer one. The next technique demonstrates how
    to use modules written with the older API.
  id: totrans-1286
  prefs: []
  type: TYPE_NORMAL
  zh: Node有一个较旧的流API，它对暂停流的语义不同。尽管应该尽可能使用较新的API，但可以在较新的API旁边使用较旧的API。下一个技巧将演示如何使用使用较旧API编写的模块。
- en: Technique 36 Using the old streams API
  id: totrans-1287
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 技巧36 使用旧的流API
- en: Before Node 0.10 (and technically 0.9.4), streams had a different API. Code
    written using that API can be used with the newer APIs by wrapping it to behave
    like the newer `stream.Readable` class.
  id: totrans-1288
  prefs: []
  type: TYPE_NORMAL
  zh: 在Node 0.10（技术上为0.9.4）之前，流有不同的API。使用该API编写的代码可以通过将其包装成表现得像较新的 `stream.Readable`
    类来与较新的API一起使用。
- en: Problem
  id: totrans-1289
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: You want to use a module that implements the old-style streaming API with classes
    that use the newer APIs.
  id: totrans-1290
  prefs: []
  type: TYPE_NORMAL
  zh: 您想使用一个实现旧式流API并使用较新API的类的模块。
- en: Solution
  id: totrans-1291
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use `Readable.prototype.wrap`.
  id: totrans-1292
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Readable.prototype.wrap`。
- en: Discussion
  id: totrans-1293
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论
- en: The older stream API had readable and writable streams, but pausing a stream
    was “advisory” only. This led to a different API design that wasn’t based around
    the newer streams2 classes. As people gradually realized how useful streamable
    classes are, a wealth of modules appeared on npm. Although the newer API solves
    key problems with the older design, there are still useful modules that haven’t
    been updated.
  id: totrans-1294
  prefs: []
  type: TYPE_NORMAL
  zh: 较旧的流API有可读和可写流，但暂停流只是“建议性的”。这导致了一个不同的API设计，该设计不是基于较新的 streams2 类。随着人们逐渐意识到可流式类是多么有用，npm上出现了大量模块。尽管较新的API解决了较旧设计中的关键问题，但仍有一些有用的模块尚未更新。
- en: Fortunately, older classes can be wrapped using the `Readable.prototype.wrap`
    method provided by the `stream` module. It literally wraps the older interface
    to make it behave like the newer `stream.Readable` class—it effectively creates
    a `Readable` instance that uses the older class as its data source.
  id: totrans-1295
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，可以使用 `stream` 模块提供的 `Readable.prototype.wrap` 方法将较旧的类包装起来。它实际上将较旧的接口包装起来，使其表现得像较新的
    `stream.Readable` 类——它有效地创建了一个使用较旧类作为其数据源的 `Readable` 实例。
- en: '[Listing 5.12](#ch05ex12) shows an example of a stream implemented with the
    older API that has been wrapped with the newer `Readable` class.'
  id: totrans-1296
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表5.12](#ch05ex12) 展示了一个使用较旧API实现并已用较新的 `Readable` 类包装的流示例。'
- en: Listing 5.12\. An old-style stream that has been wrapped
  id: totrans-1297
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.12. 已被包装的旧式流
- en: '![](108fig01_alt.jpg)'
  id: totrans-1298
  prefs: []
  type: TYPE_IMG
  zh: '![图108.1](108fig01_alt.jpg)'
- en: The example in [listing 5.12](#ch05ex12) presents a simple class that inherits
    from the Node 0.8 stream module. The `readable` property ![](1.jpg) is part of
    the old API, and signifies that this is a readable stream. Another indicator that
    this is a legacy stream is the `data` event ![](2.jpg). The newer `Readable.prototype.wrap`
    method ![](3.jpg) is what translates all of this to make it compatible with the
    streams2 API style. At the end, the wrapped stream is piped to a Node 0.10 stream
    ![](4.jpg).
  id: totrans-1299
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表5.12](#ch05ex12) 中的示例展示了一个从Node 0.8流模块继承的简单类。`readable` 属性 ![图1](1.jpg)
    是旧API的一部分，表示这是一个可读流。另一个表明这是遗留流的是 `data` 事件 ![图2](2.jpg)。较新的 `Readable.prototype.wrap`
    方法 ![图3](3.jpg) 是将所有这些转换为与 streams2 API 风格兼容的东西。最后，包装后的流被管道传输到Node 0.10流 ![图4](4.jpg)。'
- en: Now you should be able to use older streams with the newer APIs!
  id: totrans-1300
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您应该能够使用较旧的流与新的API一起使用了！
- en: Sometimes streams need to change their behavior depending on the type of input
    that has been provided. The next technique looks at ways of doing just that.
  id: totrans-1301
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，流需要根据提供的输入类型改变其行为。下一个技巧将探讨实现这一点的各种方法。
- en: Technique 37 Adapting streams based on their destination
  id: totrans-1302
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 技巧 37 基于目标适应流
- en: Stream classes are typically designed to solve a specific problem, but there’s
    also potential for customizing their behavior by detecting how the stream is being
    used.
  id: totrans-1303
  prefs: []
  type: TYPE_NORMAL
  zh: 流类通常是为了解决特定问题而设计的，但通过检测流的使用方式，也有可能自定义它们的行为。
- en: Problem
  id: totrans-1304
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: You want to make a stream behave differently when it’s piped to the TTY (the
    user’s shell).
  id: totrans-1305
  prefs: []
  type: TYPE_NORMAL
  zh: 当流被管道传输到 TTY（用户的 shell）时，你希望流有不同的行为。
- en: Solution
  id: totrans-1306
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案
- en: Bind a listener to the `pipe` event, and then use `stream.isTTY` to check if
    the stream is bound to a terminal.
  id: totrans-1307
  prefs: []
  type: TYPE_NORMAL
  zh: 将监听器绑定到 `pipe` 事件，然后使用 `stream.isTTY` 来检查流是否绑定到终端。
- en: Discussion
  id: totrans-1308
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论
- en: This technique is a specific example of adapting a stream’s behavior to its
    environment, but the general approach could be adapted to other problems as well.
    Sometimes it’s useful to detect whether a stream is writing output to a TTY or
    something else—perhaps a file—because different behavior in each is desirable.
    For example, when printing to a TTY, some commands will use ANSI colors, but this
    isn’t usually advisable when writing files because strange characters would clutter
    the results.
  id: totrans-1309
  prefs: []
  type: TYPE_NORMAL
  zh: 这项技术是适应流行为到其环境的具体示例，但一般方法也可以适应其他问题。有时检测流是否将输出写入 TTY 或其他（例如文件）是有用的，因为每种情况都希望有不同的行为。例如，当打印到
    TTY 时，一些命令将使用 ANSI 颜色，但通常不建议在写入文件时这样做，因为奇怪的字符会弄乱结果。
- en: Node makes detecting whether the current process is connected to a TTY simple—just
    use `process.stdout.isTTY` and `process.stdin.isTTY`. These are Boolean properties
    that are derived from OS-level bindings in Node’s source (in lib/tty.js).
  id: totrans-1310
  prefs: []
  type: TYPE_NORMAL
  zh: Node 使检测当前进程是否连接到 TTY 变得简单——只需使用 `process.stdout.isTTY` 和 `process.stdin.isTTY`。这些是布尔属性，它们来自
    Node 源代码中的 OS 级绑定（在 lib/tty.js 中）。
- en: The strategy to use for adapting a stream’s output is to create a new `stream.Writable`
    class and set an internal property based on `isTTY`. Then add a listener to the
    `pipe` event, which changes `isTTY` based on the newly piped stream that’s passed
    as the first argument to the listener callback.
  id: totrans-1311
  prefs: []
  type: TYPE_NORMAL
  zh: 适应流输出的策略是创建一个新的 `stream.Writable` 类，并根据 `isTTY` 设置一个内部属性。然后添加一个监听器到 `pipe` 事件，该事件根据作为监听器回调的第一个参数传递的新管道流来改变
    `isTTY`。
- en: '[Listing 5.13](#ch05ex13) demonstrates this by using two classes. The first,
    `MemoryStream`, inherits from `stream.Readable` and generates data based on Node’s
    memory usage. The second, `OutputStream`, monitors the stream it’s bound to so
    it can tell the readable stream about what kind of output it expects.'
  id: totrans-1312
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 5.13](#ch05ex13) 通过使用两个类来演示这一点。第一个类，`MemoryStream`，继承自 `stream.Readable`，并基于
    Node 的内存使用情况生成数据。第二个类，`OutputStream`，监视它所绑定的流，以便它能告诉可读流它期望的输出类型。'
- en: Listing 5.13\. Using `isTTY` to adapt stream behavior
  id: totrans-1313
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.13\. 使用 `isTTY` 来适应流的行为
- en: '![](ch05ex13-0.jpg)'
  id: totrans-1314
  prefs: []
  type: TYPE_IMG
  zh: '![](ch05ex13-0.jpg)'
- en: '![](ch05ex13-1.jpg)'
  id: totrans-1315
  prefs: []
  type: TYPE_IMG
  zh: '![](ch05ex13-1.jpg)'
- en: Internally, Node uses `isTTY` to adapt the behavior of the `repl` module and
    the `readline` interface. The example in [listing 5.13](#ch05ex13) tracks the
    state of `process.stdout.isTTY` ![](1.jpg) to determine what the original output
    stream was, and then copies that value to subsequent destinations ![](3.jpg).
    When the terminal is a TTY, colors are used ![](2.jpg); otherwise plain text is
    output instead.
  id: totrans-1316
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，Node 使用 `isTTY` 来适应 `repl` 模块和 `readline` 接口的行為。列表 5.13 中的示例跟踪 `process.stdout.isTTY`
    的状态 ![](1.jpg) 以确定原始输出流是什么，然后将该值复制到后续目的地 ![](3.jpg)。当终端是 TTY 时，使用颜色 ![](2.jpg)；否则输出纯文本。
- en: Streams, like anything else, should be tested. The next technique presents a
    method for writing unit tests for your own stream classes.
  id: totrans-1317
  prefs: []
  type: TYPE_NORMAL
  zh: 流，就像其他任何东西一样，都应该进行测试。接下来的技术介绍了一种为你的自定义流类编写单元测试的方法。
- en: Technique 38 Testing streams
  id: totrans-1318
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 技巧 38 测试流
- en: Just like anything else you write, it’s strongly recommended that you test your
    streams. This technique explains how to use Node’s built-in `assert` module to
    test a class that inherits from `stream.Readable`.
  id: totrans-1319
  prefs: []
  type: TYPE_NORMAL
  zh: 就像你写的任何其他东西一样，强烈建议你测试你的流。这项技术解释了如何使用 Node 的内置 `assert` 模块来测试继承自 `stream.Readable`
    的类。
- en: Problem
  id: totrans-1320
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: You’ve written your own stream class and you want to write a unit test for it.
  id: totrans-1321
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经编写了自己的流类，并想要为它编写一个单元测试。
- en: Solution
  id: totrans-1322
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use some suitable sample data to drive your stream class, and then call `read()`
    or `write()` to gather the results and compare them to the expected output.
  id: totrans-1323
  prefs: []
  type: TYPE_NORMAL
  zh: 使用一些合适的样本数据来驱动你的流类，然后调用 `read()` 或 `write()` 来收集结果，并将它们与预期的输出进行比较。
- en: Discussion
  id: totrans-1324
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论
- en: The common pattern for testing streams, used in Node’s source itself and by
    many open source developers, is to drive the stream being tested using sample
    data and then compare the end results against expected values.
  id: totrans-1325
  prefs: []
  type: TYPE_NORMAL
  zh: 测试流的常见模式，在 Node 的源代码中使用，并被许多开源开发者使用，是使用样本数据驱动测试流，然后将最终结果与预期值进行比较。
- en: The most difficult part of this can be coming up with suitable data to test.
    Sometimes it’s easy to create a text file, or a *fixture* in testing nomenclature,
    that can be used to drive the stream by piping it. If you’re testing a network-oriented
    stream, then you should consider using Node’s `net` or `http` modules to create
    “mock” servers that generate suitable test data.
  id: totrans-1326
  prefs: []
  type: TYPE_NORMAL
  zh: 这中最困难的部分可能是找到合适的数据进行测试。有时创建一个文本文件或测试术语中的*固定装置*很容易，可以通过管道将其用于驱动流。如果你正在测试一个面向网络的流，那么你应该考虑使用
    Node 的 `net` 或 `http` 模块来创建“模拟”服务器，以生成合适的测试数据。
- en: '[Listing 5.14](#ch05ex14) is a modified version of the CSV parser from [technique
    34](#ch05lev2sec13); it has been turned into a module so we can easily test it.
    [Listing 5.15](#ch05ex15) is the associated test that creates an instance of `CSVParser`
    and then pushes some values through it.'
  id: totrans-1327
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 5.14](#ch05ex14) 是 [技术 34](#ch05lev2sec13) 中的 CSV 解析器的修改版本；它已被转换为模块，以便我们可以轻松测试它。[列表
    5.15](#ch05ex15) 是相关的测试，它创建了一个 `CSVParser` 实例，然后通过它推送一些值。'
- en: Listing 5.14\. The `CSVParser` stream
  id: totrans-1328
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.14\. `CSVParser` 流
- en: '![](ch05ex14-0.jpg)'
  id: totrans-1329
  prefs: []
  type: TYPE_IMG
  zh: '![](ch05ex14-0.jpg)'
- en: '![](ch05ex14-1.jpg)'
  id: totrans-1330
  prefs: []
  type: TYPE_IMG
  zh: '![](ch05ex14-1.jpg)'
- en: The `CSVParser` class is exported using `module.exports` so it can be loaded
    by the unit test ![](1.jpg). The `_transform` method ![](2.jpg) will run later
    when `push` is called on an instance of this class. Next up is a simple unit test
    for this class.
  id: totrans-1331
  prefs: []
  type: TYPE_NORMAL
  zh: '`CSVParser` 类使用 `module.exports` 导出，以便单元测试 ![](1.jpg) 可以加载它。当在类的实例上调用 `push`
    时，`_transform` 方法 ![](2.jpg) 将稍后运行。接下来是这个类的一个简单的单元测试。'
- en: Listing 5.15\. Testing the `CSVParser` stream
  id: totrans-1332
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.15\. 测试 `CSVParser` 流
- en: '![](112fig01_alt.jpg)'
  id: totrans-1333
  prefs: []
  type: TYPE_IMG
  zh: '![](112fig01_alt.jpg)'
- en: A fixture file, sample.csv, has been used to pipe data to the `CSVParser` instance.
    Then the `assert.deepEqual` method has been used to make it easy to compare the
    expected array with the actual array.
  id: totrans-1334
  prefs: []
  type: TYPE_NORMAL
  zh: 使用了固定文件 sample.csv 将数据管道传输到 `CSVParser` 实例。然后使用 `assert.deepEqual` 方法来轻松比较预期数组和实际数组。
- en: A listener is attached to `exit` ![](1.jpg) because we want to wait for the
    streams to finish processing the data before running the assertion. Then data
    is `read` ![](2.jpg) from the parser and pushed to an array to examine with assertions
    ![](4.jpg)—the expected values are defined first ![](3.jpg). This pattern is used
    in Node’s own streams tests, and is a lightweight version of what test frameworks
    like Mocha and node-tap provide.
  id: totrans-1335
  prefs: []
  type: TYPE_NORMAL
  zh: 一个监听器被附加到 `exit` ![](1.jpg)，因为我们想在运行断言之前等待流完成数据处理。然后从解析器中读取数据 ![](2.jpg)，并将其推送到数组中以进行断言检查
    ![](4.jpg)——预期值首先定义 ![](3.jpg)。这种模式在 Node 的自身流测试中使用，并且是测试框架如 Mocha 和 node-tap
    提供的轻量级版本。
- en: 5.6\. Summary
  id: totrans-1336
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.6\. 摘要
- en: In this chapter you’ve seen how the built-in streamable APIs work, how to create
    new and novel streams using the base classes provided by Node, and how to use
    some more advanced techniques to structure programs with streams. As you saw in
    [technique 36](#ch05lev2sec15), building new streams starts with correctly inheriting
    from the base classes—and don’t forget to test those streams! For more on testing,
    refer back to [technique 38](#ch05lev2sec17).
  id: totrans-1337
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你看到了内置的流式 API 的工作方式，如何使用 Node 提供的基类创建新的和独特的流，以及如何使用一些更高级的技术用流来结构化程序。正如你在
    [技术 36](#ch05lev2sec15) 中所看到的，构建新的流始于正确地从基类继承——别忘了测试这些流！有关测试的更多信息，请参阅 [技术 38](#ch05lev2sec17)。
- en: 'As you saw, there are some novel uses of streams, like substack’s `baudio`
    module ([https://github.com/substack/baudio](https://github.com/substack/baudio))
    that speaks in streams of sound waves. There are also *two* streams APIs: the
    original Node 0.8 and below API, and the newer streams2 API. Forward compatibility
    is supported through the `readable-stream` module ([https://github.com/isaacs/readable-stream](https://github.com/isaacs/readable-stream)),
    and backward compatibility is made possible by wrapping streams ([technique 36](#ch05lev2sec15)).'
  id: totrans-1338
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，有一些关于流的创新用法，比如 substack 的 `baudio` 模块 ([https://github.com/substack/baudio](https://github.com/substack/baudio))，它通过声音波流进行交流。还有*两个*流
    API：原始的 Node 0.8 及以下 API 和更新的 streams2 API。通过 `readable-stream` 模块 ([https://github.com/isaacs/readable-stream](https://github.com/isaacs/readable-stream))
    支持向前兼容性，通过包装流 ([技术 36](#ch05lev2sec15)) 实现向后兼容性。
- en: A big part of working with streams is handling files. In the next chapter we’ll
    look at Node’s file system handling in detail.
  id: totrans-1339
  prefs: []
  type: TYPE_NORMAL
  zh: 与流一起工作的很大一部分是处理文件。在下一章中，我们将详细探讨Node的文件系统处理。
- en: 'Chapter 6\. File system: Synchronous and asynchronous approaches to files'
  id: totrans-1340
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第6章. 文件系统：文件同步和异步方法
- en: '*This chapter covers*'
  id: totrans-1341
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Understanding the `fs` module and its components
  id: totrans-1342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解`fs`模块及其组件
- en: Working with configuration files and file descriptors
  id: totrans-1343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置文件和文件描述符的处理
- en: Using file-locking techniques
  id: totrans-1344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用文件锁定技术
- en: Recursive file operations
  id: totrans-1345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归文件操作
- en: Writing a file database
  id: totrans-1346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写文件数据库
- en: Watching files and directories
  id: totrans-1347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控文件和目录
- en: As we’ve noted in previous chapters, Node’s core modules typically stick to
    a low-level API. This allows for various (even competing) ideas and implementations
    of higher-level concepts like web frameworks, file parsers, and command-line tools
    to exist as third-party modules. The `fs` (or file system) module is no different.
  id: totrans-1348
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的章节中提到的，Node的核心模块通常坚持使用低级API。这允许各种（甚至竞争的）高级概念（如Web框架、文件解析器和命令行工具）作为第三方模块存在。`fs`（或文件系统）模块也不例外。
- en: The `fs` module allows the developer to interact with the file system by providing
  id: totrans-1349
  prefs: []
  type: TYPE_NORMAL
  zh: '`fs`模块通过提供'
- en: POSIX file I/O primitives
  id: totrans-1350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: POSIX文件I/O原语
- en: File streaming
  id: totrans-1351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件流
- en: Bulk file I/O
  id: totrans-1352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 批量文件I/O
- en: File watching
  id: totrans-1353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件监控
- en: The `fs` module is unique compared with other I/O modules (like `net` and `http`)
    in that it has both asynchronous and synchronous APIs. That means that it provides
    a mechanism to perform blocking I/O. The reason the file system also has a synchronous
    API is largely because of the internal workings of Node itself, namely, the module
    system and the synchronous behavior of `require`.
  id: totrans-1354
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他I/O模块（如`net`和`http`）相比，`fs`模块的独特之处在于它既有异步API也有同步API。这意味着它提供了一个执行阻塞I/O的机制。文件系统也有同步API的原因很大程度上是因为Node本身的内部工作方式，即模块系统和`require`的同步行为。
- en: The goal of this chapter is to show you a number of techniques, of varying complexity,
    to use when working with the file system module. We’ll look at
  id: totrans-1355
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标是向您展示一系列不同复杂度的技术，以便在处理文件系统模块时使用。我们将探讨
- en: Asynchronous and synchronous approaches for loading configuration files
  id: totrans-1356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载配置文件的异步和同步方法
- en: Working with the file descriptors
  id: totrans-1357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件描述符的处理
- en: Advisory file-locking techniques
  id: totrans-1358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建议性文件锁定技术
- en: Recursive file operations
  id: totrans-1359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归文件操作
- en: Writing a file database
  id: totrans-1360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写文件数据库
- en: Watching for file and directory changes
  id: totrans-1361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控文件和目录变化
- en: But before we get to the techniques, let’s first take a high-level view of all
    you can do with the file system API in order to capture the functionality and
    provide some insight into what tool may be the best for the job.
  id: totrans-1362
  prefs: []
  type: TYPE_NORMAL
  zh: 但在我们深入这些技术之前，让我们首先从高层次上了解您可以使用文件系统API做什么，以便捕捉其功能并提供一些关于哪个工具可能是最佳选择的见解。
- en: 6.1\. An overview of the fs module
  id: totrans-1363
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1. fs模块概述
- en: The fs module includes wrappers for common POSIX file operations, as well as
    bulk, stream, and watching operations. It also has synchronous APIs for many of
    the operations. Let’s take a high-level walk through the different components.
  id: totrans-1364
  prefs: []
  type: TYPE_NORMAL
  zh: '`fs`模块包括常见POSIX文件操作的包装器，以及批量、流和监控操作。它还为许多操作提供了同步API。让我们从高层次上浏览不同的组件。'
- en: 6.1.1\. POSIX file I/O wrappers
  id: totrans-1365
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.1.1. POSIX文件I/O包装器
- en: 'At a bird’s-eye view, the majority of methods in the file system API are wrappers
    around standard POSIX file I/O calls ([http://mng.bz/7EKM](http://mng.bz/7EKM)).
    These methods will have a similar name. For example, the `readdir` call ([http://linux.die.net/man/3/readdir](http://linux.die.net/man/3/readdir))
    has an `fs.readdir` counterpart in Node:'
  id: totrans-1366
  prefs: []
  type: TYPE_NORMAL
  zh: 从宏观角度来看，文件系统API中的大多数方法都是围绕标准POSIX文件I/O调用（[http://mng.bz/7EKM](http://mng.bz/7EKM)）的包装。这些方法将具有类似的名字。例如，`readdir`调用（[http://linux.die.net/man/3/readdir](http://linux.die.net/man/3/readdir)）在Node中有`fs.readdir`的对应方法：
- en: '[PRE50]'
  id: totrans-1367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[Table 6.1](#ch06table01) shows a list of the supported POSIX file methods
    in Node, including a description of their functionality.'
  id: totrans-1368
  prefs: []
  type: TYPE_NORMAL
  zh: '[表6.1](#ch06table01)显示了Node支持的POSIX文件方法列表，包括它们的功能描述。'
- en: Table 6.1\. Supported POSIX file methods in Node
  id: totrans-1369
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表6.1. Node支持的POSIX文件方法
- en: '| POSIX method | fs method | Description |'
  id: totrans-1370
  prefs: []
  type: TYPE_TB
  zh: '| POSIX方法 | fs方法 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-1371
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| rename(2) | fs.rename | Changes the name of a file |'
  id: totrans-1372
  prefs: []
  type: TYPE_TB
  zh: '| rename(2) | fs.rename | 更改文件名 |'
- en: '| truncate(2) | fs.truncate | Truncates or extends a file to a specified length
    |'
  id: totrans-1373
  prefs: []
  type: TYPE_TB
  zh: '| truncate(2) | fs.truncate | 截断或扩展文件到指定长度 |'
- en: '| ftruncate(2) | fs.ftruncate | Same as truncate but takes a file descriptor
    |'
  id: totrans-1374
  prefs: []
  type: TYPE_TB
  zh: '| ftruncate(2) | fs.ftruncate | 与 truncate 相同，但接受文件描述符 |'
- en: '| chown(2) | fs.chown | Changes file owner and group |'
  id: totrans-1375
  prefs: []
  type: TYPE_TB
  zh: '| chown(2) | fs.chown | 修改文件所有者和组 |'
- en: '| fchown(2) | fs.fchown | Same as chown but takes a file descriptor |'
  id: totrans-1376
  prefs: []
  type: TYPE_TB
  zh: '| fchown(2) | fs.fchown | 与 chown 相同，但接受文件描述符 |'
- en: '| lchown(2) | fs.lchown | Same as chown but doesn’t follow symbolic links |'
  id: totrans-1377
  prefs: []
  type: TYPE_TB
  zh: '| lchown(2) | fs.lchown | 与 chown 相同，但不跟随符号链接 |'
- en: '| chmod(2) | fs.chmod | Changes file permissions |'
  id: totrans-1378
  prefs: []
  type: TYPE_TB
  zh: '| chmod(2) | fs.chmod | 修改文件权限 |'
- en: '| fchmod(2) | fs.fchmod | Same as chmod but takes a file descriptor |'
  id: totrans-1379
  prefs: []
  type: TYPE_TB
  zh: '| fchmod(2) | fs.fchmod | 与 chmod 相同，但接受文件描述符 |'
- en: '| lchmod(2) | fs.lchmod | Same as chmod but doesn’t follow symbolic links |'
  id: totrans-1380
  prefs: []
  type: TYPE_TB
  zh: '| lchmod(2) | fs.lchmod | 与 chmod 相同，但不跟随符号链接 |'
- en: '| stat(2) | fs.stat | Gets file status |'
  id: totrans-1381
  prefs: []
  type: TYPE_TB
  zh: '| stat(2) | fs.stat | 获取文件状态 |'
- en: '| lstat(2) | fs.lstat | Same as stat but returns information about link if
    provided rather than what the link points to |'
  id: totrans-1382
  prefs: []
  type: TYPE_TB
  zh: '| lstat(2) | fs.lstat | 与 stat 相同，但如果提供了链接信息而不是链接指向的内容，则返回信息 |'
- en: '| fstat(2) | fs.fstat | Same as stat but takes a file descriptor |'
  id: totrans-1383
  prefs: []
  type: TYPE_TB
  zh: '| fstat(2) | fs.fstat | 与 stat 相同，但接受文件描述符 |'
- en: '| link(2) | fs.link | Makes a hard file link |'
  id: totrans-1384
  prefs: []
  type: TYPE_TB
  zh: '| link(2) | fs.link | 创建硬链接 |'
- en: '| symlink(2) | fs.symlink | Makes a symbolic link to a file |'
  id: totrans-1385
  prefs: []
  type: TYPE_TB
  zh: '| symlink(2) | fs.symlink | 创建指向文件的符号链接 |'
- en: '| readlink(2) | fs.readlink | Reads value of a symbolic link |'
  id: totrans-1386
  prefs: []
  type: TYPE_TB
  zh: '| readlink(2) | fs.readlink | 读取符号链接的值 |'
- en: '| realpath(2) | fs.realpath | Returns the canonicalized absolute pathname |'
  id: totrans-1387
  prefs: []
  type: TYPE_TB
  zh: '| realpath(2) | fs.realpath | 返回规范化的绝对路径名 |'
- en: '| unlink(2) | fs.unlink | Removes directory entry |'
  id: totrans-1388
  prefs: []
  type: TYPE_TB
  zh: '| unlink(2) | fs.unlink | 删除目录条目 |'
- en: '| rmdir(2) | fs.rmdir | Removes directory |'
  id: totrans-1389
  prefs: []
  type: TYPE_TB
  zh: '| rmdir(2) | fs.rmdir | 删除目录 |'
- en: '| mkdir(2) | fs.mkdir | Makes directory |'
  id: totrans-1390
  prefs: []
  type: TYPE_TB
  zh: '| mkdir(2) | fs.mkdir | 创建目录 |'
- en: '| readdir(2) | fs.readdir | Reads contents of a directory |'
  id: totrans-1391
  prefs: []
  type: TYPE_TB
  zh: '| readdir(2) | fs.readdir | 读取目录内容 |'
- en: '| close(2) | fs.close | Deletes a file descriptor |'
  id: totrans-1392
  prefs: []
  type: TYPE_TB
  zh: '| close(2) | fs.close | 删除文件描述符 |'
- en: '| open(2) | fs.open | Opens or creates a file for reading or writing |'
  id: totrans-1393
  prefs: []
  type: TYPE_TB
  zh: '| open(2) | fs.open | 打开或创建文件以供读取或写入 |'
- en: '| utimes(2) | fs.utimes | Sets file access and modification times |'
  id: totrans-1394
  prefs: []
  type: TYPE_TB
  zh: '| utimes(2) | fs.utimes | 设置文件访问和修改时间 |'
- en: '| futimes(2) | fs.futimes | Same as utimes but takes a file descriptor |'
  id: totrans-1395
  prefs: []
  type: TYPE_TB
  zh: '| futimes(2) | fs.futimes | 与 utimes 相同，但接受文件描述符 |'
- en: '| fsync(2) | fs.fsync | Synchronizes file data with disk |'
  id: totrans-1396
  prefs: []
  type: TYPE_TB
  zh: '| fsync(2) | fs.fsync | 将文件数据与磁盘同步 |'
- en: '| write(2) | fs.write | Writes data to a file |'
  id: totrans-1397
  prefs: []
  type: TYPE_TB
  zh: '| write(2) | fs.write | 将数据写入文件 |'
- en: '| read(2) | fs.read | Reads data from a file |'
  id: totrans-1398
  prefs: []
  type: TYPE_TB
  zh: '| read(2) | fs.read | 从文件中读取数据 |'
- en: 'The POSIX methods provide a low-level API to many common file operations. For
    example, here we use a number of synchronous POSIX methods to write data to a
    file and then retrieve that data:'
  id: totrans-1399
  prefs: []
  type: TYPE_NORMAL
  zh: POSIX 方法提供了一组常见文件操作的底层 API。例如，这里我们使用了一些同步 POSIX 方法将数据写入文件，然后检索这些数据：
- en: '![](117fig01_alt.jpg)'
  id: totrans-1400
  prefs: []
  type: TYPE_IMG
  zh: '![](117fig01_alt.jpg)'
- en: When it comes to reading and writing files, typically you won’t need a level
    this low, but rather can use a streaming or bulk approach.
  id: totrans-1401
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到读写文件时，通常你不需要这么低的级别，而是可以使用流式或批量方法。
- en: 6.1.2\. Streaming
  id: totrans-1402
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.1.2\. 流式传输
- en: 'The `fs` module provides a streaming API with `fs.createReadStream` and `fs.createWriteStream`.
    `fs.createReadStream` is a `Readable` stream, whereas `fs.createWriteStream` is
    a `Writeable`. The streaming APIs can connect to other streams with `pipe`. For
    example, here’s a simple application that copies a file using streams:'
  id: totrans-1403
  prefs: []
  type: TYPE_NORMAL
  zh: '`fs` 模块提供了 `fs.createReadStream` 和 `fs.createWriteStream` 的流式 API。`fs.createReadStream`
    是一个 `Readable` 流，而 `fs.createWriteStream` 是一个 `Writeable`。流式 API 可以通过 `pipe` 连接到其他流。例如，以下是一个使用流复制文件的简单应用程序：'
- en: '![](117fig02_alt.jpg)'
  id: totrans-1404
  prefs: []
  type: TYPE_IMG
  zh: '![](117fig02_alt.jpg)'
- en: File streaming is beneficial when you want to deal with bits and pieces of data
    at a time or want to chain data sources together. For a more in-depth look at
    streams, check out [chapter 5](kindle_split_014.html#ch05).
  id: totrans-1405
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想一次处理数据的一部分或想将数据源链接在一起时，文件流是有益的。要深入了解流，请查看第 5 章 [chapter 5](kindle_split_014.html#ch05)。
- en: 6.1.3\. Bulk file I/O
  id: totrans-1406
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.1.3\. 批量文件 I/O
- en: The file system API also includes a few bulk methods for reading (`fs.readFile`),
    writing (`fs.writeFile`), or appending (`fs.appendFile`).
  id: totrans-1407
  prefs: []
  type: TYPE_NORMAL
  zh: 文件系统 API 还包括一些用于读取（`fs.readFile`）、写入（`fs.writeFile`）或追加（`fs.appendFile`）的批量方法。
- en: 'The bulk methods are good when you want to load a file into memory or write
    one out completely in one shot:'
  id: totrans-1408
  prefs: []
  type: TYPE_NORMAL
  zh: 批量方法在你想一次性将文件加载到内存或完全写入时很有用：
- en: '![](117fig03_alt.jpg)'
  id: totrans-1409
  prefs: []
  type: TYPE_IMG
  zh: '![](117fig03_alt.jpg)'
- en: 6.1.4\. File watching
  id: totrans-1410
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.1.4\. 文件监控
- en: The `fs` module also provides a couple of mechanisms for watching files (`fs.watch`
    and `fs.watchFile`). This is useful when you want to know if a file has changed
    in some way. `fs.watch` uses the underlying operating system’s notifications,
    making it very efficient. But `fs.watch` can be finicky or simply not work on
    network drives. For those situations, the less-efficient `fs.watchFile` method,
    which uses `stat` polling, can be used.
  id: totrans-1411
  prefs: []
  type: TYPE_NORMAL
  zh: '`fs`模块还提供了一些用于监视文件（`fs.watch`和`fs.watchFile`）的机制。当你想知道文件是否以某种方式发生变化时，这很有用。`fs.watch`使用底层操作系统的通知，使其非常高效。但是`fs.watch`可能在网络驱动器上很挑剔或者根本不起作用。在这种情况下，可以使用效率较低的`fs.watchFile`方法，它使用`stat`轮询。'
- en: We’ll look more at file watching later on in this chapter.
  id: totrans-1412
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章的后面部分更详细地探讨文件监视。
- en: 6.1.5\. Synchronous alternatives
  id: totrans-1413
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.1.5\. 同步替代方案
- en: 'Node’s synchronous file system API sticks out like a sore thumb. With a big
    `Sync` tacked onto the end of each synchronous method, it’s hard to miss its purpose.
    Synchronous methods are available for all the POSIX and bulk API calls. Some examples
    include `readFileSync`, `statSync`, and `readdirSync`. `Sync` tells you that this
    method will block your single-threaded Node process until it has finished. As
    a general rule, synchronous methods should be used when first setting up your
    application, and not within a callback:'
  id: totrans-1414
  prefs: []
  type: TYPE_NORMAL
  zh: Node的同步文件系统API非常显眼。每个同步方法末尾都附加了一个大的`Sync`，这使得其目的难以忽视。同步方法适用于所有POSIX和批量API调用。一些例子包括`readFileSync`、`statSync`和`readdirSync`。`Sync`告诉你这个方法将阻塞你的单线程Node进程，直到它完成。一般来说，同步方法应该在首次设置应用程序时使用，而不是在回调中：
- en: '![](118fig01_alt.jpg)'
  id: totrans-1415
  prefs: []
  type: TYPE_IMG
  zh: '![](118fig01_alt.jpg)'
- en: Of course there are exceptions to the rule, but what’s important is understanding
    the performance implications of using synchronous methods.
  id: totrans-1416
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，规则也有例外，但重要的是理解使用同步方法对性能的影响。
- en: '|  |'
  id: totrans-1417
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Testing server performance**'
  id: totrans-1418
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试服务器性能**'
- en: 'How do we know synchronous execution within the request handling of a web server
    is slower? A great way to test this is using ApacheBench ([http://en.wikipedia.org/wiki/ApacheBench](http://en.wikipedia.org/wiki/ApacheBench)).
    Our earlier example showed a ~2x drop in performance when serving a 10 MB file
    synchronously on every request rather than cached during application setup. Here’s
    the command used in this test:'
  id: totrans-1419
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何知道在Web服务器请求处理中的同步执行速度较慢？一个很好的测试方法是使用ApacheBench ([http://en.wikipedia.org/wiki/ApacheBench](http://en.wikipedia.org/wiki/ApacheBench))。我们之前的例子显示了在每次请求上同步服务10
    MB文件而不是在应用程序设置期间缓存时，性能下降了约2倍。以下是测试中使用的命令：
- en: '[PRE51]'
  id: totrans-1420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '|  |'
  id: totrans-1421
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: With our quick overview out of the way, we’re now ready to get into some of
    the techniques you’ll use when working with the file system.
  id: totrans-1422
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成快速概述之后，我们现在可以开始了解一些你在与文件系统工作时将使用的技巧。
- en: Technique 39 Loading configuration files
  id: totrans-1423
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 技巧39 加载配置文件
- en: Keeping configuration in a separate file can be handy, especially for applications
    that run in multiple environments (like development, staging, and production).
    In this technique, you’ll learn the ins and outs of how to load configuration
    files.
  id: totrans-1424
  prefs: []
  type: TYPE_NORMAL
  zh: 将配置保存在单独的文件中可能很有用，特别是对于在多个环境中运行的应用程序（如开发、测试和生产）。在这个技巧中，你将了解如何加载配置文件的来龙去脉。
- en: Problem
  id: totrans-1425
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: Your application stores configuration in a separate file and it depends on having
    that configuration when it starts up.
  id: totrans-1426
  prefs: []
  type: TYPE_NORMAL
  zh: 你的应用程序将配置存储在单独的文件中，并且它依赖于在启动时拥有该配置。
- en: Solution
  id: totrans-1427
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use a synchronous file system method to pull in the configuration on initial
    setup of your application.
  id: totrans-1428
  prefs: []
  type: TYPE_NORMAL
  zh: 使用同步文件系统方法在应用程序的初始设置中拉取配置。
- en: Discussion
  id: totrans-1429
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论
- en: 'A common use of synchronous APIs is for loading configuration or other data
    used in the application on startup. Let’s say we have a simple configuration file
    stored as JSON that looks like the following:'
  id: totrans-1430
  prefs: []
  type: TYPE_NORMAL
  zh: 同步API的一个常见用途是在应用程序启动时加载配置或其他数据。假设我们有一个简单的配置文件，以JSON格式存储，如下所示：
- en: '[PRE52]'
  id: totrans-1431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Let’s first look at how we could do this asynchronously so you can see the
    difference. For example, say `doThisThing` depends on information from our configuration
    file. Asynchronously we could write it this way:'
  id: totrans-1432
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先看看我们如何以异步方式完成这个任务，这样你就可以看到差异。例如，假设`doThisThing`依赖于配置文件中的信息。异步地，我们可以这样写：
- en: '![](119fig01_alt.jpg)'
  id: totrans-1433
  prefs: []
  type: TYPE_IMG
  zh: '![](119fig01_alt.jpg)'
- en: 'This will work and may be desirable for some setups, but will also have the
    effect of having everything that depends on the configuration nested in one level.
    This can get ugly. By using a synchronous version, we can handle things more succinctly:'
  id: totrans-1434
  prefs: []
  type: TYPE_NORMAL
  zh: 这将有效，对于某些设置可能是可取的，但也会导致所有依赖于配置的内容都嵌套在同一个级别。这可能会变得很丑陋。通过使用同步版本，我们可以更简洁地处理事情：
- en: '![](119fig02_alt.jpg)'
  id: totrans-1435
  prefs: []
  type: TYPE_IMG
  zh: '![](119fig02_alt.jpg)'
- en: 'One of the characteristics of using `Sync` methods is that whenever an error
    occurs, it will be thrown:'
  id: totrans-1436
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Sync` 方法的一个特点是，每当发生错误时，它都会被抛出：
- en: '![](119fig03.jpg)'
  id: totrans-1437
  prefs: []
  type: TYPE_IMG
  zh: '![](119fig03.jpg)'
- en: '|  |'
  id: totrans-1438
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**A note about require**'
  id: totrans-1439
  prefs: []
  type: TYPE_NORMAL
  zh: '**关于 require 的注意事项**'
- en: 'We can `require` JSON files as modules in Node, so our code could even be shortened
    further:'
  id: totrans-1440
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 Node 中将 JSON 文件作为模块 `require`，因此我们的代码甚至可以进一步缩短：
- en: '[PRE53]'
  id: totrans-1441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: But there’s one caveat with this approach. Modules are cached globally in Node,
    so if we have another file that also requires `config.json` and we modify it,
    it’s modified everywhere that module is used in our application. Therefore, using
    `readFileSync` is recommended when you want to tamper with the objects. If you
    choose to use `require` instead, treat the object as frozen (read-only); otherwise
    you can end up with hard-to-track bugs. You can explicitly freeze an object by
    using `Object.freeze`.
  id: totrans-1442
  prefs: []
  type: TYPE_NORMAL
  zh: 但这种方法有一个注意事项。模块在 Node 中全局缓存，所以如果我们还有另一个文件也 `require` `config.json` 并对其进行修改，那么在应用程序中使用该模块的所有地方都会进行修改。因此，当你想要修改对象时，建议使用
    `readFileSync`。如果你选择使用 `require`，则将对象视为冻结（只读）；否则，你可能会遇到难以追踪的bug。你可以通过使用 `Object.freeze`
    显式地冻结一个对象。
- en: '|  |'
  id: totrans-1443
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'This is different from asynchronous methods, which use an error argument as
    the first parameter of the callback:'
  id: totrans-1444
  prefs: []
  type: TYPE_NORMAL
  zh: 这与异步方法不同，异步方法使用错误参数作为回调的第一个参数：
- en: '![](120fig01_alt.jpg)'
  id: totrans-1445
  prefs: []
  type: TYPE_IMG
  zh: '![](120fig01_alt.jpg)'
- en: In our example of loading a configuration file, we prefer to crash the application
    since it can’t function without that file, but sometimes you may want to handle
    synchronous errors.
  id: totrans-1446
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们加载配置文件的示例中，我们更喜欢使应用程序崩溃，因为它没有那个文件就无法运行，但有时你可能想要处理同步错误。
- en: Technique 40 Using file descriptors
  id: totrans-1447
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 技巧40：使用文件描述符
- en: Working with file descriptors can be confusing at first if you haven’t dealt
    with them. This technique serves as an introduction and shows some examples of
    how you use them in Node.
  id: totrans-1448
  prefs: []
  type: TYPE_NORMAL
  zh: 与文件描述符一起工作可能一开始会让人感到困惑，如果你没有处理过它们。这项技术作为介绍，展示了如何在 Node 中使用它们的几个示例。
- en: Problem
  id: totrans-1449
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: You want to access a file descriptor to do writes or reads.
  id: totrans-1450
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要访问文件描述符来进行写入或读取。
- en: Solution
  id: totrans-1451
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use Node’s `fs` file descriptor methods.
  id: totrans-1452
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Node 的 `fs` 文件描述符方法。
- en: Discussion
  id: totrans-1453
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论
- en: '*File descriptors (FDs)* are integers (indexes) associated with open files
    within a process managed by the operating system. As a process opens files, the
    operating system keeps track of these open files by assigning each a unique integer
    that it can then use to look up more information about the file.'
  id: totrans-1454
  prefs: []
  type: TYPE_NORMAL
  zh: '*文件描述符（FD）*是与操作系统管理的进程中的打开文件相关联的整数（索引）。当进程打开文件时，操作系统通过为每个文件分配一个唯一的整数来跟踪这些打开的文件，然后它可以使用这个整数来查找有关文件更多的信息。'
- en: Although it has *file* in the name, it covers more than just regular files.
    File descriptors can point to directories, pipes, network sockets, and regular
    files, to name a few. Node can get at these low-level bits. Most processes have
    a standard set of file descriptors, as shown in [table 6.2](#ch06table02).
  id: totrans-1455
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然名字中带有 *文件*，但它涵盖的不仅仅是常规文件。文件描述符可以指向目录、管道、网络套接字和常规文件，仅举几例。Node 可以访问这些低级位。大多数进程都有一个标准的文件描述符集合，如[表6.2](#ch06table02)所示。
- en: Table 6.2\. Common file descriptors
  id: totrans-1456
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表6.2\. 常见文件描述符
- en: '| Stream | File descriptor | Description |'
  id: totrans-1457
  prefs: []
  type: TYPE_TB
  zh: '| 流 | 文件描述符 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-1458
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| stdin | 0 | Standard input |'
  id: totrans-1459
  prefs: []
  type: TYPE_TB
  zh: '| stdin | 0 | 标准输入 |'
- en: '| stdout | 1 | Standard output |'
  id: totrans-1460
  prefs: []
  type: TYPE_TB
  zh: '| stdout | 1 | 标准输出 |'
- en: '| stderr | 2 | Standard error |'
  id: totrans-1461
  prefs: []
  type: TYPE_TB
  zh: '| stderr | 2 | 标准错误 |'
- en: 'In Node, we typically are used to the `console.log` sugar when we want to write
    to stdout:'
  id: totrans-1462
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Node 中，当我们想要写入 stdout 时，通常习惯使用 `console.log` 语法：
- en: '[PRE54]'
  id: totrans-1463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'If we use the stream objects available on the `process` global, we can accomplish
    the same thing more explicitly:'
  id: totrans-1464
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用 `process` 全局上可用的流对象，我们可以更明确地完成相同的事情：
- en: '[PRE55]'
  id: totrans-1465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'But there’s another, far less used way to write to stdout using the `fs` module.
    The `fs` module contains a number of methods that take an FD as its first argument.
    We can write to file descriptor 1 (or stdout) using `fs.writeSync`:'
  id: totrans-1466
  prefs: []
  type: TYPE_NORMAL
  zh: 但还有另一种，远未广泛使用的方法，使用 `fs` 模块将内容写入 stdout。`fs` 模块包含一些方法，它们将 FD 作为第一个参数。我们可以使用
    `fs.writeSync` 将内容写入文件描述符 1（或 stdout）：
- en: '[PRE56]'
  id: totrans-1467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '|  |'
  id: totrans-1468
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Synchronous logging
  id: totrans-1469
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 同步日志
- en: '`console.log` and `process.stdout.write` are actually synchronous methods under
    the hood, provided the TTY is a file stream'
  id: totrans-1470
  prefs: []
  type: TYPE_NORMAL
  zh: '`console.log` 和 `process.stdout.write` 实际上是在底层同步方法，前提是 TTY 是一个文件流'
- en: '|  |'
  id: totrans-1471
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'A file descriptor is returned from the `open` and `openSync` calls as a number:'
  id: totrans-1472
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `open` 和 `openSync` 调用返回一个文件描述符作为数字：
- en: '![](121fig01.jpg)'
  id: totrans-1473
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.1](121fig01.jpg)'
- en: There are a variety of methods that deal with file descriptors specified in
    the file system documentation.
  id: totrans-1474
  prefs: []
  type: TYPE_NORMAL
  zh: 文件系统文档中指定了处理文件描述符的多种方法。
- en: Typically more interesting uses of file descriptors happen when you’re inheriting
    from a parent process or spawning a child process where descriptors are shared
    or passed. We’ll discuss this more when we look at child processes in a later
    chapter.
  id: totrans-1475
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，文件描述符更有趣的使用发生在你从父进程继承或创建子进程，其中描述符是共享或传递的情况下。我们将在稍后的章节中讨论这个问题。
- en: Technique 41 Working with file locking
  id: totrans-1476
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 技巧 41 使用文件锁定
- en: File locking is helpful when cooperating processes need access to a common file
    where the integrity of the file is maintained and data isn’t lost. In this technique,
    we’ll explore how to write your own file locking module.
  id: totrans-1477
  prefs: []
  type: TYPE_NORMAL
  zh: 当协作进程需要访问一个保持文件完整性和数据不丢失的公共文件时，文件锁定非常有用。在这个技巧中，我们将探讨如何编写自己的文件锁定模块。
- en: Problem
  id: totrans-1478
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: You want to lock a file to prevent processes from tampering with it.
  id: totrans-1479
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要锁定一个文件以防止进程篡改它。
- en: Solution
  id: totrans-1480
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案
- en: Set up a file-locking mechanism using Node’s built-ins.
  id: totrans-1481
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Node 的内置功能设置文件锁定机制。
- en: Discussion
  id: totrans-1482
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论
- en: In a single-threaded Node process, file locking is typically something you won’t
    need to worry about. But you may have situations where other processes are accessing
    the same file, or a cluster of Node processes are accessing the same file.
  id: totrans-1483
  prefs: []
  type: TYPE_NORMAL
  zh: 在单线程的 Node 进程中，文件锁定通常是你可以不必担心的事情。但你可能会有其他进程访问相同文件的情况，或者一个 Node 进程集群访问相同文件的情况。
- en: In these cases, there’s the possibility that races and data loss may occur (more
    about this at [http://mng.bz/yTLV](http://mng.bz/yTLV)). Most operating systems
    provide mandatory locks (those enforced at a kernel level) and advisory locks
    (not enforced; these only work if processes involved subscribe to the same locking
    scheme). Advisory locks are generally preferred if possible, as mandatory locks
    are heavy handed and may be difficult to unlock ([https://kernel.org/doc/Documentation/filesystems/mandatory-locking.txt](https://kernel.org/doc/Documentation/filesystems/mandatory-locking.txt)).
  id: totrans-1484
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，可能会发生竞争条件和数据丢失（更多关于此内容请参阅 [http://mng.bz/yTLV](http://mng.bz/yTLV)）。大多数操作系统提供强制锁（在内核级别强制执行）和咨询锁（不强制执行；这些只有在涉及的过程订阅相同的锁定方案时才起作用）。如果可能的话，通常更倾向于使用咨询锁，因为强制锁过于强硬，可能难以解锁（[https://kernel.org/doc/Documentation/filesystems/mandatory-locking.txt](https://kernel.org/doc/Documentation/filesystems/mandatory-locking.txt)）。
- en: '|  |'
  id: totrans-1485
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: File Locking with Third-Party Modules
  id: totrans-1486
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用第三方模块进行文件锁定
- en: Node has no built-in support for locking a file directly (either mandatory or
    advisory). But advisory locking of files can be done using syscalls such as `flock`
    ([http://linux.die.net/man/2/flock](http://linux.die.net/man/2/flock)), which
    is available in a third-party module ([http://github.com/baudehlo/node-fs-ext](http://github.com/baudehlo/node-fs-ext)).
  id: totrans-1487
  prefs: []
  type: TYPE_NORMAL
  zh: Node 没有内置直接锁定文件的支持（无论是强制锁还是咨询锁）。但可以使用 `flock` 等系统调用（[http://linux.die.net/man/2/flock](http://linux.die.net/man/2/flock)）进行文件的咨询锁定，这些调用在第三方模块中可用（[http://github.com/baudehlo/node-fs-ext](http://github.com/baudehlo/node-fs-ext)）。
- en: '|  |'
  id: totrans-1488
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Instead of locking a file directly with something like `flock`, you can use
    a *lockfile*. Lockfiles are ordinary files or directories whose *existence* indicates
    some other resource is currently in use and not to be tampered with. The creation
    of a lockfile needs to be atomic (no races) to avoid collisions. Being advisory,
    all the participating processes would have to play by the same rules agreed on
    when the lockfile is present. This is illustrated in [figure 6.1](#ch06fig01).
  id: totrans-1489
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 *锁文件* 而不是直接使用 `flock` 等方法来锁定文件。锁文件是普通文件或目录，其 *存在* 表示其他资源当前正在使用，不应被篡改。创建锁文件需要是原子的（没有竞争条件）以避免冲突。由于是咨询性的，所有参与进程都必须遵守当锁文件存在时达成的相同规则。这如图
    6.1 所示。
- en: Figure 6.1\. Advisory locking using a lockfile between cooperating processes
  id: totrans-1490
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 6.1\. 使用锁文件在协作进程之间进行咨询锁定
- en: '![](06fig01_alt.jpg)'
  id: totrans-1491
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.1 替代](06fig01_alt.jpg)'
- en: Let’s say we had a file called config.json that could potentially be updated
    by any number of processes at any time. To avoid data loss or corruption, a `config.lock`
    file could be created by the process making the updates and removed when the process
    is finished. Each process would agree to check for the existence of the lockfile
    before making any updates.
  id: totrans-1492
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个名为 config.json 的文件，该文件可能随时被任何数量的进程更新。为了避免数据丢失或损坏，更新进程可以创建一个 `config.lock`
    文件，并在进程完成后将其删除。每个进程都会同意在更新之前检查锁文件的存在。
- en: 'Node provides a few ways to perform this out of the box. We’ll look at a couple
    of options:'
  id: totrans-1493
  prefs: []
  type: TYPE_NORMAL
  zh: Node 提供了一些开箱即用的方法来执行此操作。我们将探讨几个选项：
- en: Creating a lockfile using the exclusive flag
  id: totrans-1494
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用独占标志创建锁文件
- en: Creating a lockfile using `mkdir`
  id: totrans-1495
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `mkdir` 创建锁文件
- en: Let’s look at using the exclusive flag first.
  id: totrans-1496
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看如何使用独占标志。
- en: Creating lockfiles using the exclusive flag
  id: totrans-1497
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用独占标志创建锁文件
- en: 'The `fs` module provides an `x` flag for any methods that involve opening a
    file (like `fs.writeFile`, `fs.createWriteStream`, and `fs.open`). This flag tells
    the operating system the file should be opened in an exclusive mode (`O_EXCL`).
    When used, the file will fail to open if it already exists:'
  id: totrans-1498
  prefs: []
  type: TYPE_NORMAL
  zh: '`fs` 模块为涉及打开文件的所有方法（如 `fs.writeFile`、`fs.createWriteStream` 和 `fs.open`）提供了一个
    `x` 标志。此标志告诉操作系统文件应以独占模式（`O_EXCL`）打开。当使用时，如果文件已存在，则文件将无法打开：'
- en: '![](123fig01_alt.jpg)'
  id: totrans-1499
  prefs: []
  type: TYPE_IMG
  zh: '![图片1](123fig01_alt.jpg)'
- en: '|  |'
  id: totrans-1500
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Flag combinations when opening files
  id: totrans-1501
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 打开文件时的标志组合
- en: 'There are a variety of flag combinations you can pass when opening files; for
    a list of all of them consult the `fs.open` documentation: [http://nodejs.org/api/fs.html#fs_fs_open_path_flags_mode_callback](http://nodejs.org/api/fs.html#fs_fs_open_path_flags_mode_callback).'
  id: totrans-1502
  prefs: []
  type: TYPE_NORMAL
  zh: 在打开文件时，你可以传递各种标志组合；要查看所有标志的列表，请参阅 `fs.open` 文档：[http://nodejs.org/api/fs.html#fs_fs_open_path_flags_mode_callback](http://nodejs.org/api/fs.html#fs_fs_open_path_flags_mode_callback)。
- en: '|  |'
  id: totrans-1503
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'We want to fail if another process has already created a lockfile. We fail
    because we don’t want to tamper with the resource behind the lockfile while another
    process is using it. Thus, having the exclusive flag mechanism turns out to be
    useful in our case. But instead of writing an empty file, it’s a good idea to
    throw the PID (process ID) inside of this file so if something bad happens, we’ll
    know what process had the lock last:'
  id: totrans-1504
  prefs: []
  type: TYPE_NORMAL
  zh: 如果另一个进程已经创建了锁文件，我们希望失败。我们失败是因为我们不希望在另一个进程使用资源时篡改锁文件背后的资源。因此，在我们的情况下，拥有独占标志机制变得非常有用。但与其写入一个空文件，不如将
    PID（进程 ID）放入此文件中，这样如果发生任何坏事，我们将知道哪个进程最后拥有锁：
- en: '![](123fig02_alt.jpg)'
  id: totrans-1505
  prefs: []
  type: TYPE_IMG
  zh: '![图片2](123fig02_alt.jpg)'
- en: Creating lockfiles with mkdir
  id: totrans-1506
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用 mkdir 创建锁文件
- en: 'Exclusive mode may not work well if the lockfile exists on a network drive,
    since some systems don’t honor the `O_EXCL` flag on network drives. To circumvent
    this, another strategy is creating a lockfile as a directory. `mkdir` is an atomic
    operation (no races), has excellent cross-platform support, and works well with
    network drives. `mkdir` will fail if a directory exists. In this case, the PID
    could be stored as a file inside of that directory:'
  id: totrans-1507
  prefs: []
  type: TYPE_NORMAL
  zh: 如果锁文件位于网络驱动器上，独占模式可能工作得不好，因为某些系统不尊重网络驱动器上的 `O_EXCL` 标志。为了解决这个问题，另一种策略是将锁文件创建为一个目录。`mkdir`
    是一个原子操作（无竞争），具有出色的跨平台支持，并且与网络驱动器配合良好。如果存在目录，`mkdir` 将失败。在这种情况下，PID 可以存储在该目录内的一个文件中：
- en: '![](123fig03_alt.jpg)'
  id: totrans-1508
  prefs: []
  type: TYPE_IMG
  zh: '![图片3](123fig03_alt.jpg)'
- en: Making a lockfile module
  id: totrans-1509
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 创建一个锁文件模块
- en: 'So far we’ve discussed a couple ways to create lockfiles. We also need a mechanism
    to remove them when we’re done. In addition, to be good lockfile citizens, we
    should remove any lockfiles created whenever our process exits. A lot of this
    functionality can be wrapped up in a simple module:'
  id: totrans-1510
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了几种创建锁文件的方法。我们还需要一个机制在我们完成时删除它们。此外，为了成为良好的锁文件公民，我们应该在进程退出时删除任何创建的锁文件。许多功能都可以封装在一个简单的模块中：
- en: '![](124fig01_alt.jpg)'
  id: totrans-1511
  prefs: []
  type: TYPE_IMG
  zh: '![图片1](124fig01_alt.jpg)'
- en: 'Here’s an example usage:'
  id: totrans-1512
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个示例用法：
- en: '![](124fig02_alt.jpg)'
  id: totrans-1513
  prefs: []
  type: TYPE_IMG
  zh: '![图片2](124fig02_alt.jpg)'
- en: For a more full-featured implementation using exclusive mode, check out the
    lockfile third-party module ([https://github.com/isaacs/lockfile](https://github.com/isaacs/lockfile)).
  id: totrans-1514
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看使用独占模式更完整功能的实现，请查看锁文件第三方模块（[https://github.com/isaacs/lockfile](https://github.com/isaacs/lockfile)）。
- en: Technique 42 Recursive file operations
  id: totrans-1515
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 技巧 42 递归文件操作
- en: Ever need to remove a directory and all subdirectories (akin to `rm -rf`)? Create
    a directory and any intermediate directories given a path? Search a directory
    tree for a particular file? Recursive file operations are helpful and hard to
    get right, especially when done asynchronously. But understanding how to perform
    them is a good exercise in mastering evented programming with Node. In this technique,
    we’ll dive into recursive file operations by creating a module for searching a
    directory tree.
  id: totrans-1516
  prefs: []
  type: TYPE_NORMAL
  zh: 是否曾经需要删除目录及其所有子目录（类似于`rm -rf`）？给定一个路径创建目录和任何中间目录？在目录树中搜索特定文件？递归文件操作很有用，但很难做对，尤其是在异步操作中。但了解如何执行它们是掌握Node事件编程的良好练习。在这个技术中，我们将通过创建一个用于搜索目录树的模块来深入了解递归文件操作。
- en: Problem
  id: totrans-1517
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: You want to search for a file within a directory tree.
  id: totrans-1518
  prefs: []
  type: TYPE_NORMAL
  zh: 你想在目录树中搜索一个文件。
- en: Solution
  id: totrans-1519
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use recursion and combine file system primitives.
  id: totrans-1520
  prefs: []
  type: TYPE_NORMAL
  zh: 使用递归并结合文件系统原语。
- en: Discussion
  id: totrans-1521
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Discussion
- en: 'When a task spans multiple directories, things become more interesting, especially
    in an asynchronous world. You can mimic the command-line functionality of `mkdir`
    with a single call to `fs.mkdir`, but for fancier things like `mkdir -p` (helpful
    for creating intermediate directories), you have to think recursively. This means
    the solution to our problem will depend on “solutions to smaller instances of
    the same problem” (“Recursion (computer science)”: [http://en.wikipedia.org/wiki/Recursion_(computer_science)](http://en.wikipedia.org/wiki/Recursion_(computer_science))).'
  id: totrans-1522
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个任务跨越多个目录时，事情变得更有趣，尤其是在异步的世界中。你可以通过一次调用`fs.mkdir`来模拟`mkdir`命令行的功能，但对于像`mkdir
    -p`（对于创建中间目录很有用）这样的更复杂的事情，你必须递归地思考。这意味着我们问题的解决方案将取决于“相同问题的较小实例的解决方案”（“递归（计算机科学）”：[http://en.wikipedia.org/wiki/Recursion_(computer_science)](http://en.wikipedia.org/wiki/Recursion_(computer_science)))。
- en: In our example we’ll write a finder module. Our finder module will recursively
    look for matching files at a given start path (akin to `find/start/path -name='file-in-question'`)
    and provide the paths to those files in an array.
  id: totrans-1523
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，我们将编写一个查找模块。我们的查找模块将递归地在给定的起始路径中查找匹配的文件（类似于`find/start/path -name='file-in-question'`），并以数组的形式提供这些文件的路径。
- en: 'Let’s say we had the following directory tree:'
  id: totrans-1524
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个以下的目录树：
- en: '![](125fig01.jpg)'
  id: totrans-1525
  prefs: []
  type: TYPE_IMG
  zh: '![](125fig01.jpg)'
- en: 'A search for the pattern `/file.*/` from the root would give us the following:'
  id: totrans-1526
  prefs: []
  type: TYPE_NORMAL
  zh: 从根目录搜索模式`/file.*`将给我们以下结果：
- en: '[PRE57]'
  id: totrans-1527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'So how do we build this? To start, the `fs` module gives us some primitives
    we’ll need:'
  id: totrans-1528
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们该如何构建它呢？首先，`fs`模块为我们提供了一些我们需要的基本操作：
- en: '**`fs.readdir/fs.readdirSync`** —List all the files (including directories),
    given a path.'
  id: totrans-1529
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`fs.readdir/fs.readdirSync`** —给定一个路径，列出所有文件（包括目录）。'
- en: '**`fs.stat/fs.statSync`** —Give us information about a file at the specified
    path, including whether the path is a directory.'
  id: totrans-1530
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`fs.stat/fs.statSync`** —提供有关指定路径上文件的信息，包括该路径是否是目录。'
- en: 'Our module will expose synchronous (`findSync`) and asynchronous (`find`) implementations.
    `findSync` will block execution like other `Sync` methods, will be slightly faster
    than its asynchronous counterpart, and may fail on excessively large directory
    trees (since JavaScript doesn’t have proper tail calls yet: [https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tail-position-calls](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tail-position-calls)).'
  id: totrans-1531
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将公开同步（`findSync`）和异步（`find`）实现。`findSync`将像其他`Sync`方法一样阻塞执行，比其异步对应物稍快，但可能在非常大的目录树上失败（因为JavaScript还没有适当的尾调用：[https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tail-position-calls](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tail-position-calls))。
- en: '|  |'
  id: totrans-1532
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Why are synchronous functions slightly faster?**'
  id: totrans-1533
  prefs: []
  type: TYPE_NORMAL
  zh: '**为什么同步函数稍微快一些？**'
- en: Synchronous functions aren’t deferred until later, even though the asynchronous
    counterparts happen very quickly. Synchronous functions happen right away while
    you’re already on the CPU and you’re guaranteed to wait only exactly as long as
    necessary for the I/O to complete. But synchronous functions will block other
    things from happening during the wait period.
  id: totrans-1534
  prefs: []
  type: TYPE_NORMAL
  zh: 同步函数不会延迟到以后，即使异步对应物发生得非常快。同步函数立即发生，当你已经在CPU上时，你保证只等待必要的I/O完成所需的时间。但同步函数将在等待期间阻止其他事情发生。
- en: '|  |'
  id: totrans-1535
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: On the other hand, `find` will be slightly slower, but won’t fail on large trees
    (since the stack is regularly cleared due to the calls being asynchronous). `find`
    won’t block execution.
  id: totrans-1536
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`find`可能会稍微慢一些，但不会在大型树中失败（因为由于调用是异步的，栈会定期清除）。`find`不会阻塞执行。
- en: 'Let’s take a look at the code for `findSync` first:'
  id: totrans-1537
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看`findSync`的代码：
- en: '![](126fig01_alt.jpg)'
  id: totrans-1538
  prefs: []
  type: TYPE_IMG
  zh: '![图片描述](126fig01_alt.jpg)'
- en: 'Since everything is synchronous, we can use `return` at the end to get all
    our results, as it’ll never reach there until all the recursion has finished.
    The first error to occur would throw and could be caught, if desired, in a try/catch
    block. Let’s look at a sample usage:'
  id: totrans-1539
  prefs: []
  type: TYPE_NORMAL
  zh: 由于一切都是同步的，我们可以在最后使用`return`来获取所有结果，因为它永远不会到达那里，直到所有递归都完成。第一个发生的错误会抛出，如果需要，可以在try/catch块中捕获。让我们看看一个示例用法：
- en: '![](127fig01_alt.jpg)'
  id: totrans-1540
  prefs: []
  type: TYPE_IMG
  zh: '![图片描述](127fig01_alt.jpg)'
- en: 'Let’s switch now and take a look at how to tackle this problem asynchronously
    with the `find` implementation:'
  id: totrans-1541
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们切换一下，看看如何使用`find`实现异步处理这个问题：
- en: '![](127fig02_alt.jpg)'
  id: totrans-1542
  prefs: []
  type: TYPE_IMG
  zh: '![图片描述](127fig02_alt.jpg)'
- en: We can’t just `return` our results, like in the synchronous version; we need
    to call back with them when we know we’re finished. To know that we’re finished,
    we use a counter (`asyncOps`). We also have to be aware whenever we have callbacks
    to ensure we have a closure around any variables we expect to have around when
    any asynchronous call completes (this is why we switched from a standard `for`
    loop to a `forEach` call—more about this at [http://mng.bz/rqEA](http://mng.bz/rqEA)).
  id: totrans-1543
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能像同步版本那样直接`return`我们的结果；当我们知道我们已经完成时，我们需要用它们调用回调。为了知道我们已经完成，我们使用一个计数器（`asyncOps`）。我们还必须意识到，每当有回调时，确保我们有一个闭包在异步调用完成后我们期望的任何变量周围（这就是为什么我们从标准的`for`循环切换到`forEach`调用——更多关于这一点在[http://mng.bz/rqEA](http://mng.bz/rqEA)）。
- en: Our counter (`asyncOps`) increments right before we do an asynchronous operation
    (like `fs.readdir` or `fs.stat`). The counter decrements in the callback for the
    asynchronous operation. Specifically it decrements *after* any other asynchronous
    calls have been made (otherwise we’ll get back to `0` too soon). In a successful
    scenario, `asyncOps` will reach `0` when all the recursive asynchronous work has
    completed, and we can call back with the results (`if (asyncOps == 0) cb(null,
    results)`). In a failure scenario, `asyncOps` will never reach `0`, and one of
    the error handlers would’ve been triggered and have already called back with the
    error.
  id: totrans-1544
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的计数器（`asyncOps`）在我们执行异步操作（如`fs.readdir`或`fs.stat`）之前增加。在异步操作的回调中计数器会递减。具体来说，它会在任何其他异步调用之后递减（否则我们会过早地回到`0`）。在成功的情况下，当所有递归异步工作完成后，`asyncOps`会达到`0`，我们可以调用回调并返回结果（`if
    (asyncOps == 0) cb(null, results)`）。在失败的情况下，`asyncOps`永远不会达到`0`，并且其中一个错误处理程序已经被触发，并且已经调用回调返回了错误。
- en: Also, in our example, we can’t be sure that `fs.stat` will be the last thing
    to be called, since we may have a directory with no files in our chain, so we
    check at both spots. We also have a simple `error` wrapper to ensure we never
    call back with more than one error. If your asynchronous operation returns one
    value like in our example or one error, it’s important to ensure you’ll never
    call the callback more than once, as it leads to hard-to-track bugs later down
    the road.
  id: totrans-1545
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在我们的例子中，我们不能确定`fs.stat`将是最后一个被调用的，因为我们可能有一个没有文件的目录链，所以我们在这两个地方进行检查。我们还有一个简单的`error`包装器，以确保我们永远不会调用回调超过一次，因为这将导致以后难以追踪的错误。如果您的异步操作返回一个值，如我们的示例或一个错误，确保您永远不会调用回调超过一次非常重要，因为这会导致以后难以追踪的错误。
- en: '|  |'
  id: totrans-1546
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Alternatives to counters
  id: totrans-1547
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 计数器的替代方案
- en: The counter isn’t the only mechanism that can track the completion of a set
    of asynchronous operations. Depending on the requirements of the application,
    recursively passing the original callback could work. For an example look at the
    third-party `mkdirp` module ([https://github.com/substack/node-mkdirp](https://github.com/substack/node-mkdirp)).
  id: totrans-1548
  prefs: []
  type: TYPE_NORMAL
  zh: 计数器并不是唯一可以跟踪一组异步操作完成的机制。根据应用程序的要求，递归传递原始回调可能有效。例如，可以查看第三方`mkdirp`模块（[https://github.com/substack/node-mkdirp](https://github.com/substack/node-mkdirp)）。
- en: '|  |'
  id: totrans-1549
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Now we have an asynchronous version (`find`) and can handle the result of that
    operation with the standard Node-style callback signature:'
  id: totrans-1550
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了异步版本（`find`），可以使用标准的Node风格回调签名来处理该操作的返回结果：
- en: '[PRE58]'
  id: totrans-1551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '|  |'
  id: totrans-1552
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Third-party solutions to parallel operations
  id: totrans-1553
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 并行操作的第三方解决方案
- en: Parallel operations can be hard to keep track of, and can easily become bug-prone,
    so you may want to use a third-party library like `async` ([https://github.com/caolan/async](https://github.com/caolan/async))
    to help. Another alternative is using a promises library like `Q` ([https://github.com/kriskowal/q](https://github.com/kriskowal/q)).
  id: totrans-1554
  prefs: []
  type: TYPE_NORMAL
  zh: 并行操作可能难以跟踪，并且容易成为bug的源头，因此你可能想使用像`async`（[https://github.com/caolan/async](https://github.com/caolan/async)）这样的第三方库来帮助。另一个选择是使用像`Q`（[https://github.com/kriskowal/q](https://github.com/kriskowal/q)）这样的promises库。
- en: '|  |'
  id: totrans-1555
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Technique 43 Writing a file database
  id: totrans-1556
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 技巧43：编写文件数据库
- en: Node’s core `fs` module gives you the tools to build complexity like the recursive
    operations you saw in the last technique. It also enables you to do other complex
    tasks such as creating a file database. In this technique we’ll write a file database
    in order to look at other pieces in the `fs` module, including streaming, working
    together.
  id: totrans-1557
  prefs: []
  type: TYPE_NORMAL
  zh: Node的核心`fs`模块为你提供了构建复杂性的工具，就像你在上一个技术中看到的递归操作。它还使你能够执行其他复杂任务，例如创建文件数据库。在这个技术中，我们将编写一个文件数据库，以便查看`fs`模块中的其他部分，包括流式传输和协作。
- en: Problem
  id: totrans-1558
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: You want a simple and fast data storage structure with some consistency guarantees.
  id: totrans-1559
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要一个简单且快速的数据存储结构，并具有一些一致性保证。
- en: Solution
  id: totrans-1560
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use an in-memory database with append-only journaling.
  id: totrans-1561
  prefs: []
  type: TYPE_NORMAL
  zh: 使用内存数据库和只追加日志记录。
- en: Discussion
  id: totrans-1562
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论
- en: 'We’ll write a simple key/value database module. The database will provide in-memory
    access to the current state for speed and use an append-only storage format on
    disk for persistence. Using append-only storage will provide us the following:'
  id: totrans-1563
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写一个简单的键/值数据库模块。数据库将为当前状态提供内存访问以实现速度，并在磁盘上使用只追加存储格式以实现持久性。使用只追加存储将为我们提供以下：
- en: '***Efficient disk I/O performance*** —We’re always writing to the end of the
    file.'
  id: totrans-1564
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***高效的磁盘I/O性能*** — 我们始终写入文件的末尾。'
- en: '***Durability*** —The previous state of the file is never changed in any way.'
  id: totrans-1565
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***耐用性*** — 文件的前一个状态永远不会以任何方式改变。'
- en: '***A simple way to create backups*** —We can just copy the file at any point
    to get the state of the database at that point.'
  id: totrans-1566
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***简单创建备份的方法*** — 我们可以在任何时刻复制文件以获取数据库在该点的状态。'
- en: 'Each line in the file is a record. The record is simply a JSON object with
    two properties, a `key` and a `value`. A `key` is a string representing a lookup
    for the `value`. The `value` can be anything JSON-serializable, which includes
    strings and numbers. Let’s look at some sample records:'
  id: totrans-1567
  prefs: []
  type: TYPE_NORMAL
  zh: 文件中的每一行都是一个记录。记录只是一个具有两个属性（`key`和`value`）的JSON对象。`key`是一个表示对`value`查找的字符串。`value`可以是任何可序列化为JSON的内容，包括字符串和数字。让我们看看一些示例记录：
- en: '[PRE59]'
  id: totrans-1568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'If a record is updated, a new version of the record will be found later in
    the file with the same key:'
  id: totrans-1569
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一条记录被更新，文件中稍后也会找到具有相同键的新版本记录：
- en: '[PRE60]'
  id: totrans-1570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'If a record has been removed, it’ll also be found later in the file with a
    `null` value:'
  id: totrans-1571
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一条记录已被删除，它稍后也会在文件中找到，值为`null`：
- en: '[PRE61]'
  id: totrans-1572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'When the database is loaded, the journal will be streamed in from top to bottom,
    building the current state of the database in memory. Remember, data isn’t deleted,
    so it’s possible to store the following data:'
  id: totrans-1573
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据库被加载时，日志将从顶部到底部流式传输，在内存中构建数据库的当前状态。记住，数据不会被删除，因此可以存储以下数据：
- en: '[PRE62]'
  id: totrans-1574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: In this case, at some point we saved `"my first value"` as the key `c`. Later
    on we deleted the key. Then, most recently, we set the key to be `{"my":"object"}`.
    The most recent entry will be loaded in memory, as it represents the current state
    of the database.
  id: totrans-1575
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，在某个时刻我们将`"my first value"`作为键`c`保存。后来我们删除了这个键。然后，最近，我们将键设置为`{"my":"object"}`。最近的条目将被加载到内存中，因为它代表了数据库的当前状态。
- en: 'We talked about how data will be persisted to the file system. Let’s talk about
    the API we’ll expose next:'
  id: totrans-1576
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了数据如何持久化到文件系统。接下来让我们谈谈我们将公开的API：
- en: '![](130fig01_alt.jpg)'
  id: totrans-1577
  prefs: []
  type: TYPE_IMG
  zh: '![图片](130fig01_alt.jpg)'
- en: 'Let’s dive into the code to start putting this together. We’ll write a `Database`
    module to store our logic. It’ll inherit from `EventEmitter` so we can emit events
    back to the consumer (like when the database has loaded all its data and we can
    start using it):'
  id: totrans-1578
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入代码，开始构建这个模块。我们将编写一个`Database`模块来存储我们的逻辑。它将继承自`EventEmitter`，这样我们就可以向消费者发出事件（例如，当数据库加载了所有数据并且我们可以开始使用它时）：
- en: '![](130fig02_alt.jpg)'
  id: totrans-1579
  prefs: []
  type: TYPE_IMG
  zh: '![图片](130fig02_alt.jpg)'
- en: 'We want to stream the data stored and emit a “load” event when that’s completed.
    Streaming will enable us to handle data as it’s being read in. Streaming also
    is asynchronous, allowing the host application to do other things while the data
    is being loaded:'
  id: totrans-1580
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想流式传输存储的数据，并在完成时发出“load”事件。流式传输将使我们能够处理正在读取的数据。流式传输也是异步的，允许宿主应用程序在数据加载时执行其他操作：
- en: '![](130fig03_alt.jpg)'
  id: totrans-1581
  prefs: []
  type: TYPE_IMG
  zh: '![](130fig03_alt.jpg)'
- en: As we read in data from the file, we find all the complete records that exist.
  id: totrans-1582
  prefs: []
  type: TYPE_NORMAL
  zh: 在从文件中读取数据时，我们发现所有存在的完整记录。
- en: '|  |'
  id: totrans-1583
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Structuring our writes to structure our reads
  id: totrans-1584
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 将我们的写入结构化以结构化我们的读取
- en: What do we do with the data we just `pop()`ed the last time a `readable` event
    is triggered? The last record turns out to always be an empty string (`''`) because
    we end each line with a newline (`\n`) character.
  id: totrans-1585
  prefs: []
  type: TYPE_NORMAL
  zh: 当触发`readable`事件时，我们刚刚`pop()`的数据是什么？最后一个记录发现总是空字符串(`''`)，因为我们每行都以换行符(`\n`)结束。
- en: '|  |'
  id: totrans-1586
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Once we’ve loaded the data and emitted the `load` event, a client can start
    interacting with the data. Let’s look at those methods next, starting with the
    simplest—the `get` method:'
  id: totrans-1587
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们加载了数据并发出`load`事件，客户端就可以开始与数据交互。让我们看看那些方法，从最简单的`get`方法开始：
- en: '![](131fig01_alt.jpg)'
  id: totrans-1588
  prefs: []
  type: TYPE_IMG
  zh: '![](131fig01_alt.jpg)'
- en: 'Let’s look at storing updates next:'
  id: totrans-1589
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何存储更新：
- en: '![](131fig02_alt.jpg)'
  id: totrans-1590
  prefs: []
  type: TYPE_IMG
  zh: '![](131fig02_alt.jpg)'
- en: 'Now we add some sugar for deleting a key:'
  id: totrans-1591
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们为删除键添加一些糖：
- en: '![](131fig03_alt.jpg)'
  id: totrans-1592
  prefs: []
  type: TYPE_IMG
  zh: '![](131fig03_alt.jpg)'
- en: 'There we have a simple database module. Last thing: we need to export the constructor:'
  id: totrans-1593
  prefs: []
  type: TYPE_NORMAL
  zh: 那里有一个简单的数据库模块。最后一件事：我们需要导出构造函数：
- en: '[PRE63]'
  id: totrans-1594
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: There are various improvements that could be made on this module, like flushing
    writes ([http://mng.bz/2g19](http://mng.bz/2g19)) or retrying on failure. For
    examples of more full-featured Node-based database modules, check out `node-dirty`
    ([https://github.com/felixge/node-dirty](https://github.com/felixge/node-dirty))
    or `nstore` ([https://github.com/creationix/nstore](https://github.com/creationix/nstore)).
  id: totrans-1595
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在这个模块上做出各种改进，比如刷新写入([http://mng.bz/2g19](http://mng.bz/2g19))或在失败时重试。有关更完整的基于Node的数据库模块的示例，请查看`node-dirty`([https://github.com/felixge/node-dirty](https://github.com/felixge/node-dirty))或`nstore`([https://github.com/creationix/nstore](https://github.com/creationix/nstore))。
- en: Technique 44 Watching files and directories
  id: totrans-1596
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 技巧44 监视文件和目录
- en: Ever need to process a file when a client adds one to a directory (through FTP,
    for instance) or reload a web server after a file is modified? You can do both
    by watching for file changes.
  id: totrans-1597
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端通过FTP等将文件添加到目录中或修改文件后重新加载Web服务器时，是否需要处理文件？您可以通过监视文件更改来完成这两项操作。
- en: 'Node has *two* implementations for file watching. We’ll talk about both in
    this technique in order to understand when to use one or the other. But at the
    core, they enable the same thing: watching files (and directories).'
  id: totrans-1598
  prefs: []
  type: TYPE_NORMAL
  zh: Node为文件监视提供了两种实现。我们将在这项技术中讨论两者，以便了解何时使用其中一个或另一个。但核心是，它们实现了相同的功能：监视文件（和目录）。
- en: Problem
  id: totrans-1599
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: You want to watch a file or directory and perform an action when a change is
    made.
  id: totrans-1600
  prefs: []
  type: TYPE_NORMAL
  zh: 您想监视一个文件或目录，并在更改时执行操作。
- en: Solution
  id: totrans-1601
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use `fs.watch` and `fs.watchFile`.
  id: totrans-1602
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`fs.watch`和`fs.watchFile`。
- en: Discussion
  id: totrans-1603
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论
- en: It’s rare to see multiple implementations for the same purpose in Node core.
    Node’s documentation recommends that you prefer `fs.watch` over `fs.watchFile`
    if possible, as it’s considered more reliable. But `fs.watch` isn’t consistent
    across operating systems, whereas `fs.watchFile` is. Why the madness?
  id: totrans-1604
  prefs: []
  type: TYPE_NORMAL
  zh: 在Node核心中很少看到同一目的的多个实现。Node的文档建议，如果可能，您应首选`fs.watch`而不是`fs.watchFile`，因为它被认为更可靠。但`fs.watch`在操作系统之间并不一致，而`fs.watchFile`是一致的。为什么会有这种混乱？
- en: The story about fs.watch
  id: totrans-1605
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 关于fs.watch的故事
- en: Node’s event loop taps into the operating system in order to juggle asynchronous
    I/O in its single-threaded environment. This also provides a performance benefit,
    as the OS can let the process know immediately when some new piece of I/O is ready
    to be handled. Operating systems have different ways of notifying a process about
    events (that’s why we have `libuv`). The culmination of that work for file watching
    is the `fs.watch` method.
  id: totrans-1606
  prefs: []
  type: TYPE_NORMAL
  zh: Node的事件循环通过操作系统来处理其单线程环境中的异步I/O。这也提供了性能优势，因为操作系统可以立即通知进程某些新的I/O操作已准备好处理。操作系统有不同的方式来通知进程关于事件（这就是为什么我们有`libuv`）。文件监视工作的成果是`fs.watch`方法。
- en: '`fs.watch` combines all these different types of event systems into one method
    with a common API to provide the following:'
  id: totrans-1607
  prefs: []
  type: TYPE_NORMAL
  zh: '`fs.watch`将这些不同类型的事件系统结合成一个具有公共API的方法，以提供以下功能：'
- en: A more reliable implementation in terms of file change events always getting
    fired
  id: totrans-1608
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在文件更改事件始终被触发方面，这是一个更可靠的实现
- en: A faster implementation, as notifications get passed to Node immediately when
    they occur
  id: totrans-1609
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一种更快的实现方式，因为通知在发生时立即传递给Node
- en: Let’s look at the older method next.
  id: totrans-1610
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看下一个更老的方法。
- en: The story about fs.watchFile
  id: totrans-1611
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 关于 `fs.watchFile` 的故事
- en: There’s another, older implementation of file watching called `fs.watchFile`.
    It doesn’t tap into the notification system but instead polls on an interval to
    see if changes have occurred.
  id: totrans-1612
  prefs: []
  type: TYPE_NORMAL
  zh: 文件监视的另一种，更老的实施方式称为 `fs.watchFile`。它没有接入通知系统，而是通过间隔轮询来查看是否发生了变化。
- en: '`fs.watchFile` isn’t as full-fledged in the changes it can detect, nor as fast.
    But the advantage of using `fs.watchFile` is that it’s *consistent* across platforms
    and it works more reliably on network file systems (like SMB and NFS).'
  id: totrans-1613
  prefs: []
  type: TYPE_NORMAL
  zh: '`fs.watchFile` 在检测变化方面并不完整，也不够快。但使用 `fs.watchFile` 的优点是它在各个平台之间是一致的，并且在网络文件系统（如SMB和NFS）上工作得更可靠。'
- en: Which one is right for me?
  id: totrans-1614
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 哪个更适合我？
- en: The preferred is `fs.watch`, but since it’s inconsistent across platforms, it’s
    a good idea to test whether it does what you want (and better to have a test suite).
  id: totrans-1615
  prefs: []
  type: TYPE_NORMAL
  zh: 更推荐使用 `fs.watch`，但由于它在各个平台之间不一致，测试它是否按您期望的那样工作（并且最好有一个测试套件）是个好主意。
- en: 'Let’s write a program to help us play around file watching and see what each
    API provides. First, create a file called watcher.js with the following contents:'
  id: totrans-1616
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个程序来帮助我们玩转文件监视，并查看每个API提供了什么。首先，创建一个名为 watcher.js 的文件，内容如下：
- en: '[PRE64]'
  id: totrans-1617
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Now create a directory called `watchdir` in the same directory as your watcher.js
    file:'
  id: totrans-1618
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在您的 watcher.js 文件所在的目录中创建一个名为 `watchdir` 的目录：
- en: '[PRE65]'
  id: totrans-1619
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Then, open a couple terminals. In the first terminal, run
  id: totrans-1620
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，打开几个终端。在第一个终端中，运行
- en: '[PRE66]'
  id: totrans-1621
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'and in the second terminal, change to `watchdir`:'
  id: totrans-1622
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个终端中，切换到 `watchdir`：
- en: '[PRE67]'
  id: totrans-1623
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'With your two terminals open (preferably side by side), we’ll make changes
    in `watchdir` and see Node pick them up. Let’s create a new file:'
  id: totrans-1624
  prefs: []
  type: TYPE_NORMAL
  zh: 在您打开的两个终端（最好是并排打开）中，我们将在 `watchdir` 中进行更改，并查看Node是否能够检测到这些更改。让我们创建一个新的文件：
- en: '[PRE68]'
  id: totrans-1625
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'We can see the Node output:'
  id: totrans-1626
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到Node的输出：
- en: '![](133fig01_alt.jpg)'
  id: totrans-1627
  prefs: []
  type: TYPE_IMG
  zh: '![](133fig01_alt.jpg)'
- en: 'All right, so now we have a file created; let’s update its modification time
    with the same command:'
  id: totrans-1628
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，所以现在我们创建了一个文件；让我们用相同的命令更新它的修改时间：
- en: '[PRE69]'
  id: totrans-1629
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Now when we look at our Node output, we see that only `fs.watch` picked up
    this change:'
  id: totrans-1630
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们查看Node输出，我们看到只有 `fs.watch` 捕获了这个变化：
- en: '[PRE70]'
  id: totrans-1631
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: So if using `touch` to update a file when watching a directory is important
    to your application, `fs.watch` has support.
  id: totrans-1632
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果您在监视目录时使用 `touch` 更新文件对您的应用程序很重要，`fs.watch` 提供了支持。
- en: '|  |'
  id: totrans-1633
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: fs.watchFile and directories
  id: totrans-1634
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '`fs.watchFile` 和目录'
- en: Many updates to files while watching a directory won’t be picked up by `fs.watchFile`.
    If you want to get this behavior with `fs.watchFile`, watch the individual file.
  id: totrans-1635
  prefs: []
  type: TYPE_NORMAL
  zh: 在监视目录时，许多对文件的更新不会被 `fs.watchFile` 捕获。如果您想通过 `fs.watchFile` 获取这种行为，请监视单个文件。
- en: '|  |'
  id: totrans-1636
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Let’s try moving our file:'
  id: totrans-1637
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试移动我们的文件：
- en: '[PRE71]'
  id: totrans-1638
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'In our Node terminal, we see the following output indicating both APIs picked
    up the change:'
  id: totrans-1639
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的Node终端中，我们看到以下输出，表明两个API都检测到了变化：
- en: '![](134fig01.jpg)'
  id: totrans-1640
  prefs: []
  type: TYPE_IMG
  zh: '![](134fig01.jpg)'
- en: 'The main point here is to test the APIs using the exact use case you want to
    utilize. Hopefully, this API will get more stable in the future. Read the documentation
    to get the latest development ([http://nodejs.org/api/fs.html#fs_fs_watch_filename_options_listener](http://nodejs.org/api/fs.html#fs_fs_watch_filename_options_listener)).
    Here are some tips to help navigate:'
  id: totrans-1641
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的主要目的是使用您想要利用的确切用例来测试API。希望这个API在未来会变得更加稳定。阅读文档以获取最新的开发信息 ([http://nodejs.org/api/fs.html#fs_fs_watch_filename_options_listener](http://nodejs.org/api/fs.html#fs_fs_watch_filename_options_listener))。以下是一些帮助导航的提示：
- en: Run your test case, preferring `fs.watch`. Are events getting triggered as you
    expect them to be?
  id: totrans-1642
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行您的测试用例，优先使用 `fs.watch`。事件是否如您预期的那样被触发？
- en: If you intend to watch a single file, don’t watch the directory it’s in; you
    may end up with more events being triggered.
  id: totrans-1643
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您打算监视单个文件，不要监视它所在的目录；您可能会触发更多的事件。
- en: If comparing file stats is important between changes, `fs.watchFile` provides
    that out of the box. Otherwise, you’ll need to manage stats manually using `fs.watch`.
  id: totrans-1644
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在更改之间比较文件状态很重要，`fs.watchFile` 提供了即时的解决方案。否则，您需要使用 `fs.watch` 手动管理状态。
- en: Just because `fs.watch` works on your Mac doesn’t mean it will work exactly
    the same way on your Linux server. Ensure development and production environments
    are tested for the desired functionality.
  id: totrans-1645
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然`fs.watch`在Mac上工作，但这并不意味着它会在Linux服务器上以完全相同的方式工作。确保开发和生产环境都经过测试以实现所需的功能。
- en: Go forth and watch wisely!
  id: totrans-1646
  prefs: []
  type: TYPE_NORMAL
  zh: 去吧，明智地观察！
- en: 6.2\. Summary
  id: totrans-1647
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2. 摘要
- en: In this chapter we talked through a number of techniques using the `fs` module.
    We covered asynchronous and synchronous usage while looking at configuration file
    loading and recursive file handling. We also looked at file descriptors and file
    locking. Lastly we implemented a file database.
  id: totrans-1648
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了使用`fs`模块的多种技术。我们在查看配置文件加载和递归文件处理的同时，涵盖了异步和同步的使用。我们还探讨了文件描述符和文件锁定。最后，我们实现了一个文件数据库。
- en: 'Hopefully this has expanded your understanding of some of the concepts possible
    with using the `fs` module. Here are a few takeaways:'
  id: totrans-1649
  prefs: []
  type: TYPE_NORMAL
  zh: 希望这已经扩展了你使用`fs`模块的一些概念的理解。以下是一些要点：
- en: Synchronous methods can be a nicer, simpler way to do things over their asynchronous
    counterparts, but beware of the performance issues, especially if you’re writing
    a server.
  id: totrans-1650
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同步方法可能比它们的异步对应方法更优雅、更简单，但要注意性能问题，尤其是如果你正在编写服务器。
- en: Advisory file locking is a helpful mechanism for resources shared across multiple
    processes as long as all processes follow the same contract.
  id: totrans-1651
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建议性文件锁定是一种有助于跨多个进程共享资源的机制，只要所有进程都遵循相同的合同。
- en: Parallel asynchronous operations that require some sort of response after completion
    need to be tracked. Although it’s helpful to understand how to use counters or
    recursive techniques, consider using a well-tested third-party module like `async`.
  id: totrans-1652
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要在完成后获得某种响应的并行异步操作需要被跟踪。虽然了解如何使用计数器或递归技术是有帮助的，但考虑使用经过良好测试的第三方模块如`async`。
- en: Look at how you’ll use a particular file to determine which course of action
    to follow. If it’s a large file or can be dealt with in chunks, consider using
    a streaming approach. If it’s a smaller file or something you can’t use until
    you have the entire file loaded, consider a bulk method. If you want to change
    a particular part of a file, you probably want to stick with the POSIX file methods.
  id: totrans-1653
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据你将如何使用特定文件来确定采取哪种行动。如果它是一个大文件或可以分块处理，考虑使用流式方法。如果它是一个小文件或你需要等到整个文件加载完毕才能使用，考虑使用批量方法。如果你想更改文件的一个特定部分，你可能想坚持使用POSIX文件方法。
- en: 'In the next chapter we’ll look at the other main form of I/O in Node: networking.'
  id: totrans-1654
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨Node的另一种主要I/O形式：网络。
- en: 'Chapter 7\. Networking: Node’s true “Hello, World”'
  id: totrans-1655
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第7章：网络：Node的真正“Hello, World”
- en: '*This chapter covers*'
  id: totrans-1656
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Networking concepts and how they relate to Node
  id: totrans-1657
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络概念及其与Node的关系
- en: TCP, UDP, and HTTP clients and servers
  id: totrans-1658
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TCP、UDP和HTTP客户端和服务器
- en: DNS
  id: totrans-1659
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DNS
- en: Network encryption
  id: totrans-1660
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络加密
- en: The Node.js platform itself is billed as a solution for writing fast and scalable
    network applications. To write network-oriented software, you need to understand
    how networking technologies and protocols interrelate. Over the course of the
    next section, we explain how networks have been designed around technology stacks
    with clear boundaries; and furthermore, how Node implements these protocols and
    what their APIs look like.
  id: totrans-1661
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js平台本身被誉为编写快速和可扩展网络应用程序的解决方案。要编写面向网络的软件，你需要了解网络技术和协议是如何相互关联的。在下一节中，我们解释了网络是如何围绕具有清晰边界的科技堆栈设计的；此外，Node是如何实现这些协议以及它们的API看起来像什么。
- en: 'In this chapter you’ll learn about how Node’s networking modules work. This
    includes the `dgram`, `dns`, `http`, and `net` modules. If you’re unsure about
    network terminology like *socket*, *packet*, and *protocol*, then don’t worry:
    we also introduce key networking concepts to give you a solid foundation in network
    programming.'
  id: totrans-1662
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将了解Node的网络模块是如何工作的。这包括`dgram`、`dns`、`http`和`net`模块。如果你对网络术语如*套接字*、*数据包*和*协议*不确定，那么不用担心：我们还介绍了关键的网络安全概念，为你提供网络编程的坚实基础。
- en: 7.1\. Networking in Node
  id: totrans-1663
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1. 网络中的Node
- en: This section is an introduction to networking. You’ll learn about network layers,
    packets, sockets—all of the stuff that networks are made of. These ideas are critical
    to understanding Node’s networking APIs.
  id: totrans-1664
  prefs: []
  type: TYPE_NORMAL
  zh: 本节是关于网络介绍的。你将了解网络层、数据包、套接字——所有构成网络的东西。这些概念对于理解Node的网络API至关重要。
- en: 7.1.1\. Networking terminology
  id: totrans-1665
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.1.1. 网络术语
- en: Networking jargon can quickly become overwhelming. To get everyone on the same
    page, we’ve included [table 7.1](#ch07table01), which summarizes the main concepts
    that will form the basis of this chapter.
  id: totrans-1666
  prefs: []
  type: TYPE_NORMAL
  zh: 网络术语很快就会变得令人不知所措。为了让大家达成共识，我们包括了[表7.1](#ch07table01)，它总结了本章将形成基础的主要概念。
- en: Table 7.1\. Networking concepts
  id: totrans-1667
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表7.1\. 网络概念
- en: '| Term | Description |'
  id: totrans-1668
  prefs: []
  type: TYPE_TB
  zh: '| Term | Description |'
- en: '| --- | --- |'
  id: totrans-1669
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Layer | A slice of related networking protocols that represents a logical
    group. The application layer, where we work, is the highest level; physical is
    the lowest. |'
  id: totrans-1670
  prefs: []
  type: TYPE_TB
  zh: '| Layer | 代表一组相关网络协议的逻辑组。我们工作的应用层是最高层；物理层是最低层。 |'
- en: '| HTTP | Hypertext Transfer Protocol—An application-layer client-server protocol
    built on TCP. |'
  id: totrans-1671
  prefs: []
  type: TYPE_TB
  zh: '| HTTP | 超文本传输协议——建立在TCP之上的应用层客户端-服务器协议。 |'
- en: '| TCP | Transmission Control Protocol—Allows communication in both directions
    from the client to the server, and is built on to create application-layer protocols
    like HTTP. |'
  id: totrans-1672
  prefs: []
  type: TYPE_TB
  zh: '| TCP | 传输控制协议——允许客户端到服务器的双向通信，并在此基础上构建应用层协议，如HTTP。 |'
- en: '| UDP | User Datagram Protocol—A lightweight protocol, typically chosen where
    speed is desired over reliability. |'
  id: totrans-1673
  prefs: []
  type: TYPE_TB
  zh: '| UDP | 用户数据报协议——一种轻量级协议，通常在需要速度而牺牲可靠性的情况下选择。 |'
- en: '| Socket | The combination of an IP address and a port number is generally
    referred to as a socket. |'
  id: totrans-1674
  prefs: []
  type: TYPE_TB
  zh: '| Socket | IP地址和端口号的组合通常被称为套接字。 |'
- en: '| Packet | TCP packets are also known as *segments*—the combination of a chunk
    of data along with a header. |'
  id: totrans-1675
  prefs: []
  type: TYPE_TB
  zh: '| Packet | TCP数据包也称为*段*——数据块和头部信息的组合。 |'
- en: '| Datagram | The UDP equivalent of a packet. |'
  id: totrans-1676
  prefs: []
  type: TYPE_TB
  zh: '| Datagram | 与数据包相当的UDP协议。 |'
- en: '| MTU | Maximum Transmission Unit—The largest size of a protocol data unit.
    Each layer can have an MTU: IPv4 is at least 68 bytes, and Ethernet v2 is 1,500
    bytes. |'
  id: totrans-1677
  prefs: []
  type: TYPE_TB
  zh: '| MTU | 最大传输单元——协议数据单元的最大大小。每一层都可以有一个MTU：IPv4至少为68字节，以太网v2为1,500字节。 |'
- en: To understand Node’s networking APIs, it’s crucial to learn about layers, packets,
    sockets, and all the other things that networks are made of. If you don’t learn
    about the difference between TCP (Transmission Control Protocol) and UDP (User
    Datagram Protocol), then it would be difficult for you to know when to use these
    protocols. In this section we introduce the terms you need to know and then explore
    the concepts a bit more so you leave the section with a solid foundation.
  id: totrans-1678
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解Node的网络API，了解层、数据包、套接字以及网络由什么组成的所有其他事物至关重要。如果你不了解TCP（传输控制协议）和UDP（用户数据报协议）之间的区别，那么你很难知道何时使用这些协议。在本节中，我们介绍了你需要了解的术语，并进一步探讨了这些概念，以便你离开本节时有一个坚实的基础。
- en: If you’re responsible for implementing high-level protocols that run on top
    of HTTP or even low-latency game code that uses UDP, then you should understand
    each of these concepts. We break each of these concepts down into more detail
    over the next few sections.
  id: totrans-1679
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你负责实现运行在HTTP之上或甚至使用UDP的低延迟游戏代码的高级协议，那么你应该理解这些概念中的每一个。我们将在接下来的几节中详细分解这些概念。
- en: Layers
  id: totrans-1680
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 层
- en: The stack of protocols and standards that make up the internet and internet
    technology in general can be modeled as layers. The lowest layers represent physical
    media—Ethernet, Bluetooth, fiber optics—the world of pins, voltages, and network
    adapters. As software developers, we work at a higher level than lower-level hardware.
    When talking to networks with Node, we’re concerned with the *application* and
    *transport* layers of the Internet Protocol (IP) suite.
  id: totrans-1681
  prefs: []
  type: TYPE_NORMAL
  zh: 构成互联网和一般互联网技术的协议和标准堆栈可以建模为层。最低层代表物理媒体——以太网、蓝牙、光纤——针脚、电压和网络适配器的世界。作为软件开发者，我们工作在比底层硬件更高的层次。当我们使用Node与网络通信时，我们关注的是互联网协议（IP）套件中的*应用层*和*传输层*。
- en: Layers are best represented visually. [Figure 7.1](#ch07fig01) relates logical
    network layers to packets. The lower-level physical and data-link layer protocols
    wrap higher-level protocols.
  id: totrans-1682
  prefs: []
  type: TYPE_NORMAL
  zh: 层最好通过视觉表示。图7.1\[图7.1](#ch07fig01)将逻辑网络层与数据包相关联。低层的物理和数据链路层协议封装了高级协议。
- en: Figure 7.1\. Protocols are grouped into seven logical layers. Packets are wrapped
    by protocols at consecutive layers.
  id: totrans-1683
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.1\. 协议被分为七个逻辑层。数据包在连续的层中被协议封装。
- en: '![](07fig01_alt.jpg)'
  id: totrans-1684
  prefs: []
  type: TYPE_IMG
  zh: '![07fig01_alt.jpg](07fig01_alt.jpg)'
- en: 'Packets are wrapped by protocols at consecutive layers. A TCP packet, which
    could represent part of a series of packets from an HTTP request, is contained
    in the data section of an IP packet, which in turn is wrapped by an Ethernet packet.
    Going back to [figure 7.1](#ch07fig01), TCP packets from HTTP requests cut through
    the transport and application layers: TCP is the transport layer, used to create
    the higher-level HTTP protocol. The other layers are also involved, but we don’t
    always know which specific protocols are used at each layer: HTTP is always transmitted
    over TCP/IP, but beyond that, Wi-Fi or Ethernet can be used—your programs won’t
    know the difference.'
  id: totrans-1685
  prefs: []
  type: TYPE_NORMAL
  zh: 数据包在连续的层中被协议包裹。一个TCP数据包，可能代表一系列HTTP请求中的部分数据包，包含在IP数据包的数据部分中，而这个IP数据包反过来又被以太网数据包包裹。回到[图7.1](#ch07fig01)，HTTP请求的TCP数据包穿越了传输层和应用层：TCP是传输层，用于创建更高层的HTTP协议。其他层也参与其中，但我们并不总是知道每一层使用的是哪些具体的协议：HTTP总是通过TCP/IP传输，但除此之外，可以使用Wi-Fi或以太网——你的程序不会知道区别。
- en: '[Figure 7.2](#ch07fig02) shows how network layers are wrapped by each protocol.
    Notice that data is never seen to move more than one step between layers—we don’t
    talk about transport layer protocols interacting with the network layer.'
  id: totrans-1686
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.2](#ch07fig02)展示了网络层是如何被每个协议包裹的。请注意，数据在层与层之间移动的步数永远不会超过一个——我们不会谈论传输层协议与网络层的交互。'
- en: Figure 7.2\. Network layer wrapping
  id: totrans-1687
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.2\. 网络层包裹
- en: '![](07fig02_alt.jpg)'
  id: totrans-1688
  prefs: []
  type: TYPE_IMG
  zh: '![07fig02_alt.jpg](07fig02_alt.jpg)'
- en: When writing Node programs, you should appreciate that HTTP is implemented using
    TCP because Node’s `http` module is built on the underlying TCP implementation
    found in the `net` module. But you don’t need to understand how Ethernet, 10BASE-T,
    or Bluetooth works.
  id: totrans-1689
  prefs: []
  type: TYPE_NORMAL
  zh: 当编写Node程序时，你应该认识到HTTP是通过TCP实现的，因为Node的`http`模块建立在`net`模块中找到的底层TCP实现之上。但你不需要了解以太网、10BASE-T或蓝牙是如何工作的。
- en: TCP/IP
  id: totrans-1690
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: TCP/IP
- en: You’ve probably heard of TCP/IP—this is what we call the *Internet Protocol
    suite* because the Transmission Control Protocol (TCP) and the Internet Protocol
    (IP) are the most important and earliest protocols defined by this standard.
  id: totrans-1691
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能听说过TCP/IP——这就是我们所说的*互联网协议套件*，因为传输控制协议（TCP）和互联网协议（IP）是这一标准定义的最重要和最早的协议。
- en: In Internet Protocol, a host is identified by an IP address. In IPv4, addresses
    are 32-bit, which limits the available address space. IP has been at the center
    of controversy over the last decade because addresses are running out. To fix
    this, a new version of the protocol known as IPv6 was developed.
  id: totrans-1692
  prefs: []
  type: TYPE_NORMAL
  zh: 在互联网协议中，主机通过IP地址来识别。在IPv4中，地址是32位的，这限制了可用的地址空间。IP在过去十年中一直是争议的焦点，因为地址正在耗尽。为了解决这个问题，开发了一种新的协议版本，称为IPv6。
- en: 'You can make TCP connections with Node by using the `net` module. This allows
    you to implement application layer protocols that aren’t supported by the core
    modules: IRC, POP, and even FTP could be implemented with Node’s core modules.
    If you find yourself needing to talk to nonstandard TCP protocols, perhaps something
    used internally in your company, then `net.Socket` and `net.createConnection`
    will make light work of it.'
  id: totrans-1693
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用`net`模块使用Node建立TCP连接。这允许你实现核心模块不支持的应用层协议：IRC、POP，甚至FTP都可以使用Node的核心模块实现。如果你发现自己需要与非标准TCP协议通信，可能是你公司内部使用的某种协议，那么`net.Socket`和`net.createConnection`将使这项工作变得简单。
- en: 'Node supports both IPv4 and IPv6 in several ways: the `dns` module can query
    IPv4 and IPv6 records, and the `net` module can transmit and receive data to hosts
    on IPv4 and IPv6 networks.'
  id: totrans-1694
  prefs: []
  type: TYPE_NORMAL
  zh: Node支持多种方式同时支持IPv4和IPv6：`dns`模块可以查询IPv4和IPv6记录，而`net`模块可以传输和接收IPv4和IPv6网络上的数据。
- en: The interesting thing about IP is it doesn’t guarantee data integrity or delivery.
    For reliable communication, we need a transport layer protocol like TCP. There
    are also times when delivery isn’t *always* required, although of course it’s
    preferred—in these situations a lighter protocol is needed, and that’s where UDP
    comes in. The next section examines TCP and UDP in more detail.
  id: totrans-1695
  prefs: []
  type: TYPE_NORMAL
  zh: 关于IP有趣的是，它不保证数据完整性或交付。为了可靠通信，我们需要一个传输层协议，如TCP。有时，交付并不是*总是*必需的，尽管当然更受欢迎——在这些情况下，需要一个更轻量级的协议，这就是UDP的作用。下一节将更详细地探讨TCP和UDP。
- en: UDP and how it compares to TCP
  id: totrans-1696
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: UDP及其与TCP的比较
- en: Datagrams are the basic unit of communication in UDP. These messages are self-contained,
    holding a source, destination, and some user data. UDP doesn’t guarantee delivery
    or message order, or offer protection against duplicated data. Most protocols
    you’ll use with Node programs will be built on TCP, but there are times when UDP
    is useful. If delivery isn’t critical, but performance is desired, then UDP may
    be a better choice. One example is a streaming video service, where occasional
    glitches are an acceptable trade-off to gain more throughput.
  id: totrans-1697
  prefs: []
  type: TYPE_NORMAL
  zh: 数据报是UDP中通信的基本单元。这些消息是自包含的，包含源地址、目标地址和一些用户数据。UDP不保证交付或消息顺序，也不提供防止数据重复的保护。你将使用的大多数与Node程序一起使用的协议都将建立在TCP之上，但有时UDP很有用。如果交付不是关键，但需要性能，那么UDP可能是一个更好的选择。一个例子是流媒体视频服务，偶尔的故障可以作为增加更多吞吐量的可接受权衡。
- en: TCP and UDP both use the same network layer—IP. Both provide services to application
    layer protocols. But they’re very different. TCP is a connect-oriented and reliable
    byte stream service, whereas UDP is based around *datagrams*, and doesn’t guarantee
    the delivery of data.
  id: totrans-1698
  prefs: []
  type: TYPE_NORMAL
  zh: TCP和UDP都使用相同的网络层——IP。它们都为应用层协议提供服务。但它们非常不同。TCP是一个面向连接且可靠的字节流服务，而UDP基于*数据报*，不保证数据的交付。
- en: Contrast this to TCP, which is a full-duplex^([[1](#ch07fn01)]) connection-oriented
    protocol. In TCP, there are only ever two endpoints for a given connection. The
    basic unit of information passed between endpoints is known as a *segment*—the
    combination of a chunk of data along with a header. When you hear the term *packet*,
    a TCP segment is generally being referred to.
  id: totrans-1699
  prefs: []
  type: TYPE_NORMAL
  zh: 与此相对的是TCP，它是一个全双工^([[1](#ch07fn01)])面向连接的协议。在TCP中，给定连接只有两个端点。在端点之间传递的信息的基本单元被称为*段*——数据块和头部的组合。当你听到*数据包*这个词时，通常指的是TCP段。
- en: '¹ Full-duplex: messages can be sent and received in the same connection.'
  id: totrans-1700
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹ 全双工：可以在同一连接中发送和接收消息。
- en: Although UDP packets include checksums that help detect corruption, which can
    occur as a datagram travels across the internet, there’s no automatic retransmission
    of corrupt packets—it’s up to your application to handle this if required. Packets
    with invalid data will be effectively silently discarded.
  id: totrans-1701
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管UDP数据包包含校验和，这有助于检测在数据报穿越互联网过程中可能发生的损坏，但不会自动重传损坏的数据包——如果需要，这取决于你的应用程序来处理。包含无效数据的数据包将被有效地静默丢弃。
- en: Every packet, whether it’s TCP or UDP, has an origin and destination address.
    But the source and destination *programs* are also important. When your Node program
    connects to a DNS server or accepts incoming HTTP connections, there has to be
    a way to map between the packets traveling along the network and the programs
    that generated them. To fully describe a connection, you need an extra piece of
    information. This is known as a *port number*—the combination of a port number
    and an address is known as a socket. Read on to learn more about ports and how
    they relate to sockets.
  id: totrans-1702
  prefs: []
  type: TYPE_NORMAL
  zh: 每个数据包，无论是TCP还是UDP，都有一个源地址和目标地址。但源地址和目标*程序*也同样重要。当你的Node程序连接到DNS服务器或接受传入的HTTP连接时，必须有一种方法来映射在网络中传输的数据包和生成它们的应用程序之间。要完全描述一个连接，你需要额外的信息。这被称为*端口号*——端口号和地址的组合称为套接字。继续阅读以了解更多关于端口号以及它们与套接字的关系。
- en: Sockets
  id: totrans-1703
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 套接字
- en: The basic unit of a network, from a programmer’s perspective, is the socket.
    A socket is the combination of an IP address and a port number—and there are both
    TCP and UDP sockets. As you saw in the previous section, a TCP connection is full-duplex—opening
    a connection to a given host allows communication to flow *to* and *from* that
    host. Although the term *socket* is correct, historically “socket” meant the Berkeley
    Sockets API.
  id: totrans-1704
  prefs: []
  type: TYPE_NORMAL
  zh: 从程序员的视角来看，网络的基本单元是套接字。套接字是IP地址和端口号的组合——既有TCP套接字也有UDP套接字。正如你在上一节中看到的，TCP连接是全双工的——打开到特定主机的连接允许通信流向该主机以及从该主机流向。尽管“套接字”这个词是正确的，但历史上“套接字”指的是伯克利套接字API。
- en: '|  |'
  id: totrans-1705
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: The Berkeley Sockets API
  id: totrans-1706
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 伯克利套接字API
- en: Berkeley Sockets, released in 1983, was an API for working with internet sockets.
    This is the original API for the TCP/IP suite. Although the origins lie in Unix,
    Microsoft Windows includes a networking stack that closely follows Berkeley Sockets.
  id: totrans-1707
  prefs: []
  type: TYPE_NORMAL
  zh: 1983年发布的伯克利套接字是用于处理互联网套接字的API。这是TCP/IP套件的原始API。尽管其起源在于Unix，但Microsoft Windows包括一个与伯克利套接字紧密遵循的网络堆栈。
- en: '|  |'
  id: totrans-1708
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: There are well-known port numbers for standard TCP/IP services. They include
    DNS, HTTP, SSH, and more. These port numbers are usually odd numbers due to historical
    reasons. TCP and UDP ports are distinct so they can overlap. If an application
    layer protocol requires both TCP *and* UDP connections, then the convention is
    to use the same port number for both connections. An example of a protocol that
    uses both UDP and TCP is DNS.
  id: totrans-1709
  prefs: []
  type: TYPE_NORMAL
  zh: 对于标准的TCP/IP服务，有一些众所周知的端口号。它们包括DNS、HTTP、SSH等。这些端口号通常由于历史原因而通常是奇数。TCP和UDP端口号是不同的，因此它们可以重叠。如果一个应用层协议需要TCP和UDP连接，那么惯例是使用相同的端口号来处理这两个连接。一个既使用UDP又使用TCP的协议示例是DNS。
- en: In Node, you can create TCP sockets with the `net` module, and UDP is supported
    by the `dgram` module. Other networking protocols are also supported—DNS is a
    good example.
  id: totrans-1710
  prefs: []
  type: TYPE_NORMAL
  zh: 在Node中，你可以使用`net`模块创建TCP套接字，UDP由`dgram`模块支持。其他网络协议也得到支持——DNS是一个很好的例子。
- en: The following sections look at the application layer protocols included in Node’s
    core modules.
  id: totrans-1711
  prefs: []
  type: TYPE_NORMAL
  zh: 以下几节将探讨Node核心模块中包含的应用层协议。
- en: 7.1.2\. Node’s networking modules
  id: totrans-1712
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.1.2. Node的网络模块
- en: Node has a suite of networking modules that allows you to build web and other
    server applications. Over the next few sections we’ll cover DNS, TCP, HTTP, and
    encryption.
  id: totrans-1713
  prefs: []
  type: TYPE_NORMAL
  zh: Node提供了一套网络模块，允许你构建Web和其他服务器应用程序。在接下来的几节中，我们将介绍DNS、TCP、HTTP和加密。
- en: DNS
  id: totrans-1714
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: DNS
- en: The Domain Name System (DNS) is the naming system for addressing resources connected
    to the internet (or even a private network). Node has a core module called `dns`
    for looking up and resolving addresses. Like other core modules, `dns` has asynchronous
    APIs. In this case, the implementation is also asynchronous, apart from certain
    methods that are backed by a thread pool. This means DNS queries in Node are fast,
    but also have a friendly API that is easy to learn.
  id: totrans-1715
  prefs: []
  type: TYPE_NORMAL
  zh: 域名系统（DNS）是为连接到互联网（或甚至私有网络）的资源提供命名的系统。Node有一个名为`dns`的核心模块，用于查找和解析地址。与其他核心模块一样，`dns`具有异步API。在这种情况下，实现也是异步的，除了某些由线程池支持的方法。这意味着Node中的DNS查询速度快，同时还有一个友好且易于学习的API。
- en: You don’t often have to use this module, but we’ve included techniques because
    it’s a powerful API that can come in handy for network programming. Most application
    layer protocols, HTTP included, accept hostnames rather than IP addresses.
  id: totrans-1716
  prefs: []
  type: TYPE_NORMAL
  zh: 你通常不需要使用这个模块，但我们包括了一些技术，因为这个API非常强大，对于网络编程来说可能很有用。大多数应用层协议，包括HTTP，都接受主机名而不是IP地址。
- en: Node also provides modules for networking protocols that we’re more familiar
    with—for example, HTTP.
  id: totrans-1717
  prefs: []
  type: TYPE_NORMAL
  zh: Node还提供了我们更熟悉的网络协议模块——例如，HTTP。
- en: HTTP
  id: totrans-1718
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: HTTP
- en: HTTP is important to most Node developers. Whether you’re building web applications
    or calling web services, you’re probably interacting with HTTP in some way. Node’s
    `http` core module is built on the `net`, `stream`, `buffer`, and `events` modules.
    It’s low-level, but can be used to create simple HTTP servers and clients without
    too much effort.
  id: totrans-1719
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP对于大多数Node开发者来说都很重要。无论你是构建Web应用程序还是调用Web服务，你很可能以某种方式与HTTP交互。Node的`http`核心模块建立在`net`、`stream`、`buffer`和`events`模块之上。它是低级的，但可以用来创建简单的HTTP服务器和客户端，而不需要太多的努力。
- en: Due to the importance of the web to Node development, we’ve included several
    techniques that explore Node’s `http` module. Also, when we’re working with HTTP
    we often need to use encryption—Node also supports encryption through the `crypto`
    and `tls` modules.
  id: totrans-1720
  prefs: []
  type: TYPE_NORMAL
  zh: 由于网络对于Node开发的重要性，我们包括了几个探索Node的`http`模块的技术。此外，当我们处理HTTP时，我们通常需要使用加密——Node也通过`crypto`和`tls`模块支持加密。
- en: Encryption
  id: totrans-1721
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 加密
- en: 'You should know the term *SSL*—Secure Sockets Layer—because it’s how secure
    web pages are served to web browsers. Not just HTTP traffic gets encrypted, though—other
    services, like email, encrypt messages as well. Encrypted TCP connections use
    TLS: Transport Layer Security. Node’s `tls` module is implemented using OpenSSL.'
  id: totrans-1722
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该了解术语*SSL*——安全套接字层——因为它是指如何将安全的网页发送到网络浏览器。不过，不仅仅是HTTP流量被加密——其他服务，如电子邮件，也会加密消息。加密的TCP连接使用TLS：传输层安全性。Node的`tls`模块是使用OpenSSL实现的。
- en: This type of encryption is called *public key cryptography*. Both clients and
    servers must have private keys. The server can then make its public key available
    so clients can encrypt messages. To decrypt these messages, access to the server’s
    *private* key is required.
  id: totrans-1723
  prefs: []
  type: TYPE_NORMAL
  zh: 这种加密类型被称为*公钥加密学*。客户端和服务器都必须有私钥。然后服务器可以使其公钥可用，以便客户端可以加密消息。要解密这些消息，需要访问服务器的*私钥*。
- en: Node supports TLS by allowing TCP servers to be created that support several
    ciphers. The TCP server itself inherits from `net.Server`—once you’ve got your
    head around TCP clients and servers in Node, encrypted connections are just an
    extension of these principles.
  id: totrans-1724
  prefs: []
  type: TYPE_NORMAL
  zh: Node通过允许创建支持多个加密套件的TCP服务器来支持TLS。TCP服务器本身继承自`net.Server`——一旦你掌握了Node中的TCP客户端和服务器，加密连接只是这些原则的扩展。
- en: A solid understanding of TLS is important if you want to deploy web applications
    with Node. People are increasingly concerned with security and privacy, and unfortunately
    SSL/TLS is designed in such a way that programmer error can cause security weaknesses.
  id: totrans-1725
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想使用Node部署Web应用程序，对TLS有扎实的理解是非常重要的。人们越来越关注安全和隐私，不幸的是，SSL/TLS被设计成这样的方式，程序员的错误可能导致安全漏洞。
- en: 'There’s one final aspect of networking in Node that we’d like to introduce
    before we move on to the techniques for this chapter: how Node is able to give
    you asynchronous APIs to networking technologies that are sometimes blocking at
    the system level.'
  id: totrans-1726
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续本章的技术之前，我们想介绍Node网络的一个最终方面：Node是如何提供异步API给那些在系统级别有时会阻塞的网络技术的。
- en: 7.1.3\. Non-blocking networking and thread pools
  id: totrans-1727
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.1.3\. 非阻塞网络和线程池
- en: This section delves into Node’s lower-level implementation to explore how networking
    works under the hood. If you’re confused about what exactly “asynchronous” means
    in the context of networking, then read on for some background information on
    what makes Node’s networking APIs tick.
  id: totrans-1728
  prefs: []
  type: TYPE_NORMAL
  zh: 本节深入探讨了Node的底层实现，以了解网络是如何在底层工作的。如果你对网络上下文中“异步”的确切含义感到困惑，那么请继续阅读，以了解使Node的网络API工作的背景信息。
- en: Remember that in Node, APIs are said to be *asynchronous* when they accept a
    callback and return immediately. At the operating system level, I/O operations
    can also be asynchronous, or they can be synchronous and wrapped with threads
    to appear asynchronous.
  id: totrans-1729
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，在Node中，当API接受回调并立即返回时，它们被称为*异步*。在操作系统级别，I/O操作也可以是异步的，或者它们可以是同步的，并使用线程包装以表现出异步性。
- en: Node employs several techniques to provide asynchronous network APIs. The main
    ones are non-blocking system calls and thread pools to wrap around blocking system
    calls.
  id: totrans-1730
  prefs: []
  type: TYPE_NORMAL
  zh: Node采用几种技术来提供异步网络API。主要的是非阻塞系统调用和线程池来包装阻塞系统调用。
- en: Behind the scenes, most of Node’s networking code is written in C and C++—the
    JavaScript code in Node’s source gives you an asynchronous binding to features
    provided by `libuv` and `c-ares`.
  id: totrans-1731
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，Node的大部分网络代码是用C和C++编写的——Node源代码中的JavaScript代码为你提供了对`libuv`和`c-ares`提供的功能的异步绑定。
- en: '[Figure 7.3](#ch07fig03) shows Apple’s Instruments tool recording the activity
    of a Node program that makes 50 HTTP requests. HTTP requests are non-blocking—each
    takes place using callbacks that are run on the main thread. The BSD sockets library,
    which is used by `libuv`, can make non-blocking TCP and UDP connections.'
  id: totrans-1732
  prefs: []
  type: TYPE_NORMAL
  zh: '[图7.3](#ch07fig03)显示了Apple的Instruments工具记录了一个Node程序发起50个HTTP请求的活动。HTTP请求是非阻塞的——每个请求都使用在主线程上运行的回调进行。'
- en: Figure 7.3\. Node’s threads when making HTTP requests
  id: totrans-1733
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.3\. Node在发起HTTP请求时的线程
- en: '![](07fig03_alt.jpg)'
  id: totrans-1734
  prefs: []
  type: TYPE_IMG
  zh: '![](07fig03_alt.jpg)'
- en: For HTTP and other TCP connections, Node is able to access the network using
    a system-level non-blocking API.
  id: totrans-1735
  prefs: []
  type: TYPE_NORMAL
  zh: 对于HTTP和其他TCP连接，Node能够通过系统级的非阻塞API访问网络。
- en: 'When writing networking or file system code, the Node code *looks* asynchronous:
    you pass a function to a method that will execute the function when the I/O operation
    has reached the desired state. But for file operations, the underlying implementation
    is not asynchronous: thread pools are used instead.'
  id: totrans-1736
  prefs: []
  type: TYPE_NORMAL
  zh: 当编写网络或文件系统代码时，Node代码*看起来*是异步的：你传递一个函数给一个方法，该方法将在I/O操作达到所需状态时执行该函数。但对于文件操作，底层实现不是异步的：而是使用线程池。
- en: When dealing with I/O operations, understanding the difference between non-blocking
    I/O, thread pools, and asynchronous APIs is important if you want to truly understand
    how Node works.
  id: totrans-1737
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理I/O操作时，了解非阻塞I/O、线程池和异步API之间的区别对于真正理解Node的工作方式非常重要。
- en: For those interested in reading more about `libuv` and networking, the freely
    available book, *An Introduction to libuv* ([http://nikhilm.github.io/uvbook/networking.html#tcp](http://nikhilm.github.io/uvbook/networking.html#tcp))
    has a section on networking that covers TCP, DNS, and UDP.
  id: totrans-1738
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些想了解更多关于 `libuv` 和网络的人来说，免费提供的书籍《libuv简介》([http://nikhilm.github.io/uvbook/networking.html#tcp](http://nikhilm.github.io/uvbook/networking.html#tcp))
    中有一节关于网络，涵盖了TCP、DNS和UDP。
- en: 'Now on to the first set of networking techniques: TCP clients and servers.'
  id: totrans-1739
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是第一组网络技术：TCP客户端和服务器。
- en: 7.2\. TCP clients and servers
  id: totrans-1740
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2：TCP客户端和服务器
- en: Node has a simple API for creating TCP connections and servers. Most of the
    lowest-level classes and methods can be found in the `net` module. In the next
    technique, you’ll learn how to create a TCP server and track the clients that
    connect to it. The cool thing about this is that higher-level protocols like HTTP
    are built on top of the TCP API, so once you’ve got the hang of TCP clients and
    servers, you can really start to exploit some of the more subtle features of the
    HTTP API as well.
  id: totrans-1741
  prefs: []
  type: TYPE_NORMAL
  zh: Node有一个简单的API用于创建TCP连接和服务器。大多数最低级别的类和方法都可以在 `net` 模块中找到。在下一个技术中，你将学习如何创建TCP服务器并跟踪连接到它的客户端。酷的地方在于，像HTTP这样的高级协议是建立在TCP
    API之上的，所以一旦你掌握了TCP客户端和服务器，你就可以真正开始利用HTTP API的一些更微妙的功能。
- en: Technique 45 Creating a TCP server and tracking clients
  id: totrans-1742
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 技巧45：创建TCP服务器并跟踪客户端
- en: The `net` module forms the foundation of many of Node’s networking features.
    This technique demonstrates how to create a TCP server.
  id: totrans-1743
  prefs: []
  type: TYPE_NORMAL
  zh: '`net` 模块构成了Node许多网络功能的基础。这个技术演示了如何创建一个TCP服务器。'
- en: Problem
  id: totrans-1744
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: You want to start your own TCP server, bind to a port, and send data over the
    network.
  id: totrans-1745
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要启动自己的TCP服务器，绑定到一个端口，并在网络上发送数据。
- en: Solution
  id: totrans-1746
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use `net.createServer` to create a server, and then call `server.listen` to
    bind it to a port. To connect to the server, either use the command-line tool
    `telnet` or create an in-process client connection with its client counterpart,
    `net.connect`.
  id: totrans-1747
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `net.createServer` 创建服务器，然后调用 `server.listen` 来将其绑定到端口。要连接到服务器，可以使用命令行工具
    `telnet` 或使用其客户端对应物 `net.connect` 创建进程内的客户端连接。
- en: Discussion
  id: totrans-1748
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论
- en: The `net.createServer` method returns an object that can be used to listen on
    a given TCP port for incoming connections. When a client makes a new connection,
    the callback passed to `net.createServer` will run. This callback receives a connection
    object which extends `EventEmitter`.
  id: totrans-1749
  prefs: []
  type: TYPE_NORMAL
  zh: '`net.createServer` 方法返回一个对象，可以用来在给定的TCP端口上监听传入的连接。当客户端建立新的连接时，传递给 `net.createServer`
    的回调将运行。这个回调接收一个连接对象，它扩展了 `EventEmitter`。'
- en: The server object itself is an instance of `net.Server`, which is just a wrapper
    around the `net.Socket` class. It’s interesting to note that `net.Socket` is implemented
    using a duplex stream—for more on streams, see [chapter 5](kindle_split_014.html#ch05).
  id: totrans-1750
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器对象本身是 `net.Server` 的一个实例，它只是 `net.Socket` 类的一个包装器。值得注意的是，`net.Socket` 是使用双工流实现的——关于流的更多信息，请参阅[第5章](kindle_split_014.html#ch05)。
- en: Before going into more theory, let’s look at an example that you can run and
    connect to with `telnet`. The following listing shows a simple TCP server that
    accepts connections and echoes data back to the client.
  id: totrans-1751
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入理论之前，让我们看看一个你可以运行并使用 `telnet` 连接到它的示例。下面的列表显示了一个简单的TCP服务器，它接受连接并将数据回显给客户端。
- en: Listing 7.1\. A simple TCP server
  id: totrans-1752
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.1：简单的TCP服务器
- en: '![](144fig01_alt.jpg)'
  id: totrans-1753
  prefs: []
  type: TYPE_IMG
  zh: '![144fig01_alt.jpg](144fig01_alt.jpg)'
- en: To try out this example, run `node server.js` to start a server, and then run
    `telnet localhost 8000` to connect to it with `telnet`. You can connect several
    times to see the ID incremented. If you disconnect, a message should be printed
    that contains the correct client ID.
  id: totrans-1754
  prefs: []
  type: TYPE_NORMAL
  zh: 要尝试这个示例，运行 `node server.js` 来启动服务器，然后运行 `telnet localhost 8000` 使用 `telnet`
    连接到它。你可以多次连接以查看ID递增。如果你断开连接，应该会打印出包含正确客户端ID的消息。
- en: Most programs that use TCP clients and servers load the `net` module ![](1.jpg).
    Once it has been loaded, TCP servers can be created using `net.createServer`,
    which is actually just a shortcut for `new net.Server` with a `listener` event
    listener. After a server has been instantiated, it can be set to listen for connections
    on a given port using `server.listen` ![](7.jpg).
  id: totrans-1755
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数使用TCP客户端和服务器的程序都会加载 `net` 模块 ![1.jpg](1.jpg)。一旦加载，就可以使用 `net.createServer`
    创建TCP服务器，这实际上只是 `new net.Server` 的一个带有 `listener` 事件监听器的快捷方式。服务器实例化后，可以使用 `server.listen`
    将其设置为在指定端口上监听连接 ![7.jpg](7.jpg)。
- en: To echo back data sent by the client, `pipe` is used ![](6.jpg). Sockets are
    streams, so you can use the standard stream API methods with them as you saw in
    [chapter 5](kindle_split_014.html#ch05).
  id: totrans-1756
  prefs: []
  type: TYPE_NORMAL
  zh: '为了回显客户端发送的数据，使用 `pipe` ![](6.jpg)。套接字是流，因此你可以像在第五章中看到的那样使用标准流 API 方法。 '
- en: In this example, we track each client that has connected using a numerical ID
    by incrementing a “global” value ![](2.jpg) that tracks the number of clients
    ![](3.jpg). The total number of connected clients is stored in the callback’s
    scope by creating a local variable in the connection callback called `clientId`.
  id: totrans-1757
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们通过递增一个“全局”值 ![](2.jpg) 来跟踪连接的客户端数量 ![](3.jpg)，该值用于跟踪客户端的数量。连接回调中创建的本地变量
    `clientId` 存储在回调的作用域中，以跟踪每个已连接的客户端。
- en: This value is displayed whenever a client connects ![](5.jpg) or disconnects
    ![](4.jpg). The client argument passed to the server’s callback is actually a
    socket—you can write to it with `client.write` and data will be sent over the
    network.
  id: totrans-1758
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端连接 ![](5.jpg) 或断开连接 ![](4.jpg) 时，将显示此值。传递给服务器回调的客户端参数实际上是一个套接字——你可以使用 `client.write`
    向其写入，数据将通过网络发送。
- en: The important thing to note is any event listener added to the socket in the
    server’s callback will share the same scope—it will create closures around any
    variables inside this callback. That means the client ID is unique to each connection,
    and you can also store other values that clients might need. This forms a common
    pattern employed by client-server applications in Node.
  id: totrans-1759
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的重要事项是添加到服务器回调中套接字上的任何事件监听器都将共享相同的范围——它将在回调内部创建任何变量的闭包。这意味着客户端 ID 对每个连接都是唯一的，你也可以存储其他客户端可能需要的值。这形成了客户端-服务器应用程序在
    Node 中采用的一种常见模式。
- en: The next technique builds on this example by adding client connections in the
    same process.
  id: totrans-1760
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个技术在这个例子基础上，通过在同一个进程中添加客户端连接来扩展。
- en: Technique 46 Testing TCP servers with clients
  id: totrans-1761
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 技术编号 46 使用客户端测试 TCP 服务器
- en: Node makes creating TCP servers *and* clients in the same process a breeze—it’s
    an approach particularly useful for testing your network programs. In this technique
    you’ll learn how to make TCP clients, and use them to test a server.
  id: totrans-1762
  prefs: []
  type: TYPE_NORMAL
  zh: Node 使在同一个进程中创建 TCP 服务器和客户端变得轻而易举——这是一种特别适用于测试你的网络程序的方法。在本技术中，你将学习如何创建 TCP 客户端，并使用它们来测试服务器。
- en: Problem
  id: totrans-1763
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: You want to test a TCP server.
  id: totrans-1764
  prefs: []
  type: TYPE_NORMAL
  zh: 你想测试一个 TCP 服务器。
- en: Solution
  id: totrans-1765
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use `net.connect` to connect to the server’s port.
  id: totrans-1766
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `net.connect` 连接到服务器的端口。
- en: Discussion
  id: totrans-1767
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论
- en: Due to how TCP and UDP ports work, it’s entirely possible to create multiple
    servers and clients in the same process. For example, a Node HTTP server could
    also run a simple TCP server on another port that allows `telnet` connections
    for remote administration.
  id: totrans-1768
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 TCP 和 UDP 端口的工作方式，在同一个进程中创建多个服务器和客户端是完全可能的。例如，Node HTTP 服务器也可以在另一个端口上运行简单的
    TCP 服务器，该端口允许远程管理 `telnet` 连接。
- en: In [technique 45](#ch07lev2sec4), we demonstrated a TCP server that can track
    client connections by issuing each client a unique ID. Let’s write a test to ensure
    this worked correctly.
  id: totrans-1769
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [技术 45](#ch07lev2sec4) 中，我们演示了一个可以通过为每个客户端分配一个唯一 ID 来跟踪客户端连接的 TCP 服务器。现在让我们编写一个测试来确保它正确工作。
- en: '[Listing 7.2](#ch07ex02) shows how to create client connections to an in-process
    server, and then run assertions on the data sent over the network by the server.
    Of course, technically this isn’t running over a real network because it all happens
    in the same process, but it could easily be adapted to work that way; just copy
    the program to a server and specify its IP address or hostname in the client.'
  id: totrans-1770
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 7.2](#ch07ex02) 展示了如何创建到进程内服务器的客户端连接，然后对服务器通过网络发送的数据运行断言。当然，从技术上讲，这并不是在真实网络中运行，因为所有操作都在同一个进程中完成，但它可以很容易地适应这种方式；只需将程序复制到服务器，并在客户端指定其
    IP 地址或主机名即可。'
- en: Listing 7.2\. Creating TCP clients to test servers
  id: totrans-1771
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.2\. 创建 TCP 客户端以测试服务器
- en: '![](ch07ex02-0.jpg)'
  id: totrans-1772
  prefs: []
  type: TYPE_IMG
  zh: '![](ch07ex02-0.jpg)'
- en: '![](ch07ex02-1.jpg)'
  id: totrans-1773
  prefs: []
  type: TYPE_IMG
  zh: '![](ch07ex02-1.jpg)'
- en: 'This is a long example, but it centers around a relatively simple method: `net.connect`.
    This method accepts some optional arguments to describe the remote host. Here
    we’ve just specified a port number, but the second argument can be a hostname
    or IP address—`localhost` is the default ![](5.jpg). It also accepts a callback,
    which can be used to write data to the other end once the client has connected.
    Remember that TCP servers are full-duplex, so both ends can receive and send data.'
  id: totrans-1774
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个较长的示例，但它围绕一个相对简单的方法：`net.connect`。此方法接受一些可选参数来描述远程主机。这里我们只指定了端口号，但第二个参数可以是主机名或IP地址——`localhost`是默认值![图片5](5.jpg)。它还接受一个回调，可以在客户端连接后用于向另一端写入数据。请记住，TCP服务器是全双工的，所以两端都可以接收和发送数据。
- en: The `runTest` function in this example will run once the server has started
    listening ![](1.jpg). It accepts an expected client ID, and a callback called
    `done` ![](4.jpg). The callback will be triggered once the client has connected,
    received some data by subscribing to the `data` event ![](6.jpg), and then disconnected.
  id: totrans-1775
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，`runTest`函数将在服务器开始监听后运行一次![图片1](1.jpg)。它接受一个预期的客户端ID和一个名为`done`的回调![图片4](4.jpg)。当客户端连接、通过订阅`data`事件![图片6](6.jpg)接收一些数据并断开连接时，回调将被触发。
- en: Whenever clients are disconnected, the `end` event will be emitted. We bind
    the `done` callback to this event ![](8.jpg). When the test has finished in the
    `data` callback, we call `client.end` to disconnect the socket manually, but `end`
    events will be triggered when servers close connections, as well.
  id: totrans-1776
  prefs: []
  type: TYPE_NORMAL
  zh: 无论客户端何时断开连接，都会触发`end`事件。我们将`done`回调绑定到这个事件![图片8](8.jpg)。当测试在`data`回调中完成时，我们调用`client.end`来手动断开套接字，但是当服务器关闭连接时，也会触发`end`事件。
- en: The `data` event is where the main test is performed ![](7.jpg). The expected
    message is passed to `assert.equal` with the data passed to the event listener.
    The data is a buffer, so `toString` is called for the assertion to work. Once
    the test has finished, and the `end` event has been triggered ![](7.jpg), the
    callback passed to `runTest` will be executed.
  id: totrans-1777
  prefs: []
  type: TYPE_NORMAL
  zh: '`data`事件是主要测试执行的地方![图片7](7.jpg)。预期的消息被传递到`assert.equal`与传递给事件监听器的事件数据。数据是一个缓冲区，所以`toString`被调用以确保断言可以工作。一旦测试完成，并且触发了`end`事件![图片7](7.jpg)，传递给`runTest`的回调将被执行。'
- en: '|  |'
  id: totrans-1778
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Error handling**'
  id: totrans-1779
  prefs: []
  type: TYPE_NORMAL
  zh: '**错误处理**'
- en: If you need to collect errors generated by TCP connections, just subscribe to
    the `error` event on the `EventEmitter` objects returned by `net.connect`. If
    you don’t, an exception will be raised; this is standard behavior in Node.
  id: totrans-1780
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要收集由TCP连接生成的错误，只需订阅`net.connect`返回的`EventEmitter`对象的`error`事件。如果不这样做，将会抛出异常；这是Node的标准行为。
- en: Unfortunately, this isn’t easy to work with when dealing with sets of distinct
    network connections. In such cases, a better technique is to use the `domain`
    module. Creating a new domain with `domain.create()` will cause error events to
    be sent to the domain; you can then handle them in a centralized error handler
    by subscribing to `error` events on the domain.
  id: totrans-1781
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，在处理不同网络连接的集合时，这并不容易处理。在这种情况下，更好的技术是使用`domain`模块。使用`domain.create()`创建一个新的域将导致错误事件被发送到该域；然后你可以通过订阅域上的`error`事件在集中式错误处理器中处理它们。
- en: For more about domains, refer to [technique 21](kindle_split_013.html#ch04lev2sec3).
  id: totrans-1782
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于域的信息，请参阅[技术21](kindle_split_013.html#ch04lev2sec3)。
- en: '|  |'
  id: totrans-1783
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: We’ve used two calls to `runTest` here by calling one inside the callback. Once
    both have run, the number of expected assertions is checked ![](2.jpg), and the
    server is shut down ![](3.jpg).
  id: totrans-1784
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里通过在回调中调用一个来使用两个`runTest`调用。一旦两者都运行，就会检查预期的断言数量![图片2](2.jpg)，然后关闭服务器![图片3](3.jpg)。
- en: 'This example highlights two important things: clients and servers can be run
    together in-process, and Node TCP clients and servers are easy to unit test. If
    the server in this example were a remote service that we had no control over,
    then we could create a “mock” server for the express purpose of testing our client
    code. This forms the basis of how most developers write tests for web applications
    written with Node.'
  id: totrans-1785
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例突出了两个重要的事情：客户端和服务器可以在进程中一起运行，并且Node TCP客户端和服务器易于单元测试。如果这个示例中的服务器是一个我们无法控制的远程服务，那么我们可以创建一个“模拟”服务器，专门用于测试我们的客户端代码。这构成了大多数开发者为使用Node编写的Web应用程序编写测试的基础。
- en: In the next technique we’ll dig deeper into TCP networking by looking at Nagle’s
    algorithm and how it can affect the performance characteristics of network traffic.
  id: totrans-1786
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个技术中，我们将通过查看Nagle算法及其如何影响网络流量的性能特征来深入了解TCP网络。
- en: Technique 47 Improve low-latency applications
  id: totrans-1787
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 技巧 47 提高低延迟应用程序
- en: Although Node’s `net` module is relatively high-level, it does provide access
    to some low-level functionality. One example of this is control over the `TCP_NODELAY`
    flag, which determines whether Nagle’s algorithm is used. This technique explains
    what Nagle’s algorithm is, when you should use it, and how to turn it off for
    specific sockets.
  id: totrans-1788
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 Node 的 `net` 模块相对较高级，但它确实提供了一些低级功能访问。这方面的一个例子是对 `TCP_NODELAY` 标志的控制，它决定了是否使用
    Nagle 算法。这项技术解释了 Nagle 算法是什么，何时应该使用它，以及如何为特定套接字关闭它。
- en: Problem
  id: totrans-1789
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: You want to improve connection latency in a real-time application.
  id: totrans-1790
  prefs: []
  type: TYPE_NORMAL
  zh: 你想在实时应用程序中提高连接延迟。
- en: Solution
  id: totrans-1791
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use `socket.setNoDelay()` to enable `TCP_NODELAY`.
  id: totrans-1792
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `socket.setNoDelay()` 来启用 `TCP_NODELAY`。
- en: Discussion
  id: totrans-1793
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论
- en: Sometimes it’s more efficient to move batches of things together, rather than
    separately. Every day millions of products are shipped around the globe, but they’re
    not carried one at a time—instead they’re grouped together in shipping containers,
    based on their final destination. TCP works exactly the same way, and this feature
    is made possible by Nagle’s algorithm.
  id: totrans-1794
  prefs: []
  type: TYPE_NORMAL
  zh: 有时将事物批量移动比单独移动更有效率。每天有成千上万的产品在全球范围内运输，但它们并不是一个接一个地被携带——相反，它们根据最终目的地被分组在运输集装箱中。TCP
    正是以这种方式工作的，而这个特性是由 Nagle 算法实现的。
- en: Nagle’s algorithm says that when a connection has data that hasn’t yet been
    acknowledged, small segments should be retained. These small segments will be
    batched into larger segments that can be transmitted when sufficient data has
    been acknowledged by the recipient.
  id: totrans-1795
  prefs: []
  type: TYPE_NORMAL
  zh: Nagle 算法指出，当一个连接有尚未被确认的数据时，应该保留小的数据段。这些小数据段将被批量合并成更大的数据段，以便在接收方确认足够的数据后进行传输。
- en: In networks where many small packets are transmitted, it can be desirable to
    reduce congestion by combining small outgoing messages, and sending them together.
    But sometimes latency is desired over all else, so transmitting small packets
    is important.
  id: totrans-1796
  prefs: []
  type: TYPE_NORMAL
  zh: 在传输许多小数据包的网络中，通过合并小的输出消息并发送它们一起，可以减少拥塞。但有时，延迟比其他所有因素都重要，因此传输小数据包很重要。
- en: This is particularly true for interactive applications, like `ssh`, or the X
    Window System. In these applications, small messages should be delivered without
    delay to create a sense of real-time feedback. [Figure 7.4](#ch07fig04) illustrates
    the concept.
  id: totrans-1797
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于交互式应用程序尤其如此，如 `ssh` 或 X 窗口系统。在这些应用程序中，应该无延迟地传递小消息，以创建实时反馈的感觉。[图 7.4](#ch07fig04)
    说明了这个概念。
- en: Figure 7.4\. When Nagle’s algorithm is used, smaller packets are collected into
    a larger payload.
  id: totrans-1798
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.4\. 当使用 Nagle 算法时，较小的数据包被收集到较大的有效载荷中。
- en: '![](07fig04.jpg)'
  id: totrans-1799
  prefs: []
  type: TYPE_IMG
  zh: '![](07fig04.jpg)'
- en: Certain classes of Node programs benefit from turning off Nagle’s algorithm.
    For example, you may have created a REPL that transmits a single character at
    a time as the user types messages, or a game that transmits location data of players.
    The next listing shows a program that disables Nagle’s algorithm.
  id: totrans-1800
  prefs: []
  type: TYPE_NORMAL
  zh: 某些类别的 Node 程序从关闭 Nagle 算法中受益。例如，你可能创建了一个 REPL，它在用户输入消息时逐个字符地传输，或者一个传输玩家位置数据的游戏。下面的列表显示了一个禁用
    Nagle 算法的程序。
- en: Listing 7.3\. Turning off Nagle’s algorithm
  id: totrans-1801
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.3\. 关闭 Nagle 算法
- en: '![](148fig01_alt.jpg)'
  id: totrans-1802
  prefs: []
  type: TYPE_IMG
  zh: '![](148fig01_alt.jpg)'
- en: To use this example, run the program in a terminal with `node nagle.js`, and
    then connect to it with `telnet 8000`. The server turns off Nagle’s algorithm
    ![](1.jpg), and then forces the client to use character mode ![](2.jpg). Character
    mode is part of the Telnet Protocol (RFC 854), and will cause the Telnet client
    to send a packet whenever a key is pressed.
  id: totrans-1803
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用此示例，请在终端中运行程序 `node nagle.js`，然后使用 `telnet 8000` 连接到它。服务器关闭 Nagle 算法 ![](1.jpg)，然后强制客户端使用字符模式
    ![](2.jpg)。字符模式是 Telnet 协议（RFC 854）的一部分，并且会在按下键时导致 Telnet 客户端发送数据包。
- en: Next, `unref` is used ![](3.jpg) to cause the program to exit when there are
    no more client connections. Finally, the `data` event is used to capture characters
    sent by the client and print them to the server’s terminal ![](4.jpg).
  id: totrans-1804
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用 `unref` ![](3.jpg) 来使程序在没有更多客户端连接时退出。最后，使用 `data` 事件来捕获客户端发送的字符并将它们打印到服务器的终端
    ![](4.jpg)。
- en: This technique could form the basis for creating low-latency applications where
    data integrity is important, which therefore excludes UDP. If you really want
    to get more control over the transmission of data, then read on for some techniques
    that use UDP.
  id: totrans-1805
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术可以作为创建低延迟应用程序的基础，其中数据完整性很重要，因此排除了 UDP。如果你真的想对数据的传输有更多的控制，那么请继续阅读一些使用 UDP
    的技术。
- en: 7.3\. UDP clients and servers
  id: totrans-1806
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3. UDP 客户端和服务器
- en: 'Compared to TCP, UDP is a much simpler protocol. That can mean more work for
    you: rather than being able to rely on data being sent and received, you have
    to cater to UDP’s more volatile nature. UDP is suitable for query-response protocols,
    which is why it’s used for the Domain Name System (DNS). It’s also stateless—if
    you want to transfer data and you value lower latency over data integrity, then
    UDP is a good choice. That might sound unusual, but there are applications that
    fit these characteristics: media streaming protocols and online games generally
    use UDP.'
  id: totrans-1807
  prefs: []
  type: TYPE_NORMAL
  zh: 与 TCP 相比，UDP 是一个更简单的协议。这可能意味着你需要做更多的工作：而不是能够依赖数据的发送和接收，你必须适应 UDP 更易变的本性。UDP
    适用于查询-响应协议，这就是为什么它被用于域名系统 (DNS)。它也是无状态的——如果你想传输数据，并且你更重视低延迟而不是数据完整性，那么 UDP 是一个好的选择。这听起来可能有些不寻常，但确实有一些应用程序符合这些特征：媒体流协议和在线游戏通常使用
    UDP。
- en: 'If you wanted to build a video streaming service, you could transfer video
    over TCP, but each packet would have a lot of overhead for ensuring delivery.
    With UDP, it would be possible for data to be lost with no simple means of discovery,
    but with video you don’t care about occasional glitches—you just want data as
    fast as possible. In fact, some video and image formats can survive a small amount
    of data loss: the JPEG format is resilient to corrupt bytes to a certain extent.'
  id: totrans-1808
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要构建一个视频流媒体服务，你可以通过 TCP 传输视频，但每个数据包都会有大量的开销来确保传输。使用 UDP，数据可能会丢失，但没有简单的发现方法，但在视频方面，你并不关心偶尔的故障——你只想尽可能快地获取数据。事实上，一些视频和图像格式可以承受一定程度的数据丢失：JPEG
    格式对损坏的字节具有一定的容错性。
- en: The next technique combines Node’s file streams with UDP to create a simple
    server that can be used to transfer files. Although this can potentially result
    in data loss, it can be useful when you care about speed over all else.
  id: totrans-1809
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个技术将 Node 的文件流与 UDP 结合起来，创建一个简单的服务器，可以用来传输文件。尽管这可能会导致数据丢失，但在你更关心速度的情况下，它可能是有用的。
- en: Technique 48 Transferring a file with UDP
  id: totrans-1810
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 技巧 48 使用 UDP 传输文件
- en: This technique is really about sending data from a stream to a UDP server rather
    than creating a generalized file transfer mechanism. You can use it to learn the
    basics of Node’s datagram API.
  id: totrans-1811
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术实际上是将数据从流发送到 UDP 服务器，而不是创建一个通用的文件传输机制。你可以用它来学习 Node 的数据报 API 的基础知识。
- en: Problem
  id: totrans-1812
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: You want to transfer data from a client to a server using datagrams.
  id: totrans-1813
  prefs: []
  type: TYPE_NORMAL
  zh: 你想使用数据报从客户端向服务器传输数据。
- en: Solution
  id: totrans-1814
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use the `dgram` module to create datagram sockets, and then send data with `socket.send`.
  id: totrans-1815
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `dgram` 模块创建数据报套接字，然后使用 `socket.send` 发送数据。
- en: Discussion
  id: totrans-1816
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论
- en: 'Sending datagrams is similar to using TCP sockets, but the API is slightly
    different, and datagrams have their own rules that reflect the actual structure
    of UDP packets. To set up a server, use the following snippet:'
  id: totrans-1817
  prefs: []
  type: TYPE_NORMAL
  zh: 发送数据报类似于使用 TCP 套接字，但 API 略有不同，数据报有自己的规则，反映了 UDP 数据包的实际结构。要设置服务器，请使用以下代码片段：
- en: '![](150fig01_alt.jpg)'
  id: totrans-1818
  prefs: []
  type: TYPE_IMG
  zh: '![图片描述](150fig01_alt.jpg)'
- en: This example creates a socket that will act as the server ![](1.jpg), and then
    binds it to a port ![](2.jpg). The port can be anything you want, but in both
    TCP and UDP the first 1,023 ports are privileged.
  id: totrans-1819
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子创建了一个将作为服务器 ![图片描述](1.jpg) 的套接字，并将其绑定到一个端口 ![图片描述](2.jpg)。端口可以是任何你想要的，但在
    TCP 和 UDP 中，前 1,023 个端口是特权端口。
- en: The client API is different from TCP sockets because UDP is a *stateless* protocol.
    You must write data a packet at a time, and packets (datagrams) must be relatively
    small—under 65,507 bytes. The maximum size of a datagram depends on the Maximum
    Transmission Unit (MTU) of the network. 64 KB is the upper limit, but isn’t usually
    used because large datagrams may be silently dropped by the network.
  id: totrans-1820
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端 API 与 TCP 套接字不同，因为 UDP 是一个 *无状态* 协议。你必须一次写入一个数据包，并且数据包（数据报）必须相对较小——小于 65,507
    字节。数据报的最大大小取决于网络的最大传输单元 (MTU)。64 KB 是上限，但通常不使用，因为大的数据报可能会被网络无声地丢弃。
- en: 'Creating a client socket is the same as servers—use `dgram.createSocket`. Sending
    a datagram requires a buffer for the payload, an offset to indicate where in the
    buffer the message starts, the message length, the server port, the remote IP,
    and an optional callback that will be triggered when the message has been sent:'
  id: totrans-1821
  prefs: []
  type: TYPE_NORMAL
  zh: 创建客户端套接字与服务器相同——使用 `dgram.createSocket`。发送数据报需要有效负载的缓冲区、表示消息在缓冲区中起始位置的偏移量、消息长度、服务器端口、远程
    IP 以及一个可选的回调函数，当消息发送后将被触发：
- en: '[PRE72]'
  id: totrans-1822
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[Listing 7.4](#ch07ex04) combines a client and a server into a single program.
    To run it, you must issue two commands: `node udp-client-server.js server` to
    run the server, and then `node udp-client-server.js client remoteIP` to start
    a client. The `remoteIP` option can be omitted if you run both locally; we designed
    this example to be a single file so you can easily copy it to another computer
    to test sending things over the internet or a local network.'
  id: totrans-1823
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 7.4](#ch07ex04) 将客户端和服务器合并到一个程序中。要运行它，您必须发出两个命令：`node udp-client-server.js
    server` 来运行服务器，然后 `node udp-client-server.js client remoteIP` 来启动客户端。如果本地运行，则可以省略
    `remoteIP` 选项；我们设计这个示例为单个文件，这样您可以轻松地将其复制到另一台计算机以测试通过互联网或本地网络发送数据。'
- en: Listing 7.4\. A UDP client and server
  id: totrans-1824
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.4\. 一个 UDP 客户端和服务器
- en: '![](ch07ex04-0.jpg)'
  id: totrans-1825
  prefs: []
  type: TYPE_IMG
  zh: '![ch07ex04-0.jpg](ch07ex04-0.jpg)'
- en: '![](ch07ex04-1.jpg)'
  id: totrans-1826
  prefs: []
  type: TYPE_IMG
  zh: '![ch07ex04-1.jpg](ch07ex04-1.jpg)'
- en: When you run this example, it starts by checking the command-line options to
    see if the client or server is required ![](10.jpg). It also accepts an optional
    argument for clients so you can connect to remote servers ![](11.jpg).
  id: totrans-1827
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行此示例时，它首先检查命令行选项以查看是否需要客户端或服务器 ![10.jpg](10.jpg)。它还接受客户端的可选参数，以便您可以连接到远程服务器
    ![11.jpg](11.jpg)。
- en: If the client was specified, then a new client will be created by making a new
    datagram socket ![](2.jpg). This involves using a read stream from the `fs` module
    so we have some data to send to the server ![](1.jpg)—we’ve used `__filename`
    to make it read the current file, but you could make it send any file.
  id: totrans-1828
  prefs: []
  type: TYPE_NORMAL
  zh: 如果指定了客户端，则将通过创建一个新的数据报套接字来创建一个新的客户端 ![2.jpg](2.jpg)。这涉及到使用来自 `fs` 模块的读取流，以便我们有数据发送到服务器
    ![1.jpg](1.jpg)——我们使用了 `__filename` 来使其读取当前文件，但您也可以让它发送任何文件。
- en: Before sending any data, we need to make sure the file has been opened and is
    ready for reading, so the `readable` event is subscribed to ![](3.jpg). The callback
    for this event executes the `sendData` function. This will be called repeatedly
    for each chunk of the file—files are read in small chunks at a time using `inStream.read`
    ![](4.jpg), because UDP packets can be silently dropped if they’re too large.
    The `socket.send` method is used to push the data to the server ![](6.jpg). The
    `message` object returned when reading the file is an instance of `Buffer`, and
    it can be passed straight to `socket.send`.
  id: totrans-1829
  prefs: []
  type: TYPE_NORMAL
  zh: 在发送任何数据之前，我们需要确保文件已被打开并且准备好读取，因此订阅了 `readable` 事件 ![3.jpg](3.jpg)。此事件的回调执行 `sendData`
    函数。这将针对文件的每个块重复调用——文件是使用 `inStream.read` ![4.jpg](4.jpg) 逐块读取的，因为如果数据报太大，它们可能会被静默丢弃。使用
    `socket.send` 方法将数据推送到服务器 ![6.jpg](6.jpg)。读取文件时返回的 `message` 对象是 `Buffer` 的实例，并且可以直接传递给
    `socket.send`。
- en: When all of the data has been read, the last chunk is set to `null`. The `socket.unref`
    ![](5.jpg) method is called to cause the program to exit when the socket is no
    longer required—in this case, once it has sent the last message.
  id: totrans-1830
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有数据都已读取后，最后一个块被设置为 `null`。调用 `socket.unref` ![5.jpg](5.jpg) 方法来使程序在套接字不再需要时退出——在这种情况下，一旦发送了最后一条消息。
- en: '|  |'
  id: totrans-1831
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Datagram packet layout and datagram size**'
  id: totrans-1832
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据报包布局和数据报大小**'
- en: UDP packets are comparatively simple. They’re composed of a source port, the
    destination port, datagram length, checksum, and the payload data. The length
    is the total size of the packet—the header size added to the payload’s size. When
    deciding on your application’s buffer size for UDP packets, you should remember
    that the length passed to `socket.send` is only for the buffer (payload), and
    the overall packet size must be under the MTU on the network. The structure of
    a datagram looks like the following.
  id: totrans-1833
  prefs: []
  type: TYPE_NORMAL
  zh: UDP 数据报相对简单。它们由源端口、目标端口、数据报长度、校验和以及有效负载数据组成。长度是数据包的总大小——头部大小加上有效负载的大小。在为 UDP
    数据包决定应用程序的缓冲区大小时，您应该记住传递给 `socket.send` 的长度仅适用于缓冲区（有效负载），并且整个数据包大小必须在网络上的 MTU
    之下。数据报的结构如下所示。
- en: '![](152fig01.jpg)'
  id: totrans-1834
  prefs: []
  type: TYPE_IMG
  zh: '![152fig01.jpg](152fig01.jpg)'
- en: The UDP header is 8 bytes, followed by an optional payload of up to 65,507 bytes
    for IPv4 and 65,527 bytes for IPv6.
  id: totrans-1835
  prefs: []
  type: TYPE_NORMAL
  zh: UDP 头部为 8 字节，后面跟着可选的有效负载，对于 IPv4 最多为 65,507 字节，对于 IPv6 最多为 65,527 字节。
- en: '|  |'
  id: totrans-1836
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: The server is simpler than the client. It sets up a socket in the same way ![](7.jpg),
    and then subscribes to two events. The first event is `message`, which is emitted
    when a datagram is received ![](8.jpg). The data is written to the terminal by
    using `process.stdout.write`. This looks better than using `console.log` because
    it won’t automatically add newlines.
  id: totrans-1837
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器比客户端简单。它以相同的方式设置套接字 ![](7.jpg)，然后订阅两个事件。第一个事件是`message`，当接收到数据报时发出 ![](8.jpg)。数据通过使用`process.stdout.write`写入终端。这比使用`console.log`更好，因为它不会自动添加新行。
- en: The `listening` event is emitted when the server is ready to accept connections
    ![](9.jpg). A message is displayed to indicate this so you know it’s safe to try
    connecting a client.
  id: totrans-1838
  prefs: []
  type: TYPE_NORMAL
  zh: 当服务器准备好接受连接时，会发出`listening`事件 ![](9.jpg)。显示一条消息以表明这一点，这样你知道可以安全地尝试连接客户端。
- en: Even though this is a simple example, it’s immediately obvious how UDP is different
    from TCP—you need to pay attention to the size of the messages you send, and realize
    that it’s possible for messages to get lost. Although datagrams have a checksum,
    lost or damaged packets aren’t reported to the application layer, which means
    data loss is possible. It’s generally best to use UDP for sending data where assured
    integrity is second place to low latency and throughput.
  id: totrans-1839
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这是一个简单的例子，但UDP与TCP的不同之处立即显而易见——你需要注意你发送的消息的大小，并意识到消息可能会丢失。尽管数据报有校验和，但丢失或损坏的数据包不会报告给应用层，这意味着可能发生数据丢失。通常，在确保完整性排在低延迟和吞吐量之后的情况下，最好使用UDP发送数据。
- en: In the next technique you’ll see how to build on this example by sending messages
    back to the client, essentially setting up bidirectional communication channels
    with UDP.
  id: totrans-1840
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个技巧中，你将看到如何通过向客户端发送消息来在此基础上构建示例，实际上是通过UDP设置双向通信通道。
- en: Technique 49 UDP client server applications
  id: totrans-1841
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 技巧49 UDP客户端/服务器应用程序
- en: UDP is often used for query-response protocols, like DNS and DHCP. This technique
    demonstrates how to send messages back to the client.
  id: totrans-1842
  prefs: []
  type: TYPE_NORMAL
  zh: UDP通常用于查询-响应协议，如DNS和DHCP。这个技巧演示了如何将消息发送回客户端。
- en: Problem
  id: totrans-1843
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: You’ve created a UDP server that responds to requests, but you want to send
    messages back to the client.
  id: totrans-1844
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经创建了一个响应请求的UDP服务器，但你想向客户端发送消息。
- en: Solution
  id: totrans-1845
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案
- en: Once you’ve created a server and it has received a message, create a datagram
    connection *back* to the client based on the `rinfo` argument that’s passed to
    `message` events. Optionally create a unique reference by combining the client
    port and IP address to send subsequent messages.
  id: totrans-1846
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了一个服务器并且它已经接收到了消息，就根据传递给`message`事件的`rinfo`参数创建一个回客户端的数据报连接 *回*。可选地，通过组合客户端端口号和IP地址创建一个唯一的引用，以发送后续消息。
- en: Discussion
  id: totrans-1847
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论
- en: Chat servers are the classic network programming example for new Node programmers,
    but this one has a twist—it uses UDP instead of TCP or HTTP.
  id: totrans-1848
  prefs: []
  type: TYPE_NORMAL
  zh: 聊天服务器是Node程序员的新网络编程的典型示例，但这个例子有一个转折——它使用UDP而不是TCP或HTTP。
- en: TCP connections are different from UDP, and this is apparent in the design of
    Node’s networking API. TCP connections are represented as a stream of bidirectional
    events, so sending a message back to the sender is straightforward—once a client
    has connected you can write messages to it at any time using `client.write`. UDP,
    on the other hand, is *connectionless*—messages are received without an active
    connection to the client.
  id: totrans-1849
  prefs: []
  type: TYPE_NORMAL
  zh: TCP连接与UDP不同，这在Node的网络API设计中很明显。TCP连接表示为双向事件的流，因此向发送者回送消息很简单——一旦客户端连接，你就可以在任何时候使用`client.write`向它写入消息。另一方面，UDP是
    *无连接* 的——消息是在没有与客户端的活跃连接的情况下接收的。
- en: There are some protocol-level similarities that enable you to respond to messages
    from clients, however. Both TCP and UDP connections use source and destination
    ports. Given a suitable network setup, it’s possible to open a connection back
    to the client based on this information. In Node the `rinfo` object that’s included
    with every `message` event contains the relevant details. [Figure 7.5](#ch07fig05)
    shows how messages flow between two clients using this scheme.
  id: totrans-1850
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有一些协议级别的相似之处，使你能够对客户端的消息做出响应，但是。TCP和UDP连接都使用源端口和目的端口。给定一个合适的网络设置，根据这些信息打开回客户端的连接是可能的。在Node中，包含在每次`message`事件中的`rinfo`对象包含相关细节。[图7.5](#ch07fig05)显示了使用此方案在两个客户端之间消息的流动。
- en: Figure 7.5\. Even though UDP isn’t full-duplex, it’s possible to create connections
    in two directions given a port number at both sides.
  id: totrans-1851
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.5\. 尽管UDP不是全双工的，但给定两端的端口号，仍然可以在两个方向上创建连接。
- en: '![](07fig05.jpg)'
  id: totrans-1852
  prefs: []
  type: TYPE_IMG
  zh: '![图7.5](07fig05.jpg)'
- en: '[Listing 7.5](#ch07ex05) presents a client-server program that allows clients
    to connect to a central server over UDP and message each other. The server keeps
    details of each client in an array, so it can refer to each one uniquely. By storing
    the client’s address and port, you can even run multiple clients on the same machine—it’s
    safe to run this program several times on the same computer.'
  id: totrans-1853
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 7.5](#ch07ex05) 展示了一个客户端-服务器程序，允许客户端通过 UDP 连接到中心服务器并相互发送消息。服务器将每个客户端的详细信息存储在数组中，因此可以唯一地引用每个客户端。通过存储客户端的地址和端口，甚至可以在同一台机器上运行多个客户端——可以在同一台计算机上多次运行此程序。'
- en: Listing 7.5\. Sending messages back to clients
  id: totrans-1854
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.5\. 向客户端发送消息
- en: '![](ch07ex05-0.jpg)'
  id: totrans-1855
  prefs: []
  type: TYPE_IMG
  zh: '![ch07ex05-0.jpg](ch07ex05-0.jpg)'
- en: '![](ch07ex05-1.jpg)'
  id: totrans-1856
  prefs: []
  type: TYPE_IMG
  zh: '![ch07ex05-1.jpg](ch07ex05-1.jpg)'
- en: This example builds on [technique 48](#ch07lev2sec7)—you can run it in a similar
    way. Type `node udp-chat.js server` to start a server, and then `node udp-chat.js
    client` to connect a client. You should run more than one client for it to work;
    otherwise messages won’t get routed anywhere.
  id: totrans-1857
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例基于 [技术 48](#ch07lev2sec7)——您可以用类似的方式运行它。输入 `node udp-chat.js server` 以启动服务器，然后输入
    `node udp-chat.js client` 以连接客户端。您应该运行多个客户端才能使其工作；否则，消息将无法路由到任何地方。
- en: The `readline` module has been used to capture user input in a friendly manner
    ![](1.jpg). Like most of the other core modules you’ve seen, this one is event-based.
    It’ll emit the `line` event whenever a line of text is entered ![](3.jpg).
  id: totrans-1858
  prefs: []
  type: TYPE_NORMAL
  zh: '`readline` 模块已被用于以友好的方式捕获用户输入 ![1.jpg](1.jpg)。像您看到的许多其他核心模块一样，这个模块也是基于事件的。每当输入一行文本时，它都会触发
    `line` 事件 ![3.jpg](3.jpg)。'
- en: Before messages can be sent by the user, an initial `join` message is sent ![](2.jpg).
    This is just to let the server know it has connected—the server code uses it to
    store a unique reference to the client ![](8.jpg).
  id: totrans-1859
  prefs: []
  type: TYPE_NORMAL
  zh: 在用户可以发送消息之前，会发送一个初始的 `join` 消息 ![2.jpg](2.jpg)。这只是为了让服务器知道它已经连接——服务器代码使用它来存储对客户端的唯一引用
    ![8.jpg](8.jpg)。
- en: The `Client` constructor wraps `socket.send` inside a function called `sendData`
    ![](5.jpg). This is so messages can be easily sent whenever a line of text is
    typed. Also, when a client itself receives a message, it’ll print it to the console
    and create a new prompt ![](4.jpg)
  id: totrans-1860
  prefs: []
  type: TYPE_NORMAL
  zh: '`Client` 构造函数将 `socket.send` 包装在一个名为 `sendData` 的函数中 ![5.jpg](5.jpg)。这样，每当输入一行文本时，就可以轻松地发送消息。此外，当客户端本身收到消息时，它会在控制台打印出来并创建一个新的提示
    ![4.jpg](4.jpg)'
- en: Messages received by the server ![](6.jpg) are used to create a unique reference
    to the client by combining the port and remote address ![](7.jpg). We get all
    of this information from the `rinfo` object, and it’s safe to run multiple clients
    on the same machine because the port will be the client’s port rather than the
    port the server listens on (which doesn’t change). To understand how this is possible,
    recall that UDP headers include a source and destination port, much like TCP.
  id: totrans-1861
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器接收到的消息 ![6.jpg](6.jpg) 通过组合端口和远程地址 ![7.jpg](7.jpg) 来创建对客户端的唯一引用。我们从 `rinfo`
    对象中获取所有这些信息，并且可以在同一台机器上运行多个客户端，因为端口将是客户端的端口，而不是服务器监听的端口（这不会改变）。要了解这是如何可能的，请回想一下，UDP
    头部包括源端口和目的端口，就像 TCP 一样。
- en: Finally, whenever a message is seen that isn’t a control message ![](9.jpg),
    each client is iterated over and sent the message ![](10.jpg). The client that
    has sent the message won’t receive a copy. Because we’ve stored references to
    each `rinfo` object in the `clients` array, messages can be sent back to clients.
  id: totrans-1862
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，每当看到一条不是控制消息 ![9.jpg](9.jpg) 的消息时，就会遍历每个客户端并发送该消息 ![10.jpg](10.jpg)。发送消息的客户端不会收到副本。因为我们已经将每个
    `rinfo` 对象的引用存储在 `clients` 数组中，所以可以向客户端发送消息。
- en: 'Client-server networking is the basis of HTTP. Even though HTTP uses TCP connections,
    it’s slightly different from the type of protocols you’ve seen so far: it’s stateless.
    That means you need different patterns to model it. The next section has more
    details on how to make HTTP clients and servers.'
  id: totrans-1863
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端-服务器网络是 HTTP 的基础。尽管 HTTP 使用 TCP 连接，但它与您迄今为止看到的协议类型略有不同：它是无状态的。这意味着您需要不同的模式来模拟它。下一节将详细介绍如何创建
    HTTP 客户端和服务器。
- en: 7.4\. HTTP clients and servers
  id: totrans-1864
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.4\. HTTP 客户端和服务器
- en: Today most of us work with HTTP—whether we’re producing or consuming web services,
    or building web applications. The HTTP protocol is stateless and built on TCP,
    and Node’s HTTP module is similarly built on top of its TCP module.
  id: totrans-1865
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，我们大多数人都在使用 HTTP——无论是生产或消费网络服务，还是构建 Web 应用程序。HTTP 协议是无状态的，建立在 TCP 之上，Node
    的 HTTP 模块也是类似地建立在它的 TCP 模块之上。
- en: You could, of course, use your own protocol built with TCP. After all, HTTP
    is built on top of TCP. But due to the prevalence of web browsers and tools for
    working with web-based services, HTTP is a natural fit for many problems that
    involve communicating between remote systems.
  id: totrans-1866
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可以使用自己用 TCP 构建的协议。毕竟，HTTP 是建立在 TCP 之上的。但由于 Web 浏览器和用于处理基于 Web 服务的工具的普遍存在，HTTP
    对于涉及远程系统之间通信的许多问题来说是一个自然的选择。
- en: In the next section you’ll learn how to write a basic HTTP server using Node’s
    core modules.
  id: totrans-1867
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将学习如何使用 Node 的核心模块编写一个基本的 HTTP 服务器。
- en: Technique 50 HTTP servers
  id: totrans-1868
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 技巧 50：HTTP 服务器
- en: In this technique you’ll learn how to create HTTP servers with Node’s `http`
    module. Although this is more work than using a web framework built on top of
    Node, popular web frameworks generally use the same techniques internally, and
    the objects they expose are derived from Node’s standard classes. Understanding
    the underlying modules and classes is therefore useful for working extensively
    with HTTP.
  id: totrans-1869
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个技巧中，你将学习如何使用 Node 的 `http` 模块创建 HTTP 服务器。尽管这比使用建立在 Node 之上的 Web 框架要费时，但流行的
    Web 框架通常在内部使用相同的技巧，并且它们公开的对象是从 Node 的标准类派生出来的。因此，理解底层模块和类对于广泛使用 HTTP 是有用的。
- en: Problem
  id: totrans-1870
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: You want to run HTTP servers and test them.
  id: totrans-1871
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要运行 HTTP 服务器并对其进行测试。
- en: Solution
  id: totrans-1872
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use `http.createServer` and `http.createClient`.
  id: totrans-1873
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `http.createServer` 和 `http.createClient`。
- en: Discussion
  id: totrans-1874
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论
- en: The `http.createServer` method is a shortcut for creating a new `http.Server`
    object that descends from `net.Server`. The HTTP server is extended to handle
    various elements of the HTTP protocol—parsing headers, dealing with response codes,
    and setting up various events on sockets. The major focus in Node’s HTTP handling
    code is parsing; a C++ wrapper around Joyent’s own C parser library is used. This
    library can extract header fields and values, Content-Length, request method,
    response status code, and more.
  id: totrans-1875
  prefs: []
  type: TYPE_NORMAL
  zh: '`http.createServer` 方法是创建一个新的 `http.Server` 对象的快捷方式，该对象从 `net.Server` 派生出来。HTTP
    服务器被扩展以处理 HTTP 协议的各个元素——解析头部、处理响应代码，并在套接字上设置各种事件。Node 的 HTTP 处理代码的主要重点是解析；使用 Joyent
    自己的 C 解析库的 C++ 包装器。这个库可以提取头部字段和值、Content-Length、请求方法、响应状态代码等等。'
- en: The following listing shows a small “Hello World” web server that uses the `http`
    module.
  id: totrans-1876
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表显示了一个使用 `http` 模块的小型“Hello World” Web 服务器。
- en: Listing 7.6\. A simple HTTP server
  id: totrans-1877
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.6\. 一个简单的 HTTP 服务器
- en: '![](157fig01_alt.jpg)'
  id: totrans-1878
  prefs: []
  type: TYPE_IMG
  zh: '![157fig01_alt.jpg](157fig01_alt.jpg)'
- en: The `http` module contains both Node’s client and server HTTP classes ![](1.jpg).
    The `http.createServer` creates a new server object and returns it. The argument
    is a callback that receives `req` and `res` objects—request and response, respectively
    ![](2.jpg). You may be familiar with these objects if you’ve used higher-level
    Node web frameworks like Express and restify.
  id: totrans-1879
  prefs: []
  type: TYPE_NORMAL
  zh: '`http` 模块包含 Node 的客户端和服务器 HTTP 类 ![1.jpg](1.jpg)。`http.createServer` 创建一个新的服务器对象并返回它。参数是一个回调函数，该函数接收
    `req` 和 `res` 对象——分别是请求和响应 ![2.jpg](2.jpg)。如果你使用过像 Express 和 restify 这样的高级 Node
    Web 框架，你可能对这些对象很熟悉。'
- en: 'The interesting thing about the listener callback passed to `http.createServer`
    is that it behaves much like the listener passed to `net.createServer`. Indeed,
    the mechanism is the same—we’re creating TCP sockets, but layering HTTP on top.
    The main conceptual difference between the HTTP protocol and TCP socket communication
    is a question of state: HTTP is a stateless protocol. It’s perfectly acceptable
    and in fact typical to create and tear down TCP sockets *per request*. This partly
    explains why Node’s underlying HTTP implementation is low-level C++ and C: it
    needs to be fast and use as little memory as possible.'
  id: totrans-1880
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给 `http.createServer` 的监听器回调函数的有趣之处在于，它的行为与传递给 `net.createServer` 的监听器非常相似。实际上，机制是相同的——我们正在创建
    TCP 套接字，但在其上叠加 HTTP。HTTP 协议与 TCP 套接字通信的主要概念区别是状态问题：HTTP 是一种无状态协议。创建和销毁 TCP 套接字
    *按请求* 是完全可接受的，实际上也是典型的。这部分解释了为什么 Node 的底层 HTTP 实现是低级的 C++ 和 C：它需要快速且尽可能少地使用内存。
- en: 'In [listing 7.6](#ch07ex06), the listener runs for every request. In the TCP
    example from [technique 45](#ch07lev2sec4), the server kept a connection open
    as long as the client was connected. Because HTTP connections are just TCP sockets,
    we can use `res` and `req` like the sockets in [listing 7.6](#ch07ex06): `res.write`
    will write to the socket ![](4.jpg), and headers can be written back with `res.writeHead`
    ![](3.jpg), which is where the socket connection and HTTP APIs visibly diverge—the
    underlying socket will be closed as soon as the response has been written.'
  id: totrans-1881
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [列表7.6](#ch07ex06) 中，监听器为每个请求运行。在 [技术45](#ch07lev2sec4) 中的TCP示例中，服务器在客户端连接期间保持连接打开。因为HTTP连接只是TCP套接字，我们可以像
    [列表7.6](#ch07ex06) 中的套接字一样使用 `res` 和 `req`：`res.write` 将写入套接字 ![4.jpg](#)，并且可以通过
    `res.writeHead` 写入头部信息 ![3.jpg](#)，这是套接字连接和HTTP API明显分叉的地方——底层的套接字将在响应写入后立即关闭。
- en: After the server has been set up, we can set it to listen on a port with `server.listen`
    ![](5.jpg).
  id: totrans-1882
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器设置完成后，我们可以通过 `server.listen` 来设置它监听一个端口 ![5.jpg](#)。
- en: Now that we can create servers, let’s look at creating HTTP requests. The `http.request`
    method will create new connections ![](6.jpg), and accepts an `options` argument
    object and a callback that will be run when a connection is made. This means we
    still need to attach a `data` listener to the *response* passed to the callback
    to slurp down any sent data.
  id: totrans-1883
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经可以创建服务器了，让我们看看如何创建HTTP请求。`http.request` 方法将创建新的连接 ![6.jpg](#)，并接受一个 `options`
    参数对象和一个回调函数，当建立连接时将运行该回调函数。这意味着我们仍然需要将一个 `data` 监听器附加到回调函数传递的 *response* 上，以获取任何发送的数据。
- en: 'The `data` callback ensures the response from the server has the expected format:
    the body content and status code ![](7.jpg) are checked. The server is told to
    stop listening for connections when the last client has disconnected by calling
    `server.unref`, which means the script exits cleanly. This makes it easy to see
    if any errors were encountered.'
  id: totrans-1884
  prefs: []
  type: TYPE_NORMAL
  zh: '`data` 回调确保服务器响应具有预期的格式：检查正文内容和状态码 ![7.jpg](#)。通过调用 `server.unref` 来停止服务器监听连接，当最后一个客户端断开连接时，这意味着脚本会干净地退出。这使得查看是否遇到任何错误变得容易。'
- en: 'One small feature of the HTTP module is the `http.STATUS_CODES` object. This
    allows human-readable messages to be generated by looking up the integer status
    code: `http.STATUS_CODES[302]` will evaluate to `Moved Temporarily`.'
  id: totrans-1885
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP模块的一个小特性是 `http.STATUS_CODES` 对象。这允许通过查找整数状态码来生成可读的消息：`http.STATUS_CODES[302]`
    将评估为 `Moved Temporarily`。
- en: Now that you’ve seen how to create HTTP servers, in the next technique we’ll
    look at the role state plays in HTTP clients—despite HTTP being a stateless protocol—by
    implementing HTTP redirects.
  id: totrans-1886
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到了如何创建HTTP服务器，在下一个技术中，我们将探讨状态在HTTP客户端中的作用——尽管HTTP是无状态协议——通过实现HTTP重定向。
- en: Technique 51 Following redirects
  id: totrans-1887
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 技术51 跟随重定向
- en: Node’s `http` module provides a convenient API for handling HTTP requests. But
    it doesn’t follow redirects, and because redirects are so common on the web, it’s
    an important technique to master. You could use a popular third-party module that
    handles redirection, like the popular *request* module by Mikeal Rogers,^([[2](#ch07fn02)])
    but you’ll learn much more about Node by looking at how it can be implemented
    with the core modules.
  id: totrans-1888
  prefs: []
  type: TYPE_NORMAL
  zh: Node的 `http` 模块提供了一个方便的API来处理HTTP请求。但它不遵循重定向，由于重定向在网络上非常常见，因此掌握这项技术非常重要。你可以使用一个流行的第三方模块来处理重定向，比如Mikeal
    Rogers的流行 *request* 模块^([[2](#ch07fn02)))，但通过查看如何使用核心模块实现它，你会对Node有更深入的了解。
- en: ² [https://npmjs.org/package/request](https://npmjs.org/package/request)
  id: totrans-1889
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ² [https://npmjs.org/package/request](https://npmjs.org/package/request)
- en: In this technique we’ll look at how to use straightforward JavaScript to maintain
    state across several requests. This allows a redirect to be followed correctly
    without creating redirect loops or other issues.
  id: totrans-1890
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个技术中，我们将探讨如何使用简单的JavaScript在多个请求之间保持状态。这允许正确地跟随重定向，而不会创建重定向循环或其他问题。
- en: Problem
  id: totrans-1891
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: You want to download pages and follow redirects if necessary.
  id: totrans-1892
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要下载页面，并在必要时跟随重定向。
- en: Solution
  id: totrans-1893
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案
- en: Handling redirection is fairly straightforward once the basics of the protocol
    are understood. The HTTP standard defines status codes that denote when redirection
    has occurred, and it also states that clients should detect infinite redirect
    loops. To satisfy these requirements, we’ll use a simple prototype class to retain
    the state of each request, redirecting if needed and detecting redirect loops.
  id: totrans-1894
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦理解了协议的基本原理，处理重定向就相当直接。HTTP标准定义了表示发生重定向的状态码，并且它还指出客户端应检测无限重定向循环。为了满足这些要求，我们将使用一个简单的原型类来保留每个请求的状态，在需要时进行重定向，并检测重定向循环。
- en: Discussion
  id: totrans-1895
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论
- en: In this example we’ll use Node’s core `http` module to make a `GET` request
    to a URL that we know will generate a redirection. To determine if a given response
    is a redirect, we need to check whether the returned status code begins with a
    3\. All of the status codes in the 3xx family of responses indicate that a redirect
    of some kind has occurred.
  id: totrans-1896
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将使用Node的核心`http`模块向一个我们知道将生成重定向的URL发起`GET`请求。为了确定给定的响应是否为重定向，我们需要检查返回的状态码是否以3开头。3xx系列的所有状态码都表示发生了某种类型的重定向。
- en: 'According to the specification, this is the full set of status codes that we
    need to deal with:'
  id: totrans-1897
  prefs: []
  type: TYPE_NORMAL
  zh: 根据规范，这是我们需要处理的所有状态码的完整集合：
- en: '***300*** —Multiple choices'
  id: totrans-1898
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***300*** —多种选择'
- en: '***301*** —Moved permanently'
  id: totrans-1899
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***301*** —永久移动'
- en: '***302*** —Found'
  id: totrans-1900
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***302*** —找到'
- en: '***303*** —See other'
  id: totrans-1901
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***303*** —另见'
- en: '***304*** —Not modified'
  id: totrans-1902
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***304*** —未修改'
- en: '***305*** —See proxy'
  id: totrans-1903
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***305*** —另见代理'
- en: '***307*** —Temporary redirect'
  id: totrans-1904
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***307*** —临时重定向'
- en: 'Exactly how each of these status codes is handled depends on the application.
    For example, it might be extremely important for a search engine to identify responses
    that return a 301, because it means the search engine’s list of URLs should be
    permanently updated. For this technique we simply need to follow redirects, which
    means a single statement is sufficient to check whether the request is being redirected:
    `if (response.statusCode >= 300 && response.statusCode < 400)`.'
  id: totrans-1905
  prefs: []
  type: TYPE_NORMAL
  zh: 每个这些状态码如何处理取决于应用程序。例如，对于搜索引擎来说，识别返回301状态码的响应可能非常重要，因为这表示搜索引擎的URL列表应该永久更新。对于这种技术，我们只需要跟随重定向，这意味着只需要一个语句就足以检查请求是否被重定向：`if
    (response.statusCode >= 300 && response.statusCode < 400)`。
- en: Testing for redirection loops is more involved. A request can no longer exist
    in isolation—we need to track the state of several requests. The easiest way to
    model this is by using a class that includes an instance variable for counting
    how many redirects have occurred. When the counter reaches a limit, an error is
    raised. [Figure 7.6](#ch07fig06) shows how HTTP redirects are handled.
  id: totrans-1906
  prefs: []
  type: TYPE_NORMAL
  zh: 测试重定向循环更为复杂。请求不能再独立存在——我们需要跟踪多个请求的状态。最容易的方法是使用一个包含实例变量以计算发生重定向次数的类。当计数器达到限制时，将引发错误。[图7.6](#ch07fig06)显示了如何处理HTTP重定向。
- en: Figure 7.6\. Redirection is cyclical, and requests will be made until a 200
    status is encountered.
  id: totrans-1907
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.6\. 重定向是循环的，请求将一直进行，直到遇到200状态码。
- en: '![](07fig06_alt.jpg)'
  id: totrans-1908
  prefs: []
  type: TYPE_IMG
  zh: '![](07fig06_alt.jpg)'
- en: Before writing any code, it’s important to consider what kind of API we need.
    Since we’ve already determined a “class” should be used to manage state, then
    users of our module will need to instantiate an instance of this class. Node’s
    `http` module is asynchronous, and our code should be as well. That means that
    to get a result back, we’ll have to pass a callback to a method.
  id: totrans-1909
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写任何代码之前，考虑我们需要什么样的API非常重要。由于我们已经确定应该使用“类”来管理状态，那么我们模块的用户将需要实例化这个类的实例。Node的`http`模块是异步的，我们的代码也应该如此。这意味着为了获取结果，我们必须将一个回调传递给一个方法。
- en: The signature for this callback should use the same format as Node’s core modules,
    where an error variable is the first parameter. Designing the API in this way
    has the advantage of making error handling straightforward. Making an HTTP request
    can result in several errors, so it’s important to handle them correctly.
  id: totrans-1910
  prefs: []
  type: TYPE_NORMAL
  zh: 这个回调的签名应该使用与Node核心模块相同的格式，其中错误变量是第一个参数。以这种方式设计API的优势在于使错误处理变得简单直接。发起HTTP请求可能会导致多个错误，因此正确处理它们非常重要。
- en: The following listing puts all of this together to successfully follow redirects
  id: totrans-1911
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表将所有这些内容组合起来以成功跟随重定向
- en: Listing 7.7\. Making an HTTP `GET` request that follows redirects
  id: totrans-1912
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.7\. 发起一个跟随重定向的HTTP `GET` 请求
- en: '![](ch07ex07-0.jpg)'
  id: totrans-1913
  prefs: []
  type: TYPE_IMG
  zh: '![](ch07ex07-0.jpg)'
- en: '![](ch07ex07-1.jpg)'
  id: totrans-1914
  prefs: []
  type: TYPE_IMG
  zh: '![](ch07ex07-1.jpg)'
- en: 'Running this code will display the last-fetched URL, and the number of times
    the request was redirected. Try it with a few URLs to see what happens: even nonexistent
    URLs that result in DNS errors should cause error information to be printed to
    `stderr`.'
  id: totrans-1915
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码将显示最后获取的URL和请求被重定向的次数。尝试用几个URL来查看会发生什么：即使导致DNS错误的非存在URL也应该导致错误信息打印到`stderr`。
- en: After loading the necessary modules ![](1.jpg), the `Request` ![](2.jpg) constructor
    function is used to create an object that models the lifetime of a request. Using
    a class in this way keeps implementation details neatly encapsulated from the
    user. Meanwhile, the `Request.prototype.get` method does most of the work. It
    sets up a standard HTTP request, or HTTPS if necessary, and then calls itself
    recursively whenever a redirect is encountered. Note that the URL has to be parsed
    ![](3.jpg) into an object that we use to create the `options` object that is compatible
    with Node’s `http` module.
  id: totrans-1916
  prefs: []
  type: TYPE_NORMAL
  zh: 在加载必要的模块![1.jpg](1.jpg)后，使用`Request`![2.jpg](2.jpg)构造函数创建一个表示请求生命周期的对象。以这种方式使用类可以将实现细节整洁地封装起来，不让用户看到。同时，`Request.prototype.get`方法做了大部分工作。它设置了一个标准的HTTP请求，或者在需要时使用HTTPS，然后每当遇到重定向时都会递归地调用自身。请注意，URL必须被解析![3.jpg](3.jpg)成一个对象，我们用它来创建与Node的`http`模块兼容的`options`对象。
- en: The request protocol (HTTP or HTTPS) is checked to ensure we use the right method
    from Node’s `http` or `https` module. Some servers are configured to always redirect
    HTTP traffic to HTTPS. Without checking for the protocol, this method would repeatedly
    fetch the original HTTP URL until `maxRedirects` is hit—this is a trivial mistake
    that’s easily avoided.
  id: totrans-1917
  prefs: []
  type: TYPE_NORMAL
  zh: 检查请求协议（HTTP或HTTPS），以确保我们使用Node的`http`或`https`模块中的正确方法。一些服务器被配置为始终将HTTP流量重定向到HTTPS。如果不检查协议，这个方法会反复获取原始HTTP
    URL，直到达到`maxRedirects`——这是一个微不足道的错误，但很容易避免。
- en: Once the response has been received, the `statusCode` is checked ![](4.jpg).
    The number of redirects is incremented as long as `maxRedirects` hasn’t been reached
    ![](5.jpg). This process is repeated until there’s no longer a status in the 300
    range, or too many redirects have been encountered.
  id: totrans-1918
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦收到响应，就会检查`statusCode`![4.jpg](4.jpg)。只要没有达到`maxRedirects`，就会增加重定向次数![5.jpg](5.jpg)。这个过程会一直重复，直到不再有300范围内的状态，或者遇到的重定向太多。
- en: When the final request has finished (or the first if there were no redirects),
    the user-supplied `callback` function is run. The standard Node API signature
    of `error, result` has been used here to stay consistent with Node’s core modules.
    An error is generated when `maxRedirects` is reached, or when creating the HTTP
    request by listening for an `error` event.
  id: totrans-1919
  prefs: []
  type: TYPE_NORMAL
  zh: 当最终请求完成（或者如果没有重定向，则是第一个请求）时，将运行用户提供的`callback`函数。这里使用了标准的Node API签名`error, result`，以保持与Node的核心模块的一致性。当达到`maxRedirects`或通过监听`error`事件创建HTTP请求时，将生成错误。
- en: The user-supplied callback runs after the last request has finished, allowing
    the callback to access the requested resource. This is handled by running the
    callback after the `end` event for the last request has been triggered, and by
    binding the event handler to the current `Request` instance ![](6.jpg). Binding
    the event handler means it’ll have access to any useful instance variables that
    the user might need—including errors that are stored in `this.error`.
  id: totrans-1920
  prefs: []
  type: TYPE_NORMAL
  zh: 用户提供的回调函数在最后一个请求完成后运行，允许回调函数访问请求的资源。这是通过在最后一个请求的`end`事件触发后运行回调函数，并将事件处理程序绑定到当前的`Request`实例![6.jpg](6.jpg)来处理的。绑定事件处理程序意味着它将能够访问用户可能需要的任何有用的实例变量——包括存储在`this.error`中的错误。
- en: Lastly, we create an instance of `Request` ![](7.jpg) to try out the class.
    You can use it with other URLs if you like.
  id: totrans-1921
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们创建一个`Request`实例![7.jpg](7.jpg)来尝试这个类。如果你愿意，可以用它来访问其他URL。
- en: 'This technique illustrates an important point: state is important, even though
    HTTP is technically a stateless protocol. Some misconfigured web applications
    and servers can create redirect loops, which would cause a client to fetch URLs
    forever until it’s forcibly stopped.'
  id: totrans-1922
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术说明了一个重要的观点：状态很重要，尽管HTTP在技术上是一个无状态协议。一些配置错误的Web应用程序和服务器可以创建重定向循环，这会导致客户端无限期地获取URL，直到被强制停止。
- en: Though [listing 7.7](#ch07ex07) showcases some of Node’s HTTP- and URL-handling
    features, it isn’t a complete solution. For a more advanced HTTP API, take a look
    at Request by Mikeal Rogers ([https://github.com/mikeal/request](https://github.com/mikeal/request)),
    a widely used simplified Node HTTP API.
  id: totrans-1923
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 [列表 7.7](#ch07ex07) 展示了 Node 的 HTTP 和 URL 处理的一些功能，但它并不是一个完整的解决方案。对于更高级的 HTTP
    API，请查看 Mikeal Rogers 的 Request ([https://github.com/mikeal/request](https://github.com/mikeal/request))，这是一个广泛使用的简化
    Node HTTP API。
- en: In the next technique we’ll dissect a simple HTTP proxy. This expands on the
    client and server techniques discussed here, and could be expanded to create numerous
    useful applications.
  id: totrans-1924
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个技巧中，我们将剖析一个简单的 HTTP 代理。这扩展了在此处讨论的客户端和服务器技巧，并可以扩展以创建许多有用的应用程序。
- en: Technique 52 HTTP proxies
  id: totrans-1925
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 技巧 52 HTTP 代理
- en: HTTP proxies are used more often than you might expect—ISPs use transparent
    proxies to make networks more efficient, corporate systems administrators use
    caching proxies to reduce bandwidth, and web application DevOps use them to improve
    the performance of their apps. This technique only scratches the surface of proxies—it
    catches HTTP requests and responses, and then mirrors them to their intended destinations.
  id: totrans-1926
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 代理的使用频率比你想象的要高——ISP 使用透明代理来提高网络效率，企业系统管理员使用缓存代理来减少带宽，Web 应用程序 DevOps 使用它们来提高其应用程序的性能。这个技巧只是触及了代理的表面——它捕获
    HTTP 请求和响应，然后将它们镜像到目标位置。
- en: Problem
  id: totrans-1927
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: You want to capture and retransmit HTTP requests.
  id: totrans-1928
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要捕获并重新传输 HTTP 请求。
- en: Solution
  id: totrans-1929
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use Node’s built-in HTTP module to act as a simple HTTP proxy.
  id: totrans-1930
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Node 内置的 HTTP 模块来充当简单的 HTTP 代理。
- en: Discussion
  id: totrans-1931
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论
- en: 'A proxy server offers a level of redirection, which facilitates a variety of
    useful applications: caching, logging, and security-related software. This technique
    explores how to use the core `http` module to create HTTP proxies. Fundamentally
    all that’s required is an HTTP server that catches requests, and then an HTTP
    client to clone them.'
  id: totrans-1932
  prefs: []
  type: TYPE_NORMAL
  zh: 代理服务器提供了一定程度的重定向，这有助于各种有用的应用程序：缓存、日志和安全相关软件。这个技巧探讨了如何使用核心 `http` 模块来创建 HTTP
    代理。从根本上说，所需的是一个捕获请求的 HTTP 服务器，然后是一个克隆它们的 HTTP 客户端。
- en: The `http.createServer` and `http.request` methods can catch and retransmit
    requests. We’ll also need to interpret the original request so we can safely copy
    it—the `url` core module has an ideal URL-parsing method that can help do this.
  id: totrans-1933
  prefs: []
  type: TYPE_NORMAL
  zh: '`http.createServer` 和 `http.request` 方法可以捕获并重新传输请求。我们还需要解释原始请求，以便我们可以安全地复制它——`url`
    核心模块有一个理想的 URL 解析方法，可以帮助我们做到这一点。'
- en: The next listing shows how simple it is to create a working proxy in Node.
  id: totrans-1934
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表展示了在 Node 中创建工作代理是多么简单。
- en: Listing 7.8\. Using the `http` module to create a proxy
  id: totrans-1935
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.8\. 使用 `http` 模块创建代理
- en: '![](ch07ex08-0.jpg)'
  id: totrans-1936
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.7](ch07ex08-0.jpg)'
- en: '![](ch07ex08-1.jpg)'
  id: totrans-1937
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.8](ch07ex08-1.jpg)'
- en: To use this example, your computer will need a bit of configuration. Find your
    system’s internet options, and then look for HTTP proxies. From there you should
    be able to enter `localhost:8080` as the proxy. Alternatively, add the proxy in
    a browser’s settings if possible. Some browsers don’t support this; Google Chrome
    will open the system proxy dialog.
  id: totrans-1938
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用此示例，你的电脑需要一些配置。找到你的系统互联网选项，然后查找 HTTP 代理。从那里你应该能够将 `localhost:8080` 作为代理输入。或者，如果可能的话，在浏览器的设置中添加代理。一些浏览器不支持此操作；Google
    Chrome 将打开系统代理对话框。
- en: '[Figure 7.7](#ch07fig07) shows how to configure the proxy on a Mac. Make sure
    you click OK and then Apply in the main *Network* dialog to save the setting.
    And remember to disable the proxy once you’re done!'
  id: totrans-1939
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7.7](#ch07fig07) 展示了如何在 Mac 上配置代理。确保你点击“确定”，然后在主“网络”对话框中应用以保存设置。并且记得完成操作后禁用代理！'
- en: Figure 7.7\. To use the Node proxy we’ve created, set `localhost:8080` as the
    Web Proxy Server.
  id: totrans-1940
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.7\. 要使用我们创建的 Node 代理，将 `localhost:8080` 设置为 Web 代理服务器。
- en: '![](07fig07_alt.jpg)'
  id: totrans-1941
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.7](07fig07_alt.jpg)'
- en: Once your system is set up to use the proxy, start the Node process up with
    `node listings/network/proxy.js` in a shell. Now when you visit web pages, you
    should see the successive requests and responses logged to the console.
  id: totrans-1942
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你的系统配置好使用代理，就可以在壳中使用 `node listings/network/proxy.js` 启动 Node 进程。现在当你访问网页时，你应该能看到连续的请求和响应被记录到控制台。
- en: This example works by first creating a server ![](1.jpg) using the `http` module.
    The callback will be triggered when a browser makes a request. We’ve used `url.parse`
    (`url` is another core module) to separate out the URL’s various parts so they
    can be passed as arguments to `http.request`. The parsed URL object is compatible
    with the arguments that `http.request` expects, so this is convenient ![](2.jpg).
  id: totrans-1943
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例通过首先使用`http`模块创建一个服务器 ![](1.jpg) 来工作。当浏览器发起请求时，将触发回调。我们使用了`url.parse`（`url`是另一个核心模块）来分离URL的各个部分，以便可以将它们作为参数传递给`http.request`。解析后的URL对象与`http.request`期望的参数兼容，因此这很方便
    ![](2.jpg)。
- en: From within the request’s callback, we can subscribe to events that need to
    be repeated back to the browser. The `data` event is useful because it allows
    us to capture the response from the server and pass it back to the client with
    `res.write` ![](3.jpg). We also respond to the end of the server’s connection
    by closing the connection to the browser ![](4.jpg). The status code is also written
    back to the client based on the server’s response ![](5.jpg).
  id: totrans-1944
  prefs: []
  type: TYPE_NORMAL
  zh: 在请求的回调中，我们可以订阅需要重复回传给浏览器的事件。`data`事件很有用，因为它允许我们捕获来自服务器的响应，并通过`res.write`将其传递回客户端
    ![](3.jpg)。我们还通过关闭与浏览器的连接来响应服务器连接的结束 ![](4.jpg)。状态码也是基于服务器的响应写回客户端的 ![](5.jpg)。
- en: Any data sent by the client is also proxied to the remote server by subscribing
    to the browser’s `data` events ![](6.jpg). Similarly, the browser’s original request
    is watched for an `end` event so it can be reflected back to the proxied request
    ![](7.jpg).
  id: totrans-1945
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端发送的任何数据也会通过订阅浏览器的`data`事件代理到远程服务器 ![](6.jpg)。同样，浏览器原始请求也会监视`end`事件，以便将其反映回代理请求
    ![](7.jpg)。
- en: Finally, the HTTP server used as the proxy is set up to listen on port 8080
    ![](8.jpg).
  id: totrans-1946
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，用作代理的HTTP服务器被设置为监听8080端口 ![](8.jpg)。
- en: This example creates a special server that sits between the browser and the
    server the browser wants to talk to. It could be extended to do lots of interesting
    things. For example, you could cache image files and compress them based on the
    remote client, sending mobile browsers heavily compressed images. You could even
    strip out certain content based on rules; some ad-blocking and parental filters
    work this way.
  id: totrans-1947
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例创建了一个特殊的服务器，它位于浏览器和浏览器想要与之通信的服务器之间。它可以扩展来做许多有趣的事情。例如，你可以根据远程客户端缓存和压缩图像文件，向移动浏览器发送高度压缩的图像。你甚至可以根据规则删除某些内容；一些广告拦截器和家长控制过滤器就是这样工作的。
- en: We’ve been using the DNS so far without really thinking about it too much. DNS
    uses TCP *and* UDP for its request/response-based protocol. Fortunately, Node
    hides this complexity for us with a slick asynchronous DNS module. The next section
    demonstrates how to make DNS requests using Node’s `dns` module.
  id: totrans-1948
  prefs: []
  type: TYPE_NORMAL
  zh: 我们到目前为止一直在使用DNS，并没有真正过多地考虑它。DNS使用TCP和UDP来支持其基于请求/响应的协议。幸运的是，Node通过一个简洁的异步DNS模块为我们隐藏了这种复杂性。下一节将演示如何使用Node的`dns`模块发起DNS请求。
- en: 7.5\. Making DNS requests
  id: totrans-1949
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.5\. 发起DNS请求
- en: Node’s DNS module lives outside of the `net` module, in `dns`. When the `http`
    or `net` modules are used to connect to remote servers, Node will look up IP addresses
    using `dns.lookup` internally.
  id: totrans-1950
  prefs: []
  type: TYPE_NORMAL
  zh: Node的DNS模块位于`net`模块之外，在`dns`中。当使用`http`或`net`模块连接到远程服务器时，Node会使用`dns.lookup`内部查找IP地址。
- en: Technique 53 Making a DNS request
  id: totrans-1951
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 技巧53 发起DNS请求
- en: Node has multiple methods for making DNS requests. In this technique you’ll
    learn how and why you should use each to resolve a domain name to an IP address.
  id: totrans-1952
  prefs: []
  type: TYPE_NORMAL
  zh: Node有多种方法来发起DNS请求。在这个技术中，你将学习如何以及为什么应该使用每种方法将域名解析为IP地址。
- en: When you query a DNS record, the results may include answers for different record
    types. The DNS is a distributed database, so it isn’t used purely for resolving
    IP addresses—some records like `TXT` are used to build features off the back of
    the DNS itself.
  id: totrans-1953
  prefs: []
  type: TYPE_NORMAL
  zh: 当你查询DNS记录时，结果可能包括不同记录类型的答案。DNS是一个分布式数据库，所以它不仅仅用于解析IP地址——一些记录，如`TXT`，用于在DNS本身的基础上构建功能。
- en: '[Table 7.2](#ch07table02) includes a list of each type along with the associated
    `dns` module method.'
  id: totrans-1954
  prefs: []
  type: TYPE_NORMAL
  zh: '[表7.2](#ch07table02) 包含了每种类型及其相关的`dns`模块方法的列表。'
- en: Table 7.2\. DNS record types
  id: totrans-1955
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表7.2\. DNS记录类型
- en: '| Type | Method | Description |'
  id: totrans-1956
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 方法 | 描述 |'
- en: '| --- | --- | --- |'
  id: totrans-1957
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| A | dns.resolve | An A record stores the IP address. It can have an associated
    time-to-live (TTL) field to indicate how often the record should be updated. |'
  id: totrans-1958
  prefs: []
  type: TYPE_TB
  zh: '| A | dns.resolve | A记录存储IP地址。它可以有一个关联的生存时间（TTL）字段，以指示记录应该更新的频率。|'
- en: '| TXT | dns.resolveTxt | Text values that can be used by other services for
    additional features built on top of DNS. |'
  id: totrans-1959
  prefs: []
  type: TYPE_TB
  zh: '| TXT | dns.resolveTxt | 可以由其他服务用于在 DNS 之上构建的附加功能的文本值。|'
- en: '| SRV | dns.resolveSrv | Service records define “location” data for a service;
    this usually includes the port number and hostname. |'
  id: totrans-1960
  prefs: []
  type: TYPE_TB
  zh: '| SRV | dns.resolveSrv | 服务记录定义了服务的“位置”数据；这通常包括端口号和主机名。|'
- en: '| NS | dns.resolveNs | Used for name servers themselves. |'
  id: totrans-1961
  prefs: []
  type: TYPE_TB
  zh: '| NS | dns.resolveNs | 用于名称服务器本身。|'
- en: '| CNAME | dns.resolveCname | Canonical name records. These are set to domain
    names rather than IP addresses. |'
  id: totrans-1962
  prefs: []
  type: TYPE_TB
  zh: '| CNAME | dns.resolveCname | 正常名称记录。这些设置为域名而不是 IP 地址。|'
- en: Problem
  id: totrans-1963
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: You want to look up a single or multiple domain names quickly.
  id: totrans-1964
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望快速查找单个或多个域名。
- en: Solution
  id: totrans-1965
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案
- en: The `dns.lookup` method can be used to look up either IPv4 or IPv6 addresses.
    When looking up multiple addresses, it can be faster to use `dns.resolve` instead.
  id: totrans-1966
  prefs: []
  type: TYPE_NORMAL
  zh: '`dns.lookup` 方法可以用来查找 IPv4 或 IPv6 地址。当查找多个地址时，使用 `dns.resolve` 可能更快。'
- en: Discussion
  id: totrans-1967
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论
- en: 'According to Node’s documentation, `dns.lookup` is backed by a thread pool,
    whereas `dns.resolve` uses the `c-ares` library, which is faster. The `dns.lookup`
    API is a little friendlier—it uses `getaddrinfo`, which is more consistent with
    the other programs on your system. Indeed, the `Socket.prototype.connect` method,
    and any of Node’s core modules that inherit from the objects in the `net` module,
    all use `dns.lookup` for consistency:'
  id: totrans-1968
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 Node 的文档，`dns.lookup` 是由线程池支持的，而 `dns.resolve` 使用的是 `c-ares` 库，这要快一些。`dns.lookup`
    API 稍微友好一些——它使用 `getaddrinfo`，这与系统上的其他程序更一致。确实，`Socket.prototype.connect` 方法，以及任何从
    `net` 模块中的对象继承的 Node 的核心模块，都使用 `dns.lookup` 以保持一致性：
- en: '![](166fig01_alt.jpg)'
  id: totrans-1969
  prefs: []
  type: TYPE_IMG
  zh: '![](166fig01_alt.jpg)'
- en: This example loads the `dns` module ![](1.jpg), and then looks up the IP address
    using `dns.lookup` ![](2.jpg). The API is asynchronous, so we have to pass a callback
    to receive the IP address and any errors that were raised when looking up the
    address. Note that the domain name has to be provided, rather than a URL—don’t
    include `http://` here.
  id: totrans-1970
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子加载了 `dns` 模块 ![](1.jpg)，然后使用 `dns.lookup` 查找 IP 地址 ![](2.jpg)。API 是异步的，因此我们必须传递一个回调来接收
    IP 地址以及查找地址时引发的任何错误。请注意，必须提供域名，而不是 URL——这里不要包含 `http://`。
- en: 'If everything runs correctly, then you should see `68.180.151.75` printed as
    the IP address. Conversely, if the previous example is run when you’re offline,
    then a rather interesting error should be printed instead:'
  id: totrans-1971
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切运行正确，你应该会看到 `68.180.151.75` 作为 IP 地址打印出来。相反，如果你在离线时运行前面的示例，那么应该会打印出一个相当有趣的错误：
- en: '![](166fig02.jpg)'
  id: totrans-1972
  prefs: []
  type: TYPE_IMG
  zh: '![](166fig02.jpg)'
- en: 'The error object includes a standard error code ![](1.jpg) alongside the system
    call that raised the error ![](2.jpg). You can use the error code in your programs
    to detect when this kind of error was raised and handle it appropriately. The
    `syscall` property, meanwhile, is useful to us as programmers: it shows that the
    error was generated by a service outside of our Node code that is provided by
    the operating system.'
  id: totrans-1973
  prefs: []
  type: TYPE_NORMAL
  zh: 错误对象包括一个标准错误代码 ![](1.jpg) 以及引发错误的系统调用 ![](2.jpg)。你可以在程序中使用错误代码来检测这种错误何时被引发，并适当地处理它。同时，`syscall`
    属性对我们程序员来说很有用：它表明错误是由操作系统提供的、位于我们 Node 代码之外的服务生成的。
- en: 'Now compare this to the version that uses `dns.resolve`:'
  id: totrans-1974
  prefs: []
  type: TYPE_NORMAL
  zh: 现在比较一下使用 `dns.resolve` 的版本：
- en: '![](166fig03_alt.jpg)'
  id: totrans-1975
  prefs: []
  type: TYPE_IMG
  zh: '![](166fig03_alt.jpg)'
- en: 'The API looks similar to the previous example, apart from `dns.resolve` ![](1.jpg).
    You’ll still see an error object that includes `ECONNREFUSED` if the DNS server
    couldn’t be reached, but this time the result is different: we receive an array
    of addresses instead of a single result. In this example you should see `[ ''68.180.151.75''
    ]`, but some servers may return more than one address.'
  id: totrans-1976
  prefs: []
  type: TYPE_NORMAL
  zh: API 看起来与前面的示例相似，除了 `dns.resolve` ![](1.jpg)。你仍然会看到一个包含 `ECONNREFUSED` 的错误对象，如果
    DNS 服务器无法到达，但这次结果不同：我们收到一个地址数组而不是单个结果。在这个例子中，你应该看到 `[ '68.180.151.75' ]`，但一些服务器可能返回多个地址。
- en: Node’s `dns` module is flexible, friendly, and fast. It can scale up well from
    infrequent single requests to making batches of requests.
  id: totrans-1977
  prefs: []
  type: TYPE_NORMAL
  zh: Node 的 `dns` 模块灵活、友好且快速。它可以从不频繁的单个请求扩展到批量请求。
- en: 'The last part of Node’s networking suite left to look at is perhaps the hardest
    to learn, yet paradoxically the most important to get right: encryption. The next
    section introduces SSL/TLS with the `tls` and `https` modules.'
  id: totrans-1978
  prefs: []
  type: TYPE_NORMAL
  zh: Node 网络套件的最后一部分需要查看的是可能最难学习，但矛盾的是，正确实现这一点是最重要的：加密。下一节介绍了使用 `tls` 和 `https` 模块的
    SSL/TLS。
- en: 7.6\. Encryption
  id: totrans-1979
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.6. 加密
- en: Node’s encryption module, `tls`, uses OpenSSL Transport Layer Security/Secure
    Socket Layer (TLS/SSL). This is a public key system, where each client and server
    both have a private key. The server makes its public key available so clients
    can encrypt subsequent communications in a way that only that server can decrypt
    again.
  id: totrans-1980
  prefs: []
  type: TYPE_NORMAL
  zh: Node的加密模块`tls`使用OpenSSL传输层安全性/安全套接字层（TLS/SSL）。这是一个公钥系统，其中每个客户端和服务器都有自己的私钥。服务器将其公钥公开，以便客户端可以以只有该服务器才能解密的方式加密后续通信。
- en: The `tls` module is used as the basis for the `https` module—this allows HTTP
    servers and clients to communicate over TLS/SSL. Unfortunately, TLS/SSL is a world
    of potential pitfalls. Node potentially supports different cyphers based on what
    version of OpenSSL it has been linked against. You can specify what cyphers you
    want to use when creating servers with `tls.createServer`, but we recommend using
    the defaults unless you have specific expertise in this area.
  id: totrans-1981
  prefs: []
  type: TYPE_NORMAL
  zh: '`tls`模块被用作`https`模块的基础——这允许HTTP服务器和客户端通过TLS/SSL进行通信。不幸的是，TLS/SSL是一个充满潜在陷阱的世界。Node根据链接的OpenSSL版本可能支持不同的加密算法。你可以在使用`tls.createServer`创建服务器时指定你想要使用的加密算法，但我们建议除非你有这方面的专业知识，否则使用默认设置。'
- en: In the following technique you’ll learn how to start a TCP server that uses
    SSL and a self-signed certificate. After that, we end the chapter with a technique
    that shows how encrypting web server communication works in Node.
  id: totrans-1982
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的技术中，你将学习如何启动一个使用SSL和自签名证书的TCP服务器。之后，我们以一个技术结束本章，展示在Node中加密Web服务器通信是如何工作的。
- en: Technique 54 A TCP server that uses encryption
  id: totrans-1983
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 技术编号54：使用加密的TCP服务器
- en: TLS can be used to encrypt servers made with `net.createServer`. This technique
    demonstrates how to do this by first creating the necessary certificates and then
    starting a client and server.
  id: totrans-1984
  prefs: []
  type: TYPE_NORMAL
  zh: TLS可以用来加密使用`net.createServer`创建的服务器。这个技术演示了如何通过首先创建必要的证书，然后启动客户端和服务器来实现这一点。
- en: Problem
  id: totrans-1985
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: You want to encrypt communication sent and received over a TCP connection.
  id: totrans-1986
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要加密通过TCP连接发送和接收的通信。
- en: Solution
  id: totrans-1987
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use the `tls` module to start a client and server. Set up the required certificate
    files using OpenSSL.
  id: totrans-1988
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`tls`模块启动客户端和服务器。使用OpenSSL设置所需的证书文件。
- en: Discussion
  id: totrans-1989
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论
- en: 'The main thing to master when working with encryption, whether it’s web servers,
    mail servers, or any TCP-based protocol, is how to properly set up the key and
    certificate files. Public key cryptography is dependent on public-private key
    pairs—a pair is required for both clients and servers. But an additional file
    is needed: the public key of the Certificate Authority (CA).'
  id: totrans-1990
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理加密时，无论是Web服务器、邮件服务器还是任何基于TCP的协议，掌握的主要事情是如何正确设置密钥和证书文件。公钥加密依赖于公私钥对——客户端和服务器都需要一对。但还需要一个额外的文件：证书颁发机构（CA）的公钥。
- en: Our goal in this technique is to create a TLS client and server that both report
    `authorized` after the TLS handshake. This state is reported when *both* parties
    have verified each other’s identity. When working with web server certificates,
    your CA will be the well-known organizations that commercially distribute certificates.
    But for the purposes of testing, you can become your own CA and sign certificates.
    This is also useful for secure communication between your own systems that don’t
    need publicly verifiable certificates.
  id: totrans-1991
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个技术中，我们的目标是创建一个TLS客户端和服务器，在TLS握手后都报告`authorized`。当*双方*都验证了对方的身份时，会报告这种状态。当与Web服务器证书一起工作时，你的CA将是那些商业上分发证书的知名组织。但为了测试目的，你可以成为自己的CA并签名证书。这对于在不需要公开可验证证书的自己的系统之间进行安全通信也是很有用的。
- en: That means before you can run any Node examples, you’ll need certificates. The
    OpenSSL command-line tools are required for this. If you don’t have them, you
    should be able to install them with your operating system’s package manager, or
    by visiting [www.openssl.org](http://www.openssl.org).
  id: totrans-1992
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着在你可以运行任何Node示例之前，你需要证书。这需要OpenSSL命令行工具。如果你没有它们，你应该能够通过操作系统的包管理器或通过访问[www.openssl.org](http://www.openssl.org)来安装它们。
- en: 'The `openssl` tool takes a command as the first argument, and then options
    as subsequent arguments. For example, `openssl req` is used for X.509 Certificate
    Signing Request (CSR) management. To make a certificate signed by an authority
    you control, you’ll need to issue the following commands:'
  id: totrans-1993
  prefs: []
  type: TYPE_NORMAL
  zh: '`openssl`工具将命令作为第一个参数，然后是后续的选项。例如，`openssl req`用于X.509证书签名请求（CSR）管理。要颁发由你控制的机构签名的证书，你需要执行以下命令：'
- en: '***`genrsa`*** —Generate an RSA certificate; this is our private key.'
  id: totrans-1994
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***`genrsa`*** —生成 RSA 证书；这是我们私钥。'
- en: '***`req`*** —Create a CSR.'
  id: totrans-1995
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***`req`*** —创建 CSR。'
- en: '***`x509`*** —Sign the private key with the CSR to produce a public key.'
  id: totrans-1996
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***`x509`*** —使用 CSR 签名私钥以生成公钥。'
- en: 'When the process is broken down like this, it’s fairly easy to understand:
    certificates require an authority and must be signed, and we need a public and
    private key. The process is similar when creating a public and private key signed
    against a commercial certificate authority, which you’ll do if you want to buy
    certificates to use with public web servers.'
  id: totrans-1997
  prefs: []
  type: TYPE_NORMAL
  zh: 当过程被这样分解时，理解起来相当容易：证书需要一个权威机构并必须被签名，我们需要一个公钥和一个私钥。当创建一个针对商业证书颁发机构签名的公钥和私钥时，这个过程是相似的，如果你想要购买用于公共
    Web 服务器的证书，你会这样做。
- en: 'The full command list for creating a public and private key is as follows:'
  id: totrans-1998
  prefs: []
  type: TYPE_NORMAL
  zh: 创建公钥和私钥的完整命令列表如下：
- en: '![](168fig01_alt.jpg)'
  id: totrans-1999
  prefs: []
  type: TYPE_IMG
  zh: '![168fig01_alt.jpg](168fig01_alt.jpg)'
- en: After creating a private key ![](1.jpg), you’ll create a CSR. When prompted
    for the “Common Name” ![](2.jpg), enter your computer’s hostname, which you can
    find by typing `hostname` in the terminal on a Unix system. This is important,
    because when your code sends or receives certificates, it’ll check the name value
    against the `servername` property passed to the `tls.connect` method.
  id: totrans-2000
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建私钥 ![1.jpg](1.jpg) 之后，你将创建一个 CSR。当提示“通用名称” ![2.jpg](2.jpg) 时，输入你的计算机主机名，你可以在
    Unix 系统的终端中通过输入 `hostname` 来找到它。这很重要，因为当你的代码发送或接收证书时，它将检查名称值与传递给 `tls.connect`
    方法的 `servername` 属性是否匹配。
- en: The next listing reads the server’s keys and starts a server running using `tls.createServer`.
  id: totrans-2001
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表读取服务器的密钥并使用 `tls.createServer` 启动一个服务器。
- en: Listing 7.9\. A TCP server that uses TLS for encryption
  id: totrans-2002
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.9\. 使用 TLS 加密的 TCP 服务器
- en: '![](169fig01_alt.jpg)'
  id: totrans-2003
  prefs: []
  type: TYPE_IMG
  zh: '![169fig01_alt.jpg](169fig01_alt.jpg)'
- en: The network code in [listing 7.9](#ch07ex09) is very similar to the `net.createServer`
    method—that’s because the `tls` module inherits from it. The rest of the code
    is concerned with managing certificates, and unfortunately this process is left
    to us to handle and is often the cause of programmer errors, which can compromise
    security. First we load the private ![](1.jpg) and public ![](2.jpg) keys, passing
    them to `tls.createServer`. We also load the client’s public key as a certificate
    authority ![](3.jpg)—when using a commercially obtained certificate, this stage
    isn’t usually required.
  id: totrans-2004
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 7.9](#ch07ex09) 中的网络代码与 `net.createServer` 方法非常相似——这是因为 `tls` 模块继承自它。其余的代码用于管理证书，不幸的是，这个过程留给了我们处理，并且经常是程序员错误的来源，这可能会损害安全性。首先，我们加载私钥
    ![1.jpg](1.jpg) 和公钥 ![2.jpg](2.jpg)，并将它们传递给 `tls.createServer`。我们还加载客户端的公钥作为证书颁发机构
    ![3.jpg](3.jpg)——当使用商业获得的证书时，这一步通常是不必要的。'
- en: When clients connect, we want to send them some data, but for the purposes of
    this example we really just want to see if the client was authorized ![](5.jpg).
    Client authorization has been forced by setting the `requestCert` option ![](4.jpg).
  id: totrans-2005
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端连接时，我们希望向他们发送一些数据，但在这个示例中，我们真正想要看到的是客户端是否被授权 ![5.jpg](5.jpg)。客户端授权是通过设置
    `requestCert` 选项 ![4.jpg](4.jpg) 来强制执行的。
- en: 'This server can be run with `node tls.js`—but there’s something missing: a
    client! The next listing contains a client that can connect to this server.'
  id: totrans-2006
  prefs: []
  type: TYPE_NORMAL
  zh: 这个服务器可以用 `node tls.js` 运行——但是缺少了一些东西：一个客户端！下一个列表包含一个可以连接到这个服务器的客户端。
- en: Listing 7.10\. A TCP client that uses TLS
  id: totrans-2007
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.10\. 使用 TLS 的 TCP 客户端
- en: '![](169fig02_alt.jpg)'
  id: totrans-2008
  prefs: []
  type: TYPE_IMG
  zh: '![169fig02_alt.jpg](169fig02_alt.jpg)'
- en: 'The client is similar to the server: the private ![](1.jpg) and public keys
    ![](2.jpg) are loaded, and this time the server is treated as the CA ![](3.jpg).
    The server’s name is set to the same value as the Common Name in the CSR by using
    `os.hostname` ![](4.jpg)—you could type in the name manually if you set it to
    something else. After that the client connects, displays whether it was able to
    authorize the certificates, and then reads data sent by the server and pipes it
    to the standard output ![](5.jpg).'
  id: totrans-2009
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端与服务器类似：加载私钥 ![1.jpg](1.jpg) 和公钥 ![2.jpg](2.jpg)，这次服务器被当作 CA ![3.jpg](3.jpg)
    处理。服务器的名称通过使用 `os.hostname` ![4.jpg](4.jpg) 设置为与 CSR 中的通用名称相同的值——如果你将其设置为其他值，你可以手动输入名称。之后客户端连接，显示它是否能够授权证书，然后读取服务器发送的数据并将其管道传输到标准输出
    ![5.jpg](5.jpg)。
- en: '|  |'
  id: totrans-2010
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Testing SSL/TLS**'
  id: totrans-2011
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试 SSL/TLS**'
- en: 'When testing secure certificates, it can be hard to tell whether the problem
    lies in your code or elsewhere. One way around this is to use the `openssl` command-line
    tool to simulate a client or server. The following command will start a client
    that connects to a server with the given certificate file:'
  id: totrans-2012
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试安全证书时，很难判断问题是否出在你的代码中或其他地方。一种解决方法是使用 `openssl` 命令行工具来模拟客户端或服务器。以下命令将启动一个连接到给定证书文件的客户端：
- en: '[PRE73]'
  id: totrans-2013
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The `openssl` tool will display a lot of extra information about the connection.
    When we wrote the example in this technique, we used it to figure out that the
    certificate we’d generated had the wrong value for its Common Name.
  id: totrans-2014
  prefs: []
  type: TYPE_NORMAL
  zh: '`openssl` 工具将显示有关连接的大量额外信息。当我们编写本技巧中的示例时，我们使用它来确定我们生成的证书的通用名称值是错误的。'
- en: '|  |'
  id: totrans-2015
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: An instance of `tls.Server` is instantiated when you call `tls.createServer`.
    This constructor calls `net.Server`—there’s a clear inheritance chain between
    each networking module. That means the events emitted by `net.Server` are the
    same for TLS servers.
  id: totrans-2016
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用 `tls.createServer` 时，会实例化一个 `tls.Server` 对象。这个构造函数调用 `net.Server`——每个网络模块之间有一个清晰的继承链。这意味着
    TLS 服务器与 `net.Server` 发射的事件是相同的。
- en: In the next technique you’ll see how to use HTTPS, and how this is also related
    to the `tls` and `net` modules.
  id: totrans-2017
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个技巧中，你将看到如何使用 HTTPS，以及这与 `tls` 和 `net` 模块的关系。
- en: Technique 55 Encrypted web servers and clients
  id: totrans-2018
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 技巧 55 加密 Web 服务器和客户端
- en: Though it’s possible to host Node applications behind other web servers like
    Apache and nginx, there are times when you’ll want to run your own HTTPS servers.
    This technique introduces the `https` module and shows how it’s related to the
    `tls` module.
  id: totrans-2019
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可以在 Apache 和 nginx 等其他 Web 服务器后面托管 Node 应用程序，但有时你将想要运行自己的 HTTPS 服务器。这个技巧介绍了
    `https` 模块，并展示了它与 `tls` 模块的关系。
- en: Problem
  id: totrans-2020
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: You want to run a server that supports SSL/TLS.
  id: totrans-2021
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要运行一个支持 SSL/TLS 的服务器。
- en: Solution
  id: totrans-2022
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use the `https` module and `https.createServer`.
  id: totrans-2023
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `https` 模块和 `https.createServer`。
- en: Discussion
  id: totrans-2024
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论
- en: To run the examples in this technique, you’ll need to have followed the steps
    to create suitable self-signed certificates, as found in [technique 54](#ch07lev2sec13).
    Once you’ve set up some public and private keys, you’ll be able to run the examples.
  id: totrans-2025
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行本技巧中的示例，你需要遵循创建合适的自签名证书的步骤，如[技巧 54](#ch07lev2sec13)中所述。一旦你设置了公钥和私钥，你就可以运行示例了。
- en: The following listing shows an HTTPS server.
  id: totrans-2026
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了 HTTPS 服务器。
- en: Listing 7.11\. A basic HTTP server that uses TLS for encryption
  id: totrans-2027
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.11\. 使用 TLS 加密的简单 HTTP 服务器
- en: '![](171fig01_alt.jpg)'
  id: totrans-2028
  prefs: []
  type: TYPE_IMG
  zh: '![171fig01_alt.jpg](171fig01_alt.jpg)'
- en: The server in [listing 7.11](#ch07ex11) is basically the same as the one in
    [technique 54](#ch07lev2sec13). Again, the private ![](1.jpg) and public ![](2.jpg)
    keys are loaded and passed to `https.createServer`.
  id: totrans-2029
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 7.11](#ch07ex11) 中的服务器基本上与[技巧 54](#ch07lev2sec13) 中的相同。再次强调，私钥 ![1.jpg](1.jpg)
    和公钥 ![2.jpg](2.jpg) 被加载并传递给 `https.createServer`。'
- en: When browsers request a page, we check the `req.socket.authorized` property
    to see if the request was authorized. This status is returned to the browser.
    If you want to try this out with a browser, ensure you type `https://` into the
    address bar; otherwise it won’t work. You’ll see a warning message because the
    browser won’t be able to verify the server’s certificate—that’s OK; you know what’s
    going on because you created the server. The server will respond saying that you’re
    *unauthorized* because it won’t be able to authorize you, either.
  id: totrans-2030
  prefs: []
  type: TYPE_NORMAL
  zh: 当浏览器请求页面时，我们检查 `req.socket.authorized` 属性以查看请求是否被授权。此状态将返回给浏览器。如果你想用浏览器尝试此操作，确保你在地址栏中输入
    `https://`；否则它将不起作用。你会看到一个警告消息，因为浏览器将无法验证服务器的证书——这是正常的；因为你创建了服务器，所以你知道发生了什么。服务器将响应说你是
    *未授权的*，因为它也无法授权你。
- en: To make a client that can connect to this server, follow the code shown next.
  id: totrans-2031
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个可以连接到此服务器的客户端，请遵循下面的代码。
- en: Listing 7.12\. An example HTTPS client
  id: totrans-2032
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.12\. HTTPS 客户端示例
- en: '![](171fig02_alt.jpg)'
  id: totrans-2033
  prefs: []
  type: TYPE_IMG
  zh: '![171fig02_alt.jpg](171fig02_alt.jpg)'
- en: This example sets the private ![](1.jpg) and public ![](2.jpg) keys for the
    client, which is what your browser does transparently when making secure requests.
    It also sets the server as a certificate authority ![](3.jpg), which wouldn’t
    usually be required. The hostname used for the HTTP request is the machine’s current
    hostname ![](4.jpg).
  id: totrans-2034
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例设置了客户端的私钥 ![1.jpg](1.jpg) 和公钥 ![2.jpg](2.jpg)，这是浏览器在发起安全请求时透明地执行的操作。它还将服务器设置为证书颁发机构
    ![3.jpg](3.jpg)，这通常是不需要的。用于 HTTP 请求的主机名是机器的当前主机名 ![4.jpg](4.jpg)。
- en: Once all of this setup is done, the HTTPS request can be made. This is done
    using `https.request` ![](5.jpg). The API is identical to the `http` module. In
    this example the server will ensure the SSL/TLS authorization procedure was valid,
    so the server will return text to indicate if the connection was fully authorized.
  id: totrans-2035
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成所有这些设置，就可以发起 HTTPS 请求。这是通过 `https.request` 完成的 ![5.jpg](5.jpg)。API 与 `http`
    模块相同。在这个例子中，服务器将确保 SSL/TLS 授权程序是有效的，因此服务器将返回文本以指示连接是否完全授权。
- en: In real HTTPS code, you probably wouldn’t make your own CA. This can be useful
    if you have internal systems that you want to communicate with using HTTPS—perhaps
    for testing or for API requests over the internet. When making HTTPS requests
    against public web servers, Node will be able to verify the server’s certificates
    for you, so you won’t need to set the `key`, `cert`, and `ca` options.
  id: totrans-2036
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际的 HTTPS 代码中，你可能不会创建自己的 CA。如果你有希望使用 HTTPS 进行通信的内部系统——可能是用于测试或通过互联网进行 API 请求——这可能会很有用。当你对公共网络服务器发起
    HTTPS 请求时，Node 将能够为你验证服务器的证书，因此你不需要设置 `key`、`cert` 和 `ca` 选项。
- en: The `https` module has some other features—there’s an `https.get` convenience
    method for making `GET` requests more easily. Otherwise, that wraps up our set
    of techniques on encryption in Node.
  id: totrans-2037
  prefs: []
  type: TYPE_NORMAL
  zh: '`https` 模块还有一些其他特性——有一个 `https.get` 便捷方法，可以更轻松地发起 `GET` 请求。否则，这就结束了我们在 Node
    中关于加密的技术集合。'
- en: '|  |'
  id: totrans-2038
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Secure pairs**'
  id: totrans-2039
  prefs: []
  type: TYPE_NORMAL
  zh: '**安全对**'
- en: 'Before moving off encryption for greener pastures, there’s one patch of delicious
    turf left to chew: `SecurePair`. This is a class in the `tls` module that can
    be used to create a secure pair of streams: one reads and writes encrypted data,
    and the other reads and writes clear text. This potentially allows you to stream
    anything to an encrypted output.'
  id: totrans-2040
  prefs: []
  type: TYPE_NORMAL
  zh: 在转向其他领域之前，还有一个美味的领域等待探索：`SecurePair`。这是 `tls` 模块中的一个类，可以用来创建一个安全的数据流对：一个读取和写入加密数据，另一个读取和写入明文。这可能会让你能够将任何内容流式传输到加密输出。
- en: 'There’s a convenience method for this: `tls.createSecurePair`. When a `SecurePair`
    establishes a secure connection, it’ll emit a `secure` event, but you’ll still
    need to check for `cleartext.authorized` to ensure the certificates were properly
    authorized.'
  id: totrans-2041
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个便捷方法：`tls.createSecurePair`。当 `SecurePair` 建立安全连接时，它将触发一个 `secure` 事件，但你仍然需要检查
    `cleartext.authorized` 以确保证书已被适当授权。
- en: '|  |'
  id: totrans-2042
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 7.7\. Summary
  id: totrans-2043
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.7. 概述
- en: This chapter has been long, but that’s because networking in Node is important.
    Node is built on excellent foundations for network programming; buffers, streams,
    and asynchronous I/O all contribute to an environment that is perfect for writing
    the next generation of network-oriented programs.
  id: totrans-2044
  prefs: []
  type: TYPE_NORMAL
  zh: 本章内容较多，但这是因为 Node 的网络编程很重要。Node 建立在优秀的网络编程基础上；缓冲区、流和异步 I/O 都有助于构建一个非常适合编写下一代面向网络程序的环境。
- en: With this chapter you should be able to appreciate how Node fits into the wider
    world of network software. Whether you’re developing Unix daemons, Windows-based
    game servers, or the next big web app, you should now know where to start.
  id: totrans-2045
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章，你应该能够理解 Node 如何融入更广泛的网络软件世界。无论你是开发 Unix 守护进程、基于 Windows 的游戏服务器，还是下一个大型网络应用，你现在应该知道从哪里开始了。
- en: It goes without saying that networking and encryption are closely related. With
    Node’s `tls` and `https` modules, you should be able to write network clients
    and servers that can talk to other systems without fear of eavesdroppers.
  id: totrans-2046
  prefs: []
  type: TYPE_NORMAL
  zh: 众所周知，网络和加密密切相关。使用 Node 的 `tls` 和 `https` 模块，你应该能够编写可以与其他系统通信的网络客户端和服务器，而不必担心窃听者。
- en: The next chapter is the last on Node’s core modules, `child_process`, and looks
    at techniques for interfacing with other command-line programs.
  id: totrans-2047
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章是关于 Node 核心模块 `child_process` 的最后一章，它探讨了与其他命令行程序交互的技术。
- en: 'Chapter 8\. Child processes: Integrating external applications with Node'
  id: totrans-2048
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 8 章. 子进程：将外部应用程序与 Node 集成
- en: '*This chapter covers*'
  id: totrans-2049
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Executing external applications
  id: totrans-2050
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行外部应用程序
- en: Detaching a child process
  id: totrans-2051
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分离子进程
- en: Interprocess communication between Node processes
  id: totrans-2052
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node 进程之间的进程间通信
- en: Making Node programs executable
  id: totrans-2053
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使 Node 程序可执行
- en: Creating job pools
  id: totrans-2054
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建作业池
- en: Synchronous child processes
  id: totrans-2055
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同步子进程
- en: 'No platform is an island. Although it would be fun to write everything in JavaScript,
    we’d miss out on valuable applications that already exist in other platforms.
    Take GraphicsMagick, for instance ([http://www.graphicsmagick.org/](http://www.graphicsmagick.org/)):
    a full-featured image manipulation tool, great for resizing that massively large
    profile photo that was just uploaded. Or take wkhtmltopdf ([http://wkhtmltopdf.org/](http://wkhtmltopdf.org/)),
    a headless webkit PDF generator, perfect for turning that HTML report into a PDF
    download. In Node, the `child_process` module allows us to execute these applications
    and others (including Node applications) to use with our programs. Thankfully,
    we don’t have to re-invent the wheel.'
  id: totrans-2056
  prefs: []
  type: TYPE_NORMAL
  zh: 没有一个平台是孤岛。虽然用 JavaScript 编写一切很有趣，但我们可能会错过其他平台上已经存在的有价值的应用程序。以 GraphicsMagick
    为例（[http://www.graphicsmagick.org/](http://www.graphicsmagick.org/)）：一个功能齐全的图像处理工具，非常适合调整刚刚上传的巨大个人资料照片。或者以
    wkhtmltopdf（[http://wkhtmltopdf.org/](http://wkhtmltopdf.org/)）为例，一个无头 Webkit
    PDF 生成器，非常适合将 HTML 报告转换为 PDF 下载。在 Node 中，`child_process` 模块允许我们执行这些应用程序和其他应用程序（包括
    Node 应用程序），以便与我们的程序一起使用。幸运的是，我们不必重新发明轮子。
- en: The `child_process` module provides four different methods for executing external
    applications. All methods are asynchronous. The right method will depend on what
    you need, as shown in [figure 8.1](#ch08fig01).
  id: totrans-2057
  prefs: []
  type: TYPE_NORMAL
  zh: '`child_process` 模块提供了四种执行外部应用程序的方法。所有方法都是异步的。正确的方法将取决于你的需求，如图 8.1 所示。'
- en: Figure 8.1\. Choosing the right method
  id: totrans-2058
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 8.1\. 选择正确的方法
- en: '![](08fig01_alt.jpg)'
  id: totrans-2059
  prefs: []
  type: TYPE_IMG
  zh: '![图片](08fig01_alt.jpg)'
- en: '***`execFile`*** —Execute an external application, given a set of arguments,
    and callback with the buffered output after the process exits.'
  id: totrans-2060
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***`execFile`*** —执行外部应用程序，给定一组参数，并在进程退出后回调带有缓冲输出的结果。'
- en: '***`spawn`*** —Execute an external application, given a set of arguments, and
    provide a streaming interface for I/O and events for when the process exits.'
  id: totrans-2061
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***`spawn`*** —给定一组参数执行外部应用程序，并提供 I/O 流式接口和进程退出时的事件接口。'
- en: '***`exec`*** —Execute one or more commands inside a shell and callback with
    the buffered output after the process exits.'
  id: totrans-2062
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***`exec`*** —在 shell 中执行一个或多个命令，并在进程退出后回调带有缓冲输出的结果。'
- en: '***`fork`*** —Execute a Node module as a separate process, given a set of arguments,
    provide a streaming and evented interface like `spawn`, and also set up an interprocess
    communication (IPC) channel between the parent and child process.'
  id: totrans-2063
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***`fork`*** —以独立进程执行 Node 模块，给定一组参数，提供类似于 `spawn` 的流式和事件接口，并在父进程和子进程之间设置一个进程间通信（IPC）通道。'
- en: 'Throughout this chapter we’ll dive into how to get the most out of these methods,
    giving practical examples of where you’d want to use each. Later on, we’ll look
    into some other techniques to use when working with child processes: detaching
    processes, interprocess communication, file descriptors, and pooling.'
  id: totrans-2064
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入了解如何充分利用这些方法，给出实际示例，说明你想要在每个地方使用哪种方法。稍后，我们将探讨一些其他技术，用于与子进程一起工作：分离进程、进程间通信、文件描述符和池化。
- en: 8.1\. Executing external applications
  id: totrans-2065
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1\. 执行外部应用程序
- en: In this first section, we will look at all the ways you can work asynchronously
    with an external program.
  id: totrans-2066
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨所有可以异步与外部程序工作的方式。
- en: Technique 56 Executing external applications
  id: totrans-2067
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 技巧 56 执行外部应用程序
- en: Wouldn’t it be great to run some image processing on a user’s uploaded photo
    with ImageMagick, or validate an XML file with xmllint? Node makes it easy to
    execute external applications.
  id: totrans-2068
  prefs: []
  type: TYPE_NORMAL
  zh: 如果能够在用户上传的图片上运行一些图像处理（使用 ImageMagick），或者使用 xmllint 验证 XML 文件，那岂不是很好？Node 使得执行外部应用程序变得简单。
- en: Problem
  id: totrans-2069
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: You want to execute an external application and get the output.
  id: totrans-2070
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要执行一个外部应用程序并获取输出。
- en: Solution
  id: totrans-2071
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use `execFile` (see [figure 8.2](#ch08fig02)).
  id: totrans-2072
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `execFile`（见图 8.2）。
- en: Figure 8.2\. The `execFile` method buffers the result and provides a callback
    interface.
  id: totrans-2073
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 8.2\. `execFile` 方法缓冲结果并提供回调接口。
- en: '![](08fig02.jpg)'
  id: totrans-2074
  prefs: []
  type: TYPE_IMG
  zh: '![图片](08fig02.jpg)'
- en: Discussion
  id: totrans-2075
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论
- en: 'If you want to run an external application and get the result, using `execFile`
    makes it simple and straightforward. It’ll buffer the output for you and provide
    the results and any errors in a callback. Let’s say we want to run the `echo`
    program given the parameters `hello world`. With `execFile`, we would do the following:'
  id: totrans-2076
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要运行一个外部应用程序并获取结果，使用 `execFile` 会使其变得简单直接。它会为你缓冲输出并提供回调中的结果和任何错误。假设我们想要运行参数为
    `hello world` 的 `echo` 程序。使用 `execFile`，我们会这样做：
- en: '![](176fig01_alt.jpg)'
  id: totrans-2077
  prefs: []
  type: TYPE_IMG
  zh: '![图片](176fig01_alt.jpg)'
- en: How does Node know where to find the external application? To answer that, we
    need to look at how paths work in the underlying operating system.
  id: totrans-2078
  prefs: []
  type: TYPE_NORMAL
  zh: Node 是如何知道在哪里找到外部应用程序的？为了回答这个问题，我们需要查看底层操作系统中路径的工作方式。
- en: 8.1.1\. Paths and the PATH environment variable
  id: totrans-2079
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.1.1\. 路径和 PATH 环境变量
- en: 'Windows/UNIX has a `PATH` environment variable (envvar: [http://en.wikipedia.org/wiki/PATH_(variable)](http://en.wikipedia.org/wiki/PATH_(variable))).
    `PATH` contains a list of directories where executable programs exist. If a program
    exists in one of the listed directories, it can be located without needing an
    absolute or relative path to the application.'
  id: totrans-2080
  prefs: []
  type: TYPE_NORMAL
  zh: 'Windows/UNIX 有一个 `PATH` 环境变量（envvar: [http://en.wikipedia.org/wiki/PATH_(variable)](http://en.wikipedia.org/wiki/PATH_(variable)))。`PATH`
    包含了可执行程序存在的目录列表。如果一个程序存在于这些目录之一中，它可以不通过绝对或相对路径找到应用程序。'
- en: Node, using `execvp` behind the scenes, will search for applications using `PATH`
    when no absolute or relative location is provided. We can see this in our earlier
    example, since directories to common system applications like `echo` usually exist
    in `PATH` already.
  id: totrans-2081
  prefs: []
  type: TYPE_NORMAL
  zh: Node 在幕后使用 `execvp` 搜索应用程序，当没有提供绝对或相对位置时。我们可以在我们之前的例子中看到这一点，因为像 `echo` 这样的常见系统应用程序的目录通常已经存在于
    `PATH` 中。
- en: 'If the directory containing the application isn’t in `PATH`, you’ll need to
    provide the location explicitly like you would on the command line:'
  id: totrans-2082
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序所在的目录不在 `PATH` 中，你需要像在命令行中一样明确地提供位置：
- en: '[PRE74]'
  id: totrans-2083
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'To see what directories are listed in `PATH`, you can run a simple one-liner
    in the Node REPL:'
  id: totrans-2084
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看 `PATH` 中列出的目录，你可以在 Node REPL 中运行一个简单的单行命令：
- en: '[PRE75]'
  id: totrans-2085
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'If you want to avoid including the location to external applications not in
    `PATH`, one option is to add any new directories to `PATH` inside your Node application.
    Just add this line before any `execFile` calls:'
  id: totrans-2086
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要避免将不在 `PATH` 中的外部应用程序的位置包含在内，一个选项是在你的 Node 应用程序内部将任何新的目录添加到 `PATH` 中。只需在
    `execFile` 调用之前添加这一行：
- en: '[PRE76]'
  id: totrans-2087
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Now any applications in that new directory will be accessible without providing
    a path to `execFile`.
  id: totrans-2088
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，任何在该新目录中的应用程序都可以不提供 `execFile` 的路径而访问。
- en: 8.1.2\. Errors when executing external applications
  id: totrans-2089
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.1.2\. 执行外部应用程序时的错误
- en: If your external application doesn’t exist, you’ll get an ENOENT error. Often
    this is due to a typo in the application name or path with the result that Node
    can’t find the application, as shown in [figure 8.3](#ch08fig03).
  id: totrans-2090
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的外部应用程序不存在，你会得到一个 ENOENT 错误。这通常是由于应用程序名称或路径中的拼写错误导致的，结果是 Node 找不到该应用程序，如
    [图 8.3](#ch08fig03) 所示。
- en: Figure 8.3\. Common child process errors
  id: totrans-2091
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 8.3\. 常见的子进程错误
- en: '![](08fig03_alt.jpg)'
  id: totrans-2092
  prefs: []
  type: TYPE_IMG
  zh: '![图 08](08fig03_alt.jpg)'
- en: If the external application does exist but Node can’t access it (typically due
    to insufficient permissions), you’ll get an EACCES or EPERM error. This can often
    be mitigated by either running your Node program as a user with sufficient permissions
    or changing the external application permissions themselves to allow access.
  id: totrans-2093
  prefs: []
  type: TYPE_NORMAL
  zh: 如果外部应用程序确实存在但 Node 无法访问它（通常是由于权限不足），你会得到一个 EACCES 或 EPERM 错误。这通常可以通过以具有足够权限的用户运行你的
    Node 程序或更改外部应用程序的权限以允许访问来缓解。
- en: 'You’ll also get an error if the external application has a non-zero exit status
    ([http://mng.bz/MLXP](http://mng.bz/MLXP)), which is used to indicate that an
    application couldn’t perform the task it was given (on both UNIX and Windows).
    Node will provide the exit status as part of the error object and will also provide
    any data that was written to stdout or stderr:'
  id: totrans-2094
  prefs: []
  type: TYPE_NORMAL
  zh: 如果外部应用程序有一个非零的退出状态 ([http://mng.bz/MLXP](http://mng.bz/MLXP))，你也会得到一个错误，这用于指示应用程序无法执行它被分配的任务（在
    UNIX 和 Windows 上）。Node 将提供退出状态作为错误对象的一部分，并且还会提供写入到 stdout 或 stderr 的任何数据：
- en: '![](178fig01_alt.jpg)'
  id: totrans-2095
  prefs: []
  type: TYPE_IMG
  zh: '![图 178](178fig01_alt.jpg)'
- en: Having `execFile` is great for when you want to just execute an application
    and get the output (or discard it), for example, if you want to run an image-processing
    command with ImageMagick and only care if it succeeds or not. But if an application
    has a lot of output or you want to do more real-time analysis of the data returned,
    using streams is a better approach.
  id: totrans-2096
  prefs: []
  type: TYPE_NORMAL
  zh: 当你只想执行一个应用程序并获取输出（或丢弃它）时，`execFile` 是很棒的，例如，如果你想使用 ImageMagick 运行图像处理命令，并且只关心它是否成功。但是，如果一个应用程序有大量的输出或者你想对返回的数据进行更多的实时分析，使用流是一个更好的方法。
- en: Technique 57 Streaming and external applications
  id: totrans-2097
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 技巧 57：流和外部应用程序
- en: Imagine a web application that uses the output from an external application.
    As that data is being made available, you can at the same time be pushing it out
    to the client. Streaming enables you to tap into the data from a child process
    as it’s being outputted, versus having the data buffered and then provided. This
    is good if you expect the external application to output large amounts of data.
    Why? Buffering a large set of data can take up a lot of memory. Also, this enables
    data to be consumed as it’s being made available, which improves responsiveness.
  id: totrans-2098
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个使用外部应用程序输出的 Web 应用程序。当数据被提供时，你可以同时将其推送到客户端。流允许你在数据输出时从子进程中提取数据，而不是在数据缓冲后提供。如果你预计外部应用程序将输出大量数据，这将很有用。为什么？缓冲大量数据可能会占用大量内存。此外，这允许在数据可用时消费数据，从而提高响应速度。
- en: Problem
  id: totrans-2099
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: You want to execute an external application and stream the output.
  id: totrans-2100
  prefs: []
  type: TYPE_NORMAL
  zh: 你想执行一个外部应用程序并流式传输其输出。
- en: Solution
  id: totrans-2101
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use `spawn` (see [figure 8.4](#ch08fig04)).
  id: totrans-2102
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `spawn`（见图 8.4）。
- en: Figure 8.4\. The `spawn` method returns a streaming interface for I/O.
  id: totrans-2103
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 8.4\. `spawn` 方法返回一个用于 I/O 的流接口。
- en: '![](08fig04.jpg)'
  id: totrans-2104
  prefs: []
  type: TYPE_IMG
  zh: '![图片](08fig04.jpg)'
- en: Discussion
  id: totrans-2105
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论
- en: 'The `spawn` method has a function signature similar to `execFile`:'
  id: totrans-2106
  prefs: []
  type: TYPE_NORMAL
  zh: '`spawn` 方法具有与 `execFile` 类似的函数签名：'
- en: '[PRE77]'
  id: totrans-2107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The application is the first argument, and an array of parameters/flags for
    the application is the second. But instead of taking a callback providing the
    output already buffered, `spawn` relies on streams:'
  id: totrans-2108
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序是第一个参数，而应用程序的参数/标志数组是第二个参数。但是，`spawn` 不会像提供已缓冲输出的回调那样接收参数，而是依赖于流：
- en: '![](179fig01_alt.jpg)'
  id: totrans-2109
  prefs: []
  type: TYPE_IMG
  zh: '![图片](179fig01_alt.jpg)'
- en: Since `spawn` is stream-based, it’s great for handling large outputs or working
    with data as it’s read in. All other benefits of streams apply as well. For example,
    `child.stdin` is a `Writeable` stream, so you can hook that up to any `Readable`
    stream to get data. The reverse is true for `child.stdout` and `child.stderr`,
    which are `Readable` streams that can be hooked into any `Writeable` stream.
  id: totrans-2110
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `spawn` 是基于流的，因此它非常适合处理大量输出或在读取数据时与数据交互。流的所有其他优点也适用。例如，`child.stdin` 是一个
    `Writeable` 流，因此你可以将其连接到任何 `Readable` 流以获取数据。对于 `child.stdout` 和 `child.stderr`，它们是
    `Readable` 流，可以连接到任何 `Writeable` 流。
- en: '|  |'
  id: totrans-2111
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: API symmetry
  id: totrans-2112
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: API 对称性
- en: The `ChildProcess` API (`child.stdin`, `child.stdout`, `child.stderr`) share
    a nice symmetry with the parent `process` streams (`process.stdin`, `process.stdout`,
    `process.stderr`).
  id: totrans-2113
  prefs: []
  type: TYPE_NORMAL
  zh: '`ChildProcess` API (`child.stdin`, `child.stdout`, `child.stderr`) 与父 `process`
    流 (`process.stdin`, `process.stdout`, `process.stderr`) 具有很好的对称性。'
- en: '|  |'
  id: totrans-2114
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 8.1.3\. Stringing external applications together
  id: totrans-2115
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.1.3\. 将外部应用程序连接起来
- en: A large part of UNIX philosophy is building applications that do one thing and
    do it well, and then communicating between those applications with a common interface
    (that being plain text).
  id: totrans-2116
  prefs: []
  type: TYPE_NORMAL
  zh: UNIX 精神的大部分内容是构建只做一件事并且做得很好的应用程序，然后通过一个公共接口（即纯文本）在这些应用程序之间进行通信。
- en: Let’s make a Node program that exemplifies this by taking three simple applications
    that deal with text streams and sticking them together using `spawn`. The `cat`
    application will read a file and output its contents. The `sort` application will
    take in the file as input and provide the lines sorted as output. The `uniq` application
    will take the sorted file as input, and output the sorted file with all the duplicate
    lines removed. This is illustrated in [figure 8.5](#ch08fig05).
  id: totrans-2117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个 Node 程序来举例说明这一点，通过使用 `spawn` 将三个处理文本流的简单应用程序组合在一起。`cat` 应用程序将读取文件并输出其内容。`sort`
    应用程序将文件作为输入并按顺序提供输出。`uniq` 应用程序将排序后的文件作为输入，并输出没有重复行的排序文件。这如图 8.5 所示。
- en: Figure 8.5\. Stringing external applications together with `spawn`
  id: totrans-2118
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 8.5\. 使用 `spawn` 将外部应用程序连接起来
- en: '![](08fig05_alt.jpg)'
  id: totrans-2119
  prefs: []
  type: TYPE_IMG
  zh: '![图片](08fig05_alt.jpg)'
- en: 'Let’s look at how we can do this with `spawn` and streams:'
  id: totrans-2120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用 `spawn` 和流来实现这一点：
- en: '![](179fig02_alt.jpg)'
  id: totrans-2121
  prefs: []
  type: TYPE_IMG
  zh: '![图片](179fig02_alt.jpg)'
- en: Using `spawn`’s streaming interfaces allows a seamless way to work with any
    stream objects in Node, including stringing external applications together. But
    sometimes we need the facilities of our underlying shell to do powerful composition
    of external applications. For that, we can use `exec`.
  id: totrans-2122
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `spawn` 的流接口允许无缝地与 Node 中的任何流对象一起工作，包括将外部应用程序连接起来。但有时我们需要底层 shell 的功能来执行外部应用程序的强大组合。为此，我们可以使用
    `exec`。
- en: '|  |'
  id: totrans-2123
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Applying what you’ve learned
  id: totrans-2124
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 应用你所学的
- en: Can you think of a way to avoid using the `cat` program based on what you learned
    with the `fs` module and streaming in [chapter 6](kindle_split_015.html#ch06)?
  id: totrans-2125
  prefs: []
  type: TYPE_NORMAL
  zh: 您能想到一种避免使用 `cat` 程序的方法吗？基于您在[第6章](kindle_split_015.html#ch06)中学习的 `fs` 模块和流？
- en: '|  |'
  id: totrans-2126
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Technique 58 Executing commands in a shell
  id: totrans-2127
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 技巧58：在shell中执行命令
- en: Shell programming is a common way to build utility scripts or command-line applications.
    You could whip up a Bash or Python script, but with Node, you can use JavaScript.
    Although you could execute a subshell manually using `execFile` or `spawn`, Node
    provides a convenient, cross-platform method for you.
  id: totrans-2128
  prefs: []
  type: TYPE_NORMAL
  zh: Shell编程是构建实用脚本或命令行应用程序的常见方式。您可以使用Bash或Python脚本，但使用Node，您可以使用JavaScript。虽然您可以使用
    `execFile` 或 `spawn` 手动执行子shell，但Node提供了一个方便的、跨平台的方法供您使用。
- en: Problem
  id: totrans-2129
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: You need to use the underlying shell facilities (like pipes, redirects, file
    blobs) to execute commands and get the output.
  id: totrans-2130
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要使用底层shell功能（如管道、重定向、文件块）来执行命令并获取输出。
- en: Solution
  id: totrans-2131
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use `exec` (see [figure 8.6](#ch08fig06)).
  id: totrans-2132
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `exec`（见[图8.6](#ch08fig06)）。
- en: Figure 8.6\. The `exec` method runs our commands in a subshell.
  id: totrans-2133
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.6\. `exec` 方法在子shell中运行我们的命令。
- en: '![](08fig06_alt.jpg)'
  id: totrans-2134
  prefs: []
  type: TYPE_IMG
  zh: '![](08fig06_alt.jpg)'
- en: Discussion
  id: totrans-2135
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论
- en: If you need to execute commands in a shell, you can use `exec`. The `exec` method
    runs the commands with `/bin/sh` or `cmd.exe` (on Windows). Running commands in
    a shell means you have access to all the functionality provided by your particular
    shell (like pipes, redirects, and backgrounding).
  id: totrans-2136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要在shell中执行命令，可以使用 `exec`。`exec` 方法使用 `/bin/sh` 或 `cmd.exe`（在Windows上）来运行命令。在shell中运行命令意味着您可以访问您特定shell提供的所有功能（如管道、重定向和后台运行）。
- en: '|  |'
  id: totrans-2137
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: A single command argument
  id: totrans-2138
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 单个命令参数
- en: Unlike `execFile` and `spawn`, the `exec` method doesn’t have a separate argument
    for command parameters/flags, since you can run more than one command on a shell.
  id: totrans-2139
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `execFile` 和 `spawn` 不同，`exec` 方法没有单独的参数/标志参数，因为在shell上可以运行多个命令。
- en: '|  |'
  id: totrans-2140
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'As an example, let’s pipe together the same three applications we did in the
    last technique to generate a sorted, unique list of names. But this time, we’ll
    use common UNIX shell facilities rather than streams:'
  id: totrans-2141
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让我们将我们在上一技巧中使用的相同三个应用程序连接起来，生成一个排序后的唯一名称列表。但这次，我们将使用常见的UNIX shell功能，而不是流：
- en: '![](181fig01_alt.jpg)'
  id: totrans-2142
  prefs: []
  type: TYPE_IMG
  zh: '![](181fig01_alt.jpg)'
- en: '|  |'
  id: totrans-2143
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: About shells
  id: totrans-2144
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 关于shell
- en: UNIX users should keep in mind that Node uses whatever is mapped to `/bin/sh`
    for execution. This typically will be Bash on most modern operating systems, but
    you have the option to remap it to another shell of your liking. Windows users
    who need a piping facility can use streams and spawn as discussed in [technique
    57](#ch08lev2sec4a).
  id: totrans-2145
  prefs: []
  type: TYPE_NORMAL
  zh: UNIX用户应记住，Node使用映射到 `/bin/sh` 的任何内容进行执行。这通常在大多数现代操作系统上将是Bash，但您可以选择将其重新映射到您喜欢的另一个shell。需要管道功能的Windows用户可以使用流和spawn，如[技巧57](#ch08lev2sec4a)中所述。
- en: '|  |'
  id: totrans-2146
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 8.1.4\. Security and shell command execution
  id: totrans-2147
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.1.4\. 安全性和shell命令执行
- en: Having access to a shell is powerful and convenient, but it should be used cautiously,
    especially with a user’s input.
  id: totrans-2148
  prefs: []
  type: TYPE_NORMAL
  zh: 能够访问shell非常强大且方便，但应谨慎使用，尤其是在处理用户输入时。
- en: 'Let’s say we’re using xmllint ([http://xmlsoft.org/xmllint.html](http://xmlsoft.org/xmllint.html))
    to parse and detect errors in a user’s uploaded XML file where the user provides
    a schema to validate against:'
  id: totrans-2149
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们正在使用xmllint ([http://xmlsoft.org/xmllint.html](http://xmlsoft.org/xmllint.html))来解析和检测用户上传的XML文件中的错误，其中用户提供了一个模式进行验证：
- en: '[PRE78]'
  id: totrans-2150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'If a user provided “[http://site.com/schema.xsd](http://site.com/schema.xsd),”
    it would be replaced and the following command would run:'
  id: totrans-2151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户提供了“[http://site.com/schema.xsd](http://site.com/schema.xsd)”，它将被替换，并运行以下命令：
- en: '[PRE79]'
  id: totrans-2152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'But since the argument has user input, it can easily fall prey to command (or
    shell) injection attacks ([https://golemtechnologies.com/articles/shell-injection](https://golemtechnologies.com/articles/shell-injection))—for
    example, a malicious user provides “; rm -rf / ;” causing the following comment
    to run (*please don’t run this in your terminal!*):'
  id: totrans-2153
  prefs: []
  type: TYPE_NORMAL
  zh: 但由于参数包含用户输入，它很容易成为命令（或shell）注入攻击的受害者（[https://golemtechnologies.com/articles/shell-injection](https://golemtechnologies.com/articles/shell-injection)）——例如，恶意用户提供了“;
    rm -rf / ;”，导致以下注释运行（*请勿在您的终端中运行此命令!*）：
- en: '[PRE80]'
  id: totrans-2154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: If you haven’t guessed already, this says, “Start new command (`;`), remove
    forcibly and recursively all files/directories at root of the file system (`rm
    -rf /`), and end the command (`;`) in case something follows it.”
  id: totrans-2155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有猜到，这意味着“启动新命令（`;`），强制递归地删除文件系统根目录下的所有文件/目录（`rm -rf /`），并在其后跟有内容时结束命令（`;`）”。
- en: In other words, this injection could potentially delete all the files the Node
    process has permission to access on the entire operating system! And that’s just
    one of the commands that can be run. Anything your process user has access to
    (files, commands, and so on) can be exploited.
  id: totrans-2156
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，这种注入可能会删除Node进程在整个操作系统中具有权限访问的所有文件！这只是可以运行的命令之一。任何你的进程用户可以访问的（文件、命令等）都可以被利用。
- en: 'If you need to run an application and don’t need shell facilities, it’s safer
    (and slightly faster) to use `execFile` instead:'
  id: totrans-2157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要运行一个应用程序且不需要shell功能，使用`execFile`更安全（并且稍微快一点）：
- en: '[PRE81]'
  id: totrans-2158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Here this malicious injection attack would fail since it’s not run in a shell
    and the external application likely wouldn’t understand the argument and would
    raise an error.
  id: totrans-2159
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，由于不是在shell中运行，并且外部应用程序可能不理解该参数并会引发错误，因此恶意注入攻击会失败。
- en: Technique 59 Detaching a child process
  id: totrans-2160
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 技巧59 分离子进程
- en: Node can be used to kick off external applications and then allow them to run
    on their own. For example, let’s say you have an administrative web application
    in Node that allows you to kick off a long-running synchronization process with
    your cloud provider. If that Node application were to crash, your synchronization
    process would be halted. To avoid this, you detach your external application so
    it’ll be unaffected.
  id: totrans-2161
  prefs: []
  type: TYPE_NORMAL
  zh: Node可以用来启动外部应用程序，然后允许它们独立运行。例如，假设你有一个在Node中的管理型Web应用程序，它允许你启动一个与云服务提供商的长运行同步进程。如果该Node应用程序崩溃，你的同步进程将被终止。为了避免这种情况，你需要分离外部应用程序，这样它就不会受到影响。
- en: Problem
  id: totrans-2162
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: You have a long-running external application that you want Node to start but
    then be able to exit with the child process still running.
  id: totrans-2163
  prefs: []
  type: TYPE_NORMAL
  zh: 你有一个需要Node启动但随后能够退出而子进程仍然运行的长运行外部应用程序。
- en: Solution
  id: totrans-2164
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案
- en: Detach a spawned child process (see [figure 8.7](#ch08fig07)).
  id: totrans-2165
  prefs: []
  type: TYPE_NORMAL
  zh: 分离一个派生的子进程（见[图8.7](#ch08fig07)）。
- en: Figure 8.7\. Detached child process exists independent of the Node process
  id: totrans-2166
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.7\. 分离的子进程独立于Node进程存在
- en: '![](08fig07_alt.jpg)'
  id: totrans-2167
  prefs: []
  type: TYPE_IMG
  zh: '![08fig07_alt](08fig07_alt.jpg)'
- en: Discussion
  id: totrans-2168
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论
- en: Normally, any child process will be terminated when the parent Node process
    is terminated. Child processes are said to be *attached* to the parent process.
    But the `spawn` method includes the ability to *detach* a child process and promote
    it to be a process group leader. In this scenario, if the parent is terminated,
    the child process will continue until finished.
  id: totrans-2169
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，任何子进程都会在父Node进程终止时被终止。子进程被称为*附加*到父进程。但是`spawn`方法包括将子进程*分离*并提升为进程组领导者的能力。在这种情况下，如果父进程被终止，子进程将继续运行直到完成。
- en: This scenario is useful when you want Node to set up the execution of a long-running
    external process and you don’t need Node to babysit it after it starts.
  id: totrans-2170
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想要Node设置长运行外部进程的执行，而你又不希望Node在启动后监视它时，这种场景很有用。
- en: 'This is the `detached` option, configurable as part of a third options parameter
    to `spawn`:'
  id: totrans-2171
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`detached`选项，可以作为`spawn`的第三个选项参数进行配置：
- en: '[PRE82]'
  id: totrans-2172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: In this example, `longrun` will be promoted to a process group leader. If you
    were to run this Node program and forcibly terminate it (Ctrl-C), `longrun` would
    continue executing until finished.
  id: totrans-2173
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`longrun`将被提升为进程组领导者。如果你运行这个Node程序并强制终止它（Ctrl-C），`longrun`将继续执行直到完成。
- en: If you didn’t forcibly terminate, you’d notice that the parent stays alive until
    the child has completed. This is because I/O of the child process is connected
    to the parent. In order to disconnect the I/O, you have to configure the `stdio`
    option.
  id: totrans-2174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有强制终止，你会注意到父进程会一直存活，直到子进程完成。这是因为子进程的I/O连接到了父进程。为了断开I/O，你必须配置`stdio`选项。
- en: 8.1.5\. Handing I/O between the child and parent processes
  id: totrans-2175
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.1.5\. 在子进程和父进程之间处理I/O
- en: The `stdio` option defines where the I/O from a child process will be redirected.
    It takes either an array or a string as a value. The string values are simply
    shorthands that will expand to common array configurations.
  id: totrans-2176
  prefs: []
  type: TYPE_NORMAL
  zh: '`stdio`选项定义了子进程的I/O将被重定向到何处。它接受一个数组或一个字符串作为值。字符串值只是简写，将扩展为常见的数组配置。'
- en: The array is structured such that the *indexes* correspond to file descriptors
    in the child process and the *values* indicate where the I/O for the particular
    file descriptor (FD) should be redirected.
  id: totrans-2177
  prefs: []
  type: TYPE_NORMAL
  zh: 该数组结构使得*索引*对应于子进程中的文件描述符，而*值*指示特定文件描述符（FD）的I/O应重定向到何处。
- en: '|  |'
  id: totrans-2178
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: What are file descriptors?
  id: totrans-2179
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 文件描述符是什么？
- en: If you’re confused about file descriptors, check out [technique 40](kindle_split_015.html#ch06lev2sec22)
    in [chapter 6](kindle_split_015.html#ch06) for an introduction.
  id: totrans-2180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对文件描述符感到困惑，请查看第6章中的[技术40](kindle_split_015.html#ch06lev2sec22)以获取介绍。
- en: '|  |'
  id: totrans-2181
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: By default, `stdio` is configured as
  id: totrans-2182
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`stdio`配置如下：
- en: '[PRE83]'
  id: totrans-2183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'which is a shorthand for the following array values:'
  id: totrans-2184
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对以下数组值的简写：
- en: '[PRE84]'
  id: totrans-2185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: This means that file descriptors 0-2 will be made accessible on the `ChildProcess`
    object as streams (`child.stdio[0]`, `child.stdio[1]`, `child.stdio[2]`). But
    since FDs 0-2 often refer to `stdin`, `stdout`, and `stderr`, they’re also made
    available as the now familiar `child.stdin`, `child.stdout`, and `child.stderr`
    streams.
  id: totrans-2186
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着文件描述符0-2将在`ChildProcess`对象上作为流（`child.stdio[0]`、`child.stdio[1]`、`child.stdio[2]`）可用。但由于FD
    0-2通常指的是`stdin`、`stdout`和`stderr`，它们也作为现在熟悉的`child.stdin`、`child.stdout`和`child.stderr`流提供。
- en: 'The `pipe` value connects the parent and child processes because these streams
    stay open, waiting to write or read data. But for this technique, we want to disconnect
    the two in order to exit the Node process. A brute-force approach would be to
    simply destroy all the streams created:'
  id: totrans-2187
  prefs: []
  type: TYPE_NORMAL
  zh: '`pipe`值连接父进程和子进程，因为这些流保持打开状态，等待写入或读取数据。但为了使用这种技术，我们希望断开这两个进程的连接，以便退出Node进程。一种暴力方法是简单地销毁创建的所有流：'
- en: '[PRE85]'
  id: totrans-2188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Although this would work, given our intent to not use them, it’s better to not
    create the streams in the first place. Instead, we can assign a file descriptor
    if we want to direct the I/O elsewhere or use `ignore` to discard it completely.
  id: totrans-2189
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这会起作用，但鉴于我们不打算使用它们，最好从一开始就不创建流。相反，如果我们想将I/O导向其他地方，可以分配一个文件描述符，或者使用`ignore`完全丢弃它。
- en: 'Let’s look at a solution that uses both options. We want to `ignore` FD 0 (`stdin`)
    since we won’t be providing any input to the child process. But let’s capture
    any output from FDs 1 and 2 (`stdout`, `stderr`) just in case we need to do some
    debugging later on. Here’s how we can accomplish that:'
  id: totrans-2190
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看使用这两个选项的解决方案。我们想要`ignore`文件描述符0（`stdin`），因为我们不会向子进程提供任何输入。但让我们捕获文件描述符1和2（`stdout`、`stderr`）的任何输出，以防我们稍后需要进行一些调试。以下是我们可以如何实现这一点：
- en: '![](184fig01_alt.jpg)'
  id: totrans-2191
  prefs: []
  type: TYPE_IMG
  zh: '![](184fig01_alt.jpg)'
- en: This will disconnect the I/O between the child and parent processes. If we run
    this application, the output from the child process will end up in the log files.
  id: totrans-2192
  prefs: []
  type: TYPE_NORMAL
  zh: 这将断开子进程和父进程之间的I/O。如果我们运行此应用程序，子进程的输出将最终出现在日志文件中。
- en: 8.1.6\. Reference counting and child processes
  id: totrans-2193
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.1.6. 引用计数和子进程
- en: We’re almost there. The child process will live on because it’s detached and
    the I/O is disconnected from the parent. But the parent still has an internal
    reference to the child process and won’t exit until the child process has finished
    and the reference has been removed.
  id: totrans-2194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎完成了。子进程将继续存在，因为它已断开，并且I/O已从父进程断开。但父进程仍然保留对子进程的内部引用，并且不会退出，直到子进程完成并且引用被移除。
- en: 'You can use the `child.unref()` method to tell Node not to include this child
    process reference in its count. The following complete application will now exit
    after spawning the child process:'
  id: totrans-2195
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`child.unref()`方法告诉Node不要将此子进程引用包含在其计数中。以下完整的应用程序现在将在启动子进程后退出：
- en: '![](184fig02.jpg)'
  id: totrans-2196
  prefs: []
  type: TYPE_IMG
  zh: '![](184fig02.jpg)'
- en: 'To review, detaching a process requires three things:'
  id: totrans-2197
  prefs: []
  type: TYPE_NORMAL
  zh: 为了回顾，断开进程需要三件事：
- en: The `detached` option must be set to `true` so the child becomes its own process
    leader.
  id: totrans-2198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`detached`选项必须设置为`true`，以便子进程成为自己的进程领导者。'
- en: The `stdio` option must be configured so the parent and child are disconnected.
  id: totrans-2199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stdio`选项必须配置为使父进程和子进程断开连接。'
- en: The reference to the child must be severed in the parent using `child.unref()`.
  id: totrans-2200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在父进程中使用`child.unref()`必须切断对子进程的引用。
- en: 8.2\. Executing Node programs
  id: totrans-2201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2. 执行Node程序
- en: Any of the prior techniques can be used to execute Node applications. However,
    in the techniques to follow, we will focus on making the most out of Node child
    processes.
  id: totrans-2202
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用任何先前的技术来执行Node应用程序。然而，在接下来的技术中，我们将专注于充分利用Node子进程。
- en: Technique 60 Executing Node programs
  id: totrans-2203
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 技术编号60：执行Node程序
- en: When writing shell scripts, utilities, or other command-line applications in
    Node, it’s often handy to make executables out of them for ease of use and portability.
    If you publish command-line applications to npm, this also comes in handy.
  id: totrans-2204
  prefs: []
  type: TYPE_NORMAL
  zh: 当在Node中编写shell脚本、实用程序或其他命令行应用程序时，将其制作成可执行文件对于方便使用和可移植性非常有用。如果您将命令行应用程序发布到npm，这也很有用。
- en: Problem
  id: totrans-2205
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: You want to make a Node program an executable script.
  id: totrans-2206
  prefs: []
  type: TYPE_NORMAL
  zh: 您想将Node程序制作成可执行脚本。
- en: Solution
  id: totrans-2207
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案
- en: Set up the file to be executable by your underlying platform.
  id: totrans-2208
  prefs: []
  type: TYPE_NORMAL
  zh: 将文件设置为可由您的底层平台执行。
- en: Discussion
  id: totrans-2209
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论
- en: 'A Node program can be run as a child process with any of the means we’ve already
    described by simply using the `node` executable:'
  id: totrans-2210
  prefs: []
  type: TYPE_NORMAL
  zh: Node 程序可以通过使用 `node` 可执行文件以任何我们已经描述的方式作为子进程运行：
- en: '[PRE86]'
  id: totrans-2211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'But there are many cases where having a standalone executable is more convenient,
    where you can instead use your app like this:'
  id: totrans-2212
  prefs: []
  type: TYPE_NORMAL
  zh: 但在许多情况下，拥有独立的可执行文件更方便，您可以像这样使用您的应用程序：
- en: '[PRE87]'
  id: totrans-2213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: The process for making an executable will vary depending on whether you’re on
    Windows or UNIX.
  id: totrans-2214
  prefs: []
  type: TYPE_NORMAL
  zh: 创建可执行文件的过程将根据您是在 Windows 还是 UNIX 上而有所不同。
- en: Executables on Windows
  id: totrans-2215
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Windows 上的可执行文件
- en: 'Let’s say we have a simple one-liner `hello.js` program that echoes the first
    argument passed:'
  id: totrans-2216
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个简单的单行 `hello.js` 程序，该程序会回显传递的第一个参数：
- en: '[PRE88]'
  id: totrans-2217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: To run this program, we type
  id: totrans-2218
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行此程序，我们输入
- en: '[PRE89]'
  id: totrans-2219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'To make a Windows executable, we can make a simple batch script calling the
    Node program. For consistency, let’s call it `hello.bat`:'
  id: totrans-2220
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建 Windows 可执行文件，我们可以创建一个简单的批处理脚本，调用 Node 程序。为了保持一致性，让我们称它为 `hello.bat`：
- en: '![](185fig01.jpg)'
  id: totrans-2221
  prefs: []
  type: TYPE_IMG
  zh: '![](185fig01.jpg)'
- en: 'Now we can execute our hello.js program by simply running the following:'
  id: totrans-2222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过简单地运行以下命令来执行我们的 hello.js 程序：
- en: '[PRE90]'
  id: totrans-2223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Running it as a child process requires the `.bat` extension:'
  id: totrans-2224
  prefs: []
  type: TYPE_NORMAL
  zh: 作为子进程运行需要 `.bat` 扩展名：
- en: '[PRE91]'
  id: totrans-2225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Executables on UNIX
  id: totrans-2226
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: UNIX 上的可执行文件
- en: 'To turn a Node program into an executable script on most UNIX systems, we don’t
    need a separate batch file like in Windows; we simply modify `hello.js` itself
    by adding the following to the top of the file:'
  id: totrans-2227
  prefs: []
  type: TYPE_NORMAL
  zh: 将 Node 程序转换为大多数 UNIX 系统上的可执行脚本，我们不需要像 Windows 一样单独的批处理文件；我们只需通过在文件顶部添加以下内容来修改
    `hello.js` 本身：
- en: '![](186fig01_alt.jpg)'
  id: totrans-2228
  prefs: []
  type: TYPE_IMG
  zh: '![](186fig01_alt.jpg)'
- en: 'Then to actually make the file executable, we run the following command:'
  id: totrans-2229
  prefs: []
  type: TYPE_NORMAL
  zh: 然后为了真正使文件可执行，我们运行以下命令：
- en: '[PRE92]'
  id: totrans-2230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'We can then run the command like this:'
  id: totrans-2231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像这样运行命令：
- en: '[PRE93]'
  id: totrans-2232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'The file can be renamed as well to look more like a standalone program:'
  id: totrans-2233
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件也可以重命名，使其看起来更像是一个独立程序：
- en: '[PRE94]'
  id: totrans-2234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Executing this program as a child process will look the same as its command-line
    counterpart:'
  id: totrans-2235
  prefs: []
  type: TYPE_NORMAL
  zh: 作为子进程执行此程序将与其命令行对应物看起来相同：
- en: '[PRE95]'
  id: totrans-2236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '|  |'
  id: totrans-2237
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Publishing executable files in npm
  id: totrans-2238
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 在 npm 中发布可执行文件
- en: For publishing packages that contain executable files, use the UNIX conventions,
    and npm will make the proper adjustments for Windows.
  id: totrans-2239
  prefs: []
  type: TYPE_NORMAL
  zh: 对于包含可执行文件的包的发布，使用 UNIX 习惯，npm 将为 Windows 进行适当的调整。
- en: '|  |'
  id: totrans-2240
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Technique 61 Forking Node modules
  id: totrans-2241
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 技巧 61：Node 模块分叉
- en: Web workers ([http://mng.bz/UG63](http://mng.bz/UG63)) provide the browser and
    JavaScript an elegant way to run computationally intense tasks off the main thread
    with a built-in communication stream between the parent and worker. This removes
    the painful work of breaking up computation into pieces in order to not upset
    the user experience. In Node, we have the same concept, with a slightly different
    API with `fork`. This helps us break out any heavy lifting into a separate process,
    keeping our event loop running smoothly.
  id: totrans-2242
  prefs: []
  type: TYPE_NORMAL
  zh: Web Workers ([http://mng.bz/UG63](http://mng.bz/UG63)) 为浏览器和 JavaScript 提供了一种优雅的方式来在主线程之外运行计算密集型任务，并在父进程和工作者之间内置通信流。这消除了将计算分解成片段以不破坏用户体验的痛苦工作。在
    Node 中，我们有相同的概念，但 API 略有不同，使用 `fork`。这有助于我们将任何繁重的工作分离到单独的进程中，保持事件循环平稳运行。
- en: Problem
  id: totrans-2243
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: You want to manage separate Node processes.
  id: totrans-2244
  prefs: []
  type: TYPE_NORMAL
  zh: 您想管理独立的 Node 进程。
- en: Solution
  id: totrans-2245
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use `fork` (see [figure 8.8](#ch08fig08)).
  id: totrans-2246
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `fork`（见[图 8.8](#ch08fig08)）。
- en: Figure 8.8\. The `fork` command runs a Node module in a separate process and
    sets up a communications channel.
  id: totrans-2247
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 8.8。`fork` 命令在单独的进程中运行 Node 模块，并设置通信通道。
- en: '![](08fig08.jpg)'
  id: totrans-2248
  prefs: []
  type: TYPE_IMG
  zh: '![](08fig08.jpg)'
- en: Discussion
  id: totrans-2249
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论
- en: Sometimes it’s useful to have separate Node processes. One such case is computation.
    Since Node is single-threaded, computational tasks directly affect the performance
    of the whole process. This may be acceptable for certain jobs, but when it comes
    to network programming, it’ll severely affect performance since requests can’t
    be serviced when the process is tied up. Running these types of tasks in a forked
    process allows the main application to stay responsive. Another use of forking
    is for sharing file descriptors, where a child can accept an incoming connection
    received by the parent process.
  id: totrans-2250
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候拥有独立的 Node 进程很有用。其中一种情况是计算。由于 Node 是单线程的，计算任务会直接影响整个进程的性能。这可能适用于某些工作，但当涉及到网络编程时，它将严重影响性能，因为当进程被占用时，请求无法得到服务。在分叉进程中运行这些类型的任务可以使主应用程序保持响应。分叉的另一个用途是共享文件描述符，其中子进程可以接受父进程接收到的传入连接。
- en: 'Node provides a nice way to communicate between other Node programs. Under
    the hood, it sets up the following `stdio` configuration:'
  id: totrans-2251
  prefs: []
  type: TYPE_NORMAL
  zh: Node 提供了一种很好的方式来在其他的 Node 程序之间进行通信。在底层，它设置了以下 `stdio` 配置：
- en: '[PRE96]'
  id: totrans-2252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'This means that, by default, all output and input are directly inherited from
    the parent; there’s no `child.stdin`, `child.stdout`, or `child.stderr`:'
  id: totrans-2253
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着默认情况下，所有输出和输入都是直接从父进程继承的；没有 `child.stdin`、`child.stdout` 或 `child.stderr`：
- en: '[PRE97]'
  id: totrans-2254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'If you want to provide an I/O configuration that behaves like the `spawn` defaults
    (meaning you get a `child.stdin`, and so on), you can use the `silent` option:'
  id: totrans-2255
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要提供一个类似于 `spawn` 默认的 I/O 配置（这意味着你得到 `child.stdin` 等），你可以使用 `silent` 选项：
- en: '[PRE98]'
  id: totrans-2256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '|  |'
  id: totrans-2257
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Internals of interprocess communication
  id: totrans-2258
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 进程间通信的内部机制
- en: Although a number of mechanisms exist to provide interprocess communication
    (IPC; see [http://mng.bz/LGKD](http://mng.bz/LGKD)), Node IPC channels will use
    either a UNIX domain socket ([http://mng.bz/1189](http://mng.bz/1189)) or a Windows
    named pipe ([http://mng.bz/262Q](http://mng.bz/262Q)).
  id: totrans-2259
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管存在许多机制来提供进程间通信（IPC；见 [http://mng.bz/LGKD](http://mng.bz/LGKD)），Node IPC 通道将使用
    UNIX 域套接字 ([http://mng.bz/1189](http://mng.bz/1189)) 或 Windows 命名管道 ([http://mng.bz/262Q](http://mng.bz/262Q))。
- en: '|  |'
  id: totrans-2260
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Communicating with forked Node modules
  id: totrans-2261
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 与分叉的 Node 模块通信
- en: The `fork` method opens up an IPC channel that allows message passing between
    Node processes. On the child side, it exposes `process.on('message')` and `process.send()`
    as mechanisms for receiving and sending messages. On the parent side, it provides
    `child.on('message')` and `child.send()`.
  id: totrans-2262
  prefs: []
  type: TYPE_NORMAL
  zh: '`fork` 方法打开了一个 IPC 通道，允许 Node 进程之间进行消息传递。在子进程中，它暴露了 `process.on(''message'')`
    和 `process.send()` 作为接收和发送消息的机制。在父进程中，它提供了 `child.on(''message'')` 和 `child.send()`。'
- en: 'Let’s make a simple echo module that sends back any message received from the
    parent:'
  id: totrans-2263
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个简单的回声模块，它将发送从父进程接收到的任何消息：
- en: '![](188fig01_alt.jpg)'
  id: totrans-2264
  prefs: []
  type: TYPE_IMG
  zh: '![](188fig01_alt.jpg)'
- en: 'An application can now consume this module using `fork`:'
  id: totrans-2265
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序现在可以使用 `fork` 来消费此模块：
- en: '![](188fig02_alt.jpg)'
  id: totrans-2266
  prefs: []
  type: TYPE_IMG
  zh: '![](188fig02_alt.jpg)'
- en: 'Sending data between the processes maintains the type information, which means
    you can send any valid JSON value over the wire and it retains the type:'
  id: totrans-2267
  prefs: []
  type: TYPE_NORMAL
  zh: 在进程之间发送数据保持类型信息，这意味着你可以通过电线发送任何有效的 JSON 值，并且它保留了类型：
- en: '[PRE99]'
  id: totrans-2268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Disconnecting from forked Node modules
  id: totrans-2269
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 从分叉的 Node 模块断开连接
- en: 'Since we’re opening an IPC channel between the parent and child, both stay
    alive until the child is disconnected (or exits some other way). If you need to
    disconnect the IPC channel, you can do that explicitly from the parent process:'
  id: totrans-2270
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在父进程和子进程之间打开了一个 IPC 通道，两者都会保持活动状态，直到子进程断开连接（或以其他方式退出）。如果你需要断开 IPC 通道，你可以从父进程中显式地做到这一点：
- en: '[PRE100]'
  id: totrans-2271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: Technique 62 Running jobs
  id: totrans-2272
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 技巧 62 运行工作
- en: When you need to run *routine* computational jobs, forking processes on demand
    will quickly eat up your CPU resources. It’s better to keep a job pool of available
    Node processes ready for work. This technique takes a look at that.
  id: totrans-2273
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要运行 *常规* 计算工作，按需分叉进程将很快消耗你的 CPU 资源。更好的做法是保持一个可用的 Node 进程池，随时准备工作。这项技术将探讨这一点。
- en: Problem
  id: totrans-2274
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: You have routine jobs that you don’t want to run on the main event loop.
  id: totrans-2275
  prefs: []
  type: TYPE_NORMAL
  zh: 你有一些常规工作不想在主事件循环上运行。
- en: Solution
  id: totrans-2276
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use `fork` and manage a pool of workers.
  id: totrans-2277
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `fork` 并管理一个工作池。
- en: Discussion
  id: totrans-2278
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论
- en: 'We can use the IPC channel built into `fork` to create a pattern for handling
    computationally intensive tasks (or jobs). It builds upon our last technique,
    but adds an important constraint: when the parent sends a task to the child, it
    expects to receive exactly one result. Here’s how this works in the parent process:'
  id: totrans-2279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `fork` 内置的 IPC 通道来创建处理计算密集型任务（或工作）的模式。它基于我们之前的技巧，但增加了一个重要的约束：当父进程向子进程发送任务时，它期望收到确切的一个结果。以下是这在父进程中的工作方式：
- en: '![](189fig01_alt.jpg)'
  id: totrans-2280
  prefs: []
  type: TYPE_IMG
  zh: '![](189fig01_alt.jpg)'
- en: But receiving a result is only one of the possible outcomes. To build resilience
    into our `doWork` function, we’ll account for
  id: totrans-2281
  prefs: []
  type: TYPE_NORMAL
  zh: 但接收结果只是可能的结果之一。为了使 `doWork` 函数具有弹性，我们将考虑
- en: The child exiting for any reason
  id: totrans-2282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子进程由于任何原因退出
- en: Unexpected errors (like a closed IPC channel or failure to fork)
  id: totrans-2283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 意外的错误（如关闭 IPC 通道或无法分叉）
- en: 'Handling those in code will involve a couple more listeners:'
  id: totrans-2284
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中处理这些将涉及更多的监听器：
- en: '![](189fig02.jpg)'
  id: totrans-2285
  prefs: []
  type: TYPE_IMG
  zh: '![](189fig02.jpg)'
- en: 'This is a good start, but we run the risk of calling our callback more than
    once in the case where the worker finished the job but then later exited or had
    an error. Let’s add some state and clean things up a bit:'
  id: totrans-2286
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个好的开始，但我们面临的风险是在工作进程完成工作但后来退出或发生错误的情况下多次调用我们的回调。让我们添加一些状态并稍微整理一下：
- en: '![](189fig03_alt.jpg)'
  id: totrans-2287
  prefs: []
  type: TYPE_IMG
  zh: '![](189fig03_alt.jpg)'
- en: 'So far we’ve only looked at the parent process. The child worker takes in a
    job, and sends exactly one message back to the parent when completed:'
  id: totrans-2288
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只看了父进程。子工作进程接收一个工作，并在完成时向父进程发送一条确切的消息：
- en: '[PRE101]'
  id: totrans-2289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 8.2.1\. Job pooling
  id: totrans-2290
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.2.1\. 工作池
- en: 'Currently, our `doWork` function will spin up a new child process every time
    we need to do some work. This isn’t free, as the Node documentation states:'
  id: totrans-2291
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的 `doWork` 函数每次需要执行一些工作时会启动一个新的子进程。这并不是免费的，正如 Node 文档所述：
- en: '*These child Nodes are still whole new instances of V8\. Assume at least 30ms
    startup and 10mb memory for each new Node. That is, you cannot create many thousands
    of them.*'
  id: totrans-2292
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*这些子节点仍然是全新的 V8 实例。假设每个新节点至少需要 30ms 的启动时间和 10MB 的内存。也就是说，你不能创建成千上万的它们。*'
- en: A performant way to work around this is not to spin off a new process whenever
    you want to do something computationally expensive, but rather to maintain a pool
    of long-running processes that can handle the load.
  id: totrans-2293
  prefs: []
  type: TYPE_NORMAL
  zh: 一种高效地解决这个问题的方式不是每次你想执行一些计算密集型任务时都启动一个新的进程，而是维护一个可以处理负载的长运行进程池。
- en: 'Let’s expand our `doWork` function, creating a module for handling a worker
    pool. Here are some additional constraints we’ll add:'
  id: totrans-2294
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们扩展 `doWork` 函数，创建一个处理工作池的模块。以下是我们将添加的一些额外约束：
- en: Only fork up to as many worker processes as CPUs on the machine.
  id: totrans-2295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只启动与机器上的 CPU 数量相等的子工作进程。
- en: Ensure new work gets an available worker process and not one that’s currently
    in-process.
  id: totrans-2296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保新的工作能够获得一个可用的工作进程，而不是一个当前正在处理中的进程。
- en: When no worker processes are available, maintain a queue of tasks to execute
    as processes become available.
  id: totrans-2297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当没有可用的工作进程时，维护一个任务队列，以便在进程可用时执行。
- en: Fork processes on demand.
  id: totrans-2298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按需进行进程的 `fork`。
- en: 'Let’s take a look at the code to implement this:'
  id: totrans-2299
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看实现这个功能的代码：
- en: '![](190fig01_alt.jpg)'
  id: totrans-2300
  prefs: []
  type: TYPE_IMG
  zh: '![](190fig01_alt.jpg)'
- en: '|  |'
  id: totrans-2301
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Applying what you’ve learned
  id: totrans-2302
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 应用所学知识
- en: Other constraints may apply depending on the needs of the pool, for example,
    retrying jobs on failure or killing long-running jobs. How would you implement
    a retry or timeout using the preceding example?
  id: totrans-2303
  prefs: []
  type: TYPE_NORMAL
  zh: 根据池的需求，可能还有其他约束，例如在失败时重试工作或终止长运行的工作。你将如何使用前面的示例来实现重试或超时？
- en: '|  |'
  id: totrans-2304
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 8.2.2\. Using the pooler module
  id: totrans-2305
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.2.2\. 使用 pooler 模块
- en: 'Let’s say we want to run a computationally intensive task based on a user’s
    request to our server. First, let’s expand our child worker process to simulate
    an intensive task:'
  id: totrans-2306
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要根据用户对服务器的请求运行一个计算密集型任务。首先，让我们扩展我们的子工作进程来模拟一个密集型任务：
- en: '![](191fig01_alt.jpg)'
  id: totrans-2307
  prefs: []
  type: TYPE_IMG
  zh: '![](191fig01_alt.jpg)'
- en: 'Now that we have a sample child process to run, let’s put this all together
    with a simple application that uses the pooler module and worker modules:'
  id: totrans-2308
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个要运行的样本子进程，让我们将所有这些与一个简单的应用程序结合起来，该应用程序使用 pooler 模块和工作模块：
- en: '![](191fig02_alt.jpg)'
  id: totrans-2309
  prefs: []
  type: TYPE_IMG
  zh: '![](191fig02_alt.jpg)'
- en: Pooling saves the overhead of spinning up and destroying child processes. It
    makes use of the communications channels built into `fork` and allows Node to
    be used effectively for managing jobs across a set of child processes.
  id: totrans-2310
  prefs: []
  type: TYPE_NORMAL
  zh: 池化可以节省启动和销毁子进程的开销。它利用了 `fork` 中内置的通信通道，使得 Node 能够有效地管理一组子进程中的工作。
- en: '|  |'
  id: totrans-2311
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Going further
  id: totrans-2312
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 进一步了解
- en: To further investigate job pools, check out the third-party `compute-cluster`
    module ([https://github.com/lloyd/node-compute-cluster](https://github.com/lloyd/node-compute-cluster)).
  id: totrans-2313
  prefs: []
  type: TYPE_NORMAL
  zh: 要进一步研究工作池，请查看第三方 `compute-cluster` 模块（[https://github.com/lloyd/node-compute-cluster](https://github.com/lloyd/node-compute-cluster)）。
- en: '|  |'
  id: totrans-2314
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: We’ve discussed asynchronous child process execution, which is when you need
    to juggle multiple points of I/O, like servers. But sometimes you just want to
    execute commands one after another without the overhead. Let’s look at that next.
  id: totrans-2315
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了异步子进程执行，这是当你需要处理多个 I/O 点时的情况，比如服务器。但有时你只是想依次执行命令，而不需要额外的开销。让我们看看下一个例子。
- en: 8.3\. Working synchronously
  id: totrans-2316
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3\. 同步工作
- en: Non-blocking I/O is important for keeping the event loop humming along without
    having to wait for an unwieldy child process to finish. However, it has extra
    coding overhead that isn’t pleasant when you want things to block. A good example
    of this is writing shell scripts. Thankfully, synchronous child processes are
    also available.
  id: totrans-2317
  prefs: []
  type: TYPE_NORMAL
  zh: 非阻塞 I/O 对于保持事件循环流畅运行至关重要，无需等待一个难以管理的子进程完成。然而，当你想要阻塞时，它有额外的编码开销，这并不愉快。一个很好的例子是编写
    shell 脚本。幸运的是，同步子进程也是可用的。
- en: Technique 63 Synchronous child processes
  id: totrans-2318
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 技巧 63 同步子进程
- en: 'Synchronous child process methods are recent additions to the Node scene. They
    were first introduced in Node 0.12 to address a very real problem in a performant
    and familiar manner: shell scripting. Before Node 0.12, clever but nonperformant
    hacks were used to get synchronous-like behavior. Now, synchronous methods are
    a first-class citizen.'
  id: totrans-2319
  prefs: []
  type: TYPE_NORMAL
  zh: 同步子进程方法是Node场景中的新加入功能。它们首次在Node 0.12版本中引入，以高效且熟悉的方式解决了一个非常实际的问题：shell脚本。在Node
    0.12之前，使用了一些巧妙但性能不佳的技巧来获得类似同步的行为。现在，同步方法成为了一等公民。
- en: In this technique we’ll cover all the synchronous methods available in the child
    process modules.
  id: totrans-2320
  prefs: []
  type: TYPE_NORMAL
  zh: 在这项技术中，我们将涵盖子进程模块中所有可用的同步方法。
- en: Problem
  id: totrans-2321
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 问题
- en: You want to execute commands synchronously.
  id: totrans-2322
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要同步执行命令。
- en: Solution
  id: totrans-2323
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use `execFileSync`, `spawnSync`, and `execFile`.
  id: totrans-2324
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`execFileSync`、`spawnSync`和`execFile`。
- en: Discussion
  id: totrans-2325
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 讨论
- en: By now, we hope these synchronous methods look extremely familiar. In fact,
    they’re the same in their function signatures and purpose as we’ve discussed previously
    in this chapter, with one important distinction—*they block and run to completion*
    when called.
  id: totrans-2326
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们希望这些同步方法看起来非常熟悉。实际上，它们在函数签名和目的上与我们在本章之前讨论的相同，只有一个重要区别——*当被调用时，它们会阻塞并运行到完成*。
- en: 'If you just want to execute a single command and get output synchronously,
    use `execFileSync`:'
  id: totrans-2327
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只想同步执行单个命令并获取输出，请使用`execFileSync`：
- en: '![](192fig01_alt.jpg)'
  id: totrans-2328
  prefs: []
  type: TYPE_IMG
  zh: '![图片](192fig01_alt.jpg)'
- en: 'If you want to execute multiple commands synchronously and programmatically
    where the input of one depends on the output of another, use `spawnSync`:'
  id: totrans-2329
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要同步执行多个命令，并且一个命令的输入依赖于另一个命令的输出，请使用`spawnSync`：
- en: '![](193fig01_alt.jpg)'
  id: totrans-2330
  prefs: []
  type: TYPE_IMG
  zh: '![图片](193fig01_alt.jpg)'
- en: 'The resulting synchronous child process contains a lot of detail of what happened,
    which is another advantage of using `spawnSync`:'
  id: totrans-2331
  prefs: []
  type: TYPE_NORMAL
  zh: 结果同步子进程包含发生了很多细节，这是使用`spawnSync`的另一个优点：
- en: '![](193fig02_alt.jpg)'
  id: totrans-2332
  prefs: []
  type: TYPE_IMG
  zh: '![图片](193fig02_alt.jpg)'
- en: 'Lastly, there’s `execSync`, which executes a subshell synchronously and runs
    the commands given. This can be handy when writing shell scripts in JavaScript:'
  id: totrans-2333
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，还有`execSync`，它以同步方式执行子shell并运行给定的命令。当在JavaScript中编写shell脚本时，这可能会很有用：
- en: '![](193fig03_alt.jpg)'
  id: totrans-2334
  prefs: []
  type: TYPE_IMG
  zh: '![图片](193fig03_alt.jpg)'
- en: 'This will output the following:'
  id: totrans-2335
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出以下内容：
- en: '![](194fig01_alt.jpg)'
  id: totrans-2336
  prefs: []
  type: TYPE_IMG
  zh: '![图片](194fig01_alt.jpg)'
- en: Error handing with synchronous child process methods
  id: totrans-2337
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用同步子进程方法进行错误处理
- en: 'If a non-zero exit status is returned in `execSync` or `execFileSync`, an exception
    will be thrown. The error object will include everything we saw returned using
    `spawnExec`. We’ll have access to important things like the status code and `stderr`
    stream:'
  id: totrans-2338
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`execSync`或`execFileSync`返回非零退出状态，将会抛出异常。错误对象将包括我们使用`spawnExec`返回的所有内容。我们将能够访问重要信息，如状态码和`stderr`流：
- en: '![](194fig02_alt.jpg)'
  id: totrans-2339
  prefs: []
  type: TYPE_IMG
  zh: '![图片](194fig02_alt.jpg)'
- en: 'This program yields the following output:'
  id: totrans-2340
  prefs: []
  type: TYPE_NORMAL
  zh: 该程序产生以下输出：
- en: '[PRE102]'
  id: totrans-2341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: We talked errors in `execFile` and `execFileSync`. What about `spawnSync`? Since
    `spawnSync` returns everything that happens when running the process, it doesn’t
    throw an exception. Therefore, you’re responsible to check the success or failure.
  id: totrans-2342
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了`execFile`和`execFileSync`中的错误处理。那么`spawnSync`呢？由于`spawnSync`返回运行进程时发生的所有内容，它不会抛出异常。因此，你需要负责检查成功或失败。
- en: 8.4\. Summary
  id: totrans-2343
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.4. 摘要
- en: 'In this chapter you learned to integrate different uses of external applications
    in Node by using the `child_process` module. Here are some tips in summary:'
  id: totrans-2344
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何通过使用`child_process`模块在Node中集成外部应用程序的不同用法。以下是一些总结性的提示：
- en: Use `execFile` in cases where you just need to execute an external application.
    It’s fast, simple, and safer when dealing with user input.
  id: totrans-2345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你只需要执行外部应用程序时，使用`execFile`。它快速、简单，并且在与用户输入交互时更安全。
- en: Use `spawn` when you want to do something more with the I/O of the child process,
    or when you expect the process to have a large amount of output. It provides a
    nice streamable interface, and is also safer when dealing with user input.
  id: totrans-2346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你想对子进程的I/O做更多操作，或者当你预期进程会有大量输出时，使用`spawn`。它提供了一个很好的可流式接口，并且在与用户输入交互时也更安全。
- en: Use `exec` when you want to access your shell’s facilities (pipes, redirects,
    blobs). Many shells allow running multiple applications in one go. Be careful
    with user input though, as it’s never a good idea to put untrusted input into
    an `exec` call.
  id: totrans-2347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你想访问你的shell功能（管道、重定向、大块数据）时，使用`exec`。许多shell允许一次性运行多个应用程序。但是，在使用用户输入时要小心，因为将不受信任的输入放入`exec`调用中从不是个好主意。
- en: Use `fork` when you want to run a Node module as a separate process. This enables
    computation and file descriptor handling (like an incoming socket) to be handled
    off the main Node process.
  id: totrans-2348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你想将 Node 模块作为独立进程运行时，请使用 `fork`。这允许计算和文件描述符处理（如传入套接字）由主 Node 进程之外处理。
- en: Detach `spawn`ed processes you want to survive after a Node process dies. This
    allows Node to be used to set up long-running processes and let them live on their
    own.
  id: totrans-2349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `spawn` 生成的进程分离，以便在 Node 进程死亡后它们仍能存活。这允许 Node 被用来设置长时间运行的过程，并让它们独立运行。
- en: Pool a cluster of Node processes and use the built-in IPC channel to save the
    overhead of starting and destroying processes on every `fork`. This is useful
    for building computational clusters of Node processes.
  id: totrans-2350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将一组 Node 进程池化，并使用内置的 IPC 通道来节省每次 `fork` 时启动和销毁进程的开销。这对于构建 Node 进程的计算集群非常有用。
- en: This concludes our dive into Node fundamentals. We focused on specific core
    module functionality, focusing on idiomatic Node principals. In the next section,
    our focus will expand beyond core concepts into real-world development recipes.
  id: totrans-2351
  prefs: []
  type: TYPE_NORMAL
  zh: 这标志着我们对 Node 基础知识的深入探究结束。我们专注于特定的核心模块功能，关注 Node 的惯用原则。在下一节中，我们的关注点将扩展到核心概念之外，进入现实世界的开发食谱。
