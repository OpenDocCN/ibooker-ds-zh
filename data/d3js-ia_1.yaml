- en: Part 2\. Complex data visualization
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第二部分\. 复杂数据可视化
- en: The next three chapters deal with the three families of data visualization that
    fall under the auspices of “complex” data visualization. These three forms—hierarchical,
    network, and geospatial—all vary from traditional numerical data visualization
    in that they try to encode something besides numerical precision. You will hear,
    when presenting data in this way, more resistance to these forms in industry,
    because your audience assumes that numerical precision is the only reason for
    data visualization. This is often expressed as “show me the data,” when the data
    itself has no raw form. Data visualization is about how we decide to surface insights,
    and those insights cannot all be shown with one chart type. As a result, your
    decision to preference the network structure will cause the geospatial patterns
    to suffer, the same way your decision to show the numerical structure will cause
    the hierarchical patterns to suffer. In [chapter 6](../Text/kindle_split_016.html#ch06)
    we start with hierarchical data visualization, which is the representation of
    how data is nested into categories and bands. [Chapter 7](../Text/kindle_split_017.html#ch07)
    deals with network data visualization, which emphasizes the relationships between
    data. [Chapter 8](../Text/kindle_split_018.html#ch08) deals with geospatial data
    visualization and therefore focuses on how spatial distribution influences the
    pattern of the data.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的三章将处理属于“复杂数据可视化”范畴下的三个数据可视化家族。这三种形式——分层、网络和地理空间——都与传统的数值数据可视化不同，因为它们试图编码除了数值精度之外的东西。当以这种方式展示数据时，你会在行业中听到对这些形式的更多抵制，因为你的观众假设数值精度是数据可视化的唯一原因。这通常表现为“给我看数据”，当数据本身没有原始形式时。数据可视化关乎我们如何决定呈现洞察力，而这些洞察力不能都通过一种图表类型来展示。因此，你偏好网络结构的选择将导致地理空间模式受损，就像你选择展示数值结构将导致分层模式受损一样。在第[6章](../Text/kindle_split_016.html#ch06)中，我们从分层数据可视化开始，这是数据如何嵌套到类别和波段中的表示。[第7章](../Text/kindle_split_017.html#ch07)处理网络数据可视化，强调数据之间的关系。[第8章](../Text/kindle_split_018.html#ch08)处理地理空间数据可视化，因此关注空间分布如何影响数据的模式。
- en: Chapter 6\. Hierarchical visualization
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第6章\. 分层可视化
- en: '*This chapter covers*'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Understanding hierarchical data principles
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解分层数据原则
- en: Using dendrograms
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用树状图
- en: Learning about circle packs
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解圆形打包
- en: Working with treemaps
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用树形图
- en: Employing partitions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用分区
- en: Complex data visualization is defined by its encoding of data types other than
    numerical data. We’ll start with dealing with hierarchical data, which encodes
    how things are related to other things, whether through dependency, lineage, or
    categorization. There are four different layouts we’ll look at in this chapter,
    each of which uses different methods to show a node and indicate the parent-child
    relationships between those nodes. For two of those charting methods—circle packing
    and treemaps—the way we signal parent-child relationship is via *enclosure*, which
    is to say that the parent graphical mark is drawn around the child graphical mark.
    In the other two charts, parent-child relationship is signaled by *adjacency*
    (in the case of the partition layout) or via *connection* (using lines in the
    dendrogram). See [figure 6.1](#ch06fig01).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂数据可视化由其编码的数据类型定义，这些数据类型除了数值数据之外。我们将从处理分层数据开始，这种数据编码了事物之间如何相互关联，无论是通过依赖、血统还是分类。本章我们将探讨四种不同的布局，每种布局都使用不同的方法来展示节点，并指示这些节点之间的父子关系。对于这两种图表方法——圆形打包和树形图——我们通过*包含*来表示父子关系，也就是说，父图形标记被绘制在子图形标记周围。在其他两种图表中，父子关系通过*相邻*（在分区布局的情况下）或通过*连接*（使用树状图中的线条）来表示。参见[图6.1](#ch06fig01)。
- en: Figure 6.1\. Some of the hierarchical diagrams we’ll look at in this chapter.
    The dendrogram (left), the icicle chart (middle), and a treemap (right) showing
    a radial projection that’s popular with hierarchical diagrams.
  id: totrans-10
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.1\. 本章我们将探讨的一些分层图。树状图（左），冰柱图（中），以及一个树形图（右），展示了一个在分层图中流行的径向投影。
- en: '![](../Images/06fig01_alt.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/06fig01_alt.jpg)'
- en: 6.1\. Hierarchical patterns
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.1\. 分层模式
- en: When you’re designing and building data visualization products, it’s easy to
    think about visualizing numerical data. We grew up learning about bar charts and
    line charts, and the people we build dashboards and data visualization for are
    used to seeing them. When most people talk about data, they mean numerical data,
    and when they talk about data visualization, they mean visualizing numerical data
    so that they can precisely measure the heights and slopes and differences. It
    can be a tough sell to tell them that you want to obscure the numerical precision
    of the data in favor of showing other patterns. That’s one of the challenges of
    using complex data visualization like hierarchical layouts and one that you’re
    going to have to tackle head on.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 当你设计和构建数据可视化产品时，很容易想到可视化数值数据。我们在学习条形图和折线图的过程中长大，而我们为构建仪表板和数据可视化的人习惯于看到它们。当大多数人谈论数据时，他们指的是数值数据，当他们谈论数据可视化时，他们指的是可视化数值数据，以便他们可以精确地测量高度、斜率和差异。告诉他们你希望为了显示其他模式而模糊数据的数值精度可能很难说服他们。这就是使用复杂数据可视化（如层次布局）的挑战之一，你将不得不直面这个挑战。
- en: 'Hierarchical data, which is any data that maps the parent to child relationships,
    exists in every system: people in family trees, business org charts, and even
    categories like the food pyramid. If you only show the numerical patterns, then
    the best charts you can use are the ones that encode using length, which means
    bar charts and line charts. But if you only make decisions based on what you can
    measure with bar charts and line charts, then you hamstring your organization.
    A classic example of the value of hierarchical data visualization comes from data
    dashboards with their innumerable filters.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 层次化数据，即任何将父级映射到子级关系的数据，存在于每个系统中：家谱中的人，商业组织结构图，甚至是像食物金字塔这样的类别。如果你只展示数值模式，那么你可以使用的最佳图表是使用长度编码的图表，这意味着条形图和折线图。但如果你只基于条形图和折线图可以衡量的内容做出决策，那么你将削弱你的组织。层次化数据可视化的价值的一个经典例子来自具有无数筛选器的数据仪表板。
- en: 'A/B testing is used everywhere now, and visualization of A/B test results is
    a key requirement of data visualization. The people using those A/B testing visualizations
    are obsessed with numbers, particularly the scores that a test gets across a set
    of key metrics, which is almost always tied to another number: the statistical
    significance between that cell’s score and the control cell’s score. Imagine an
    A/B testing dashboard for your data visualization firm that shows test results
    and which you could slice and dice by country, gender, or the subscription level
    of the user. Your latest test rolls out changes to user experience so that certain
    clients get all their results as pie charts, while other clients only get results
    in animated gifs.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: A/B测试现在无处不在，A/B测试结果的可视化是数据可视化的一个关键要求。使用这些A/B测试可视化的人对数字着迷，尤其是测试在一系列关键指标上获得的分数，这几乎总是与另一个数字相关：该单元格的分数与控制单元格的分数之间的统计显著性。想象一下，为你的数据可视化公司设计一个A/B测试仪表板，它显示了测试结果，你可以通过国家、性别或用户的订阅级别来切片和切块。你最新的测试推出了用户体验的改变，以便某些客户可以以饼图的形式获得所有结果，而其他客户只能以动画GIF的形式获得结果。
- en: Let’s put the results of each test cell on a tabular chart, with the change
    in each metric so people can see the numbers. We’ll use color to highlight whether
    a particular metric in a particular cell is a “win” or a “loss” because, hey,
    we’re data visualization professionals. Here you can see how the test cells did
    in a traditional tabular view ([figure 6.2](#ch06fig02)). Looks like GIFs everywhere
    is the right way to go, right?
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把每个测试单元的结果放在表格图表上，展示每个指标的变化，这样人们可以直观地看到数字。我们将使用颜色来突出显示特定单元格中特定指标是“成功”还是“失败”，因为，嘿，我们是数据可视化专业人士。在这里，你可以看到测试单元在传统表格视图中的表现（[图6.2](#ch06fig02)）。看起来到处都是GIF是正确的方向，对吧？
- en: Figure 6.2\. Typical A/B testing results in a tabular view, showing several
    metrics and the change versus the control cell. Positive changes are denoted with
    a plus symbol, and statistically significant changes are shown with green for
    a statistically signficant positive change and orange for a statistically significant
    negative change.
  id: totrans-17
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.2\. 表格视图中的典型A/B测试结果，显示了多个指标以及与控制单元的变化。正变化用加号表示，统计上显著的变化用绿色表示统计上显著的正面变化，用橙色表示统计上显著的负面变化。
- en: '![](../Images/06fig02.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/06fig02.jpg)'
- en: If we nest the test results hierarchically, we can’t use a data visualization
    that shows numeric values well. We’ll be left with the color we were using to
    encode statistically significant wins and losses in metrics. But though we lose
    numerical precision, we gain the ability to see the pattern of wins and losses
    across our dimensions. Three cells, 4 subscription categories, 20 countries, 5
    metrics = 1200 different combinations. That would be a pretty long table, but
    in a hierarchical data visualization like a circle pack, it looks like [figure
    6.3](#ch06fig03).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将测试结果分层嵌套，我们就无法使用能够很好地显示数值的数据可视化。我们将只剩下我们用来编码统计上显著的胜负的颜色。尽管我们失去了数值精度，但我们获得了看到胜负模式的能力。三个单元格，4个订阅类别，20个国家，5个指标
    = 1200种不同的组合。这将是一个相当长的表格，但在像圆形包这样的分层数据可视化中，它看起来就像[图6.3](#ch06fig03)。
- en: Figure 6.3\. A circle pack of A/B testing results, showing the nested results
    by cell, metric, subscription level, and country. Green shows statistically significant
    wins, and orange shows statistically significant losses.
  id: totrans-20
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.3\. A/B测试结果的圆形包，按单元格、指标、订阅级别和国家显示嵌套结果。绿色表示统计上显著的胜利，橙色表示统计上显著的失败。
- en: '![](../Images/06fig03.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/06fig03.jpg)'
- en: This kind of quick overview gives us a sense of the hierarchical pattern in
    the wins and losses. Each black circle represents a cell, the control cell is
    in the top left, the top right is our Only Pie Charts cell, and the bottom circle
    is our GIFs Everywhere cell. We can see that like our summary table, it’s clear
    that Only Pie Charts isn’t working across countries or subscription levels, but
    it does seem like GIFs Everywhere has more losses than we might expect. It also
    highlights one of the issues we need to address when deploying hierarchical data
    visualization, the order of the hierarchy can highlight or obscure patterns.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这种快速概览让我们对胜负的分层模式有了感觉。每个黑色圆圈代表一个单元格，控制单元格位于左上角，右上角是我们的“只有饼图”单元格，底部圆圈是我们的“到处都是GIF”单元格。我们可以看到，就像我们的总结表一样，很明显“只有饼图”在国家和订阅级别上不起作用，但似乎“到处都是GIF”的损失比我们预期的要多。它还突出了我们在部署分层数据可视化时需要解决的一个问题，即层次结构的顺序可能会突出或隐藏模式。
- en: If we order the hierarchy differently and put countries under cells, we get
    a more interesting pattern ([figure 6.4](#ch06fig04)).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们改变层次结构的顺序并将国家放在单元格下面，我们会得到一个更有趣的模式([图6.4](#ch06fig04))。
- en: Figure 6.4\. Hierarchical viz of A/B testing results ordered by cell, country,
    subscription, and then metric
  id: totrans-24
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.4\. 按单元格、国家、订阅和指标排序的A/B测试结果的分层可视化
- en: '![](../Images/06fig04.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/06fig04.jpg)'
- en: Although this doesn’t change our view of Only Pie Charts, which is still a miserable
    failure (Sorry, Robert!^([[1](#ch06fn01)])), we can see that the GIFs Everywhere
    losses seem to map to certain countries. They should. When I built the model that
    generated this random data, I made sure that Only Pie Charts showed statistically
    significant losses across the board, whereas GIFs Everywhere was supposed to be
    a success in certain countries, bad in others, and a wash otherwise. In a traditional
    dashboard, maybe an analyst would have stumbled on this by filtering down to those
    countries, or maybe they would have seen the overall success (you showed them
    the numbers, after all, the way they wanted) and rolled out the new features,
    even though it could have caused critical damage to your firm’s success in some
    of those countries.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这并没有改变我们对“只有饼图”的看法，它仍然是一个悲惨的失败（抱歉，Robert！^([[1](#ch06fn01)]))，但我们可以看到“到处都是GIF”的损失似乎与某些国家相对应。它们应该如此。当我构建生成这些随机数据的模型时，我确保“只有饼图”在所有方面都显示出统计上显著的损失，而“到处都是GIF”则应该在某些国家取得成功，在其他国家表现不佳，在其他情况下则是一无所获。在一个传统的仪表板上，分析师可能通过筛选到那些国家来偶然发现这一点，或者他们可能看到了整体的成功（毕竟，你向他们展示了数字，这是他们想要的）并推出了新功能，尽管这可能会在某些国家对你公司的成功造成关键损害。
- en: ¹
  id: totrans-27
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-28
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Robert Kosara, chief scientist at Tableau, published a famous paper saying that
    pie charts aren’t so bad. See [https://eagereyes.org/pie-charts](https://eagereyes.org/pie-charts).
  id: totrans-29
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Tableau的首席科学家Robert Kosara发表了一篇著名的论文，称饼图并不那么糟糕。见[https://eagereyes.org/pie-charts](https://eagereyes.org/pie-charts)。
- en: 6.2\. Working with hierarchical data
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2\. 与分层数据一起工作
- en: 'In order to make hierarchical data visualization products, we need hierarchical
    data. While hierarchical data is everywhere, D3 expects it in a particular format
    for its hierarchical layouts. That formatting is accomplished by using `d3.hierarchy`
    and passing to `d3.hierarchy` a hierarchical JavaScript object along with settings
    for how the child nodes are accessed and any numerical value assigned to the nodes.
    Let’s assume that we have hierarchical data that looks like this:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了制作层次化数据可视化产品，我们需要层次化数据。虽然层次化数据无处不在，但D3期望它以特定的格式用于其层次布局。这种格式化是通过使用 `d3.hierarchy`
    并将层次化JavaScript对象以及如何访问子节点和分配给节点的任何数值设置传递给 `d3.hierarchy` 来实现的。假设我们有一些看起来像这样的层次化数据：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We’d need to pass that data to `d3.hierarchy` to create the kind of hierarchical
    data that D3 expects for its hierarchical layouts:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将那些数据传递给 `d3.hierarchy` 来创建D3期望用于其层次布局的层次化数据：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The resulting object is extended to include methods for each of the nodes that
    allow you to access descendants and ancestors so that you can filter your hierarchical
    data easily in tandem or separate from passing it to hierarchical layouts.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的对象扩展了包含每个节点的方法，允许你访问后代和祖先，这样你就可以轻松地对层次化数据进行过滤，或者在与层次布局传递时分离。
- en: 6.2.1\. Hierarchical JSON and hierarchical objects
  id: totrans-36
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.2.1\. 层次化JSON和层次化对象
- en: '*Hierarchical JSON* or *hierarchical objects* refer to any JSON or JavaScript
    object that acts as a root node with properties (typically called *children* or
    *values*) that are arrays of more objects, typically with the same properties
    as the root node. In hierarchical terminology, the *root* node is the top-most
    parent, and a *leaf* node is a child with no children.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*层次化JSON* 或 *层次化对象* 指的是任何作为根节点具有属性（通常称为 *children* 或 *values*）的JSON或JavaScript对象，这些属性是更多对象的数组，通常具有与根节点相同的属性。在层次化术语中，*根*
    节点是最高级的父节点，而 *叶* 节点是没有子节点的子节点。'
- en: 6.2.2\. D3.nest
  id: totrans-38
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.2.2\. D3.nest
- en: We’ve seen `d3.nest` many times already, where we’ve used it to flatten data.
    The other use, which reflects the name of the function, is to create hierarchical
    datasets out of flat data. If, for instance, we had an array of objects that looked
    like this
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经多次看到 `d3.nest` 的使用，我们用它来扁平化数据。另一种用途反映了函数的名称，即从扁平数据中创建层次化数据集。例如，如果我们有一个看起来像这样的对象数组
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: and we passed that array to a `d3.nest` function that referenced all of its
    categorical attributes as keys, like this
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 并且我们将这个数组传递给一个 `d3.nest` 函数，该函数将其所有分类属性作为键，如下所示
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: the result would be nested hierarchical JavaScript object almost ready to be
    visualized by a D3 hierarchical layout. The only step remaining is that we want
    a hierarchical object and `d3.nest` returns an array, so we need to put the results
    of the array inside an object, as you’ll see in all the following examples.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将是一个嵌套的层次化JavaScript对象，几乎可以直接由D3层次布局可视化。唯一剩下的步骤是我们想要一个层次化对象，而 `d3.nest` 返回一个数组，因此我们需要将数组的输出放入一个对象中，正如你将在所有后续示例中看到的那样。
- en: 6.2.3\. D3.stratify
  id: totrans-44
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.2.3\. D3.stratify
- en: 'Version 4 of D3 introduces a new piece of functionality for building hierarchical
    data from tabular data: `d3.stratify`. Much of our hierarchical data comes in
    the form of tabular data indicating the parent-child relationship via columns.
    Let’s say you downloaded your family tree from your favorite genealogy package
    and it gave you data that looked like the following listing.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: D3的第四版引入了从表格数据构建层次化数据的新功能：`d3.stratify`。我们的大部分层次化数据都是以表格数据的形式出现，通过列来表示父子关系。假设你从你最喜欢的家谱软件中下载了你的家谱，并得到了如下所示的数据。
- en: Listing 6.1\. Some common hierarchical data in tabular format
  id: totrans-46
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.1\. 表格格式中的一些常见层次化数据
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You could pass this data to a `d3.stratify` function formatted like this:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将这些数据传递给一个格式如下 `d3.stratify` 函数：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'And it will give you back a hierarchy with “you” as the root node. I know what
    you’re thinking: “You’re setting the `parentID` as the child—your example dataset
    is backward.” But it’s not; I formatted it like that on purpose because I want
    to highlight that in a hierarchical dataset, the parent refers to the hierarchical
    parent, and it has to terminate at a single node. In this case, because the family
    tree grows out from “you” that makes “you” the root node and “your mom” and “your
    dad” as the first child nodes of that root node. If you want to represent hierarchies
    that don’t terminate in a single node, you’ll have to wait for [chapter 7](../Text/kindle_split_017.html#ch07)
    and use network visualization techniques.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 它将返回一个以“你”为根节点的层次结构。我知道你在想什么：“你将`parentID`设置为子节点——你的示例数据集是反向的。”但这不是；我故意这样格式化，因为我想要强调在层次化数据集中，父节点指的是层次化父节点，并且它必须终止在单个节点上。在这种情况下，因为家谱从“你”开始，所以“你”成为根节点，“你的妈妈”和“你的爸爸”成为该根节点的第一个子节点。如果你想表示不以单个节点终止的层次结构，你将不得不等待第7章，并使用网络可视化技术。
- en: 6.3\. Pack layouts
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.3\. 布局排列
- en: Hierarchical data is amenable to an entire family of layouts. One of the most
    popular is circle packing, shown in [figure 6.5](#ch06fig05). Each object is placed
    graphically inside the hierarchical parent of that object. You can see the hierarchical
    relationship. As with all hierarchical layouts, the pack layout expects a data
    representation of data that may not align with the data you’re working with. Specifically,
    pack expects a JavaScript object array where the child elements in a hierarchy
    are stored in a children attribute that points to an array. In examples of layout
    implementations on the web, the data is typically formatted to match the expected
    data format. In our case, we’d format our tweets like [figure 6.5](#ch06fig05).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 层次化数据适合于一系列布局。其中最受欢迎的是圆圈排列，如图6.5所示。每个对象都放置在该对象层次结构的父级中。你可以看到层次关系。与所有层次布局一样，布局排列期望的数据表示可能与您正在处理的数据不匹配。具体来说，布局排列期望一个JavaScript对象数组，其中层次结构中的子元素存储在一个指向数组的`children`属性中。在网页上布局实现的示例中，数据通常格式化为与期望的数据格式相匹配。在我们的情况下，我们将推文格式化为图6.5所示。
- en: Figure 6.5\. Pack layouts are useful for representing nested data. They can
    be flattened (top) or they can visually represent hierarchy (bottom).
  id: totrans-53
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.5\. 布局排列对于表示嵌套数据很有用。它们可以是平铺的（顶部）或者可以直观地表示层次结构（底部）。
- en: '![](../Images/06fig05.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/06fig05.jpg)'
- en: But it’s better to get accustomed to adjusting the accessor function of `d3.hierarchy`
    to match our data. This doesn’t mean we don’t have to do any data formatting when
    we use `d3.nest`, for instance, or get our data from an external source where
    child nodes are denoted by another key.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 但最好习惯于调整`d3.hierarchy`的访问器函数以匹配我们的数据。这并不意味着我们在使用`d3.nest`时不需要进行任何数据格式化，例如，或者从外部源获取数据，其中子节点由另一个键表示。
- en: 6.3.1\. Drawing the circle pack
  id: totrans-56
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.3.1\. 绘制圆圈排列
- en: We still need to create a root node for circle packing to work (what’s referred
    to as “All Tweets” in the previous code). But we’ll adjust the accessor function
    to match the structure of the data as it’s represented in `nestedTweets`, which
    stores the child elements on the `values` key. In the following listing, we also
    update the `.sum()` method that determines the size of circles and set it to a
    fixed value, as shown in [figure 6.6](#ch06fig06).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然需要创建一个根节点，以便布局排列能够工作（在之前的代码中称为“所有推文”）。但我们将调整访问器函数以匹配`nestedTweets`中数据表示的结构，其中子元素存储在`values`键上。在下面的列表中，我们还更新了`.sum()`方法，该方法确定圆圈的大小，并将其设置为固定值，如图6.6所示。
- en: Figure 6.6\. Each tweet is represented by a green circle nested inside an orange
    circle that represents the user who made the tweet. One of those green circles
    is exactly the same size as its parent orange circle, which we address below.
    The users are all nested inside a blue circle that represents our “root” node.
  id: totrans-58
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.6\. 每条推文都由一个嵌套在代表发推用户的橙色圆圈内的绿色圆圈表示。其中有一个绿色圆圈的大小与其父橙色圆圈完全相同，我们将在下面讨论。用户都嵌套在一个代表我们的“根”节点的蓝色圆圈内。
- en: '![](../Images/06fig06.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/06fig06.jpg)'
- en: Listing 6.2\. Circle packing of nested tweets data
  id: totrans-60
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.2\. 嵌套推文数据的圆圈排列
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '***1* Puts the array that d3.nest creates inside a “root” object that acts
    as the top-level parent**'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将d3.nest创建的数组放入一个充当顶级父级的“根”对象中**'
- en: '***2* Initialize the pack layout**'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 初始化布局排列**'
- en: '***3* Sets the size of the circle-packing chart**'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 设置圆打包图表的大小**'
- en: '***4* Process the hierarchy with an accessor function for child elements to
    look for values, which matches the data created by d3.nest**'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 使用子元素访问器函数处理层次结构以查找值，这与d3.nest创建的数据相匹配**'
- en: '***5* Creates a function that returns 1 when determining the size of leaf nodes**'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 创建一个在确定叶节点大小时返回1的函数**'
- en: '***6* Processes the hierarchy with the pack layout and then flattens it using
    descendants to get a flattened array**'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 使用打包布局处理层次结构，然后使用后代将其展平以获得一个扁平数组**'
- en: '***7* Radius and xy coordinates are all computed by the pack layout**'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 半径和xy坐标都是由打包布局计算的**'
- en: '***8* The pack layout also gives each node a depth attribute that we can use
    to color them distinctly by depth**'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8* 打包布局还给了每个节点一个深度属性，我们可以使用它来根据深度区分它们的颜色**'
- en: 'Keep in mind that the `.descendants` method of a node processed by `d3.hierarchy`
    is going to include the parent node that you’ve sent. Also, when the pack layout
    has a single child (as in the case of Sam, who only made one tweet), the size
    of the child node is the same as the size of the parent. This can visually seem
    like Sam is at the same hierarchical level as the other Twitter users who made
    more tweets. To correct this, we can modify the pack layout’s padding method to
    set a padding around each circle:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '请记住，由`d3.hierarchy`处理的节点的`.descendants`方法将包括你发送的父节点。此外，当打包布局有一个单一子节点（如Sam只发了一条推文的情况）时，子节点的大小与父节点的大小相同。这在视觉上可能看起来Sam与其他发了更多推文的Twitter用户处于相同的层次级别。为了纠正这一点，我们可以修改打包布局的填充方法，为每个圆设置一个填充： '
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This will give you margins like you see in [figure 6.7](#ch06fig07). You can
    experiment with implementing padding as a function dependent on the depth of the
    node.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给你带来如图6.7中所示的外边距。你可以尝试实现一个作为节点深度函数的填充。
- en: Figure 6.7\. An example of a fixed margin based on hierarchical depth. We can
    create this by reducing the circle size of each node based on its computed depth
    value.
  id: totrans-73
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.7\. 基于层次深度的固定边距示例。我们可以通过根据每个节点的计算深度值减少节点圆的大小来创建它。
- en: '![](../Images/06fig07.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/06fig07.jpg)'
- en: I glossed over the `.sum()` setting of `d3.hierarchy` earlier. If you have a
    numerical measurement for your leaf nodes, you can use that measurement to set
    their size using `.sum()` and therefore influence the size of their parent nodes.
    In our case, we can base the size of our leaf nodes (tweets) on the number of
    favorites and retweets each has received (the same value we used in [chapter 4](../Text/kindle_split_013.html#ch04)
    as our “impact factor”). The results in [figure 6.8](#ch06fig08) reflect this
    new setting.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前简要地提到了`d3.hierarchy`的`.sum()`设置。如果你对你的叶节点有一个数值测量，你可以使用这个测量来使用`.sum()`设置它们的大小，从而影响它们父节点的大小。在我们的例子中，我们可以根据每个叶节点（推文）收到的点赞和转发数量（我们在[第4章](../Text/kindle_split_013.html#ch04)中用作“影响因子”的相同值）来设置我们叶节点的大小。图6.8中的结果反映了这个新设置。
- en: Figure 6.8\. A circle-packing layout with the size of the leaf nodes set to
    the impact factor of those nodes
  id: totrans-76
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.8\. 一个将叶节点大小设置为这些节点影响因子的圆打包布局
- en: '![](../Images/06fig08.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/06fig08.jpg)'
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '***1* Adds 1 so that tweets with no retweets or favorites still have a value
    greater than zero and are displayed along with checking to make sure it has a
    retweets property**'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 加1，以便没有转发或喜欢的推文仍然具有大于零的值，并且与检查以确保它具有转发属性一起显示**'
- en: Layouts, like generators and components, are amenable to method chaining. You’ll
    see examples where the settings and data are all strung together in long chains.
    As with the pie chart, you could assign interactivity to the nodes or adjust the
    colors, but this chapter focuses on the general structure of layouts. Notice that
    circle packing is similar to another hierarchical layout known as treemaps. *Treemaps*
    pack space more effectively because they’re built out of rectangles, but they
    can be harder to read. The next layout is another hierarchical layout, known as
    a *dendrogram*, that more explicitly draws the hierarchical connections in your
    data.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 布局，就像生成器和组件一样，适用于方法链。你将看到示例，其中设置和数据都连成了一条长链。与饼图一样，你可以将交互性分配给节点或调整颜色，但本章重点介绍布局的一般结构。请注意，圆打包与另一种称为树状图的已知层次布局相似。*树状图*通过矩形打包空间更有效，但它们可能更难阅读。下一个布局是另一种称为*系统发育树*的层次布局，它更明确地绘制了数据中的层次关系。
- en: 6.3.2\. When to use circle packing
  id: totrans-81
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.3.2\. 何时使用圆打包
- en: Circle packs don’t use space efficiently—there’s a lot of screen real estate
    that’s left outside of round objects being shown on rectangular screens. There’s
    also a big difference between the way you see a circle when it’s being used to
    enclose other circles versus when it’s floating there on its own. With that in
    mind, you should use circle packing when you’re trying to focus on the thing at
    the bottom of the circle pack, the leaf nodes, and how they’re sorted by the various
    categories you’ve nested them by, which will be all the other circles you see.
    Because circles are so bad at encoding numerical value with their radius, you
    should avoid anything where those leaf nodes encode size with any precision. The
    best circle packs have leaf nodes that map well to individual things of the same
    type and that we don’t think of as varying in size, like a person. While human
    beings do vary in size, they’re often put in charts represented by individual
    marks of the same size, like circles in a network diagram or little person icons
    in an infographic. But if you want to encode some value to each person, such as
    their wealth or number of D3.js books in their library, then you probably don’t
    want to use a circle pack.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 圆形包不高效地使用空间——在矩形屏幕上显示的圆形对象之外，有很多屏幕空间被浪费了。此外，当圆形被用来包围其他圆形时，与它单独漂浮在那里时，你所看到的圆形有很大的不同。考虑到这一点，当你试图关注圆形包底部的对象，即叶节点，以及它们如何根据你嵌套的各种类别进行排序时，你应该使用圆形包，这些叶节点将很好地映射到相同类型的单个对象，并且我们认为它们的大小没有变化，比如一个人。虽然人类的大小是不同的，但它们通常被放在图表中，用相同大小的标记表示，如网络图中的圆圈或信息图表中的人物图标。但如果你想要为每个人编码一些值，比如他们的财富或他们图书馆中的D3.js书籍数量，那么你可能不想使用圆形包。
- en: 6.4\. Trees
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.4\. 树
- en: Another way to show hierarchical data is to lay it out like a family tree, with
    the parent nodes connected to the child nodes in a dendrogram ([figure 6.9](#ch06fig09)).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 展示层次数据的另一种方法是将其布局成家谱树，父节点通过树状图连接到子节点（[图6.9](#ch06fig09)）。
- en: Figure 6.9\. Tree layouts are another useful method for expressing hierarchical
    relationships and are often laid out vertically (top), horizontally (middle),
    or radially (bottom). (Examples from Mike Bostock at [d3js.org](http://d3js.org).)
  id: totrans-85
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.9\. 树布局是表达层次关系的另一种有用方法，通常垂直（顶部）、水平（中部）或辐射（底部）布局。（来自Mike Bostock的[d3js.org](http://d3js.org)的示例。）
- en: '![](../Images/06fig09_alt.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/06fig09_alt.jpg)'
- en: 6.4.1\. Drawing a dendrogram
  id: totrans-87
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.4.1\. 绘制树状图
- en: The prefix *dendro* means “tree,” and in D3 the layout is `d3.tree`. It follows
    much the same setup as the pack layout, except that to draw the lines connecting
    the nodes, we need to use `svg:line` or `svg:path` elements. We process the data
    using `d3.nest` and `d3.hierarchy` in exactly the same manner as we do for the
    circle pack, and then use the code in the following listing to draw our first
    dendrogram.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 前缀*dendro*意味着“树”，在D3中布局是`d3.tree`。它遵循与包布局几乎相同的设置，除了为了绘制连接节点的线条，我们需要使用`svg:line`或`svg:path`元素。我们使用`d3.nest`和`d3.hierarchy`处理数据，与圆形包完全相同，然后使用以下列表中的代码绘制我们的第一个树状图。
- en: Listing 6.3\. Callback function to draw a dendrogram
  id: totrans-89
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.3\. 绘制树状图的回调函数
- en: '[PRE9]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '***1* Draw a <g> element for each node so we can put a circle in it now and
    add a label later**'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 为每个节点绘制一个<g>元素，这样我们就可以现在在其中放置一个圆圈，稍后添加标签**'
- en: '***2* Fill based on the depth calculated by d3.hierarchy**'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 基于d3.hierarchy计算的深度进行填充**'
- en: '***3* Add a white halo around each node to give the connecting lines an offset
    appearance**'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 在每个节点周围添加一个白色光环，以使连接线看起来有偏移效果**'
- en: '***4* Draw links using the same data except filter out any nodes that don’t
    have parents (which won’t have links)**'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 使用相同的数据绘制链接，但过滤掉任何没有父节点（将没有链接）的节点** '
- en: '***5* Draw the link ending at the child node location**'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 绘制以子节点位置结束的链接**'
- en: '***6* Draw the link starting at the parent node location**'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 从父节点位置开始绘制链接**'
- en: The resulting dendrogram shows the hierarchical structure of our tweets and
    tweeters using circles, like the circle pack, but using lines and rank position
    to indicate who the parents and children are as you can see in [figure 6.10](#ch06fig10)
    is a bit hard to read.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的树状图显示了我们的推文和推文作者的层次结构，使用圆形，就像圆形包一样，但使用线条和排名位置来指示父母和子女，如[图6.10](#ch06fig10)所示，读起来有点困难。
- en: Figure 6.10\. A dendrogram laid out vertically using data from tweets.json.
    The level 0 “root” node (which we created to contain the users) is in blue, the
    level 1 nodes (which represent users) are in orange, and the level 2 “leaf” nodes
    (which represent tweets) are in green.
  id: totrans-98
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.10\. 使用tweets.json中的数据垂直排列的树状图。级别0的“根”节点（我们创建它来包含用户）为蓝色，级别1的节点（代表用户）为橙色，级别2的“叶”节点（代表推文）为绿色。
- en: '![](../Images/06fig10.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/06fig10.jpg)'
- en: 'We can add labels pretty easily; the only thing we have to take into account
    is that the label for each node is going to be a different kind of data depending
    on which node in the hierarchy we’re labeling (the root node or one of the users
    or one of the individual tweets). Append a `<text>` element like so:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以很容易地添加标签；唯一需要注意的是，每个节点的标签将根据我们正在标记的层次结构中的节点类型而有所不同（根节点或用户之一或单个推文之一）。添加一个类似这样的`<text>`元素：
- en: '[PRE10]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You’ll get the results you see in [figure 6.11](#ch06fig11).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 你将得到[图6.11](#ch06fig11)中看到的结果。
- en: Figure 6.11\. A dendrogram with labels for each of the nodes
  id: totrans-103
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.11\. 为每个节点添加标签的树状图
- en: '![](../Images/06fig11.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/06fig11.jpg)'
- en: 'Because the tweet labels are the content of the tweet, it’s pretty hard to
    read the labels drawing the dendrogram vertically like that. To turn it on its
    side, we need to adjust the positioning of the `<g>` elements by flipping the
    x and y coordinates, which orients the nodes horizontally. We also need to flip
    the x1, x2, y1, and y2 references for the `svg:line` element to orient the lines
    horizontally:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 由于推文标签是推文的内容，所以以那种方式垂直绘制树状图的标签很难阅读。为了将其翻转，我们需要通过翻转x和y坐标来调整`<g>`元素的定位，从而使节点水平排列。我们还需要翻转`svg:line`元素的x1、x2、y1和y2引用，以使线条水平排列：
- en: '[PRE11]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The result, shown in [figure 6.12](#ch06fig12), is more legible because the
    text isn’t overlapping on the bottom of the canvas. But critical aspects of the
    chart are still drawn off the canvas without adjusting the margins of the container
    `<g>`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 结果，如[图6.12](#ch06fig12)所示，由于文本没有在画布底部重叠，因此更易于阅读。但图表的关键方面仍然在容器`<g>`的边距未调整的情况下绘制。
- en: Figure 6.12\. The same dendrogram as [figure 6.11](#ch06fig11) but laid out
    horizontally
  id: totrans-108
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.12\. 与[图6.11](#ch06fig11)相同的树状图，但水平排列
- en: '![](../Images/06fig12_alt.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/06fig12_alt.jpg)'
- en: We could try to create margins along the height and width of the layout as we
    did earlier. Or we could provide information about each node as an information
    box that opens when we click it, as with the soccer data. But a better option
    is to give the user the ability to drag the canvas up and down and left and right
    to see more of the visualization.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以尝试在布局的高度和宽度上创建边距，就像我们之前做的那样。或者，我们可以提供有关每个节点的信息，当点击时以信息框的形式打开，就像足球数据那样。但更好的选择是给用户拖动画布上下左右的能力，以便看到更多可视化内容。
- en: To do this, we use the D3 zoom behavior, `d3.zoom`, which creates a set of event
    listeners. A *behavior* is like a component, but instead of creating graphical
    objects, it registers events (in this case for drag, mousewheel, and double-click)
    and ties those events to the element that calls the behavior. With each of these
    events, a zoom object changes its `.translate()` and/or `.scale()` values to correspond
    to the traditional dragging and zooming interaction. You’ll use these changed
    values to adjust the position of graphical elements in response to user interaction.
    Like a component, the zoom behavior needs to be called by the element to which
    you want these events attached. Typically, you call the zoom from the base `<svg>`
    element because then it fires whenever you click anything in your graphical area.
    When creating the zoom component, you need to define what functions are called
    on *zoomstart*, *zoom*, and *zoomend*, which correspond (as you might imagine)
    to the beginning of a zoom event, the event itself, and the end of the event,
    respectively. Because zoom fires continuously as a user drags the mouse, you may
    want resource-intensive functions only at the beginning or end of the zoom event.
    You’ll see more complicated zoom strategies, as well as the use of scale, in [chapter
    8](../Text/kindle_split_018.html#ch08) when we look at geospatial mapping, which
    uses zooming extensively.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们使用 D3 缩放行为，`d3.zoom`，它创建一组事件监听器。*行为* 就像组件一样，但它不是创建图形对象，而是注册事件（在这种情况下为拖动、鼠标滚轮和双击）并将这些事件绑定到调用行为的元素上。在每个这些事件中，缩放对象都会改变其
    `.translate()` 和/或 `.scale()` 值，以对应传统的拖动和缩放交互。您将使用这些改变后的值来根据用户交互调整图形元素的位置。就像组件一样，缩放行为需要由您想要附加这些事件的元素调用。通常，您从基础
    `<svg>` 元素调用缩放，因为这样它会在您点击图形区域中的任何内容时触发。在创建缩放组件时，您需要定义在 *zoomstart*、*zoom* 和 *zoomend*
    时调用哪些函数，这些函数分别对应于缩放事件的开始、事件本身和事件的结束。由于缩放在用户拖动鼠标时会连续触发，您可能只想在缩放事件的开始或结束时调用资源密集型函数。当我们在第
    8 章[查看地理空间映射](../Text/kindle_split_018.html#ch08)时，您将看到更复杂的缩放策略以及缩放的使用，该章使用了大量的缩放。
- en: 'As with other components, to start a zoom component you create a new instance
    and set any attributes of it you may need. In our case, we only want the default
    zoom component, with the `zoom` event triggering a new function, `zoomed()`. This
    function changes the position of the `<g>` element that holds our chart and allows
    the user to drag it around:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 就像其他组件一样，要启动缩放组件，您需要创建一个新的实例并设置可能需要的任何属性。在我们的例子中，我们只想使用默认的缩放组件，其中 `zoom` 事件触发一个新的函数，`zoomed()`。这个函数改变包含我们图表的
    `<g>` 元素的位置，并允许用户拖动它：
- en: '[PRE12]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '***1* Creates a new zoom component**'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 创建一个新的缩放组件**'
- en: '***2* Keys the “zoom” event to the zoomed() function**'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将“缩放”事件绑定到 zoomed() 函数**'
- en: '***3* Calls our zoom component with the SVG canvas**'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 使用 SVG 画布调用我们的缩放组件**'
- en: '***4* Updating the <g> to set it to the same translate setting of the zoom
    component updates the position of the <g> and all its child elements**'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 将 <g> 更新为与缩放组件相同的平移设置，以更新 <g> 及其所有子元素的位置**'
- en: Now we can drag and pan our entire chart left and right and up and down. The
    ability to zoom and pan gives you powerful interactivity to enhance your charts.
    It may seem odd that you learned how to use something called *zoom* and haven’t
    even dealt with zooming in and out, but panning tends to be more universally useful
    with charts like these, whereas changing scale becomes a necessity when dealing
    with maps.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以拖动和缩放整个图表的左右和上下。缩放和平移的能力为您提供了强大的交互性，以增强您的图表。您可能觉得奇怪，您学习了如何使用名为 *缩放* 的东西，但甚至还没有处理过缩放和缩小，但平移对于这些图表来说通常更有用，而在处理地图时，改变比例则成为了一种必需。
- en: 6.4.2\. Radial tree diagrams
  id: totrans-119
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.4.2. 径向树形图
- en: 'We have other choices besides drawing our tree from top to bottom and left
    to right. If we tie the position of each node to an angle, we can draw our tree
    diagrams in a radial pattern. To make this work well, we need to reduce the size
    of our chart, because the radial drawing of a tree layout in D3 uses the size
    to determine the maximum radius, and is drawn out from the 0,0 point of its container
    like a `<circle>` element:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们除了从上到下、从左到右绘制树形图之外，还有其他选择。如果我们把每个节点的位置与一个角度绑定，我们就可以以辐射模式绘制我们的树形图。为了使这工作得更好，我们需要减小图表的大小，因为
    D3 中树布局的辐射绘制使用大小来确定最大半径，并从其容器的 0,0 点向外绘制，就像一个 `<circle>` 元素：
- en: '[PRE13]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'With these changes in place, we need to create a projection function to translate
    the xy coordinates into a radial coordinate system:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些变化到位后，我们需要创建一个投影函数，将xy坐标转换为径向坐标系：
- en: '[PRE14]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then we use that function to calculate new coordinates for our nodes and lines:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们使用该函数来计算节点和线条的新坐标：
- en: '[PRE15]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[Figure 6.13](#ch06fig13) shows the results of these changes.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '[图6.13](#ch06fig13)显示了这些变化的结果。'
- en: Figure 6.13\. The same dendrogram laid out in a radial manner.
  id: totrans-127
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.13\. 以径向方式布局的相同树状图。
- en: '![](../Images/06fig13.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/06fig13.jpg)'
- en: The dendrogram is a generic way of displaying information. It can be repurposed
    for menus or information you may not think of as traditionally hierarchical. One
    example ([figure 6.14](#ch06fig14)) is from the work of Jason Davies, who used
    the dendrogram functionality in D3 to create word trees. A few hierarchical structures
    that follow this pattern are genealogies, sentence trees, and decision trees.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 树状图是一种通用的信息显示方式。它可以被重新用于菜单或你可能不会认为是传统层次结构的信息。一个例子（[图6.14](#ch06fig14)）来自Jason
    Davies的工作，他使用D3中的树状图功能创建了词树。遵循这种模式的几个层次结构包括家谱、句子树和决策树。
- en: Figure 6.14\. Example of using a dendrogram in a word tree by Jason Davies ([www.jasondavies.com/wordtree/](http://www.jasondavies.com/wordtree/)).
  id: totrans-130
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.14\. Jason Davies使用树状图在词树中的示例（[www.jasondavies.com/wordtree/](http://www.jasondavies.com/wordtree/)）。
- en: '![](../Images/06fig14.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/06fig14.jpg)'
- en: 6.4.3\. d3.cluster vs d3.tree
  id: totrans-132
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.4.3\. d3.cluster与d3.tree的比较
- en: In this example we used the `d3.tree` layout. You can also use the `d3.cluster`
    layout, which forces leaf nodes to all be drawn at the same level. That’s not
    so apparent with our dataset, because all of our hierarchical data has the same
    depth (all the leaf nodes are depth 3) but with leaf nodes with uneven depth,
    like in [figure 6.15](#ch06fig15), you can see the difference between `d3.cluster`
    rendering and `d3.tree` rendering.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用了`d3.tree`布局。你也可以使用`d3.cluster`布局，它强制所有叶节点都在同一级别上绘制。在我们的数据集中，这一点并不明显，因为我们的所有层次数据都有相同的深度（所有叶节点都是深度3），但在像[图6.15](#ch06fig15)这样的叶节点深度不均匀的情况下，你可以看到`d3.cluster`渲染和`d3.tree`渲染之间的区别。
- en: Figure 6.15\. The same dataset rendered using `d3.tree` (left) and `d3.cluster`
    (right)
  id: totrans-134
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.15\. 使用`d3.tree`（左）和`d3.cluster`（右）渲染的相同数据集。
- en: '![](../Images/06fig15.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/06fig15.jpg)'
- en: As a general rule, you should use `d3.tree` unless you have a good reason for
    lining up all your leaf nodes on the same level. When you use `d3.cluster` you’re
    increasing the amount of ink you’re using to represent your links, even though
    those links aren’t any different in what they represent. This means your ink-to-data
    ratio is worse, and if you’re going to make your ink-to-data ratio worse, it better
    be for a good reason.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一般规则，你应该使用`d3.tree`，除非你有很好的理由将所有叶节点对齐到同一级别。当你使用`d3.cluster`时，你正在增加表示你的链接所使用的墨水量，尽管这些链接所代表的内容并没有任何不同。这意味着你的墨水与数据的比率更差，如果你要使墨水与数据的比率更差，那一定是有很好的理由。
- en: 6.4.4\. When to use dendrograms
  id: totrans-137
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.4.4\. 何时使用树状图
- en: In contrast to the circle pack, which emphasizes the leaf nodes, the dendrogram
    shows each node using the same symbology. The use of lines to demonstrate connections
    between the nodes places gives more visual structure to the lineage rather than
    the links or the nodes separately. Dendrograms should be used when each parent
    and child is of the same type (like a word or sentence fragment in a word tree)
    and the focus is on paths and forks in the path.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 与强调叶节点的圆包图相比，树状图使用相同的符号显示每个节点。使用线条来展示节点之间的连接，为谱系提供了更多的视觉结构，而不是单独的链接或节点。当每个父节点和子节点都是同一类型（如词树中的单词或句子片段）且焦点在于路径和路径的分支时，应使用树状图。
- en: 6.5\. Partition
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.5\. 分区
- en: I started this chapter by noting that most methods of representing hierarchical
    data don’t encode numerical data in a way that allows for precise comparison.
    One layout in D3 encodes parent and children nodes using length, and that’s the
    partition layout. *Partition* charts, commonly referred to as icicle charts, are
    like stacked bar charts.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我在本章开头指出，大多数表示层次数据的方法都没有以允许精确比较的方式编码数值数据。D3中的一个布局使用长度来编码父节点和子节点，这就是分区布局。*分区*图，通常被称为冰锥图，类似于堆叠条形图。
- en: 6.5.1\. Drawing an icicle chart
  id: totrans-141
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.5.1\. 绘制冰锥图
- en: As with the other hierarchical charts, we need to first nest and process our
    data using `d3.nest` and `d3.hierarchy`. Unlike with the dendrogram we should
    use the partition layout’s `sum` function to set the size of the individual pieces
    to reflect the value of the underlying data (as we did with the final circle pack
    piece). After we pass the processed data to `d3.partition`, we can draw the rectangles,
    as described in the following listing.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他分层图表一样，我们需要首先使用`d3.nest`和`d3.hierarchy`对数据进行嵌套和处理。与树状图不同，我们应该使用分区布局的`sum`函数来设置各个部分的大小，以反映底层数据的值（正如我们在最终的圆形布局部分所做的那样）。在将处理后的数据传递给`d3.partition`之后，我们可以绘制矩形，如下面的列表中所述。
- en: Listing 6.4\. Drawing a simple partition layout
  id: totrans-143
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.4\. 绘制简单的分区布局
- en: '[PRE16]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '***1* The code is all much the same as our earlier hierarchical layouts**'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 代码与我们的早期分层布局几乎完全相同**'
- en: '***2* Position is given back as a bounding box where the upper left corner
    in x0/y0**'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 位置以一个边界框的形式返回，其中左上角为x0/y0**'
- en: '***3* Size can be derived by subtracting the bottom right corner (x1/y1) from
    the upper left**'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 大小可以通过从右上角（x1/y1）减去左上角（x0/y0）来得出**'
- en: The result of that code is shown in [figure 6.16](#ch06fig16), which shows the
    nodes in our hierarchical dataset in a new visual metaphor. Instead of parents
    being connected to children by lines like we see with dendrograms, or being visually
    enclosed in their parent like the circle packing does, the parent is stacked on
    top of its children and has a length equal to the sum of lengths of its children
    (which in our case is based on the number of retweets and favorites of a tweet).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 该代码的结果显示在[图6.16](#ch06fig16)中，它以新的视觉隐喻显示了我们的分层数据集中的节点。与树状图不同，父母不是通过线与子节点连接，也不是像圆形布局那样在视觉上包含在父节点中，而是父节点堆叠在其子节点之上，其长度等于其子节点长度的总和（在我们的例子中是基于推文的转发和点赞数）。
- en: Figure 6.16\. A partition layout of our data, showing tweets at the bottom in
    green, sized by “impact” with users in orange sized by the total impact of their
    tweets and the root node (in this case “All Tweets”) in blue.
  id: totrans-149
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.16\. 我们数据的一个分区布局，显示底部为绿色的推文，按“影响力”大小排列，橙色表示用户按其推文的总体影响力大小排列，根节点（在这种情况下为“All
    Tweets”）为蓝色。
- en: '![](../Images/06fig16.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/06fig16.jpg)'
- en: 'I know what you’re thinking: “That doesn’t look like an icicle at all—people
    who name charts are dumb.” And you’re not wrong; chart naming has some serious
    issues. I mean, what is a line chart? Everything that’s drawn is made of lines,
    right? But the icicle chart gets its name from how it looks when we have data
    that’s not all the same depth, and this partition layout visually makes a bit
    more sense as an “icicle chart” when you see it with data like what we used to
    compare the cluster and tree layouts, as we see in [figure 6.17](#ch06fig17).'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道你在想什么：“这根本不像冰锥——给图表命名的人真傻。”你是对的；图表命名确实有一些严重的问题。我的意思是，什么是折线图？所有绘制的东西都是由线组成的，对吧？但冰锥图的名字来源于当我们有深度不一的数据时它的外观，当你用像我们在比较聚类和树布局时使用的数据来看这个分区布局时，它作为一个“冰锥图”在视觉上会更有意义，正如我们在[图6.17](#ch06fig17)中看到的。
- en: Figure 6.17\. Icicle charts look like melting icicles hanging from the gutter
    when you have hierarchical data of uneven depth, as you have in this example.
  id: totrans-152
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.17\. 当你有深度不一的分层数据时，冰锥图看起来像从排水沟悬挂下来的融化的冰锥。
- en: '![](../Images/06fig17.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/06fig17.jpg)'
- en: '6.5.2\. Sunburst: radial icicle chart'
  id: totrans-154
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.5.2\. 太阳花图：径向冰锥图
- en: Like the dendrogram, we can draw a radial partition layout, and it’s considered
    one of the most popular “impressive data visualization techniques.” There are
    always several examples at the top of the list on bl.ocks.org showing the most
    popular D3 code examples, as you can see in [figure 6.18](#ch06fig18).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 与树状图类似，我们可以绘制一个径向分区布局，这被认为是最受欢迎的“令人印象深刻的数据可视化技术”之一。在bl.ocks.org的列表顶部总是有几个示例，展示了最受欢迎的D3代码示例，正如你在[图6.18](#ch06fig18)中看到的。
- en: Figure 6.18\. The most popular blocks on October 20, 2016, which include not
    one or two but four different sunburst diagrams
  id: totrans-156
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.18\. 2016年10月20日最受欢迎的块，包括不止一个或两个，而是四个不同的太阳花图
- en: '![](../Images/06fig18_alt.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/06fig18_alt.jpg)'
- en: 'It’s so popular, in fact, that it’s not called a radial partition chart or
    radial icicle chart but rather has its own fancy name: a *sunburst diagram*. Even
    though it has its own fancy name, drawing it only requires us to use the same
    technique we used to create a radial dendrogram: we adjust the size to more suit
    our rendering method and change the way we render the pieces. In the case of a
    sunburst this means changing the size so that the width is in degrees and changing
    the rendering method so we’re using the `d3.arc` generator rather than `svg:rect`.
    It’s not that big of a difference, even though the code in the following listing
    is almost completely different—if you look closely you can see that it’s fundamentally
    the same logic but applied to a different scale and passed to arcs instead of
    rectangles.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，它非常受欢迎，以至于它不被称为径向分区图或径向冰柱图，而有一个自己的花哨名称：太阳图。尽管它有一个花哨的名称，但绘制它只需要我们使用与创建径向树状图相同的技巧：我们调整大小以更适合我们的渲染方法，并改变我们渲染片段的方式。在太阳图的情况下，这意味着调整大小，使宽度以度为单位，并改变渲染方法，以便我们使用
    `d3.arc` 生成器而不是 `svg:rect`。尽管接下来的列表中的代码几乎完全不同——如果你仔细看，你可以看到它基本上是相同的逻辑，但应用于不同的比例，并传递给弧而不是矩形。
- en: Listing 6.5\. Using the partition layout to create a sunburst
  id: totrans-159
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 6.5\. 使用分区布局创建一个太阳图
- en: '[PRE17]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '***1* Set the size of the layout to be 2PI for with width and whatever radius
    we want of the total chart for the height**'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将布局的大小设置为 2PI，宽度为 whatever radius 我们想要的整个图表的高度**'
- en: '***2* We’ll use y0 and y1 to determine the upper and lower bounds of the arcs
    we draw so that they stack on top of each other radially**'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 我们将使用 y0 和 y1 来确定我们绘制的弧线的上下界限，以便它们在径向上堆叠**'
- en: '***3* Remember we need to re-center the chart because the arc generator will
    draw out from 0,0**'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 记住我们需要重新居中图表，因为弧生成器将从 0,0 绘制**'
- en: '***4* Create a properly formatted object of the kind that arc() expects using
    object destructuring and object literal shorthand**'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 使用对象解构和对象字面量简写创建一个符合 arc() 期望格式的对象**'
- en: Our simple sunburst version of our data is in [figure 6.19](#ch06fig19). As
    I pointed out in the last chapter when we used `d3.histogram` to draw violin plots,
    I think it’s important to pause and dwell on how simple it is to draw a partition
    layout as a sunburst with D3\. Now, naturally, you have to understand how the
    arc generator works and what the layout is doing, but once you do, you can use
    D3 to create charts that you imagine rather than recreating the charts that you’ve
    seen online.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简单化的数据太阳图版本在 [图 6.19](#ch06fig19) 中。正如我在上一章中提到的，当我们使用 `d3.histogram` 来绘制小提琴图时，我认为暂停并思考如何使用
    D3 将分区布局作为太阳图绘制是如此简单是很重要的。现在，自然地，你必须理解弧生成器的工作原理以及布局在做什么，但一旦你做到了，你就可以使用 D3 创建你想象中的图表，而不是重新创建你在网上看到的图表。
- en: Figure 6.19\. A sunburst version of our nested tweets.
  id: totrans-166
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 6.19\. 我们嵌套推文的太阳图版本。
- en: '![](../Images/06fig19.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/06fig19.jpg)'
- en: 6.5.3\. Flame graph
  id: totrans-168
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.5.3\. 火焰图
- en: 'Before we move on to the next hierarchical visualization type, I want to draw
    your attention to a different use of the partition layout for a specialized data
    visualization chart: the flame graph. Developed to see what processes are burning
    up your applications, the *flame graph* is a fully featured application that consumes
    profiled data and returns an orange-formatted icicle chart has been ported as
    d3-flame-graph, an example of which you can see in [figure 6.20](#ch06fig20).'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续到下一个层次可视化类型之前，我想将你的注意力引向分区布局在专用数据可视化图表中的不同用途：火焰图。火焰图是为了查看哪些进程正在消耗你的应用程序而开发的，它是一个功能齐全的应用程序，消耗分析数据并返回一个橙色格式的冰柱图，已被移植为
    d3-flame-graph，你可以在 [图 6.20](#ch06fig20) 中看到一个示例。
- en: Figure 6.20\. An example of d3-flame-graph, which implements the flame graph
    first developed by Brandon Gregg. Note that the value of the children (in this
    case the higher bars) often adds up to less than the value of the parents.
  id: totrans-170
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 6.20\. d3-flame-graph 的一个示例，它实现了由 Brandon Gregg 首先开发的火焰图。注意，子项的值（在这种情况下是较高的条形）的总和往往小于父项的值。
- en: '![](../Images/06fig20_alt.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/06fig20_alt.jpg)'
- en: The major difference between the way the flame graph is presenting data and
    your typical partition layouts is that in most partition layouts, and most hierarchical
    data visualization, when you’re representing the size of the parent it’s typically
    as a sum of the size of its children. But in a flame chart, the parent is a process
    that takes up its own amount of time plus the time of its child processes. It
    would be too involved to recreate the entire parsing of profiled data, but remember
    that the `sum` method in `d3.hierarchy` is a convenience function and can be replaced
    with your own complex value setting function, so you could easily assign every
    node a value equal to the sum of its children plus its own value and achieve something
    like a flame graph.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 火焰图展示数据的方式与您典型的分区布局之间的主要区别在于，在大多数分区布局和大多数层次化数据可视化中，当你表示父节点的大小时，它通常是其子节点大小的总和。但在火焰图中，父节点是一个占用其自身时间加上其子进程时间的进程。重新创建整个分析数据的解析过程可能会过于复杂，但请记住，`d3.hierarchy`中的`sum`方法是一个便利函数，可以被你自己的复杂值设置函数所替代，因此你可以轻松地为每个节点分配一个等于其子节点总和加上其自身值的值，从而实现类似火焰图的效果。
- en: 6.5.4\. When to use the partition layout
  id: totrans-173
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.5.4. 何时使用分区布局
- en: In comparison to the dendrogram and the circle pack, the partition layout has
    great data-to-ink ratio. Literally no space is wasted on links, and the value
    of each node is encoded in the length of the node, facilitating good ability on
    the part of the reader to evaluate the numerical difference between the nodes.
    It’s great for use in applications where you need to give your readers the ability
    to quickly and effectively measure the values encoded in the nodes. But it’s the
    ultimate rich-get-richer visual representation of hierarchies, because the value
    at each depth accretes into the parent node’s value, which can make it hard to
    make out interesting breaks in the hierarchy that would be readily apparent in
    a dendrogram or clustering by category, like we saw with the countries in our
    A/B testing example at the start of the chapter. The best use case for partition
    layouts is the kind of data that drives the flame graph, where the accretion of
    time or processing power is exactly what you want to emphasize to software developers
    looking to optimize their code.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 与树状图和圆形打包相比，分区布局具有很高的数据到墨水比率。实际上，在链接上没有浪费任何空间，每个节点的值都编码在节点的长度中，这有助于读者评估节点之间的数值差异。它非常适合用于需要让读者能够快速有效地测量节点中编码的值的场景。但它是层次结构的终极富集视觉表示，因为每个深度的值都会累积到父节点的值中，这可能会使得在层次结构中难以识别出有趣的转折点，而这些转折点在树状图或按类别聚类的层次结构中会很容易显现出来，就像我们在本章开头A/B测试示例中看到的国家那样。分区布局的最佳用例是驱动火焰图的那种数据，其中时间或处理能力的累积正是你想要强调给那些希望优化其代码的软件开发人员的内容。
- en: 6.6\. Treemaps
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.6. 树状图
- en: The last hierarchical data visualization method we’ll look at is the treemap,
    which was developed to show stock performance while at the same time showing parts
    of the market into which those stocks were categorized. Because of this serious
    business--oriented pedigree, the treemap is a well-received way of showing hierarchical
    data. The *treemap* is a mix of circle packing and partition, using rectangles
    to represent nodes and enclosing those rectangles within their parent rectangles.
    Unlike circle packing, it has the benefit of using rectilinear shapes on a rectilinear
    screen, so we don’t see a lot of wasted space like we do with circle packing.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要查看的最后一种层次化数据可视化方法是树状图，它是为了在展示股票表现的同时，展示那些股票被分类的市场部分而开发的。由于这种严肃的商业血统，树状图是展示层次化数据的一种受欢迎的方式。*树状图*是圆形打包和分区的一种混合，使用矩形来表示节点，并将这些矩形包含在其父矩形内。与圆形打包不同，它具有在矩形屏幕上使用矩形形状的优点，所以我们不会看到像圆形打包那样的大量浪费空间。
- en: 6.6.1\. Building
  id: totrans-177
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.6.1. 构建
- en: By now you should know how to make hierarchical data visualization products
    in D3\. You need to have your hierarchical data, but you may have acquired it
    or processed it and passed it to `d3.hierarchy`. You’ll use the `sum` method of
    `d3.hierarchy` because we want to show the value of our tweet data in our charts.
    This time, the only difference is you’ll send all that to `d3.treemap`, as we
    see in the following listing.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你应该知道如何在D3中制作层次化数据可视化产品。你需要有你的层次化数据，但你可能已经获取或处理了它，并将其传递给`d3.hierarchy`。你会使用`d3.hierarchy`的`sum`方法，因为我们想在我们的图表中展示我们的推文数据。这次，唯一的区别是你将所有这些发送到`d3.treemap`，正如我们在下面的列表中看到的那样。
- en: Listing 6.6\. Drawing a treemap
  id: totrans-179
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.6\. 绘制树状图
- en: '[PRE18]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '***1* Because the layout mutates root, you can run it without assigning it
    to a variable**'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 因为布局会改变根，所以你可以运行它而不将其分配给变量**'
- en: '***2* Set a key so we can filter-zoom later**'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 设置一个键，以便我们可以在以后进行过滤缩放**'
- en: '***3* All the hierarchical layouts that are typically represented with rectangles
    expose x1,x0 and y1,y0 because it’s easy to derive height/width from that and
    still use it for other projections**'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 所有通常用矩形表示的层次布局都暴露了x1,x0和y1,y0，因为这很容易从中推导出高度/宽度，并且仍然可以用于其他投影**'
- en: We’re doing almost exactly the same thing with treemap that we’ve done with
    `d3.partition`. The results that you see in [figure 6.21](#ch06fig21) are a bit
    different, though, despite the fact that we’re still using `svg:rect` to represent
    our nodes.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎与`d3.partition`所做的一样，使用树状图。尽管我们仍然使用`svg:rect`来表示我们的节点，但你在[图6.21](#ch06fig21)中看到的结果还是有点不同。
- en: Figure 6.21\. A treemap without padding will only show the leaf nodes.
  id: totrans-185
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.21\. 没有填充的树状图只会显示叶节点。
- en: '![](../Images/06fig21.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/06fig21.jpg)'
- en: 'The rectangles have filled the space efficiently—a bit too efficiently. We’ve
    lost our hierarchical data—in this case, which nodes were tweeted by which people.
    That’s because without putting in padding on treemap we end up with our leaf nodes
    perfectly abutting each other in the rectangle we describe with the size array.
    Let’s add padding:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 矩形已经有效地填充了空间——有点过于有效。我们已经失去了我们的层次数据——在这种情况下，哪些节点是由哪些人推文的。这是因为没有在树状图中添加填充，我们最终在我们的尺寸数组描述的矩形中完美地并排放置了我们的叶节点。让我们添加填充：
- en: '[PRE19]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: By adding padding, we restore that enclosure signal that indicates which nodes
    are the children of which other nodes, as you can see in [figure 6.22](#ch06fig22).
    Padding can take a function, like we have in [figure 6.21](#ch06fig21). But be
    careful with dynamic padding because your reader is trying to evaluate the data
    encoded using the area of the shapes represented, so if you’re changing the calculation
    of the area of that shape based on its depth in the hierarchy, don’t expect that
    to be readily apparent to your reader’s visual processing. In the case of a hierarchical
    dataset like our tweets, we’re not causing too much harm because it’s equal depth,
    but in one of those datasets where the depth is not equal, you may be setting
    your readers up to misunderstand the data you’re visualizing.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加填充，我们恢复了表示哪些节点是哪些其他节点子节点的封装信号，正如你在[图6.22](#ch06fig22)中可以看到。填充可以是一个函数，就像我们在[图6.21](#ch06fig21)中看到的那样。但要注意动态填充，因为你的读者正在尝试评估使用形状表示的区域编码的数据，所以如果你根据形状在层次结构中的深度改变该形状的面积计算，不要期望你的读者能够轻易地通过视觉处理来识别这一点。在我们的推文这样的层次数据集中，我们没有造成太大的伤害，因为它们具有相同的深度，但在那些深度不等的其中一个数据集中，你可能会让你的读者误解你正在可视化的数据。
- en: Figure 6.22\. A treemap with the padding method set. Notice that padding determines
    the space between children and not siblings.
  id: totrans-190
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.22\. 使用填充方法的树状图。注意填充决定了子节点之间的空间，而不是兄弟节点之间的空间。
- en: '![](../Images/06fig22.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/06fig22.jpg)'
- en: 6.6.2\. Filtering
  id: totrans-192
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.6.2\. 过滤
- en: When you want to zoom into a hierarchical data visualization, what you’re doing
    is laying it out anew with the node you’ve clicked on as your root node. Because
    your data is hierarchically structured, this is easier than it sounds. We’ll add
    the click event in the following listing to all our rectangles, as in the following
    listing.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想放大到层次数据可视化时，你所做的是用你点击的节点作为根节点重新布局。因为你的数据是层次结构的，所以这比听起来容易。我们将在以下列表中添加点击事件到所有我们的矩形中，如下所示。
- en: Listing 6.7\. Filter zoom example
  id: totrans-194
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表6.7\. 过滤缩放示例
- en: '[PRE20]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '***1* Build a new hierarchy using the currently clicked node as the root node**'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 使用当前点击的节点作为根节点构建一个新的层次结构**'
- en: '***2* Add any new nodes (when we’re zooming out)**'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 添加任何新的节点（当我们缩小视图时）**'
- en: '***3* Remove any trimmed nodes (when we’re zooming in)**'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 移除任何被裁剪的节点（当我们放大时）**'
- en: '***4* Update the filter function so it zooms out if we’re zoomed in and zooms
    in if we’re zoomed out**'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 更新过滤函数，以便我们在放大时缩小，在缩小时放大**'
- en: '***5* Redraw any remaining nodes to the new scale**'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 将任何剩余的节点重绘到新的比例**'
- en: And that’s all there is to it when you’re introducing zoom functionality to
    hierarchical data visualization products. If we click the blue area of the viz,
    nothing will happen (because that’s our root node) and if we click the green then
    we’ll zoom all the way down to a leaf node. If we click the orange area, we’ll
    zoom to a single user as a node and all their tweets, like we see in [figure 6.23](#ch06fig23),
    with a nice animated transition to the new view.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 当你向层次化数据可视化产品引入缩放功能时，就是这样。如果我们点击可视化中的蓝色区域，什么也不会发生（因为那是我们的根节点），如果我们点击绿色区域，我们会缩放到一个叶节点。如果我们点击橙色区域，我们会缩放到一个单独的用户节点以及他们的所有推文，就像我们在[图6.23](#ch06fig23)中看到的那样，并且有一个漂亮的动画过渡到新视图。
- en: Figure 6.23\. The “zoomed in” view of our treemap, showing only the leaf nodes
    in one of the intermediary node views. Note that the recalculated treemap has
    adjusted the padding because the orange node is now the root node.
  id: totrans-202
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.23\. 我们树状图的“放大”视图，仅显示中间节点视图中的一个叶节点。注意，重新计算的树状图已经调整了填充，因为橙色节点现在是根节点。
- en: '![](../Images/06fig23.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/06fig23.jpg)'
- en: 6.6.3\. Radial treemap
  id: totrans-204
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.6.3\. 径向树状图
- en: For the sake of completeness, yes, you can project a treemap radially, as seen
    in [figure 6.24](#ch06fig24).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完整性起见，是的，你可以将树状图径向投影，如图6.24所示。
- en: Figure 6.24\. A radial treemap accomplished by taking the drawing instructions
    from `d3.treemap` and using them to draw paths using `d3.arc` instead of `svg:rect`
    elements.
  id: totrans-206
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图6.24\. 通过从`d3.treemap`获取绘图指令并使用它们通过`d3.arc`绘制路径而不是`svg:rect`元素来实现的径向树状图。
- en: '![](../Images/06fig24.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/06fig24.jpg)'
- en: It’s not considered a popular data visualization charting method. It might be
    because people have a hard time evaluating the area of arcs. I think people don’t
    use it because it looks like the schematics of the Death Star.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不被认为是一种流行的数据可视化图表方法。可能是因为人们很难评估弧形的面积。我认为人们不使用它是因为它看起来像死亡星的示意图。
- en: 6.6.4\. When to use treemaps
  id: totrans-209
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 6.6.4\. 何时使用树状图
- en: Unlike the length of rectangles, people have a hard time evaluating the area
    of rectangles and understanding the value mapped to that area, so treemaps aren’t
    going to be as effective as icicle charts for allowing precise comparison of values.
    However, because they encode parent-child relationship using enclosure, they don’t
    spend as much ink on the parent nodes that partition charts do, and they encode
    value better than circle packs do using radius. They’re a good kind of chart for
    hierarchical data that’s numerical and that you want to compare the rough value
    and aggregated value across categories. Another example is demographic data, where
    each leaf node represents items that vary numerically, like counties or census
    blocks, and for which you might want to see the breakdown by demographics aggregated
    by their hierarchical parents.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 与矩形的长度相比，人们很难评估矩形的面积并理解映射到该面积的价值，因此树状图在允许精确比较值方面不会像冰柱图那样有效。然而，由于它们使用包围来编码父子关系，它们在分区图表中使用的父节点上花费的墨水较少，并且它们使用半径比圆饼图更好地编码价值。它们是用于数值型层次化数据的好图表，你想要比较跨类别的粗略值和汇总值。另一个例子是人口统计数据，其中每个叶节点代表数值变化的项，如县或人口普查区，你可能想看到按其层次父节点汇总的细分。
- en: 6.7\. Summary
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.7\. 摘要
- en: Hierarchical data visualization can be achieved using several different methods,
    such as circle packing, tree maps, or tree diagrams. Methods share many of the
    same functions (like padding in `pack()`, and `treemap()`) is suited for different
    types and densities of hierarchical data.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 层次化数据可视化可以通过多种不同的方法实现，例如圆形排列、树状图或树形图。这些方法共享许多相同的功能（如`pack()`中的填充和`treemap()`）适合不同类型和密度的层次化数据。
- en: Hierarchical layouts in D3 all start with using `hierarchy()` to process a hierarchical
    dataset. Once processed, this dataset can be hierarchically filtered or sorted,
    as well as flattened for display.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: D3中的层次化布局都是从使用`hierarchy()`处理层次化数据集开始的。一旦处理完毕，这个数据集可以进行层次化过滤或排序，也可以扁平化以供显示。
- en: Certain hierarchical layouts are particularly amenable to radial display, such
    as the dendrogram or partition layout. When a partition layout is displayed hierarchically,
    it’s called a sunburst.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 某些层次化布局特别适合径向显示，例如树状图或分区布局。当分区布局以层次化方式显示时，它被称为太阳花图。
- en: Even though all hierarchical layouts use the same kind of data doesn’t mean
    you should pick one randomly or use the one you’re most familiar with. Instead,
    you should think about the aspect of the hierarchical data you want to present
    to your users and choose the hierarchical layout that best emphasizes it.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管所有分层布局使用相同类型的数据，但这并不意味着你应该随机选择或使用你最熟悉的一种。相反，你应该考虑你想向用户展示的分层数据的方面，并选择最能强调该方面的分层布局。
- en: D3.js in the real world
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: D3.js 在现实世界中的应用
- en: Nadieh Bremer Data Visualization Consultant
  id: totrans-217
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Nadieh Bremer 数据可视化顾问
- en: '*A Closer Look at Labor*'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '*更深入地了解劳动*'
- en: The visual shows the ~550 different occupations as defined by the Bureau of
    Labor Statistics in their hierarchical groupings. Each white circle represents
    an occupation and these circles are scaled according to the total number of people
    working in the occupation. Within each circle there is a bar chart further detailing
    the division between age groups in the occupation. It’s possible to zoom into
    any level of hierarchy and the visual only shows the bar charts in those circles
    that have become large enough to readably fit the bar chart.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 该可视化展示了美国劳工统计局根据其分层分类定义的 ~550 种不同的职业。每个白色圆圈代表一个职业，这些圆圈根据从事该职业的总人数进行缩放。每个圆圈内部有一个条形图，进一步详细说明该职业中年龄组的划分。可以放大到任何级别的层次结构，可视化只显示那些圆圈中足够大的条形图。
- en: '![](../Images/203fig01.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/203fig01.jpg)'
- en: The data that’s available in this visual amounts to at least 7 (age groups)
    times 550 (occupations) = 3850 data points. By using the hierarchical approach
    I could prevent overwhelming the viewers with too much data and instead let them
    dive into the occupational areas they would find most interesting. The deeper
    they dive into the different hierarchical levels of occupations, from service
    occupations to food preparation to cooks, the more information that becomes available
    to them due to more bar charts being drawn within each white circle. This is a
    details-on-demand approach.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 该可视化中可用的数据至少有 7（年龄组）乘以 550（职业）= 3850 个数据点。通过使用分层方法，我可以防止观众被过多数据淹没，相反，让他们深入到他们最感兴趣的职业领域。他们越深入到不同层级的职业，从服务行业到食品准备到厨师，由于每个白色圆圈内部绘制了更多的条形图，他们可以获得的信息就越多。这是一种按需提供细节的方法。
- en: '![](../Images/204fig01_alt.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/204fig01_alt.jpg)'
- en: Chapter 7\. Network visualization
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 7 章。网络可视化
- en: '*This chapter covers*'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Creating adjacency matrices and arc diagrams
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建邻接矩阵和弧形图
- en: Using the force-directed layout
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用力导向布局
- en: Using constrained forces
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用约束力
- en: Representing directionality
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表示方向性
- en: Adding and removing network nodes and edges
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加和删除网络节点和边
- en: Network analysis and network visualization are more common now with the growth
    of online social networks like Twitter and Facebook, as well as social media and
    linked data, all of which are commonly represented with network structures. Network
    visualizations like the kind you’ll see in this chapter, some of which are shown
    in [figure 7.1](#ch07fig01), are particularly interesting because they focus on
    how things are related. They represent systems more accurately than the traditional
    flat data seen in more common data visualizations.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 随着像 Twitter 和 Facebook 这样的在线社交网络以及社交媒体和链接数据的增长，网络分析和网络可视化现在更为常见。所有这些通常都用网络结构表示。本章中你将看到的网络可视化（如图
    7.1 所示，其中一些已在[图 7.1](#ch07fig01)中展示），特别有趣，因为它们关注的是事物之间的关系。它们比在更常见的数据可视化中看到的传统平面数据更能准确地表示系统。
- en: Figure 7.1\. Along with explaining the basics of network analysis ([section
    7.2.3](#ch07lev2sec6)), this chapter includes laying out networks using xy positioning
    ([section 7.2.5](#ch07lev2sec8)), force-directed algorithms ([section 7.2](#ch07lev1sec2)),
    adjacency matrices ([section 7.1.2](#ch07lev2sec2)), and arc diagrams ([section
    7.1.3](#ch07lev2sec3)).
  id: totrans-231
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.1。本章不仅解释了网络分析的基础（[第 7.2.3 节](#ch07lev2sec6)），还包括使用 xy 定位布局网络（[第 7.2.5 节](#ch07lev2sec8)）、力导向算法（[第
    7.2 节](#ch07lev1sec2)）、邻接矩阵（[第 7.1.2 节](#ch07lev2sec2)）和弧形图（[第 7.1.3 节](#ch07lev2sec3)）。
- en: '![](../Images/07fig01_alt.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/07fig01_alt.jpg)'
- en: This chapter focuses on representing networks, so it’s important that you understand
    a little network terminology as we get started. In general, when dealing with
    networks you refer to the things being connected (like people) as *nodes* and
    the connections between them (such as being a friend on Facebook) as *edges* or
    *links*. Networks may also be referred to as *graphs*, because that’s what they’re
    called in mathematics.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的重点是表示网络，因此在我们开始之前，了解一些网络术语是很重要的。一般来说，在处理网络时，你将连接的事物（如人）称为*节点*，它们之间的连接（如成为Facebook上的朋友）称为*边*或*链接*。网络也可以称为*图*，因为在数学中就是这样称呼的。
- en: Networks aren’t only a data format—they’re a perspective on data. When you work
    with network data, you typically try to discover and display patterns of the network
    or of parts of the network, and not of individual nodes in the network. Although
    you may use a network visualization because it makes a cool graphical index, like
    a mind map or a network map of a website, in general you’ll find that the typical
    information visualization techniques are designed to showcase network structure,
    not individual nodes.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 网络不仅仅是一种数据格式——它是对数据的视角。当您处理网络数据时，通常试图发现和显示网络或网络部分的模式，而不是网络中单个节点的模式。尽管您可能使用网络可视化，因为它可以创建一个酷的图形索引，如思维导图或网站的网络图，但通常您会发现典型信息可视化技术的设计是为了展示网络结构，而不是单个节点。
- en: 7.1\. Static network diagrams
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1\. 静态网络图
- en: 'Network data is different from hierarchical data. Networks present the possibility
    of many-to-many connections, like the Sankey layout from [chapter 5](../Text/kindle_split_014.html#ch05),
    whereas in hierarchical data a node can have many children but only one parent,
    like the tree and pack layouts from [chapter 5](../Text/kindle_split_014.html#ch05).
    A network doesn’t have to be a social network. This format can represent many
    different structures, such as transportation networks and linked open data. In
    this chapter, we’ll look at four common forms for representing networks: as data,
    as adjacency matrices, as arc diagrams, and using force-directed network diagrams.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 网络数据与层次数据不同。网络展示了多对多连接的可能性，例如第5章中的Sankey布局[5](../Text/kindle_split_014.html#ch05)，而在层次数据中，一个节点可以有多个子节点，但只有一个父节点，如第5章中的树状布局和堆叠布局[5](../Text/kindle_split_014.html#ch05)。网络不一定是社交网络。这种格式可以表示许多不同的结构，例如交通网络和链接开放数据。在本章中，我们将探讨表示网络的四种常见形式：作为数据、作为邻接矩阵、作为弧线图，以及使用力导向网络图。
- en: In each case, the graphical representation will be quite different. For instance,
    in the case of a force-directed layout, we’ll represent the nodes as circles and
    the edges as lines. But in the case of the adjacency matrix, nodes will be positioned
    on x- and y-axes, and the edges will be filled squares. Networks don’t have a
    default representation, but the examples you’ll see in this chapter are the most
    common.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在每种情况下，图形表示将非常不同。例如，在力导向布局的情况下，我们将节点表示为圆圈，将边表示为线条。但在邻接矩阵的情况下，节点将位于x轴和y轴上，边将填充为正方形。网络没有默认的表示形式，但本章中您将看到的例子是最常见的。
- en: 7.1.1\. Network data
  id: totrans-238
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.1.1\. 网络数据
- en: Network data stores nodes, which can be companies or nucleotides or, in our
    case, people, and the links that connect them. Those links could be anything,
    from Facebook friends to molecular interaction. In this chapter, we’re going to
    get into People Analytics, an exciting new trend in human resources to try to
    analyze and visualize data related to how organizations perform. It’s data-driven
    HR, and because HR is all about people, we deal with more interesting datasets
    than usual—such as text analysis for written reviews or, in our case, network
    analysis to see team dynamics.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 网络数据存储节点，这些节点可以是公司、核苷酸，或者在我们的案例中，是人，以及连接这些节点的链接。这些链接可以是任何东西，从Facebook的朋友关系到分子相互作用。在本章中，我们将探讨人力资源领域的一个令人兴奋的新趋势——人员分析，尝试分析和可视化与组织表现相关的数据。这是数据驱动的HR，由于HR的核心是人员，我们处理的数据集比通常更有趣——例如，书面评论的文本分析，或者在我们的案例中，网络分析以查看团队动态。
- en: Imagine we have three teams and a couple contractors and every six months they
    do a 360 review where they give feedback to the people that they worked with over
    the last six months. At the end of each review, the team member gives a numerical
    score indicating whether they have confidence in the person they’re reviewing,
    from 0 (indicating no confidence) to 5 (indicating total confidence). Many Silicon
    Valley companies do this kind of review, and you can take the reviews that each
    employee gives and make it a link in a network to create interesting social network
    analysis graphs. These networks can show us how teams are or aren’t working together
    as we’d want them to be and allow us to map out key contributors and ways in which
    we might make our teams stronger.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有三支团队和一些承包商，每六个月他们会对过去六个月与他们一起工作的人进行360度评价，并给出反馈。在每个评价的结束时，团队成员会给出一个数值评分，表示他们对被评价的人是否有信心，从0（表示没有信心）到5（表示完全信心）。许多硅谷公司都进行这种评价，你可以将每个员工给出的评价作为网络中的一个链接，以创建有趣的社会网络分析图。这些网络可以显示团队是否像我们希望的那样合作，并允许我们绘制关键贡献者和我们可能使团队变得更强大的方法。
- en: Although you can store networks in several data formats, the most straightforward
    is known as an edge list. An *edge list* is typically represented as a CSV like
    that shown in [listing 7.1](#ch07ex01), with a source column and a target column,
    and a string or number to indicate which nodes are connected, resulting in connections
    and networks like those described in [figure 7.2](#ch07fig02). Each edge may also
    have other attributes, indicating the type of connection or its strength, the
    time period when the connection is valid, its color, or any other information
    you want to store about a connection. The important thing is that only the source
    and target columns are necessary. It’s hard to indicate negative links (like people
    who are connected to each other by their deep and abiding hatred, like how you
    might connect Harry Potter and Voldemort, or Romeo and Tybalt), so we’re only
    looking at links in our made-up people analytics network where the score is 1
    or greater.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你可以用几种数据格式存储网络，但最直接的方式被称为边列表。**边列表**通常表示为CSV，如[列表7.1](#ch07ex01)中所示，有一个源列和一个目标列，以及一个字符串或数字来表示哪些节点是连接的，从而形成描述[图7.2](#ch07fig02)中那样的连接和网络。每条边也可以有其他属性，表示连接的类型或其强度、连接有效的时期、其颜色或任何其他你想要存储的关于连接的信息。重要的是，只需要源和目标列。很难表示负链接（例如，通过他们之间深深的仇恨而相互连接的人，比如你可能连接哈利·波特和伏地魔，或者罗密欧和提伯尔特），所以我们只关注我们虚构的人分析网络中的链接，其中分数为1或更高。
- en: Figure 7.2\. Some basic kinds of network connections (directed, reciprocated,
    and undirected) that show up in basic networks like simple directed and undirected
    networks
  id: totrans-242
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.2\. 基本网络中出现的几种网络连接类型（有向、互惠和无向），如简单的有向和无向网络
- en: '![](../Images/07fig02.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/07fig02.jpg)'
- en: In the case of directed networks, the source and target columns indicate the
    direction of connection between nodes. A *directed* network means that nodes may
    be connected in one direction but not in the other. For instance, you could follow
    a user on Twitter, but that doesn’t necessarily mean the user follows you. *Undirected*
    networks still typically have the columns listed as “source” and “target,” but
    the connection is the same in both directions. Take the example of a network made
    up of connections indicating people who have shared classes. If I’m in a class
    with you, you’re likewise in a class with me. You’ll see directed and weighted
    networks represented throughout this chapter because our sample dataset will be
    one person’s rating of another, and just because they rated them doesn’t mean
    they were rated in return (maybe they got a 0 in return, or maybe the other person
    does a worse job of filling out their 360 reviews).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在有向网络的情况下，源节点和目标节点列表示节点之间连接的方向。一个**有向**网络意味着节点可能在一个方向上连接，但在另一个方向上则不连接。例如，你可以在Twitter上关注一个用户，但这并不一定意味着该用户也会关注你。**无向**网络通常列出的列仍然是“源”和“目标”，但连接在两个方向上是相同的。以一个由表示人们共享课程连接组成的网络为例。如果我与你在一个班级里，你同样也在一个班级里与我。你将看到在本章中，有向和加权网络被表示出来，因为我们的样本数据集将是一个人对另一个人的评分，仅仅因为他们给出了评分并不意味着他们也会得到评分（也许他们得到了0分，或者也许另一个人在填写他们的360度评价时做得更差）。
- en: Listing 7.1\. edgelist.csv
  id: totrans-245
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.1\. edgelist.csv
- en: '[PRE21]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Reading this dataset, you can see that Jim and Susie both have total confidence
    in Irene, whereas Irene either gave anyone connected to her a 0 or didn’t get
    around to doing her 360 reviews (which happens a lot, and the lack of connection
    is itself something key to visualize with datasets like this). This is a *weighted
    network* because the edges have a value. It’s a *directed network* because the
    edges have direction. Therefore, we have a *weighted directed network*, and we
    need to account for both weight and direction in our network visualizations.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读这个数据集，你可以看到吉姆和苏西都对艾琳有完全的信心，而艾琳要么给所有与她相连的人0分，要么还没来得及完成她的360度评估（这种情况经常发生，而且缺乏联系本身也是用此类数据集可视化的关键）。这是一个
    *加权网络*，因为边有值。它是一个 *有向网络*，因为边有方向。因此，我们有一个 *加权有向网络*，我们需要在我们的网络可视化中考虑权重和方向。
- en: Technically, you only need an edge list to create a network, because you can
    derive a list of nodes from the unique values in the edge list. This is done by
    traditional network analysis software packages like Gephi. Although you can derive
    a node list with JavaScript, it’s more common to have a corresponding node list
    that provides more information about the nodes in your network, like we have in
    the following listing.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术上讲，你只需要一个边列表来创建一个网络，因为你可以从边列表中的唯一值中推导出一个节点列表。这是由传统的网络分析软件包如 Gephi 完成的。虽然你可以用
    JavaScript 推导出一个节点列表，但更常见的是有一个相应的节点列表，它提供了关于你网络中节点的更多信息，就像我们在以下列表中所拥有的那样。
- en: Listing 7.2\. nodelist.csv
  id: totrans-249
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.2\. nodelist.csv
- en: '[PRE22]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Because these are employees, we have a bit more information about them besides
    their links—in this case, their role and their salary. As with the edge list,
    it’s not necessary to have more than an ID. But having access to more data gives
    you the chance to modify your network visualization to reflect the node attributes.
    We’ll use role to color the later networks (managers in orange, employees in green,
    and contractors in purple).
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些是员工，我们除了他们的链接之外还有更多关于他们的信息——在这种情况下，他们的角色和他们的薪水。与边列表一样，没有必要有超过一个 ID。但拥有更多数据的机会让你有机会修改你的网络可视化以反映节点属性。我们将使用角色来着色后续网络（经理用橙色，员工用绿色，承包商用紫色）。
- en: 'How you represent a network depends on its size and nature. If a network doesn’t
    represent discrete connections between similar things, but rather the flow of
    goods or information or traffic, then you could use a Sankey diagram as we did
    in [chapter 5](../Text/kindle_split_014.html#ch05). Recall that the data format
    for the Sankey is exactly the same as what we have here: a table of nodes and
    a table of edges. The Sankey diagram is only suitable for specific kinds of network
    data. Other chart types, such as an adjacency matrix, are more generically useful
    for network data.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何表示一个网络取决于其大小和性质。如果一个网络不表示类似事物之间的离散连接，而是表示商品、信息或交通的流动，那么你可以使用类似我们在第 5 章中使用的桑基图。回想一下，桑基图的数据格式与我们这里完全相同：一个节点表和一个边表。桑基图仅适用于特定类型的网络数据。其他图表类型，如邻接矩阵，对网络数据更具通用性。
- en: Before we get started with code to create a network visualizations, let’s put
    together a CSS page so that we can set color based on class and use inline styles
    as little as possible. [Listing 7.3](#ch07ex03) gives the CSS necessary for all
    the examples in this chapter. Keep in mind that we’ll still need to set some inline
    styles when we want the numerical value of an attribute to relate to the data
    bound to that graphical element—for example, when we base the stroke-width of
    a line on the strength of that line.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编写创建网络可视化的代码之前，让我们先创建一个 CSS 页面，这样我们就可以根据类设置颜色，并尽可能少地使用内联样式。[列表 7.3](#ch07ex03)
    提供了本章所有示例所需的 CSS。请注意，当我们想要属性的数值与绑定到该图形元素的数值相关联时，我们仍然需要设置一些内联样式——例如，当我们根据线的强度设置线的宽度时。
- en: Listing 7.3\. networks.css
  id: totrans-254
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.3\. networks.css
- en: '[PRE23]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '***1* If you set the style of a <g> element, it will set that style for all
    its children, which can be useful if you have multipart elements that you want
    to have the same style**'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 如果你设置了 <g> 元素的样式，它将为所有子元素设置该样式，这在你想让多个元素具有相同样式时非常有用**'
- en: 7.1.2\. Adjacency matrix
  id: totrans-257
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.1.2\. 邻接矩阵
- en: As you see more and more networks represented graphically, it seems like the
    only way to represent a network is with a circle or square that represents the
    node and a line (whether straight or curvy) that represents the edge. It may surprise
    you that one of the most effective network visualizations has no connecting lines
    at all. Instead, the *adjacency matrix* uses a grid to represent connections between
    nodes, with the graphical rules of the chart as described in [figure 7.3](#ch07fig03).
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你越来越多地看到用图形表示的网络，似乎唯一表示网络的方式是使用代表节点的圆形或正方形以及代表边的直线（无论是直线还是曲线）。可能会让你惊讶的是，最有效的网络可视化之一根本没有任何连接线。相反，*邻接矩阵*使用网格来表示节点之间的连接，图表的图形规则如[图7.3](#ch07fig03)中所述。
- en: Figure 7.3\. How edges are described graphically in an adjacency matrix. In
    this kind of diagram, the nodes are listed on the axes as columns, and a connection
    is indicated by a shaded cell where those columns intersect.
  id: totrans-259
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.3. 在邻接矩阵中如何图形化地描述边。在这种图表中，节点被列在轴上作为列，连接由交叉处的阴影单元格表示。
- en: '![](../Images/07fig03.jpg)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![图7.3](../Images/07fig03.jpg)'
- en: 'The principle of an adjacency matrix (a two-node example is seen in the figure)
    is simple: you place the nodes along the x-axis and then place the same nodes
    along the y-axis. If two nodes are connected, then the corresponding grid square
    is filled; otherwise, it’s left blank. In our case, because it’s a directed network,
    the nodes along the y-axis are considered the source, and the nodes along the
    x-axis are considered the target, as you’ll see in a few pages. Because our people
    analytics network is also weighted, we’ll use saturation to indicate weight, with
    lighter colors indicating a weaker connection and darker colors indicating a stronger
    connection.'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 邻接矩阵的原则（图中有两个节点的示例）很简单：你将节点沿着x轴放置，然后沿着y轴放置相同的节点。如果两个节点相连，则相应的网格方格被填充；否则，留空。在我们的情况下，因为这是一个有向网络，y轴上的节点被认为是源节点，x轴上的节点被认为是目标节点，你将在几页后看到。因为我们的数据分析网络也是加权的，我们将使用饱和度来表示权重，浅色表示较弱的连接，深色表示较强的连接。
- en: The only problem with building an adjacency matrix in D3 is that it doesn’t
    have an existing layout, which means you have to build it by hand like we did
    with the bar chart, scatterplot, and boxplot. Mike Bostock has an impressive example
    at [http://bost.ocks.org/mike/miserables/](http://bost.ocks.org/mike/miserables/),
    but you can make something that’s functional without too much code, which we’ll
    do with the function in [listing 7.4](#ch07ex04). In doing so, though, we need
    to process the two arrays of JavaScript objects that are created from our CSVs
    and format the data so that it’s easy to work with. This is getting close to writing
    our own layout, something we’ll do in [chapter 10](../Text/kindle_split_021.html#ch10),
    and a good idea generally.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在D3中构建邻接矩阵的唯一问题是它没有现成的布局，这意味着你必须手动构建，就像我们之前构建条形图、散点图和箱形图那样。Mike Bostock有一个令人印象深刻的例子，可以在[http://bost.ocks.org/mike/miserables/](http://bost.ocks.org/mike/miserables/)找到，但你也可以用不太多的代码制作出功能性的东西，我们将在[列表7.4](#ch07ex04)中的函数中这样做。然而，这样做的时候，我们需要处理从我们的CSV文件中创建的两个JavaScript对象数组，并格式化数据，使其易于处理。这接近于编写我们自己的布局，我们将在[第10章](../Text/kindle_split_021.html#ch10)中这样做，这通常是一个好主意。
- en: One thing you’ll notice in [listing 7.4](#ch07ex04) that might intimidate you
    is the Promise API. *Promises* are asynchronous functions that fire a resolve
    or reject event when the asynchronous call finishes. We’re not using them for
    fancy async behavior—we’re using them so that we can fire `Promise.all`, which
    lets us pass an array of promises and only fires a function once all those promises
    have been resolved or one of them has been rejected. The simple promise wrapper
    we see in the [listing 7.4](#ch07ex04) is how you might wrap a callback function
    like `d3.csv` so that it resolves as a promise. It’s better to use core ES6 functionality
    like this, which you will run into in industry, than helper libraries like, say,
    `d3.queue`. I decided to use promises for any example where we need to wait for
    the asynchronous behavior of two or more functions because I think it’s going
    to serve you best to get exposed to and familiar with promises rather than a D3-specific
    approach.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 你会在[列表 7.4](#ch07ex04)中注意到的一件事可能会让你感到害怕，那就是 Promise API。*承诺*是异步函数，当异步调用完成时，会触发
    resolve 或 reject 事件。我们不是用它们来实现复杂的异步行为——我们用它们来调用 `Promise.all`，这允许我们传递一个承诺数组，并且只有在所有这些承诺都解决或其中一个被拒绝时才会调用一个函数。我们在[列表
    7.4](#ch07ex04)中看到的简单的承诺包装器是你可以如何包装一个回调函数，比如 `d3.csv`，使其作为一个承诺解决。使用像这样的核心 ES6
    功能，这在行业中会遇到，比像 `d3.queue` 这样的辅助库更好。我决定在需要等待两个或更多函数的异步行为时使用承诺，因为我认为让你接触并熟悉承诺比特定的
    D3 方法更有益。
- en: Listing 7.4\. The adjacency matrix function
  id: totrans-264
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.4\. 邻接矩阵函数
- en: '[PRE24]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '***1* We need to wrap our calls in promises to use promise.all**'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 我们需要将我们的调用包裹在承诺中才能使用 promise.all**'
- en: '***2* Promise.all returns an array of results in the order of the promises
    that were sent**'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* Promise.all 返回一个结果数组，其顺序与发送的承诺相同**'
- en: '***3* A hash allows us to test whether a source-target pair has a link**'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 一个散列允许我们测试源-目标对是否有链接**'
- en: '***4* Creates all possible source-target connections**'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 创建所有可能的源-目标连接**'
- en: '***5* Sets the xy coordinates based on the source-target array positions**'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 根据源-目标数组位置设置 xy 坐标**'
- en: '***6* If there’s a corresponding edge in our edge list, give it that weight**'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 如果在我们的边列表中有一个相应的边，就给它那个权重**'
- en: '***7* Creates horizontal labels from the nodes**'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 从节点创建水平标签**'
- en: '***8* Vertical labels with text-anchor: end because that will line it up better**'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8* 垂直标签使用 text-anchor: end 因为这样可以更好地对齐**'
- en: We’re building this matrix array of objects that may seem obscure. But if you
    examine it in your console, you’ll see, as in [figure 7.4](#ch07fig04), that it’s
    a list of every possible connection and the strength of that connection, if it
    exists.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在构建一个对象矩阵数组，这可能看起来有些晦涩。但如果你在你的控制台中检查它，你会看到，就像[图 7.4](#ch07fig04)中一样，它是一个包含每个可能的连接及其强度（如果存在）的列表。
- en: Figure 7.4\. The array of connections we’re building. Notice that every possible
    connection is stored in the array. Only those connections that exist in our dataset
    have a weight value other than 0\. Also note that our CSV import creates the weight
    value as a string.
  id: totrans-275
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.4\. 我们正在构建的连接数组。请注意，每个可能的连接都存储在数组中。只有存在于我们的数据集中的连接才有非 0 的权重值。此外，请注意，我们的
    CSV 导入将权重值作为字符串创建。
- en: '![](../Images/07fig04.jpg)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/07fig04.jpg)'
- en: '[Figure 7.5](#ch07fig05) shows the resulting adjacency matrix based on the
    node list and edge list.'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7.5](#ch07fig05) 显示了基于节点列表和边列表的结果邻接矩阵。'
- en: Figure 7.5\. A weighted, directed adjacency matrix where lighter orange indicates
    weaker connections and darker orange indicates stronger connections. The source
    is on the y-axis, and the target is on the x-axis. The matrix shows that Sarah,
    Nadieh, and Hajra didn’t give anyone feedback, whereas Kai gave Susie feedback,
    and Susie gave Kai feedback (what we call a *reciprocated tie* in network analysis).
  id: totrans-278
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.5\. 一个加权、有向的邻接矩阵，其中浅橙色表示较弱的连接，深橙色表示较强的连接。源位于 y 轴，目标位于 x 轴。矩阵显示 Sarah、Nadieh
    和 Hajra 没有给任何人反馈，而 Kai 给了 Susie 反馈，Susie 也给了 Kai 反馈（我们在网络分析中称之为*互惠关系*）。
- en: '![](../Images/07fig05.jpg)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/07fig05.jpg)'
- en: You’ll notice in many adjacency matrices that the square indicating the connection
    from a node to itself is always filled. In network parlance this is a *self-loop*,
    and it occurs when a node is connected to itself. In our case, it would mean that
    someone gave themselves positive feedback, and fortunately no one in our dataset
    is a big enough loser to do that.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到在许多邻接矩阵中，表示节点到自身连接的方块总是被填充的。在网络的术语中，这被称为*自环*，它发生在节点连接到自身时。在我们的例子中，这意味着有人给自己提供了正反馈，幸运的是，在我们的数据集中没有人足够糟糕到去做这样的事情。
- en: 'If we want, we can add interactivity to help make the matrix more readable.
    Grids can be hard to read without something to highlight the row and column of
    a square. It’s simple to add highlighting to our matrix. All we have to do is
    add a mouseover event listener that fires a `gridOver` function to highlight all
    rectangles that have the same x or y value:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们愿意，我们可以添加交互性来帮助使矩阵更易于阅读。没有突出显示方块行和列的网格很难阅读。在我们的矩阵中添加高亮显示很简单。我们只需要添加一个鼠标悬停事件监听器，该监听器触发一个
    `gridOver` 函数来突出显示所有具有相同 x 或 y 值的矩形：
- en: '[PRE25]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Now you can see in [figure 7.6](#ch07fig06) how moving your cursor over a grid
    square highlights the row and column of that grid square.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以在[图 7.6](#ch07fig06)中看到，将光标移至网格方块上时，会突出显示该网格方块所在的行和列。
- en: Figure 7.6\. Adjacency highlighting of the column and row of the grid square.
    In this instance, the mouse is over the Erik-to-Kai edge, and as a result highlights
    the Erik row and the Kai column. You can see that Erik gave feedback to three
    people, whereas Kai received feedback from four people.
  id: totrans-284
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.6\. 网格方块的列和行邻接高亮显示。在这个例子中，鼠标位于 Erik 到 Kai 的边上，因此突出显示了 Erik 行和 Kai 列。你可以看到
    Erik 给了三个人反馈，而 Kai 则从四个人那里收到了反馈。
- en: '![](../Images/07fig06.jpg)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/07fig06.jpg)'
- en: 7.1.3\. Arc diagram
  id: totrans-286
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.1.3\. 弧图
- en: Another way to graphically represent networks is by using an arc diagram. An
    *arc diagram* arranges the nodes along a line and draws the links as arcs above
    and/or below that line (as seen in [figure 7.7](#ch07fig07)). Whereas adjacency
    matrices let you see edge dynamics quickly, arc diagrams let you see node dynamics
    quickly. You can see which nodes are isolated and which nodes have many connections,
    as well as get a ready sense of the directionality of those connections.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种图形表示网络的方法是使用弧图。*弧图*将节点沿一条线排列，并在该线之上和/或之下绘制链接（如图 7.7 所示）。与邻接矩阵让您快速看到边动态不同，弧图让您快速看到节点动态。您可以看到哪些节点是孤立的，哪些节点有很多连接，以及对这些连接方向性的直观感受。
- en: Figure 7.7\. The components of an arc diagram are circles for nodes and arcs
    for connections, with nodes laid out along a baseline and the location of the
    arc relative to that baseline indicative of the direction of the connection.
  id: totrans-288
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.7\. 弧图的组成部分是节点用圆圈表示，连接用弧线表示，节点沿基线排列，弧线相对于基线的位置表示连接的方向。
- en: '![](../Images/07fig07.jpg)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/07fig07.jpg)'
- en: Again, there isn’t a layout available for arc diagrams, and there are even fewer
    examples, but the principle is rather simple after you see the code. We build
    another pseudo-layout like we did with the adjacency matrix, but this time we
    need to process the nodes as well as the links, as shown in [listing 7.5](#ch07ex05).
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，弧图没有可用的布局，而且示例也更少，但代码一看，原理就相当简单。我们构建了一个类似于邻接矩阵的伪布局，但这次我们需要处理节点以及链接，如图 7.5
    所示。
- en: Listing 7.5\. Arc diagram code
  id: totrans-291
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.5\. 弧图代码
- en: '[PRE26]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '***1* Takes the results of the same Promise.all as adjacencyMatrix**'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 使用与 adjacencyMatrix 相同的 Promise.all 的结果**'
- en: '***2* Creates a hash that associates each node JSON object with its ID value
    and sets each node with an x position based on its array position**'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 创建一个哈希，将每个节点 JSON 对象与其 ID 值关联，并根据其数组位置设置每个节点的 x 位置**'
- en: '***3* Replaces the string ID of the node with a pointer to the JSON object**'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 将节点的字符串 ID 替换为指向 JSON 对象的指针**'
- en: '***4* Draws a basis-interpolated line from the source node to a computed middle
    point above them to the target node**'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 从源节点绘制一条基于基础插值的线到它们上面的计算中间点，再到目标节点**'
- en: Notice that the edges array that we built uses a hash with the ID value of our
    edges to create object references. By building objects that have references to
    the source and target nodes, we can easily calculate the graphical attributes
    of the `<line>` or `<path>` element we’re using to represent the connection. This
    is the same method used in the force layout that we’ll look at later in the chapter.
    The result of the code is your first arc diagram, shown in [figure 7.8](#ch07fig08).
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们构建的边数组使用一个哈希表，其中包含边的ID值来创建对象引用。通过构建具有对源和目标节点的引用的对象，我们可以轻松计算我们用来表示连接的`<line>`或`<path>`元素的图形属性。这是我们在本章后面将要查看的力布局中使用的方法。代码的结果是您的第一个弧图，如图7.8所示。
- en: Figure 7.8\. An arc diagram, with connections between nodes represented as arcs
    above and below the nodes. We can see the first (left) two nodes have no outgoing
    links, and the rightmost three nodes also have no outgoing links. The length of
    the arcs is meaningless and based on how we’ve laid the nodes out (nodes that
    are far away will have longer links), but the width of the arcs is based on the
    weight of the connection.
  id: totrans-298
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.8\. 一个弧图，节点之间的连接用节点上方和下方的弧线表示。我们可以看到前两个（左侧）节点没有出向链接，最右侧的三个节点也没有出向链接。弧线的长度没有意义，它基于我们如何布置节点（距离较远的节点将具有更长的链接），但弧线的宽度基于连接的权重。
- en: '![](../Images/07fig08.jpg)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/07fig08.jpg)'
- en: With abstract charts like these, you’re getting to the point where interactivity
    is no longer optional. Even though the links follow rules, and you’re not dealing
    with too many nodes or edges, it can be hard to make out what’s connected to what
    and how. You can add useful interactivity by having the edges highlight the connecting
    nodes on mouseover. You can also have the nodes highlight connected edges on mouseover
    by adding two new functions, as shown in [listing 7.6](#ch07ex06), with the results
    in [figure 7.9](#ch07fig09).
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这样的抽象图表，您已经达到了交互性不再是可选的程度。尽管链接遵循规则，并且您没有处理太多节点或边，但很难弄清楚什么连接到什么以及如何连接。您可以通过在鼠标悬停时突出显示连接节点来添加有用的交互性。您还可以通过添加两个新功能来使节点在鼠标悬停时突出显示连接的边，如[列表7.6](#ch07ex06)所示，结果如图7.9所示。
- en: Figure 7.9\. Mouseover behavior on edges (right), with the edge being moused
    over in orange, the source node in light green, and the target node in dark green.
    Mouseover behavior on nodes (left), with the node being moused over in orange
    and the connected edges in light orange.
  id: totrans-301
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.9\. 边的鼠标悬停行为（右侧），悬停的边为橙色，源节点为浅绿色，目标节点为深绿色。节点的鼠标悬停行为（左侧），悬停的节点为橙色，连接的边为浅橙色。
- en: '![](../Images/07fig09.jpg)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/07fig09.jpg)'
- en: Listing 7.6\. Arc diagram interactivity
  id: totrans-303
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.6\. 弧图交互性
- en: '[PRE27]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '***1* Makes a selection of all nodes to set the class of the node being hovered
    over to “active”**'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 选择所有节点以设置悬停节点的节点类为“active”**'
- en: '***2* Any edge where the selected node shows up as source or target renders
    as red**'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 任何选定的节点作为源或目标出现的边将以红色显示**'
- en: '***3* This nested if checks to see if a node is the source or target and sets
    its class accordingly**'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 这个嵌套if检查一个节点是否是源或目标，并相应地设置其类**'
- en: If you’re interested in exploring arc diagrams further and want to use them
    for larger datasets, you’ll also want to look into *hive plots*, which are arc
    diagrams arranged on spokes. We won’t deal with hive plots in this book, but there’s
    a plugin layout for hive plots that you can see at [https://github.com/d3/d3-plugins/tree/master/hive](https://github.com/d3/d3-plugins/tree/master/hive).
    Both the adjacency matrix and arc diagram benefit from the control you have over
    sorting and placing the nodes, as well as the linear manner in which they’re laid
    out.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想进一步探索弧图并希望将其用于更大的数据集，您还应该查看*蜂巢图*，它们是按辐条排列的弧图。本书中不会处理蜂巢图，但有一个用于蜂巢图的插件布局，您可以在[https://github.com/d3/d3-plugins/tree/master/hive](https://github.com/d3/d3-plugins/tree/master/hive)中查看。邻接矩阵和弧图都受益于您对排序和放置节点的控制，以及它们的线性布局方式。
- en: The next method for network visualization, which is our focus for the rest of
    the chapter, uses entirely different principles for determining how and where
    to place nodes and edges.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 网络可视化的下一个方法，也是本章剩余部分的重点，使用完全不同的原则来确定节点和边的放置方式和位置。
- en: 7.2\. Force-directed layout
  id: totrans-310
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2\. 力导向布局
- en: The *force layout* gets its name from the method by which it determines the
    most optimal graphical representation of a network (yet another instance of bad
    naming in data visualization). Like the word cloud and the Sankey diagram from
    [chapter 5](../Text/kindle_split_014.html#ch05), the `force()` layout dynamically
    updates the positions of its elements to find the best fit. Unlike those layouts,
    it does it continuously in real time rather than as a preprocessing step before
    rendering. The principle behind a force layout is the interplay between three
    forces, shown in [figure 7.10](#ch07fig10). These forces push nodes away from
    each other, attract connected nodes to each other, and keep nodes from flying
    out of sight.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '*力布局*的名字来源于它确定网络最优化图形表示的方法（数据可视化中又一例糟糕的命名）。像第5章中的词云和桑基图一样，`force()`布局动态更新其元素的位置以找到最佳匹配。与那些布局不同，它是在实时而不是在渲染前的预处理步骤中连续进行的。力布局背后的原理是三种力的相互作用，如图7.10所示。这些力将节点相互推开，将连接的节点相互吸引，并防止节点飞出视线。'
- en: 'Figure 7.10\. The forces in a force-directed algorithm: attraction/repulsion,
    gravity, and link attraction. Other factors, such as hierarchical packing and
    community detection, can also be factored into force-directed algorithms, but
    the aforementioned features are the most common. Forces are approximated for larger
    networks to improve performance.'
  id: totrans-312
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.10\. 力导向算法中的力：吸引力/排斥力、重力和链接吸引力。其他因素，如层次化打包和社区检测，也可以纳入力导向算法，但上述功能是最常见的。为了提高性能，对大型网络进行力近似。
- en: '![](../Images/07fig10_alt.jpg)'
  id: totrans-313
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/07fig10_alt.jpg)'
- en: In this section, you’ll learn how force-directed layouts work, how to make them,
    and general principles from network analysis that will help you better understand
    them. You’ll also learn how to add and remove nodes and edges, as well as adjust
    the settings of the layout on the fly.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将了解力导向布局的工作原理，如何创建它们，以及网络分析的一般原则，这些原则将帮助你更好地理解它们。你还将了解如何添加和删除节点和边，以及如何动态调整布局的设置。
- en: 7.2.1\. Playing with forces
  id: totrans-315
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.2.1\. 玩转力
- en: 'Before we get into networks with links, let’s look at a couple of forces to
    start with: x, y, charge, and collision. To initialize forces, you have to first
    initialize `d3.forceSimulation`, which calculates the effects of your forces and
    from which you draw your network. With the code in [listing 7.7](#ch07ex07), we’ll
    initialize a random dataset to play with and create a simple `forceSimulation`
    with only the `manyBody` force attracting nodes to each other.'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入研究带链接的网络之前，让我们先看看几个力：x、y、电荷和碰撞。要初始化力，你必须首先初始化`d3.forceSimulation`，它计算你的力的效果，并从其中绘制你的网络。在[列表7.7](#ch07ex07)中的代码中，我们将初始化一个随机数据集以进行实验，并创建一个仅包含`manyBody`力的简单`forceSimulation`，该力将节点相互吸引。
- en: Listing 7.7\. An initial force simulation with no links or collision detection
  id: totrans-317
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.7\. 无链接或碰撞检测的初始力模拟
- en: '[PRE28]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '***1* Creating a hundred circles ranging in size from .5 radius to 49.5**'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 创建一百个从0.5半径到49.5半径的圆圈**'
- en: '***2* Register a manyBody force with positive strength to make it attractive**'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 注册一个具有正强度的manyBody力以使其具有吸引力**'
- en: '***3* Register a center strength to try to make the nodes center at 250,250**'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 注册一个中心强度以尝试使节点中心位于250,250**'
- en: '***4* Attach the forces to our simulation**'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 将力附加到我们的模拟中**'
- en: '***5* Send the nodes array to simulation so it knows what to calculate with**'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 将节点数组发送到模拟中，以便它知道如何计算**'
- en: '***6* At each tick, have it run the updateNetwork function**'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 在每个滴答时运行updateNetwork函数**'
- en: '***7* Draw a circle for each datapoint**'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 为每个数据点画一个圆圈**'
- en: '***8* Each time the simulation ticks, update their position based on the newly
    calculated position by the simulation**'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8* 每次模拟时钟滴答时，根据模拟计算的新位置更新它们的位置**'
- en: Your first implementation of `forceSimulation` is going to be pretty unimpressive,
    though, with results looking something like [figure 7.11](#ch07fig11). The circles
    will bounce around a bit and finally settle on top of each other—which, if you
    think about it, is exactly what you might expect if you made all the circles attractive
    to each other.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你的第一次`forceSimulation`实现可能不会太令人印象深刻，结果看起来可能像[图7.11](#ch07fig11)所示。圆圈会四处弹跳，最终堆叠在一起——如果你这么想，这正是如果你使所有圆圈相互吸引时你可能期望的结果。
- en: Figure 7.11\. The results of a force simulation where the only force acting
    on the nodes is attraction
  id: totrans-328
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.11\. 仅节点受到吸引力作用的力模拟结果
- en: '![](../Images/07fig11.jpg)'
  id: totrans-329
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/07fig11.jpg)'
- en: 'To make this a bit more interesting, let’s register a “collide” force using
    `d3.force-Collide` and setting it to base the collision detection off the size
    of each node (its `.r` attribute):'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个例子更有趣，让我们使用 `d3.force-Collide` 注册一个“碰撞”力，并将其设置为基于每个节点的大小（其 `.r` 属性）进行碰撞检测：
- en: '[PRE29]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: With this in place, we get a simple bubble chart of our data, as we see in [figure
    7.12](#ch07fig12).
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，我们得到了一个简单的气泡图，如图 7.12 所示。
- en: Figure 7.12\. Our sample node data laid out with collision detection. This is
    one way to create a simple bubble chart.
  id: totrans-333
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.12\. 使用碰撞检测布局的样本节点数据。这是创建简单气泡图的一种方法。
- en: '![](../Images/07fig12.jpg)'
  id: totrans-334
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/07fig12.jpg)'
- en: The last thing we want to look at is using x- and y-constraints to lay out our
    nodes. If we replace our random data with normally distributed random data and
    add an x-constraint to keep it in a line and a y-constraint to have its y position
    correspond to its value, we can produce a beeswarm plot, as in the following listing.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后要考虑的是使用 x 和 y 约束来布局我们的节点。如果我们用正态分布的随机数据替换随机数据，并添加一个 x 约束以使其成一行，以及一个 y 约束以使其
    y 位置对应其值，我们就可以生成蜜蜂群图，如下面的列表所示。
- en: Listing 7.8\. Code modifications for a beeswarm plot
  id: totrans-336
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.8\. 蜜蜂群图的代码修改
- en: '[PRE30]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '***1* A normally distributed bunch of points that we’ve offset so they can
    easily appear onscreen**'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 一堆正态分布的点，我们已将其偏移，以便它们可以轻松地出现在屏幕上**'
- en: '***2* Exert a force on each node that tries to make its x position as close
    to 100 as possible**'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 对每个节点施加一个力，使其 x 位置尽可能接近 100**'
- en: '***3* Exert a stronger force on each node that tries to make its y position
    reflect its value**'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 对每个节点施加更强的力，使其 y 位置反映其值**'
- en: The result of your simulation this time tries to arrange each node in a way
    that they’re laid out along a shared x-axis but positioned to show their value.
    This beeswarm plot, as you see in [figure 7.13](#ch07fig13), is pretty popular
    and allows you to show distributions while maintaining individual sample points.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 这次模拟的结果试图以这种方式排列每个节点，即它们沿共享的 x 轴排列，但位置显示它们的值。如图 7.13 所示，这种蜜蜂群图相当流行，允许您在保持单个样本点的同时显示分布。
- en: Figure 7.13\. A beeswarm plot created with our code (rotated to better fit on
    the page)
  id: totrans-342
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.13\. 使用我们的代码创建的蜜蜂群图（旋转以更好地适应页面）
- en: '![](../Images/07fig13.jpg)'
  id: totrans-343
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/07fig13.jpg)'
- en: 7.2.2\. Creating a force-directed network diagram
  id: totrans-344
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.2.2\. 创建力导向网络图
- en: The `forceSimulation()`layout that you’ve been using and which you see initialized
    in [listing 7.9](#ch07ex09) has even more settings. The `nodes()` method that
    we already used is similar to the one you saw in the Sankey layout in [chapter
    5](../Text/kindle_split_014.html#ch05), but links in `forceSimulation` are registered
    with a “link” force that takes, as you’d expect, the settings for how the links
    describe source and target as well as an array of those links. We need to take
    the links from edges.csv and change the source and target into objects like we
    did with the arc diagram. That’s the formatting that `forceSimulation()` expects.
    It also accepts integer values where the integer values correspond to the array
    position of a node in the nodes array, like the formatting of data for the Sankey
    diagram links array from [chapter 5](../Text/kindle_split_014.html#ch05). Other
    than the links force, the only new setting we have is to use `forceManyBody` with
    a negative value, meaning that nodes will push each other away. This will result
    in connected nodes attracted to connected nodes and create the kind of network
    diagram people are familiar with.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 您一直在使用的 `forceSimulation()` 布局，您在 [列表 7.9](#ch07ex09) 中看到的初始化，还有更多设置。我们之前使用的
    `nodes()` 方法与您在 [第 5 章](../Text/kindle_split_014.html#ch05) 中看到的桑基图布局中的方法类似，但在
    `forceSimulation` 中的链接是通过一个“链接”力注册的，这个力按照您预期的设置描述了源和目标，以及那些链接的数组。我们需要从 edges.csv
    中获取链接，并将源和目标转换为与我们在弧形图中做的那样，转换为对象。这就是 `forceSimulation()` 所期望的格式。它还接受整数值，其中整数值对应于节点数组中节点的数组位置，就像
    [第 5 章](../Text/kindle_split_014.html#ch05) 中桑基图链接数组的格式。除了链接力之外，我们唯一的新设置是使用 `forceManyBody`
    并设置一个负值，这意味着节点会相互推开。这将导致连接的节点相互吸引，并创建人们熟悉的那种网络图。
- en: Listing 7.9\. Force layout function
  id: totrans-346
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.9\. 力布局函数
- en: '[PRE31]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '***1* How much each node pushes away each other—if set to a positive value,
    nodes attract each other**'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 每个节点相互推开的程度——如果设置为正值，节点会相互吸引**'
- en: '***2* Key values for your nodes and edges will help when we update the network
    later**'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 当我们稍后更新网络时，节点和边的键值将有所帮助**'
- en: The animated nature of the force layout is lost on the page, but you can see
    in [figure 7.14](#ch07fig14) general network structure that’s less prominent in
    an adjacency matrix or arc diagram. It’s readily apparent that there are dense
    and sparse parts of the network, with key brokers like Zan who connect two different
    groups. We can also see that two people aren’t connected to anyone, having neither
    given nor received feedback. The only reason those nodes are still onscreen is
    because the layout’s gravity pulls unconnected pieces toward the center. We can
    see that our two managers both gave feedback to only two people, but that they
    have different positions in the structure of our two teams. If Irene quit tomorrow,
    there wouldn’t be much change in this network, but if Zan quit, then the two teams
    wouldn’t have any communication with each other.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 力导向布局的动画性质在页面上消失了，但你可以在[图 7.14](#ch07fig14)中看到一般网络结构，这在邻接矩阵或弧图中不太突出。很明显，网络中存在密集和稀疏的部分，关键经纪人如
    Zan 连接了两个不同的群体。我们还可以看到，有两个人没有连接任何人，既没有给出也没有收到反馈。这些节点仍然在屏幕上的唯一原因是布局的重力将未连接的部分拉向中心。我们可以看到，我们的两位经理只向两个人提供了反馈，但他们在我们两个团队的结构中处于不同的位置。如果
    Irene 明天辞职，这个网络不会有太大的变化，但如果 Zan 辞职，那么两个团队之间将没有任何沟通。
- en: Figure 7.14\. A force-directed layout based on our dataset and organized graphically
    using default settings in the force layout. Managers are in orange, employees
    green, and contractors purple.
  id: totrans-351
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.14\. 基于我们的数据集和默认设置在力导向布局中图形化组织的一种力导向布局。经理用橙色表示，员工用绿色表示，承包商用紫色表示。
- en: '![](../Images/07fig14.jpg)'
  id: totrans-352
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/07fig14.jpg)'
- en: The thickness of the lines corresponds to the strength of connection. But although
    we have edge strength, we’ve lost the direction of the edges in this layout. You
    can tell that the network is directed only because the links are drawn as semitransparent,
    so you can see when two links of different weights overlap each other. We need
    to use a method to show if these links are to or from a node. One way to do this
    is to turn our lines into arrows using SVG markers.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 线条的粗细对应于连接的强度。但尽管我们有了边强度，在这个布局中我们失去了边的方向。你可以通过链接以半透明的方式绘制，从而知道不同权重的链接何时重叠。我们需要使用一种方法来显示这些链接是向节点还是从节点发出的。一种方法是将我们的线条转换为箭头，使用
    SVG 标记。
- en: 7.2.3\. SVG markers
  id: totrans-354
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.2.3\. SVG 标记
- en: Sometimes you want to place a symbol, such as an arrowhead, on a line or path
    that you’ve drawn. In that case, you have to define a marker in your `svg:defs`
    and then associate that marker with the element on which you want it to draw.
    You can define your marker statically in HTML or create it dynamically like any
    SVG element, as we’ll do next. The marker we define can be any sort of SVG shape,
    but we’ll use a path because it lets us draw an arrowhead. A marker can be drawn
    at the start, end, or middle of a line, and has settings to determine its direction
    relative to its parent element. See the following listing.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你希望在绘制的线条或路径上放置一个符号，例如箭头。在这种情况下，你必须在 `svg:defs` 中定义一个标记，并将其与你想在上面绘制的元素关联起来。你可以在
    HTML 中静态定义你的标记，或者像任何 SVG 元素一样动态创建它，就像我们接下来要做的那样。我们定义的标记可以是任何类型的 SVG 形状，但我们将使用路径，因为它允许我们绘制箭头。标记可以绘制在线条的开始、结束或中间，并且有设置来确定其相对于父元素的方向。请参阅以下列表。
- en: Listing 7.10\. Marker definition and application
  id: totrans-356
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.10\. 标记定义和应用
- en: '[PRE32]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '***1* The default setting for markers bases their size off the stroke-width
    of the parent, which in our case would result in difficult-to-read markers**'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 标记的默认设置基于父元素的 stroke-width，在我们的情况下会导致难以阅读的标记**'
- en: '***2* A marker is assigned to a line by setting the marker-end, marker-start,
    or marker-mid attribute to point to the marker**'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 通过设置 marker-end、marker-start 或 marker-mid 属性指向标记，将标记分配给线条**'
- en: With the markers defined in [listing 7.10](#ch07ex10), you can now read the
    network (as shown in [figure 7.15](#ch07fig15)) more effectively. You see how
    the nodes are connected to each other and you can spot which nodes have reciprocal
    ties with each other (where nodes are connected in both directions). Reciprocation
    is important to identify, because there’s a big difference between people who
    favorite Katy Perry’s tweets and people whose tweets are favorited by Katy Perry
    (the current Twitter user with the most followers). Direction of edges is important,
    but you can represent direction in other ways, such as using curved edges or edges
    that grow fatter on one end than the other. To do something like that, you’d need
    to use a `<path>` rather than a `<line>` for the edges like we did with the Sankey
    layout or the arc diagram.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 在[列表7.10](#ch07ex10)中定义了标记后，您现在可以更有效地阅读网络（如图7.15所示）。您可以看到节点是如何相互连接的，并且可以找出哪些节点之间有相互联系（节点在两个方向上都有连接）。相互联系是重要的，因为喜欢凯蒂·佩里推文的人和被凯蒂·佩里喜欢的推文的人之间有很大的区别（凯蒂·佩里是当前拥有最多追随者的Twitter用户）。边的方向很重要，但您可以用其他方式表示方向，例如使用曲线边或一端比另一端更粗的边。要实现类似的功能，您需要使用`<path>`而不是我们用于桑基布局或弧形图的`<line>`。
- en: 'Figure 7.15\. Edges now display markers (arrowheads) indicating the direction
    of connection. Notice that all the arrowheads are the same size. You can control
    the color of the arrowheads by using CSS rules such as `marker > path {fill: #
    93C464;}`.'
  id: totrans-361
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '图7.15。现在边现在显示标记（箭头）以指示连接的方向。请注意，所有箭头的大小都相同。您可以通过使用CSS规则如`marker > path {fill:
    # 93C464;}`来控制箭头的颜色。'
- en: '![](../Images/07fig15.jpg)'
  id: totrans-362
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/07fig15.jpg)'
- en: If you’ve run this code on your own, your network should look exactly like [figure
    7.15](#ch07fig15). That’s because even though network visualizations created with
    force-directed layouts are the result of the interplay of forces, D3’s force simulation
    is deterministic as long as the inputs don’t change. However, if your network
    inputs are constantly changing, one way to help your readers is to generate a
    network using a force-directed layout and then fix it in place to create a network
    basemap. You can then apply any later graphical changes to that fixed network.
    The concept of a basemap comes from geography and in network visualization refers
    to the use of the same layout with differently sized and/or colored nodes and
    edges. It allows readers to identify regions of the network that are significantly
    different according to different measures. You can see this concept of a basemap
    in use in [figure 7.16](#ch07fig16), which shows how one network can be measured
    in multiple ways.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在自己的机器上运行了这段代码，您的网络应该看起来与[图7.15](#ch07fig15)完全一样。这是因为尽管使用力导向布局创建的网络可视化是力的相互作用的结果，但只要输入没有变化，D3的力模拟就是确定性的。然而，如果您的网络输入不断变化，帮助读者的一个方法就是使用力导向布局生成网络，并将其固定以创建网络底图。然后，您可以对该固定网络应用任何后续的图形更改。底图的概念来自地理学，在网络可视化中指的是使用不同大小和/或颜色的节点和边相同的布局。这允许读者根据不同的度量标准识别网络中显著不同的区域。您可以在[图7.16](#ch07fig16)中看到底图的使用，它展示了同一个网络可以用多种方式来衡量。
- en: Figure 7.16\. The same network measured using degree centrality (top left),
    closeness centrality (top right), eigenvector centrality (bottom left), and betweenness
    centrality (bottom right). We’ll only see degree centrality, but you can explore
    the others with libraries like jsnetworkx.js. More-central nodes are larger and
    bright red, whereas less-central nodes are smaller and gray. Notice that although
    some nodes are central according to all measures, their relative centrality varies,
    as does the overall centrality of other nodes.
  id: totrans-364
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.16。使用度中心性（左上角）、接近中心性（右上角）、特征向量中心性（左下角）和中介中心性（右下角）测量的相同网络。我们只看到度中心性，但您可以使用jsnetworkx.js等库探索其他中心性。中心性更高的节点更大且呈鲜红色，而中心性较低的节点较小且为灰色。请注意，尽管一些节点根据所有度量标准都是中心节点，但它们的相对中心性各不相同，其他节点的整体中心性也是如此。
- en: '![](../Images/07fig16.jpg)'
  id: totrans-365
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/07fig16.jpg)'
- en: '|  |'
  id: totrans-366
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Infoviz term: hairball**'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '**信息可视化术语：毛线球**'
- en: Network visualizations are impressive, but they can also be so complex that
    they’re unreadable. For this reason, you’ll encounter critiques of networks that
    are too dense to be readable. These network visualizations are often referred
    to as *hairballs* due to extensive overlap of edges that make them resemble a
    mass of unruly hair.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 网络可视化令人印象深刻，但它们也可能过于复杂，以至于难以阅读。因此，你可能会遇到对过于密集而难以阅读的网络进行的批评。这些网络可视化通常被称为*毛线球*，因为它们边缘的广泛重叠使它们看起来像一团杂乱无章的头发。
- en: If you think a force-directed layout is hard to read, you can pair it with another
    network visualization such as an adjacency matrix and highlight both as the user
    navigates either visualization. You’ll see techniques for pairing visualizations
    like this in [chapter 11](../Text/kindle_split_022.html#ch11).
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你认为力导向布局难以阅读，你可以将其与另一种网络可视化，如邻接矩阵搭配，并在用户导航任一可视化时突出显示两者。你可以在[第11章](../Text/kindle_split_022.html#ch11)中看到这种搭配可视化技术的示例。
- en: '|  |'
  id: totrans-370
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The force-directed layout provides the added benefit of seeing larger structures.
    Depending on the size and complexity of your network, they may be enough. But
    you may need to represent other network measurements when working with network
    data.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '力导向布局提供了看到更大结构的额外好处。根据你的网络的大小和复杂性，这可能是足够的。但在处理网络数据时，你可能需要表示其他网络度量。 '
- en: 7.2.4\. Network measures
  id: totrans-372
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.2.4. 网络度量
- en: Networks have been studied for a long time—at least for decades; if you consider
    graph theory in mathematics, for centuries. As a result, you may encounter a few
    terms and measures when working with networks. This is only meant to be a brief
    overview. If you want to learn more about networks, I would suggest reading the
    excellent introduction to networks and network analysis by S. Weingart, I. Milligan,
    and S. Graham at [www.themacroscope.org/?page_id=337](http://www.themacroscope.org/?page_id=337).
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 网络已经被研究了很长时间——至少几十年；如果你考虑数学中的图论，那可能就是几个世纪。因此，在处理网络时，你可能会遇到一些术语和度量。这只是一个简要概述。如果你想了解更多关于网络的知识，我建议阅读S.
    Weingart、I. Milligan和S. Graham关于网络和网络分析的出色介绍，可以在[www.themacroscope.org/?page_id=337](http://www.themacroscope.org/?page_id=337)找到。
- en: Edge weight
  id: totrans-374
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 边权重
- en: You’ll notice that our dataset contains a `weight` value for each link. This
    represents the strength of the connection between two nodes. In our case, we assume
    that the more favorites, the stronger a connection that one Twitter user has.
    I drew thicker lines for a higher weight, but we can also adjust the way the force
    layout works based on that weight, as you’ll see next.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到我们的数据集中包含了每个链接的`权重`值。这代表了两个节点之间连接的强度。在我们的案例中，我们假设拥有更多收藏夹的Twitter用户拥有更强的连接。我为更高的权重画了更粗的线条，但我们也可以根据那个权重调整力布局的工作方式，就像你接下来会看到的那样。
- en: Centrality
  id: totrans-376
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 中心性
- en: Networks are representations of systems, and one of the things you want to know
    about the nodes in a system is which ones are more important than the others,
    referred to as *centrality*. Central nodes are considered to have more power or
    influence in a network. There are many different measurements of centrality, a
    few of which are shown in [figure 7.16](#ch07fig16), and different measures more
    accurately assess centrality in different network types.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 网络是系统的表示，你想要了解系统中的节点之一是哪些比其他节点更重要，这被称为*中心性*。中心节点被认为在网络中拥有更多的权力或影响力。中心性的测量方法有很多种，其中一些在[图7.16](#ch07fig16)中展示，不同的测量方法可以更准确地评估不同网络类型中的中心性。
- en: Degree
  id: totrans-378
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 度
- en: Degree, also known as *degree centrality*, is the total number of links that
    are connected to a node. In our example data, Mo has a degree of 6, because he’s
    the source or target of 6 links. Degree is a rough measure of the importance of
    a node in a network, because you assume that people or things with more connections
    have more power or influence in a network. Weighted degree is used to refer to
    the total value of the connections to a node, which would give Mo a value of 18\.
    Further, you can differentiate degree into *in degree* and *out degree*, which
    are used to distinguish between incoming and outgoing links, and which for Mo’s
    case would be 4 and 2, respectively.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 度，也称为*度中心性*，是一个节点连接到的链接总数。在我们的示例数据中，Mo的度数为6，因为他有6个链接的源或目标。度是衡量网络中节点重要性的粗略指标，因为你假设拥有更多连接的人或事物在网络中拥有更多的权力或影响力。加权度用于指代连接到节点的总价值，这将使Mo的值为18。此外，你还可以将度区分为*入度*和*出度*，它们用于区分传入和传出链接，对于Mo的情况，分别是4和2。
- en: 'You can calculate degree centrality easily by filtering the edges array to
    show only links that involve that node:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过过滤边数组来轻松计算度中心性，只显示涉及该节点的链接：
- en: '[PRE33]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We’ll use that to affect the way the force layout runs. For now, let’s add
    a button that resizes the nodes based on their `weight` attribute:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用这个功能来影响力导向布局的运行方式。现在，让我们添加一个按钮，根据节点的`weight`属性来调整节点大小：
- en: '[PRE34]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[Figure 7.17](#ch07fig17) shows the value of the degree centrality measure.
    Although you can see and easily count the connections and nodes in this small
    network, being able to spot at a glance the most and least connected nodes is
    extremely valuable. Notice that we’re counting links in both directions, so that
    even though Kai and Tony are connected to the same number of people, Kai’s circle
    is slightly larger because he’s involved in more connections total (to and from).'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '[图7.17](#ch07fig17)显示了度中心性测量的值。虽然你可以看到并轻松计数这个小网络中的连接和节点，但能够一眼看出最和最不连接的节点是非常有价值的。请注意，我们正在计算双向链接，因此尽管凯伊和托尼连接到的人数相同，但凯伊的圆圈略大，因为他参与的总连接更多（来和去）。'
- en: Figure 7.17\. Sizing nodes by weight indicates the number of total connections
    for each node by setting the radius of the circle equal to the weight times 2.
  id: totrans-385
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.17\. 通过设置圆的半径等于权重乘以2，按权重调整节点大小表示每个节点的总连接数。
- en: '![](../Images/07fig17.jpg)'
  id: totrans-386
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/07fig17.jpg)'
- en: Clustering and modularity
  id: totrans-387
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 聚类和模块度
- en: One of the most important things to find out about a network is whether any
    communities exist in that network and what they look like. This is done by looking
    at whether certain nodes are more connected to each other than to the rest of
    the network, known as *modularity*. You can also look at whether nodes are interconnected,
    known as *clustering*. Cliques, mentioned earlier, are part of the same measurement,
    and *clique* is a term for a group of nodes that are fully connected to each other.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 了解一个网络最重要的几个方面之一是判断该网络中是否存在社区以及它们是什么样的。这通过观察某些节点是否比网络中的其他部分更紧密地连接在一起来实现，这被称为*模块度*。你也可以观察节点是否相互连接，这被称为*聚类*。前面提到的派系是同一测量的一部分，*派系*是指一组完全相互连接的节点。
- en: 'Notice that this interconnectedness and community structure are supposed to
    arise visually out of a force-directed layout. You see the four highly connected
    users in a cluster and the other users farther away. If you’d prefer to measure
    your networks to try to reveal these structures, you can see an implementation
    of a community detection algorithm implemented in libraries like `jLouvain` at
    [https://github.com/upphiminn/jLouvain](https://github.com/upphiminn/jLouvain).
    This algorithm runs in the browser and can be integrated with your network quite
    easily to color your network based on community membership or even organize the
    network visually based on module as you can see here:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这种相互关联和社区结构应该从力导向布局中直观地出现。你看到四个高度连接的用户在一个集群中，其他用户则远离。如果你更喜欢测量你的网络以尝试揭示这些结构，你可以在[https://github.com/upphiminn/jLouvain](https://github.com/upphiminn/jLouvain)这样的库中找到一个社区检测算法的实现。此算法在浏览器中运行，可以很容易地与你的网络集成，根据社区成员资格着色你的网络，甚至根据模块组织网络，就像你在这里看到的那样：
- en: '[http://bl.ocks.org/emeeks/302096884d5fbc1817062492605b50dd](http://bl.ocks.org/emeeks/302096884d5fbc1817062492605b50dd).'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://bl.ocks.org/emeeks/302096884d5fbc1817062492605b50dd](http://bl.ocks.org/emeeks/302096884d5fbc1817062492605b50dd)。'
- en: 7.2.5\. Force layout settings
  id: totrans-391
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.2.5\. 力导向布局设置
- en: When we initialized our force layout, we started out with a charge setting of
    –1000\. Charge and a few other settings give you more control over the way the
    force layout runs.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们初始化力导向布局时，我们开始时的电荷设置为-1000。电荷和几个其他设置可以让你更控制力导向布局的运行方式。
- en: Charge
  id: totrans-393
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 电荷
- en: '*Charge* sets the rate at which nodes push each other away or attract each
    other. If you don’t set the charge strength, then it has a default setting of
    –30\. Along with setting fixed values for charge, you can use an accessor function
    to base the charge values on an attribute of the node. For instance, you could
    base the charge on the weight (the degree centrality) of the node so that nodes
    with many connections push nodes away more, giving them more space on the chart.'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '*电荷*设置节点相互推开或吸引的速度。如果你不设置电荷强度，则默认设置为-30。除了设置固定的电荷值外，你还可以使用访问器函数，根据节点的属性来设置电荷值。例如，你可以根据节点的权重（度中心性）来设置电荷，这样连接数量多的节点会推开其他节点，在图表上给它们更多的空间。'
- en: Negative charge values represent repulsion in a force-directed layout, but you
    could set them to positive if you wanted your nodes to exert an attractive force.
    This would cause problems with a traditional network visualization but may come
    in handy for a more complicated visualization.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 在力导向布局中，负电荷值表示排斥，但如果你想让节点施加吸引力，你可以将它们设置为正值。这可能会在传统的网络可视化中引起问题，但对于更复杂的可视化可能很有用。
- en: Gravity
  id: totrans-396
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 重力
- en: With This used to be a universal gravity setting that has now been replaced
    by independent x- and y-constraints. The other way to center your network, which
    we’ve been using, is to visually center it using the center constraint. You’ll
    want to experiment with gravity when that visual centering isn’t enough.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 这曾经是一个通用的重力设置，但现在已被独立的x和y约束所取代。我们一直在使用的另一种将网络居中的方法是使用中心约束在视觉上居中它。当这种视觉居中不够时，你将想要尝试重力。
- en: linkForce
  id: totrans-398
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: linkForce
- en: Attraction between nodes is determined by setting the `strength` property of
    the “link” force. Setting your `link.strength()` parameter too high causes your
    network to fold back in on itself, which you can identify by the presence of prominent
    triangles in the network visualization.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 节点之间的吸引力是通过设置“链接”力的`strength`属性来确定的。将你的`link.strength()`参数设置得太高会导致你的网络折叠回自身，你可以通过网络可视化中突出的三角形来识别这一点。
- en: 'You can set `link.strength` to be a function and associate it with edge weight
    so that edges with higher or lower weight values have lower or higher distance
    settings. A force layout is a physical simulation, meaning it uses physical metaphors
    to arrange the network to its optimal graphical shape. If your network has stronger
    and weaker links, as our example does, then it makes sense to have those edges
    exert stronger and weaker effects on the controlling nodes. As a result, people
    who have rated their confidence in their coworkers higher will be visually closer
    to those coworkers than people who have rated their confidence as lower:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将`link.strength`设置为一个函数，并将其与边权重关联起来，以便具有更高或更低权重值的边具有更低或更高的距离设置。力布局是一个物理模拟，这意味着它使用物理隐喻来安排网络以最佳图形形状。如果你的网络有更强和更弱的链接，如我们的示例所示，那么让这些边对控制节点施加更强或更弱的影响是有意义的。因此，那些对其同事的信心评分较高的人将与那些评分较低的人相比，在视觉上更接近那些同事：
- en: '[PRE35]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We’re ramping up the repulsive charge because we’re increasing the maximum link
    strength to 10\. We’re also using canvas gravity with x and y forces because that
    repulsive charge will push nodes offscreen. [Figure 7.18](#ch07fig18) dramatically
    demonstrates the results, which reflect the weak nature of several of the connections.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在增加排斥电荷，因为我们正在将最大链接强度增加到10。我们还使用画布重力与x和y力一起使用，因为这种排斥电荷会将节点推离屏幕。[图7.18](#ch07fig18)显著展示了结果，这些结果反映了几个连接的弱性质。
- en: Figure 7.18\. By basing the strength of the attraction between nodes on the
    strength of the connections between nodes, you see a dramatic change in the structure
    of the network. The weaker connections between x and y allow that part of the
    network to drift away.
  id: totrans-403
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.18\. 通过将节点之间吸引力的强度基于节点之间连接的强度，你可以看到网络结构的显著变化。x和y之间的较弱连接允许网络的那部分漂移开去。
- en: '![](../Images/07fig18.jpg)'
  id: totrans-404
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/07fig18.jpg)'
- en: 7.2.6\. Updating the network
  id: totrans-405
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.2.6\. 更新网络
- en: When you create a network, you want to provide your users with the ability to
    add or remove nodes to the network, or drag them around. You may also want to
    adjust the various settings dynamically rather than changing them when you first
    create the force layout.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建一个网络时，你希望为用户提供添加或删除节点到网络，或拖动它们的能力。你可能还希望动态地调整各种设置，而不是在第一次创建力布局时更改它们。
- en: Stopping and restarting the layout
  id: totrans-407
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 停止和重新启动布局
- en: The force layout is designed to “cool off” and eventually stop after the network
    is laid out well enough that the nodes no longer move to new positions. When the
    layout has stopped like this, you’ll need to restart it if you want it to animate
    again. Also, if you’ve made any changes to the force settings or want to add or
    remove parts of the network, then you’ll need to stop it and restart it.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 力布局设计为在网络布局得足够好，节点不再移动到新位置后“冷却”并最终停止。当布局以这种方式停止时，如果你想再次让它动画化，你需要重新启动它。此外，如果你对力设置进行了任何更改或想要添加或删除网络的部分，那么你需要停止它并重新启动它。
- en: stop()
  id: totrans-409
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: stop()
- en: You can turn off the force interaction by using `simulation.stop()`, which stops
    running the simulation. It’s good to stop the network when there’s an interaction
    with a component elsewhere on your web page or a change in the styling of the
    network, and then restart it once that interaction is over.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用 `simulation.stop()` 来关闭力交互，这将停止运行模拟。当你的网页上的其他组件发生交互或网络样式发生变化时，停止网络是很好的，一旦交互结束，再重新启动它。
- en: restart()
  id: totrans-411
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: restart()
- en: To begin or restart the animation of the layout, use `simulation.restart()`.
    You don’t have to start the simulation when you first create it, it’s started
    automatically.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始或重新启动布局的动画，请使用 `simulation.restart()`。你不必在首次创建时启动模拟，它是自动启动的。
- en: tick()
  id: totrans-413
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: tick()
- en: Finally, if you want to move the layout forward one step, you can use `simulation.tick()`.
    Force layouts can be resource-intensive, and you may want to use one for a few
    seconds rather than let it run continuously. You can also precalculate your chart
    if you don’t need the fancy animation, so you could `simulation.tick(120)` to
    precalculate your beeswarm plot before you lay it out. Simulating the network
    without graphically animating it is much faster, and you can use D3 transitions
    to animate the movement of the nodes to their final precalculated position.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果你想将布局向前移动一步，你可以使用 `simulation.tick()`。力布局可能很耗费资源，你可能只想运行几秒钟而不是让它持续运行。如果你不需要复杂的动画，你也可以预先计算你的图表，这样你就可以在布局之前使用
    `simulation.tick(120)` 预先计算你的蜜蜂群图。在没有图形动画的情况下模拟网络要快得多，你还可以使用 D3 过渡来动画化节点移动到它们最终预先计算的位置。
- en: force.drag()
  id: totrans-415
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: force.drag()
- en: With traditional network analysis programs, the user can drag nodes to new positions.
    This is implemented using the behavior `d3.drag()`. A *behavior* is like a component
    in that it’s called by an element using `.call()`, but instead of creating SVG
    elements, it creates a set of event listeners.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的网络分析程序中，用户可以将节点拖动到新的位置。这是通过使用行为 `d3.drag()` 来实现的。行为就像一个组件，因为它通过 `.call()`
    被元素调用，但它不创建 SVG 元素，而是创建一组事件监听器。
- en: In the case of `d3.drag()`, those event listeners correspond to dragging events
    that give you the ability to click and drag your nodes around while the force
    layout runs. You can enable dragging on all your nodes by selecting them and calling
    `d3.drag()` on that selection. See the following listing.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `d3.drag()` 的情况下，这些事件监听器对应于拖动事件，它赋予你在力布局运行时点击和拖动节点的能力。你可以通过选择它们并在该选择上调用 `d3.drag()`
    来在所有节点上启用拖动。请参见以下列表。
- en: Listing 7.11\. Setting up drag for networks
  id: totrans-418
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.11\. 为网络设置拖动
- en: '[PRE36]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '***1* The drag behavior also exposes a “start” and “end” event**'
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 拖动行为也暴露了“开始”和“结束”事件**'
- en: '***2* This will give us the event so we can get the current x and y coordinates**'
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 这将给我们事件，以便我们可以获取当前的 x 和 y 坐标**'
- en: '***3* Setting fx or fy sets the fixed position of the node**'
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 设置 fx 或 fy 设置节点的固定位置**'
- en: '***4* If the simulation has cooled down enough, heat it back up and restart
    it**'
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 如果模拟已经足够冷却，就重新加热并重新启动**'
- en: '***5* Assign the drag behavior to the nodes**'
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 将拖动行为分配给节点**'
- en: Fixed node positions
  id: totrans-425
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 固定节点位置
- en: As a force layout runs, it checks to see if each node has .fx or .fy attributes
    and doesn’t adjust the x and/or y position of nodes that have them. One effective
    interaction technique is to set a node as fixed when the user interacts with it.
    This allows users to drag nodes to a position on the canvas so they can visually
    sort the important nodes. The effect of dragging some of our nodes is shown in
    [figure 7.19](#ch07fig19).
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 当力布局运行时，它会检查每个节点是否有 .fx 或 .fy 属性，并且不会调整具有这些属性的节点的 x 和/或 y 位置。一种有效的人际交互技术是在用户与之交互时将节点设置为固定。这允许用户将节点拖动到画布上的某个位置，以便他们可以直观地对重要节点进行排序。拖动我们的一些节点的影响如图
    7.19 所示。
- en: Figure 7.19\. The two nodes representing managers have been dragged to the top
    corners, allowing the rest of the nodes to take their positions based on the forces
    of the simulation (being dragged toward the center along with being dragged toward
    the fixed nodes).
  id: totrans-427
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.19\. 代表管理员的两个节点已被拖动到顶部角落，允许其余节点根据模拟的力（被拖向中心的同时被拖向固定节点）占据其位置。
- en: '![](../Images/07fig19.jpg)'
  id: totrans-428
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/07fig19.jpg)'
- en: 7.2.7\. Removing and adding nodes and links
  id: totrans-429
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.2.7\. 移除和添加节点和链接
- en: When dealing with networks, you may want to filter the networks or give the
    user the ability to add or remove nodes. To filter a network, you need to `stop()`
    it, remove any nodes and links that are no longer part of the network, rebind
    those arrays to the force layout, and then `restart()` the layout.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理网络时，您可能想要过滤网络或给用户添加或删除节点的权限。要过滤网络，您需要 `stop()` 它，移除任何不再是网络一部分的节点和链接，将这些数组重新绑定到力布局，然后
    `restart()` 布局。
- en: This can be done as a filter on the array that makes up your nodes. For instance,
    we may want to only see the network without contractors and managers, so we can
    see who the most influential peers are and how only the employee network looks.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过对构成您的节点数组的过滤来实现。例如，我们可能只想看到没有承包商和经理的网络，这样我们就可以看到最有影响力的同侪是谁，以及员工网络是如何的。
- en: If we got rid of the nodes, we’d still have links in our layout that reference
    nodes which no longer exist. We’ll need a more involved filter for our links array.
    By using the `.indexOf` function of an array, though, we can easily create our
    filtered links by checking to see if the source and target are both in our filtered
    nodes array. Because we used key values when we first bound our arrays to our
    selection in [listing 7.12](#ch07ex12), we can use the `selection.exit()` behavior
    to easily update our network. You can see how to do this in the following listing
    and the effects in [figure 7.20](#ch07fig20).
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们移除了节点，我们布局中仍然会有引用不再存在的节点的链接。我们需要对我们的链接数组进行更复杂的过滤。不过，通过使用数组的 `.indexOf` 函数，我们可以通过检查源和目标是否都在我们的过滤节点数组中来轻松创建过滤后的链接。因为我们最初在将数组绑定到选择时使用了键值，所以我们可以使用
    `selection.exit()` 行为来轻松更新我们的网络。您可以在以下列表中看到如何这样做，以及 [图 7.20](#ch07fig20) 中的效果。
- en: Figure 7.20\. The network has been filtered to only show nodes that are not
    managers or contractors. This figure catches two processes in midstream, the transition
    of nodes from full to 0 opacity, and the removal of edges.
  id: totrans-433
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.20\. 网络已被过滤，只显示不是经理或承包商的节点。此图捕捉了两个过程的中途，节点从全不透明到 0 不透明的转换，以及边的移除。
- en: '![](../Images/07fig20.jpg)'
  id: totrans-434
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.20](../Images/07fig20.jpg)'
- en: Listing 7.12\. Filtering a network
  id: totrans-435
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.12\. 过滤网络
- en: '[PRE37]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '***1* Accesses the current array of nodes and array of links associated with
    the force layout**'
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 访问与力布局关联的当前节点数组和链接数组**'
- en: '***2* Makes an array of nodes and links only out of those that reference existing
    nodes**'
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 只从引用现有节点的节点和链接中创建一个数组**'
- en: '***3* By setting a transition on the exit(), it applies the transition only
    to those nodes being removed and waits until the transition is finished to remove
    them**'
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 通过在 exit() 上设置转换，它只对正在被移除的节点应用转换，并等待转换完成后才移除它们**'
- en: '***4* Reinitialize the simulation with only the existing nodes and edges and
    reheat it by setting the alpha and restart the network**'
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 使用现有的节点和边重新初始化模拟，通过设置 alpha 并重新启动网络**'
- en: Because the force algorithm is restarted after the filtering, you can see how
    the shape of the network changes with the removal of so many nodes. That animation
    is important because it reveals structural changes in the network.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 由于过滤后重新启动了力算法，您可以看到网络在移除这么多节点后形状的变化。这个动画很重要，因为它揭示了网络中的结构变化。
- en: Putting more nodes and edges into the network is easy, as long as you properly
    format your data. You stop the force layout, add the properly formatted nodes
    or edges to the respective arrays, and rebind the data as you’ve done in the past.
    Let’s say we want to convince Irene to work more closely with someone from Zan’s
    team. We’d probably suggest Tony, because he’s so well connected on our diagram.
    If, for instance, we want to add an edge between Irene and Tony, as shown in [figure
    7.21](#ch07fig21), we need to stop the force layout like we did earlier, create
    a new datapoint for that edge, and add it to the array we’re using for the links,
    as shown in [listing 7.13](#ch07ex13). Then we rebind the data and append a new
    line element for that edge before we restart the force layout.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 将更多节点和边放入网络中很容易，只要您正确格式化您的数据。您停止力布局，将正确格式化的节点或边添加到相应的数组中，然后像过去一样重新绑定数据。假设我们想要说服艾琳与赞的团队中的某人更紧密地合作。我们可能会建议托尼，因为他在我们图表中联系得很好。例如，如果我们想在艾琳和托尼之间添加一条边，如图
    [图 7.21](#ch07fig21) 所示，我们需要像之前一样停止力布局，为那条边创建一个新的数据点，并将其添加到我们用于链接的数组中，如 [列表 7.13](#ch07ex13)
    所示。然后我们重新绑定数据，在重新启动力布局之前为那条边添加一个新的行元素。
- en: Figure 7.21\. Network with a new edge added
  id: totrans-443
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.21\. 添加了新边的网络
- en: '![](../Images/07fig21.jpg)'
  id: totrans-444
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/07fig21.jpg)'
- en: Now Irene can see visually that she’s occupying a more central position in the
    network, and the organization as a whole can see that the network is more resilient
    to any personnel changes that may happen. See the following listing.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 Irene 可以直观地看到她在网络中占据了更中心的位置，整个组织也可以看到网络对可能发生的人员变动具有更强的适应性。请参阅以下列表。
- en: Listing 7.13\. A function for adding edges
  id: totrans-446
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.13\. 添加边的函数
- en: '[PRE38]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Now let’s imagine that Shirley wants to bring in a pair of contractors to work
    on a new project, so we have two new nodes and the corresponding links we need
    to add, as shown in [figure 7.22](#ch07fig22). The code and process, which you
    can see in [listing 7.14](#ch07ex14), should look familiar to you by now.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们想象 Shirley 想要引入一对承包商来参与一个新项目，因此我们有两个新节点和相应的需要添加的链接，如图 7.22 所示。你现在应该已经熟悉了代码和过程，如列表
    7.14 所示。
- en: Figure 7.22\. Network with two new nodes added (Mike and Noah), both with links
    to Sam
  id: totrans-449
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.22\. 添加了两个新节点（Mike 和 Noah），它们都与 Sam 有链接
- en: '![](../Images/07fig22.jpg)'
  id: totrans-450
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/07fig22.jpg)'
- en: Listing 7.14\. Function for adding nodes and edges
  id: totrans-451
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.14\. 添加节点和边的函数
- en: '[PRE39]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '***1* A node is always an object, and we want the new nodes to have the same
    structure as our original nodes**'
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 节点始终是一个对象，我们希望新节点与我们的原始节点具有相同的结构**'
- en: '***2* The edges reference an original node and a new node**'
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 边引用原始节点和新节点**'
- en: '***3* We need to add the new nodes and edges to our existing arrays for the
    simulation to be aware of them**'
  id: totrans-455
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 我们需要将新节点和边添加到现有的数组中，以便模拟能够识别它们**'
- en: 7.2.8\. Manually positioning nodes
  id: totrans-456
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.2.8\. 手动定位节点
- en: The force-directed layout doesn’t move your elements. Instead, it calculates
    the position of elements based on the x and y attributes of those elements in
    relation to each other. During each tick, it updates those x and y attributes.
    The tick function selects the `<line>` and `<g>` elements and moves them to these
    updated x and y values.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 力导向布局不会移动你的元素。相反，它根据元素之间的 x 和 y 属性计算元素的位置。在每次迭代中，它更新这些 x 和 y 属性。tick 函数选择 `<line>`
    和 `<g>` 元素并将它们移动到这些更新的 x 和 y 值。
- en: When you want to move your elements manually, you can do so like you normally
    would in [listing 7.15](#ch07ex15). But first you need to stop the force so that
    you prevent that tick function from overwriting your elements’ positions. Maybe
    the CEO has seen some of these network charts and wants to know if we’re properly
    rewarding people for being so central to the networks they’re in. Let’s lay out
    our nodes like a scatterplot, looking at the degree centrality (number of links)
    by the salary of each node. We’ll also add axes to make it readable. You can see
    the code in the following listing and the results in [figure 7.23](#ch07fig23).
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想手动移动元素时，你可以像在列表 7.15 中那样操作。但首先你需要停止力，以防止 tick 函数覆盖你的元素位置。也许 CEO 看过一些这些网络图表，想知道我们是否适当地奖励了那些在网络中处于中心位置的人。让我们将节点布局成散点图，查看每个节点的度中心性（链接数量）与薪资的关系。我们还将添加轴以使其可读。你可以在下面的列表中看到代码，在图
    7.23 中看到结果。
- en: Figure 7.23\. When the network is represented as a scatterplot, the links increase
    the visual clutter. It provides a useful contrast to the force-directed layout,
    but can be hard to read on its own.
  id: totrans-459
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.23\. 当网络以散点图表示时，链接会增加视觉杂乱。它提供了与力导向布局的有用对比，但单独阅读可能难以理解。
- en: '![](../Images/07fig23.jpg)'
  id: totrans-460
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/07fig23.jpg)'
- en: Listing 7.15\. Moving our nodes manually
  id: totrans-461
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.15\. 手动移动节点
- en: '[PRE40]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '***1* We need to parseInt the salary value because d3.csv brings everything
    in as strings**'
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 我们需要将薪资值解析为整数，因为 d3.csv 将所有内容都作为字符串传入**'
- en: '***2* Manually move the nodes and links**'
  id: totrans-464
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 手动移动节点和链接**'
- en: '***3* Manually move the nodes and links**'
  id: totrans-465
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 手动移动节点和链接**'
- en: '***4* Update the xy coordinates of the nodes to match their new screen coordinates**'
  id: totrans-466
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 更新节点的 xy 坐标以匹配它们的新屏幕坐标**'
- en: '***5* Zero out the velocity so that when you restart the simulation they don’t
    have their old velocity in play**'
  id: totrans-467
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 将速度置零，以便在重新启动模拟时它们不会保留旧的速度**'
- en: Notice that you need to update the `x` and `y` attributes of each node, but
    you also need to update the `vx` and `vy` attributes of each node. The `vx` and
    `vy` attributes are the current velocity along the x- and y-axes of the node before
    the last tick. If you don’t update them, the force layout might think that the
    nodes have high velocity and will violently move them from their new position.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你需要更新每个节点的 `x` 和 `y` 属性，但你还需要更新每个节点的 `vx` 和 `vy` 属性。`vx` 和 `vy` 属性是节点在最后一次更新之前沿
    x 轴和 y 轴的当前速度。如果你不更新它们，力布局可能会认为节点具有很高的速度，并将它们从新位置猛烈地移动。
- en: If you didn’t update the `x`, `y`, `vx`, and `vy` attributes, the next time
    you started the force layout, the nodes would immediately return to their positions
    before you moved them. This way, when you restart the force layout with `simulation.restart()`,
    the nodes and edges animate from their current position.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有更新 `x`、`y`、`vx` 和 `vy` 属性，下次你启动力布局时，节点会立即回到你移动它们之前的位置。这样，当你使用 `simulation.restart()`
    重新启动力布局时，节点和边会从当前位置开始动画。
- en: 7.2.9\. Optimization
  id: totrans-470
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.2.9. 优化
- en: The force layout is extremely resource-intensive. That’s why it cools off and
    stops running by design. And if you have a large network running with the force
    layout, you can tax a user’s computer until it becomes practically unusable. The
    first tip to optimization, then, is to limit the number of nodes in your network,
    as well as the number of edges. A general rule is no more than 500 nodes, but
    that limit used to be 100 and gets higher as browsers increase in performance,
    so use profiling and understand the minimum performance of the browsers that your
    audience will likely be using.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 力布局非常资源密集。这就是为什么它按设计冷却并停止运行。如果你有一个使用力布局的大网络运行，你可能会让用户的电脑变得几乎无法使用。因此，优化的第一个技巧是限制你网络中的节点数量以及边的数量。一个普遍的规则是不超过500个节点，但这个限制曾经是100，随着浏览器的性能提高，这个限制也在提高，所以使用分析并了解你的观众可能会使用的浏览器的最低性能。
- en: But if you have to present more nodes and want to improve the performance, you
    can use `forceManyBody.chargeDistance()` to set a maximum distance when computing
    the repulsive charge for each node. The lower this setting, the less structured
    the force layout will be, but the faster it will run. Because networks vary so
    much, you’ll have to experiment with different values for `chargeDistance` to
    find the best one for your network.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你需要展示更多的节点并想提高性能，你可以在计算每个节点的排斥电荷时使用 `forceManyBody.chargeDistance()` 来设置一个最大距离。这个设置越低，力布局的结构就越不紧密，但运行速度会更快。因为网络差异很大，你将不得不对不同值的
    `chargeDistance` 进行实验，以找到最适合你网络的值。
- en: 7.3\. Summary
  id: totrans-473
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3. 概述
- en: Like hierarchical data visualization, you have many ways to represent a network,
    such as with adjacency matrices, arc diagrams, and force-directed diagrams. You
    need to make sure you use the method that suits your network structure and your
    audience.
  id: totrans-474
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与层次数据可视化一样，你有许多方式来表示网络，例如邻接矩阵、弧图和力导向图。你需要确保你使用适合你的网络结构和观众的方法。
- en: D3’s `forceSimulation()` functionality can be used to create chart types that
    aren’t what you’d typically think of as network charts, such as beeswarm plots
    and bubble charts. Some of the most innovative work in data visualization is with
    physical simulations like this.
  id: totrans-475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: D3 的 `forceSimulation()` 功能可以用来创建你通常不会认为是网络图表的图表类型，例如蜂群图和气泡图。数据可视化中最具创新性的工作之一就是使用这种物理模拟。
- en: You need to understand networks and network statistics a bit if you want to
    do anything sophisticated with network representations.
  id: totrans-476
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想对网络表示进行任何复杂操作，你需要对网络和网络统计有一定的了解。
- en: The next time you’re asked to do your 360 reviews (or your company’s equivalent)
    or when you’re managing your social media, remember that you’re in a network,
    and that as a node in that network you’ve seen how those dynamics play out.
  id: totrans-477
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下次你被要求进行360度评估（或你公司的等效评估）或当你管理你的社交媒体时，记住你在一个网络中，作为该网络中的一个节点，你已经看到了这些动态是如何发挥作用的。
- en: D3.js in the real world
  id: totrans-478
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: D3.js 在现实世界中的应用
- en: Shirley Wu Data Visualization Consultant
  id: totrans-479
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Shirley Wu 数据可视化顾问
- en: '*An Interactive Visualization of Every Line in Hamilton*'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: '*《汉密尔顿每一行的交互式可视化》*'
- en: '[http://polygraph.cool/hamilton/](http://polygraph.cool/hamilton/)'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://polygraph.cool/hamilton/](http://polygraph.cool/hamilton/)'
- en: When we think of force layouts, we immediately think of node-and-link graphs,
    of Les Miserables characters connected by their co-appearances. And D3’s implementation
    of the force-directed graph is certainly well suited to calculating node positions
    on a screen, but I think animation is where it shines. Those few seconds before
    the simulation cools down enough to converge on a layout, when the nodes are still
    bouncing around on the screen—they have a playfulness that no amount of custom
    transitions can replicate.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想到力导向布局时，我们立刻会想到节点和链接图，就像《悲惨世界》中的人物通过他们的共同出现而相互连接。D3 对力导向图的实现当然非常适合在屏幕上计算节点位置，但我认为动画才是它的亮点。在模拟足够冷却并收敛到布局之前的那几分钟，当节点仍在屏幕上弹跳时——它们有一种顽皮，任何自定义过渡都无法复制。
- en: When I started on my project visualizing Hamilton, I knew that I wanted it to
    reach a wide audience, one that might not be as intimately familiar with data
    visualizations. To keep their attention, I needed a way to delight, and what better
    way than for the dots (each representing a set of lines by a character) to burst
    out of their initial positions and then regroup to the next configuration? The
    animation happens as the user scrolls between sections, introducing the next topic
    with a wave of confetti-like dots zipping around the screen. It’s an effect only
    the force layout can accomplish, adds absolutely zero insights to the data, but
    is fun and slightly silly and keeps the user scrolling.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 当我开始着手可视化 Hamilton 的项目时，我知道我希望它能触及广泛的受众，这些人可能并不那么熟悉数据可视化。为了保持他们的注意力，我需要一种令人愉悦的方式，还有什么比让代表一组线条（每个线条由一个角色表示）的点从它们初始位置爆发出并重新组合到下一个配置更好的方式呢？当用户在章节之间滚动时，动画就会发生，通过屏幕上飞舞的类似纸屑的点波来引入下一个主题。这是只有力导向布局才能实现的效果，对数据没有任何洞察力，但很有趣，有点傻，而且能保持用户继续滚动。
- en: '![](../Images/239fig01_alt.jpg)'
  id: totrans-484
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/239fig01_alt.jpg)'
- en: '![](../Images/240fig01_alt.jpg)'
  id: totrans-485
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/240fig01_alt.jpg)'
- en: Chapter 8\. Geospatial information visualization
  id: totrans-486
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 8 章 地理空间信息可视化
- en: '*This chapter covers*'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Creating points and polygons from GeoJSON and TopoJSON data
  id: totrans-488
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 GeoJSON 和 TopoJSON 数据创建点和多边形
- en: Using Mercator, Mollweide, orthographic, and satellite projections
  id: totrans-489
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用墨卡托、莫勒瓦德、正射和卫星投影
- en: Understanding advanced TopoJSON neighbor and merging functionality
  id: totrans-490
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解高级 TopoJSON 邻接和合并功能
- en: One of the most common categories of data you’ll encounter is geospatial data.
    This can come in the form of administrative regions like states or counties, points
    that represent cities or the location of a person when sending a tweet, or satellite
    imagery of the surface of the earth.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 你会遇到的最常见的几种数据类型之一是地理空间数据。这可能以行政区域的形式出现，如州或县，代表城市或发送推文时的人的位置，或者地球表面的卫星图像。
- en: D3 provides enough core functionality to make any kind of map you’ve seen on
    the web (examples of maps created in this chapter using D3 can be seen in [figure
    8.1](#ch08fig01)). Because you’re already working with D3, you can make that map
    far more sophisticated and distinctive than the out-of-the-box maps you typically
    see. The major reason to use a dedicated library like Google Maps API is because
    of the added functionality that comes from being in that ecosystem, such as Street
    View. Another reason is if you want to do the cool 3D mapping you can accomplish
    with WebGL-based mapping libraries like MapboxGL. But if you’re not looking for
    those features, then it may be a smarter move to build the map with D3\. You won’t
    have to invest in learning a different syntax and abstraction layer, and you’ll
    have the greater flexibility D3 mapping affords.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: D3 提供了足够的核心功能，可以制作你在网上见过的任何类型的地图（本章使用 D3 创建的地图示例可以在[图 8.1](#ch08fig01)中看到）。因为你已经在使用
    D3，你可以制作出比典型的开箱即用的地图更复杂、更有特色的地图。使用像 Google Maps API 这样的专用库的主要原因是因为在那个生态系统中可以获得额外的功能，比如街景。另一个原因是如果你想要使用基于
    WebGL 的地图库（如 MapboxGL）实现的酷炫 3D 地图，那么这也是一个原因。但如果你不寻求这些功能，那么使用 D3 制作地图可能是一个更明智的选择。你不必投资学习不同的语法和抽象层，而且你将拥有
    D3 地图提供的更大灵活性。
- en: Figure 8.1\. Mapping with D3 takes many forms and offers many options, including
    topology operations like merging and finding neighbors ([section 8.4](#ch08lev1sec4)),
    globes ([section 8.3.1](#ch08lev2sec7)), spatial calculations ([section 8.1.4](#ch08lev2sec4)),
    and data-driven maps ([section 8.1](#ch08lev1sec1)) using novel projections ([section
    8.1.3](#ch08lev2sec3)).
  id: totrans-493
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.1. 使用D3进行地图绘制有多种形式和许多选项，包括拓扑操作如合并和查找邻居([第8.4节](#ch08lev1sec4))、地球仪([第8.3.1节](#ch08lev2sec7))、空间计算([第8.1.4节](#ch08lev2sec4))以及使用新颖投影的数据驱动地图([第8.1节](#ch08lev1sec1))。
- en: '![](../Images/08fig01_alt.jpg)'
  id: totrans-494
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/08fig01_alt.jpg)'
- en: Because mapmaking and geographic information systems and science (known as GIS
    and GIScience, respectively) have been in practice for so long, well-developed
    methods exist for representing this kind of data. D3 has built-in robust functionality
    to load and display geospatial data. A related library that you’ll get to know
    in this chapter, TopoJSON, provides more functionality for geospatial information
    visualization.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 由于地图制作和地理信息系统及科学（分别称为GIS和GIScience）已经实践了很长时间，因此存在用于表示此类数据的成熟方法。D3内置了强大的功能来加载和显示地理空间数据。在本章中你将了解的相关库，TopoJSON，提供了更多用于地理空间信息可视化的功能。
- en: In this chapter, we’ll start by making maps that combine points, lines, and
    polygons using data from CSV- and GeoJSON-formatted sources. You’ll learn how
    to style those maps and provide interactive zooming by revisiting `d3.zoom()`
    and exploring it in more detail. After that, we’ll look at the TopoJSON data format,
    its built-in functionality that uses topology, and why it provides significantly
    smaller data files. Finally, you’ll learn how to make maps using tiles to show
    terrain and satellite imagery.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将从使用CSV和GeoJSON格式源的数据制作结合点、线和多边形的地图开始。你将学习如何设计这些地图，并通过重新访问`d3.zoom()`并更详细地探索它来提供交互式缩放。之后，我们将查看TopoJSON数据格式，其内置使用拓扑的功能，以及为什么它提供了显著更小的数据文件。最后，你将学习如何使用瓦片制作地图以显示地形和卫星图像。
- en: 8.1\. Basic mapmaking
  id: totrans-497
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1. 基本地图制作
- en: Before you explore the boundaries of mapping possibilities, you need to make
    a simple map. In D3, the simplest map you can make is a vector map using SVG `<path>`
    and `<circle>` elements to represent countries and cities. We can bring back cities.csv,
    which we used in [chapter 2](../Text/kindle_split_011.html#ch02), and finally
    take advantage of its coordinates, but we need to look a bit further to find the
    data necessary to represent those countries. After we have that data, we can render
    it as areas, lines, or points on a map. Then we can add interactivity, such as
    highlighting a region when you move your mouse over it or computing and showing
    its center.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 在你探索地图可能性边界之前，你需要制作一个简单的地图。在D3中，你可以制作的 simplest 地图是使用SVG `<path>` 和 `<circle>`
    元素表示国家和城市的矢量地图。我们可以调回cities.csv，这是我们[第2章](../Text/kindle_split_011.html#ch02)中使用的，并最终利用其坐标，但我们需要进一步查找表示那些国家所需的数据。在获得这些数据后，我们可以在地图上将其渲染为区域、线条或点。然后我们可以添加交互性，例如，当你将鼠标移至某个区域时突出显示该区域，或者计算并显示其中心。
- en: Before we get started, though, let’s look at the CSS for this chapter, as shown
    in the following listing.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，让我们先看看本章的CSS，如下所示。
- en: Listing 8.1\. ch8.css
  id: totrans-500
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.1. ch8.css
- en: '[PRE41]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '***1* A centroid is the center point of a geographic feature—we’ll see them
    later**'
  id: totrans-502
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 重心是地理特征的中心点——我们稍后会看到它们**'
- en: '***2* Graticules are those background latitude and longitude lines you see
    on maps—you’ll learn how to create them in this chapter**'
  id: totrans-503
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 格网是你在地图上看到的背景经纬线——你将在本章学习如何创建它们**'
- en: 8.1.1\. Finding data
  id: totrans-504
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.1.1. 查找数据
- en: Making a map requires data, and you have an enormous amount of data available.
    Geographic data can come in several forms. If you’re familiar with GIS, then you’ll
    be familiar with one of the most common forms for complex geodata, the *shapefile*,
    which is a format developed by Esri and is most commonly found in desktop GIS
    applications. But the most human-readable form of geodata is latitude and longitude
    (or xy coordinates like we list in our file) when dealing with points like cities,
    often in a CSV. We’ll use cities.csv, shown in the following listing. This is
    the same CSV we measured in [chapter 2](../Text/kindle_split_011.html#ch02) that
    had the locations of eight cities from around the world.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 制作地图需要数据，而你拥有大量的数据可用。地理数据可以以多种形式存在。如果你熟悉GIS，那么你将熟悉复杂地理数据最常见的形式之一，即*shapefile*，这是一种由Esri开发的格式，在桌面GIS应用中最常见。但处理像城市这样的点时，最易读的地理数据形式是经纬度（或我们文件中列出的xy坐标），通常在CSV文件中。我们将使用以下列表中的cities.csv，这是我们在[第2章](../Text/kindle_split_011.html#ch02)中测量的相同CSV文件，其中包含来自世界各地的八个城市的地理位置。
- en: Listing 8.2\. cities.csv
  id: totrans-506
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.2\. cities.csv
- en: '[PRE42]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: If you only have city names or addresses and need to get latitude and longitude,
    you can take advantage of geocoding services that provide latitude and longitude
    from addresses. These exist as APIs and are available on the web for small batches.
    You can see an example of these services maintained by Texas A&M at [http://geoservices.tamu.edu/Services/Geocode/](http://geoservices.tamu.edu/Services/Geocode/).
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只有城市名称或地址，需要获取经纬度，可以利用提供从地址获取经纬度的地理编码服务。这些服务作为API存在，并且可以在网上为小批量数据使用。你可以看到由德克萨斯A&M大学维护的这些服务的示例，[http://geoservices.tamu.edu/Services/Geocode/](http://geoservices.tamu.edu/Services/Geocode/)。
- en: When dealing with more complex geodata like shapes or lines, you’ll necessarily
    deal with more complex data formats. You’ll want to use GeoJSON, which has become
    the standard for web-mapping data.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理更复杂的地理数据，如形状或线条时，你不可避免地会处理更复杂的数据格式。你将想要使用GeoJSON，它已成为网络地图数据的行业标准。
- en: GeoJSON
  id: totrans-510
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: GeoJSON
- en: GeoJSON ([geojson.org](http://geojson.org)) is, like it sounds, a way of encoding
    geodata in JSON format. Each `feature` in a `featureCollection` is a JSON object
    that stores the border of the feature in a *coordinates* array as well as metadata
    about the feature in a `properties` hash object. For instance, if you wanted to
    draw a square that went around the island of Manhattan, it would have corners
    at [–74.0479, 40.6829], [–74.0479, 40.8820], [-73.9067, 40.8820], and [–73.9067,
    40.6829], as shown in [figure 8.2](#ch08fig02). You can easily export shapefiles
    into GeoJSON using QGIS (a desktop GIS application, [qgis.org](http://qgis.org)),
    PostGIS (a spatial database run on Postgres, [postgis.net](http://postgis.net)),
    GDAL (a library for manipulation of geospatial data, [gdal.org](http://gdal.org)),
    and other tools and libraries.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: GeoJSON ([geojson.org](http://geojson.org))，正如其名，是一种以JSON格式编码地理数据的方法。`featureCollection`中的每个`feature`都是一个JSON对象，它在一个*coordinates*数组中存储特征的边界，并在一个`properties`哈希对象中存储关于特征的元数据。例如，如果你想绘制一个围绕曼哈顿岛的正方形，它的角落将在[–74.0479,
    40.6829], [–74.0479, 40.8820], [-73.9067, 40.8820], 和 [–73.9067, 40.6829]，如图8.2所示。你可以轻松地使用QGIS（一个桌面GIS应用，[qgis.org](http://qgis.org))，PostGIS（在Postgres上运行的空间数据库，[postgis.net](http://postgis.net))，GDAL（一个用于地理空间数据操作的库，[gdal.org](http://gdal.org))和其他工具和库将shapefile导出为GeoJSON。
- en: Figure 8.2\. A polygon drawn at the coordinates [–74.0479, 40.8820], [–73.9067,
    40.8820], [–73.9067, 40.6829], and [–74.0479, 40.6829].
  id: totrans-512
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.2\. 在坐标[–74.0479, 40.8820], [–73.9067, 40.8820], [–73.9067, 40.6829], 和 [–74.0479,
    40.6829]处绘制的多边形。
- en: '![](../Images/08fig02.jpg)'
  id: totrans-513
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/08fig02.jpg)'
- en: 'A rectangle drawn over a geographic feature like this is known as a *bounding
    box*. It’s often represented with only two coordinate pairs: the upper-left and
    bottom-right corners. But any polygon data, such as the irregular border of a
    state or coastline, can be represented by an array of coordinates like this. In
    the following listing, we have a fully compliant GeoJSON `"FeatureCollection"`
    with only one feature: the simplified borders of the small nation of Luxembourg.'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 在像这样的地理特征上绘制的矩形被称为*边界框*。它通常只使用两个坐标对来表示：左上角和右下角。但任何多边形数据，如州或海岸线的非规则边界，都可以用这样的坐标数组表示。在以下列表中，我们有一个完全符合GeoJSON
    `"FeatureCollection"`规范，只有一个特征：这个小型国家卢森堡的简化边界。
- en: Listing 8.3\. GeoJSON example of Luxembourg
  id: totrans-515
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.3\. 卢森堡的GeoJSON示例
- en: '[PRE43]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: We’re not going to create our own GeoJSON in this chapter, and unless you get
    into serious GIS, you may never create your own GeoJSON. Instead, you can get
    by with downloading existing geodata and either use it without editing it or edit
    it in a GIS application and export it. In our examples in this chapter, we’ll
    use world.geojson (available at [https://github.com/emeeks/d3_in_action_2/blob/master/data/world.geojson](https://github.com/emeeks/d3_in_action_2/blob/master/data/world.geojson)),
    a file that consists of the countries of the world in the same simplified, low-resolution
    representation that you see in [figure 8.3](#ch08fig03).
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们不会创建自己的 GeoJSON，除非你深入研究 GIS，否则你可能永远不会创建自己的 GeoJSON。相反，你可以通过下载现有的地理数据，要么不编辑它而直接使用，要么在
    GIS 应用程序中编辑它并导出。在本章的示例中，我们将使用 world.geojson（可在[https://github.com/emeeks/d3_in_action_2/blob/master/data/world.geojson](https://github.com/emeeks/d3_in_action_2/blob/master/data/world.geojson)找到），这是一个包含世界各国的文件，其表示方式与你在[图
    8.3](#ch08fig03)中看到的是相同的简化、低分辨率表示。
- en: Figure 8.3\. A map of the world using the default settings for D3’s Mercator
    projection. You can see most of the Western Hemisphere and some of Europe and
    Africa, but the rest of the world is rendered out of sight.
  id: totrans-518
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 8.3\. 使用 D3 的墨卡托投影默认设置的全球地图。你可以看到大部分西半球以及部分欧洲和非洲，但世界其他部分则被渲染在视线之外。
- en: '![](../Images/08fig03.jpg)'
  id: totrans-519
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/08fig03.jpg)'
- en: Projection
  id: totrans-520
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 投影
- en: Entire books have been written on creating web maps, and an entire book could
    be written on using D3.js for crafting maps. Because this is only one chapter,
    I’ll gloss over many deep issues. One of these is projection. In GIS, *projection*
    refers to the process of rendering points on a globe, like the earth, onto a flat
    plane, like your computer monitor. You can project geographic data in many different
    ways for representation on your screen, and in this chapter we’ll look at a few
    different methods.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 已经有整本书是关于创建网络地图的，而且完全可以写一本书来专门讲述如何使用 D3.js 制作地图。因为这只是其中的一章，所以我会略过许多深入的问题。其中之一就是投影。在
    GIS 中，*投影*指的是将地球上的点渲染到平面上的过程，比如你的电脑显示器。你可以以许多不同的方式投影地理数据，以便在屏幕上展示，在本章中，我们将探讨几种不同的方法。
- en: To start, we’ll use one of the most common geographic projections, the Mercator
    projection, which is used in most web maps. It became the de facto standard because
    it’s the projection used by Google Maps. To use the Mercator projection, you have
    to include an extension of D3, `d3.geo.projection.js`, which you’ll want for the
    more interesting work you’ll do later in the chapter. By defining a projection,
    you can take advantage of `d3.geoPath`, which draws geodata onscreen based on
    your selected projection. After we’ve defined a projection and have `geo.path()`
    ready, the entire code in [listing 8.4](#ch08ex04) is all we need to draw the
    map shown in [figure 8.3](#ch08fig03).
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将使用最常见的一种地理投影——墨卡托投影，它被大多数网络地图所使用。它成为事实上的标准，因为它是谷歌地图所使用的投影。要使用墨卡托投影，你必须包含
    D3 的一个扩展，`d3.geo.projection.js`，你将在本章后面更有趣的工作中使用它。通过定义一个投影，你可以利用 `d3.geoPath`，它根据你选择的投影在屏幕上绘制地理数据。在我们定义了投影并且有了
    `geo.path()` 准备好的情况下，[代码清单 8.4](#ch08ex04) 中的所有代码都是我们绘制[图 8.3](#ch08fig03)中所示地图所需要的。
- en: Listing 8.4\. Initial mapping function
  id: totrans-523
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.4\. 初始映射函数
- en: '[PRE44]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '***1* Projection functions have many options that you’ll see later**'
  id: totrans-525
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 投影函数有许多选项，你将在后面看到**'
- en: '***2* d3.geoPath() defaults to albersUSA, which is a projection suitable only
    for maps of the United States**'
  id: totrans-526
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* d3.geoPath() 默认使用 albersUSA 投影，这仅适用于美国地图**'
- en: '***3* d3.geoPath() takes properly formatted GeoJSON features and returns SVG
    drawing code for SVG paths**'
  id: totrans-527
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* d3.geoPath() 接收格式正确的 GeoJSON 特征，并返回 SVG 路径的绘制代码**'
- en: Why do you only see part of the world in [figure 8.3](#ch08fig03)? Because the
    default scale and transform of the Mercator projection show only part of the world
    in your SVG canvas. If you want to center the map on a different part of the world,
    you need to change the scale and transform, as we will shortly. Each projection
    has a `.translate()` and `.scale()` that follow the syntax of the transform convention
    in SVG, but have different effects with different projections.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么你在[图 8.3](#ch08fig03)中只看到世界的一部分？因为墨卡托投影的默认比例和变换只显示了 SVG 画布上世界的一部分。如果你想将地图中心放在世界的另一部分，你需要改变比例和变换，我们很快就会这样做。每种投影都有一个
    `.translate()` 和 `.scale()`，它们遵循 SVG 变换约定的语法，但不同的投影有不同的效果。
- en: scale
  id: totrans-529
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 比例
- en: You have to do several tricks to set the right scale for certain projects. For
    instance, with our Mercator projection, if we divide the width of the available
    space by 2 and divide the quotient by `Math.pi`, then the result will be the proper
    scale to display the entire world in the available space. Figuring out the right
    scale for your map and your projection is typically done through experimenting
    with different values, but it’s easier when you include zooming, as you’ll see
    in [section 8.2.2](#ch08lev2sec6).
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须做一些技巧来设置某些项目的正确比例。例如，在我们的墨卡托投影中，如果我们将可用空间的宽度除以2，然后将商除以`Math.pi`，那么结果将是显示整个世界的正确比例。通常，通过尝试不同的值来确定地图和投影的正确比例，但当你包括缩放时，这会更容易，正如你在[第8.2.2节](#ch08lev2sec6)中看到的。
- en: 'Different families of projections have different scale defaults. The `d3.geo.albers-Usa`
    projection defaults to 1070, whereas `d3.geo.mercator` defaults to 150\. As with
    most D3 functions like this, you can see the default by calling the function without
    passing it a value:'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的投影家族有不同的默认比例。`d3.geo.albers-Usa`投影默认为1070，而`d3.geo.mercator`默认为150。与大多数这样的D3函数一样，你可以通过不传递值来调用函数来查看默认值：
- en: '[PRE45]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '***1* 150**'
  id: totrans-533
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 150**'
- en: '***2* 1070**'
  id: totrans-534
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 1070**'
- en: By adjusting the `translate` and `scale` as in [listing 8.5](#ch08ex05), we
    can adjust the projection to show different parts of the geodata we’re working
    with—in our case, the world. The result in [figure 8.4](#ch08fig04) shows that
    we now see the entire world rendered.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调整`translate`和`scale`，如[列表8.5](#ch08ex05)所示，我们可以调整投影以显示我们正在处理的地理数据的不同部分——在我们的情况下，是世界。[图8.4](#ch08fig04)中的结果表明我们现在看到了整个世界的渲染。
- en: Figure 8.4\. The Mercator-projected world from our data now fitting our SVG
    area. Notice the enormous distortion in size of regions near the poles, such as
    Greenland and Antarctica.
  id: totrans-536
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.4\. 我们的数据现在适合我们的SVG区域，展示了墨卡托投影的世界地图。注意，靠近极地的地区，如格陵兰和南极洲，区域大小存在巨大的扭曲。
- en: '![](../Images/08fig04.jpg)'
  id: totrans-537
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/08fig04.jpg)'
- en: Listing 8.5\. Simple map with scale and translate settings
  id: totrans-538
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.5\. 带有比例和转换设置的简单地图
- en: '[PRE46]'
  id: totrans-539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '***1* Scale values are different for different families of projections—80 works
    well in this case**'
  id: totrans-540
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 不同投影家族的比例值不同——在这个情况下80效果很好**'
- en: '***2* Moves the center of the projection to the center of our canvas**'
  id: totrans-541
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将投影的中心移动到画布的中心**'
- en: 8.1.2\. Drawing points on a map
  id: totrans-542
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.1.2\. 在地图上绘制点
- en: 'Projection isn’t used only to display areas; it’s also used to place individual
    points. Typically, you think of cities or people as represented not by their spatial
    footprint (though you do this with particularly large cities) but with a single
    point on a map, which is sized based on a variable such as population. A D3 projection
    can be used not only in a `geo.path()` but also as a function on its own. When
    you pass it an array with a pair of latitude and longitude coordinates, it returns
    the screen coordinates necessary to place that point. For instance, if we want
    to know where to place a point representing San Francisco (roughly speaking, –122
    latitude, 37 longitude), we could pass those values to our projection. This code
    segment will return xy screen coordinates (roughly [79.65, 194.32]:'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 投影不仅用于显示区域；它还用于放置单个点。通常，你将城市或人视为不是通过它们的空间足迹（尽管你会在特别大的城市中这样做）而是通过地图上的一个点来表示，其大小基于人口等变量。D3投影不仅可以用于`geo.path()`，也可以作为一个单独的函数使用。当你传递一个包含纬度和经度坐标对的数组时，它返回放置该点的必要屏幕坐标。例如，如果我们想知道代表旧金山（大致为-122纬度，37经度）的点应该放在哪里，我们可以将这些值传递给我们的投影。这段代码将返回xy屏幕坐标（大致为[79.65,
    194.32]）。
- en: '[PRE47]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We can use this to add cities to our map along with loading the data from cities.csv,
    as in [listing 8.6](#ch08ex06) and which you see in [figure 8.5](#ch08fig05).
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这个方法将城市添加到我们的地图中，同时从cities.csv加载数据，如[列表8.6](#ch08ex06)所示，并在[图8.5](#ch08fig05)中看到。
- en: Figure 8.5\. Our map with our eight world cities added to it. At this distance,
    you can’t tell how inaccurate these points are, but if you zoom in, you see that
    both of our Italian cities are in the Mediterranean.
  id: totrans-546
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.5\. 我们将八个世界城市添加到地图上。在这个距离上，你看不出这些点有多不准确，但如果你放大，你会看到我们两个意大利城市都位于地中海。
- en: '![](../Images/08fig05.jpg)'
  id: totrans-547
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/08fig05.jpg)'
- en: Listing 8.6\. Loading point and polygon geodata
  id: totrans-548
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.6\. 加载点和多边形地理数据
- en: '[PRE48]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '***1* Updated our promise wrapper to let us send the specific xhr request**'
  id: totrans-550
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 更新了我们的promise包装器，以便我们可以发送特定的xhr请求**'
- en: '***2* You want to draw the cities over the countries, so you append them second.**'
  id: totrans-551
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 你想在国家之上绘制城市，所以你将它们作为第二个添加。**'
- en: '***3* Projection returns an array, which means you need to take the [0] value
    for cx and the [1] value for cy**'
  id: totrans-552
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 投影返回一个数组，这意味着你需要为cx取[0]值，为cy取[1]值**'
- en: One thing to note from [listing 8.6](#ch08ex06) is that coordinates are often
    given in the real world in the order of “latitude, longitude.” Because latitude
    corresponds to the y-axis and longitude corresponds to the x-axis, you have to
    flip them to provide the x, y coordinates necessary for GeoJSON and D3.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 从[列表8.6](#ch08ex06)中需要注意的一点是，坐标通常以“纬度，经度”的顺序在现实世界中给出。因为纬度对应于y轴，经度对应于x轴，所以你必须翻转它们以提供GeoJSON和D3所需的x，y坐标。
- en: 8.1.3\. Projections and areas
  id: totrans-554
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.1.3\. 投影和面积
- en: Depending on what projection you use, the graphical size of your geographic
    objects will appear different. That’s because it’s impossible to perfectly display
    spherical coordinates on a flat surface. Different projections are designed to
    visually display the geographic area of land or ocean regions, or the measurable
    distance, or particular shapes. Because we included `d3.geo.projection.js`, we
    have access to quite a few more projections to play with, one of which is the
    Mollweide projection. In the code in [listing 8.7](#ch08ex07), you can see the
    settings necessary to properly display a Mollweide projection of our geodata.
    We’ll use the calculated area of the countries (the graphical area, not their
    physical area) to color each country. The results are quite distinct from the
    same code running on our Mercator projection, as shown in [figure 8.6](#ch08fig06).
    The world as displayed with Mollweide curves the edges, rather than stretching
    them into a rectangle like Mercator does.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你使用的投影，你的地理对象的图形大小将有所不同。这是因为完美地在平面上显示球坐标是不可能的。不同的投影被设计用来视觉上显示陆地或海洋区域的地理面积，或可测量的距离，或特定的形状。因为我们包含了`d3.geo.projection.js`，我们可以访问更多可玩的投影，其中之一就是莫勒韦德投影。在[列表8.7](#ch08ex07)中的代码中，你可以看到正确显示我们地理数据的莫勒韦德投影所需的设置。我们将使用国家的计算面积（图形面积，而不是它们的物理面积）来为每个国家着色。结果与在[图8.6](#ch08fig06)中显示的相同代码在麦卡托投影上运行的结果截然不同。莫勒韦德投影的世界地图弯曲了边缘，而不是像麦卡托投影那样将其拉伸成矩形。
- en: Figure 8.6\. Mercator (left) dramatically distorts the size of Antarctica so
    much that no other shape looks as large. In comparison, the Mollweide projection
    maintains the physical area of the countries and continents in your geodata, at
    the cost of distorting their shape and angle. Notice that `geo.path.area` measures
    the graphical area and not the physical area of the features.
  id: totrans-556
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.6\. 麦卡托投影（左）将南极洲的大小扭曲得如此严重，以至于没有其他形状看起来那么大。相比之下，莫勒韦德投影在保持你地理数据中的国家和大陆的物理面积的同时，牺牲了它们的形状和角度。请注意，`geo.path.area`测量的是图形面积，而不是要素的物理面积。
- en: '![](../Images/08fig06_alt.jpg)'
  id: totrans-557
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/08fig06_alt.jpg)'
- en: Listing 8.7\. Mollweide projected world
  id: totrans-558
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.7\. 莫勒韦德投影的世界地图
- en: '[PRE49]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '***1* For a Mollweide projection, these settings show the entire world on a
    500 px map**'
  id: totrans-560
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 对于莫勒韦德投影，这些设置显示整个世界在一张500像素的地图上**'
- en: '***2* Measures the features and assigns the size classes to a color ramp**'
  id: totrans-561
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 测量要素并将大小类别分配给颜色渐变**'
- en: '***3* Colors each country based on its size**'
  id: totrans-562
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 根据其大小为每个国家着色**'
- en: Picking the right projection is never easy, and depends on the goals of the
    map you’re making. If you’re working with traditional tile mapping (the kind of
    map you see on Google Maps or Apple Maps, where the map consists of tiled images
    stitched together), then you’ll probably stick with Mercator. If you’re working
    on the world scale, it’s usually best to use an equal-area projection like Mollweide
    that doesn’t distort the visual area of geographic features. But because D3 has
    so many different projections available, you should experiment to see which best
    suits the particular map you’re creating.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 选择正确的投影从来都不容易，这取决于你制作地图的目标。如果你正在处理传统的瓦片映射（你可以在谷歌地图或苹果地图上看到的地图类型，其中地图由拼接在一起的瓦片图像组成），那么你可能会坚持使用麦卡托投影。如果你在处理世界范围，通常最好使用莫勒韦德这样的等面积投影，它不会扭曲地理特征的视觉面积。但鉴于D3提供了如此多的不同投影，你应该尝试看看哪一个最适合你正在创建的特定地图。
- en: '|  |'
  id: totrans-564
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Infoviz term: choropleth map**'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: '**信息可视化术语：分色地图**'
- en: As you encounter more mapmaking, you’ll come across the term *choropleth map*
    used to refer to a map that encodes data using the color of a region. You can
    use the existing geographic features—in this case, countries—to display statistical
    data, such as the GDP of a country, its population, or its most widely used language.
    You can do this in D3 either by getting geodata where the `properties` field has
    that information or by linking a table of data to your geodata where they both
    have the same unique ID values in common.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 随着您遇到更多的制图，您将遇到术语*等值线图*，它指的是使用区域颜色编码数据的地图。您可以使用现有的地理特征——在本例中是各国——来显示统计数据，例如一个国家的
    GDP、人口或最广泛使用的语言。在 D3 中，您可以通过获取具有该信息的`properties`字段的地理数据，或者通过将数据表链接到您的地理数据来实现，其中它们都有相同的唯一
    ID 值。
- en: Keep in mind that choropleth maps, though useful, are subject to what’s known
    as the *areal unit problem*, which is what happens when you draw boundaries or
    select existing features in such a way that they disproportionately represent
    your statistics. This is the case with gerrymandering, when political districts
    are drawn in such a way as to create majorities for one political party or another.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，虽然等值线图很有用，但它们容易受到所谓的*区域单元问题*的影响，这是当你以某种方式绘制边界或选择现有特征时，它们不成比例地代表你的统计数据时发生的情况。这在划分选区时就是这样，当政治选区以某种方式划分，以创造一个政党或另一个政党的多数时。
- en: '|  |'
  id: totrans-568
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 8.1.4\. Interactivity
  id: totrans-569
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.1.4\. 交互性
- en: Much of the geospatial data-related code in D3 comes with built-in functionality
    that you’ll typically need when working with geodata. In addition to determining
    the area like we did to color our features, D3 has other useful functions. Two
    that are commonly used in mapping are the ability to quickly calculate the center
    of a geographic area (known as a *centroid*) and its bounding box, like you see
    in [figure 8.7](#ch08fig07). In [listing 8.8](#ch08ex08), you can see how to add
    mouseover events to the paths we created and draw a circle at the center of each
    geographic area, as well as a bounding box around it.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: D3 中与地理空间数据相关的代码大多带有内置功能，您在处理地理数据时通常会用到这些功能。除了像我们为着色特征那样确定面积之外，D3 还有其他有用的功能。在制图中常用的两个功能是快速计算地理区域的中心（称为*质心*）及其边界框，就像您在[图
    8.7](#ch08fig07)中看到的那样。在[列表 8.8](#ch08ex08)中，您可以看到如何向创建的路径添加鼠标悬停事件，并在每个地理区域的中心画一个圆圈，以及在其周围画一个边界框。
- en: Figure 8.7\. Your interactivity provides a bounding box around each country
    and a red circle representing its graphical center. Here you see the bounding
    box and centroid of China. The D3 implementation of a centroid is weighted, so
    that it’s the center of most area, and not only the center of the bounding box.
  id: totrans-571
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 8.7\. 您的交互性为每个国家提供了一个边界框，以及表示其图形中心的红色圆圈。在这里，您可以看到中国的边界框和质心。D3 对质心的实现是加权的，因此它是大多数区域的中心，而不仅仅是边界框的中心。
- en: '![](../Images/08fig07_alt.jpg)'
  id: totrans-572
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/08fig07_alt.jpg)'
- en: Listing 8.8\. Rendering bounding boxes with geodata
  id: totrans-573
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.8\. 使用地理数据渲染边界框
- en: '[PRE50]'
  id: totrans-574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '***1* Functions of geo.path that give results based on the associated projection**'
  id: totrans-575
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* geo.path 函数的功能，根据相关投影给出结果**'
- en: '***2* Bounding box is the top-left and bottom-right coordinates as an array**'
  id: totrans-576
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 边界框是一个表示左上角和右下角坐标的数组**'
- en: '***3* Centroid is an array with the x and y coordinates of the center of a
    feature**'
  id: totrans-577
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 质心是一个包含特征中心 x 和 y 坐标的数组**'
- en: '***4* Removes the shapes when you mouse off a feature**'
  id: totrans-578
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 当鼠标离开一个特征时移除形状**'
- en: 'You’ve learned the core geo functions that allow you to make maps with D3:
    projections and `geoPath`. By using these functions, you can create maps with
    a distinct look and feel and provide your users with the ability to interact with
    them as shapes and as geographic features. D3 provides more functionality, and
    we’ll dive into it now.'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经学习了核心的 geo 函数，这些函数允许您使用 D3 制作地图：投影和 geoPath。通过使用这些函数，您可以创建具有独特外观和感觉的地图，并允许您的用户以形状和地理特征的方式与之交互。D3
    提供了更多功能，我们现在将深入探讨。
- en: 8.2\. Better mapping
  id: totrans-580
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2\. 更好的制图
- en: 'To make your maps more readable, you can use built-in features from D3: the
    graticule generator and the zoom behavior. One provides grid lines that make it
    easier to read a map, and the other allows you to pan and zoom around your map.
    Both follow the same format and functionality of other behaviors and generators
    in D3, but are particularly useful for maps.'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使您的地图更易于阅读，您可以使用 D3 的内置功能：网格线生成器和缩放行为。前者提供了网格线，使阅读地图更容易，后者允许您在地图周围平移和缩放。这两个都遵循
    D3 中其他行为和生成器的相同格式和功能，但特别适用于地图。
- en: 8.2.1\. Graticule
  id: totrans-582
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.2.1. 经纬网
- en: A *graticule* is a grid line on a map. The same way D3 has generators for lines,
    areas, and arcs, it has a generator for graticules to make your maps more beautiful.
    The graticule generator creates gridlines (you can specify where and how many,
    or use the default) and creates an outline that can provide a useful border. [Listing
    8.9](#ch08ex09) shows how to draw a graticule beneath the countries we’ve already
    drawn. Instead of `.data` we use `.datum`, which is a convenience function that
    allows us to bind a single datapoint to a selection so it doesn’t need to be in
    an array—`.datum(yourDatapoint)` is the same as `.data([yourDatapoint]`).
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: '*经纬网*是地图上的网格线。与D3有用于线条、区域和圆弧的生成器一样，它也有用于经纬网的生成器，以使你的地图更加美观。经纬网生成器创建网格线（你可以指定位置和数量，或者使用默认设置）并创建一个轮廓，可以提供有用的边界。[列表8.9](#ch08ex09)展示了如何在已绘制的国家下方绘制经纬网。我们使用`.datum`而不是`.data`，这是一个便利函数，允许我们将单个数据点绑定到一个选择中，因此它不需要在数组中——`.datum(yourDatapoint)`与`.data([yourDatapoint])`相同。'
- en: Listing 8.9\. Adding a graticule
  id: totrans-584
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.9. 添加经纬网
- en: '[PRE51]'
  id: totrans-585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: But how are we drawing so many graticule lines in [figure 8.8](#ch08fig08) from
    a single datapoint? The `geo.graticule` function creates a feature known as a
    multilinestring. A *multilinestring*, as you may have figured out, is an array
    of arrays of coordinates, each corresponding to separate individual components
    of a feature. Multilinestrings and their counterparts, multipolygons, have always
    been a part of GIS because countries like the United States or Indonesia are made
    up of disconnected features such as states and regions, and that information needed
    to be stored in the data. As a result, when `d3.geoPath` gets a multipolygon or
    multilinestring, it draws a `<path>` element made up of multiple, disconnected
    pieces.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们是如何从单个数据点在[图8.8](#ch08fig08)中绘制这么多经纬网线的？`geo.graticule`函数创建了一个称为多线字符串的特征。正如你可能已经猜到的，*多线字符串*是一系列坐标数组，每个数组对应于一个特征的不同单独组件。多线字符串及其对应的多多边形一直是GIS的一部分，因为像美国或印度尼西亚这样的国家由州和地区等不连续的特征组成，这些信息需要存储在数据中。因此，当`d3.geoPath`接收到多边形或多线字符串时，它会绘制由多个不连续部分组成的`<path>`元素。
- en: Figure 8.8\. Our map with a graticule (in light gray) and a graticule outline
    (the black border around the edge of the map)
  id: totrans-587
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.8. 我们带有经纬网（浅灰色）和经纬网轮廓（地图边缘的黑边）的地图
- en: '![](../Images/08fig08_alt.jpg)'
  id: totrans-588
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/08fig08_alt.jpg)'
- en: 8.2.2\. Zoom
  id: totrans-589
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.2.2. 缩放
- en: You dealt with zoom a little bit in [chapter 5](../Text/kindle_split_014.html#ch05),
    when you saw how the zoom behavior can easily allow you to pan a chart around
    the screen. Now it’s time you start zooming with zoom. When we first looked at
    the zoom behavior, we used it to adjust the `transform` attribute of a `<g>` element
    that held our chart. This time, we’ll use the scale and translate values of the
    zoom behavior to update the settings of our projection, which will give us the
    ability to zoom and pan our map.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](../Text/kindle_split_014.html#ch05)中，你稍微处理了缩放，当时你看到了缩放行为如何轻松地允许你在屏幕上移动图表。现在是时候开始使用缩放功能进行缩放了。当我们第一次查看缩放行为时，我们使用它来调整包含我们的图表的`<g>`元素的`transform`属性。这次，我们将使用缩放行为的缩放和转换值来更新投影的设置，这将使我们能够缩放和移动地图。
- en: Create a zoom behavior and call it from the `<svg>` element. Whenever you have
    a drag event on anything in the `<svg>`, a mousewheel event, or a double-click,
    it triggers zoom. When we worked with zoom before, we only dealt with the dragging,
    which updates the `zoom.translate()` value and which you can use to update the
    translate value of whatever element you want to update. This time, we’ll also
    use the `zoom.scale()` value, which gives us an increasing (when you double-click
    or roll your mousewheel forward) or decreasing (when you roll your mousewheel
    backward) value. To use zoom with a projection, we’ll want to overwrite the initial
    `zoom.scale()` value with the scale value of the projection and do the same with
    the zoom translate value. After that, any time we have an event that triggers
    zoom, we’ll use the new values to update our projection, as shown in [listing
    8.10](#ch08ex10) and in [figure 8.9](#ch08fig09).
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个缩放行为，并从 `<svg>` 元素中调用它。每当在 `<svg>` 中的任何内容上发生拖动事件、鼠标滚轮事件或双击时，它都会触发缩放。在我们之前处理缩放时，我们只处理拖动，这会更新
    `zoom.translate()` 值，您可以使用它来更新您想要更新的任何元素的平移值。这次，我们还将使用 `zoom.scale()` 值，它给我们一个增加的值（当您双击或向前滚动鼠标滚轮时）或减少的值（当您向后滚动鼠标滚轮时）。要使用投影与缩放一起使用，我们将想要用投影的比例值覆盖初始的
    `zoom.scale()` 值，并用缩放平移值做同样的事情。之后，每当有触发缩放的事件时，我们将使用新值来更新我们的投影，如 [代码列表 8.10](#ch08ex10)
    和 [图 8.9](#ch08fig09) 所示。
- en: Figure 8.9\. Our map with zooming enabled. Panning occurs with the drag behavior
    and zooming with mousewheel and/or double-clicking. Notice that the bounding box
    and centroid functions still work because they’re based on our constantly updating
    projection.
  id: totrans-592
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 8.9\. 启用缩放的地图。平移通过拖动行为发生，缩放通过鼠标滚轮和/或双击。请注意，边界框和质心函数仍然有效，因为它们基于我们不断更新的投影。
- en: '![](../Images/08fig09_alt.jpg)'
  id: totrans-593
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/08fig09_alt.jpg)'
- en: Listing 8.10\. Zoom and pan with maps
  id: totrans-594
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 代码列表 8.10\. 地图的缩放和平移
- en: '[PRE52]'
  id: totrans-595
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '***1* We use zoomIdentity to overwrites the translate and scale of the zoom
    to match the projection**'
  id: totrans-596
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 我们使用 zoomIdentity 来覆盖缩放和比例的缩放，以匹配投影**'
- en: '***2* Get the zoom settings from the event**'
  id: totrans-597
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 从事件中获取缩放设置**'
- en: '***3* Whenever the zoom behavior is called, this overwrites the original projection
    values to match the updated zoom values**'
  id: totrans-598
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 每当调用缩放行为时，它都会覆盖原始投影值以匹配更新的缩放值**'
- en: '***4* Any path will be properly redrawn by calling the d3.geoPath associated
    with the updated projection**'
  id: totrans-599
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 任何路径都将通过调用与更新后的投影关联的 d3.geoPath 适当地重新绘制**'
- en: '***5* Also calls the now-updated projection**'
  id: totrans-600
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 还调用现在已更新的投影**'
- en: The zoom behavior updates its `.transform` object in reference to your behavior,
    updating `transform.x` and `transform.y` from dragging and changing `transform.k`
    (scale) in reference to your mousewheel and double-click behavior. Because it’s
    designed to work with SVG transform and D3 geographic projections, `d3.zoom` is
    all you need for pan-and-zoom functionality.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 缩放行为根据您的行为更新其 `.transform` 对象，通过拖动更新 `transform.x` 和 `transform.y`，并通过鼠标滚轮和双击行为更新
    `transform.k`（比例）。因为它旨在与 SVG 变换和 D3 地理投影一起工作，所以 `d3.zoom` 就是您需要的平移和缩放功能。
- en: '|  |'
  id: totrans-602
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Infoviz term: semantic zoom**'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: '**信息可视化术语：语义缩放**'
- en: When you think about zooming in on things, you naturally think about increasing
    their size. But from working with mapping, you know that you don’t merely increase
    the size or resolution as you zoom in—you also change the kind of data that you
    present to the reader. This is known as *semantic zoom* in contrast to *graphical
    zoom*. It’s clearest when you look at a zoomed-out map and see only country boundaries
    and a few major cities, but as you zoom in you see roads, smaller cities, parks,
    and so on.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 当您想到放大事物时，您自然会想到增加它们的大小。但通过处理地图，您知道在放大时，您不仅增加了大小或分辨率——您还改变了您向读者展示的数据类型。这与 *语义缩放*
    相比，*图形缩放*。当您查看缩放后的地图，只看到国家边界和几个主要城市时，这最为明显，但随着您放大，您会看到道路、较小的城市、公园等等。
- en: You should try to use semantic zoom whenever you’re letting your user zoom in
    and out of any data visualization, not only charts. It allows you to present strategic
    or global information when zoomed out, and high-resolution data when zoomed in.
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该在用户可以放大和缩小任何数据可视化时尝试使用语义缩放，而不仅仅是图表。它允许您在缩放时展示战略或全局信息，在放大时展示高分辨率数据。
- en: '|  |'
  id: totrans-606
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The default zoom behavior assumes a user knows that the mousewheel and double-clicking
    are associated with zooming. But sometimes you want zoom buttons, because you
    can’t assume the user knows that interaction or because you want to constrain
    or control the zooming process in a more complicated manner. The code in [listing
    8.11](#ch08ex11) creates a zoom function and adds the necessary buttons, as seen
    in [figure 8.10](#ch08fig10).
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的缩放行为假设用户知道鼠标滚轮和双击与缩放相关联。但有时你需要缩放按钮，因为你不能假设用户知道这种交互，或者因为你想要以更复杂的方式约束或控制缩放过程。列表8.11中的代码创建了一个缩放函数并添加了必要的按钮，如图8.10所示。
- en: Figure 8.10\. Zoom buttons and the effect of clicking Zoom In twice. Because
    the zoom buttons modify the zoom behavior’s translate and scale, any mouse interaction
    afterward reflects the updated settings.
  id: totrans-608
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.10。缩放按钮和点击“放大”两次的效果。因为缩放按钮修改了缩放行为的平移和缩放，之后的任何鼠标交互都会反映更新后的设置。
- en: '![](../Images/08fig10.jpg)'
  id: totrans-609
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/08fig10.jpg)'
- en: Listing 8.11\. Manual zoom controls for maps
  id: totrans-610
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.11。地图的手动缩放控制
- en: '[PRE53]'
  id: totrans-611
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '***1* Calculating the new scale is easy**'
  id: totrans-612
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**1** 计算新的缩放设置很容易'
- en: '***2* Calculating the new translate settings isn’t so easy and requires that
    you recalculate the center**'
  id: totrans-613
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**2** 计算新的平移设置并不容易，需要你重新计算中心'
- en: '***3* Sets the zoom behavior’s scale and translate settings to your new settings**'
  id: totrans-614
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**3** 将缩放行为的缩放和平移设置设置为你的新设置'
- en: '***4* Calls the zoom function associated with the SVG through a transition,
    so your zooming is animated**'
  id: totrans-615
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**4** 通过过渡调用与SVG关联的缩放函数，所以你的缩放是动画化的'
- en: With this kind of styling and interactivity in place, you can make a map for
    most any application. Zooming and panning is important for maps because users
    expect to zoom in and out, and they also expect the details of the map to change
    when they do so. In that way, geospatial is one of the most powerful forms of
    information visualization because users have a high level of literacy when it
    comes to reading and interacting with maps. But users also expect a map to have
    certain features and functionality, and when those are missing they think it’s
    broken. Make sure that when you create your map, it either includes this functionality
    or you have a good reason to leave it out.
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种样式和交互性到位的情况下，你可以为大多数应用制作地图。缩放和平移对地图很重要，因为用户期望可以放大和缩小，并且他们还期望在这样做时地图的细节会发生变化。因此，地理空间是信息可视化中最强大的形式之一，因为用户在阅读和交互地图时具有很高的素养。但用户还期望地图具有某些功能和功能，当这些功能缺失时，他们会认为地图是损坏的。确保当你创建你的地图时，它要么包含这些功能，要么你有很好的理由将其排除在外。
- en: 8.3\. Advanced mapping
  id: totrans-617
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3。高级地图制作
- en: We’ve covered the aspects of creating maps that you’ll likely end up using with
    all your maps. You could explore many variations. You may want to scale your `<circle>`
    elements based on population, or use `<g>` elements so that you can also provide
    labels like we did earlier. But if you’re making a map, it will probably have
    polygons and points and take advantage of bounding boxes or centroids, and will
    likely be tied to a zoom behavior. The exciting thing about D3 is that it lets
    you explore more complex ways of representing geography, with a little more effort.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经涵盖了创建地图的各个方面，你可能会在所有地图中使用这些方面。你可以探索许多变体。你可能希望根据人口规模调整 `<circle>` 元素，或者使用
    `<g>` 元素以便你也可以提供像之前那样的标签。但如果你在制作地图，它可能包含多边形和点，并利用边界框或质心，并且很可能会与缩放行为相关联。D3令人兴奋的地方在于它让你能够以更多复杂的方式表示地理信息，只需付出一点努力。
- en: 8.3.1\. Creating and rotating globes
  id: totrans-619
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.3.1。创建和旋转地球仪
- en: 'We’ll do only one thing in 3D in this entire book and that’s create a globe.
    We don’t need to use three.js or learn WebGL. Instead, we’ll take advantage of
    a trick of one of the geographic projections available in D3: the *orthographic*
    projection, which renders geographic data as it would appear from a distant point
    viewing the entire globe. We need to update our projection to refer to the orthographic
    projection and have a slightly different scale, as shown in the following listing.'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书的整个3D部分中，我们只做一件事，那就是创建一个地球仪。我们不需要使用three.js或学习WebGL。相反，我们将利用D3中可用的地理投影之一的一个技巧：正射投影，它将地理数据渲染成从远处观察整个地球时的样子。我们需要更新我们的投影以引用正射投影，并具有略微不同的缩放，如下面的列表所示。
- en: Listing 8.12\. Creating a simple globe
  id: totrans-621
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.12。创建一个简单的地球仪
- en: '[PRE54]'
  id: totrans-622
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: With this new projection, you can see what looks like a globe in [figure 8.11](#ch08fig11).
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种新的投影，你可以在图8.11中看到类似地球的形状。
- en: Figure 8.11\. An orthographic projection makes our map look like a globe. Notice
    that even though the paths for countries are drawn over each other, they’re still
    drawn above the graticules. Also notice that although zooming in and out works,
    panning doesn’t spin the globe but instead moves it around the canvas. The coloration
    of our countries is once again based on the graphical size of the country.
  id: totrans-624
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 8.11\. 正射投影使我们的地图看起来像一个地球仪。注意，尽管国家的路径相互重叠，但它们仍然绘制在网格线之上。注意，尽管缩放和平移工作，但平移不会使地球仪旋转，而是将其移动到画布上。我们国家的着色再次基于国家的图形大小。
- en: '![](../Images/08fig11.jpg)'
  id: totrans-625
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/08fig11.jpg)'
- en: To make it rotate, we need to use `d3.mouse`, which returns the current position
    of the mouse on the SVG canvas. Pair this with event listeners to turn on and
    off a mousemove listener on the canvas. This simulates dragging the globe, which
    we’ll use only to rotate it along the x-axis. Because we’re introducing new behavior
    and it’s been a while since we looked at the full code, the following listing
    has the entire code for creating the globe.
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 要使其旋转，我们需要使用 `d3.mouse`，它返回 SVG 画布上鼠标的当前位置。将此与事件监听器配对，以在画布上打开和关闭 mousemove 监听器。这模拟了拖动地球仪，我们将仅使用它来沿
    x 轴旋转地球仪。因为我们引入了新的行为，而且我们已经有一段时间没有查看完整的代码了，所以下面的列表包含了创建地球仪的完整代码。
- en: Listing 8.13\. A draggable globe in D3
  id: totrans-627
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.13\. D3 中的可拖动地球仪
- en: '[PRE55]'
  id: totrans-628
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '***1* Orthographic should start out untranslated**'
  id: totrans-629
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 正射投影应从未翻译开始**'
- en: '***2* This scale will be used to transform for x-zoom to degrees**'
  id: totrans-630
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 此比例将用于将 x-zoom 转换为度**'
- en: '***3* Even though projection.rotate can deal with rotations greater than 360
    degrees and less than –360 degrees, we need to filter the points so this will
    help**'
  id: totrans-631
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 即使 projection.rotate 可以处理大于 360 度和小于 –360 度的旋转，我们仍需要过滤点以便这有助于**'
- en: '***4* Rotate the projection only on the x-axis**'
  id: totrans-632
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 仅在 x 轴上旋转投影**'
- en: '***5* Paths will be automatically clipped**'
  id: totrans-633
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 路径将被自动裁剪**'
- en: '***6* Let’s color the countries based on displayed size**'
  id: totrans-634
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 让我们根据显示的大小给国家上色**'
- en: '***7* For points, we need to hide the points that aren’t in the current view**'
  id: totrans-635
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 对于点，我们需要隐藏不在当前视图中的点**'
- en: 'A more sophisticated dragging approach is known as Versor Dragging, an example
    of which you can see at: [https://bl.ocks.org/mbostock/7ea1dde508cec6d2d95306f92642bc42](https://bl.ocks.org/mbostock/7ea1dde508cec6d2d95306f92642bc42).'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 一种更复杂的拖动方法称为 Versor Dragging，一个例子可以在以下链接中看到：[https://bl.ocks.org/mbostock/7ea1dde508cec6d2d95306f92642bc42](https://bl.ocks.org/mbostock/7ea1dde508cec6d2d95306f92642bc42).
- en: We’re drawing all the countries using `geoPath.area()`, which returns the area
    as the shape is drawn, has even worse issues than the Mercator projection had.
    For instance, in [figure 8.12](#ch08fig12), Australia is colored as if it were
    smaller than India and had an area similar to Madagascar. Fortunately, D3 also
    includes `d3.geoArea()`, which determines the spherical area of a shape corresponding
    to its geographic area, as in [figure 8.13](#ch08fig13).
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `geoPath.area()` 绘制所有国家，它返回随着形状绘制而得到的面积，比墨卡托投影有更严重的问题。例如，在 [图 8.12](#ch08fig12)
    中，澳大利亚被着色得好像比印度小，面积与马达加斯加相似。幸运的是，D3 还包括 `d3.geoArea()`，它可以确定与形状的地理面积相对应的球面面积，如
    [图 8.13](#ch08fig13) 所示。
- en: Figure 8.12\. A draggable globe that clips the cities based on whether they
    should be in view and recolors the countries based on their displayed size
  id: totrans-638
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 8.12\. 一个可拖动的地球仪，根据城市是否应显示来裁剪路径，并根据显示的大小重新着色国家
- en: '![](../Images/08fig12.jpg)'
  id: totrans-639
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/08fig12.jpg)'
- en: Figure 8.13\. Our globe with countries colored by their geographic area, rather
    than their graphical area
  id: totrans-640
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 8.13\. 我们的世界地图，国家根据其地理面积而不是图形面积着色
- en: '![](../Images/08fig13.jpg)'
  id: totrans-641
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/08fig13.jpg)'
- en: 'We could rewrite the draw code to use `d3.geoArea`, but instead let’s recolor
    our existing globe. But how do we get the data? Until now, we’ve assumed that
    the data array was exposed somewhere our functions could get to, but what if it’s
    outside our current scope? In this case, we can use `selectAll.data()` and get
    an array of data associated with whatever we select (which includes undefined
    elements if we select HTML elements that aren’t bound with data):'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将绘制代码重写为使用 `d3.geoArea`，但让我们先重新着色现有的地球仪。但我们如何获取数据？到目前为止，我们假设数据数组在某个地方被暴露出来，我们的函数可以访问它，但如果我们当前的作用域之外呢？在这种情况下，我们可以使用
    `selectAll.data()` 并获取与所选择内容（如果选择的是未绑定数据的 HTML 元素，则包括未定义的元素）相关联的数据数组：
- en: '[PRE56]'
  id: totrans-643
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The spherical area of a shape as measured by `d3.geoArea()` is given in *steradians*
    (spherical radians, used to measure area on the surface of a sphere), and so it’s
    only a roughly proportionate area. If you want the square kilometers of a country
    or other shape, you’ll still need to calculate that in a GIS package like QGIS
    or get that information from another source.
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`d3.geoArea()`测量的形状的球面面积以*球面弧度*（球面弧度，用于测量球面表面的面积）给出，因此它只是一个大致成比例的面积。如果你想得到一个国家或其他形状的平方公里数，你仍然需要在QGIS这样的GIS软件包中计算，或者从其他来源获取该信息。
- en: 8.3.2\. Satellite projection
  id: totrans-645
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.3.2\. 卫星投影
- en: Isometric views of the world are powerful tools for storytelling. Imagine you
    had to create a map related to how the Middle East has a changing view of Europe.
    By crafting a satellite view looking out over the Mediterranean from the Middle
    East as shown in [figure 8.14](#ch08fig14), you invite your map reader to see
    a distant Europe from a geographical perspective in the Middle East.
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 世界的等距视图是强大的叙事工具。想象一下，你必须创建一个与中东对欧洲看法变化的地图。通过制作一个从中东看向地中海的卫星视图，如图8.14所示，你邀请你的地图读者从地理角度在中东看到遥远的欧洲。
- en: Figure 8.14\. A satellite projection of data from the Middle East facing Europe
  id: totrans-647
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.14\. 面向欧洲的中东数据卫星投影
- en: '![](../Images/08fig14.jpg)'
  id: totrans-648
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/08fig14.jpg)'
- en: This is a projection like the orthographic, Mercator, and Mollweide projections
    we previously used, but as you see in the following listing, it has specific settings
    for scale and rotate. It also uses new settings, tilt and distance, to determine
    the angle of the satellite projection.
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种类似于我们之前使用的正射投影、墨卡托投影和莫勒韦德投影的投影，但正如你在下面的列表中看到的，它具有特定的比例尺和旋转设置。它还使用新的设置，倾斜和距离，来确定卫星投影的角度。
- en: Listing 8.14\. Satellite projection settings
  id: totrans-650
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.14\. 卫星投影设置
- en: '[PRE57]'
  id: totrans-651
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '***1* The angle of the perspective on the geographic features**'
  id: totrans-652
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 地理特征的视角角度**'
- en: '***2* The distance of the surface from your perspective**'
  id: totrans-653
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 从你的视角到表面的距离**'
- en: '*Tilt* is the angle of the perspective on the data, whereas *distance* is the
    percentage of the radius of the earth (so 1.119 is 11.9% of the radius of the
    earth above the earth). How do you come up with such exact settings? You have
    two options. The first is to understand how to describe a tilted projection like
    this mathematically. If you have a degree in math or geography, you can look into
    literature for calculating this. If, like me, you don’t have that kind of background,
    then I would suggest building a tool, using the code we explored in this chapter,
    to adjust the rotation, tilt, distance, and scale settings interactively. That’s
    how I did it, and you can play with my satellite projection tool here: [http://bl.ocks.org/emeeks/10173187](http://bl.ocks.org/emeeks/10173187).'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: '*倾斜*是数据视角的角度，而*距离*是地球半径的百分比（因此1.119是地球上方地球半径的11.9%）。你是如何得出这样精确的设置的？你有两个选择。第一个是理解如何用数学方法描述这种倾斜的投影。如果你有数学或地理学位，你可以查阅文献来计算这个。如果你像我一样，没有这样的背景，那么我建议构建一个工具，使用本章中探索的代码来交互式地调整旋转、倾斜、距离和比例尺设置。我就是这样做的，你可以在我的卫星投影工具这里进行尝试：[http://bl.ocks.org/emeeks/10173187](http://bl.ocks.org/emeeks/10173187)。'
- en: Recall my advice in [Chapter 5](../Text/kindle_split_014.html#ch05) for understanding
    how the Sankey layout works. Use information visualization to visualize how the
    functions work so you can better understand them and find the right settings.
    Otherwise, you’re going to need to take a course in GIS or wait for someone to
    write *D3.js Mapping in Action*.
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下我在[第5章](../Text/kindle_split_014.html#ch05)中给出的建议，了解如何理解Sankey布局的工作原理。使用信息可视化来可视化函数的工作方式，这样你可以更好地理解它们并找到正确的设置。否则，你可能需要参加GIS课程或等待有人编写《*D3.js
    Mapping in Action*》。
- en: 'Now we’ll shift gears away from visualization and back to geodata structure
    to explore a library that was developed by Mike Bostock and is intimately tied
    to D3 mapping: TopoJSON.'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将从可视化转向地理数据结构，探索由Mike Bostock开发并与D3映射紧密相关的库：TopoJSON。
- en: 8.4\. TopoJSON data and functionality
  id: totrans-657
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.4\. TopoJSON数据和功能
- en: TopoJSON ([https://github.com/mbostock/topojson](https://github.com/mbostock/topojson))
    is fundamentally three different things. First of all, it’s a data standard for
    geographic data, and an extension of GeoJSON. Secondly, it’s a library that runs
    in node.js to create TopoJSON-formatted files from GeoJSON files. Thirdly, it’s
    a JavaScript library that processes TopoJSON--formatted files to create the data
    objects necessary to render them with libraries like D3\. You won’t deal with
    the second form at all, and you’ll only examine the first in a cursory manner
    as you learn about rendering TopoJSON data, merging it, and using it to find a
    feature’s neighbors.
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: TopoJSON ([https://github.com/mbostock/topojson](https://github.com/mbostock/topojson))
    基本上包括三个不同的东西。首先，它是一个地理数据的数据标准，也是 GeoJSON 的扩展。其次，它是一个在 node.js 中运行的库，可以从 GeoJSON
    文件创建 TopoJSON 格式的文件。第三，它是一个 JavaScript 库，用于处理 TopoJSON 格式的文件，以创建渲染它们所需的必要数据对象。你根本不会处理第二种形式，你将在学习如何渲染
    TopoJSON 数据、合并它以及使用它来查找特征邻居时，仅对第一种形式进行简要了解。
- en: 8.4.1\. TopoJSON the file format
  id: totrans-659
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.4.1\. TopoJSON 文件格式
- en: The difference between GeoJSON files and TopoJSON files is that whereas GeoJSON
    records for each feature an array of longitude and latitude coordinates that describe
    a point, line, or polygon, TopoJSON stores for each feature an array of arcs.
    An *arc* is any distinct segment of a line shared by one or more features in your
    dataset. As you can see in [figure 8.15](#ch08fig15), the shared border between
    the state of California and the state of Nevada is a single arc that’s referred
    to in the `arcs` array of the feature for California and the `arcs` array of the
    feature for Nevada.
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: GeoJSON 文件和 TopoJSON 文件之间的区别在于，GeoJSON 为每个特征记录一个经纬度坐标数组，这些坐标描述了一个点、线或多边形，而 TopoJSON
    为每个特征存储一个弧数组。一个 *弧* 是你的数据集中一个或多个特征共享的任何不同线段。正如你在 [图 8.15](#ch08fig15) 中可以看到的，加利福尼亚州和内华达州之间的共享边界是一个单一的弧，它在加利福尼亚州特征的
    `arcs` 数组和内华达州特征的 `arcs` 数组中被引用。
- en: Figure 8.15\. Arcs making up the counties of California and Nevada and neighboring
    states. You can see that the arcs are split whenever there is a possibility that
    they could be used in a different polygon. As a result, the 17 arcs making up
    the border of California and Nevada are used not only in the polygons making California
    and Nevada but also the polygons making their counties. Because the dataset knows
    the arcs are shared, it can easily derive neighbors.
  id: totrans-661
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 8.15\. 组成加利福尼亚州和内华达州及其邻近州的县弧。你可以看到，当有它们可能被用于不同多边形的机会时，弧会被分割。因此，组成加利福尼亚州和内华达州边界的
    17 个弧不仅用于构成加利福尼亚州和内华达州的多边形，也用于构成它们各自的县的多边形。因为数据集知道这些弧是共享的，它可以轻松地推导出邻居。
- en: '![](../Images/08fig15.jpg)'
  id: totrans-662
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/08fig15.jpg)'
- en: Most datasets have shared segments, so TopoJSON often produces significantly
    smaller datasets. This is part of its appeal. Another part is that if you know
    what segments are shared, then you can do interesting things with the data, like
    easily calculating the neighboring features or the shared border, or merging features.
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数数据集都有共享的部分，因此 TopoJSON 通常会产生显著更小的数据集。这是其吸引力的一部分。另一部分是，如果你知道哪些部分是共享的，那么你可以用数据做一些有趣的事情，比如轻松计算相邻特征或共享边界，或者合并特征。
- en: TopoJSON stores the arcs as a reference to a particular arc in a master list
    of arcs that defines the coordinates of that arc. You need the Topojson.js library
    included in any website you’re using to create maps with TopoJSON, because it
    changes TopoJSON into a format that D3 can read and create graphics from.
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: TopoJSON 将弧存储为对主弧列表中特定弧的引用，该列表定义了该弧的坐标。你需要将 Topojson.js 库包含在任何使用 TopoJSON 创建地图的网站上，因为它将
    TopoJSON 转换为 D3 可以读取并从中创建图形的格式。
- en: 8.4.2\. Rendering TopoJSON
  id: totrans-665
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.4.2\. 渲染 TopoJSON
- en: Because TopoJSON stores its data in a format different from the GeoJSON structure
    that’s expected by `d3.geoPath()`, we need to include Topojson.js and use it to
    process TopoJSON data to produce GeoJSON features. This is rather straightforward
    and can be done in a call to our new datafile, as shown in [listing 8.15](#ch08ex15).
    [Figure 8.16](#ch08fig16) shows the properly formatted features in your console.
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 TopoJSON 以与 `d3.geoPath()` 预期的 GeoJSON 结构不同的格式存储其数据，我们需要包含 Topojson.js 并使用它来处理
    TopoJSON 数据，以生成 GeoJSON 特征。这相当直接，可以在我们的新数据文件调用中完成，如 [代码清单 8.15](#ch08ex15) 所示。[图
    8.16](#ch08fig16) 显示了在控制台中正确格式化的特征。
- en: Figure 8.16\. TopoJSON data formatted using `Topojson.feature()`. The data is
    an array of objects, and it represents geometry as an array of coordinates like
    the features that come out of a GeoJSON file.
  id: totrans-667
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 8.16\. 使用 `Topojson.feature()` 格式的 TopoJSON 数据。数据是一个对象数组，它将几何形状表示为坐标数组，就像从
    GeoJSON 文件中输出的特征一样。
- en: '![](../Images/08fig16.jpg)'
  id: totrans-668
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/08fig16.jpg)'
- en: Listing 8.15\. Loading TopoJSON
  id: totrans-669
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.15\. 加载 TopoJSON
- en: '[PRE58]'
  id: totrans-670
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '***1* Notice that our TopoJSON file has a property “objects”, which all TopoJSON
    files have, but “countries” is specific to this file and might be “rivers” or
    “land” or other property names in other files**'
  id: totrans-671
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 注意，我们的 TopoJSON 文件有一个“objects”属性，所有 TopoJSON 文件都有，但“countries”是特定于这个文件的，可能是“rivers”或“land”或其他文件中的其他属性名**'
- en: Now that it’s in the format we want, we can send it to our existing code and
    draw this array of features like we did with the features we loaded from world.geojson.
    We replace our earlier `countries` with the `worldFeatures` variable declared
    in [listing 8.15](#ch08ex15). That’s all that most people do with TopoJSON, and
    they’re happy for it because TopoJSON data is significantly smaller than GeoJSON
    data. But because we know the topology of the features in a TopoJSON data file,
    we do interesting geographic tricks with it.
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 现在格式符合我们的要求，我们可以将其发送到现有的代码中，并像处理从 world.geojson 加载的特征那样绘制这个特征数组。我们将之前的 `countries`
    替换为在 [列表 8.15](#ch08ex15) 中声明的 `worldFeatures` 变量。大多数人就是用 TopoJSON 做这些事情，他们对此感到满意，因为
    TopoJSON 数据比 GeoJSON 数据小得多。但因为我们知道 TopoJSON 数据文件中特征的拓扑结构，所以我们用它来做一些有趣的地理技巧。
- en: 8.4.3\. Merging
  id: totrans-673
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.4.3\. 合并
- en: The TopoJSON library provides you with the capacity to create new features by
    merging existing features. You can create a new feature for “North America” by
    merging the countries in North America, or create “The United States in 1912”
    by merging the states that were part of the United States in 1912\. [Listing 8.16](#ch08ex16)
    shows the code to draw a map using our new TopoJSON data file and merge all the
    countries that have a center west of 0° longitude. The results, shown in [figure
    8.17](#ch08fig17), show that merging combines not only contiguous features but
    also separate features into a multipolygon.
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: TopoJSON 库为你提供了通过合并现有特征来创建新特征的能力。你可以通过合并北美国家的特征来创建“北美”的新特征，或者通过合并 1912 年美国的一部分州来创建“1912
    年的美国”。[列表 8.16](#ch08ex16) 展示了使用我们新的 TopoJSON 数据文件绘制地图并合并所有中心经度西于 0° 的国家的代码。如图
    8.17 所示的结果表明，合并不仅结合了连续的特征，还将分离的特征合并成一个多边形。
- en: Figure 8.17\. The results of merging based on the centroid of a feature. The
    feature in gray is a single merged feature made up of many separate polygons.
  id: totrans-675
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 8.17\. 基于特征质心的合并结果。灰色特征是由许多单独的多边形组成的单一合并特征。
- en: '![](../Images/08fig17.jpg)'
  id: totrans-676
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/08fig17.jpg)'
- en: Listing 8.16\. Rendering and merging TopoJSON
  id: totrans-677
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.16\. 渲染和合并 TopoJSON
- en: '[PRE59]'
  id: totrans-678
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '***1* After processed by Topojson.features, we use exactly the same methods
    to render the features**'
  id: totrans-679
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 经过 Topojson.features 处理后，我们使用完全相同的方法来渲染特征**'
- en: '***2* Our merge function**'
  id: totrans-680
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 合并函数**'
- en: '***3* We’re working with the TopoJSON dataset**'
  id: totrans-681
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 我们正在处理 TopoJSON 数据集**'
- en: '***4* To use geoCentroid, we convert each feature into GeoJSON**'
  id: totrans-682
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 要使用 geoCentroid，我们需要将每个特征转换为 GeoJSON**'
- en: '***5* Results in an array of only the corresponding geometries**'
  id: totrans-683
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 结果是一个仅包含相应几何形状的数组**'
- en: '***6* Uses datum because merge returns a single multipolygon**'
  id: totrans-684
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 使用 datum，因为 merge 返回一个单一的多边形**'
- en: 'We can adjust the `mergeAt` test slightly to look at the x coordinate or to
    see features that have greater values of `mergeAt`. As shown in [figure 8.18](#ch08fig18),
    this creates a single feature in each of four cases: less than or greater than
    0° latitude and less than or greater than 0° longitude. Notice in each case that
    it’s a single feature but not a single polygon.'
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以稍微调整 `mergeAt` 测试，以查看 x 坐标或查看 `mergeAt` 值更大的特征。如图 8.18 所示，这会在四种情况下创建单个特征：小于或大于
    0° 纬度和小于或大于 0° 经度。注意在每个情况下，它都是一个单一的特征，但不是一个单一的多边形。
- en: Figure 8.18\. By adjusting the merge settings, we can create something like
    northern and eastern hemispheres as merged features. Notice that because this
    is based on a centroid, we can see at the bottom a piece of Eastern Russia as
    part of our merged feature, along with Antarctica.
  id: totrans-686
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 8.18\. 通过调整合并设置，我们可以创建类似北半球和东半球这样的合并特征。注意，因为这是基于质心，所以我们可以在底部看到作为我们合并特征一部分的俄罗斯东部，以及南极洲。
- en: '![](../Images/08fig18_alt.jpg)'
  id: totrans-687
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/08fig18_alt.jpg)'
- en: 'A quick note for those who may want to continue working in topologies: `Topojson.merge`
    has a sister function, `mergeArcs`, that allows you to merge shapes but keep them
    in TopoJSON format. Why would you want to maintain arcs? Because then you could
    continue to use TopoJSON functionality like merging, creating meshes, or finding
    neighbors of your newly merged features.'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些可能想要继续在拓扑结构中工作的人来说，有一个快速提示：`Topojson.merge` 有一个姐妹函数 `mergeArcs`，它允许你合并形状，但保持它们在
    TopoJSON 格式。你为什么要保持弧线呢？因为这样你就可以继续使用 TopoJSON 的功能，如合并、创建网格或找到你新合并的特征的邻居。
- en: 8.4.4\. Neighbors
  id: totrans-689
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.4.4. 邻居
- en: Because we know when features share arcs, we also know what features neighbor
    each other. The function `Topojson.neighbors` builds an array of all the features
    that share a border. We can use this array to easily identify neighboring countries
    in our dataset using the code in [listing 8.17](#ch08ex17). The results of the
    interaction provided by this code are shown in [figure 8.19](#ch08fig19).
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们知道特征共享弧线，所以我们也知道哪些特征彼此相邻。`Topojson.neighbors` 函数构建了一个所有共享边界的特征的数组。我们可以使用这个数组通过
    [列表 8.17](#ch08ex17) 中的代码轻松地识别数据集中的邻近国家。此代码提供的交互结果在 [图 8.19](#ch08fig19) 中显示。
- en: Figure 8.19\. Hover behavior displaying the neighbors of France using TopoJSON’s
    `neighbor` function. Because Guyana is an overseas department of France, France
    is considered to be neighbors with Brazil and Suriname. This is because France
    is represented as a multipolygon in the data, and any neighbors with any of its
    shapes are returned as neighbors.
  id: totrans-691
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 8.19. 使用 TopoJSON 的 `neighbor` 函数显示法国的邻居的悬停行为。因为圭亚那是法国的海外领地，所以法国被认为是巴西和苏里南的邻居。这是因为法国在数据中表示为多边形，任何与它的形状相邻的邻居都会被返回。
- en: '![](../Images/08fig19.jpg)'
  id: totrans-692
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/08fig19.jpg)'
- en: Listing 8.17\. Calculating neighbors and interactive highlighting
  id: totrans-693
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.17. 计算邻居和交互式高亮
- en: '[PRE60]'
  id: totrans-694
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '***1* Creates an array indicating neighbors by their array position**'
  id: totrans-695
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 创建一个数组，通过它们的数组位置指示邻居**'
- en: '***2* Colors the country you hover over orange**'
  id: totrans-696
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将你悬停的国家变为橙色**'
- en: '***3* Colors all neighbors green**'
  id: totrans-697
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 将所有邻居绿色**'
- en: '***4* Colors all countries gray to “clear” results**'
  id: totrans-698
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 将所有国家灰色以“清除”结果**'
- en: TopoJSON is a powerful technology that provides tremendous opportunity for web
    map development. Understanding how it models data and the functionality it provides
    are key to creating maps that impress users. Keep in mind that the same topological
    functionality is available in `d3.voronoi`.
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: TopoJSON 是一种强大的技术，为网络地图开发提供了巨大的机会。了解它如何建模数据和它提供的功能对于创建能打动用户的地图至关重要。请记住，相同的拓扑功能在
    `d3.voronoi` 中也是可用的。
- en: 8.5\. Further reading for web mapping
  id: totrans-700
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.5. Further reading for web mapping
- en: As I said in the beginning of this chapter, the things you can do with D3’s
    mapping capabilities would fill an entire book. This section touches on a few
    other capabilities we didn’t cover in this chapter.
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我在本章开头所说，你可以使用 D3 的映射功能做的事情可以填满一本书。本节简要介绍了本章未涉及的一些其他功能。
- en: 8.5.1\. Tile mapping
  id: totrans-702
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.5.1. 瓦片映射
- en: D3 can be used in conjunction with other web libraries or the `d3.geoTile` module
    to overlay vector features on raster tiles. If you’re serious about developing
    tile-based maps, though, you’re probably better off working with dedicated libraries,
    like mapboxGL, which you can find at [www.mapbox.com/mapbox-gl-js/api/](http://www.mapbox.com/mapbox-gl-js/api/).
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: D3 可以与其他网络库或 `d3.geoTile` 模块结合使用，在栅格瓦片上叠加矢量特征。不过，如果你认真对待基于瓦片的地图开发，那么使用专门的库，如
    mapboxGL，可能更好，你可以在 [www.mapbox.com/mapbox-gl-js/api/](http://www.mapbox.com/mapbox-gl-js/api/)
    找到它。
- en: 8.5.2\. Transform zoom
  id: totrans-704
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.5.2. 变换缩放
- en: The method we used for our zoom behavior in this chapter, known as *projection
    zoom*, recalculates mathematically the shape of features based on a change in
    scale and translation. But if you’re using a projection that’s flat, like Mercator,
    you can achieve faster performance by tying the change in scale and translate
    of the zoom behavior to your features’ SVG `transform`.
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我们用于缩放行为的我们使用的方法，称为 *投影缩放*，根据比例和转换的变化在数学上重新计算特征的形状。但是，如果你使用的是像墨卡托这样的平面投影，你可以通过将缩放行为的比例和转换的变化与你的特征的
    SVG `transform` 绑定来达到更快的性能。
- en: 8.5.3\. Canvas drawing
  id: totrans-706
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.5.3. Canvas 绘图
- en: The `.context` function of `d3.geoPath` allows you to easily draw your vector
    data to a `<canvas>` element, which can dramatically improve speed in certain
    cases. It also allows you to use `.toDataURL()` to dynamically create a PNG for
    users to save or share on social media. We’ll see this in [chapter 11](../Text/kindle_split_022.html#ch11).
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: '`d3.geoPath`的`.context`函数允许你轻松地将矢量数据绘制到`<canvas>`元素上，这在某些情况下可以显著提高速度。它还允许你使用`.toDataURL()`动态创建一个PNG，供用户保存或分享到社交媒体。我们将在[第11章](../Text/kindle_split_022.html#ch11)中看到这一点。'
- en: 8.5.4\. Raster reprojection
  id: totrans-708
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.5.4\. 栅格重投影
- en: Jason Davies and Mike Bostock have both provided examples of reprojecting not
    only vector data, but the tile data used in tile maps (see bl.ocks.org/mbostock/
    and [www.jasondavies.com/maps/raster/satellite/](http://www.jasondavies.com/maps/raster/satellite/)).
    You can use this to show a satellite--projected terrain map or a terrain map with
    the Mollweide projection we used earlier.
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: Jason Davies和Mike Bostock都提供了重新投影矢量数据以及用于瓦片地图的瓦片数据的示例（见bl.ocks.org/和[www.jasondavies.com/maps/raster/satellite/](http://www.jasondavies.com/maps/raster/satellite/)）。你可以使用这些示例来显示卫星投影的地形图或使用我们之前使用的Mollweide投影的地形图。
- en: 8.5.5\. Hexbins
  id: totrans-710
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.5.5\. 六边形分箱
- en: The `d3.hexbin` plugin allows you to easily create hexbin overlays for your
    maps like that seen in [figure 8.20](#ch08fig20). This can be effective when you
    have quantitative data in point form and you want to aggregate it by area.
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: '`d3.hexbin`插件允许你轻松地为地图创建六边形分箱覆盖，就像在[图8.20](#ch08fig20)中看到的那样。当你有以点形式存在的定量数据，并希望按区域对其进行汇总时，这可以非常有效。'
- en: Figure 8.20\. An example of hexbinning by Mike Bostock showing the locations
    of Walmart stores in the United States (available at [http://bl.ocks.org/mbostock/4330486](http://bl.ocks.org/mbostock/4330486)).
  id: totrans-712
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.20\. Mike Bostock展示的六边形分箱示例，显示了美国沃尔玛商店的位置（可在[http://bl.ocks.org/mbostock/4330486](http://bl.ocks.org/mbostock/4330486)查看）。
- en: '![](../Images/08fig20.jpg)'
  id: totrans-713
  prefs: []
  type: TYPE_IMG
  zh: '![图8.20](../Images/08fig20.jpg)'
- en: 8.5.6\. Voronoi diagrams
  id: totrans-714
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.5.6\. Voronoi图
- en: As with hexbins, if you only have point data and want to create area data from
    it, you can use the `d3.geom.voronoi` function to derive polygons from points
    like the kind seen in [figure 8.21](#ch08fig21).
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 与六边形分箱类似，如果你只有点数据，并想从中创建区域数据，可以使用`d3.geom.voronoi`函数从点推导出多边形，就像在[图8.21](#ch08fig21)中看到的那样。
- en: Figure 8.21\. An example of a Voronoi diagram used to split the United States
    into polygons based on the closest state capital (available at [www.jasondavies.com/maps/voronoi/us-capitals/](http://www.jasondavies.com/maps/voronoi/us-capitals/)).
  id: totrans-716
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.21\. 使用最近州首府划分美国为多边形的Voronoi图示例（可在[www.jasondavies.com/maps/voronoi/us-capitals/](http://www.jasondavies.com/maps/voronoi/us-capitals/)查看）。
- en: '![](../Images/08fig21.jpg)'
  id: totrans-717
  prefs: []
  type: TYPE_IMG
  zh: '![图8.21](../Images/08fig21.jpg)'
- en: 8.5.7\. Cartograms
  id: totrans-718
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.5.7\. 地形图
- en: Distorting the area or length of a geographic object to show other information
    creates a *cartogram*. For example, you could distort the streets of your city
    based on the time it takes to drive along them, or make the size of countries
    on a world map bulge or shrink based on population. Although no simple functions
    exist to create cartograms, examples of how to create them in D3 include one created
    by Jason Davies ([www.jasondavies.com/maps/dorling-world/](http://www.jasondavies.com/maps/dorling-world/)),
    one created by Mike Bostock ([http://bl.ocks.org/mbostock/4055908](http://bl.ocks.org/mbostock/4055908)),
    and the cost cartogram I built ([orbis.stanford.edu](http://orbis.stanford.edu)).
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 通过扭曲地理对象的面或长度来展示其他信息，可以创建一个*地形图*。例如，你可以根据沿着街道驾驶所需的时间扭曲你城市的街道，或者根据人口使世界地图上的国家大小膨胀或缩小。尽管没有简单的函数可以创建地形图，但D3中创建地形图的示例包括Jason
    Davies创建的一个（[www.jasondavies.com/maps/dorling-world/](http://www.jasondavies.com/maps/dorling-world/)），Mike
    Bostock创建的一个（[http://bl.ocks.org/mbostock/4055908](http://bl.ocks.org/mbostock/4055908)），以及我构建的成本地形图（[orbis.stanford.edu](http://orbis.stanford.edu)）。
- en: 8.6\. Summary
  id: totrans-720
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.6\. 摘要
- en: Maps are a core aspect of data visualization. To create them, we need to know
    how to work with GeoJSON.
  id: totrans-721
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 地图是数据可视化的核心方面。要创建它们，我们需要了解如何使用GeoJSON。
- en: Combining CSV data with geodata to present polygons for countries and points
    for cities is done with D3’s geographic projection functions.
  id: totrans-722
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将CSV数据与地理数据结合，使用D3的地理投影函数来呈现国家和城市的多边形以及点。
- en: D3’s `geoPath` not only creates SVG drawing instructions for `<path>` elements
    from geodata, but also provides functions to calculate the center, area, and bounds
    of the shape.
  id: totrans-723
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: D3的`geoPath`不仅从地理数据创建SVG绘图指令用于`<path>`元素，还提供了计算形状中心、面积和边界的函数。
- en: Like using an axis with charts, longitude and latitude lines can be created
    with the built-in `graticule()` functionality in `geoPath`.
  id: totrans-724
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 像使用图表中的轴一样，可以使用 `geoPath` 内置的 `graticule()` 功能创建经纬线。
- en: Dragging and zooming into and out of the map, as well as rotating globes, all
    use `zoom()`.
  id: totrans-725
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拖动和缩放地图，以及旋转地球仪，都使用 `zoom()`。
- en: TopoJSON provides more compact geodata and added functionality, like the ability
    to merge polygons and detect neighbors.
  id: totrans-726
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TopoJSON提供了更紧凑的地理数据和附加功能，例如合并多边形和检测邻居的能力。
- en: D3 in the real world
  id: totrans-727
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 真实世界中的D3
- en: Philippe Rivière journalist/programmer
  id: totrans-728
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Philippe Rivière 记者兼程序员
- en: '*Visionscarto*'
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: '*Visionscarto*'
- en: '[Visionscarto.net](http://Visionscarto.net) is a small independent research
    center with a special interest in the intersection of art, geography, and social
    justice. To create maps, our toolset includes crayons and watercolor, paper and
    vector graphic software, and geographic information systems. We use D3 to prototype,
    create first images from datasets, and to try various algorithms, for example
    when we need to place labels automatically on thematic maps.'
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: '[Visionscarto.net](http://Visionscarto.net) 是一个小型的独立研究中心，特别关注艺术、地理和社会正义的交汇点。为了创建地图，我们的工具集包括蜡笔和水彩、纸张和矢量图形软件，以及地理信息系统。我们使用D3进行原型设计，从数据集中创建第一张图像，并尝试各种算法，例如当我们需要自动在专题地图上放置标签时。'
- en: '![](../Images/271fig01_alt.jpg)'
  id: totrans-731
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/271fig01_alt.jpg)'
- en: '![](../Images/271fig02_alt.jpg)'
  id: totrans-732
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/271fig02_alt.jpg)'
- en: What drew us to D3 was its amazing set of geographic projections. Being able,
    with a simple code change, to choose the relevant projection (be it a classical
    Robinson, or a polar projection when necessary), and rotate it at will, was a
    killer feature. Web-Mercator no more! This also lead us down the rabbit hole of
    researching new projections—with lots of difficulties...and lots of delight.
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: 我们被D3吸引的原因是其惊人的地理投影集。能够通过简单的代码更改选择相关的投影（无论是经典的罗宾逊投影，还是必要时使用的极地投影），并且可以随意旋转，这是一个杀手级特性。不再需要Web-Mercator！这也让我们陷入了研究新投影的兔子洞——充满了许多困难……以及许多乐趣。
- en: 'Toy as much as possible with all the examples given by the community, try to
    modify them in unplanned ways, and by practicing a lot, you’ll find your own voice.
    The beautiful thing with D3 is that it models all the abstractions at the right
    level: scales are not only a means to transfer data to pixels, but a solid way
    of designing your graphs; countries are not only shapes on a map, but a meaningful
    topology in which they share borders with neighbors.'
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: 尽可能多地尝试社区提供的所有示例，尝试以未计划的方式修改它们，通过大量实践，你会发现自己的声音。D3的美丽之处在于它以正确的级别建模所有抽象：比例不仅是一种将数据传输到像素的手段，而且是一种设计图表的坚实方法；国家不仅是在地图上的形状，而且是一个有意义的拓扑，它们与邻居共享边界。
