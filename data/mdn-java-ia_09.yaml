- en: Appendix D. Lambdas and JVM bytecode
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 附录 D. Lambda 和 JVM 字节码
- en: You may wonder how the Java compiler implements lambda expressions and how the
    Java virtual machine (JVM) deals with it. If you think lambda expressions can
    simply be translated to anonymous classes, you should read on. This appendix briefly
    discusses how lambda expressions are compiled, by examining the generated class
    files.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会想知道 Java 编译器如何实现 lambda 表达式，以及 Java 虚拟机 (JVM) 如何处理它。如果您认为 lambda 表达式可以简单地翻译成匿名类，请继续阅读。本附录简要讨论了
    lambda 表达式是如何编译的，通过检查生成的类文件。
- en: D.1\. Anonymous classes
  id: totrans-2
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: D.1. 匿名类
- en: We showed in [chapter 2](kindle_split_012.xhtml#ch02) that anonymous classes
    can be used to declare and instantiate a class at the same time. As a result,
    just like lambda expressions, they can be used to provide the implementation for
    a functional interface.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 [第 2 章](kindle_split_012.xhtml#ch02) 中展示了匿名类可以同时声明和实例化一个类。因此，就像 lambda 表达式一样，它们可以用来为函数式接口提供实现。
- en: 'Because a lambda expression provides the implementation for the abstract method
    of a functional interface, it would seem straightforward to ask the Java compiler
    to translate a lambda expression into an anonymous class during the compilation
    process. But anonymous classes have some undesirable characteristics that impact
    the performance of applications:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 lambda 表达式为函数式接口的抽象方法提供了实现，因此似乎在编译过程中要求 Java 编译器将 lambda 表达式翻译成匿名类是直截了当的。但是匿名类有一些不希望的特性，这些特性会影响应用程序的性能：
- en: '*The compiler generates a new class file for each anonymous class.* The filename
    usually looks like `ClassName$1`, where `ClassName` is the name of the class in
    which the anonymous class appears, followed by a dollar sign and a number. The
    generation of many class files is undesirable, because each class file needs to
    be loaded and verified before being used, which impacts the startup performance
    of the application. If lambdas were translated to anonymous classes, you’d have
    one new class file for each lambda.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*编译器为每个匿名类生成一个新的类文件。* 文件名通常看起来像 `ClassName$1`，其中 `ClassName` 是匿名类出现的类的名称，后面跟着一个美元符号和一个数字。生成许多类文件是不希望的，因为每个类文件在使用之前都需要被加载和验证，这会影响应用程序的启动性能。如果
    lambda 被翻译成匿名类，那么每个 lambda 就会有一个新的类文件。'
- en: '*Each new anonymous class introduces a new subtype for a class or interface.*
    If you had a hundred different lambdas for expressing a `Comparator`, that would
    mean a hundred different subtypes of `Comparator`. In certain situations, this
    can make it harder to improve runtime performance by the JVM.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*每个新的匿名类都会为类或接口引入一个新的子类型。* 如果您有表达 `Comparator` 的 100 个不同的 lambda，那么这意味着 100
    个不同的 `Comparator` 子类型。在某些情况下，这可能会使 JVM 提高运行时性能变得更加困难。'
- en: D.2\. Bytecode generation
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: D.2. 字节码生成
- en: A Java source file is compiled to Java bytecode by the Java compiler. The JVM
    can then execute the generated bytecode and run the application. Anonymous classes
    and lambda expressions use different bytecode instructions when they’re compiled.
    You can inspect the bytecode and constant pool of any class file using the command
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 Java 源文件由 Java 编译器编译成 Java 字节码。然后 JVM 可以执行生成的字节码并运行应用程序。匿名类和 lambda 表达式在编译时使用不同的字节码指令。您可以使用以下命令检查任何类文件的字节码和常量池：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Let’s try to implement an instance of the `Function` interface using the old
    Java 7 syntax, as an anonymous inner class, as shown in the following listing.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试使用旧的 Java 7 语法实现 `Function` 接口的实例，作为一个匿名内部类，如下所示。
- en: Listing D.1\. A `Function` implemented as an anonymous inner class
  id: totrans-11
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 D.1. 作为匿名内部类实现的 `Function`
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Doing this, the corresponding generated bytecode for the `Function` created
    as an anonymous inner class will be something along the lines of this:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做，作为匿名内部类创建的 `Function` 对应生成的字节码将大致如下：
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This code shows the following:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码展示了以下内容：
- en: An object of type `InnerClass$1` is instantiated using the byte code operation
    `new`. A reference to the newly created object is pushed on the stack at the same
    time.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用字节码操作 `new` 实例化类型为 `InnerClass$1` 的对象。同时将新创建的对象引用压入栈中。
- en: The operation `dup` duplicates that reference on the stack.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作 `dup` 复制栈上的那个引用。
- en: This value then gets consumed by the instruction `invokespecial`, which initializes
    the object.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此值随后被指令 `invokespecial` 消耗，该指令初始化对象。
- en: The top of the stack now still contains a reference to the object, which is
    stored in the `f1` field of the `LambdaBytecode` class using the `putfield` instruction.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 栈顶现在仍然包含对对象的引用，该对象使用 `putfield` 指令存储在 `LambdaBytecode` 类的 `f1` 字段中。
- en: '`InnerClass$1` is the name generated by the compiler for the anonymous class.
    If you want to reassure yourself, you can inspect the `InnerClass$1` class file
    as well, and you’ll find the code for the implementation of the `Function` interface:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`InnerClass$1` 是编译器为匿名类生成的名称。如果你想确认这一点，你也可以检查 `InnerClass$1` 类文件，你将找到实现 `Function`
    接口的代码：'
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: D.3\. Invokedynamic to the rescue
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: D.3\. Invokedynamic to the rescue
- en: Now let’s try to do the same using the new Java 8 syntax as a lambda expression.
    Inspect the generated class file of the code in the following listing.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试使用新的 Java 8 语法，即 lambda 表达式，来做同样的事情。检查以下列表中代码生成的类文件。
- en: Listing D.2\. A `Function` implemented with a lambda expression
  id: totrans-24
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 D.2\. 使用 lambda 表达式实现的 `Function`
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You’ll find the following bytecode instructions:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 你将找到以下字节码指令：
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We explained the drawbacks in translating a lambda expression in an anonymous
    inner class, and indeed you can see that the result is very different. The creation
    of an extra class has been replaced with an `invokedynamic` instruction.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们解释了在匿名内部类中翻译 lambda 表达式的缺点，确实你可以看到结果非常不同。额外类的创建已被 `invokedynamic` 指令所取代。
- en: '|  |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**The invokedynamic instruction**'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**invokedynamic 指令**'
- en: 'The bytecode instruction `invokedynamic` was introduced in JDK7 to support
    dynamically typed languages on the JVM. `invokedynamic` adds a further level of
    indirection when invoking a method, to let some logic dependent on the specific
    dynamic language determine the call target. The typical use for this instruction
    is something like the following:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`invokedynamic` 字节码指令是在 JDK7 中引入的，以支持 JVM 上的动态类型语言。`invokedynamic` 在调用方法时添加了另一层间接性，以便让一些依赖于特定动态语言的逻辑确定调用目标。此指令的典型用途如下：'
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here the types of `a` and `b` aren’t known at compile time and can change from
    time to time. For this reason, when the JVM executes an `invokedynamic` for the
    first time, it consults a bootstrap method, implementing the language-dependent
    logic that determines the actual method to be called. The bootstrap method returns
    a linked call site. There’s a good chance that if the `add` method is called with
    two `int`s, the subsequent call will also be with two `int`s. As a result, it’s
    not necessary to rediscover the method to be called at each invocation. The call
    site itself can contain the logic defining under which conditions it needs to
    be relinked.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`a` 和 `b` 的类型在编译时是未知的，并且可能会不时地改变。因此，当 JVM 首次执行 `invokedynamic` 时，它会咨询一个启动方法，该启动方法实现了确定要调用实际方法的与语言相关的逻辑。启动方法返回一个链接的调用点。如果
    `add` 方法用两个 `int` 调用，那么随后的调用也很可能也是用两个 `int` 调用。因此，在每次调用时都不需要重新发现要调用的方法。调用点本身可以包含定义在什么条件下需要重新链接的逻辑。
- en: '|  |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'In listing D.2, the features of the `invokedynamic` instruction have been used
    for a slightly different purpose than the one for which they were originally introduced.
    In fact, here it used to delay the strategy used to translate lambda expressions
    in bytecode until runtime. In other words, using `invokedynamic` in this way allows
    deferring code generation for implementing the lambda expression until runtime.
    This design choice has positive consequences:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表 D.2 中，`invokedynamic` 指令被用于一个与最初引入时的不同目的。实际上，这里它被用来延迟在字节码中翻译 lambda 表达式的策略，直到运行时。换句话说，以这种方式使用
    `invokedynamic` 允许将 lambda 表达式的实现代码生成推迟到运行时。这种设计选择有积极的影响：
- en: The strategy used to translate the lambda expression body to bytecode becomes
    a pure implementation detail. It could also be changed dynamically, or optimized
    and modified in future JVM implementations, preserving the bytecode’s backward
    compatibility.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 lambda 表达式体翻译成字节码的策略变成了一个纯粹的实施细节。它也可以在动态中更改，或者在未来的 JVM 实现中进行优化和修改，以保持字节码的向后兼容性。
- en: There’s no overhead, such as additional fields or static initializer, if the
    lambda is never used.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 lambda 从未使用，则没有开销，例如额外的字段或静态初始化器。
- en: For stateless (noncapturing) lambdas it’s possible to create one instance of
    the lambda object, cache it, and always return the same. This is a common use
    case, and people were used to doing this explicitly before Java 8; for example,
    declaring a specific `Comparator` instance in a static final variable.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于无状态（非捕获）lambda，可以创建一个 lambda 对象的实例，将其缓存，并始终返回相同的实例。这是一个常见的用例，在 Java 8 之前，人们习惯于显式地这样做；例如，在静态最终变量中声明特定的
    `Comparator` 实例。
- en: There’s no additional performance cost because this translation has to be performed,
    and its result linked, only when the lambda is invoked for the first time. All
    subsequent invocations can skip this slow path and call the formerly linked implementation.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于这个翻译必须在 lambda 首次被调用时执行，并且其结果被链接，所以没有额外的性能开销。所有后续调用都可以跳过这个慢路径，并调用之前链接的实现。
- en: D.4\. Code-generation strategies
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: D.4. 代码生成策略
- en: 'A lambda expression is translated into bytecode by putting its body into one
    of a static method created at runtime. A stateless lambda, one that captures no
    state from its enclosing scope, like the one we defined in listing D.2, is the
    simplest type of lambda to be translated. In this case the compiler can generate
    a method having the same signature of the lambda expression, so the result of
    this translation process can be logically seen as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: lambda 表达式通过将其主体放入在运行时创建的静态方法之一中，被翻译成字节码。无状态 lambda，即不捕获其封闭作用域中的任何状态的 lambda，如我们在列表
    D.2 中定义的那样，是最简单的 lambda 类型，需要被翻译。在这种情况下，编译器可以生成一个与 lambda 表达式具有相同签名的方 法，因此这个翻译过程的最终结果可以逻辑上看作如下：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The case of a lambda expression capturing final (or effectively final) local
    variables or fields, as in the following example, is a bit more complex:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，lambda 表达式捕获最终（或实际上是最终）局部变量或字段的情况，要复杂一些：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In this case the signature of the generated method can’t be the same as the
    lambda expression, because it’s necessary to add extra arguments to carry the
    additional state of the enclosed context. The simplest solution to achieve this
    is to prepend the arguments of the lambda expression with an additional argument
    for each of the captured variables, so the method generated to implement the former
    lambda expression will be something like this:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，生成的方法的签名不能与 lambda 表达式相同，因为需要添加额外的参数来携带封闭上下文的额外状态。实现这个目标的最简单方法是，在 lambda
    表达式的参数前面添加一个额外的参数，用于每个捕获的变量，因此用于实现前一个 lambda 表达式的生成方法将类似于以下这样：
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'More information about the translation process for lambda expressions can be
    found here: [http://cr.openjdk.java.net/~briangoetz/lambda/lambda-translation.html](http://cr.openjdk.java.net/~briangoetz/lambda/lambda-translation.html).'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 lambda 表达式翻译过程的更多信息，可以在这里找到：[http://cr.openjdk.java.net/~briangoetz/lambda/lambda-translation.html](http://cr.openjdk.java.net/~briangoetz/lambda/lambda-translation.html)。
