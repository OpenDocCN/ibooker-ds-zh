- en: 5 Code quality enforcement
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5 代码质量执行
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Standardizing our code’s format by using formatting tools and linters
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用格式化工具和代码检查器标准化我们的代码格式
- en: Reducing bugs and vulnerabilities in our code by introducing static code analysis
    tools
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过引入静态代码分析工具减少代码中的错误和漏洞
- en: Automating quality checks before pushing code to a repository
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在将代码推送到仓库之前自动化质量检查
- en: Organizing our code and documenting it for clearer usage and reuse
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组织我们的代码并为其编写文档，以便更清晰的使用和重用
- en: Creating a culture of learning through code reviews
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过代码审查建立学习文化
- en: “As you can see, we can structure our projects in a way that empowers our developers
    to deliver quickly, efficiently, and with quality, while lowering costs. We have
    written and deployed a new version of our translation application in a day with
    flexible deployment options along with automated quality checks.”
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: “正如你所见，我们可以以一种赋予开发者快速、高效且高质量交付项目的能力的方式来构建我们的项目。我们只用了一天的时间就编写并部署了我们的翻译应用的新版本，同时提供了灵活的部署选项和自动化的质量检查。”
- en: Your project manager is smiling from ear to ear as they say this and sit back
    down. Your demo went really well. Without going into the nitty-gritty details,
    you were able to demonstrate your new application and even push a live change
    during the demo to show the quick turnaround you can achieve. Your CTO looked
    intrigued but not convinced.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的项目经理这样说并坐下来时，他们满脸笑容。你的演示做得非常好。不深入细节，你能够展示你的新应用，甚至在演示期间推送了实时更改，以展示你可以实现的多快速度。你的CTO看起来很感兴趣，但并不确信。
- en: “What you have demonstrated looks promising, but I’m not convinced this will
    scale. We have a bunch of other developers, an entire QA team, and an operations
    team that all need work. I need to see a plan that shows me how we can spread
    this throughout the organization. I need to see how you can integrate with existing
    systems, teams, and developers before I consider doing this company wide. Can
    we meet on Friday to have these questions answered?”
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: “你所展示的看起来很有希望，但我还没有确信这可以扩展。我们有一群其他开发者，一个完整的QA团队，以及一个运营团队，他们都需要工作。我需要看到一份计划，展示我们如何在整个组织中推广它。我需要看到你如何与现有系统、团队和开发者集成，在我考虑在全局范围内实施之前。我们能否在周五见面，解答这些问题？”
- en: You nod your head. It all makes sense to you since developers don’t often work
    in a vacuum. Plus, this is an iterative process, and you just got a bunch of great
    feedback.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你点头。这一切对你来说都很有意义，因为开发者很少单独工作。此外，这是一个迭代的过程，你刚刚得到了很多很好的反馈。
- en: “Great!” says your project manager, “I’ll get us something on the books. Please
    make sure you have a plan, documents, and another demo ready for Friday. You hit
    this one out of the park. Let’s see if you can do it again.”
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: “太好了！”你的项目经理说，“我会为我们安排一些事情。请确保你有一个计划，文件，并且为周五准备另一个演示。你这次做得很好。让我们看看你是否能再次做到。”
- en: 5.1 Reviewing code
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.1 代码审查
- en: Thus far, you’ve worked in a vacuum—just you and your code. This isn’t how software
    is usually made. Instead, most projects are a collaborative effort among several
    people. Over time this group of people becomes a team. As a team, they create
    sets of rules to operate by, learn from each other, and help improve each other.
    But how do we do this?
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你一直是在真空状态下工作——只有你和你的代码。这并不是软件通常的制作方式。相反，大多数项目都是几个人之间的协作努力。随着时间的推移，这些人组成了一个团队。作为一个团队，他们制定了一系列规则来运作，相互学习，并帮助彼此改进。但我们如何做到这一点呢？
- en: 'We have already introduced this tool: the repository. Not only does a repository
    store your code, but we can place it in a holding pattern until someone else allows
    it to be incorporated. Imagine again that our repository is a warehouse. When
    a shipment of goods comes in, someone needs to sign for it. If the boxes are damaged
    or missing, there is a trail back to the person who accepted the goods. There
    is a sense of accountability.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经引入了这项工具：仓库。仓库不仅存储你的代码，我们还可以将其放置在待处理模式中，直到有人允许将其合并。再次想象我们的仓库是一个仓库。当货物到达时，有人需要签收。如果箱子损坏或丢失，就可以追溯到接收货物的人。有一种责任感。
- en: In the same way, we want to have our team sign off on whatever we are introducing
    to the code repository. To do this, we use a mechanism called a *pull request*,
    which is a review process of code against a repository. This will protect the
    source code and educate others about the changes you are making. Let’s add this
    protection to our repository now.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们希望我们的团队能够对我们将要引入代码库中的任何内容进行签字确认。为此，我们使用一种称为“拉取请求”的机制，这是一种针对代码库的审查过程。这将保护源代码，并教育他人你正在进行的更改。现在让我们将这种保护添加到我们的代码库中。
- en: 'To do this, we need to navigate to our repository. Click Settings → Branches.
    Here you will see a section called “Branch Protection Rules” where you will see
    a form on which you input the name of the branch you want to protect and the specific
    rules associated with it. Fill it in as in figure 5.1: add the branch you are
    protecting and what needs to be done to protect this branch. This will protect
    the main branch from direct commits (unless you are an admin) and will prevent
    merges until you have one review and checks have passed.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们需要导航到我们的代码库。点击设置→分支。在这里，你会看到一个名为“分支保护规则”的部分，你将在其中看到一个表单，你可以输入你想要保护的分支的名称和与之相关的特定规则。按照图5.1中的方式填写：添加你想要保护的分支以及保护此分支需要执行的操作。这将保护主分支免受直接提交（除非你是管理员）的影响，并将在你有一个审查并且检查通过之前阻止合并。
- en: '![](../../OEBPS/Images/CH05_F01_Holmes4.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图5.1 在GitHub仓库中设置分支保护](../../OEBPS/Images/CH05_F01_Holmes4.png)'
- en: Figure 5.1 Setting up branch protection in GitHub Repo
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1 设置GitHub仓库中的分支保护
- en: You should notice that we have also selected that checks should pass before
    merging. We already have some checks in place with our unit tests, and we will
    add these checks throughout the chapter (and book) to help aid our reviews and
    protect the developer’s time. But for now, let us focus on the branch protection
    we just introduced. At this point, no one (other than an admin) will be able to
    commit directly to your main branch. Instead, they must submit a pull request
    for others to view. This means that any changes require approval from one other
    person as a way of tracking accountability throughout the product. If a bug is
    introduced, it is no longer a single individual’s mistake but that of the whole
    team since they didn’t catch it in a review.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该注意到，我们还在合并前选择了检查应该通过。我们已经在单元测试中设置了一些检查，并将把这些检查贯穿于整章（和整本书）中，以帮助我们的审查并保护开发者的时间。但就目前而言，让我们专注于我们刚刚引入的分支保护。在此阶段，除了管理员之外，没有人能够直接向你的主分支提交代码。相反，他们必须提交一个拉取请求供他人查看。这意味着任何更改都需要得到另一人的批准，作为在整个产品中跟踪责任的一种方式。如果引入了错误，它就不再是单个个人的错误，而是整个团队的责任，因为他们没有在审查中捕捉到它。
- en: Code reviews seem to be a slow and cumbersome process when you are just trying
    to get work done. But I can assure you that they are not. They provide an excellent
    way of teaching others and informing your team about what you are changing. Even
    while working alone on a project, I find myself creating pull requests for *myself*.
    This helps me review what has changed and can help me identify bugs and problems.
    This is like reviewing a paper you’ve written and finding mistakes and glaring
    problems that you missed in the initial draft. What makes for an effective review,
    and what do you look for?
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当你只是试图完成工作的时候，代码审查似乎是一个缓慢而繁琐的过程。但我可以向你保证，事实并非如此。它们提供了一种极好的方式来教导他人，并通知你的团队你正在进行的更改。即使是在独立进行项目工作时，我也会为自己创建拉取请求。这有助于我审查更改的内容，并帮助我识别错误和问题。这就像审查你写的论文，发现你在初稿中遗漏的错误和明显的问题。一个有效的审查应该包含哪些内容，你又在寻找什么？
- en: 5.1.1 Keep it small
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1.1 保持简洁
- en: Limit reviews to 300 lines of code (including test code). Why? Because we as
    humans have a short attention span. Even if you can read a novel all day or a
    technical journal on a lunch break, you may not be able to handle a large review.
    A review is more like reading a recipe than a book. Long, drawn-out, complex recipes
    are prone to failure because you may miss a step. Here, you may miss a line of
    code or a small bug. While this might be caught by some tools we’ll introduce
    later, it could still slip through. Having a smaller review lets us focus on the
    task, merge quickly, and merge often, as we talked about in chapter 1, using trunk-based
    development.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 将审查限制在300行代码（包括测试代码）以内。为什么？因为我们作为人类，注意力跨度有限。即使你整天都能读小说，或者在午餐休息时阅读技术期刊，你可能也无法处理大量的审查。审查更像是在阅读食谱，而不是一本书。长而复杂的食谱容易失败，因为你可能会错过一个步骤。在这里，你可能会错过一行代码或一个小错误。虽然我们稍后会介绍的一些工具可能会捕捉到这些，但它们仍然可能被忽略。较小的审查让我们能够专注于任务，快速合并，并且经常合并，正如我们在第1章中讨论的，使用基于主干的开发。
- en: Small reviews are not a hard-and-fast rule but something your team will have
    to learn to do. This first comes from understanding how to break tasks down into
    small chunks to allow your code reviews to be smaller. A 2,000-line change could
    be broken into 10 reviews of about 200\. While this may seem excessive, you will
    likely find that your team can focus more on the small changes and point out problems.
    Also, it may not be just one person doing the development at one time, as demonstrated
    in chapter 1 with the task breakdown between API and UI work.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 小型审查不是一成不变的规则，但这是你的团队必须学会做的事情。这首先来自于理解如何将任务分解成小块，以便你的代码审查可以更小。2000行的更改可以分解成大约200行的10次审查。虽然这看起来可能有些过度，但你可能会发现你的团队能够更多地关注这些小的变化，并指出问题。此外，正如第1章中展示的，可能不是只有一个人在同时进行开发，API和UI工作之间的任务分解也是如此。
- en: 5.1.2 Keep an open mind
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1.2 保持开放的心态
- en: Code reviews are a team-building exercise and should be treated as such. They
    are not personal attacks or challenges to you as a developer. Nor are they a way
    to embarrass other developers. They are opportunities for you to learn and teach.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 代码审查是一种团队建设练习，应该这样对待。它们不是对你作为开发者的个人攻击或挑战，也不是用来羞辱其他开发者的方式。它们是你学习和教授的机会。
- en: The author Stephen King says that the first step to becoming a good writer is
    to become an active reader. I believe that the same holds for developers. To become
    a better developer, you need to read more code. As a team, this allows more senior
    developers to show younger developers different techniques and ways to write code
    and solve problems. For younger developers, it becomes a way to show senior developers
    new techniques and solutions to problems. I personally love code reviews. I think
    it’s a fantastic way to build and work with a team.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 作者斯蒂芬·金说，成为一名优秀作家的第一步是成为一个积极的读者。我相信这一点同样适用于开发者。要成为一名更好的开发者，你需要阅读更多的代码。作为一个团队，这可以让资深开发者向年轻开发者展示不同的技术和编写代码、解决问题的方法。对于年轻开发者来说，这成为了一种向资深开发者展示新技术和问题解决方案的方式。我个人非常喜欢代码审查。我认为这是一种与团队建立和工作的绝佳方式。
- en: 'Treat code reviews as a philosophical discussion with friends rather than a
    political one. There are no hard-and-fast rules in development, but there are
    always areas in which to learn from others as in a philosophical discussion. Once
    it becomes personal, it becomes more difficult for others to learn, and often
    someone will start putting up their guard or being defensive and cease to learn
    instead of seeing the other side. To this day, I do not know how something as
    innocent as a code review can become such a sore spot for teams, but they often
    do. Here are some tips for how I think you can avoid this:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 将代码审查视为与朋友进行的哲学讨论，而不是政治讨论。在开发中，没有一成不变的规则，但总有可以从他人那里学习的地方，就像哲学讨论一样。一旦变得个人化，其他人学习就会变得更加困难，通常有人会开始竖起防御性的壁垒，不再学习而是看到另一面。时至今日，我仍然不知道像代码审查这样一件看似无辜的事情怎么会成为团队的一个痛点，但它们确实经常如此。以下是我认为你可以避免这种情况的一些技巧：
- en: Treat others as you want to be treated.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以你希望被对待的方式对待他人。
- en: Check your ego at the door.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在门口放下你的自尊。
- en: Don’t waste others’ time with bad code.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不要用糟糕的代码浪费他人的时间。
- en: Learn from feedback, and try not to repeat mistakes.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从反馈中学习，并尽量不再犯同样的错误。
- en: Take discussions offline instead of going back and forth in comments.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将讨论移至线下，而不是在评论中来回回复。
- en: Keep an open mind as to what others are doing.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对他人的行为保持开放的心态。
- en: Make sure it works.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保它能够正常工作。
- en: This list comes from experience with my past teams; 99% of the problems can
    be solved by communication, and the other 1% can be solved by process. Use code
    reviews as a way of connecting and building a team, not as a way of making yourself
    look better or others look bad.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这个列表来自我过去团队的经验；99%的问题可以通过沟通解决，其余的1%可以通过流程解决。将代码审查作为一种建立联系和团队建设的方式，而不是作为一种让自己看起来更好或让别人看起来更差的方式。
- en: 5.1.3 Keep it moving
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1.3 保持前进
- en: Reviews should be a priority because they are considered *work in progress*
    (WIP). As you’ve learned in earlier chapters, WIP is money stuck in the pipeline.
    Let’s do some math. If a developer makes $100,000 a year, every hour of development
    amounts to about $50 worth of work. As that code sits in a review state, we do
    not receive any money from that work. I’m sure you are thinking, “If I’m reviewing
    code, I’m not writing code, and that is wasted time and money.” If you spend time
    writing code while the code sits in the review, you increase the WIP and do not
    deliver the value. Soon a mass of reviews are in progress and nothing is completed.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 审查应该优先考虑，因为它们被视为*工作正在进行中*（WIP）。正如你在前面的章节中学到的，WIP是管道中停滞的资金。让我们来做一些数学计算。如果一个开发者每年赚10万美元，那么每小时的开发工作相当于大约50美元的价值。当代码处于审查状态时，我们不会从这项工作中获得任何收入。我敢肯定你正在想，“如果我正在审查代码，我就没有在写代码，这是浪费时间和金钱。”如果你在代码处于审查状态时花时间写代码，你会增加WIP，并且不会交付价值。很快，大量的审查都在进行中，但没有任何东西完成。
- en: It may also seem that switching tasks between writing code and reviewing code
    can be costly because you can forget where you are and what you were doing. The
    answer to this problem is learning to work reviews into your daily routine. Associate
    the task with something. When you find yourself with a fresh cup of coffee, do
    your reviews. I’d sit down every morning with my coffee, do my reviews, and then
    start my day. Once it was time for a second cup (or the ultimate conclusion of
    the beverage drinking occurred), I would do more reviews. We always find time
    for the things we want to do but rarely try to do things we don’t want to do.
    We grow frustrated that no one reviews our code, but we don’t take the time to
    review theirs.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 也可能看起来在编写代码和审查代码之间切换任务可能会很昂贵，因为你可能会忘记自己在哪里以及你在做什么。这个问题的答案是学会将审查融入你的日常工作中。将任务与某事联系起来。当你发现自己有一杯新鲜的咖啡时，就进行审查。我每天早上都会坐在咖啡旁，进行审查，然后开始新的一天。一旦到了喝第二杯咖啡的时间（或者饮料饮用的最终结论发生），我会进行更多的审查。我们总是有时间做我们想做的事情，但很少尝试做我们不想要做的事情。我们感到沮丧，因为没有人为我们的代码进行审查，但我们没有花时间去审查他们的代码。
- en: NOTE Build the time in and make sure others know that you are waiting on a review
    (politely).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：确保时间被安排在内，并确保其他人知道你正在等待审查（礼貌地）。
- en: Remind others that time stuck in review is time away from delivering to a customer.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 提醒其他人，停滞在审查中的时间是远离向客户交付的时间。
- en: 5.1.4 Keep it interesting
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1.4 保持有趣
- en: Code review after code review can become dull, so it is important to keep things
    interesting. Talk with your team to see how things can change and improve in your
    review process. Go through your review, and ask questions or make comments. This
    is a great way of getting feedback from others. Have challenges to see who can
    eliminate the most code through a refactor or who can find a new way to write
    a unit test.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 代码审查一次又一次可能会变得乏味，因此保持事物有趣是很重要的。与你的团队讨论如何改变和改进你的审查流程。进行你的审查，提出问题或发表评论。这是从他人那里获得反馈的好方法。设立挑战，看看谁能通过重构消除最多的代码，或者谁能找到编写单元测试的新方法。
- en: This seems dumb, but it helps with team morale. Like anything, it keeps people
    coming back for more. I once worked with a group that required a funny GIF as
    part of the pull request submission process, and reviewers not only needed to
    review the code but rate the GIF. Again, this helps build team morale, and while
    it seems like it is contrived or a waste of time, the cohesiveness of the team
    grows, and team members become more productive.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来很愚蠢，但它有助于团队士气。就像任何事物一样，它让人们对更多的事情保持兴趣。我曾经和一个团队一起工作，该团队要求在拉取请求提交过程中包含一个有趣的GIF作为部分要求，审查者不仅需要审查代码，还需要对GIF进行评分。再次强调，这有助于建立团队士气，虽然这看起来像是人为的或浪费时间，但团队的凝聚力增强，团队成员的生产力也提高了。
- en: 5.1.5 Keep it the same
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1.5 保持一致
- en: While experimenting is fun and keeps people engaged, it is also important to
    establish some standards. GitHub allows for *pull request templates*, which allow
    you to create a standard format for a pull request, including a checklist. The
    checklist is a great way to remind others of what they need to do before submitting
    the request. To do this, open your source code, create a new directory called
    `.github`, and add a file called `PULL_REQUEST_TEMPLATE.md`. The next listing
    shows an example template that can help with a pull request.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然实验很有趣，能让人保持参与，但建立一些标准也很重要。GitHub 允许使用 *pull request templates*，这允许你为拉取请求创建一个标准格式，包括检查清单。检查清单是提醒他人提交请求前需要做什么的好方法。为此，打开你的源代码，创建一个名为
    `.github` 的新目录，并添加一个名为 `PULL_REQUEST_TEMPLATE.md` 的文件。下一个列表显示了一个可以帮助拉取请求的示例模板。
- en: Listing 5.1 `PULL_REQUEST_TEMPLATE.md`
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.1 `PULL_REQUEST_TEMPLATE.md`
- en: '[PRE0]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, you have asked what was done and what sort of documentation you have for
    the work, as well as for a list of things that should be done before submitting.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你询问了已经做了什么，以及为这项工作提供的文档类型，以及提交前应该做的事情清单。
- en: When working as a team on the code review process, you should do regular check-ins
    about what is working and not working. In doing this, you can start to refine
    the process. There are still things you can do to automate the process and teach
    others. We’ll see how to make it so the human doesn’t have to bear all of the
    load of the review but work together with the machines to help guide and teach.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当作为团队在代码审查过程中工作时，你应该定期检查哪些工作得好，哪些工作得不好。通过这样做，你可以开始完善流程。你仍然可以做一些事情来自动化流程并教会他人。我们将看到如何让人类不必承担所有审查的负担，而是与机器一起协作，帮助指导和教学。
- en: 5.2 Constraints on development
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.2 开发约束
- en: 'There is an infamous scene from the famous show *I Love Lucy* where the main
    character Lucy and her friend Ethel work on an assembly line and it all goes wrong.
    Lucy and Ethel are working at a chocolate factory putting chocolates from the
    assembly line into wrappers. In the beginning, the two can keep pace with the
    flow of chocolates moving by them, but an unfortunate incident happens that causes
    them to fall behind. Panicking, the two go to comedic lengths to stem the flow
    of chocolates. To the public, this is an unfortunate and hilarious exposition
    of what can happen if workers fall behind on an assembly line. Industrial engineers
    watching this clip see only one thing: a constraint. A *constraint* is also known
    as a bottleneck. It is the location in an assembly line that determines the throughput
    of the factory.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在著名的电视剧《我爱露西》中有一个臭名昭著的场景，主角露西和她的朋友伊瑟尔在流水线上工作，结果出了差错。露西和伊瑟尔在一家巧克力工厂工作，将巧克力从流水线上放入包装纸中。一开始，两人还能跟上巧克力流动的速度，但不幸的是，发生了一个意外事件，导致她们落后了。慌乱中，两人想尽办法阻止巧克力的流动。对公众来说，这是不幸而又好笑的展示，说明了如果工人在流水线上落后会发生什么。观看这个片段的工业工程师只看到一件事：一个约束。*约束*也被称为瓶颈。它是流水线上决定工厂吞吐量的位置。
- en: In his novel *The Goal*, Eliyahu Goldratt outlines what is known as the “theory
    of constraints,” in which he states that optimizations in any system that are
    not constraints are pointless. In our *I Love Lucy* example, enhancing the speed
    at which the chocolates are made is pointless if Lucy and Ethel cannot wrap them
    in time. This is demonstrated in figure 5.2\. If A (Lucy) produces four items
    per minute and B (Ethel) can only process one item per minute, we will start overproducing
    items. Soon, excess inventory will begin to pile up, and the total throughput
    of our entire system will only equal one item per minute.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在他的小说《目标》中，艾利雅胡·高德拉特概述了所谓的“约束理论”，其中他声称，任何系统中不是约束的优化都是没有意义的。在我们的《我爱露西》例子中，如果露西和伊瑟尔不能及时包装，提高巧克力制作速度是没有意义的。这如图
    5.2 所示。如果 A（露西）每分钟生产四个物品，而 B（伊瑟尔）每分钟只能处理一个物品，我们就会开始过度生产物品。很快，过剩的库存就会开始堆积，我们整个系统的总吞吐量将只有每分钟一个物品。
- en: '![](../../OEBPS/Images/CH05_F02_Holmes4.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH05_F02_Holmes4.png)'
- en: Figure 5.2 Step B can only process one item from step A. Work will eventually
    build up in front of B, and any enhancements to A or C will not help with the
    throughput.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2 步骤 B 只能从步骤 A 处理一个物品。工作最终会在 B 前面堆积，对 A 或 C 的任何改进都不会有助于吞吐量。
- en: According to Goldratt, the focus of any company should be on trying to increase
    the throughput of the constraint and protecting its time from being wasted at
    that stage. This is known as *elevating the constraint*. There are several ways
    of elevating a constraint. In our *I Love Lucy* example, Lucy and Ethel may not
    have had a problem if additional workers helped them or if they had a machine
    that allowed them to wrap 10 times the number of chocolates. In another scenario,
    let’s imagine Lucy and Ethel could keep a decent pace and were able to wrap 100
    chocolates an hour, but 10% of them were defective for some reason. Their throughput
    would have gone down to 90 chocolates an hour. Once we’ve identified our constraint,
    we can find new ways of making it productive and protect it so that we have higher
    throughput.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 根据高德拉特（Goldratt）的观点，任何公司的重点都应该是尝试提高约束的吞吐量，并保护其时间不被浪费在那个阶段。这被称为*提高约束*。提高约束有几种方法。在我们的*我爱露西*（I
    Love Lucy）例子中，如果额外的工人帮助他们，或者如果他们有一个可以让他们包装十倍数量的巧克力的机器，露西和艾塞尔可能不会有问题。在另一个场景中，让我们想象露西和艾塞尔能够保持一个不错的速度，并且每小时能够包装100块巧克力，但其中10%由于某种原因有缺陷。他们的吞吐量将下降到每小时90块巧克力。一旦我们确定了我们的约束，我们就可以找到新的方法使其变得高效，并保护它，以便我们有更高的吞吐量。
- en: Software development also has constraints. Almost the entire process is automated
    by a computer, which means that the slowest part of our pipeline is the developer.
    The actual thinking and development of features should be what determines the
    throughput of our pipeline. Code generation and reviews take time and are not
    automated tasks; therefore, time should be protected. A simple solution could
    be to add more workers. Adding more team members could mean more people writing
    code, but it gets complicated. As a team grows, a larger number of communication
    lines are required to maintain relationships and collaborate. Typically, most
    companies follow the *two-pizza rule*, in which a team should have no more people
    than can be fed by two pizzas. Any larger and you start seeing diminishing returns
    on team productivity.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 软件开发也有约束。几乎整个流程都是由计算机自动化的，这意味着我们管道中最慢的部分是开发者。实际思考和开发功能应该是决定我们管道吞吐量的因素。代码生成和审查需要时间，并且不是自动化任务；因此，时间应该得到保护。一个简单的解决方案可能是增加更多工人。增加更多团队成员可能意味着更多的人编写代码，但这会变得复杂。随着团队的增长，需要更多的沟通线路来维持关系和协作。通常，大多数公司遵循*两个披萨规则*，即一个团队不应该有超过两个披萨可以喂的人数。如果人数更多，你开始看到团队生产力的递减回报。
- en: NOTE Fred Brooks famously said that adding more people to a project doesn’t
    speed up delivery time, just as “nine women cannot make a baby in one month.”
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：弗雷德·布鲁克斯（Fred Brooks）曾著名地表示，给一个项目增加更多的人手并不会加快交付时间，就像“九个女人一个月也生不出一个孩子”一样。
- en: If adding more people isn’t the solution, we need to make sure we protect their
    time. We can measure throughput for a company by measuring features and counting
    bugs as rework or work with defects. We can then focus on elevating our constraint
    by making it easy to develop code and catch bugs before they happen. This can
    be done by making our code easy to read, write, and fix and providing a mechanism
    for learning and teaching other developers about what we write. In this chapter,
    we check the quality of our code before we merge it and use this quality check
    as a way of learning and improving our system.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果增加人手不是解决方案，我们需要确保保护他们的时间。我们可以通过测量特性和计算缺陷作为返工或存在缺陷的工作来衡量一个公司的吞吐量。然后我们可以通过使代码易于开发、在发生之前捕捉到错误来提高我们的约束。这可以通过使我们的代码易于阅读、编写和修复，并提供一种机制来学习和教授其他开发者我们编写的内容来实现。在本章中，我们在合并代码之前检查代码的质量，并将这种质量检查作为学习和改进我们系统的一种方式。
- en: 5.3 Standardizing our code through format and lint checks
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.3 通过格式和lint检查标准化我们的代码
- en: It is common on assembly lines for the various stations to be standardized so
    that workers don’t have to waste energy or time trying to determine which pieces
    go where. If we look back at Lucy and Ethel, we could only imagine how far behind
    they could have gotten if they needed to determine which wrapper color went on
    various pieces of chocolate. Instead, all of the wrappers and chocolates were
    standardized to help with the flow so that Lucy and Ethel could wrap them as quickly
    as they could.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在装配线上，各个工作站通常都是标准化的，这样工人就不必浪费精力或时间去确定哪些部件该放在哪里。如果我们回顾露西和艾塞尔的情况，我们可以想象如果他们需要确定哪种包装颜色应该放在各种巧克力的不同部分，他们可能会落后得多。相反，所有的包装和巧克力都被标准化了，以帮助流动，这样露西和艾塞尔就可以尽可能快地包装它们。
- en: Standardization then becomes an important element in helping with the flow through
    our development pipeline. As we outlined in chapter 2, standardizing the way we
    set up our environments and workstations is important to the overall developer
    experience, but that standardization needs to be extended. If we consider wrappers
    and chocolates as part of the materials flowing through Lucy’s chocolate factory,
    we need to consider how we can standardize our materials through our pipeline.
    But how do you standardize code?
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 标准化随后成为帮助我们通过开发流程的重要元素。正如我们在第 2 章中概述的，标准化我们设置环境和工作站的方式对于整体开发者体验很重要，但这种标准化需要扩展。如果我们把包装和巧克力作为流经露西巧克力工厂的材料的一部分，我们需要考虑如何通过我们的管道标准化我们的材料。但如何标准化代码呢？
- en: NOTE It is important to distinguish here between industrial programming versus
    personal projects. *Industrial programming* means that others will be working
    with you on a product that others will consume. Here, standardization becomes
    important so that everyone is on the same page. *Personal projects* don’t need
    this level of rigor if you are just experimenting with something. If a personal
    project becomes an industrial product, it is always best to consider rewriting
    it with these principles in place.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在此处区分工业编程与个人项目很重要。*工业编程*意味着其他人将与你在某个产品上一起工作，该产品将被其他人消费。在这里，标准化变得很重要，以确保每个人都处于同一页面上。*个人项目*如果你只是对某事进行实验，则不需要这种程度的严谨性。如果个人项目成为工业产品，最好考虑使用这些原则重新编写它。
- en: Each piece of code written must serve some special or individual purpose; otherwise,
    it wouldn’t be written. You won’t have the same unique chunks of code delivered
    by each of your developers. What can be standardized is the way the code looks
    and feels, its documentation, established patterns for pieces of code, and tests.
    Standardization then becomes a process of coming up with a general code style
    and deciding how to enforce that style so that when others look at your code,
    it is indistinguishable from that of code written by another teammate. This is
    typically done through a *style guide*, wherein the group establishes a set of
    rules about the format of their code. In general, this can be as simple (or controversial)
    as using tabs versus spaces, keeping brackets on the same line or the next line,
    spaces between functions, and many more. This will vary between languages and
    teams.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 每一段代码的编写都必须服务于某种特殊或个人目的；否则，就不会被编写出来。你不会从每个开发者那里得到相同的独特代码块。可以标准化的是代码的外观和感觉、代码的文档、代码片段的既定模式以及测试。标准化随后变成了一个提出通用代码风格并决定如何执行这种风格的过程，以便当其他人查看你的代码时，它与其他团队成员编写的代码无法区分。这通常是通过一个*风格指南*来完成的，其中团队建立了一套关于其代码格式的规则。一般来说，这可以很简单（或具有争议性），比如使用制表符与空格、保持括号在同一行或下一行、函数之间的空格等。这将在不同的语言和团队之间有所不同。
- en: 'In addition to formatting rules, Go provides a guide for writing idiomatic
    Go code, which many linters will try to enforce. We will discuss linters later,
    but the following article also provides reasoning for the various format decisions
    that were made when writing the Go language: [https://golang.org/doc/effective_go](https://golang.org/doc/effective_go).'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 除了格式规则之外，Go 还提供了一份编写惯用 Go 代码的指南，许多代码检查器都会尝试强制执行。我们将在后面讨论代码检查器，但以下文章还提供了在编写 Go
    语言时做出各种格式决策的理由：[https://golang.org/doc/effective_go](https://golang.org/doc/effective_go)。
- en: Go, however, has its own style, so this becomes a nonproblem. The running joke
    is “Nobody likes Go format, everyone loves Go format,” meaning that there is most
    likely something that people don’t like about some aspect of the Go formatting
    tool, but everyone likes the fact that a standard formatter exists and no one
    needs to worry about it. It is simple to use and built in. Go to your project
    directory, and type
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Go 语言有其独特的风格，因此这并不是一个问题。流行的玩笑是“没有人喜欢 Go 格式，每个人都喜欢 Go 格式”，这意味着人们可能不喜欢 Go 格式化工具的一些方面，但每个人都喜欢存在一个标准格式化工具，而且没有人需要担心它。它使用简单且内置其中。进入你的项目目录，然后输入
- en: '[PRE1]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You may see something change, or you may not. Go will move brackets to the same
    line as the function declaration, replace spaces with tabs, consolidate spaces
    between functions, and so much more. The point is that, as a developer, you should
    worry about things other than the format of your code. Additional tools are out
    there for other languages, such as JavaScript’s `prettier` package and Python’s
    `autopep8`. But it is one thing to have formatting standards and another to enforce
    their usage.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会看到一些变化，也可能不会。Go 会将括号移动到与函数声明相同的行，用制表符替换空格，合并函数之间的空格，等等。重点是，作为一个开发者，你应该担心的事情不仅仅是你的代码格式。对于其他语言，如
    JavaScript 的 `prettier` 包和 Python 的 `autopep8`，还有其他工具。但是，有格式标准和使用它们是两回事。
- en: 'We need to do two things to help our developer: first, automate the process;
    second, enforce it. Let’s start on the second portion so that we can see it in
    action and then automate it.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做两件事来帮助我们的开发者：首先，自动化流程；其次，强制执行。让我们从第二部分开始，这样我们就可以看到它的实际效果，然后再进行自动化。
- en: To enforce these rules, we should have already set some limitations on the main
    branch. We will set our pipeline to enforce checks before the merge button is
    allowed to be pushed.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为了强制执行这些规则，我们已经在主分支上设置了一些限制。我们将设置我们的管道，在允许推送合并按钮之前强制执行检查。
- en: Currently, our CI system only runs on changes to the main branch, so we will
    need to update the `pipeline.yml` file to run on pull requests. Open that file,
    and add the code in the following listing.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的持续集成系统仅在主分支的更改上运行，因此我们需要更新 `pipeline.yml` 文件以在拉取请求上运行。打开该文件，并添加以下列表中的代码。
- en: Listing 5.2 `pipeline.yml`
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.2 `pipeline.yml`
- en: '[PRE2]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ Runs on pull requests to main
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在主分支的拉取请求上运行
- en: ❷ Only runs deployments on pushes to the main branch, not pull requests
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 只在主分支的推送操作上运行部署，不运行拉取请求
- en: Additionally, we want to add a new check to see if formatting occurred before
    merging, so we will add a step to our pipeline. We will add this command to our
    Makefile (see the following listing).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还想添加一个新检查，以查看合并前是否进行了格式化，因此我们将在我们的管道中添加一个步骤。我们将添加以下列表中的命令到我们的 Makefile
    中（见下）。
- en: Listing 5.3 Makefile
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.3 Makefile
- en: '[PRE3]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ This will check the results of running the format command to see if there
    were any changes. If so, it returns a failing value.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 这将检查运行格式化命令的结果，看是否有任何变化。如果有，它将返回一个失败值。
- en: Now we can update our pipeline to run this step, as in the following listing.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以更新我们的管道以运行此步骤，如下所示。
- en: Listing 5.4 `pipeline.yml`
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.4 `pipeline.yml`
- en: '[PRE4]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ Since formatting is less expensive than running tests, let’s save time by
    checking the format first.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 由于格式化比运行测试成本低，让我们先检查格式以节省时间。
- en: ❷ Calls our check format command from the Makefile to see the results
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 从 Makefile 中调用我们的检查格式化命令以查看结果
- en: 'Now create a branch called task/quality-check-enforcement-formatting, and commit
    your changes. Push the new branch, and create a pull request. Watch as the CI
    pipeline runs to make sure all of your changes work. Did it fail? If so, look
    into the failure. If it passes, feel free to try to make it fail by messing up
    the formatting and pushing again. Once everything is working, merge it. Congratulations!
    You have added a guard to your main branch. In fact, we’ve added two: formatting
    and testing now both need to pass in order to merge to main. This also relieves
    our team from needing to ask people to format. Next, we need to help our team
    by automatically finding bad code and security flaws that can’t be found by linting
    but by another tool called static code analysis.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在创建一个名为 task/quality-check-enforcement-formatting 的分支，并提交你的更改。推送新分支，并创建一个拉取请求。观察
    CI 管道运行以确保所有更改都正常工作。它失败了？如果是这样，调查失败原因。如果它通过了，你可以自由地尝试通过破坏格式化并再次推送来让它失败。一旦一切正常，就合并它。恭喜！你已经为主分支添加了一个保护措施。实际上，我们已经添加了两个：格式化和测试现在都需要通过才能合并到主分支。这也减轻了我们的团队需要要求人们格式化的负担。接下来，我们需要通过自动查找无法通过
    linting 检测到的坏代码和安全漏洞来帮助我们的团队。
- en: 5.4 Static code analysis
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.4 静态代码分析
- en: Software is used to automate a formerly manual task. While humans are essential
    to reviews, they can make mistakes. Luckily, many bad coding practices and anti-patterns
    can be automatically recognized by software called *static code analysis* tools.
    These tools comb through your code looking for known patterns that are often related
    to bugs or security vulnerabilities. Some can be used to enforce good programming
    practices like documentation and spelling. Adding static code analysis tools to
    your pipeline can help reduce bugs and protect reviewers from wasting their time
    on “bad code.”
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 软件用于自动化以前的手动任务。虽然人类对审查至关重要，但他们可能会犯错误。幸运的是，许多不良编码实践和反模式可以通过称为 *静态代码分析* 工具的软件自动识别。这些工具会遍历你的代码，寻找与错误或安全漏洞相关的已知模式。一些工具可以用来强制执行良好的编程实践，如文档和拼写。将静态代码分析工具添加到你的管道中可以帮助减少错误并保护审查者免于在“坏代码”上浪费时间。
- en: To do this, we will use two tools. One is a tool built into Go, and the other
    is a community-supported tool that provides an extensive array of libraries to
    support additional checks. Let’s first start with Go’s internal command `go` `vet`,
    which is great for providing fast results about bugs in your code. Let’s run it
    now to see if there are any problems. To do this, type
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们将使用两个工具。一个是 Go 内置的工具，另一个是社区支持的提供广泛库的工具，这些库支持额外的检查。让我们首先从 Go 的内部命令 `go
    vet` 开始，这是一个提供有关代码中错误快速结果的绝佳工具。现在让我们运行它，看看是否有任何问题。为此，请输入
- en: '[PRE5]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The three dots, like in testing, tell the program to run the vet tool across
    all packages. Hopefully, you should see nothing as part of the results. Open `cmd/main.go`,
    and change one line (see the following code listing).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 与测试中一样，三个点表示程序运行 vet 工具跨所有包。希望你在结果中看不到任何东西。打开 `cmd/main.go`，更改一行（见以下代码列表）。
- en: Listing 5.5 `main.go`
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.5 `main.go`
- en: '[PRE6]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ Adding an extra variable can cause this line to fail.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 添加一个额外的变量可能导致这一行失败。
- en: Now run the `go vet` command, and you should see an error. The vet tool checks
    your source code and finds that you have a format command that has more variables
    than expected. This is great because it will catch a potential bug. We should
    add this to our pipeline so that we can do the checks. Once again, running this
    is much faster than running tests (or will be in the future), so we should add
    it before we test, but we can also run it after format checking. Let’s update
    our pipeline to run these checks using the code in the following listing.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行 `go vet` 命令，你应该会看到一个错误。vet 工具检查你的源代码，发现你有一个格式化命令，其变量多于预期。这很好，因为它将捕获一个潜在的错误。我们应该将此添加到我们的管道中，以便我们可以进行这些检查。再次强调，运行这个命令比运行测试（或将来会是这样）要快得多，因此我们应该在测试之前运行它，但我们也可以在格式化检查之后运行它。让我们更新我们的管道，使用以下列表中的代码运行这些检查。
- en: Listing 5.6 `pipeline.yml`
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.6 `pipeline.yml`
- en: '[PRE7]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ Runs built-in Go tool for checking code
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 运行内置的 Go 工具检查代码
- en: This will now run before we run our tests and after we check the formatting.
    This is great because it gives us a pipeline through which we can test the code
    quality and give specific feedback to our developers if something fails. We can
    think of this as various sieves through which we filter stones. Bigger holes allow
    larger rocks through, but as we progressively decrease the size, the smaller the
    stones become and the more easily you can see the individual stones. In the end,
    you are left with the different sizes of stones that you want.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在我们运行测试之前和检查格式化之后执行。这很好，因为它为我们提供了一个可以通过它来测试代码质量和在出现问题时向开发者提供具体反馈的管道。我们可以将其视为各种筛子，通过这些筛子我们筛选石头。较大的孔允许较大的石头通过，但随着我们逐渐减小孔径，石头变得越小，你越容易看到单个石头。最后，你将留下你想要的石头不同大小。
- en: In the same way, our code will move through, providing us with easy-to-digest
    errors and improvements to make until we are left with a product that is ready
    to review. The pipeline approach works well for targeting and pointing out the
    various problems but can also result in longer lead time. *Lead time* refers to
    the time between the start and stop of a process from the moment an issue or feature
    is raised and gets delivered to the customer. The time between each of these steps
    is known as *cycle time*. If a cycle time is a subset of the overall lead time,
    we can focus on optimizing our cycle times to reduce the overall lead time to
    our customer. In figure 5.3, you can see that the overall lead time between a
    customer’s request to delivery should be reduced to meet their needs. To do that,
    we can consider reducing the cycle times of each step in our pipeline.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 以同样的方式，我们的代码将通过，为我们提供易于消化的错误和改进，直到我们只剩下一个准备审查的产品。管道方法在针对和指出各种问题方面效果良好，但也可能导致更长的领先时间。*领先时间*指的是从问题或功能提出到交付给客户的过程中，从开始到停止的过程时间。这些步骤之间的时间被称为*周期时间*。如果一个周期时间是总领先时间的子集，我们可以专注于优化我们的周期时间，以减少对客户的总领先时间。在图5.3中，您可以看到客户请求到交付之间的总领先时间应该减少以满足他们的需求。为了做到这一点，我们可以考虑减少管道中每个步骤的周期时间。
- en: '![](../../OEBPS/Images/CH05_F03_Holmes4.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图5.3 Holmes4](../../OEBPS/Images/CH05_F03_Holmes4.png)'
- en: Figure 5.3 Overall lead time is the time from the creation of the task to its
    delivery to a customer.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3 总的领先时间是任务创建到交付给客户的时间。
- en: We can imagine that our pipeline could run multiple stages at the same time,
    such as linting, vetting, and testing. This becomes computationally expensive
    because you are running machines or processes in parallel, but you get your results
    faster and can see all problems that have occurred. This is another spot in which
    your team will need to determine how you want to run your pipeline. In this example,
    we will run a hybrid of parallel and sequential steps in our pipeline.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以想象我们的管道可以同时运行多个阶段，例如代码检查、审查和测试。这会变得计算成本高昂，因为您正在并行运行机器或进程，但您可以得到更快的结果，并可以看到所有发生的问题。这是您的团队需要确定如何运行管道的另一个地方。在这个例子中，我们将在管道中运行并行和顺序步骤的混合。
- en: NOTE GolangCI Lint is an aggregate linting tool that allows developers to select
    from a myriad of linters.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：GolangCI Lint 是一个聚合代码检查工具，允许开发者从众多代码检查器中选择。
- en: '`go` `vet` is a great starting place for statically checking our code, but
    it doesn’t need to stop there. A tool called `golangci-lint` can be installed
    on your machine and used as a pipeline step. GolangCI-Lint allows you to select
    from numerous linting and static-checking libraries to help extend your quality
    assessments. The full list is available on the libraries page, but we will use
    a few here to get started. By default, it will run several checks that will look
    for unused code, ineffective variable assignments, missing error checks, and much
    more. In addition, we will add a check for security. To do this, we need to create
    a new file called `.golangci.yml`. Create it in the root directory, and add the
    code in the following listing.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`go` `vet` 是静态检查我们代码的一个很好的起点，但并不需要就此停止。可以在您的机器上安装一个名为 `golangci-lint` 的工具，并将其用作管道步骤。GolangCI-Lint
    允许您从众多的代码检查和静态检查库中选择，以帮助扩展您的质量评估。完整的列表可在库页面找到，但我们将在这里使用几个以开始。默认情况下，它将运行几个检查，以查找未使用的代码、无效的变量赋值、缺失的错误检查等等。此外，我们还将添加一个安全检查。为此，我们需要创建一个名为
    `.golangci.yml` 的新文件。在根目录中创建它，并添加以下列表中的代码。'
- en: Listing 5.7 `golangci.yml`
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.7 `golangci.yml`
- en: '[PRE8]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ Adds linter to the file
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将代码检查器添加到文件中
- en: ❷ Customizes the output format of the linter
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 自定义代码检查器的输出格式
- en: The linter we are using will automatically look for this configuration file
    when it runs within this project.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所使用的代码检查器在运行本项目时会自动查找此配置文件。
- en: Code security is an often overlooked step in static code analysis, but a crucial
    one. Security checks can allow for things such as which randomization libraries
    and functions to use as well as what kind of hashing you may need. Your code may
    not use these things, but one day you may find (if you have your linter on) that
    you need to. Now that we have a broad understanding of what this tool can do,
    let’s add it to our pipeline (see the following code listing).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 代码安全性是静态代码分析中经常被忽视的一步，但却是关键的一步。安全检查可以允许你选择使用哪些随机化库和函数，以及你可能需要的哈希类型。你的代码可能不会使用这些功能，但有一天你可能会发现（如果你启用了你的代码检查器），你可能需要它们。现在我们已经广泛了解了这个工具能做什么，让我们将其添加到我们的管道中（见下面的代码列表）。
- en: Listing 5.8 `pipeline.yml`
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.8 `pipeline.yml`
- en: '[PRE9]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ❶ Adds a lint check as a dependency
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 添加一个代码检查作为依赖项
- en: ❷ Adds a lint action to pipeline
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将代码检查添加到管道中
- en: Create a branch called task/add-static-check, commit your code, and create a
    pull request. What do you see? It should error! Why? Well, it looks like we are
    missing an error check on a function. If we had only seen this earlier, we could
    have saved ourselves some time. Let’s remedy this by adding the installation and
    static check to our Makefile using the code in the following listing.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 task/add-static-check 的分支，提交你的代码，并创建一个拉取请求。你看到了什么？它应该出错！为什么？好吧，看起来我们在一个函数上缺少错误检查。如果我们早点看到这个，我们就可以节省一些时间。让我们通过添加以下列表中的代码到我们的
    Makefile 中来解决这个问题。
- en: Listing 5.9 `pipeline.yml`
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.9 `pipeline.yml`
- en: '[PRE10]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ❶ Grabs the content from the linter locally
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 从本地获取代码检查器的内容
- en: Great, now we can run `make lint` locally and get the same errors. Fix the line
    by adding the code in the following listing.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了，现在我们可以在本地运行 `make lint` 并得到相同的错误。通过添加以下列表中的代码来修复这一行。
- en: Listing 5.10 Makefile
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.10 Makefile
- en: '[PRE11]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ❶ This needs to capture the error message even though we are not using it.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 即使我们现在没有使用它，这也需要捕获错误信息。
- en: Commit your changes and push. Now everything should be green, and you can merge.
    This simple step will save you from several bugs and problems along the way. Situations
    like missing error checks can hide underlying problems that occurred while the
    system is running. Ineffective assignments are another common problem, wherein
    a variable is set but never used, which could lead to a bug. These tools add mild
    overhead but save you in the long run. Take the time as a team to evaluate and
    use them as you see fit, and let them evolve with your team.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 提交你的更改并推送。现在一切应该都是绿色的，你可以合并。这个简单的步骤将帮助你避免在开发过程中遇到几个错误和问题。像缺少错误检查这样的情况可能会隐藏在系统运行期间发生的潜在问题。无效的赋值是另一个常见问题，其中变量被设置但从未使用，这可能导致错误。这些工具会增加轻微的开销，但长远来看会节省你时间。作为团队，花时间评估并按需使用它们，并让它们随着团队的发展而发展。
- en: 5.5 Code documentation
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.5 代码文档
- en: Writing code should be like telling a story. You start with an idea and then
    define the structure. Most developers will not start writing code by first writing
    comments. They will most likely write a function just once and hopefully never
    need to come back to it. More frequently, someone will need to use the function
    or package for some reason or another, and it is the developer’s job to tell the
    story of what the function does so that others don’t need to dive into the code
    to figure it out. This comes down to making sure the title of the story is clear
    and the description is sound.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 编写代码应该像讲故事一样。你从一个想法开始，然后定义结构。大多数开发者不会先写注释就开始编写代码。他们很可能会只写一个函数一次，并希望永远不需要回到它。更常见的情况是，有人可能因为某种原因需要使用这个函数或包，开发者的工作是讲述这个函数的功能故事，这样其他人就不需要深入研究代码来弄清楚它。这归结于确保故事标题清晰，描述准确。
- en: Because this is my first venture into writing, I can say that writing can be
    difficult. But I have found coming up with what to write on a function comment
    much more challenging. You need to first come up with a good name for the function
    that is helpful to people. This needs to be something that makes sense, like `Translate`
    `and TranslateFile` instead of `T` `and` `TFile`. Alternatively, you don’t need
    to tell a story with a name like `TranslatesFileWithCaseInsensitiveAndUnixBasedHomeDir`.
    Instead, you would put in the comments how someone should expect the function
    to work. We’ve avoided package-level and function-level comments until now.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这是我第一次尝试写作，我可以说我发现为函数注释想出内容更具挑战性。你需要首先想出一个对人们有帮助的好名字的函数。这需要是某种有意义的名字，比如 `Translate`
    和 `TranslateFile` 而不是 `T` 和 `TFile`。或者，你不需要用像 `TranslatesFileWithCaseInsensitiveAndUnixBasedHomeDir`
    这样的名字讲故事。相反，你会在注释中说明人们应该如何期望函数的工作方式。我们一直避免编写包级和函数级注释。
- en: Go has built into it the capabilities of hosting a documentation server, wherein
    the library will parse your source code looking for comments above package declarations
    and above functions to create documentation. However, anything in the include
    directory will be skipped because it cannot be used in a dependency.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Go 内置了托管文档服务器的功能，其中库会解析你的源代码，寻找位于包声明和函数之上的注释以创建文档。然而，包含目录中的任何内容都会被跳过，因为它不能用于依赖项。
- en: Since we don’t have the documentation, we should remedy that. However, we also
    want to make sure that after we go through this exercise, no one follows us by
    not commenting on their code. This is known as a *scout philosophy*, in which
    you “leave it better than you found it.” To do this, let’s add a new *static code
    analysis* tool to check the comments. We will use a checker that requires comments
    on all exported functions and packages. Additionally, we will add a spell-check
    and ensure that all comments end in a period. Open `.golangci-lint.yml`, and add
    the code in the following listing.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们没有文档，我们应该解决这个问题。然而，我们还想确保在完成这个练习后，没有人会像我们一样不注释他们的代码。这被称为 *侦察哲学*，即你“让它比找到它时更好。”为了做到这一点，让我们添加一个新的
    *静态代码分析* 工具来检查注释。我们将使用一个要求所有导出函数和包都有注释的检查器。此外，我们将添加拼写检查并确保所有注释都以句号结束。打开 `.golangci-lint.yml`，并添加以下列表中的代码。
- en: Listing 5.11 `\golangci-lint.yml`
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.11 `\golangci-lint.yml`
- en: '[PRE12]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ❶ Adds linters to check comments and style
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 添加代码检查器以检查注释和风格
- en: ❷ Settings for linter where we want to capture stylistic problems
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在我们想要捕获风格问题的代码检查器设置
- en: ❸ Some of these lint errors are hidden by GolangCI-Lint, so we want to disable
    that.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 一些这些代码检查错误被 GolangCI-Lint 隐藏了，所以我们要禁用这个功能。
- en: Style checks will ensure that our comments are required and that we follow some
    other standards for comment writing. `godot` and `misspell` will make sure that
    our strings and comments are well punctuated and spelled correctly. Once you’ve
    added this file, run `make static-check` and see the results. Fix the code by
    adding comments that you feel are appropriate. Push your changes and merge. Remember,
    comments should explain what the function does, not how it does it. For example,
    the function `Translate` would have a comment such as “Translate will take a given
    word and language and will return the translation if available; otherwise, it
    will return an empty string.”
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 风格检查将确保我们的注释是必需的，并且我们遵循一些其他注释写作标准。`godot` 和 `misspell` 将确保我们的字符串和注释标点正确且拼写无误。一旦添加了此文件，运行
    `make static-check` 并查看结果。通过添加你认为合适的注释来修复代码。推送你的更改并合并。记住，注释应该解释函数做什么，而不是它是如何做的。例如，`Translate`
    函数的注释可以是：“`Translate` 函数将接受一个单词和语言，如果可用则返回翻译；否则，它将返回一个空字符串。”
- en: 5.6 Git hooks
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.6 Git 钩子
- en: We’ve protected our main branch, added quality checks, and then added various
    requirements on the main branch. We now need to focus on localizing the changes
    to our development environment. As a general rule, it is important to localize
    changes to your pipeline so that your developers can easily reproduce them locally.
    If you find that verifying changes locally becomes a problem, you should consider
    changing your pipeline. Localized functions allow developers to ensure their code
    should work before pushing it to a pull request. Imagine trying to guess if your
    code will pass before creating a pull request. This would create delays and problems
    along the way. For the most part, we have already automated a lot of the functions
    our pipeline has done, but we failed to ensure that developers are using them
    locally.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经保护了主分支，增加了质量检查，然后在主分支上添加了各种要求。现在我们需要专注于本地化我们的开发环境中的更改。一般来说，本地化您的管道中的更改非常重要，这样您的开发者就可以轻松地在本地重现它们。如果您发现验证本地更改成为问题，您应该考虑更改您的管道。本地化函数允许开发者在将代码推送到拉取请求之前确保其代码能够正常工作。想象一下在创建拉取请求之前尝试猜测您的代码是否会通过。这会在过程中造成延误和问题。就大部分而言，我们已经自动化了我们管道所做的大部分功能，但我们未能确保开发者在本地使用它们。
- en: The policy will only get you so far. Often a developer will write some code
    in earnest, push it, create a pull request, and move on only to find in a few
    hours that the pull request failed for one reason or another. Similarly, when
    seeing a new pull request, developers will flock to review and approve it only
    to find that there are errors that prevent it from being merged. This wastes time
    for the developer, reviewer, and the CI pipeline. Moving these checks as close
    as possible to the source will help move the process along.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 政策只能带你走这么远。通常，开发者会认真编写一些代码，推送它，创建一个拉取请求，然后继续前进，几个小时后发现拉取请求因为这样或那样的原因失败了。同样，当看到一个新的拉取请求时，开发者会蜂拥而至进行审查和批准，却发现有错误阻止它合并。这浪费了开发者、审阅者和CI管道的时间。尽可能地将这些检查移到源代码附近将有助于推进这个过程。
- en: Git has a beautiful feature called *hooks* that ties into various functions
    supported by Git. A hook will run when a specific function is executed, either
    before or after. In our case, we want to create a *pre-commit hook* that will
    run before we commit our changes. This hook will verify that our code is properly
    formatted and that the static code analysis runs as expected. We need to ensure
    that these functions are installed for everyone, and they therefore should be
    part of our setup. First, we must create the script, which is just a simple shell
    script. Create a file called `scripts/hooks/pre-commit`, and add the code in the
    following listing.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Git有一个美丽的特性叫做 *hooks*，它可以与Git支持的各种功能相结合。当执行特定功能时，hook会运行，要么在之前，要么在之后。在我们的情况下，我们想要创建一个
    *pre-commit hook*，它将在我们提交更改之前运行。这个hook将验证我们的代码是否格式正确，以及静态代码分析是否按预期运行。我们需要确保这些功能对每个人都是可用的，因此它们应该成为我们设置的一部分。首先，我们必须创建脚本，它只是一个简单的shell脚本。创建一个名为
    `scripts/hooks/pre-commit` 的文件，并添加以下列表中的代码。
- en: Listing 5.12 `pre-commit`
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.12 `pre-commit`
- en: '[PRE13]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ❶ Grabs all Go files
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 获取所有Go文件
- en: ❷ If there aren’t any, print the message.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 如果没有，打印消息。
- en: ❸ Runs format on all files and adds the file to the commit
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 对所有文件运行格式化并将文件添加到提交中
- en: ❹ Runs lint check
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 运行lint检查
- en: Now we will create a script that adds this to our `.git/hooks` directory as
    part of initialization (see the following listing). Once there, it will run before
    any branch push, so be aware of error messages!
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将创建一个脚本，将其作为初始化的一部分添加到我们的 `.git/hooks` 目录中（见以下列表）。一旦在那里，它将在任何分支推送之前运行，所以请注意错误信息！
- en: Listing 5.13 Makefile
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.13 Makefile
- en: '[PRE14]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: ❶ Creates a script and copies files
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建脚本并复制文件
- en: Problems should now be caught in a local environment as a team tries to use
    these hooks to ensure that basic tasks are being completed, but be aware of the
    time cost of these functions. Notice that we did not add the test stage to the
    pre-push. This is because tests take a longer time to run as opposed to static
    checks. Try to find a happy medium. Make sure things don’t take too long and interrupt
    the development flow. You and your team may find that these hooks are more obtrusive
    than helpful, in which case you should discuss their usage and function with your
    team.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应该在本地环境中捕捉到问题，因为团队试图使用这些钩子来确保基本任务正在完成，但要注意这些函数的时间成本。请注意，我们没有将测试阶段添加到预推送中。这是因为测试的运行时间比静态检查要长。尽量找到一个合适的平衡点。确保事情不会花费太多时间并打断开发流程。你和你的团队可能会发现这些钩子比有帮助还要侵扰，在这种情况下，你应该与你的团队讨论它们的用法和功能。
- en: 5.7 Flow
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.7 流动
- en: A psychologist named Mihaly Csikszentmihalyi studied the way people work and
    how it relates to happiness and creativity. He believed that people enjoy what
    they do if they can establish a sense of *flow* or state of concentration and
    absorption in the task at hand. This is also known as “being in the zone.” If
    you play sports or an instrument, I’m sure you’ve found yourself in a state of
    flow. You can see the next play, anticipate the next note, or become absorbed
    in what you are doing at the moment.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 心理学家Mihaly Csikszentmihalyi研究了人们的工作方式以及它与幸福和创造力的关系。他相信，如果人们能够建立一种*流动感*或对当前任务的专注和沉浸感，他们会享受他们所做的事情。这也被称为“进入状态”。如果你玩运动或乐器，我敢肯定你曾经进入过一种流动状态。你可以看到下一个动作，预测下一个音符，或者沉浸在你正在做的事情中。
- en: 'Csikszentmihalyi discovered that this pattern can be reflected in work as well,
    as long as it engages the worker in some way. Developers find this flow when writing
    code. Some of the most innovative and efficient code can come from an engaged
    development team. What can cause problems, though, is the interruption of flow,
    such as by these:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: Csikszentmihalyi 发现这种模式也可以在工作上反映出来，只要它能以某种方式吸引工人。开发者会在编写代码时找到这种流动。一些最具创新性和效率的代码可以来自一个投入的开发团队。然而，可能会引起问题的，是流动的中断，例如：
- en: Meeting overload
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 会议超载
- en: Broken builds and tests
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 破坏构建和测试
- en: Local development problems
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地开发问题
- en: Heisenbugs, bugs that are inconsistently reproducible
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 海森堡虫，不一致可复现的虫子
- en: Coworkers popping in to talk or ask a question
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同事突然进来交谈或提问
- en: Why does this matter? Because the flow of your team members is important. Making
    things easier will help to create a better flow for them. What we want to focus
    on is the flow that goes from an idea to implementation. The fewer disruptions
    we have at this stage, the better. This flow comes from the person doing the work,
    and anything that interrupts the flow interrupts their ability to be successful.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这为什么重要？因为团队成员的流动很重要。使事情变得更容易将有助于为他们创造更好的流动。我们想要关注的是从想法到实施的过程。在这个阶段，我们遇到的干扰越少，越好。这种流动来自做这项工作的人，任何打断流动的事情都会打断他们成功的能力。
- en: On the other hand, loose quality enforcement can lead to interruptions in the
    form of bugs and errors. There is no formula for what works best with teams. If
    you are a team of senior-level developers, you may require fewer guardrails. If
    you are a team of less experienced developers, you may find you need more. The
    key here is to communicate. Talk to each other regularly. Refine and enhance.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，宽松的质量控制可能导致中断，形式为错误和错误。没有适用于团队的最佳方案的公式。如果你是一个高级开发者的团队，你可能需要较少的约束。如果你是一个经验较少的开发者团队，你可能发现你需要更多。这里的关键是沟通。经常互相交谈。改进和增强。
- en: 'Overall, this chapter has been about helping your team work together. I realize
    that this is a challenging and unique area, as every team will be different, so
    you will notice that I have repeated a similar line time and again: do what works
    best for your team. We have built a pipeline, and we are adding to it. With each
    addition comes more complexity, but this complexity can often help teams as they
    grow and evolve. Most of these steps and protections will help your team in the
    long run. It may be by catching bugs or errors, but in some cases, it will keep
    people on their toes.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，这一章是关于帮助你的团队一起工作。我意识到这是一个具有挑战性和独特性的领域，因为每个团队都会有所不同，所以你会注意到我一次又一次地重复了类似的句子：做对你团队最有利的事情。我们已经建立了一个管道，并且正在对其进行扩展。每次增加都会带来更多的复杂性，但这种复杂性往往可以帮助团队随着成长和演变。这些步骤和大多数保护措施都将有助于你的团队长期发展。这可能是通过捕捉错误或错误，但在某些情况下，它将使人们保持警惕。
- en: Parents often use timers as a way of communicating that it is time to leave
    rather than telling their kids it’s time to go. This helps because the parent
    and the child have agreed that the timer is the thing that determines when it
    is time to go and not a seemingly arbitrary announcement from the parent. The
    timer is the communication tool. In the same way, team members will respond better
    to a program telling them to comment on their code rather than a team member because
    both have agreed on a single tool to keep them in check.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 父母通常使用计时器作为一种沟通方式，表明是时候离开了，而不是告诉孩子们该走了。这样做的好处是，父母和孩子已经同意，计时器是决定何时离开的东西，而不是父母看似随意的宣布。计时器是沟通工具。同样，团队成员会更乐意响应一个程序告诉他们评论代码，而不是团队成员，因为双方都同意使用一个单一的工具来约束他们。
- en: “Hey, do you have a minute?” Startled, you look up and see your project manager
    with someone you’ve never met before. “I want to introduce you to Yvonne, an intern
    who is going to help you meet the demo on Friday. She doesn’t have a bunch of
    experience, but I’m sure you can help her get up to speed fairly quickly.” Any
    help is welcome, especially now that you’ve standardized your work.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: “嘿，你有几分钟时间吗？”你惊讶地抬起头，看到你的项目经理和一个你从未见过的人。他说：“我想介绍你认识一下Yvonne，她是一名实习生，将帮助你满足周五的演示。她没有很多经验，但我相信你能够很快帮助她熟悉工作。”任何帮助都是受欢迎的，尤其是在你已经标准化了你的工作之后。
- en: Summary
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Code quality checks can reduce bugs and standardize work.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码质量检查可以减少错误并标准化工作。
- en: Formatting can standardize a workspace and make it easier for newcomers to onboard.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 格式化可以标准化工作空间，并使新成员更容易融入。
- en: Static code analysis will check your code for known anti-patterns and ask you
    to fix them.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态代码分析将检查你的代码中已知的不良模式，并要求你修复它们。
- en: Moving quality checks to the front of the pipeline can reduce wait time and
    catch bugs before deployment.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将质量检查移至管道前端可以减少等待时间，并在部署前捕获错误。
- en: Constantly review and improve your development process to ensure the flow of
    the developer’s work.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不断审查和改进你的开发流程，以确保开发者的工作流程顺畅。
