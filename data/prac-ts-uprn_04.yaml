- en: Chapter 4\. Simulating Time Series Data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章 模拟时间序列数据
- en: Up to this point, we have discussed where to find time series data and how to
    process it. Now we will look at how to create times series data via simulation.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了在哪里找到时间序列数据以及如何处理它。现在我们将看看如何通过模拟创建时间序列数据。
- en: Our discussion proceeds in three parts. First, we compare simulations of time
    series data to other kinds of data simulations, noting what new areas of particular
    concern emerge when we have to account for time passing. Second, we look at a
    few code-based simulations. Third, we discuss some general trends in the simulation
    of time series.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的讨论分为三部分。首先，我们将时间序列数据的模拟与其他类型的数据模拟进行比较，注意在考虑时间流逝时会出现哪些新的特别关注的领域。其次，我们看一些基于代码的模拟。第三，我们讨论时间序列模拟中的一些一般趋势。
- en: 'The bulk of this chapter will focus on specific code examples for generating
    various kinds of time series data. We will run through the following examples:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的大部分内容将集中在生成各种类型时间序列数据的具体代码示例上。我们将逐个讨论以下示例：
- en: We simulate email opening and donation behavior of members of a nonprofit organization
    over the course of several years. This is related to the data we examined in [“Retrofitting
    a Time Series Data Collection from a Collection of Tables”](ch02.html#retrofitting-sect).
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们模拟非营利组织成员多年来的电子邮件打开和捐赠行为。这与我们在["从表格集合中重塑时间序列数据收集"](ch02.html#retrofitting-sect)章节中检验的数据相关。
- en: We simulate events in a taxicab fleet of 1,000 vehicles with various shift start
    times and hour-of-the-day-dependent passenger pickup frequencies over the course
    of a single day.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在一天之内模拟了1,000辆出租车的事件，这些出租车有不同的班次开始时间和与一天中小时相关的乘客接载频率。
- en: We simulate step-by-step state evolution of a magnetic solid for a given temperature
    and size using relevant laws of physics.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用相关物理定律，模拟给定温度和尺寸的磁性固体的逐步状态演变。
- en: 'These three code examples correlate to three classes of time series simulations:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个代码示例对应于三类时间序列模拟：
- en: Heuristic simulations
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 启发式模拟
- en: We decide how the world should work, ensure it makes sense, and code it up,
    one rule at a time.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们决定世界应该如何运作，确保它合理，然后一条规则一条规则地编写代码。
- en: Discrete event simulations
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 离散事件模拟
- en: We build individual actors with certain rules in our universe and then run those
    actors to see how the universe evolves over time.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在我们的宇宙中构建具有特定规则的个体行为者，然后运行这些行为者，看看宇宙随时间的演变。
- en: Physics-based simulations
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 基于物理的模拟
- en: We apply physical laws to see how a system evolves over time.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用物理定律来观察系统如何随时间演变。
- en: Simulating time series can be a valuable analytical exercise and one we will
    also demonstrate in later chapters as it relates to specific models.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟时间序列可以是一个有价值的分析练习，我们将在后续章节中演示，因为它涉及到具体的模型。
- en: What’s Special About Simulating Time Series?
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟时间序列的特别之处在于什么？
- en: 'Simulating data is an area of data science that is rarely taught, but which
    is a particularly useful skill for time series data. This follows from one of
    the downsides of having temporal data: no two data points in the same time series
    are exactly comparable since they happen at different times. If we want to think
    about *what could have happened at a given time*, we move into the world of simulation.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟数据是数据科学中很少被教授的一个领域，但对于时间序列数据却是一项特别有用的技能。这是因为时间数据的一个缺点是：同一时间序列中的两个数据点是不能完全比较的，因为它们发生在不同的时间。如果我们想考虑在特定时间发生了什么，我们就进入了模拟的世界。
- en: 'Simulations can be simple or complex. On the simpler side, you will encounter
    synthetic data in any statistics textbook on time series, such as in the form
    of a random walk. These are usually generated as cumulative sums of a random process
    (such as R’s `rnorm`) or by a periodic function (such as a sine curve). On the
    more complex side, many scientists and engineers make their careers out of simulating
    time series. Time series simulations remain an active area of research—and a computationally
    demanding one—in many fields, including:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟可以简单也可以复杂。在简单的一面，你会在任何关于时间序列的统计学教科书中遇到合成数据，比如随机漫步形式。这些通常通过随机过程的累积总和（如R的`rnorm`）或周期函数（如正弦曲线）生成。在更复杂的一面，许多科学家和工程师把他们的职业建立在模拟时间序列上。时间序列模拟仍然是许多领域的一个活跃研究领域，也是一个计算上要求高的领域，包括：
- en: Meteorology
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 气象学
- en: Finance
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 金融学
- en: Epidemiology
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流行病学
- en: Quantum chemistry
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 量子化学
- en: Plasma physics
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等离子体物理学
- en: In some of these cases, the fundamental rules of behavior are well understood,
    but it can still be difficult to account for everything that can happen due to
    the complexity of the equations (meteorology, quantum chemistry, plasma physics).
    In other cases, not all of the predictive variables can ever be known, and experts
    aren’t even sure that perfect predictions can be made due to the stochastic nonlinear
    nature of the systems studied (finance, epidemiology).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，行为的基本规则是被充分理解的，但由于方程的复杂性（气象学、量子化学、等离子物理学），仍然很难考虑到所有可能发生的事情。在其他情况下，不可能知道所有的预测变量，专家甚至不确定由于系统的随机非线性特性是否可以做出完美的预测（金融、流行病学）。
- en: Simulation Versus Forecasting
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模拟与预测
- en: Simulation and forecasting are similar exercises. In both cases you must form
    hypotheses about underlying system dynamics and parameters, and then extrapolate
    from these hypotheses to generate data points.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟和预测是类似的练习。在这两种情况下，您必须形成关于基础系统动态和参数的假设，然后从这些假设中推断出数据点。
- en: 'Nonetheless, there are important differences to keep in mind when learning
    about and developing simulations rather than forecasts:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在学习和开发模拟而不是预测时，需要记住重要的差异：
- en: It can be easier to integrate qualitative observations into a simulation than
    into a forecast.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将定性观察整合到模拟中可能比整合到预测中更容易。
- en: Simulations are run at scale so that you can see many alternative scenarios
    (thousands or more), whereas forecasts should be more carefully produced.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟是在规模上运行的，这样您可以看到许多替代场景（成千上万甚至更多），而预测应该更加仔细地制作。
- en: Simulations have lower stakes than forecasts; there are no lives and no resources
    on the line, so you can be more creative and exploratory in your initial rounds
    of simulations. Of course, you eventually want to make sure you can justify how
    you build your simulations, just as you must justify your forecasts.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟比预测风险较低；没有生命和资源在危险线上，因此您在最初的模拟轮次中可以更有创意和探索性。当然，最终您希望能够证明您构建模拟的方式，就像您必须证明您的预测一样。
- en: Simulations in Code
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代码中的模拟
- en: Next we look at three examples of coding up simulations of time series. As you
    read these examples, consider what a wide array of data can be simulated to produce
    a “time series,” and how the temporal element can be very specific and human-driven,
    such as days of the week and times of day of donations, but can also be very nonspecific
    and essentially unlabeled, such as the "*n*th step” of a physics simulation.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看一看编写时间序列模拟的三个例子。在阅读这些例子时，请考虑可以模拟的广泛数据范围，以生成“时间序列”，以及时间元素可以非常具体和人为驱动，比如捐赠的星期几和一天中的时间，但也可以非常不具体，基本上是未标记的，比如物理模拟的“第n步”。
- en: 'The three examples of simulation we will discuss in this section are:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论三个模拟的例子：
- en: Simulating a synthetic data set to test our hypotheses about how members of
    an organization may (or may not) have correlated behavior between receptiveness
    to organizational email and willingness to make donations. This is the most DIY
    example in that we hardcode relationships and generate tabular data with `for`
    loops and the like.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟合成数据集以测试我们关于组织成员之间接受组织电子邮件和愿意捐赠之间相关行为的假设。这是最自助的例子，因为我们硬编码关系并生成包括`for`循环在内的表格数据。
- en: Simulating the synthetic data set to explore aggregate behavior in a fleet of
    taxis, complete with shift times and time-of-day-dependent frequency of passengers.
    In this data set, we make use of Python’s object-oriented attributes as well as
    generators, which are quite helpful when we want to set a system going and see
    what it does.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟合成数据集以探索出租车队的聚合行为，包括轮班时间和依赖时间的乘客频率。在这个数据集中，我们利用Python的面向对象属性以及生成器，在我们想要启动系统并观察其行为时非常有帮助。
- en: Simulating the physical process of a magnetic material gradually orienting its
    individual magnetic elements, which begin in disarray but ultimately coalesce
    into a well-ordered system. In this example, we see how physical laws can drive
    a time series simulation and insert natural temporal scaling into a process.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟磁性材料逐渐定向其个体磁元素的物理过程，这些元素最初处于无序状态，但最终会融合成一个有序的系统。在这个例子中，我们看到物理法则如何驱动时间序列模拟，并将自然的时间尺度插入到一个过程中。
- en: Doing the Work Yourself
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自己动手完成工作
- en: When you are programming simulations, you need to keep in mind the logical rules
    that apply to your system. Here we walk through an example where the programmer
    does most of the work of making sure the data makes sense (for example, by not
    specifying events that happen in an illogical order).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当您编写模拟程序时，需要牢记适用于系统的逻辑规则。在这里，我们通过示例详细说明了程序员通过确保数据合理性来完成大部分工作（例如，不指定按照不合逻辑顺序发生的事件）。
- en: 'We start by defining the membership universe—that is, how many members we have
    and when each joined the organization. We also pair each member with a member
    status:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义会员的成员资格宇宙，即我们有多少会员以及每个会员何时加入组织。我们还将每个会员与会员状态配对：
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Notice that there are already many rules/assumptions built into the simulation
    just from these lines of code. We impose specific probabilities of the years the
    members joined. We also make the status of the member entirely independent on
    the year they joined. In the real world, it’s likely we can already do better
    than this because these two variables should have some connection, particularly
    if we want to incentivize people to remain members.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这些行代码中已经内置了许多规则/假设来模拟。我们设定了会员加入年份的具体概率。我们还使会员的状态完全独立于他们加入的年份。在现实世界中，我们可能已经能够做得比这更好，因为这两个变量应该有一定的关联，特别是如果我们想要激励人们继续保持会员身份。
- en: 'We make a table indicating when members opened emails each week. In this case,
    we define our organization’s behavior: we send three emails a week. We also define
    different patterns of members behavior with respect to email:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们制作了一张表格，表明会员每周何时打开邮件。在这种情况下，我们定义了我们组织的行为：我们每周发送三封邮件。我们还定义了会员在邮件方面的不同行为模式：
- en: Never opening email
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从不打开邮件
- en: Constant level of engagement/email open rate
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 邮件开启率/参与度保持不变
- en: Increasing or decreasing level of engagement
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参与度的增加或减少
- en: 'We can imagine ways to make this more complex and nuanced depending on anecdotal
    observations from veterans or novel hypotheses we have about unobservable processes
    affecting the data:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以想象根据老兵的轶事观察或者我们对影响数据的不可观察过程的新颖假设，使这一过程变得更加复杂和微妙：
- en: '[PRE1]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We have defined functions to simulate four distinct kinds of behavior:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经定义了模拟四种不同行为的函数：
- en: Members who never open the emails we send them
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 从不打开我们发送给他们的邮件的会员
- en: (`never_opens()`)
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: (`never_opens()`)
- en: Members who open about the same number of emails each week
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 每周打开邮件数量大致相同的会员
- en: (`constant_open_rate()`)
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: (`constant_open_rate()`)
- en: Members who open a decreasing number of emails each week
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 每周打开邮件数量逐渐减少的会员
- en: (`decreasing_open_rate()`)
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: (`decreasing_open_rate()`)
- en: Members who open an increasing number of emails each week
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 每周打开邮件数量逐渐增加的会员
- en: (`increasing_open_rate()`)
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: (`increasing_open_rate()`)
- en: We ensure that those who grow increasingly engaged or disengaged over time are
    simulated in the same way with the `open_rate_with_factor_change()` function via
    the functions `increasing_open_rate()` and `decreasing_open_rate()`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们确保那些随时间增加或减少参与度的人通过函数`open_rate_with_factor_change()`以及函数`increasing_open_rate()`和`decreasing_open_rate()`进行了相同的模拟。
- en: 'We also need to come up with a system to model donation behavior. We don’t
    want to be totally naive, or our simulation will not give us insights into what
    we should expect. That is, we want to build into the model our current hypotheses
    about member behavior and then test whether the simulations based on those hypotheses
    match what we see in our real data. Here, we make donation behavior loosely but
    not deterministically related to the number of emails a member has opened:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要设计一个系统来模拟捐赠行为。我们不希望过于天真，否则我们的模拟将无法给我们带来关于我们应该期待什么的见解。也就是说，我们希望在模型中加入我们对会员行为的当前假设，然后测试基于这些假设的模拟是否与我们在真实数据中看到的相符。在这里，我们使捐赠行为与会员打开的邮件数量
    loosely 但不是确定性地相关：
- en: '[PRE2]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'There are a few steps we have taken here to make sure the code produces realistic
    behavior:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里采取了一些步骤，以确保代码产生逼真的行为：
- en: We make the overall number of donations dependent on how long someone has been
    a member.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使总体捐款数量依赖于某人成为会员的时间长短。
- en: We generate a wealth status per member, building in a hypothesis about behavior
    that donation amount is related to a stable amount a person would have earmarked
    for making donations.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们生成每位会员的财富状态，建立了一个关于行为的假设，即捐款金额与一个人用于捐款的稳定金额相关。
- en: 'Because our member behaviors are tied to a specific timestamp, we have to choose
    which weeks each member made donations and also when during that week they made
    the donation. We write a utility function to pick a random time during the week:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们的会员行为与特定时间戳相关联，所以我们必须选择每个会员何时进行捐赠以及在那一周的哪个时间进行捐赠。我们编写了一个实用函数来在一周内选择随机时间：
- en: '[PRE3]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You may have noticed that we only draw the hour of the timestamp from the range
    of 11 to 23 (`hours_of_day = [h for h in range(11, 23)]`). We are postulating
    a universe with people in a very limited range of time zones or even in just a
    single time zone, as we do not allow hours outside the range given. Here we are
    building in more of our underlying model as to how users behave.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，我们只从时间戳的小时范围中提取了11到23点之间的小时（`hours_of_day = [h for h in range(11, 23)]`）。我们假设的是一个非常有限时区范围内的人们甚至只有一个单一时区的宇宙，因为我们不允许超出给定范围的小时。在这里，我们正在构建更多关于用户行为的基础模型。
- en: We thus expect to see unified behavior from our users as though they are all
    in one or a few adjoining time zones, and we are further postulating that reasonable
    donation behavior is for people to donate from late morning to late evening, but
    not overnight and not first thing when they wake up.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们预期会看到我们的用户表现出统一的行为，就好像他们都在一个或几个相邻的时区内，而我们进一步推测合理的捐赠行为是人们从早上稍晚到晚上捐款，但不包括过夜和早上醒来时第一件事。
- en: 'Finally, we put all the components just developed together to simulate a certain
    number of members and associated events in a way that ensures that events happen
    only once a member has joined and that a member’s email events have some relation
    (but not an unrealistically small relation) to their donation events:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将所有开发的组件放在一起，以一种方式模拟一定数量的会员和相关事件，确保事件仅在会员加入后发生，并且会员的电子邮件事件与其捐赠事件有一定关系（但关系不是不切实际小的）：
- en: '[PRE4]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We then look at the temporal behavior of the donations to get a sense of how
    we might try this for further analysis or forecasting. We plot the total sum of
    donations we received for each month of the data set (see [Figure 4-1](#fig-0401)):'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们查看捐款的时间行为，以了解我们可能如何尝试进行进一步分析或预测。我们绘制了数据集每个月收到的捐款总额的总和（见[图4-1](#fig-0401)）：
- en: '[PRE5]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '![](assets/ptsa_0401.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ptsa_0401.png)'
- en: Figure 4-1\. Total sum of donations received for each month of the data set.
  id: totrans-71
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4-1. 数据集每个月收到的捐款总额。
- en: It looks as though the number of donations and of emails opened rose over time
    from 2015 through 2018\. This is not surprising, since the number of members also
    rose over time, as indicated in the cumulative sum of members and the year they
    joined. In fact, one built-in assumption of our model was that we got to keep
    a member indefinitely after they joined. We made no provision for termination
    other than allowing for members to open a decreasing number of emails. Even in
    that case, however, we left open the possibility of continued donations. We see
    this assumption of indefinitely continuing membership (and correlated donation
    behavior) in [Figure 4-1](#fig-0401). We should probably go back and refine our
    code, as indefinite membership and donation is not a realistic scenario.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 从2015年到2018年，捐款数和已打开的电子邮件数量看起来随着时间的推移有所增加。这并不令人惊讶，因为成员数量随时间增加，如成员的累积总和和加入年份所示。事实上，我们模型的一个内置假设是，一旦成员加入，我们就可以无限期地保留其成员资格。我们没有设定终止成员资格的任何规定，除非允许成员打开越来越少的电子邮件。即使在这种情况下，我们也留下了继续捐赠的可能性。我们在[图4-1](#fig-0401)中看到了这种无限期持续会员资格（及相关的捐赠行为）的假设。我们可能应该回过头来改进我们的代码，因为无限期的会员资格和捐赠并不是一个现实的情景。
- en: 'This is not a classic time series simulation, so it may feel quite a bit more
    like an exercise in generating tabular data. It absolutely is that as well, but
    we did have to be time series–aware:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一个经典的时间序列模拟，因此可能更像是生成表格数据的练习。但我们确实必须意识到时间序列：
- en: We had to make decisions about how many time series our users were in.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不得不做出关于我们的用户处于多少时间序列中的决策。
- en: 'We had to make decisions about what kinds of trends we would model over time:'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们必须对我们将随时间建模的趋势类型做出决策：
- en: 'In the case of email, we decided to have three trends: stable, increasing,
    and decreasing email open rates.'
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在电子邮件的情况下，我们决定有三种趋势：稳定、增长和减少的电子邮件开启率。
- en: In the case of donations, we made donations a stable behavioral pattern related
    to how many emails the member had ever opened in their lifetime. This included
    a lookahead, but since we were generating data, this was a way of deciding that
    a member’s overall affinity in the organization, which would lead to more emails
    opened, would also increase the frequency of donations.
  id: totrans-77
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在捐款的情况下，我们使捐款成为一个稳定的行为模式，与成员在其生命周期内打开的电子邮件数量有关。这包括一个前瞻，但由于我们正在生成数据，这是一种决定成员在组织中整体亲和力的方式，这将导致更多的电子邮件打开，也会增加捐款的频率。
- en: We had to be careful to make sure we did not have emails opened or donations
    made before the member joined the organization.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们必须小心确保在成员加入组织之前没有打开电子邮件或进行捐款。
- en: We had to make sure our data did not go into the future, to make it more realistic
    for consumers of the data. Note that for a simulation it is fine if our data goes
    into the future.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们必须确保我们的数据不会进入未来，以使其对数据的消费者更具现实意义。请注意，对于模拟来说，如果我们的数据进入未来是可以的。
- en: But it’s not perfect. The code presented here is ungainly, and it doesn’t produce
    a realistic universe. What’s more, since only the programmer checked the logic,
    they could have missed edge cases such that events take place in an illogical
    order. It would be good to establish external metrics and standards of validity
    before running the simulation as one protection against such errors.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 但它并不完美。这里提出的代码笨拙不堪，并且不能产生一个真实的宇宙。更重要的是，由于只有程序员检查了逻辑，他们可能会错过一些边界情况，导致事件按照不合逻辑的顺序发生。在运行模拟之前，建立外部度量和有效性标准是防止此类错误的一种保护措施之一。
- en: We need software that enforces a logical and consistent universe. We will look
    at Python generators as a better option in the next section.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一种能够强制实现逻辑和一致的软件宇宙。我们将在下一节中看一看 Python 生成器作为更好的选择。
- en: Building a Simulation Universe That Runs Itself
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建一个自运行的模拟宇宙
- en: Sometimes you have a specific system and you want to set up the rules for that
    system and see how it rolls along. Perhaps you want to envision what a universe
    of independent members accessing your application will use, or you want to attempt
    to validate an internal theory of decision making based on posited external behavior.
    In these cases, you are looking to see how individual agents contribute to your
    aggregate metrics over time. Python is an especially good fit for this job thanks
    to the availability of generators. When you start building software rather than
    staying purely in analysis, it makes sense to move to Python even if you are more
    comfortable in R.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你有一个特定的系统，你想为该系统设置规则并观察其运行。也许你想设想一下独立成员访问你的应用程序将使用的宇宙，或者你想试图验证一个基于假设的外部行为的内部决策理论。在这些情况下，你希望看到个体代理如何随时间推移贡献到你的聚合度量中。由于生成器的可用性，Python在这项工作中尤为合适。当你开始构建软件而不仅仅停留在分析时，即使你更喜欢R，使用Python也是有道理的。
- en: Generators allow us to create a series of independent (or dependent!) actors
    and wind them up to watch what they do, without too much boilerplate code to keep
    track of everything.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器允许我们创建一系列独立（或依赖的！）行为者，并让它们运转起来，观察它们的行为，而无需太多样板代码来跟踪一切。
- en: In the next code example, we explore a taxicab simulation.^([1](ch04.html#idm45576041340488))
    We want to imagine how a fleet of taxis, scheduled to begin their shifts at different
    times, might behave in aggregate. To do so, we want to create many individual
    taxis, set them loose in a cyber city, and have them report their activities back.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的代码示例中，我们探索一个出租车模拟。^([1](ch04.html#idm45576041340488)) 我们想象一下，一群打算在不同时间开始工作的出租车会以何种方式进行集体行动。为了做到这一点，我们希望创建许多个体出租车，将它们释放在一个虚拟城市中，并让它们汇报它们的活动。
- en: Such a simulation could be exceptionally complicated. For demonstration purposes,
    we accept that we will build a simpler world than what we imagine to truly be
    the case (“All models are wrong…”). We start by trying to understand what a Python
    generator is.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的模拟可能异常复杂。为了演示目的，我们接受将构建一个比我们想象中更简单的世界（“所有模型都是错误的…”）。我们首先尝试理解 Python 生成器是什么。
- en: 'Let’s first consider a method I wrote to retrieve a taxi identification number:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先考虑一种我编写的用于获取出租车识别号的方法：
- en: '[PRE6]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'For those who are not familiar with generators, here is the preceding code
    in action:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些不熟悉生成器的人，这里是前面的代码示例：
- en: '[PRE7]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'which might print out:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会打印出以下内容：
- en: '[PRE8]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This will iterate until it has emitted 10 numbers, at which point it will exit
    the `for` loop held within the generator and emit a `StopIteration` exception.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这将迭代直到发出10个数字，此时它将退出生成器中保存的`for`循环，并发出`StopIteration`异常。
- en: The `taxi_id_number()` produces single-use objects, all of which are independent
    of one another and keep their own state. This is a generator function. You can
    think of generators as tiny objects that maintain their own small bundle of state
    variables, which is useful when you want many objects parallel to one another,
    each one minding its own variables.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`taxi_id_number()`生成一次性对象，它们之间都是相互独立的，并且保持自己的状态。这是一个生成器函数。你可以把生成器想象成维护自己的一小组状态变量的小对象，当你希望许多对象并行运行时特别有用，每个对象都关注自己的变量。'
- en: 'In the case of this simple taxi simulation, we compartmentalize our taxis into
    different shifts, and we also use a generator to indicate shifts. We schedule
    more taxis in the middle of the day than in the evening or overnight shifts by
    setting different probabilities for starting a shift at a given time:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简单的出租车模拟案例中，我们将出租车分成不同的班次，并且使用生成器来指示班次。我们通过在特定时间开始班次设置不同的概率，白天中段调度更多的出租车，而不是在晚上或过夜的班次：
- en: '[PRE9]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Pay attention to `start_times_and_freqs`. This is our first bit of code that
    will contribute to making this a time series simulation. We are indicating that
    different parts of the day have different likelihoods of having a taxi assigned
    to the shift. Additionally, different times of the day have a different mean number
    of trips.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`start_times_and_freqs`。这是我们第一段代码，将有助于将其变成时间序列模拟。我们指出一天中的不同时间段有不同的出租车分配概率。此外，一天中的不同时间有不同的平均出租车次数。
- en: 'Now we create a more complex generator that will use the preceding generators
    to establish individual taxi parameters as well as create individual taxi timelines:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们创建一个更复杂的生成器，它将使用前面的生成器来建立单个出租车的参数，并创建单个出租车的时间线：
- en: '[PRE10]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here the taxi accesses generators to determine its ID number, shift start times,
    and mean number of trips for its start time. From there, it departs on its own
    individual journey as it runs through a certain number of trips on its own timeline
    and emits those to the client calling `next()` on this generator. In effect, this
    generator produces a time series of points for an individual taxi.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，出租车访问生成器来确定其ID编号、班次开始时间以及其开始时间的平均出租车次数。从那里开始，它将在自己的时间轴上运行一定数量的行程，并将这些行程传递给调用此生成器上的`next()`的客户端。实际上，这个生成器为单个出租车产生了时间序列点。
- en: 'The taxi generator yields `TimePoint`s, which are defined as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 出租车生成器产生了`TimePoint`，其定义如下：
- en: '[PRE11]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We use the relatively new `dataclass` decorator to simplify the code (this requires
    Python 3.7). I recommend that all Python-using data scientists familiarize themselves
    with this new and data-friendly addition to Python.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用相对较新的`dataclass`装饰器简化代码（这需要Python 3.7）。我建议所有使用Python的数据科学家熟悉这个新的对数据友好的Python添加。
- en: Python’s Dunder Methods
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python的Dunder方法
- en: Python’s *dunder* methods, whose names begin and end with two underscores, are
    a set of built-in methods for every class. Dunder methods are called automatically
    in the natural course using a given object. There are predefined implementations
    that can be overridden when you define them for your class yourself. There are
    many reasons you might want to do this, such as in the case of the preceding code,
    where we want `TimePoint`s to be compared only based on their time and not based
    on their `taxi_id` or `name` attributes.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Python的*dunder*方法，名称以双下划线开始和结束，是每个类的内置方法集。Dunder方法在使用给定对象时会自动调用。这些方法有预定义的实现，可以在你自己定义类时覆盖。你可能希望这样做的原因有很多，例如在前面的代码中，我们希望仅基于它们的时间而不是基于它们的`taxi_id`或`name`属性来比较`TimePoint`。
- en: Dunder originated as an abbreviation of “double under.”
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Dunder源于“double under”的缩写。
- en: 'In addition to the automatically generated initializer for `TimePoint`, we
    need only two other dunder methods, `__lt__` (to compare `TimePoint`s) and `__str__`
    (to print out `TimePoint`s, not shown here). We need comparison because we will
    take all `TimePoint`s produced into a data structure that will keep them in order:
    a priority queue. A *priority queue* is an abstract data type into which objects
    can be inserted in any order but which will emit objects in a specified order
    based on their priority.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 除了自动生成的`TimePoint`初始化器外，我们只需要其他两个dunder方法，`__lt__`（用于比较`TimePoint`）和`__str__`（用于打印`TimePoint`，这里没有显示）。我们需要比较，因为我们将把所有生成的`TimePoint`放入一个数据结构中，这个数据结构将按照它们的优先级来保持它们的顺序：一个*优先队列*是一个抽象数据类型，可以按任何顺序插入对象，但将按其优先级发射对象。
- en: Abstract Data Type
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽象数据类型
- en: An *abstract data type* is a computational model defined by its behavior, which
    consists of an enumerated set of possible actions and input data and what the
    results of such actions should be for certain sets of data.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '*抽象数据类型*是一种由其行为定义的计算模型，其行为由一组可能的操作和输入数据的枚举集合以及对于某些数据集的操作结果组成。'
- en: One commonly known abstract data type is a first-in-first-out (FIFO) data type.
    This requires that objects are emitted from the data structure in the same order
    in which they were fed into the data structure. How the programmer elects to accomplish
    this is a matter of implementation and not a definition.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 一个广为人知的抽象数据类型是先进先出（FIFO）数据类型。这要求对象从数据结构中被发射出来的顺序与它们被送入数据结构的顺序相同。程序员如何选择实现这一点是实现的问题，而不是定义的问题。
- en: 'We have a simulation class to run these taxi generators and keep them assembled.
    This is not merely a `dataclass` because it has quite a bit of functionality,
    even in the initializer, to arrange the inputs into a sensible array of information
    and processing. Note that the only public-facing functionality is the `run()`
    function:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个模拟类来运行这些出租车生成器并保持它们的组装。这不仅仅是一个`dataclass`，因为它在初始化器中有相当多的功能，来将输入整理成一个合理的信息和处理数组。请注意，唯一面向公众的功能是`run()`函数：
- en: '[PRE12]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: First, we create the number of taxi generators that we need to represent the
    right number of taxis. Then we run through each of these taxis while it still
    has `TimePoint`s and push all these `TimePoint`s into a priority queue. The priority
    of the object is determined for a custom class such as `TimePoint` by our implementation
    of a `TimePoint`’s `__lt__`, where we compare start time. So, as the `TimePoint`s
    are pushed into the priority queue, it will prepare them to be emitted in temporal
    order.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建所需数量的出租车生成器来表示正确数量的出租车。然后我们遍历每一个这些出租车，当它还有`TimePoint`时，将所有这些`TimePoint`推入优先队列。对象的优先级由我们对`TimePoint`类的`__lt__`实现决定，我们在其中比较开始时间。因此，当`TimePoint`被推入优先队列时，它们将准备好按时间顺序被发射出去。
- en: 'We run the simulation:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们运行模拟：
- en: '[PRE13]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here’s what the output looks like (your output will be different, as we haven’t
    set a seed—and every time you run the code it will be different from the last
    iteration):'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是输出的样子（你的输出将会不同，因为我们还没有设置种子——每次运行代码时都会与上次迭代不同）：
- en: '[PRE14]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Setting a Seed When Generating Random Numbers
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在生成随机数时设置种子
- en: When you write code that is generating random numbers, you might want to ensure
    that it’s reproducible (e.g., if you wanted to set up unit tests for code that
    is normally random or if you were trying to debug and wanted to narrow down sources
    of variation to make debugging easier). To ensure that random numbers come out
    in the same nonrandom order, you set a seed. This is a common operation, so there
    are guides on how to set a seed in any computer language.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当您编写生成随机数的代码时，您可能希望确保它是可重现的（例如，如果您想为通常是随机的代码设置单元测试，或者如果您试图调试并希望缩小变异源以便更容易调试）。为了确保随机数以相同的非随机顺序输出，您设置了一个种子。这是一个常见操作，因此有关如何在任何计算机语言中设置种子的指南。
- en: 'We have rounded to the nearest minute for display simplicity, although we do
    have more fine-grained data available. What temporal resolution we use will depend
    on our purposes:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经将显示简单性舍入到最接近的分钟，尽管我们有更精细的数据可用。我们使用什么时间分辨率将取决于我们的目的：
- en: If we want to make an educational display for people in our city of how the
    taxi fleet affects traffic, we might display hourly aggregates.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们想为我们城市的人们制作一个教育展示，展示出出租车队对交通的影响，我们可以显示每小时的汇总。
- en: If we are a taxicab app and need to understand load on our server, we likely
    want to look at minute-by-minute data or even more highly resolved data to think
    about our infrastructure design and capacity.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们是一个出租车应用程序，并且需要了解服务器的负载情况，我们可能希望查看逐分钟甚至更高分辨率数据，以考虑我们的基础设施设计和容量。
- en: We made the decision to report taxi `TimePoint`s as they are “happening.” That
    is, we report the start of a taxi ride (“pick up”) without the time when the ride
    will end, even though we easily could have condensed this. This is one way of
    making the time series more realistic, in the sense that you likely would have
    recorded events in this way in a live stream.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们决定按照“发生”的方式报告出租车的“时间点”。也就是说，我们报告出租车乘车的开始（“接人”），而不是结束时间，尽管我们很容易可以压缩这一信息。这是使时间序列更加真实的一种方式，因为在实时流中，您很可能会以这种方式记录事件。
- en: 'Note that, as in the previous case, our time series simulation has not yet
    produced a time series. We have produced a log and can see our way through to
    making this a time series in a number of ways, however:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，与前一种情况类似，我们的时间序列模拟尚未生成时间序列。我们已经生成了一个日志，并可以通过多种方式使其成为时间序列，然而：
- en: Output to a CSV file or time series database as we run the simulation.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在运行模拟的同时，将结果输出到CSV文件或时间序列数据库。
- en: Run some kind of online model hooked up to our simulation to learn how to develop
    a real-time streaming data processing pipeline.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行某种在线模型，连接到我们的模拟以了解如何开发实时流数据处理管道。
- en: Save the output down to a file or database and then do more post-processing
    to package the data in a convenient (but possibly risky vis-à-vis lookahead) form,
    such as pairing together start and end times of a given ride to study how the
    length of a taxi ride behaves at different times of the day.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将输出保存到文件或数据库中，然后进行更多的后处理，以便以一种方便的形式（但可能与前瞻性风险相关）打包数据，例如将给定乘车的起始和结束时间配对，以研究出租车乘车时间在不同时间段的行为。
- en: There are several advantages to simulating this data in addition to being able
    to test hypotheses about the dynamics of a taxi system. Here are a couple of situations
    where this synthetic time series data could be useful:.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 除了能够测试关于出租车系统动态的假设之外，模拟此数据还有几个优点。以下是一些情况，合成时间序列数据可能会有用：
- en: Testing the merits of various forecasting models relative to the known underlying
    dynamics of the simulation.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相对于已知的模拟底层动态，测试各种预测模型的优点。
- en: Building a pipeline for data you eventually expect to have based on your synthetic
    data while you await the real data.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在等待真实数据时，为基于合成数据的数据构建管道。
- en: You will be well served as a time series analyst by your ability to make use
    of generators and object-oriented programming. This example offers just one example
    of how such knowledge can simplify your life and improve the quality of your code.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 作为时间序列分析员，您能够利用生成器和面向对象编程将大有裨益。此示例仅提供了一个如何利用此类知识简化生活并提高代码质量的例子。
- en: For Extensive Simulations, Consider Agent-Based Modeling
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对于广泛的模拟，请考虑基于代理的建模
- en: The solution we coded here was all right, but it was a fair amount of boilerplate
    to ensure that logical conditions would be respected. If a simulation of discrete
    events based on the actions of discrete actors would be a useful source of simulated
    time series data, you should consider a simulation-oriented module. The [SimPy](https://simpy.readthedocs.io/en/latest)
    module is a helpful option, with an accessible API and quite a bit of flexibility
    to do the sorts of simulation tasks we handled in this section.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里编码的解决方案还算可以，但需要大量样板来确保逻辑条件得到尊重。如果基于离散行动者的离散事件模拟能成为模拟时间序列数据的有用来源，则应考虑采用面向模拟的模块。[SimPy](https://simpy.readthedocs.io/en/latest)模块是一个有帮助的选择，具有易于访问的API，并具有相当多的灵活性，可以执行我们在本节中处理的各种模拟任务。
- en: A Physics Simulation
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 物理模拟
- en: 'In another kind of simulation scenario, you may be in full possession of the
    laws of physics that define a system. This doesn’t have to be physics per se,
    however; it can also apply to a number of other areas:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一种模拟场景中，您可能完全掌握了定义系统的物理定律。然而，这不一定是物理本身，它也可以适用于许多其他领域：
- en: Quantitative researchers in finance often hypothesize the “physical” rules of
    the market. So do economists, albeit at different timescales.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 金融量化研究人员通常会假设市场的“物理”规则。经济学家也是如此，尽管时间尺度不同。
- en: Psychologists posit the “psychophysical” rules of how humans make decisions.
    These can be used to generate “physical” rules about expected human responses
    to a variety of options over time.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 心理学家提出了关于人类决策方式的“心理物理学”规则。这些规则可以用来生成关于期望人类对各种选项反应的“物理”规则。
- en: Biologists research rules about how a system behaves over time in response to
    various stimuli.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生物学家研究系统如何在时间上响应各种刺激的规则。
- en: One case of knowing some rules for a simple physical system is that of modeling
    a magnet. This is the case we are going to work on, via an oft-taught statistical
    mechanics model called the Ising model.^([2](ch04.html#idm45576040330184)) We
    will look at a simplified version of how to simulate its behavior over time. We
    will initialize a magnetic material so that its individual magnetic components
    are pointing in random directions. We will then watch how this system evolves
    into order where all the magnetic components point in the same direction, under
    the action of known physical laws and a few lines of code.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 一个了解简单物理系统某些规则的案例是模拟磁铁行为。这是我们要处理的情况，通过一个常见的统计力学模型称为伊辛模型[^2](ch04.html#idm45576040330184)。我们将看看如何模拟其随时间的行为。我们将初始化磁性材料，使其各个磁性组件指向随机方向。然后，我们将观察这个系统如何在已知物理法则和几行代码的作用下演变成所有磁性组件指向相同方向的有序状态。
- en: Next we discuss how such a simulation is accomplished via a Markov Chain Monte
    Carlo (MCMC) method, discussing both how that method works in general and as applied
    to this specific system.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们讨论如何通过马尔可夫链蒙特卡洛（MCMC）方法实现这样的模拟，讨论该方法在一般情况下以及应用于这个特定系统时的工作原理。
- en: 'In physics, an MCMC simulation can be used, for example, to understand how
    quantum transitions in individual molecules can affect aggregate ensemble measurements
    of that system over time. In this case, we need to apply a few specific rules:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在物理学中，MCMC模拟可以用于了解个别分子中的量子跃迁如何影响该系统的聚集集合测量结果随时间的变化。在这种情况下，我们需要应用一些特定的规则：
- en: In a Markov process, the probability of a transition to a state in the future
    depends only on the present state (not on past information).
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在马尔可夫过程中，未来状态的转移概率仅依赖于当前状态（而不是过去信息）。
- en: We will impose a physics-specific condition of requiring a Boltzmann distribution
    for energy; that is, <math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>T</mi>
    <mrow><mi>i</mi><mi>j</mi></mrow></msub> <mo>/</mo> <msub><mi>T</mi> <mrow><mi>j</mi><mi>i</mi></mrow></msub>
    <mo>=</mo> <msup><mi>e</mi> <mrow><mo>-</mo><mi>b</mi><mo>(</mo><msub><mi>E</mi>
    <mi>j</mi></msub> <mo>-</mo><msub><mi>E</mi> <mi>i</mi></msub> <mo>)</mo></mrow></msup></mrow></math>
    . For most of us, this is just an implementation detail and not something nonphysicists
    need to worry about.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将施加一个物理特定的条件，要求能量的玻尔兹曼分布；即，<math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>T</mi>
    <mrow><mi>i</mi><mi>j</mi></mrow></msub> <mo>/</mo> <msub><mi>T</mi> <mrow><mi>j</mi><mi>i</mi></mrow></msub>
    <mo>=</mo> <msup><mi>e</mi> <mrow><mo>-</mo><mi>b</mi><mo>(</mo><msub><mi>E</mi>
    <mi>j</mi></msub> <mo>-</mo><msub><mi>E</mi> <mi>i</mi></msub> <mo>)</mo></mrow></msup></mrow></math>
    。对于大多数人来说，这只是一个实现细节，非物理学家无需担心。
- en: 'We implement an MCMC simulation as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们按以下方式实施MCMC模拟：
- en: Select the starting state of each individual lattice site randomly.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 随机选择每个个体晶格点的起始状态。
- en: For each individual time step, choose an individual lattice site and flip its
    direction.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个时间步长，选择一个个体晶格点并翻转其方向。
- en: 'Calculate the change in energy that would result from this flip given the physical
    laws you are working with. In this case this means:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据您正在使用的物理定律计算此翻转导致的能量变化。在这种情况下，这意味着：
- en: If the change in energy is negative, you are transitioning to a lower energy
    state, which will always be favored, so you keep the switch and move on to the
    next time step.
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果能量变化为负，你正在过渡到一个更低能量状态，这将始终被偏爱，因此您会保持这种转换并继续到下一个时间步骤。
- en: If the change in energy is not negative, you accept it with the acceptance probability
    of <math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>e</mi> <mrow><mo>(</mo><mo>-</mo><mtext>energy</mtext><mtext>change</mtext><mo>)</mo></mrow></msup></math>
    . This is consistent with rule 2.
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果能量变化不为负，你以 <math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mi>e</mi>
    <mrow><mo>(</mo><mo>-</mo><mtext>energy</mtext><mtext>change</mtext><mo>)</mo></mrow></msup></math>
    的接受概率接受它。这与规则2一致。
- en: Continue steps 2 and 3 indefinitely until convergence to determine the most
    likely state for whatever aggregate measurement you are making.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 持续执行步骤2和3，直到收敛，以确定您正在进行的任何综合测量的最可能状态。
- en: Let’s take a look at the specific details of the Ising model. Imagine we have
    a two-dimensional material composed of a grid of objects, each one having what
    boils down to a mini-magnet that can point up or down. We put those mini-magnets
    randomly in an up or down spin at time zero, and we then record the system as
    it evolves from a random state to an ordered state at low temperature.^([3](ch04.html#idm45576040229528))
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下伊辛模型的具体细节。想象我们有一个由物体网格组成的二维材料，每个物体都有一个可以指向上或向下的微小磁铁。我们在时间零时随机放置这些微小磁铁，然后记录系统从随机状态到低温有序状态的演变。^([3](ch04.html#idm45576040229528))
- en: 'First we configure our system, as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们配置我们的系统如下：
- en: '[PRE15]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then we have some utility methods, such as random initialization of our starting
    block:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们有一些实用方法，比如随机初始化我们的起始块：
- en: '[PRE16]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We also calculate the energy for a given center state alignment relative to
    its neighbors:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还计算了相对于其邻居的中心状态对齐给定能量：
- en: '[PRE17]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'And we want to determine the magnetization of the entire block for a given
    state:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要确定给定状态下整个块的磁化：
- en: '[PRE18]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here’s where we introduce the MCMC steps discussed earlier:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们介绍了前面讨论过的 MCMC 步骤：
- en: '[PRE19]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now to actually run a simulation, we need some recordkeeping as well as repeated
    calls to the MCMC adjustment:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们实际运行一次模拟，我们需要一些记录以及对 MCMC 调整的重复调用：
- en: '[PRE20]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'And we run the simulation:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们运行模拟：
- en: '[PRE21]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We can get some insights from this simulation by looking at the beginning and
    ending states (see [Figure 4-2](#fig-0402)).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 通过观察初始状态和最终状态，我们可以从这个模拟中得到一些见解（见 [图 4-2](#fig-0402)）。
- en: '![](assets/ptsa_0402.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ptsa_0402.png)'
- en: Figure 4-2\. Initial state of a 5 × 5 simulated ferromagnetic material, initialized
    with each state randomly selected to be spin up or spin down with equal probability.
  id: totrans-168
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-2\. 一个 5 × 5 模拟铁磁材料的初始状态，每个状态随机选择为向上或向下旋转，概率相等。
- en: In [Figure 4-2](#fig-0402) we examine one randomly generated initial state.
    While you might expect to see the two states more mixed up, remember that probabilistically
    it’s not that likely to get a perfect checkerboard effect. Try generating the
    initial state many times, and you will see that the seemingly “random” or “50/50”
    checkerboard state is not at all likely. Notice, however, that we start with approximately
    half our sites in each state. Also realize that any patterns you find in the initial
    states is likely your brain following the very human tendency to see patterns
    even where there aren’t any.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [图 4-2](#fig-0402) 中，我们研究了一个随机生成的初始状态。虽然您可能期望看到这两个状态更加混合，但请记住从概率上讲，得到完美的棋盘效应并不那么可能。尝试多次生成初始状态，您会发现这种看似“随机”或“50/50”的棋盘状态并不常见。然而，请注意，我们的大约一半站点起始于每种状态。还要意识到，您在初始状态中发现的任何模式很可能是您的大脑遵循的非常人类的倾向，即在那里没有任何模式的地方也看到模式。
- en: We then pass the initial state into the `runState()` function, allow 1,000 time
    steps to pass, and then examine the outcome in [Figure 4-3](#fig-0403).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将初始状态传递到 `runState()` 函数中，允许 1,000 个时间步骤后检查结果，并观察 [图 4-3](#fig-0403) 中的结果。
- en: This is a snapshot of the state taken at step 1,000\. There are at least two
    interesting observations at this point. First, the dominant state has reversed
    compared to step 1,000\. Second, the dominant state is no more dominant numerically
    than was the other dominant state at step 1,000\. This suggests that the temperature
    may continue to flip sites out of the dominant state even when it might otherwise
    be favored. To better understand these dynamics, we should consider plotting overall
    aggregate measurements, such as magnetization, or make movies where we can view
    our two-dimensional data in a time series format.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在第 1,000 步拍摄的状态快照。此时至少有两个有趣的观察点。首先，与第 1,000 步相比，主导状态已经反转。其次，主导状态在数字上并不比第 1,000
    步的另一主导状态更主导。这表明，即使在可能偏向于其它情况的情况下，温度也可能继续翻转站点。为了更好地理解这些动态，我们应该考虑绘制整体的聚合测量，比如磁化，或制作影片，在那里我们可以以时间序列格式查看我们的二维数据。
- en: '![](assets/ptsa_0403.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ptsa_0403.png)'
- en: Figure 4-3\. Final low temperature state in one run of our simulation, as seen
    at 1,000 time steps.
  id: totrans-173
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-3\. 在我们模拟中运行的最终低温状态，看起来像是在 1,000 个时间步骤时。
- en: 'We do this with magnetization over time for many independent runs of the previous
    simulation, as pictured in [Figure 4-4](#fig-0404):'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过许多先前模拟的独立运行来获得随时间变化的磁化，如 [图 4-4](#fig-0404) 所示：
- en: '[PRE22]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The magnetization curves are just one example of how we could picture the system
    evolving over time. We might also consider recording 2D time series, as the snapshot
    of the overall state at each point in time. Or there might be other interesting
    aggregate variables to measure at each step, such as a measure of layout entropy
    or a measure of total energy. Quantities such as magnetization or entropy are
    related quantities, as they are a function of the geometric layout of the state
    at each lattice site, but each quantity is a slightly different measure.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 磁化曲线只是我们可以想象系统随时间演变的一个例子。我们还可以考虑记录 2D 时间序列，作为每个时间点总体状态的快照。或者可能有其他有趣的聚合变量在每一步测量，比如布局熵或总能量的测量。磁化或熵等量是相关的量，因为它们是每个晶格点状态几何布局的函数，但每个量略有不同的度量。
- en: '![](assets/ptsa_0404.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/ptsa_0404.png)'
- en: Figure 4-4\. 100 independent simulations of potential ways the system could
    enter a magnetized state at a low temperature even when each original lattice
    site was initialized randomly.
  id: totrans-178
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: Figure 4-4\. 对系统进入低温时可能出现磁化状态的 100 次独立模拟，即使每个原始晶格点是随机初始化的。
- en: 'We can use this data in similar ways to what we discussed with the taxicab
    data, even though the underlying system is quite different. For example, we could:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像讨论出租车数据那样使用这些数据，即使底层系统完全不同。例如，我们可以：
- en: Use the simulated data as the impetus to set up a pipeline.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用模拟数据作为设置管道的动力。
- en: Test machine learning methods on this synthetic data to see if they can be helpful
    on physical data before we go to the trouble of cleaning up real-world data for
    such modeling.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们费心清理真实世界数据进行建模之前，用这些合成数据测试机器学习方法，看看它们是否有助于物理数据。
- en: Watch the movie-like imagery of important metrics to develop better physical
    intuitions about the system.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 观看重要指标的电影般的图像，以开发关于系统更好的物理直觉。
- en: Final Notes on Simulations
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于模拟的最后说明
- en: We have looked at a number of very different examples of simulating measurements
    that describe behavior over time. We have looked at simulating data related to
    consumer behavior (NGO membership and donation), city infrastructure (taxicab
    pick-up patterns), and the laws of physics (the gradual ordering of a randomized
    magnetic material). These examples should leave you feeling comfortable enough
    to begin reading code examples of simulated data and also come up with ideas for
    how your own work could benefit from simulations.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看过许多非常不同的例子，模拟测量描述随时间变化的行为。我们看过有关消费者行为（NGO 成员资格和捐赠）、城市基础设施（出租车接载模式）以及物理定律（随机磁性材料逐渐有序化）的模拟数据。这些例子应该使你感到足够自信，可以开始阅读模拟数据的代码示例，并且可以思考你自己的工作如何从模拟中受益。
- en: Chances are that, in the past, you have made assumptions about your data without
    knowing how to test those or alternate possibilities. Simulations give you a route
    to do so, which means your conversations about data can expand to include hypothetical
    examples paired with quantitative metrics from simulations. This will ground your
    discussions while opening new possibilities, both in the time series domain and
    in other branches of data science.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 过去，你可能在不知道如何测试数据假设或替代可能性的情况下做出关于数据的假设。模拟为你提供了这样的机会，这意味着你关于数据的讨论可以扩展到包括假设的例子和来自模拟的定量指标。这将在时间序列领域以及数据科学的其他分支中为你的讨论奠定基础，并开辟新的可能性。
- en: Statistical Simulations
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 统计模拟
- en: Statistical simulations are the most traditional route to simulated time series
    data. They are particularly useful when we know the underlying dynamics of a stochastic
    system and want to estimate a few unknown parameters or see how different assumptions
    would impact the parameter estimation process (we will see an example of this
    later in the book). Even for physical systems, sometimes the statistical simulation
    is better.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 统计模拟是模拟时间序列数据的最传统途径。当我们了解随机系统的基本动态并希望估计几个未知参数或查看不同假设对参数估计过程的影响时，它们尤其有用（我们将在本书后面看到一个例子）。即使对于物理系统，有时统计模拟效果也更好。
- en: Statistical simulations of time series data are also quite valuable when we
    need to have a definitive quantitative metric to define our own uncertainty about
    the accuracy of our simulations. In traditional statistical simulations, such
    as an ARIMA model (to be discussed in [Chapter 6](ch06.html#statistical_model_for_time_series)),
    the formulas for the error are well established, meaning that to understand a
    system with a posited underlying statistical model, you do not need to run many
    simulations to make numerical assertions about error and variance.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们需要确定我们对模拟精度的不确定性的定量度量时，时间序列数据的统计模拟也是非常有价值的。在传统的统计模拟中，例如ARIMA模型（将在[第6章](ch06.html#statistical_model_for_time_series)中讨论），误差的公式是被充分验证的，这意味着为了理解一个假设的基础统计模型的系统，您不需要运行许多模拟来对误差和方差进行数值断言。
- en: Deep Learning Simulations
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 深度学习模拟
- en: Deep learning simulations for time series are a nascent but promising field.
    The advantages of deep learning are that very complicated, nonlinear dynamics
    can be captured in time series data even without the practitioner fully understanding
    the dynamics. This is also a disadvantage, however, in that the practitioner has
    no principled basis for understanding the dynamics of the system.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 深度学习模拟时间序列是一个新兴但有前途的领域。深度学习的优势在于即使在没有完全理解动态的情况下，也能捕捉时间序列数据中非常复杂的非线性动态。然而，这也是一个缺点，因为从业者在理解系统动态方面没有原则性的基础。
- en: Deep learning simulations also offer promise where privacy is a concern. For
    example, deep learning has been used to generate synthetic heterogeneous time
    series data for medical applications based on real time series data but without
    the potential to leak private information. Such a data set, if it can truly be
    produced without any privacy leaks, would be invaluable because researchers could
    have access to a large array of (otherwise expensive and privacy-violating) medical
    data.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 深度学习模拟也在隐私成为问题时提供了希望。例如，深度学习已被用于基于实际时间序列数据生成合成的异质时间序列数据，但不会泄露私人信息。如果可以确实地生成这样的数据集而不会泄露隐私信息，这将是非常宝贵的，因为研究人员可以访问大量（否则昂贵且侵犯隐私的）医疗数据。
- en: More Resources
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多资源
- en: Cristóbal Esteban, Stephanie L. Hyland, and Gunnar Rätsch, [“Real-Valued (Medical)
    Time Series Generation with Recurrent Conditional GANs,”](https://perma.cc/Q69W-L44Z)
    unpublished manuscript, last revised December 4, 2017, https://perma.cc/Q69W-L44Z.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: Cristóbal Esteban, Stephanie L. Hyland 和 Gunnar Rätsch, [“用递归条件生成对抗网络生成实值（医学）时间序列,”](https://perma.cc/Q69W-L44Z)
    未发表手稿, 最后修订于2017年12月4日, https://perma.cc/Q69W-L44Z.
- en: The authors demonstrate how generative adversarial networks can be used to produce
    realistic-looking heterogenous medical time series data. This is an example of
    how deep learning simulation can be used to create ethical, legal, and (hopefully)
    privacy-preserving medical data sets to enable wider access to useful data for
    machine learning and deep learning in the healthcare context.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 作者展示了如何利用生成对抗网络来生成看起来逼真的异质医疗时间序列数据。这是深度学习模拟可用于创建伦理、法律和（希望是）保护隐私的医疗数据集的一个示例，以便在医疗保健背景下为机器学习和深度学习提供更广泛的有用数据访问。
- en: 'Gordon Reikard and W. Erick Rogers, [“Forecasting Ocean Waves: Comparing a
    Physics-based Model with Statistical Models,”](https://perma.cc/89DJ-ZENZ) *Coastal
    Engineering* 58 (2011): 409–16, https://perma.cc/89DJ-ZENZ.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 'Gordon Reikard 和 W. Erick Rogers, [“预测海洋波浪：将基于物理模型与统计模型进行比较,”](https://perma.cc/89DJ-ZENZ)
    *海岸工程* 58 (2011): 409–16, https://perma.cc/89DJ-ZENZ.'
- en: This article offers an accessible and practical comparison of two drastically
    different ways of modeling a system, with physics or with statistics. The researchers
    conclude that for the particular problem they address, the timescale of interest
    to the forecaster should drive decisions about which paradigm to apply. While
    this article is about forecasting, simulation is strongly related and the same
    insights apply.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 本文提供了一个关于用物理或统计方法建模系统的两种截然不同方式的易于理解和实用的比较。研究人员得出结论，对于他们解决的特定问题，预测者感兴趣的时间尺度应该决定应用哪种范式。虽然本文是关于预测的，但模拟与之密切相关，并且相同的见解同样适用。
- en: 'Wolfgang Härdle, Joel Horowitz, and Jens-Peter Kreiss, [“Bootstrap Methods
    for Time Series,”](https://perma.cc/6CQA-EG2E) *International Statistical Review
    / Revue Internationale de Statistique* 71, no. 2 (2003): 435–59, https://perma.cc/6CQA-EG2E.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 'Wolfgang Härdle, Joel Horowitz 和 Jens-Peter Kreiss, [“时间序列的自举方法,”](https://perma.cc/6CQA-EG2E)
    *国际统计评论 / International Statistical Review* 71, no. 2 (2003): 435–59, https://perma.cc/6CQA-EG2E.'
- en: A classic 2005 review of the difficulties of statistical simulation of time
    series data given temporal dependencies. The authors explain, in a highly technical
    statistics journal, why methods to bootstrap time series data lag behind methods
    for other kinds of data, as well as what promising methods were available at the
    time of writing. The state of the art has not changed too much, so this is a useful,
    if challenging, read.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 一篇经典的2005年综述文章，讨论了统计模拟时间序列数据在处理时间依赖性方面的困难。作者在一本高度技术性的统计期刊中解释了，为什么时间序列数据的自举方法落后于其他类型数据的方法，并且在写作时可用的有前景的方法是什么。由于技术发展并未有太大改变，这篇文章是一篇有用的、尽管具有挑战性的阅读材料。
- en: ^([1](ch04.html#idm45576041340488-marker)) This example is heavily inspired
    by Luciano Ramalho’s book, [*Fluent Python*](https://oreil.ly/fluent-python) (O’Reilly
    2015). I highly recommend reading the full simulation chapter in that book to
    improve your Python programming skills and see more elaborate opportunities for
    agent-based simulation.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch04.html#idm45576041340488-marker)) 本例受到Luciano Ramalho的书籍《[*流畅的Python*](https://oreil.ly/fluent-python)》（O'Reilly
    2015）的启发。我强烈推荐阅读该书的完整仿真章节，以提高你的Python编程技能，并看到基于代理的仿真的更多精彩机会。
- en: ^([2](ch04.html#idm45576040330184-marker)) The Ising model is a well-known and
    commonly taught classical statistical mechanical model of magnets. You can find
    many code examples and further discussion of this model online in both programming
    and physics contexts if you are interested in learning more.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch04.html#idm45576040330184-marker)) Ising模型是一个众所周知且广泛教授的经典统计力学模型，用于研究磁铁。如果你有兴趣了解更多，你可以在编程和物理上下文中找到许多此模型的代码示例和进一步讨论。
- en: ^([3](ch04.html#idm45576040229528-marker)) The Ising model is more often used
    to understand what a ferromagnet’s equilibrium state is rather than to consider
    the temporal aspect of how a ferromagnet might make its way into an equilibrium
    state. However, we treat the evolution over time as a time series.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: ^([3](ch04.html#idm45576040229528-marker)) Ising模型更常用于理解铁磁体的平衡态，而不是考虑铁磁体如何进入平衡态的时间方面。然而，我们将随时间的演变视为时间序列。
