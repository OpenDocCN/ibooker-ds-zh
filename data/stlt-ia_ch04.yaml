- en: 5 Sharing your apps with the world
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 5 在全球范围内分享您的应用程序
- en: This chapter covers
  id: totrans-1
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 本章涵盖了
- en: The various options available to share your app with users
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可用于与用户分享应用程序的各种选项
- en: Deploying an app to Streamlit Community Cloud for free
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 免费将应用程序部署到Streamlit社区云
- en: Connecting an app to an external service like an API
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将应用程序连接到外部服务，如API
- en: Safeguarding your API keys and other secrets in production
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在生产中保护您的API密钥和其他机密信息
- en: Managing your app's dependencies
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理您的应用程序依赖项
- en: The moment you first successfully run an app you've built from scratch is magical—it's
    when all the hours spent designing, developing, and refining finally pay off.
    You've guided it through multiple iterations, squashed bugs, and fine-tuned every
    feature.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 当您第一次成功运行您从头开始构建的应用程序时，这是一种神奇的时刻——这是所有花费在设计、开发和改进上的时间最终得到回报的时刻。您已经引导它经历了多次迭代，解决了错误，并微调了每个功能。
- en: But what's next? Do you keep it hidden away on your local machine? Unless you've
    built something solely for your own use, the answer is probably no. To make your
    app truly useful, you need to get your app in the hands of your intended audience.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 但接下来是什么？您是否将其隐藏在本地机器上？除非您只为自己的使用构建了某些东西，否则答案可能是否定的。要使您的应用程序真正有用，您需要将应用程序交给您的目标受众。
- en: This chapter is about making the leap from local development to global deployment.
    We'll briefly discuss the various paths you have available for sharing your apps.
    We'll then settle on one of them and walk through putting your app in production
    for the world to experience.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是关于从本地开发到全球部署的飞跃。我们将简要讨论您可用于分享应用程序的各种路径。然后我们将确定其中之一，并指导您将应用程序投入生产，让全世界体验。
- en: Along the way, we'll cover key considerations involved in making your app public,
    such as safeguarding confidential information like API keys and managing your
    code's dependencies. As always, we'll take a practical approach through all of
    this, giving you direct hands-on experience with everything we discuss.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个过程中，我们将讨论使您的应用程序公开时涉及的关键考虑因素，例如保护API密钥等机密信息以及管理您的代码依赖项。一如既往，我们将采取实用方法，让您直接亲身体验我们讨论的每一件事。
- en: 5.1 Deploying your apps
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.1 部署您的应用程序
- en: We've come a long way since we started out with Streamlit. Over the last three
    chapters, you've created three fully functional—dare I even say, *useful*—applications.
    However, you've been hiding your light under the proverbial bushel; no one else
    has experienced your craft. It's time to change that!
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 自我们从Streamlit开始以来已经走了很长的路。在过去的三个章节中，您已经创建了三个完全功能性的——我甚至可以说，*有用的*——应用程序。然而，您一直将您的才华隐藏在俗语所说的灌木丛下；没有人体验过您的技艺。是时候改变这一点了！
- en: 5.1.1 What is deployment?
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1.1 什么是部署？
- en: Deploying an app loosely means making it available for other people to use.
    More specifically, it means hosting your application somewhere that your intended
    users can readily access.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 部署应用程序松散地意味着使其可供其他人使用。更具体地说，这意味着将您的应用程序托管在您的目标用户可以轻松访问的地方。
- en: Recall from Chapter 4 that a Streamlit app consists of a backend server and
    a frontend that runs on a web browser. While the frontend makes requests to the
    server and shows you the results, it's the server that really runs the show.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下第四章，Streamlit应用程序由一个后端服务器和一个在网页浏览器上运行的客户端组成。虽然前端向服务器发送请求并显示结果，但实际上是服务器在真正运行。
- en: To set up the connection between the frontend and the server and thus load an
    app, the user has to navigate to the URL and port where the server is running.
    You've experienced this before; when you start an app with the `streamlit run`
    command, this is what the command actually does at the end—it opens up a web browser
    for you and navigates to a URL like "`https://localhost:8501`".
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要建立前端和服务器之间的连接并加载应用程序，用户必须导航到服务器运行的URL和端口。您之前已经体验过这个过程；当您使用`streamlit run`命令启动应用程序时，这个命令最终实际上做的就是为您打开一个网页浏览器并导航到一个类似于"`https://localhost:8501`"的URL。
- en: You could have done this manually, too. In fact, as long as your Streamlit server
    is running, opening the URL in a new browser tab or window creates a new connection
    to the server and a new instance of your app.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以手动完成这项工作。事实上，只要您的Streamlit服务器正在运行，在新的浏览器标签页或窗口中打开URL就会创建到服务器的新的连接和您应用程序的新实例。
- en: Deploying your app, then, involves starting and keeping a Streamlit server running,
    ready to accept new connections. Only, rather than you accessing your own app
    through the `localhost` URL, it'll be other people accessing it through a different
    URL.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，部署你的应用程序涉及启动并保持 Streamlit 服务器运行，以便接受新的连接。只是，而不是你通过 `localhost` URL 访问自己的应用程序，其他人将通过不同的
    URL 访问它。
- en: There are several approaches by which you can deploy an app. We'll discuss these
    briefly in the next section.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 部署应用程序有几种方法。我们将在下一节中简要讨论这些方法。
- en: 5.1.2 Options for deployment
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.1.2 部署选项
- en: 'Depending on your requirements, how much money you''re willing to spend, and
    how much effort you''re willing to put in, there are multiple options you might
    consider for deployment. Let''s consider some of them briefly:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的需求、你愿意花费的金额以及你愿意投入的努力，你可能需要考虑多种部署选项。让我们简要地考虑一些：
- en: Running a server over your local network
  id: totrans-22
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在本地网络中运行服务器
- en: 'The simplest way to deploy your app is something you''ve already done each
    time you''ve run a Streamlit app. Recall that when you do this using the `streamlit
    run` command, a Streamlit server starts, and you can see output similar to the
    following in your terminal window:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 部署你的应用程序最简单的方法就是每次运行 Streamlit 应用程序时你已经做过的。回想一下，当你使用 `streamlit run` 命令这样做时，Streamlit
    服务器会启动，你可以在终端窗口中看到类似以下输出：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As we've seen many times at this point, the "local URL" here lets *you* access
    your app from the computer it's running on.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在这里多次看到的那样，这里的“本地 URL”允许你从运行应用程序的计算机上访问你的应用程序。
- en: But if your machine is connected to a local network or even your home Wifi,
    other devices on the network can access it through the *network URL*.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你的机器连接到本地网络或甚至你的家庭 Wi-Fi，网络上的其他设备可以通过 *网络 URL* 访问它。
- en: Go ahead and try it out! If you're on Wifi (or a LAN) and have another device—like
    a smartphone or another computer—that's connected to the same Wifi / LAN, try
    running one of the apps you've created, note the network URL, and open it in the
    second device's web browser.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，试试看！如果你在 Wi-Fi（或局域网）上，并且有另一台设备——比如智能手机或另一台电脑——连接到相同的 Wi-Fi / LAN，尝试运行你创建的一个应用程序，记下网络
    URL，然后在第二台设备的网页浏览器中打开它。
- en: 'For instance, figure 5.1 shows what I saw when I opened my todo-list app from
    my phone connected to the same Wifi network:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，图 5.1 展示了我从连接到同一 Wi-Fi 网络的手机打开我的待办事项应用程序时看到的内容：
- en: '![image](../Images/05__image001.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/05__image001.png)'
- en: Figure 5.1 Using the network URL of your Streamlit app to access it from a different
    device connected to the same network
  id: totrans-30
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.1 使用 Streamlit 应用程序的网络 URL 从同一网络中的另一台设备访问它
- en: Note
  id: totrans-31
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Getting this to work depends on how your network is set up. For instance, your
    firewall may block incoming traffic from other devices, thus preventing it from
    reaching your Streamlit server, or there may be other similar rules in place.
    Fixing such issues is outside the scope of this book, but you should be able to
    figure it out with some Googling or help from your network administrator.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 使其工作取决于你的网络如何设置。例如，你的防火墙可能阻止来自其他设备的传入流量，从而阻止它到达你的 Streamlit 服务器，或者可能存在其他类似的规则。修复此类问题超出了本书的范围，但你应该能够通过一些
    Google 搜索或从你的网络管理员那里获得帮助来解决这个问题。
- en: One advantage of this method of deployment is that making changes and having
    them be visible to your users is as easy as editing your code; there are no extra
    steps!
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这种部署方法的一个优点是，更改代码并让用户看到这些更改就像编辑你的代码一样简单；没有额外的步骤！
- en: 'There are some obvious limitations, however:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有一些明显的局限性：
- en: It only works while the computer where you're running the Streamlit server is
    on and connected to the network.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它仅在运行 Streamlit 服务器的计算机开启并连接到网络时才有效。
- en: It only allows devices connected to your local network to access your app, not
    the general public.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它只允许连接到你的本地网络的设备访问你的应用程序，而不是公众。
- en: Still, it can come in handy in a bunch of places. You could create apps for
    your household, for example, and share the link with your family. You could even
    use this type of deployment for basic non-business-critical apps at your workplace
    depending on how lenient your networking and security policies are.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，它在很多地方都可能很有用。例如，你可以为你的家庭创建应用程序，并与家人分享链接。甚至根据你的网络和安全策略的宽松程度，你还可以在工作场所使用这种类型的部署来运行基本的非业务关键应用程序。
- en: Setting up a dedicated server
  id: totrans-38
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置专用服务器
- en: If you're looking to make your Streamlit app available to a broader audience,
    setting up a dedicated server *may* be a logical step beyond local deployment.
    This involves using a separate physical or virtual machine that runs independently
    of your personal computer. By doing this, you can ensure your app is available
    around the clock and accessible to users outside your local network.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望让你的Streamlit应用程序对更广泛的受众可用，设置一个专用服务器可能是在本地部署之外的一个合理的步骤。这涉及到使用一个独立于你个人电脑的单独的物理或虚拟机器。通过这样做，你可以确保你的应用程序全天候可用，并且对本地网络之外的用户可访问。
- en: In this setup, you start by selecting a suitable server—this could be a repurposed
    extra computer you own or a new machine set up specifically for this purpose.
    After choosing a server-~-and installing Python and Streamlit on it-~-you would
    launch the Streamlit server for your app, and expose the correct port (e.g., port
    8501) to external traffic. You'll also need to handle network configuration to
    allow access, such as setting up port forwarding on your router if the server
    is behind a firewall.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种设置中，你首先选择一个合适的服务器——这可能是你拥有的一个重新利用的额外电脑，或者是一个专门为此目的设置的新机器。在选择服务器并在其上安装Python和Streamlit之后，你将启动你的应用程序的Streamlit服务器，并将正确的端口（例如，端口8501）暴露给外部流量。你还需要处理网络配置以允许访问，例如，如果服务器位于防火墙后面，你需要在路由器上设置端口转发。
- en: Operating a dedicated server can be a daunting undertaking that comes with many
    responsibilities, especially related to security. You would be responsible for
    configuring firewalls, maintaining and updating your server's operating system
    and software, etc.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 运营一个专用服务器可能是一项艰巨的任务，伴随着许多责任，尤其是与安全相关。你将负责配置防火墙，维护和更新服务器的操作系统和软件等。
- en: The advantage of going this route is that you'll have complete control over
    your deployment, but on the flip side, it requires a lot of technical knowhow
    and probably more importantly, a big portion of your time.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 选择这种方式的优点是你可以完全控制你的部署，但另一方面，它需要大量的技术知识，也许更重要的是，你将投入大量的时间。
- en: If you simply want to let the general public use the app you've developed, I
    would recommend one of the remaining options that we'll discuss.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只是想让公众使用你开发的应用程序，我会推荐我们接下来要讨论的剩余选项之一。
- en: Deploying to the cloud
  id: totrans-44
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 部署到云端
- en: For greater scalability, reliability, and ease of access, you can use a cloud-based
    platform to deploy your app. This approach leverages the infrastructure of public
    cloud service providers—such as Amazon Web Services (AWS), Microsoft Azure, or
    Google Cloud—allowing you to host your app without the need for physical hardware.
    It provides numerous benefits, including automatic scaling to handle varying levels
    of traffic, robust security measures to protect your data, and high availability
    to ensure your app is accessible at all times.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现更大的可扩展性、可靠性和易于访问，你可以使用基于云的平台来部署你的应用程序。这种方法利用了公共云服务提供商的基础设施——例如亚马逊网络服务（AWS）、微软Azure或谷歌云——允许你无需物理硬件即可托管你的应用程序。它提供了许多好处，包括自动扩展以处理不同水平的流量，强大的安全措施以保护你的数据，以及高可用性以确保你的应用程序始终可访问。
- en: The key benefit of cloud deployment is that your cloud provider manages much
    of the infrastructure-related responsibilities associated with maintaining your
    application. This includes server maintenance and security updates, allowing you
    to focus on the development and improvement of your app.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 云部署的关键好处是云服务提供商管理了与维护应用程序相关的许多基础设施责任。这包括服务器维护和安全更新，让你可以专注于应用程序的开发和改进。
- en: Many companies have already migrated, or are in the process of migrating, their
    internal applications to the cloud. If you're considering making your app available
    to users within your organization or to a broader audience, cloud deployment can
    be an efficient and effective solution. Collaborating with your cloud administrator
    or IT team will help ensure a smooth setup and integration process.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 许多公司已经将或正在将他们的内部应用程序迁移到云端。如果你考虑让你的应用程序在组织内部或更广泛的受众中可用，云部署可以是一个高效且有效的解决方案。与你的云管理员或IT团队合作将有助于确保顺利的设置和集成过程。
- en: However, it's important to note that using a cloud provider can be expensive
    as your app gets popular, since costs are usually based on the resources your
    app uses, which increases with the number of users accessing it.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，重要的是要注意，随着你的应用程序变得流行，使用云提供商可能会很昂贵，因为成本通常基于你的应用程序使用的资源，这随着访问它的用户数量的增加而增加。
- en: Chapter 13 will discuss in detail how to deploy your app to public cloud platforms
    such as AWS and Google Cloud.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 第13章将详细讨论如何将您的应用程序部署到公共云平台，如AWS和Google Cloud。
- en: Streamlit Community Cloud
  id: totrans-50
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Streamlit社区云
- en: That leaves us with the option we'll be using for most of this book—Streamlit
    Community Cloud, a way to publish your apps to anyone who cares to use them, c*ompletely
    free of charge*.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这就留下了我们将在这本书的大部分内容中使用的选项——Streamlit社区云，这是一种将您的应用程序发布给任何感兴趣的人的方式，*完全免费*。
- en: Streamlit Community Cloud is run by Snowflake, the company that owns Streamlit.
    It prioritizes ease-of-use, and as the name suggests, is custom-built to run Streamlit
    apps.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Streamlit社区云由Streamlit的所有者Snowflake公司运营。它优先考虑易用性，正如其名称所暗示的，是专门为运行Streamlit应用程序而构建的。
- en: Community Cloud does come with resource limitations, such as how much computational
    power, memory, and storage your app can use. If you cross those limits—say, if
    your app blows up in popularity—you may need to look at a different option, such
    as deployment to a paid cloud provider (see Chapter 13).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 社区云确实有一些资源限制，例如您的应用程序可以使用多少计算能力、内存和存储空间。如果您超过了这些限制——比如说，如果您的应用程序因受欢迎而变得非常流行——您可能需要考虑其他选项，例如部署到付费云提供商（见第13章）。
- en: However, given that we're in the process of learning Streamlit, Community Cloud
    is ideal for our purposes. In the rest of this chapter, we'll go through how to
    deploy an app to it.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，鉴于我们正处于学习Streamlit的过程中，社区云非常适合我们的需求。在本章的其余部分，我们将介绍如何将应用程序部署到社区云。
- en: 5.2 Deploying our to-do list app to Streamlit Community Cloud
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.2 将我们的待办事项应用程序部署到Streamlit社区云
- en: As discussed in the previous section, Streamlit Community Cloud serves our deployment
    needs perfectly, since it's free, custom-built for Streamlit, and incredibly easy
    to use.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Streamlit社区云完美地满足了我们的部署需求，因为它免费、专门为Streamlit定制，并且极其易于使用。
- en: In this section, we'll deploy one of the apps we built previously—our to-do
    list app from Chapter 4—to Community Cloud, making it so that anyone with an internet
    connection can use it.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将部署我们之前构建的一个应用程序——第4章中的待办事项应用程序——到社区云上，这样任何有互联网连接的人都可以使用它。
- en: 5.2.1 Prerequisites
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.1 前提条件
- en: 'In addition to Python and Streamlit itself, deploying an app to Streamlit Community
    Cloud requires the following:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 除了Python和Streamlit本身之外，将应用程序部署到Streamlit社区云还需要以下内容：
- en: '`git`, the popular version control tool that we discussed briefly in Chapter
    2'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`git`，我们在第2章中简要讨论的流行版本控制工具'
- en: A GitHub account
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitHub账户
- en: A Streamlit Community Cloud account
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Streamlit社区云账户
- en: Connecting your GitHub account to Community Cloud
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将您的GitHub账户连接到社区云
- en: If you've never used `git` before and want to get acquainted with it, head over
    to Appendix B, which touches upon how to use it.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您之前从未使用过`git`并且想了解它，请参阅附录B，其中简要介绍了如何使用它。
- en: Creating and setting up a GitHub account
  id: totrans-65
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建和设置GitHub账户
- en: You may have heard of GitHub, a web-based platform used for version control
    and collaborative software development. It uses `git`, a distributed version control
    system, to help developers track changes in their code, collaborate on projects,
    and manage versions of their software.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能听说过GitHub，这是一个用于版本控制和协作软件开发的基于网络的平台。它使用`git`，一个分布式版本控制系统，帮助开发者跟踪其代码的变化，在项目上进行协作，并管理其软件的版本。
- en: Note
  id: totrans-67
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: GitHub and git are not to be confused with each other. git is the name of the
    version control system. and Git*Hub* is the most popular platform for hosting
    repositories created using git. You can use git with other hosting platforms,
    such as Bitbucket, though Streamlit Community Cloud does require GitHub.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub和git不要混淆。git是版本控制系统的名称，而Git*Hub*是使用git创建的仓库最流行的托管平台。您可以使用git与其他托管平台一起使用，例如Bitbucket，尽管Streamlit社区云确实需要GitHub。
- en: A link to a GitHub account is a pretty standard fixture on most developers'
    resume these days. Importantly for us, Streamlit Community Cloud expects that
    your app's code will be stored in a GitHub *repository*, which consists of a collection
    of files and directories along with their revision history.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub账户的链接现在是大多数开发者简历上的一个相当标准的固定项目。对我们来说，重要的是Streamlit社区云期望您的应用程序代码存储在GitHub
    *仓库* 中，该仓库包含一组文件和目录及其修订历史。
- en: Begin by going to `github.com` and signing up for a new account. The sign-up
    process is pretty similar to what you would expect on other websites—you'll have
    to enter your email and verify it, create a username, and select a strong password.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，请访问`github.com`并注册一个新账户。注册过程与其他网站上的预期非常相似——您需要输入您的电子邮件并验证它，创建用户名，并选择一个强大的密码。
- en: Once you've created your account, you'll need to enable your command-line to
    authenticate and push code to any repositories you make. There are several ways
    to do this, but we'll use Personal Access Tokens (PATs), which are alternatives
    to passwords meant for accessing GitHub through the command-line or an API.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您创建了账户，您需要启用您的命令行以进行身份验证并将代码推送到您创建的任何仓库。有几种方法可以做到这一点，但我们将使用个人访问令牌（PATs），这是密码的替代品，用于通过命令行或API访问GitHub。
- en: 'At the time of writing, to get to the PAT creation screen, you can follow these
    steps:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，要到达PAT创建屏幕，您可以按照以下步骤操作：
- en: Click on your profile picture and then "Settings"
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点击您的个人头像然后“设置”
- en: Find and click on "Developer settings" in the side panel
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在侧面板中找到并点击“开发者设置”
- en: Click "Personal access tokens" > "Tokens (classic)"
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点击“个人访问令牌”>“令牌（经典）”
- en: Select "Generate new token"
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择“生成新令牌”
- en: Figure 5.2 shows this path visually (though of course GitHub may change how
    it's configured).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2以可视方式显示了此路径（尽管当然GitHub可能会更改其配置方式）。
- en: '![image](../Images/05__image002.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/05__image002.png)'
- en: Figure 5.2 How to get to the Personal Access Token generation page on GitHub
  id: totrans-79
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.2 如何在GitHub上到达个人访问令牌生成页面
- en: In the screen that opens up, make sure to select the "repo" scope, which gives
    you full control of repositories.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在打开的屏幕上，请确保选择“repo”范围，这会为您提供对仓库的完全控制权。
- en: You'll also need to enter a note describing what the token is for (feel free
    to enter something like "Token to push Streamlit code") and an expiration.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 您还需要输入一个描述令牌用途的备注（您可以输入类似“用于推送Streamlit代码”的内容）以及一个有效期。
- en: Once a PAT expires, you won't be able to use it any more and will need to create
    another one, so choose accordingly. A shorter expiry is more secure-~-as it'll
    be valid for a smaller period if compromised-~-but also means you'll have to change
    it more frequently.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦PAT过期，您将无法再使用它，需要创建一个新的，因此请相应选择。较短的过期时间更安全——因为它在泄露的情况下有效期限更短——但也意味着您需要更频繁地更改它。
- en: Figure 5.3 shows the selections you could make.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3显示了您可以做出的选择。
- en: '![image](../Images/05__image003.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/05__image003.png)'
- en: Figure 5.3 The PAT creation screen on GitHub; make sure to select the "repo"
    scope
  id: totrans-85
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.3 GitHub上的PAT创建屏幕；请确保选择“repo”范围
- en: Click "Generate token" to actually create it. GitHub will now show you the token
    you created. Copy it and store it somewhere safe, because you'll never be able
    to see it again!
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 点击“生成令牌”以实际创建它。GitHub现在会向您展示您创建的令牌。请复制并安全存储它，因为您将再也看不到它了！
- en: We'll use the PAT later when we're pushing our code.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在推送我们的代码时使用PAT。
- en: Creating a Streamlit Community Cloud account
  id: totrans-88
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建Streamlit社区云账户
- en: To create a Community Cloud account, go to the Streamlit website, `https://streamlit.io/`,
    click "Sign up", and follow the instructions. I recommend siging up with your
    GitHub account.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建社区云账户，请访问Streamlit网站，`https://streamlit.io/`，点击“注册”，并按照指示操作。我建议使用您的GitHub账户注册。
- en: Once you're done, it should take you to a "dashboard" page.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，它应该会带您到一个“仪表板”页面。
- en: If you didn't sign up with your GitHub account, you'll see an exclamation point
    next to "Workspaces" on the top left.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您没有使用GitHub账户注册，您会在左上角的“工作区”旁边看到一个感叹号。
- en: If this is the case, you'll need to separately connect your GitHub account to
    Community Cloud. As of the time of writing, you can do this by clicking "Workspaces"
    and then "Connect GitHub account".
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果是这样，您需要单独将您的GitHub账户连接到社区云。截至撰写本文时，您可以通过点击“工作区”然后“连接GitHub账户”来完成此操作。
- en: If you're already logged in to GitHub, you won't need to do anything else. If
    you aren't, you'll need to enter your GitHub account credentials.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经登录GitHub，您不需要做任何事情。如果您还没有，您需要输入您的GitHub账户凭据。
- en: 5.2.2 Deployment steps
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.2.2 部署步骤
- en: 'Now that you''ve got your accounts set up, deploying your app is a three-step
    process:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您的账户已经设置好了，部署您的应用程序是一个三步过程：
- en: Creating a GitHub repo
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建GitHub仓库
- en: Pushing your code to GitHub
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将您的代码推送到GitHub
- en: Telling Community Cloud where to look for it
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 告诉社区云在哪里查找它
- en: If your app needs to connect to an external service, or if it needs specialized
    libraries, there are a couple more steps that we'll explore later in the chapter,
    but the above steps will work for the existing to-do list app that we built in
    Chapter 4.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的应用需要连接到外部服务，或者如果它需要专用库，我们将在本章后面探索一些额外的步骤，但上述步骤将适用于我们在第 4 章中构建的现有待办事项应用。
- en: If you've already made `git` a part of your regular workflow as a developer
    (as we recommended in Chapter 2), you may already have created a repo and pushed
    your code into it, and can therefore skip ahead to the section "Telling Community
    Cloud where to find your app.”
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经像我们在第 2 章中建议的那样，将 `git` 作为您作为开发者的常规工作流程的一部分，您可能已经创建了一个仓库并将代码推送到其中，因此可以跳过到“告诉社区云您的应用位置”这一部分。
- en: If not, read the sections below in order.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果还没有，按照下面的部分顺序阅读。
- en: Creating a GitHub repo
  id: totrans-102
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建 GitHub 仓库
- en: To start, sign in to your GitHub account. The button to create a new repo should
    be fairly obvious. If you've never created one before in this account, you should
    see a "Create repository" button as shown on the left of figure 5.4\. If you do
    have some repos already, it should instead display a list of your top repos and
    you can create a new one by clicking "New", as shown on the right.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，登录您的 GitHub 账户。创建新仓库的按钮应该相当明显。如果您在此账户中之前从未创建过，您应该会看到一个“创建仓库”按钮，如图 5.4 左侧所示。如果您已经有了一些仓库，它将显示您的顶级仓库列表，您可以通过点击“新建”，如图
    5.4 右侧所示来创建一个新的。
- en: '![image](../Images/05__image004.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/05__image004.png)'
- en: Figure 5.4 Buttons to create a new repo on GitHub
  id: totrans-105
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.4 在 GitHub 上创建新仓库的按钮
- en: This should lead you to a page that asks you about the details of your new repo
    (see figure 5.5)
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会带您到一个询问您新仓库详细信息的页面（见图 5.5）
- en: '![image](../Images/05__image005.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/05__image005.png)'
- en: Figure 5.5 The repository creation screen on GitHub
  id: totrans-108
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.5 GitHub 上的仓库创建界面
- en: You can ignore most settings here—just make sure you give the repo a memorable
    name and choose "Public" for the visibility.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以忽略这里的大多数设置——只需确保您给仓库起一个容易记住的名字，并选择“公开”作为可见性。
- en: When you're done, click "Create repository.” You'll be taken to a screen with
    some instructions and importantly, the URL of your repo, as seen in figure 5.6.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，点击“创建仓库”。您将被带到包含一些说明和重要的是，您的仓库 URL 的界面，如图 5.6 所示。
- en: '![image](../Images/05__image006.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/05__image006.png)'
- en: Figure 5.6 Your repo URL
  id: totrans-112
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.6 您的仓库 URL
- en: Make a note of this URL as you'll need it in the next section. If you need to,
    you can find this URL again later by navigating to your repo.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 记下这个 URL，因为您在下一节中需要它。如果需要，您可以在以后通过导航到您的仓库再次找到这个 URL。
- en: Your repository is now ready for you to put some code in!
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 您的仓库现在已准备好供您存放一些代码了！
- en: Pushing your code to GitHub
  id: totrans-115
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 将代码推送到 GitHub
- en: At this juncture, you have a *remote* GitHub repo, but your Streamlit app code
    is stored *locally*, on your computer. We'll now make this code available in your
    remote repo, a process called *pushing* your code.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您有一个*远程* GitHub 仓库，但您的 Streamlit 应用代码是存储在*本地*，在您的计算机上。我们现在将使此代码在您的远程仓库中可用，这个过程称为*推送*您的代码。
- en: 'Open a terminal window and navigate to the directory that contains your to-do
    list app from Chapter 4, which consists of two files: `todo_list.py` and `task.py`.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 打开一个终端窗口，导航到包含第 4 章中待办事项应用（由两个文件组成：`todo_list.py` 和 `task.py`）的目录。
- en: 'Enter the following command to initialize this directory as a *local* Git repository
    (as opposed to the remote one on GitHub):'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 输入以下命令以将此目录初始化为*本地* Git 仓库（与 GitHub 上的远程仓库相对）：
- en: '[PRE1]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `git init` command creates an empty Git repo, setting up all the required
    files in a hidden subdirectory called `.git`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`git init` 命令创建一个空的 Git 仓库，在名为 `.git` 的隐藏子目录中设置所有必需的文件。'
- en: 'Next, type in:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，输入：
- en: '[PRE2]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This adds the contents of the current directory to Git's *staging area*, which
    is a temporary holding place for changes you make to your code. You use the staging
    area to prepare the exact snapshot of the code you want to save.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这会将当前目录的内容添加到 Git 的*暂存区*，这是一个临时存放您对代码所做的更改的地方。您使用暂存区来准备您想要保存的代码的确切快照。
- en: 'It''s time to *commit* your changes, so enter:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候*提交*您的更改了，所以输入：
- en: '[PRE3]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This command captures a snapshot of your code's current state, saving it in
    the local repository with a descriptive message about the changes.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令捕获您代码当前状态的快照，并将其保存到本地仓库中，附有关于更改的描述性消息。
- en: The last step here is to actually copy your code to GitHub. For this, we'll
    first need to make your local Git repo aware of your remote repo on GitHub.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 此处的最后一步是将您的代码复制到GitHub。为此，我们首先需要让您的本地Git仓库知道您在GitHub上的远程仓库。
- en: 'Fetch the PAT you created in section 5.1.1 as well as the URL to your remote
    repo, and combine them to create a PAT-embedded GitHub URL:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 获取您在5.1.1节中创建的PAT以及您远程仓库的URL，并将它们组合起来创建一个PAT嵌入的GitHub URL：
- en: '[PRE4]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'For example, if your PAT is `ghp_fLbbSwjMlw3gUs7fgRux8Ha3PIlG9w3ZY3zY` (not
    a real one) and your repo is `https://github.com/omnom-code2/streamlit-todo-list-app.git`,
    your PAT-embedded URL will be:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您的PAT是`ghp_fLbbSwjMlw3gUs7fgRux8Ha3PIlG9w3ZY3zY`（这不是一个真实的PAT）并且您的仓库是`https://github.com/omnom-code2/streamlit-todo-list-app.git`，您的PAT嵌入URL将是：
- en: '[PRE5]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You can now add this URL as a *remote* to your local repo by typing:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以通过输入以下命令将此URL添加为本地仓库的*远程*：
- en: '[PRE6]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'or in our example:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 或者在我们的例子中：
- en: '[PRE7]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This tells Git to add a remote repository with the alias "origin" to your local
    Git configuration, associating it with the specified PAT-embedded URL. This allows
    you to interact with the remote repository using that alias in future Git commands,
    and automatically uses the PAT for authentication.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉Git将一个带有别名“origin”的远程仓库添加到您的本地Git配置中，并将其与指定的PAT嵌入URL关联。这允许您在未来的Git命令中使用该别名与远程仓库交互，并自动使用PAT进行身份验证。
- en: 'Finally, run the following command to perform the code push:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，运行以下命令以执行代码推送：
- en: '[PRE8]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This does two things:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这做了两件事：
- en: Pushes the local branch you're currently in (called "master" by default) to
    the remote repo you designated as "origin,” thus making your code available in
    the "master" branch of the remote repo.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将您当前所在的本地分支（默认称为“master”）推送到您指定的“origin”远程仓库，从而使您的代码在远程仓库的“master”分支中可用。
- en: Sets the default *upstream branch* (`-u` is shorthand for `-–set-upstream`)
    of your local repo to the "master" branch on the remote repo, so that in the future
    you can push your code with just `git push` without the `-u origin main`.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将您的本地仓库的默认*上游分支*（`-u`是`-–set-upstream`的缩写）设置为远程仓库上的“master”分支，这样在将来您只需使用`git
    push`即可推送代码，无需`-u origin main`。
- en: Note
  id: totrans-142
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'We''re assuming here that the default branch that Git creates in your repo
    is called "master.” Some versions of Git use the name "main" instead. If you get
    an error when you use "master,” try replacing it with "main.” Your command would
    then become: "git push -u origin main". Alternatively, you can determine the name
    of the branch you''re on by typing "git branch" (your current branch will be highlighted),
    and use that.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里假设Git在您的仓库中创建的默认分支名为“master”。一些Git版本使用“main”这个名字。如果您在“master”上使用时遇到错误，请尝试将其替换为“main”。您的命令将变为：“git
    push -u origin main”。或者，您可以通过输入“git branch”来确定您所在的分支名称（当前分支将被突出显示），并使用它。
- en: If you navigate to the repo you created on GitHub, you should now be able to
    see your code, as displayed in figure 5.7
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您导航到您在GitHub上创建的仓库，您现在应该能够看到您的代码，如图5.7所示。
- en: '![image](../Images/05__image007.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/05__image007.png)'
- en: Figure 5.7 Your repo in GitHub, after pushing your code
  id: totrans-146
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.7 推送代码后您的GitHub仓库
- en: Git can be quite a complex tool to work with. What I just described in this
    section is really only the bare minimum of Git you need to know to deploy your
    code to Streamlit Community Cloud, but ideally, you should be using it as part
    of your regular development workflow, committing your code each time you complete
    a meaningful piece of work. This requires you to be familiar with the various
    Git commands and options. If you'd like to develop a good mental model for working
    with Git, check out the tutorial in Appendix B.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Git是一个相当复杂的工具，与它一起工作可能会有些复杂。我在本节中描述的只是您部署代码到Streamlit社区云所需了解的Git的最基本知识，但理想情况下，您应该将其作为常规开发工作流程的一部分来使用，每次完成有意义的工作后都提交代码。这要求您熟悉各种Git命令和选项。如果您想为使用Git建立一个良好的心理模型，请查看附录B中的教程。
- en: Telling Community Cloud where to find your code
  id: totrans-148
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 告诉社区云在哪里找到您的代码
- en: We've set up our Streamlit code on GitHub. All we need now is to tell Streamlit
    Community Cloud where to look for it.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在GitHub上设置了Streamlit代码。我们现在需要告诉Streamlit社区云在哪里查找它。
- en: Log in to your Community Cloud account at `streamlit.io` and click the "Create
    an app" button on the top right. If it asks you whether you already have an app,
    select the option that says you do.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 登录到您的社区云账户`streamlit.io`，然后点击右上角的“创建应用”按钮。如果它询问您是否已有应用，请选择表示您已有的选项。
- en: This should take you to the "Deploy an app" page shown in figure 5.8.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会带您到如图5.8所示的“部署应用”页面。
- en: '![image](../Images/05__image008.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/05__image008.png)'
- en: Figure 5.8 The app deployment screen on Streamlit Community Cloud
  id: totrans-153
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图5.8 Streamlit社区云上的应用程序部署屏幕
- en: 'Fill out the details of where you pushed your code, including:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 填写你推送代码的详细信息，包括：
- en: the GitHub repository you created
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你创建的GitHub仓库
- en: the branch you pushed your code to (e.g. `master` from `git push -u origin master`)
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你推送代码到的分支（例如，从`git push -u origin master`推送到的`master`）
- en: the path to your app (this would be `todo_list.py` since that's the file you
    use in the `streamlit run` command, and it's located in the root directory of
    your repo)
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你应用程序的路径（这将是`todo_list.py`，因为这是你在`streamlit run`命令中使用的文件，并且它位于你的仓库根目录中）
- en: In the App URL field, you can choose the address that people can use to access
    your app. Streamlit will suggest a default URL, but you can override it to something
    more meaningful. In figure 5.8, I chose `stmlit-todo-list-app-1.streamlit.app`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序URL字段中，你可以选择人们可以使用来访问你的应用程序的地址。Streamlit会建议一个默认URL，但你也可以将其覆盖为更有意义的内容。在图5.8中，我选择了`stmlit-todo-list-app-1.streamlit.app`。
- en: There are some advanced settings available that we'll take a look at later in
    the chapter, but ignore them for now.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 一些高级设置将在本章的后面部分进行探讨，但你现在可以忽略它们。
- en: That's it! Go ahead and click the "Deploy!" button.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了！继续点击“部署！”按钮。
- en: After a minute or so, your app should be ready! Anyone with an internet connection
    can now visit the address you chose (`https://stmlit-todo-list-app-1.streamlit.app/`
    in this case) to run your to-do list app and get their life in order. You difference-maker,
    you!
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 一分钟左右，你的应用程序应该准备好了！任何有互联网连接的人现在都可以访问你选择的地址（在这个例子中是`https://stmlit-todo-list-app-1.streamlit.app/`）来运行你的待办事项列表应用程序并整理自己的生活。你，改变生活的人！
- en: 5.3 Deploying an app that uses an external service
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.3 部署使用外部服务的应用程序
- en: As we saw in the last section, deploying a simple app to Streamlit Community
    Cloud follows a logical path and is quite straightforward. Our to-do list app
    is "simple" in the sense that it is fairly self-contained.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一节中看到的，将一个简单的应用程序部署到Streamlit社区云遵循一个逻辑路径，并且相当直接。我们的待办事项列表应用程序在“简单”这个意义上是相当自包含的。
- en: For one thing, other than Streamlit and Python itself, it has no other libraries
    or software that it depends on. For another, it does not interact with any external
    service or API.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，除了Streamlit和Python本身之外，它没有其他库或软件依赖于它。其次，它不与任何外部服务或API交互。
- en: This is not going to be true for most practical apps you create. In the real
    world, you'll build software on top of software built by other people. Therefore,
    it's quite likely that your business logic will need third-party libraries that
    don't come pre-installed with Python.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于你创建的大多数实际应用程序来说并不成立。在现实世界中，你将在其他人构建的软件之上构建软件。因此，你的业务逻辑很可能需要第三方库，而这些库并不是Python预先安装的。
- en: You will also find that, often, your app needs to reach out to services on the
    internet to do something useful. In fact, it's almost inevitable. At some point,
    your app will need access to an English dictionary to check if a word entered
    by a user is valid, or currency exchange rates to show a price in a different
    currency, or news headlines from around the globe. In these cases, you'll usually
    need to sign up for and connect to some kind of Application Programming Interface
    (API) that provides the specific service you need.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 你还会发现，通常，你的应用程序需要连接到互联网上的服务以执行某些有用的操作。实际上，这是几乎不可避免的。在某个时候，你的应用程序将需要访问英语词典以检查用户输入的单词是否有效，或者货币汇率以显示不同货币的价格，或者来自全球的新闻头条。在这些情况下，你通常需要注册并连接到某种类型的应用程序编程接口（API），以提供你需要的特定服务。
- en: In this section, we'll add some of this complexity to our existing to-do list
    app and see how to deploy the changes correctly.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将向现有的待办事项列表应用程序添加一些复杂性，并查看如何正确部署更改。
- en: 5.3.1 A quote-of-the-day to inspire users
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3.1 一句每日名言来激励用户
- en: Imagine a user of your to-do list app starting their day. The sky is clear,
    the birds are chirping, and they have a clean slate in front of them. The *diem*
    is theirs to *carpe*. So, humming the spring portion of Vivaldi's *Four Seasons*,
    they begin adding their tasks.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下你的待办事项应用程序的用户开始他们的一天。天空晴朗，鸟儿在鸣叫，他们面前有一张干净的画布。*diem*属于他们去*carpe*。因此，哼唱维瓦尔第的《四季》中的春之部分，他们开始添加他们的任务。
- en: Fast forward five minutes, and they've added the eighteenth thing they just
    remembered has to be done *today*. Shoulders sagging, your user is now vaguely
    humming the Darth Vader tune from Star Wars in their head, slowly realizing how
    much of an uphill climb the day is going to be.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 快进五分钟，他们又添加了第十八件他们刚刚想起今天必须做的事情。肩膀垂下，你的用户现在在脑海中模糊地哼着《星球大战》中的达斯·维达曲调，慢慢地意识到这一天将会是多么艰难的攀登。
- en: Well, we can't have that! What if our app could provide a word of comfort to
    the user in their time of need, a quote to motivate them? Might we not find a
    choice piece of wisdom to share with them—something like *"The secret of getting
    ahead is getting started"*—to inspire them to rise to the occasion?
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我们不能让这种情况发生！如果我们的应用能在用户需要的时候提供一些安慰，一些激励他们的名言呢？我们难道不能找到一些值得分享的智慧来激励他们——比如像“成功的关键在于开始行动”这样的名言——来鼓励他们应对挑战吗？
- en: Of course, some of your more cynical users will just throw their coffee mugs
    at the screen, but hey, you can't please everyone.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你们的一些更愤世嫉俗的用户可能会把咖啡杯扔向屏幕，但嘿，你不可能取悦每一个人。
- en: Regardless, let's think about what adding a quote-of-the-day to our app will
    entail. We could hardcode a bunch of quotes in our code, but that seems wasteful
    and not very scalable. Instead, we'll use a public API to obtain the quotes.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 不论如何，让我们考虑一下在我们的应用中添加每日名言将涉及什么。我们可以在代码中硬编码一些名言，但这似乎很浪费，而且不太可扩展。相反，我们将使用公共API来获取名言。
- en: APIs and how to call them
  id: totrans-174
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: API及其调用方法
- en: An API is really just a fancy term for a set of instructions that lets different
    pieces of software talk to each other. You might remember that in Chapter 3, we
    defined an "API" for the backend of our unit conversion app which was a *contract*
    that defined how our frontend was allowed to interact with it.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: API实际上只是一个术语，指的是一组指令，允许不同的软件组件相互通信。你可能记得在第三章中，我们为我们的单位转换应用的后端定义了一个“API”，这是一个*合约*，定义了前端如何与之交互。
- en: In general parlance, "API" means pretty much the same thing, except that rather
    than the contract between two parts of the same application, we're referring to
    the contract that defines how any piece of software is allowed to interact with
    a particular external service.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 一般而言，“API”意味着几乎相同的意思，只不过我们不是指同一应用两个部分之间的合约，而是指定义任何软件如何与特定外部服务交互的合约。
- en: An API can be structured however its developer wants and the only perfect way
    to understand how to use it is to read the documentation. That said, there are
    some common *conventional* API patterns you'll encounter quite frequently.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: API可以按照其开发者的意愿进行结构化，而唯一完美理解如何使用它的方法就是阅读文档。话虽如此，你会在实践中遇到一些常见的*传统*API模式。
- en: 'Generally speaking, you can *call* this type of API by sending an HTTP (or
    web) request to a URL that takes the following form:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，你可以通过向以下形式的URL发送HTTP（或Web）请求来调用此类API：
- en: '[PRE9]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The base address is a common address that's part of every request sent to the
    API, whereas the endpoint is specific to the type of request you're making. For
    instance, a weather-related API might have `api.weathersite.com` as the base address,
    and `forecast` and `history` as the endpoints for weather predictions and past
    weather data respectively.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 基础地址是API请求中每个请求都包含的常见地址，而端点是针对你请求的类型特定的。例如，一个与天气相关的API可能有`api.weathersite.com`作为基础地址，`forecast`和`history`作为天气预测和过去天气数据的端点。
- en: You would normally customize your API request by passing key-value parameters
    either in the URL (in the case of a GET request) or as a request payload (in a
    POST request). You may also need to pass additional information, such as an API
    key, as HTTP headers. See the sidebar to learn more about how HTTP works.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 你通常会通过传递键值参数来定制你的API请求，这些参数可以是URL中的（在GET请求的情况下）或者作为请求负载（在POST请求中）。你可能还需要通过HTTP头传递其他信息，例如API密钥。请参阅侧边栏了解HTTP工作原理的更多信息。
- en: 'In our weather example above, we might want to pass a date as a URL parameter
    to the API to get the forecast for that date, so that the URL becomes:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们上面的天气示例中，我们可能需要将日期作为URL参数传递给API，以获取该日期的预报，因此URL变为：
- en: '[PRE10]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The API would then return a response, often in a format called JSON (JavaScript
    Object Notation) that you can parse in your code to make sense of it.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，API会返回一个响应，通常是以JSON（JavaScript对象表示法）格式返回，你可以在代码中解析它以理解其含义。
- en: 'In our example, the response might be something like:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，响应可能如下所示：
- en: '[PRE11]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Sidebar: How HTTP requests work'
  id: totrans-187
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 侧边栏：HTTP请求的工作原理
- en: HTTP, which stands for HyperText Transfer Protocol, is the set of rules that
    define how messages are sent across the web. Think of it as the grammatical structure
    that computers use when they communicate over the web.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP，即超文本传输协议，是一组定义如何在网络上发送消息的规则。把它想象成计算机在网络上通信时使用的语法结构。
- en: To communicate using HTTP (e.g. when a web browser wants to talk to a web server
    to retrieve a web page), an HTTP *client—*like a browser*—*sends properly formed
    HTTP *requests* to a web server. The server then returns an HTTP *response*, which
    may consist of an HTML file, or an image, or just some text, or pretty much anything
    else.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用HTTP进行通信（例如，当网页浏览器想要与网页服务器通信以检索网页时），一个HTTP客户端——比如浏览器——会向网页服务器发送格式正确的HTTP请求。然后服务器返回一个HTTP响应，这可能包括一个HTML文件、一张图片、一些文本，或者几乎任何其他内容。
- en: 'HTTP requests consist of:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP请求包括：
- en: a request line (for our purposes, let's just think of this as a URL)
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个请求行（在我们的用例中，我们可以将其视为一个URL）
- en: some HTTP headers, which are key-value pairs providing additional information
    about how to handle the request
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些HTTP头部，它们是键值对，提供了关于如何处理请求的额外信息
- en: an optional body, which contains data that the client wants to send to the server
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个可选的主体，其中包含客户端想要发送到服务器的数据
- en: There are several different types of HTTP requests, but by far the most common
    are GET and POST.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP请求有几种不同的类型，但最常见的是GET和POST。
- en: 'Loosely speaking, GET requests are "lightweight" requests that don''t have
    a body. All of the information about the request is contained within the URL.
    Any data that needs to be sent to the server is encoded as key-value pairs and
    attached to the end of the URL like this: `?param1=value1&param2=value2...`'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 通俗地说，GET请求是没有主体的“轻量级”请求。关于请求的所有信息都包含在URL中。需要发送到服务器的数据被编码为键值对，并附加到URL的末尾，如下所示：`?param1=value1&param2=value2...`
- en: When you enter a query in a search engine, that's usually a GET request. In
    fact, when you type a URL in your browser's address bar and press return, you're
    sending a GET request to that URL.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在搜索引擎中输入查询时，这通常是一个GET请求。事实上，当你在你浏览器的地址栏中输入一个URL并按回车时，你正在向该URL发送一个GET请求。
- en: POST requests *do* have a body that contains additional information. This body
    is often called a *payload*, and may contain things like information entered into
    a web form, or an uploaded file.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: POST请求确实有一个包含额外信息的主体。这个主体通常被称为*负载*，可能包含诸如输入到网页表单中的信息或上传的文件。
- en: The API Ninjas Quotes API
  id: totrans-198
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: API Ninjas的报价API
- en: The API we'll be using is from a website called API Ninjas `(https://api-ninjas.com/)`.
    API Ninjas offers free APIs for a variety of services, such as real-time commodity
    prices, exchange rates, URL information lookups, face-detection in images, and
    much more.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要使用的API来自一个名为API Ninjas的网站（`https://api-ninjas.com/`）。API Ninjas提供各种服务的免费API，例如实时商品价格、汇率、URL信息查找、图像中的面部检测等等。
- en: They make money off the paid version of their APIs, which you have to use if
    you issue more than 10,000 calls a month. Since we're just learning, we can make
    do with much less than that, so we'll just use the free version. Specifically,
    we're interested in their Quotes API, which—according to their documentation—"provides
    a nearly endless amount of quotes from famous people throughout history."
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 他们通过他们API的付费版本赚钱，如果你每月发出超过10,000次调用，就必须使用这个版本。由于我们只是在学习，我们可以用得少一些，所以我们只会使用免费版本。具体来说，我们对其报价API感兴趣，根据他们的文档，“提供历史上著名人物的几乎无尽的引言。”
- en: To access it, you'll need to make an account with them. Head on over to `https://api-ninjas.com/`
    and sign up. As usual, you'll need to provide and verify your email and create
    a password.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问它，你需要在他们那里创建一个账户。前往`https://api-ninjas.com/`并注册。像往常一样，你需要提供并验证你的电子邮件并创建一个密码。
- en: Once you're signed in, find your API key (you'll have one key that can access
    all their APIs), which is a set of characters that identifies you when you connect
    to the API. As I write this, there's a "Show API Key" button under "My Account".
    Make a note of the key.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你登录，找到你的API密钥（你将有一个可以访问所有API的密钥），这是一个当你连接到API时用来识别你的字符集。当我写这篇文章时，在“我的账户”下有一个“显示API密钥”按钮。记下这个密钥。
- en: Check the documentation at `https://api-ninjas.com/api/quotes` to get a sense
    of how to connect to the Quotes API.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 查看在`https://api-ninjas.com/api/quotes`上的文档，以了解如何连接到报价API。
- en: The base URL here is `api.api-ninjas.com`, a common one shared across all of
    their APIs. The endpoint for the Quotes API is `/v1/quotes`, which "returns one
    (or more) random quotes".
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的基础URL是`api.api-ninjas.com`，这是他们所有API中共享的一个常见URL。Quotes API的端点是`/v1/quotes`，它“返回一个（或多个）随机名言”。
- en: The documentation also mentions that you can pass a category parameter that
    gives you a quote from a specific listed category. There's also a limit parameter
    that lets you specify how many quotes you want, but that's a paid feature that
    we won't use. By default, the API will return one quote which is all we need.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 文档还提到，你可以传递一个类别参数，以获取特定列表类别中的一句话。还有一个限制参数，允许你指定你想要多少句话，但这是一个付费功能，我们不会使用。默认情况下，API将返回一句话，这是我们需要的所有内容。
- en: Let's say we want a quote from the category "friendship". We would send a GET
    request to the URL
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要“友谊”类别中的一句话。我们将向以下URL发送GET请求
- en: '[PRE12]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'As an experiment, try going to this URL in your browser (which, as the sidebar
    on HTTP requests mentions, sends a GET request). If everything''s working as intended,
    you should get an authentication error message:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 作为实验，尝试在你的浏览器中访问这个URL（正如HTTP请求侧边栏中提到的，这会发送一个GET请求）。如果一切按预期工作，你应该得到一个认证错误消息：
- en: '[PRE13]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: That's because we also need to provide the API key we noted earlier. The documentation
    mentions that this needs to be passed as an HTTP header by the name `X-Api-Key`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为我们还需要提供之前记下的API密钥。文档提到，这需要以名为`X-Api-Key`的HTTP头的形式传递。
- en: To do this, we'll use a Python library called `requests`.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们将使用一个名为`requests`的Python库。
- en: 5.3.2 Using the `requests` library to connect to an API
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3.2 使用`requests`库连接到API
- en: As we've seen, the API we'll be using to generate inspirational quotes is a
    web-based one, where calling it requires our code to send and receive messages
    via HTTP.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，我们将使用的生成励志名言的API是一个基于Web的API，调用它需要我们的代码通过HTTP发送和接收消息。
- en: We *could* do this with vanilla Python, but we'll instead use `requests`, which
    is the Python world's go-to library for HTTP communication. `requests` provides
    a lot of built-in functionality around handling HTTP `requests`, and has a more
    user-friendly set of tools than the alternatives.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们*可以*使用纯Python来做这件事，但我们将使用`requests`，这是Python世界中用于HTTP通信的首选库。`requests`提供了大量处理HTTP`requests`的内置功能，并且比其他替代方案具有更友好的工具集。
- en: 'First, you''ll need to install `requests` using the following command:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要使用以下命令安装`requests`：
- en: '[PRE14]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Once that's done, verify that it's installed using `pip show requests`, which
    should display the version of `requests` you have, along with some other information.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，使用`pip show requests`命令验证是否已安装，该命令应显示你拥有的`requests`版本以及其他一些信息。
- en: 'Sending an HTTP request using the `requests` module is quite easy: there are
    simple `get` and `post` methods we can use.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`requests`模块发送HTTP请求相当简单：我们有简单的`get`和`post`方法可以使用。
- en: 'To give this a shot, open up a Python shell (enter `python` or `python3` in
    the command line) and try the following:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 为了尝试一下，打开Python shell（在命令行中输入`python`或`python3`）并尝试以下操作：
- en: '[PRE15]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here we're simply using the `requests.get` method to send the same request we
    sent through the browser earlier. This method returns an instance of the `Response`
    class, which encapsulates the HTTP server's response to our request.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只是使用`requests.get`方法发送我们之前通过浏览器发送的相同请求。此方法返回一个`Response`类的实例，它封装了HTTP服务器对我们请求的响应。
- en: We then access the `text` property of `response`, which gets the body of the
    response as a string. As you can see, the string is exactly what we got before
    in the browser.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们访问`response`的`text`属性，它以字符串的形式获取响应的主体。正如你所见，字符串与我们之前在浏览器中看到的一模一样。
- en: 'As we learned from the docs, we can pass our API key using the `X-Api-Key`
    header. The `requests.get` method accepts an argument called `headers` in the
    form of a regular Python dictionary, so let''s get that set up:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们从文档中学到的，我们可以使用`X-Api-Key`头传递我们的API密钥。`requests.get`方法接受一个名为`headers`的参数，其形式为常规Python字典，所以让我们设置一下：
- en: '[PRE16]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '#A Replace the "+4VJR…" with the API key you noted down earlier'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '#A 将之前记下的API密钥“+4VJR…”替换'
- en: Looks like it's working now! When we passed along the API key we obtained from
    API Ninjas in the `X-Api-Key` header, we got back an actual quote from the API!
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来现在它正在工作！当我们通过`X-Api-Key`头传递从API Ninjas获得的API密钥时，我们得到了API的实际名言！
- en: There's a lot more to the `requests` library than this. We'll encounter the
    module quite a few times in the remainder of this book, but if you'd like to learn
    more, check out the documentation at `https://requests.readthedocs.io/`.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`requests` 库的功能远不止这些。在这本书的剩余部分，我们将多次遇到这个模块，但如果你想了解更多，请查看 `https://requests.readthedocs.io/`
    上的文档。'
- en: 5.3.3 Incorporating quotes in our app
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3.3 在我们的应用中整合名言
- en: We now have everything we need to add a quote-of-the-day feature to our to-do
    list app. Since this is quite a bit different from the core functionality of managing
    your to-dos, it probably makes sense to create a new file, `quotes.py`, for this.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了添加每日名言功能所需的一切，到我们的待办事项应用中。由于这与管理待办事项的核心功能有很大不同，因此创建一个新的文件 `quotes.py`
    可能是有意义的。
- en: Specifically, we need a function, say `generate_quote`, that takes an API key
    and pulls a quote from the Quotes API.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们需要一个函数，比如 `generate_quote`，它接受一个API密钥并从名言API中提取名言。
- en: Listing 5.1 shows what `quotes.py` might look like.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 5.1 展示了 `quotes.py` 可能的样子。
- en: Listing 5.1 quotes.py
  id: totrans-232
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.1 quotes.py
- en: '[PRE17]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We place `API_URL` and `CATEGORY` (set to "inspirational", which is one of the
    categories the API Ninjas documentation tells us we can use) at the top of the
    file as easily configurable constants so that if anyone needs to change them later,
    it's easy to do so without modifying the function itself.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 `API_URL` 和 `CATEGORY`（设置为“inspirational”，这是API Ninjas文档告诉我们可以使用的一个类别）放置在文件顶部，作为易于配置的常量，以便如果以后需要更改它们，可以轻松地做到这一点，而无需修改函数本身。
- en: 'Within the function, you may notice that instead of passing the category directly
    in the URL using the `?category=` notation, we''re doing something different;
    we''re creating a dictionary like this:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数内部，你可能注意到我们没有直接使用 `?category=` 符号将类别直接传递到 URL 中，而是做了不同的处理；我们创建了一个类似这样的字典：
- en: '[PRE18]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'and passing that dictionary in the `params` argument of `requests.get`:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 并将这个字典传递给 `requests.get` 的 `params` 参数：
- en: '[PRE19]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The other way works just as well, but this is more readable. Besides, if we
    ever need to send a POST request (using `requests.post`) instead, the `params`
    argument works there too, while you can't use the URL method.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法同样有效，但这种方法更易读。此外，如果我们需要发送POST请求（使用 `requests.post`），`params` 参数在那里也适用，而你不能使用URL方法。
- en: 'Next, rather than using `response.text` as we did in the Python shell earlier,
    we''re using `response.json()`. That''s because, from our earlier experiment in
    the shell, we know that the response from the API is in JSON format:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们不再使用之前在Python shell中使用的 `response.text`，而是使用 `response.json()`。这是因为，从我们在shell中的早期实验中，我们知道API的响应是JSON格式：
- en: '[PRE20]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: JSON is a format that lets you create arbitrary hierarchies of data using text.
    It's actually pretty easy for Python developers to read a blob of JSON data since
    the way you'd store the data in JSON is almost identical to the way you would
    encode that same data in a Python literal.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: JSON是一种格式，允许你使用文本创建任意层次的数据结构。对于Python开发者来说，读取JSON数据块实际上相当容易，因为你在JSON中存储数据的方式几乎与你在Python字面量中编码相同的数据方式相同。
- en: 'So in the above value of `response.text`, you can probably tell that the data
    is encoded as a list (because of the square brackets) that contains one element:
    a dictionary with three keys: "quote", "author" and "category".'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 所以在 `response.text` 的上述值中，你可能已经看出数据被编码为一个列表（因为方括号），它包含一个元素：一个包含三个键：“quote”、“author”和“category”的字典。
- en: '`response.text`, however, is a string. To be able to access the data easily
    in Python, we need to parse it into a Python object. That''s what the `response.json()`
    method does: it parses the textual body of the response into a Python object,
    assuming the text is JSON.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`response.text` 是一个字符串。为了能够在Python中轻松访问数据，我们需要将其解析成一个Python对象。这就是 `response.json()`
    方法的作用：它将响应的文本主体解析成一个Python对象，假设文本是JSON。
- en: '[PRE21]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Once we have the result of `response.json()`, we can treat it as a normal Python
    object. In this case, we know the data is a single-element list, so we use `response.json()[0]`
    to obtain the only element of the list, which is our three-key dictionary.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了 `response.json()` 的结果，我们可以将其视为一个正常的Python对象。在这种情况下，我们知道数据是一个单元素列表，因此我们使用
    `response.json()[0]` 来获取列表的唯一元素，它是一个包含三个键的字典。
- en: 'The next portion checks if the request went through fine:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分检查请求是否顺利通过：
- en: '[PRE22]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Every HTTP response comes with a status code that classifies the result of the
    request. You may have seen these before. A status code of 200 means "OK", the
    code 404 means "Not found" etc.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 每个HTTP响应都附带一个状态码，用于分类请求的结果。你可能之前见过这些。状态码200表示“OK”，代码404表示“未找到”等。
- en: In the above snippet, the `if` statement verifies that the status code corresponds
    to a successful result, or in this case, that a quote was returned. `requests.codes`
    provides a more readable way to refer to specific HTTP status codes. `requests.codes.ok`
    just means the code 200.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的代码片段中，`if` 语句验证状态码对应于成功的结果，或者在这种情况下，返回了一个引用。`requests.codes` 提供了一种更易读的方式来引用特定的
    HTTP 状态码。`requests.codes.ok` 仅表示代码 200。
- en: If everything's fine, we construct a string with the quote itself, as well as
    the author, separated by "--". We use `quote_obj['quote']` and `quote_obj['author']`
    to extract these from the `quote_obj` dictionary we parsed the JSON result into.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切正常，我们构建一个包含引用本身以及作者（用"--"分隔）的字符串。我们使用 `quote_obj['quote']` 和 `quote_obj['author']`
    从我们解析 JSON 结果的 `quote_obj` 字典中提取这些信息。
- en: '[PRE23]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Finally, if anything went wrong with the API call and the status code was *not*
    200, we fail gracefully by returning an evergreen motivational quote from Shia
    LaBeouf, one of the great philosophers of our time.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果 API 调用出现错误且状态码不是 200，我们将优雅地失败，并返回 Shia LaBeouf 的永恒励志名言，他是我们这个时代伟大的哲学家之一。
- en: 'Once `quotes.py` is complete, using it to create a quote to display in our
    main app is pretty simple. In `todo_list.py`, import the `generate_quotes` function
    at the top:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 `quotes.py` 完成，使用它来创建在主应用程序中显示的引用非常简单。在 `todo_list.py` 中，在顶部导入 `generate_quotes`
    函数：
- en: '[PRE24]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then, to display the quote, call `generate_quote` with your API key right above
    where you''re showing the task completion metric, and put the result in an st.info
    box:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，要显示引用，请在显示任务完成度指标的正上方调用 `generate_quote` 函数并使用您的 API 密钥，并将结果放入一个 st.info
    框中：
- en: '[PRE25]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As before, don't forget to replace the argument to `generate_quote` with your
    actual API key.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 和以前一样，别忘了将 `generate_quote` 的参数替换为您的实际 API 密钥。
- en: If you `streamlit run` your app at this point, you should see your quote-of-the-day
    show up as in figure 5.9.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您此时使用 `streamlit run` 运行应用程序，您应该会看到如图 5.9 所示的每日名言出现。
- en: '![image](../Images/05__image009.png)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/05__image009.png)'
- en: Figure 5.9 Quote-of-the-day in our to-do list app
  id: totrans-261
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.9 我们待办事项应用程序中的每日名言
- en: Great! That seems like our API call is working exactly as we intended! We can
    rest assured that if our user feels like giving up in the middle of organizing
    their day, they'll have a daily motivational quote to inspire them to stay strong.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！这似乎表明我们的 API 调用完全按照我们的预期工作！我们可以放心，如果我们的用户在组织他们的一天中间想要放弃，他们会有一个每日励志名言来激励他们保持坚强。
- en: But wait! Recall that Streamlit reruns your *entire* code each time any interaction
    takes place. That includes making an API call through `generate_quote`. Basically,
    each time your user adds a task, or marks something done, or basically does anything
    in the app, an API call is made and a new quote is generated. Forget quote-of-the-day,
    we're dealing with quote-of-the-click here.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 但等等！回想一下，Streamlit 每次发生任何交互时都会重新运行您的 *全部* 代码。这包括通过 `generate_quote` 进行 API 调用。基本上，每次您的用户添加任务、标记某事为完成或基本上在应用程序中做任何事情时，都会进行一次
    API 调用并生成一个新的引用。忘掉每日名言吧，我们在这里处理的是点击名言。
- en: Normally, you might be forgiven for wanting to chalk that up as "a feature,
    not a bug". But remember that we only have 10,000 free API calls available per
    month. If we keep pulling a quote every time the user clicks on anything, we'll
    burn through even that hefty quota pretty quickly.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您可能会认为这是“功能，而不是错误”。但请记住，我们每月只有 10,000 次免费的 API 调用。如果我们每次用户点击任何东西时都拉取一个引用，我们很快就会用完这个庞大的配额。
- en: 'Instead, let''s make use of our old friend `st.session_state` from Chapter
    4\. Just as we saved our task list so it doesn''t get reset with every run, we''ll
    also save our quote so we only call the API once:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，让我们利用我们第 4 章的老朋友 `st.session_state`。就像我们保存任务列表以便每次运行时不会重置一样，我们也会保存引用，这样我们只调用
    API 一次：
- en: '[PRE26]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '#A Again, replace the "+4VJR…" with the API key you noted down earlier'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '#A 再次，将 "+4VJR…" 替换为您之前记下的 API 密钥'
- en: 'We can now replace our earlier st.info line with this:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以用这个来替换我们之前的 st.info 行：
- en: '[PRE27]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: If you try the app now, you'll see that the quote doesn't change when you add
    a task or do anything else in the app, only when you refresh the page.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 如果现在尝试该应用程序，您会看到当您在应用程序中添加任务或执行其他任何操作时，引用不会改变，只有当您刷新页面时才会改变。
- en: So are we done? Well, not quite...
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们完成了吗？嗯，还不完全...
- en: 5.3.4 Accessing your API key safely with st.secrets
  id: totrans-272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.3.4 使用 st.secrets 安全地访问您的 API 密钥
- en: Our app works just fine now, but it has a glaring security flaw. We just embedded
    our API key directly in the code.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序现在运行得很好，但它有一个明显的安全漏洞。我们只是直接将 API 密钥嵌入到代码中。
- en: If we now commit this code to a public GitHub repository, anyone will be able
    to see it and therefore find our API key! In this instance, with a free API, the
    stakes are pretty low, but imagine if you were paying for the API—either because
    you exhausted your free quota, or because you're using a different API that costs
    money!
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在将此代码提交到公共GitHub仓库，任何人都可以看到它，因此可以找到我们的API密钥！在这种情况下，使用免费API的风险相对较低，但想象一下，如果你在付费API上——无论是用完了免费配额，还是因为你正在使用一个需要付费的API！
- en: Anyone who accesses your GitHub repo might—unwittingly or with malicious intent—set
    themselves loose on your API account, costing you hundreds or maybe even thousands
    of dollars.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 任何访问你的GitHub仓库的人——可能是无意中或出于恶意意图——都可能对你的API账户造成破坏，可能花费你数百甚至数千美元。
- en: Note
  id: totrans-276
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'It''s worth internalizing this rule right now: never store any secret information,
    whether it''s an API key or a password, or any other kind of credential, in your
    code—especially if the code is going to be publicly accessible.'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 现在值得记住这个规则：永远不要在代码中存储任何秘密信息，无论是API密钥、密码还是任何其他类型的凭证——特别是如果代码将要公开访问。
- en: 'What''s the alternative then? How do we give our app access to our API key
    if we can''t put it in code? Generally speaking, there are a few ways to do this:
    you could put your key in an environment variable that''s stored securely on the
    server where your app is running. Another option is to use a secrets management
    service like AWS Secrets Manager or HashiCorp Vault which allow you to retrieve
    confidential info securely.'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，替代方案是什么？如果我们不能将其放入代码中，我们如何让我们的应用访问API密钥？一般来说，有几种方法可以做到这一点：你可以将你的密钥放入一个存储在服务器上的环境变量中，该服务器上运行着你的应用。另一个选择是使用像AWS
    Secrets Manager或HashiCorp Vault这样的秘密管理服务，这些服务允许你安全地检索机密信息。
- en: 'Fortunately, Streamlit provides an easy way to keep your secrets safe: `st.secrets`.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Streamlit提供了一个简单的方法来保护你的秘密：`st.secrets`。
- en: Like `st.session_state`, `st.secrets` is a dictionary-like structure that you
    can use to store secret information as key-value pairs.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 与`st.session_state`类似，`st.secrets`是一个类似字典的结构，你可以用它来存储作为键值对的秘密信息。
- en: To make a value available to `st.secrets`, you put it in a special file called
    `secrets.toml`. While you're developing locally, Streamlit will pull values from
    the `secrets.toml` file. When you push your code, you take care to *not* push
    the `secrets.toml` file.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 要使一个值可用于`st.secrets`，你将其放入一个名为`secrets.toml`的特殊文件中。当你本地开发时，Streamlit会从`secrets.toml`文件中提取值。当你推送代码时，请确保不要推送`secrets.toml`文件。
- en: Instead, you would configure the information directly into Streamlit Community
    Cloud, so that your deployed app can access it in production.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，你将直接在Streamlit社区云中配置这些信息，这样你的部署应用就可以在生产环境中访问它。
- en: The secrets.toml file
  id: totrans-283
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`secrets.toml`文件'
- en: In the root folder of your local repository (where you ran `git init` earlier),
    create an empty directory called `.streamlit`, and under it, an empty text file
    called `secrets.toml`.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在你本地仓库的根目录（你之前在这里运行了`git init`），创建一个名为`.streamlit`的空目录，并在其中创建一个名为`secrets.toml`的空文本文件。
- en: Next enter your API key in the file as shown in listing 5.2.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，按照列表5.2所示，在文件中输入你的API密钥。
- en: Listing 5.2 secrets.toml
  id: totrans-286
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.2 secrets.toml
- en: '[PRE28]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: As before, use your actual API key here.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，在这里使用你的实际API密钥。
- en: The `.toml` format may be new to you. TOML stands for Tom's Obvious Minimal
    Language. It's a format for configuration files designed to be concise and easily
    readable by humans, and was originally created by a guy named—believe it or not—Tom.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '`.toml`格式可能对你来说很新。TOML代表Tom''s Obvious Minimal Language。它是一种用于配置文件的格式，旨在简洁且易于人类阅读，最初由一个名叫——信不信由你——Tom的人创建。'
- en: '`.toml` files mostly consist of key-value pairs and support a range of simple
    and complex data types, including arrays and tables. They can be divided into
    sections denoted by square brackets.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '`.toml`文件主要由键值对组成，支持一系列简单和复杂的数据类型，包括数组和表格。它们可以通过方括号分隔的节来划分。'
- en: The file shown in listing 5.2 has a single section, `quotes_api`, with a single
    key-value pair (with the key being `api_key`).
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 列表5.2中显示的文件有一个单独的节，`quotes_api`，其中有一个键值对（键为`api_key`）。
- en: 'If we were to read it in Python (outside of Streamlit, you would usually do
    this using the `toml` module), it would map to the following nested dictionary:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在Python中读取它（在Streamlit之外，你通常会使用`toml`模块来做这件事），它将映射到以下嵌套字典：
- en: '[PRE29]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In Streamlit, this is more or less what `st.secrets` would also contain.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在Streamlit中，`st.secrets`大致也会包含这些内容。
- en: 'We can therefore now replace the part of `todo_list.py` that calls `generate_quote`
    with this:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在可以将`todo_list.py`中调用`generate_quote`的部分替换为以下内容：
- en: '[PRE30]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: At runtime, Streamlit will read our `secrets.toml` file to populate `st.secrets`
    as shown above, and we can use `st.secrets["quotes_api"]["api_key"]` to refer
    to the API key. Try it out—you'll see that your app is still able to fetch a quote
    from the API.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时，Streamlit将读取我们的`secrets.toml`文件，如上所示，填充`st.secrets`，我们可以使用`st.secrets["quotes_api"]["api_key"]`来引用API密钥。试一试——你会看到你的应用仍然能够从API中获取引言。
- en: Note
  id: totrans-298
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Technically, the .streamlit directory should be located in the directory that
    you run the command "streamlit run <file_path>" from. For instance, if you're
    currently in a directory called "apps", your actual code is located in a folder
    called "todo_list_app", and the command you use to run your app is "streamlit
    run todo_list_app/todo_list.py", then the .streamlit folder should located in
    the "apps" folder, not in the "todo_list_app" folder. When you deploy your code
    to Streamlit Community Cloud, "streamlit run" will effectively be run from your
    repo root, which is why I suggested placing .streamlit there. While developing
    locally, if your local repo root is different from the folder you usually execute
    "streamlit run" from, you'll probably need to "cd" into the repo root to get this
    to work.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 技术上，.streamlit目录应该位于你运行“streamlit run <file_path>”命令的目录中。例如，如果你目前在一个名为“apps”的目录中，你的实际代码位于一个名为“todo_list_app”的文件夹中，你用来运行应用的命令是“streamlit
    run todo_list_app/todo_list.py”，那么.streamlit文件夹应该位于“apps”文件夹中，而不是“todo_list_app”文件夹中。当你将代码部署到Streamlit社区云时，“streamlit
    run”实际上会从你的仓库根目录运行，这就是为什么我建议将其放置在那里。在本地开发时，如果你的本地仓库根目录与您通常执行“streamlit run”的文件夹不同，你可能需要“cd”到仓库根目录才能使其工作。
- en: At the end of this, your `todo_list.py` file should be as shown in listing 5.3
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，你的`todo_list.py`文件应该如列表5.3所示
- en: Listing 5.3 The final state of todo_list.py
  id: totrans-301
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.3 `todo_list.py`的最终状态
- en: '[PRE31]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 5.4 Deploying our changes to Streamlit Community Cloud
  id: totrans-303
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.4 将我们的更改部署到Streamlit社区云
- en: Generally speaking, making changes to an already-deployed Streamlit app is simple.
    All you need to do is to commit your changes and use `git push` to push them to
    your GitHub repo, and Streamlit Community Cloud will automatically pick them up.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 通常来说，对已经部署的Streamlit应用进行更改很简单。你所需要做的就是提交你的更改，并使用`git push`将它们推送到你的GitHub仓库，Streamlit社区云将自动获取这些更改。
- en: 'However, given the most recent changes we''ve made to our app, in our case
    this process will be slightly more complicated. There are three complicating factors:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，鉴于我们对应用所做的最新更改，在我们的情况下，这个过程将稍微复杂一些。有三个复杂因素：
- en: We're now using an additional third-party library, requests, and we have to
    make sure the right version is installed in production
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们现在使用了一个额外的第三方库，requests，并且我们必须确保在生产环境中安装了正确的版本
- en: We need to make sure we don't ever push `secrets.toml` to GitHub, even by accident
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要确保永远不要将`secrets.toml`推送到GitHub，即使是不小心也是如此
- en: Since we're not going to store our API key in the GitHub repo, we need to configure
    it in Community Cloud directly
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于我们不会将API密钥存储在GitHub仓库中，我们需要直接在社区云中配置它
- en: 5.4.1 Using a `requirements.txt` file to manage Python dependencies
  id: totrans-309
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.4.1 使用`requirements.txt`文件管理Python依赖项
- en: 'One of the things that can trip you up when you first start to publish your
    apps to the world is that you now have two *environments* to manage: your development
    environment (often simply called *dev*), which is in your laptop or whatever computer
    you''re using to code your app, and your production environment (called *prod*),
    which is in Streamlit Community Cloud.'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 当你刚开始将你的应用发布到世界时，可能会让你感到困惑的一件事是，你现在需要管理两个*环境*：你的开发环境（通常简称为*dev*），它位于你的笔记本电脑或你用来编写应用的任何计算机上，以及你的生产环境（称为*prod*），它位于Streamlit社区云中。
- en: To make sure the app that you've coded in dev works as expected in prod, you
    have to make sure that two two environments are configured in exactly the same
    way, or at least that *any differences between dev and prod are not relevant to
    your app*.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保你在开发环境中编写的应用在生产环境中按预期工作，你必须确保两个环境配置得完全相同，或者至少确保*开发环境和生产环境之间的任何差异都不会影响你的应用*。
- en: Obviously, this means that your Python code that runs in prod should be exactly
    the same as what's running on your computer in dev, but that's not enough; your
    Python code may rely on software you didn't write yourself, such as the `requests`
    module in the case of our to-do list app, or indeed, Streamlit itself—this means
    that we also need to make sure that these *dependencies* of your app are the same
    in prod and dev, or at least that they don't differ in any ways that matter to
    your app's functionality.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这意味着在生产环境中运行的 Python 代码应该与你在开发环境中运行的代码完全相同，但这还不够；你的 Python 代码可能依赖于你未编写的软件，例如在我们的待办事项应用程序中，`requests`
    模块，或者实际上，Streamlit 本身——这意味着我们还需要确保这些 *依赖项* 在生产环境和开发环境中是相同的，或者至少它们在影响应用程序功能的方式上没有差异。
- en: For instance, if you use a feature of the requests library that was introduced
    in requests version 2.1.1 but the version of `requests` you have installed in
    prod is version 2.0.5, your app will run into errors in prod. To be sure your
    code won't break, you need to install `requests` version 2.1.1 or higher in prod.
    Technically, to be really sure your code won't break, you need to install exactly
    the version 2.1.1, as there's always a small possibility that the feature you
    used may be deprecated or removed in a future version.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你使用了 requests 库在 2.1.1 版本中引入的功能，但你在生产环境中安装的 `requests` 版本是 2.0.5，你的应用程序在生产环境中将会遇到错误。为了确保你的代码不会出错，你需要在生产环境中安装
    `requests` 版本 2.1.1 或更高版本。技术上，为了确保你的代码不会出错，你需要安装确切的 2.1.1 版本，因为总有可能你使用的功能在未来的版本中被弃用或删除。
- en: 'In the Python world, we conventionally use a file called `requirements.txt`
    to prevent these kinds of discrepancies. The premise of `requirements.txt` is
    simple: each line in it represents a Python module and a string that specifies
    a version or a range of versions of that module that is compatible with your code.'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 世界中，我们传统上使用一个名为 `requirements.txt` 的文件来防止这类差异。`requirements.txt` 的前提很简单：它中的每一行代表一个
    Python 模块和一个字符串，该字符串指定了该模块的版本或一系列版本，这些版本与你的代码兼容。
- en: When fed into the `pip install` command (as `pip install -r requirements.txt`),
    `pip` will automatically go through the file and install the right versions of
    every module in it.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 当将文件输入到 `pip install` 命令（如 `pip install -r requirements.txt`）时，`pip` 将会自动遍历该文件并安装其中每个模块的正确版本。
- en: Streamlit Community Cloud knows what to do with a `requirements.txt` file, so
    if you add one to your GitHub repo, it will automatically install the libraries
    you need to make your app work.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: Streamlit 社区云知道如何处理 `requirements.txt` 文件，所以如果你在你的 GitHub 仓库中添加一个，它将自动安装使你的应用程序工作的库。
- en: Creating a `requirements.txt` file
  id: totrans-317
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建一个 `requirements.txt` 文件
- en: Our app only has two outside dependencies—`streamlit` and `requests` (you can
    determine this by examining the import statements in all of your `.py` files).
    The contents of our `requirements.txt` file can therefore be quite simple as shown
    in listing 5.4
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序只有两个外部依赖项——`streamlit` 和 `requests`（你可以通过检查所有 `.py` 文件中的导入语句来确定这一点）。因此，我们的
    `requirements.txt` 文件的内容可以非常简单，如列表 5.4 所示。
- en: Listing 5.4 A simple requirements.txt
  id: totrans-319
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 5.4 一个简单的 requirements.txt 文件
- en: '[PRE32]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: While this is a valid `requirements.txt`, it doesn't say anything about what
    versions we want installed.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是一个有效的 `requirements.txt` 文件，但它并没有说明我们想要安装的版本。
- en: One safe way to handle this would be to determine the versions of these libraries
    we have installed in dev and specify those exact versions in `requirements.txt`.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 处理这个问题的一个安全方法就是确定我们在开发环境中安装的这些库的版本，并在 `requirements.txt` 中指定这些确切的版本。
- en: 'There are a couple of ways to do this:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以做到这一点：
- en: you could type `pip show streamlit` and `pip show requests` to see (among other
    information) the versions of each library you have.
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以输入 `pip show streamlit` 和 `pip show requests` 命令来查看（以及其他信息）你拥有的每个库的版本。
- en: you could also enter the command `pip freeze > requirements.txt` to automatically
    create the `requirements.txt` file from the modules you have installed in dev—this,
    however, will include *every* module you have installed, regardless of whether
    you're importing them in your code. If you go this way, it might make sense to
    delete all the lines from the file except those that correspond to `streamlit`
    or `requests`.
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你也可以输入命令 `pip freeze > requirements.txt` 以自动从你在开发环境中安装的模块创建 `requirements.txt`
    文件——然而，这将会包括你安装的 *所有* 模块，无论你是否在代码中导入它们。如果你选择这种方式，可能需要删除文件中除了与 `streamlit` 或 `requests`
    对应的行之外的所有行。
- en: Either way, once you've determined the right versions using `pip show` or already
    created the file using `pip freeze`, your `requirements.txt` file should look
    something like listing 5.5.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 无论哪种方式，一旦你使用`pip show`确定了正确的版本，或者已经使用`pip freeze`创建了文件，你的`requirements.txt`文件应该看起来像列表5.5。
- en: Listing 5.5 A strict requirements.txt
  id: totrans-327
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.5 严格的requirements.txt
- en: '[PRE33]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We don't *have* to be this strict with the versions. We could instead allow
    any version of these libraries that are the same or higher than the ones we have
    installed. That way, we could allow our app to benefit from any under-the-hood
    improvements these libraries may make in the future, while still being *reasonably*
    sure it won't break. In this case, our file may look like listing 5.6.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 我们**不必**对版本这么严格。我们也可以允许这些库的任何版本，只要它们与我们安装的版本相同或更高。这样，我们就可以让我们的应用程序从这些库可能在未来做出的任何底层改进中受益，同时仍然可以**合理地**确信它不会崩溃。在这种情况下，我们的文件可能看起来像列表5.6。
- en: Listing 5.6 A this-version-or-higher requirements.txt
  id: totrans-330
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表5.6 允许此版本或更高版本的requirements.txt
- en: '[PRE34]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Once you've got your file ready, save it to the root of your local Git repo.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你的文件准备好了，将其保存到本地Git仓库的根目录下。
- en: Note
  id: totrans-333
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: You may notice that your app works fine in production even if you *don't* create
    a requirements.txt file. That's because Streamlit Community Cloud pre-installs
    the two libraries we're using here, i.e. streamlit and requests. Obviously the
    streamlit library is required for any app to function. Since the streamlit module
    actually depends on the requests module internally, requests is pre-installed
    too! Still, you'll undoubtedly encounter situations in the future where you need
    libraries other than those two, and you'll need a requirements.txt then. Even
    in the current case, you'll need this file to restrict the exact versions of these
    modules that are installed in prod.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到，即使你没有创建requirements.txt文件，你的应用程序在生产环境中也能正常工作。这是因为Streamlit Community
    Cloud预先安装了我们在这里使用的两个库，即streamlit和requests。显然，streamlit库对于任何应用程序的正常运行都是必需的。由于streamlit模块实际上依赖于requests模块，因此requests也被预先安装了！然而，你无疑会在未来遇到需要安装除这两个库之外的其他库的情况，那时你需要一个requirements.txt文件。即使在当前情况下，你也需要这个文件来限制在生产环境中安装的这些模块的确切版本。
- en: 5.4.2 Using .gitignore to protect secrets.toml
  id: totrans-335
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.4.2 使用.gitignore保护secrets.toml
- en: You may be wondering about how using a `secrets.toml` file actually protects
    your API key from prying eyes—the key may not technically be in your Python code
    any more but it's still stored in a file next to your actual code. Well, the point
    is to keep `secrets.toml` around locally but to never commit it to our Git repo.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道使用`secrets.toml`文件实际上是如何保护你的API密钥不被窥视的——密钥可能技术上不再在你的Python代码中，但它仍然存储在你实际代码旁边的文件中。好吧，关键是要在本地保留`secrets.toml`文件，但永远不要将其提交到我们的Git仓库中。
- en: To make certain that we don't accidentally commit the `secrets.toml` file, we'll
    use a file called `.gitignore`.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们不会意外提交`secrets.toml`文件，我们将使用一个名为`.gitignore`的文件。
- en: '`.gitignore` is a simple text file located in the root of your repository that
    tells Git to ignore certain files and never commit them.'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '`.gitignore`是一个简单的文本文件，位于你的仓库根目录，它告诉Git忽略某些文件，永远不要提交它们。'
- en: 'If the file doesn''t already exist, create an empty text file called `.gitignore`
    in the repo root. Then append the path to your `.streamlit` folder. Since the
    `.streamlit` folder should also be in the repo root, you would simply add the
    following to `.gitignore`:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文件还不存在，在仓库根目录下创建一个名为`.gitignore`的空文本文件。然后添加你的`.streamlit`文件夹的路径。由于`.streamlit`文件夹也应该在仓库根目录下，你只需将以下内容添加到`.gitignore`中：
- en: '[PRE35]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: If you now do a `git add` or `git commit`, your `secrets.toml` file (and indeed,
    any file in the `.streamlit` directory) won't be committed.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在执行`git add`或`git commit`，你的`secrets.toml`文件（以及实际上`.streamlit`目录中的任何文件）都不会被提交。
- en: Note
  id: totrans-342
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'Git may already be tracking your .streamlit folder from before you added it
    to .gitignore. In this case, to remove it from Git''s index, you may have to enter
    this command:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: Git可能已经在你将其添加到.gitignore之前跟踪了你的`.streamlit`文件夹。在这种情况下，为了将其从Git的索引中删除，你可能需要输入以下命令：
- en: git rm -r --cached .streamlit/
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: git rm -r --cached .streamlit/
- en: 'At this point, your directory structure should look like the following:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你的目录结构应该看起来像以下这样：
- en: '[PRE36]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Add your changes to Git, commit them with a message, and then push them to
    GitHub. You could use the following commands:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 将你的更改添加到Git中，用消息提交，然后将它们推送到GitHub。你可以使用以下命令：
- en: '[PRE37]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Note that you can use the simple `git push` command above since you set the
    upstream of your branch to your remote repo earlier using `git push -u`.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你可以使用上面的简单 `git push` 命令，因为你之前已经使用 `git push -u` 将分支的上游设置为远程仓库。
- en: Your changes should now be reflected in your production Streamlit app. Or should
    it? Navigate to your app's public URL now to see what's shown in figure 5.10.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 你的更改现在应该反映在你的生产 Streamlit 应用程序中。或者，应该是这样吗？现在导航到你的应用程序的公共 URL，看看图 5.10 中显示的内容。
- en: '![image](../Images/05__image010.png)'
  id: totrans-351
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/05__image010.png)'
- en: Figure 5.10 Our app throws an error since it's unable to access an API key
  id: totrans-352
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.10 由于无法访问 API 密钥，我们的应用程序抛出了错误
- en: Looks like there's a final bit of configuration we have to do before your app
    works okay.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来在我们应用程序正常工作之前，我们还需要进行一些最后的配置。
- en: 5.4.3 Configuring secrets in Community Cloud
  id: totrans-354
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 5.4.3 在社区云中配置秘密
- en: We've taken pains to keep our API key secret but our app still needs it while
    it's running in prod. To enable this, we need to configure it in Streamlit Community
    Cloud where we've deployed our app.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经尽力保护我们的 API 密钥不被泄露，但我们的应用程序在运行时仍然需要它。为了启用此功能，我们需要在部署应用程序的 Streamlit 社区云中进行配置。
- en: 'We can do this in the *App settings* screen on Community Cloud. You can access
    this screen in two ways:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在社区云的 *应用设置* 屏幕上完成这项操作。你可以通过两种方式访问此屏幕：
- en: When you're on your deployed app's public URL, click "Manage app" on the bottom
    right (you can see it in figure 5.11), click the three vertical dots and then
    "Settings"
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你在已部署应用程序的公共 URL 上时，点击右下角的 "管理应用程序"（如图 5.11 所示），然后点击三个垂直点，再点击 "设置"。
- en: When logged in to Community Cloud on streamlit.io, click the three vertical
    dots next to your app in the list of apps, and click "Settings" from there.
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你在 streamlit.io 上的社区云登录时，点击应用程序列表中你应用程序旁边的三个垂直点，然后从那里点击 "设置"。
- en: Either way, once you have your App settings page open, click "Secrets" on the
    side panel to get to the screen shown in figure 5.11.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 无论哪种方式，一旦你打开了应用程序设置页面，点击侧面板上的 "秘密"，就可以进入图 5.11 中显示的屏幕。
- en: '![image](../Images/05__image011.png)'
  id: totrans-360
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/05__image011.png)'
- en: Figure 5.11 The secrets configuration screen on Streamlit Community Cloud
  id: totrans-361
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.11 Streamlit 社区云中的秘密配置屏幕
- en: In the textbox under "Secrets", simply copy and paste whatever you have in your
    `secrets.toml` file on your dev machine, and click "Save".
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 在 "秘密" 下的文本框中，只需复制并粘贴你在开发机器上的 `secrets.toml` 文件中的内容，然后点击 "保存"。
- en: With that, you're all done! Go to your app's public URL again. It should now
    be fully functional, as seen in figure 5.12.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，你就完成了所有操作！再次访问你应用程序的公共 URL。现在它应该完全可用，如图 5.12 所示。
- en: '![image](../Images/05__image012.png)'
  id: totrans-364
  prefs: []
  type: TYPE_IMG
  zh: '![image](../Images/05__image012.png)'
- en: Figure 5.12 Your fully-functional app, deployed to production
  id: totrans-365
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 5.12 已部署到生产环境的完整功能应用程序
- en: By now, you should be equipped to build and share useful Streamlit apps with
    a public audience. In the next chapter, we'll explore a more advanced app focused
    on working with data.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你应该已经准备好构建和与公众分享有用的 Streamlit 应用程序了。在下一章中，我们将探讨一个更高级的应用程序，该应用程序专注于数据处理。
- en: 5.5 Summary
  id: totrans-367
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 5.5 总结
- en: Deployment is the process of hosting and setting up your app so your intended
    users can access it.
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署是将你的应用程序托管并设置起来，以便目标用户可以访问的过程。
- en: There are multiple ways to deploy an app—you could simply run a server over
    your local network, set up a dedicated server, or use a cloud provider.
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署应用程序有多种方式——你可以在本地网络中简单地运行一个服务器，设置一个专用服务器，或者使用云服务提供商。
- en: You can deploy an unlimited number of apps to Streamlit Community Cloud for
    free, subject to some resource usage limits.
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以免费将无限数量的应用程序部署到 Streamlit 社区云，但受一些资源使用限制的约束。
- en: Deploying to Community Cloud involves creating a GitHub account, pushing your
    local code to a remote GitHub repo, and telling Community Cloud where to find
    your code.
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在社区云中部署涉及创建 GitHub 账户，将本地代码推送到远程 GitHub 仓库，并告诉社区云你的代码位置。
- en: You can connect to external services through the HTTP protocol using a library
    called `requests`.
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以通过名为 `requests` 的库使用 HTTP 协议连接到外部服务。
- en: In conjunction with a `secrets.toml` file located within a `.streamlit` folder,
    `st.secrets` can be used to keep your credentials safe.
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结合位于 `.streamlit` 文件夹中的 `secrets.toml` 文件，可以使用 `st.secrets` 来保护你的凭证安全。
- en: Make sure to never commit your `secrets.toml` file—prevent accidents by adding
    it to `.gitignore`. Instead, use the App settings page on Streamlit Community
    Cloud to hold in production the information you store in `secrets.toml` locally.
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保永远不要提交你的 `secrets.toml` 文件——通过将其添加到 `.gitignore` 来防止意外，而是在 Streamlit 社区云的应用设置页面上保存你在本地
    `secrets.toml` 中存储的信息。
- en: You can use a `requirements.txt` file to specify the versions of various Python
    libraries your app depends on.
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用`requirements.txt`文件来指定您的应用程序所依赖的各种Python库的版本。
- en: Deploying any changes you make to an already-deployed app on Community Cloud
    is as simple as pushing the changes to your remote GitHub repo.
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在社区云上部署您对已部署应用程序所做的任何更改，就像将更改推送到您的远程GitHub仓库一样简单。
