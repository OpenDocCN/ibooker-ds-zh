- en: 13 Experimenting with useTransition, useDeferredValue, and SuspenseList
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 13 尝试使用useTransition、useDeferredValue和SuspenseList
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Delaying UI updates with the `useTransition` hook
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`useTransition`钩子延迟 UI 更新
- en: Flagging inconsistent state and UI with the `isPending` Boolean
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`isPending`布尔值标记不一致的状态和 UI
- en: Using old and new values simultaneously with the `useDeferredValue` hook
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`useDeferredValue`钩子同时使用旧值和新值
- en: Managing multiple fallbacks with the `SuspenseList` component
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`SuspenseList`组件管理多个回退
- en: Understanding the promise of Concurrent Mode
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解并发模式的承诺
- en: '*Concurrent Mode* lets React work on multiple versions of our UI at once, showing
    older versions that are still fully interactive until newer versions are ready.
    This can mean that, for brief periods, the latest state doesn’t match the current
    UI in the browser and React gives us some hooks and components to manage the feedback
    we give to our users. The aim is to improve the user experience of our apps, making
    them feel more responsive and orchestrating updates so our users immediately understand
    what is stale, what is updating, and what is fresh.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*并发模式*让 React 同时处理我们 UI 的多个版本，显示仍然完全交互的旧版本，直到新版本准备就绪。这意味着在短暂的时间内，最新状态可能不匹配浏览器中的当前
    UI，React 给我们一些钩子和组件来管理我们向用户提供的反馈。目标是提高我们应用程序的用户体验，使它们感觉更响应，并编排更新，让我们的用户立即理解什么是过时的，什么是正在更新的，什么是新鲜的。'
- en: Concurrent Mode is still experimental, so the two new hooks we introduce in
    this chapter, `useTransition` and `useDeferredValue`, are experimental too. They
    give React permission to keep showing old UI or old values while components load
    new data or calculate new values. This helps us avoid receded states, whereby
    the UI falls back from a useful, interactive component to a previous loading state.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 并发模式仍然是实验性的，因此在本章中引入的两个新钩子`useTransition`和`useDeferredValue`也是实验性的。它们允许 React
    在组件加载新数据或计算新值时继续显示旧 UI 或旧值。这有助于我们避免退缩状态，即 UI 从一个有用的、交互式的组件回退到之前的加载状态。
- en: In the previous two chapters, we spent a lot of time wrapping components that
    could suspend in `Suspense` components, specifying appropriate fallbacks. As the
    number of `Suspense` components on a page increases, we risk infecting our users
    with fallback fever, making everything start spinning. One potential cure is the
    `SuspenseList` component, a soothing bandage that controls spinners, promoting
    them from a sickness to sign of health.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在前两个章节中，我们花费了大量时间包装可以在`Suspense`组件中挂起的组件，并指定适当的回退。随着页面中`Suspense`组件数量的增加，我们可能会让我们的用户感染上回退热，导致一切开始旋转。一种潜在的疗法是`SuspenseList`组件，这是一种舒缓的绷带，它控制着旋转器，将它们从疾病状态转变为健康状态的标志。
- en: Let’s explore these experimental solutions as we improve the Users page in the
    bookings app.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索这些实验性解决方案，随着我们在预订应用中改进用户页面。
- en: 13.1 Making smoother transitions between states
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.1 在状态之间实现更平滑的过渡
- en: When we first load the Users page, we see a spinner as the details for the current
    user load. That’s fine; we might expect some spinners when first loading a page.
    But when we subsequently select a new user for the first time, the UI goes back
    to showing a spinner, as you can see in figure 13.1\. (If necessary, start `json-server`
    with a delay to simulate slower connections.)
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们首次加载用户页面时，我们会看到一个旋转器，因为当前用户的详情正在加载。这是可以接受的；我们可能预期在首次加载页面时会有一些旋转器。但当我们第一次选择新用户时，UI
    会回到显示旋转器，如图 13.1 所示。（如果需要，可以延迟启动`json-server`来模拟较慢的连接。）
- en: '![](../Images/13-1.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/13-1.png)'
- en: Figure 13.1 Selecting a new user (Clarisse) in the list of users causes a spinner
    to replace the user details panel. This can be jarring; it feels like a backward
    step. We call it a receded state.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.1 在用户列表中选择新用户（Clarisse）会导致旋转器替换用户详情面板。这可能会让人感到震惊；感觉像是倒退了一步。我们称之为退缩状态。
- en: Waiting for data to load may be unavoidable, but we can try to improve the perceived
    responsiveness of the page by avoiding the display of spinners, and continuing
    to show the old data while the new data loads.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 等待数据加载可能是不可避免的，但我们可以通过避免显示旋转器，并在新数据加载时继续显示旧数据来尝试提高页面的感知响应速度。
- en: 'In this section, we explore our last two built-in hooks, `useTransition` and
    `useDeferredValue`, as ways of improving the user experience by delaying the update
    of the UI as data loads. To use these hooks, our app needs to be in Concurrent
    Mode, and for that we need the experimental version of React. Install it like
    this:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了最后两个内置钩子 `useTransition` 和 `useDeferredValue`，作为通过延迟 UI 更新来改善用户体验的方法。要使用这些钩子，我们的应用需要处于并发模式，为此我们需要
    React 的实验版本。按照以下方式安装它：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If there is a problem with React Query insisting on a stable version of React,
    you could uninstall React Query before installing React’s experimental release.
    Then reinstall React Query with the `-force` flag, like this:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 React Query 坚持要使用稳定版本的 React 存在问题，您可以在安装 React 的实验版本之前卸载 React Query。然后，使用
    `-force` 标志重新安装 React Query，如下所示：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Then, update index.js to render the app as in the following listing.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，更新 index.js 以渲染应用，如下所示。
- en: 'Branch: 1301-use-transition, File: /src/index.js'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 分支：1301-use-transition，文件：/src/index.js
- en: Listing 13.1 Enabling Concurrent Mode
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 13.1 启用并发模式
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ Use the element with ID “root” as the root of the app.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用具有 ID “root” 的元素作为应用的根。
- en: ❷ Render the App component into the root element.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将 App 组件渲染到根元素中。
- en: 13.1.1 Avoiding receded states with useTransition
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.1.1 使用 useTransition 避免回退状态
- en: Figure 13.2 shows an improved UI experience when selecting a new user on the
    Users page. While viewing the details for Mark, we’ve clicked Clarisse in the
    list of users, but the user details panel on the right continues to show the old
    UI, Mark’s information, rather than dropping back to a spinner.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.2 展示了在用户页面选择新用户时的改进 UI 体验。在查看 Mark 的详细信息时，我们已点击用户列表中的 Clarisse，但右侧的用户详情面板继续显示旧
    UI，Mark 的信息，而不是回退到加载指示器。
- en: '![](../Images/13-2.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/13-2.png)'
- en: Figure 13.2 A new user (Clarisse) is selected, but instead of immediately showing
    a receded loading spinner, the UI continues to show the old user (Mark).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.2 选择了一个新用户（Clarisse），但不是立即显示回退的加载指示器，UI 继续显示旧用户（Mark）。
- en: The following listing shows how to use the `useTransition` hook to give React
    permission to display old UI if a change of state (switching the user, for example)
    causes a child component to suspend.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表展示了如何使用 `useTransition` 钩子给予 React 显示旧 UI 的权限，如果状态改变（例如切换用户）导致子组件挂起。
- en: 'Branch: 1301-use-transition, File: /src/components/Users/UsersPage.js'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 分支：1301-use-transition，文件：/src/components/Users/UsersPage.js
- en: Listing 13.2 Using a transition to improve UX on `UsersPage`
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 13.2 在 `UsersPage` 上使用转换来改善 UX
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ Import the useTransition hook.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 导入 useTransition 钩子。
- en: ❷ Get a transition function, startTransition.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 获取转换函数，startTransition。
- en: ❸ Wrap the user state change in the transition.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将用户状态改变包裹在转换中。
- en: ❹ Show a spinner while the first user loads.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 在第一个用户加载时显示加载指示器。
- en: To reinforce the fact that this is all experimental, the hook has an `unstable`
    prefix, so we import `unstable_useTransition` from the `react` package. We rename
    it `useTransition`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了强调这全部都是实验性的，钩子有一个 `unstable` 前缀，因此我们从 `react` 包中导入 `unstable_useTransition`，并将其重命名为
    `useTransition`。
- en: 'The `useTransition` hook returns an array whose first element is a function
    we use to wrap state changes that might cause components to suspend. We assign
    the function to the `startTransition` variable:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`useTransition` 钩子返回一个数组，其第一个元素是一个我们用来包裹可能使组件挂起的状态改变的函数。我们将该函数分配给 `startTransition`
    变量：'
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Our state change is in the `switchUser` function. Switching to a new user might
    cause the `UserDetails` component to suspend if React Query has not yet loaded
    that user’s data. Wrapping the state change in `startTransition` tells React to
    keep showing the old UI rather than the `Suspense` fallback, until the data loads.
    If there isn’t any old UI—the component has not yet mounted—React will show the
    `Suspense` fallback while waiting for data:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的状态改变发生在 `switchUser` 函数中。切换到新用户可能会使 `UserDetails` 组件挂起，如果 React Query 尚未加载该用户的数据。将状态改变包裹在
    `startTransition` 中告诉 React 保持显示旧 UI 而不是 `Suspense` 回退，直到数据加载完成。如果没有旧 UI（组件尚未挂载），React
    将在等待数据时显示 `Suspense` 回退：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Not falling back to a spinner on state changes is an improvement as long as
    the data for the new state doesn’t take long to load. If it does, the user is
    left in limbo, staring at the old UI. Has the app crashed? We need to give them
    some feedback to say the app is busy loading data.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在新状态的数据加载时间不长的情况下，不回退到加载指示器是一个改进。如果加载时间较长，用户就会陷入困境，盯着旧 UI。应用崩溃了吗？我们需要给他们一些反馈，告诉他们应用正在加载数据。
- en: 13.1.2 Giving users feedback with isPending
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.1.2 使用 isPending 给用户反馈
- en: The `useTransition` hook lets React show old UI while the state is changing.
    But inconsistent UIs might lead to confusion if they last too long. It would be
    good to give our users some feedback that a change is happening even if the UI
    continues to show some old values.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`useTransition` 钩子允许 React 在状态变化时显示旧 UI。但如果它们持续太长时间，不一致的 UI 可能会导致困惑。如果 UI 继续显示一些旧值，那么给我们的用户提供一些变化正在发生的反馈将会很好。'
- en: Something like figure 13.3 is what we’re after; we’ve clicked a new user, Clarisse,
    in the users list, but our transition has kept the details for the old user, Mark,
    on the screen while Clarisse’s information loads. We reduce the opacity of the
    user details panel to show that the details are stale.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们追求的是类似于图 13.3 的东西；我们在用户列表中点击了新用户，Clarisse，但我们的转换仍然保留了旧用户 Mark 的详细信息在屏幕上，同时
    Clarisse 的信息正在加载。我们降低用户详细信息面板的不透明度以显示详细信息已过时。
- en: '![](../Images/13-3.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/13-3.png)'
- en: Figure 13.3 During a transition, the `isPending` value is used to set the class
    of the user details panel, allowing its opacity to be reduced via CSS. We don’t
    have a receded spinner but do indicate a transition.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.3 在转换期间，使用 `isPending` 值设置用户详细信息面板的类，允许通过 CSS 减少其不透明度。我们没有缩小的旋转器，但确实表示了转换。
- en: 'Helpfully, `useTransition` also returns a Boolean value in its array to indicate
    a transition is ongoing. We can assign the Boolean to a local variable, `isPending`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 有助于，`useTransition` 还在其数组中返回一个布尔值，以指示转换正在进行。我们可以将布尔值分配给一个局部变量，`isPending`：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We can then use `isPending` to set a class name on the user details panel, for
    example, as shown in listing 13.3 for `UsersPage` and listing 13.4 for `UserDetails`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用 `isPending` 在用户详细信息面板上设置一个类名，例如，如列表 13.3 中的 `UsersPage` 和列表 13.4 中的
    `UserDetails` 所示。
- en: 'Branch: 1302-is-pending, File: /src/components/Users/UsersPage.js'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 分支：1302-is-pending，文件：/src/components/Users/UsersPage.js
- en: Listing 13.3 Destructuring an `isPending` value to set a property during transitions
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 13.3 在转换期间解构 `isPending` 值以设置属性
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ Assign pending flag to a local variable.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将挂起标志分配给局部变量。
- en: ❷ Start the transition.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 开始转换。
- en: ❸ Pass the pending flag to UserDetails.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将挂起标志传递给 UserDetails。
- en: 'Branch: 1302-is-pending, File: /src/components/Users/UserDetails.js'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 分支：1302-is-pending，文件：/src/components/Users/UserDetails.js
- en: Listing 13.4 Using `isPending` to set a class name in `UserDetails`
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 13.4 在 `UserDetails` 中使用 `isPending` 设置类名
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ Get isPending flag from props.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 从 props 获取 isPending 标志。
- en: ❷ Use isPending flag to conditionally set the class.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用 isPending 标志有条件地设置类。
- en: The `UserDetails` component for the new `userID` value will suspend while it
    fetches the user’s data. While the transition takes place, however, React will
    continue to use the UI for the old user but will re-render it with `isPending`
    set to `true`. React manages two versions of the same component concurrently.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 对于新的 `userID` 值，`UserDetails` 组件将在获取用户数据时挂起。然而，在转换进行时，React 将继续使用旧用户的 UI，但会将其重新渲染为
    `isPending` 设置为 `true`。React 同时管理同一组件的两个版本。
- en: 13.1.3 Integrating transitions with common components
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.1.3 将转换与常见组件集成
- en: When Concurrent Mode and its APIs become stable, we would expect to use transitions
    a lot to smooth switching states for potentially longer-running updates. But rather
    than inserting calls to `useTransition` all over the codebase, the React docs
    suggest we integrate the calls into our design system. Our buttons, for example,
    could wrap their event handlers in transitions.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当并发模式和其 API 变得稳定时，我们预计会大量使用转换来平滑可能运行时间较长的更新状态。但与其在代码库的各个地方插入 `useTransition`
    调用，React 文档建议我们将这些调用集成到我们的设计系统中。例如，我们的按钮可以将其事件处理程序包裹在转换中。
- en: Let’s try using transition-ready buttons in our `UsersList` component; we can
    remove the transition and `isPending` code from `UsersPage` and `UserDetails`.
    Figure 13.4 shows what will happen when we click a new user, Clarisse. The button
    starts the transition to Clarisse and uses the `isPending` state to give feedback,
    showing spinners for the loading user. While the transition is ongoing, the old
    user, Mark, is still highlighted and his details are shown on the right.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试在我们的 `UsersList` 组件中使用准备好的转换按钮；我们可以从 `UsersPage` 和 `UserDetails` 中移除转换和
    `isPending` 代码。图 13.4 显示了我们点击新用户 Clarisse 时会发生什么。按钮开始转换到 Clarisse，并使用 `isPending`
    状态来提供反馈，显示正在加载用户的旋转器。在转换进行时，旧用户 Mark 仍然被突出显示，并且他的详细信息显示在右侧。
- en: '![](../Images/13-4.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/13-4.png)'
- en: Figure 13.4 The buttons in the users list show spinners when their transition
    is underway.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.4 用户列表中的按钮在其转换进行时显示旋转器。
- en: The following listing shows our new UI component, `ButtonPending`. It renders
    a button but also encapsulates the transition code. Clicking the button starts
    a transition, and spinners are shown by the button while the transition is in
    a pending state.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表展示了我们新的 UI 组件 `ButtonPending`。它渲染一个按钮，同时也封装了过渡代码。点击按钮开始过渡，在过渡处于挂起状态时，按钮会显示旋转器。
- en: 'Branch: 1303-button-pending, File: /src/components/UI/ButtonPending.js'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 分支：1303-button-pending，文件：/src/components/UI/ButtonPending.js
- en: Listing 13.5 A `ButtonPending` component that uses transitions
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 13.5 使用过渡的 `ButtonPending` 组件
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ❶ Pass in a handler that needs a transition.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 传递一个需要过渡的处理程序。
- en: ❷ Wrap the handler in a transition.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在处理程序周围包裹一个过渡。
- en: ❸ Use the pending flag to indicate a transition is in progress.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用挂起标志来指示过渡正在进行中。
- en: Replace the `button` in the `UsersList` component with `ButtonPending` (literally
    swap the names). Using the special button enables transitions! The CSS is set
    to fade in the spinners after a few hundred milliseconds; for quickly loaded data,
    you won’t see the spinners.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `UsersList` 组件中的 `button` 替换为 `ButtonPending`（实际上交换名称）。使用这个特殊按钮可以启用过渡！CSS
    设置在几百毫秒后淡入旋转器；对于快速加载数据，您将看不到旋转器。
- en: 13.1.4 Holding on to old values with useDeferredValue
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.1.4 使用 `useDeferredValue` 保持旧值
- en: 'There’s one more tool we’ll cover in our introduction to concurrent user interfaces:
    the `useDeferredValue` hook. We maintain old and new versions of a value and use
    both in our UI. Figure 13.5 shows what happens when we switch the user from Mark
    to Clarisse. The list of users immediately highlights the new user and shows a
    spinner, while the details panel continues to show details for the old user.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们介绍并发用户界面的过程中，我们还将介绍一个工具：`useDeferredValue` 钩子。我们维护值的旧版本和新版本，并在我们的 UI 中使用这两个版本。图
    13.5 展示了当我们从 Mark 切换到 Clarisse 用户时会发生什么。用户列表立即突出显示新用户，并显示一个旋转器，而详情面板继续显示旧用户的详细信息。
- en: '![](../Images/13-5.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/13-5.png)'
- en: Figure 13.5 The `UsersList` shows the latest selection (Clarisse) with inline
    spinners, but the user details panel still shows the old user (Mark), the deferred
    value.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.5 `UsersList` 显示了最新的选择（Clarisse）和内联旋转器，但用户详情面板仍然显示旧用户（Mark），即延迟值。
- en: If switching to a new user, Clarisse, causes a delay in rendering the details
    panel, it will continue to use the old value, Mark, until the UI can be rendered
    for the new value. The new value has been *deferred*. The following listing updates
    `UsersPage` again, this time to pass a deferred value for the user to `UserDetails`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果切换到新用户 Clarisse 导致详情面板渲染延迟，它将继续使用旧值 Mark，直到新值的 UI 可以渲染。新值已被**延迟**。以下列表更新了
    `UsersPage`，这次是为用户传递给 `UserDetails` 的延迟值。
- en: 'Branch: 1304-deferred-value, File: /src/components/Users/UsersPage.js'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 分支：1304-deferred-value，文件：/src/components/Users/UsersPage.js
- en: Listing 13.6 Passing a deferred value to `UserDetails`
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 13.6 将延迟值传递给 `UserDetails`
- en: '[PRE10]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '❶ Track the user value: return the old if the new delays rendering.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 跟踪用户值：如果新值延迟渲染，则返回旧值。
- en: ❷ Create a pending flag that’s true if the deferred value is stale.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 创建一个表示延迟值过时的标志。
- en: ❸ Update the user value.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 更新用户值。
- en: ❹ Let the list know the new user.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 让列表知道新用户。
- en: ❺ Let the list know its user is inconsistent with UserDetails.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 让列表知道其用户信息与 `UserDetails` 不一致。
- en: ❻ Show the old user details while waiting for the new.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 在等待新用户信息的同时显示旧用户信息。
- en: ❼ Let UserDetails know its user is stale.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 让 `UserDetails` 知道其用户信息已过时。
- en: '`UsersPage` gets the `useDeferredValue` hook to manage old and new user values.
    We call `useDeferredValue` with a value to track, like this:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`UsersPage` 获取 `useDeferredValue` 钩子来管理旧用户和新用户值。我们使用以下方式调用 `useDeferredValue`
    来跟踪一个值：'
- en: '[PRE11]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The hook tracks a value. If the value changes from an old value to a new one,
    the hook can return either of the values. If React can successfully render a new
    UI with the new value, and no children suspend or delay rendering, the hook returns
    the new value, and React updates the UI. If the new value causes React to wait
    for a process to complete before finishing rendering, the hook returns the old
    value, and React displays the UI with the old value (while working in memory on
    the UI with the new value). `deferredValue` starts as `undefined`, so we add the
    `||` `user` at the end to make sure we use the initial `user` value as soon as
    it is set:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 该钩子跟踪一个值。如果值从旧值更改为新值，钩子可以返回任一值。如果 React 可以成功使用新值渲染新的 UI，并且没有子组件挂起或延迟渲染，则钩子返回新值，React
    更新 UI。如果新值导致 React 在完成渲染之前等待某个过程完成，则钩子返回旧值，React 使用旧值显示 UI（同时在内存中处理新值的 UI）。`deferredValue`
    初始为 `undefined`，因此我们在末尾添加 `||` `user` 以确保一旦设置初始 `user` 值就立即使用：
- en: '[PRE12]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In listing 13.6, we pass `UsersList` the newly selected user value while passing
    `UserDetails` the potentially stale `deferredUser` value:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表 13.6 中，我们向 `UsersList` 传递新选定的用户值，同时向 `UserDetails` 传递可能过时的 `deferredUser`
    值：
- en: '[PRE13]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `UserDetails` component continues to show the previous user while the new
    user loads. While the two user values are inconsistent, we set the `isPending`
    flag to `true`; `UsersList` will show spinners, and `UserDetails` will reduce
    its opacity, giving extra visual feedback to draw attention to the inconsistent
    UI state.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `UserDetails` 组件在加载新用户信息时，会继续显示之前用户的信息。当两个用户值不一致时，我们将 `isPending` 标志设置为 `true`；`UsersList`
    将显示加载指示器，而 `UserDetails` 将降低其不透明度，以提供额外的视觉反馈，以吸引注意不一致的用户界面状态。
- en: 13.2 Using SuspenseList to manage multiple fallbacks
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.2 使用 SuspenseList 管理多个后备方案
- en: When we have multiple `Suspense` components in our UI, it can be useful to have
    a little more control over if and when to show their fallbacks; we don’t want
    a full circus of spinners and acrobatic components jumping around the screen.
    We need a ringmaster to whip them into shape, introducing the pieces in a well-ordered
    manner. That ringmaster is the `SuspenseList` component.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在 UI 中有多个 `Suspense` 组件时，对何时以及如何显示它们的后备方案有更多控制可能很有用；我们不希望屏幕上出现满载的旋转器和杂技组件。我们需要一个马戏团老板来指挥它们，以有序的方式介绍各个部分。这个马戏团老板就是
    `SuspenseList` 组件。
- en: Say the Users page now includes the bookings for the selected user and any to-dos
    they’ve been assigned. The UI might be something like figure 13.6 with the user
    info, bookings, and to-dos displayed as part of the user details panel.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 假设用户页面现在包括所选用户的预订以及分配给他们的任何待办事项。UI 可能类似于图 13.6，其中用户信息、预订和待办事项作为用户详细信息面板的一部分显示。
- en: '![](../Images/13-6.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/13-6.png)'
- en: Figure 13.6 The user details now include bookings and to-dos.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.6 用户详细信息现在包括预订和待办事项。
- en: In this section, we first update `UserDetails` to show the new information within
    separate `Suspense` components. Then we wrap the `Suspense` components inside
    a `SuspenseList` to better control the order in which we display their fallbacks.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们首先更新 `UserDetails` 以在单独的 `Suspense` 组件中显示新信息。然后我们将 `Suspense` 组件包裹在一个
    `SuspenseList` 中，以更好地控制显示其后备方案的顺序。
- en: 13.2.1 Showing data from multiple sources
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.2.1 显示来自多个来源的数据
- en: We want the `UserDetails` component to display user bookings and to-dos. While
    the data loads, we might see something like figure 13.7 with fallback messages,
    “Loading user bookings . . . ” and “Loading user todos . . .” displayed by `Suspense`
    components.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望 `UserDetails` 组件显示用户预订和待办事项。当数据加载时，我们可能会看到类似于图 13.7 的内容，其中 `Suspense` 组件显示后备信息，“正在加载用户预订……”和“正在加载用户待办事项……”。
- en: '![](../Images/13-7.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/13-7.png)'
- en: Figure 13.7 Showing fallbacks for loading bookings and to-dos
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.7 显示加载预订和待办事项的后备方案
- en: Listing 13.7 adds `UserBookings` and `UserTodos` components to the `UserDetails`
    UI. Each loads its own data, so we wrap them in `Suspense` components with the
    appropriate fallback messages. Check the repo for the implementation of the new
    components; it’s not important for the current discussion.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 13.7 向 `UserDetails` UI 添加 `UserBookings` 和 `UserTodos` 组件。每个组件都加载自己的数据，因此我们将它们包裹在具有适当后备信息的
    `Suspense` 组件中。请检查仓库中新组件的实现；对于当前讨论来说这不重要。
- en: 'Branch: 1305-multi-suspense, File: /src/components/Users/UserDetails.js'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 分支：1305-multi-suspense，文件：/src/components/Users/UserDetails.js
- en: Listing 13.7 Including bookings and to-dos in `UserDetails`
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 13.7 在 `UserDetails` 中包含预订和待办事项
- en: '[PRE14]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: ❶ Include a Suspense fallback for the bookings.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 为预订添加 Suspense 后备方案。
- en: ❷ Show the bookings.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 显示预订信息。
- en: ❸ Include a Suspense fallback for the to-dos.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 包含一个Suspense后备用于待办事项。
- en: ❹ Show the to-dos.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 显示待办事项。
- en: 'A UI circus problem might arise because we can’t predict how long each new
    component will take to load its data. Figure 13.8 shows what happens if the to-dos
    load first: the to-do list is rendered, but the fallback for the bookings is still
    showing above the list. When the bookings finally load, the to-dos, which we might
    be trying to read, will be shunted down the page by the incoming bookings.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们无法预测每个新组件加载数据需要多长时间，可能会出现一个UI马戏团问题。图13.8显示了如果待办事项首先加载会发生什么：待办事项列表被渲染，但预订的后备仍然显示在列表上方。当预订最终加载时，我们可能正在尝试阅读的待办事项将被即将到来的预订向下推到页面底部。
- en: '![](../Images/13-8.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/13-8.png)'
- en: Figure 13.8 The to-dos are showing, but the bookings are still loading. Once
    the bookings load, they’ll push the to-dos down.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.8待办事项正在显示，但预订仍在加载。一旦预订加载完成，它们将把待办事项向下推。
- en: If we can either show both components at the same time or ensure that the bookings
    are displayed first, we’ll improve the user experience. Let’s see how `SuspenseList`
    helps us send the circus packing.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们可以同时显示两个组件，或者确保预订首先显示，我们将提高用户体验。让我们看看`SuspenseList`如何帮助我们让马戏团离开。
- en: 13.2.2 Controlling multiple fallbacks with SuspenseList
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.2.2 使用SuspenseList控制多个后备
- en: To avoid shifting components down when components above them render more slowly,
    we could specify that the components appear in order, top-down, even if the data
    for the later components loads first. For the Users page, we want to display the
    user’s bookings first, as shown in figure 13.9, even if the to-dos data could
    load more quickly.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免当上面的组件渲染较慢时组件向下移动，我们可以指定组件按顺序、自上而下显示，即使较晚组件的数据首先加载。对于用户页面，我们希望首先显示用户的预订，如图13.9所示，即使待办事项的数据可能加载得更快。
- en: '![](../Images/13-9.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/13-9.png)'
- en: Figure 13.9 With `SuspenseList`, we can set the reveal order to force the bookings
    to appear first.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.9使用`SuspenseList`，我们可以设置显示顺序以强制预订首先显示。
- en: 'We’ll use a `SuspenseList` component to manage our fallbacks. It’s currently
    imported as `unstable_SuspenseList`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`SuspenseList`组件来管理我们的后备。它目前被导入为`unstable_SuspenseList`：
- en: '[PRE15]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The following listing shows the `UserBookings` and `UserTodos` components and
    their fallbacks wrapped in a `SuspenseList` with `revealOrder` set to `forwards`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了`UserBookings`和`UserTodos`组件及其后备组件，它们被包裹在一个设置了`revealOrder`为`forwards`的`SuspenseList`中。
- en: 'Branch: 1306-suspense-list, File: /src/components/Users/UserDetails.js'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 分支：1306-suspense-list，文件：/src/components/Users/UserDetails.js
- en: Listing 13.8 Wrap the two `Suspense` components in a `SuspenseList`
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 列表13.8将两个`Suspense`组件包裹在`SuspenseList`中
- en: '[PRE16]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: ❶ Wrap the Suspense components in a SuspenseList.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将Suspense组件包裹在SuspenseList中。
- en: ❷ Specify the revealOrder.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 指定显示顺序。
- en: We could also set `revealOrder` to `backwards` to show the to-dos first, or
    `together` to show bookings and to-dos at the same time.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以将`revealOrder`设置为`backwards`以首先显示待办事项，或者设置为`together`以同时显示预订和待办事项。
- en: 'We might not want multiple fallbacks to show, and `SuspenseList` also has a
    `tail` prop that if set to `collapsed` shows only one fallback at a time:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能不希望显示多个后备，`SuspenseList`还有一个`tail`属性，如果设置为`collapsed`，则一次只显示一个后备：
- en: '[PRE17]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Figure 13.10 shows the user details panel when we set the `tail` prop on the
    `SuspenseList`. The user details panel shows just the “Loading user bookings .
    . . ” fallback. The “Loading user todos . . . ” fallback, as in figure 13.9, appears
    only after the bookings have rendered.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.10显示了当我们设置`SuspenseList`上的`tail`属性时用户详情面板。用户详情面板只显示“正在加载用户预订...”的后备。如图13.9所示，“正在加载用户待办事项...”的后备只在预订渲染后出现。
- en: '![](../Images/13-10.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/13-10.png)'
- en: 'Figure 13.10 Only one fallback is shown at a time: first the fallback for the
    bookings and then the fallback for the to-dos.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.10一次只显示一个后备：首先显示预订的后备，然后显示待办事项的后备。
- en: '`SuspenseList` is still experimental, and the ways in which it will help us
    orchestrate loading states will evolve in the coming months. Our Users page example
    could be improved with some judicious prefetching of data and a more careful combination
    of all of the techniques used in this chapter. But the examples should have given
    you a good feel for what’s arriving in React soon.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`SuspenseList`仍然是实验性的，它将帮助我们编排加载状态的方式将在接下来的几个月内演变。我们的用户页面示例可以通过一些明智的数据预取和更仔细地组合本章中使用的所有技术来改进。但示例应该已经让你对React即将到来的一些新功能有了很好的感觉。'
- en: 13.3 Concurrent Mode and the future
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 13.3 并发模式和未来
- en: With Concurrent Mode, React can work on rendering multiple versions of the UI
    in memory at the same time and update the DOM with only the most appropriate version
    for the current state, which might be in the process of change, waiting for updates
    that take time. This flexibility lets React interrupt rendering if higher-priority
    updates, like user interaction with form fields, are required. This helps keep
    the app responsive and improves the perceived performance of the app.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 使用并发模式，React 可以在内存中同时渲染多个 UI 版本，并且只使用最适合当前状态的版本来更新 DOM，这可能是一个正在变化的过程，等待耗时的更新。这种灵活性允许
    React 在需要更高优先级更新，如用户与表单字段交互时，中断渲染。这有助于保持应用响应，并提高应用的感知性能。
- en: Being able to prepare updates in memory also gives React the ability to switch
    to an updated UI only when it has enough of it ready, whether that’s a new page,
    a filtered list, or details for a user. The old UI can still be updated to display
    pending indicators to let the user know that change is afoot. Avoiding receded
    states and jarring spinners can make interacting with our apps feel smoother,
    helping users to stay focused on their tasks rather than frustrated with the app.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 能够在内存中准备更新也使 React 能够在准备好足够的新 UI 时切换到更新后的 UI，无论是新页面、筛选后的列表还是用户的详细信息。旧 UI 仍然可以更新以显示挂起指示器，让用户知道正在发生变更。避免回退状态和令人不适的加载指示器可以使与我们的应用交互感觉更平滑，帮助用户专注于他们的任务，而不是对应用感到沮丧。
- en: Concurrent Mode paves the way for more targeted, intentional loading of code,
    data, and resources, integrating server-side rendering more smoothly with the
    hydration of client-side components, the timely injection of resources to make
    components responsive just in time for user interaction.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 并发模式为更精确、有目的的代码、数据和资源加载铺平了道路，更平滑地整合了服务器端渲染与客户端组件的激活，及时注入资源，以便在用户交互时使组件即时响应。
- en: Figure 13.11 shows many of the features that Concurrent Mode promises. It’s
    taken from the React documentation at [http://mng.bz/7VRe](https://shortener.manning.com/7VRe)
    and includes a third mode, Blocking Mode, an intermediate step in adopting Concurrent
    Mode, that you can read about there, as well as the features we’ve covered in
    part 2 of this book.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.11 展示了并发模式所承诺的许多特性。它来自 React 文档，网址为 [http://mng.bz/7VRe](https://shortener.manning.com/7VRe)，其中包括第三种模式，阻塞模式，这是采用并发模式的一个中间步骤，你可以在那里了解更多信息，以及本书第二部分中我们讨论的特性。
- en: '![](../Images/13-11.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.11](../Images/13-11.png)'
- en: Figure 13.11 A feature comparison of Concurrent Mode, Blocking Mode, and Legacy
    Mode from the React docs page on adopting Concurrent Mode
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.11 来自 React 文档页面关于采用并发模式的并发模式、阻塞模式和传统模式的特性比较
- en: Summary
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Remember, these APIs are experimental and are likely to change.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记住，这些 API 是实验性的，可能会发生变化。
- en: 'Enable Concurrent Mode by updating how your app is initially rendered to the
    browser. Use `ReactDOM.unstable_createRoot` and `render`, like this:'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过更新应用最初渲染到浏览器的方式启用并发模式。使用 `ReactDOM.unstable_createRoot` 和 `render`，如下所示：
- en: '[PRE18]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Delay rendering of new UI that’s waiting for data by calling the `useTransition`
    hook:'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过调用 `useTransition` 钩子延迟等待数据的新的 UI 的渲染：
- en: '[PRE19]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Wrap state changes that might cause components to suspend in the `startTransition`
    function. React can continue to show the old UI until the new UI is ready.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将可能导致组件暂停的状态更改包装在 `startTransition` 函数中。React 可以继续显示旧 UI，直到新 UI 准备好。
- en: '[PRE20]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Use the `isPending` Boolean, the second element in the array that `useTransition`
    returns, to update the old UI, letting the user know that the state is updating.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `isPending` 布尔值，即 `useTransition` 返回数组中的第二个元素，来更新旧 UI，让用户知道状态正在更新。
- en: Create design system components like custom buttons that automatically transition
    from one state to another by wrapping their event handlers with `startTransition`.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建设计系统组件，如自定义按钮，通过将事件处理程序包装在 `startTransition` 中来自动从一个状态过渡到另一个状态。
- en: 'When updating state, continue to use old values if the new value causes a delay,
    by calling the `useDeferredValue` hook to track the value:'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在更新状态时，如果新值导致延迟，继续使用旧值，通过调用 `useDeferredValue` 钩子来跟踪值：
- en: '[PRE21]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Components that can render immediately can use the new state, while those that
    might suspend can use the deferred value:'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以立即渲染的组件可以使用新状态，而可能暂停的组件可以使用延迟值：
- en: '[PRE22]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Use the `SuspenseList` component to manage the order in which `Suspense` components
    display their fallbacks. Specify the `revealOrder` as `forwards`, `backwards`,
    or `together`, and, optionally, show only one fallback at a time by setting the
    `tail` prop.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `SuspenseList` 组件来管理 `Suspense` 组件显示其后备内容的顺序。指定 `revealOrder` 为 `forwards`、`backwards`
    或 `together`，并且可选地通过设置 `tail` 属性一次只显示一个后备内容。
- en: '[PRE23]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Remember, these APIs are experimental and are likely to change.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记住，这些 API 是实验性的，很可能会发生变化。
