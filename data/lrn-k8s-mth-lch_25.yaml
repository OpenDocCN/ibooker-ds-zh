- en: 21 Running serverless functions in Kubernetes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 21 在 Kubernetes 中运行无服务器函数
- en: Welcome to the last full chapter of the book! We’re going to finish on a high
    note, learning how to turn your Kubernetes cluster into a serverless platform.
    Lots of serverless platforms are in the cloud, but they’re mostly bespoke systems,
    and you can’t easily move your AWS Lambda components to Azure Functions. The extensibility
    of Kubernetes makes it easy to deploy a serverless runtime in the cluster, which
    is just as portable as all your other apps. We’ll cover some open source projects
    in this chapter that give you a very Lambda—like experience, where you focus on
    the code and the platform packages and it deploys it for you. Serverless functions
    run as containers in Pods, so you manage them in the usual way, but the platform
    adds some higher-level abstractions.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到本书的最后一章！我们将以高调结束，学习如何将你的 Kubernetes 集群转变为无服务器平台。许多无服务器平台都在云中，但它们大多是定制系统，你无法轻易地将
    AWS Lambda 组件迁移到 Azure Functions。Kubernetes 的可扩展性使得在集群中部署无服务器运行时变得容易，这与其他所有应用程序一样具有可移植性。在本章中，我们将介绍一些开源项目，它们为你提供了非常类似
    Lambda 的体验，你只需关注代码，平台会为你打包和部署。无服务器函数作为容器在 Pods 中运行，因此你以通常的方式管理它们，但平台添加了一些高级抽象。
- en: 'Several serverless platforms exist in the Kubernetes ecosystem, and all take
    slightly different approaches. One of the most popular is the Knative project
    from Google, but it has an unusual workflow: you need to package your functions
    in Docker images yourself, and then Knative deploys them for you. I much prefer
    the code-first approach, where you bring your code and the platform runs it in
    a container; that fits the goal of a simple workflow for serverless functions.
    In this chapter, we’ll use Kubeless, another popular platform, and we’ll also
    see how to abstract the serverless platform itself with the Serverless project.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 生态系统中存在多个无服务器平台，它们采取了略微不同的方法。最受欢迎的是来自 Google 的 Knative 项目，但它有一个不寻常的工作流程：你需要自己打包函数到
    Docker 镜像中，然后 Knative 会为你部署它们。我更倾向于代码优先的方法，即你带来代码，平台在容器中运行它；这符合无服务器函数简单工作流程的目标。在本章中，我们将使用另一个流行的平台
    Kubeless，我们还将看到如何使用 Serverless 项目抽象无服务器平台本身。
- en: 21.1 How serverless platforms work in Kubernetes
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 21.1 Kubernetes 中无服务器平台的工作原理
- en: 'What does serverless mean in the context of Kubernetes? You obviously have
    servers involved because they’re the nodes in your cluster. It’s really about
    removing all the ceremony between writing code and having it running in a Pod—cutting
    out all the overhead in compiling the app, building a container image, designing
    the deployment, and crafting YAML specs. AWS Lambda and Azure Functions have a
    command-line interface (CLI) where you upload your code file and the function
    starts running somewhere in the cloud. Serverless for Kubernetes gives you the
    same workflow, but you know where your function is running: in a Pod in your own
    cluster.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 的背景下，无服务器意味着什么？显然，服务器是集群中的节点，因此肯定涉及服务器。这实际上是在编写代码和将其运行在 Pod 中之间去除所有仪式——消除了编译应用程序、构建容器镜像、设计部署和编写
    YAML 规范的所有开销。AWS Lambda 和 Azure Functions 都有一个命令行界面 (CLI)，你可以上传代码文件，函数就会在云中的某个地方开始运行。Kubernetes
    的无服务器为你提供了相同的流程，但你确切地知道函数运行的位置：在你的集群中的 Pod 中。
- en: 'The Kubeless workflow is particularly neat: you take your source code file
    and deploy it as a function using the Kubeless CLI. There are no additional artifacts
    to describe your function, and the CLI creates a custom resource with all the
    details and the source code. The Kubeless controller acts on the function resource
    and creates a Pod to run the function. You can trigger the function manually through
    the CLI, or you can create a permanent trigger so the function listens for HTTP
    requests, subscribes to a message queue, or runs on a schedule. Figure 21.1 shows
    the architecture of a Kubeless function.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Kubeless 工作流程特别简洁：你只需将源代码文件部署为函数，使用 Kubeless CLI 即可。无需额外描述函数的工件，CLI 会创建一个包含所有细节和源代码的自定义资源。Kubeless
    控制器作用于函数资源，并创建一个 Pod 来运行该函数。你可以通过 CLI 手动触发函数，或者创建一个永久触发器，使函数能够监听 HTTP 请求、订阅消息队列或按计划运行。图
    21.1 展示了 Kubeless 函数的架构。
- en: '![](../Images/21-1.jpg)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/21-1.jpg)'
- en: Figure 21.1 The serverless function with Kubeless turns your code into a running
    Pod.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 图 21.1 使用 Kubeless 的无服务器函数将你的代码转换为正在运行的 Pod。
- en: 'This workflow means you run one command to get a code file running in a Pod
    and another command if you want to expose it over HTTP. It’s perfect for webhooks,
    integration components, and simple APIs. Other serverless platforms support Kubernetes
    and work in similar ways: Nuclio, OpenWhisk, and Fn Project all take your code,
    package it into a container to run, and support multiple triggers to invoke the
    function. They use standard resources, like Pods and Services, and standard patterns,
    like ingress controllers and message queues. In this chapter, you’ll use Kubeless
    to add new features to an existing app without changing the app itself. We’ll
    start simple with a Hello, Kiamol example.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 'This workflow means you run one command to get a code file running in a Pod
    and another command if you want to expose it over HTTP. It’s perfect for webhooks,
    integration components, and simple APIs. Other serverless platforms support Kubernetes
    and work in similar ways: Nuclio, OpenWhisk, and Fn Project all take your code,
    package it into a container to run, and support multiple triggers to invoke the
    function. They use standard resources, like Pods and Services, and standard patterns,
    like ingress controllers and message queues. In this chapter, you’ll use Kubeless
    to add new features to an existing app without changing the app itself. We’ll
    start simple with a Hello, Kiamol example.'
- en: Try it now Start by deploying Kubeless in your cluster. There’s a snapshot of
    the most recent release in this chapter’s folder.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Try it now Start by deploying Kubeless in your cluster. There’s a snapshot of
    the most recent release in this chapter’s folder.
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You can see in figure 21.2 that Kubeless uses the techniques you learned in
    chapter 20: CustomResourceDefinitions for the HTTP and schedule triggers, and
    for serverless functions themselves. A controller monitors all those resources
    and turns functions into Pods, HTTP triggers into Ingress rules, and scheduled
    triggers into CronJobs.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 'You can see in figure 21.2 that Kubeless uses the techniques you learned in
    chapter 20: CustomResourceDefinitions for the HTTP and schedule triggers, and
    for serverless functions themselves. A controller monitors all those resources
    and turns functions into Pods, HTTP triggers into Ingress rules, and scheduled
    triggers into CronJobs.'
- en: '![](../Images/21-2.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/21-2.jpg)'
- en: Figure 21.2 The Kubeless architecture adds new resources to provide the serverless
    abstraction.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 图 21.2 Kubeless 架构通过添加新资源来提供无服务器抽象。
- en: 'You can create Kubeless custom resources yourself, which fits neatly if your
    function code is all in source control and you already have a CI/CD process that
    uses kubectl. The Kubeless CLI is an easier option: you run simple commands, and
    it creates the resources for you. The CLI is a single binary you can install on
    macOS, Linux, or Windows. You’ve installed enough software already, though, so
    we’ll run Kubeless in a Pod that has the CLI installed and kubectl configured
    to work with your cluster.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 'You can create Kubeless custom resources yourself, which fits neatly if your
    function code is all in source control and you already have a CI/CD process that
    uses kubectl. The Kubeless CLI is an easier option: you run simple commands, and
    it creates the resources for you. The CLI is a single binary you can install on
    macOS, Linux, or Windows. You’ve installed enough software already, though, so
    we’ll run Kubeless in a Pod that has the CLI installed and kubectl configured
    to work with your cluster.'
- en: Try it now Run the Kubeless CLI in a Pod, and confirm it can connect to your
    cluster.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试 Run the Kubeless CLI in a Pod, and confirm it can connect to your cluster.
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Kubeless supports a lot of languages, as you see in figure 21.3, from common
    ones like Java, .NET, and Python, to interesting newcomers like Ballerina and
    Vert.x (which itself supports multiple JVM variants like Java, Kotlin, and Groovy).
    If any of those fit with your tech stack, you can deploy functions with Kubeless—it’s
    a great way to evaluate new versions of your runtime or try out new languages.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Kubeless supports a lot of languages, as you see in figure 21.3, from common
    ones like Java, .NET, and Python, to interesting newcomers like Ballerina and
    Vert.x (which itself supports multiple JVM variants like Java, Kotlin, and Groovy).
    If any of those fit with your tech stack, you can deploy functions with Kubeless—it’s
    a great way to evaluate new versions of your runtime or try out new languages.
- en: '![](../Images/21-3.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/21-3.jpg)'
- en: Figure 21.3 Serverless functions can be written in all the major languages with
    Kubeless.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图 21.3 使用 Kubeless，无服务器函数可以用所有主要语言编写。
- en: Serverless functions are meant to do a single focused task, and the source code
    should usually be a single file, but Kubeless does let you deploy larger projects.
    It understands the dependency management systems for all the runtimes, and it
    will fetch dependencies as part of the deployment. You can upload a zip archive
    containing a whole project structure when you create a new function, or you can
    upload a single file. Listing 21.1 shows a simple hello function in Java. Don’t
    worry about the source code too much—this example is just to show you that there’s
    a standard approach to writing a Kubeless function, no matter what language you
    use.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 无服务器函数旨在执行单个专注的任务，源代码通常应该是一个文件，但 Kubeless 确实允许你部署更大的项目。它理解所有运行时的依赖管理系统，并在部署过程中获取依赖项。当你创建一个新的函数时，你可以上传包含整个项目结构的
    zip 存档，或者你可以上传单个文件。列表 21.1 显示了一个简单的 Java 欢迎函数。不必太担心源代码——这个例子只是为了向你展示，无论你使用什么语言，编写
    Kubeless 函数都有一种标准的方法。
- en: Listing 21.1 hello-kiamol.java, a simple Java serverless function
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 21.1 hello-kiamol.java，一个简单的 Java 无服务器函数
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Every function receives two fields: one with details about the event, including
    the type of trigger and any data sent by the caller, and one with the context
    of the function itself, including the runtime and the timeout set for the function
    to complete. There’s no service account token to authenticate with the Kubernetes
    API server, and your functions will normally be application features rather than
    Kubernetes extensions (although they do run in Pods, so the token can be automounted
    in the filesystem if you do need it).'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 每个函数接收两个字段：一个包含关于事件的详细信息，包括触发器的类型和调用者发送的任何数据，另一个包含函数本身的上下文，包括函数的运行时间和为函数完成设置的超时时间。没有服务账户令牌用于与
    Kubernetes API 服务器进行身份验证，并且你的函数通常将是应用程序功能而不是 Kubernetes 扩展（尽管它们确实在 Pod 中运行，所以如果需要，令牌可以自动挂载到文件系统中）。
- en: When functions are invoked, they do whatever they need to do, and they can return
    a string, which is sent as the response to the caller if the function was triggered
    by an HTTP request. The function code executes inside a Pod container so you can
    write log entries to the standard output stream and see them in Pod logs. You
    can deploy the simple function from listing 21.1 and check the Pod spec to see
    how Kubeless works.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当函数被调用时，它们执行所需的所有操作，并且可以返回一个字符串，如果函数是由 HTTP 请求触发的，则将该字符串作为响应发送给调用者。函数代码在 Pod
    容器内部执行，因此你可以将日志条目写入标准输出流并在 Pod 日志中查看它们。你可以部署列表 21.1 中的简单函数并检查 Pod 规范以了解 Kubeless
    的工作方式。
- en: Try it now Deploy the simple Hello Java function with the Kubeless CLI, and
    look at the Kubernetes objects it creates.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试看 部署简单的 Hello Java 函数使用 Kubeless CLI，并查看它创建的 Kubernetes 对象。
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Figure 21.4 ends with the logs from the init container in the Pod. Kubeless
    has a nice way of packaging apps without needing to build and push a container
    image. Every supported runtime has an init container image that has all the build
    tools for the runtime—in this case, it’s the Java JDK and Maven for dependency
    management. The init container loads the function source code from a ConfigMap
    volume, builds the application, and copies the output to an `EmptyDir` volume.
    The app container runs from an image with the language runtime and launches the
    compiled application from the shared `EmptyDir` volume.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图 21.4 以 Pod 中 init 容器的日志结束。Kubeless 有一种打包应用程序的好方法，无需构建和推送容器镜像。每个支持的运行时都有一个
    init 容器镜像，其中包含运行时的所有构建工具——在本例中，是 Java JDK 和 Maven 用于依赖管理。init 容器从 ConfigMap 卷加载函数源代码，构建应用程序，并将输出复制到
    `EmptyDir` 卷。应用程序容器从一个包含语言运行时的镜像运行，并从共享的 `EmptyDir` 卷启动编译后的应用程序。
- en: '![](../Images/21-4.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/21-4.jpg)'
- en: Figure 21.4 Kubeless makes good use of init containers to compile functions
    without building images.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图 21.4 Kubeless 充分利用 init 容器来编译函数而不构建镜像。
- en: This approach means a slower startup time for functions compared to platforms
    that build and push an image for every function, but it removes a lot of friction
    for developers. It also means your cluster doesn’t need to be configured with
    Secrets that have write permission to registries, and you don’t even need to use
    a container runtime that can build and push images. Now you have a function running
    in a Pod, and you didn’t need a build server or Java or Maven installed.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法意味着与为每个函数构建和推送镜像的平台相比，函数的启动时间较慢，但它为开发者消除了许多摩擦。这也意味着你的集群不需要配置具有对注册表写入权限的
    Secrets，而且你甚至不需要使用可以构建和推送镜像的容器运行时。现在你有一个在 Pod 中运行的函数，而你不需要构建服务器或安装 Java 或 Maven。
- en: Function Pods have an HTTP server listening for requests. When you create a
    trigger, it sends requests to the Service for the Pod. You can scale and autoscale
    functions in the same way as standard application Pods, and requests are load-balanced
    by the Service in the usual way. Kubeless builds on the established Kubernetes
    resources and gives you an easy way to get your apps running. This function doesn’t
    have any triggers yet, so you can’t call it from outside the cluster, but you
    can start a proxy with kubectl and call the Service directly.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 函数Pod有一个监听请求的HTTP服务器。当你创建一个触发器时，它会向Pod的服务发送请求。你可以像标准应用程序Pod一样扩展和自动扩展函数，并且请求由服务以通常的方式负载均衡。Kubeless建立在已建立的Kubernetes资源之上，为你提供了一个简单的方法来运行你的应用程序。这个函数还没有任何触发器，因此你无法从集群外部调用它，但你可以使用kubectl启动代理并直接调用服务。
- en: Try it now You can invoke the function with an HTTP request proxied by kubectl,
    or you can use the Kubeless CLI—we’re still inside the Pod session for this exercise.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下 你可以使用kubectl代理的HTTP请求来调用函数，或者你可以使用Kubeless CLI——我们仍然在这个练习的Pod会话中。
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You can see in figure 21.5 that the Kubeless CLI gives you an easy way to interact
    with your functions, but every function is a Kubernetes app, so you can also work
    with it using the usual kubectl commands.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在图21.5中看到，Kubeless CLI为你提供了一个与函数交互的简单方法，但每个函数都是一个Kubernetes应用程序，因此你也可以使用通常的kubectl命令来与之交互。
- en: '![](../Images/21-5.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/21-5.jpg)'
- en: 'Figure 21.5 Serverless is really a deployment abstraction: Kubeless creates
    standard Kubernetes resources.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图21.5无服务器实际上是一种部署抽象：Kubeless创建了标准的Kubernetes资源。
- en: This function isn’t too useful. One area where serverless functions really shine
    is adding new features to existing applications, without needing any changes or
    deployments to the main app. In the next sections, we’ll use serverless functions
    to add some much-needed features to the beloved (or maybe not by now) to-do app.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数并不太有用。无服务器函数真正发光的地方是向现有应用程序添加新功能，而无需对主应用程序进行任何更改或部署。在接下来的几节中，我们将使用无服务器函数向备受喜爱的（或者可能现在不再如此）待办事项应用程序添加一些急需的功能。
- en: 21.2 Triggering functions from HTTP requests
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 21.2 从HTTP请求触发函数
- en: You learned about ingress in chapter 15\. It’s the usual way to route incoming
    requests across multiple apps running in your cluster. Ingress rules also hide
    the details of how a single application is put together, so different paths in
    the same domain name might be served by one component or by different components.
    You can leverage that with serverless functions to add new features that appear
    to be part of the main application.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你在第15章学习了入口的概念。它是将进入请求路由到集群中运行的多个应用程序的常用方法。入口规则还隐藏了单个应用程序是如何组合起来的细节，因此同一域名中的不同路径可能由一个组件或不同的组件提供服务。你可以利用这一点，通过无服务器函数添加看起来像是主应用程序一部分的新功能。
- en: We’ll do that to add a new REST API for the to-do list application, building
    on the work we did in chapter 20\. There we introduced a message queue for communication
    between the website and a message handler that saved new items to the database.
    Any component with access can post a message to the queue, so we can run a simple
    API in a serverless function to do that. Let’s start by getting the to-do app
    running again.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为此为待办事项应用程序添加一个新的REST API，基于我们在第20章所做的工作。在那里，我们介绍了一个用于网站和将新项目保存到数据库的消息处理程序之间的通信的消息队列。任何具有访问权限的组件都可以向队列中发布消息，因此我们可以在无服务器函数中运行一个简单的API来完成这个任务。让我们先让待办事项应用程序重新运行起来。
- en: Try it now Deploy the to-do app using simple Deployment specs for the NATS message
    queue and the database.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下 使用简单的Deployment规范部署待办事项应用程序，用于NATS消息队列和数据库。
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Nothing special in figure 21.6—just the same old to-do app running. This isn’t
    the full production deployment using Operators to manage the message queue and
    database, but it’s the same architecture and functionality.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图21.6没有什么特别之处——只是运行着的老式待办事项应用程序。这不是使用操作员管理消息队列和数据库的完整生产部署，但它具有相同的架构和功能。
- en: '![](../Images/21-6.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/21-6.jpg)'
- en: Figure 21.6 Serverless functions can integrate nicely with your app if it has
    the right architecture.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图21.6显示，如果应用程序具有正确的架构，无服务器函数可以很好地与你的应用程序集成。
- en: I’m going to use lots of different languages for the serverless functions in
    this section so you get a feel for how they work and see the similarities between
    runtimes. The to-do API uses Node.js, which makes use of some additional libraries
    to send messages to NATS. Kubeless takes care of loading dependencies in the init
    container when a function Pod starts; you just need to specify the dependencies
    in a file using the standard format for the runtime. Listing 21.2 shows the main
    part of the API function using the NATS library to send messages.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将使用多种不同的语言来编写无服务器函数，这样您可以了解它们是如何工作的，并看到运行时之间的相似性。待办API使用Node.js，它使用一些额外的库来向NATS发送消息。Kubeless负责在函数Pod启动时在初始化容器中加载依赖项；您只需在文件中使用运行时的标准格式指定依赖项即可。列表21.2显示了使用NATS库发送消息的API函数的主要部分。
- en: Listing 21.2 server.js, a serverless API in Node.js
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 列表21.2 server.js，Node.js中的无服务器API
- en: '[PRE6]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The Node.js function has the same structure as the Java function in listing
    21.1: it receives event and context objects with details about the call. The data
    is the new to-do item sent by the caller, and the code builds that into a message,
    which it publishes to the queue. The format is the same as that the website publishes,
    so the message handler will receive messages from both the API and the web app
    and save new items to the database. Alongside the code file is a package file,
    which lists dependencies, so this is ready to deploy with Kubeless.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js函数的结构与列表21.1中的Java函数相同：它接收包含调用详细信息的event和context对象。数据是由调用者发送的新待办事项，代码将其构建成一个消息，并将其发布到队列中。格式与网站发布的格式相同，因此消息处理程序将接收来自API和Web应用的消息，并将新项目保存到数据库中。与代码文件并列的是包文件，它列出了依赖项，因此它可以与Kubeless一起部署。
- en: Try it now Functions with dependencies are deployed in the same way; you just
    need to specify the dependency file as well as the code file in the Deployment
    command.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下；具有依赖关系的函数以相同的方式部署；您只需在Deployment命令中指定依赖文件以及代码文件即可。
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Messaging architecture makes this sort of new functionality simple. The message
    handler listens for events when a new item is created and saves them to the database.
    It doesn’t matter what the source of the event is. As shown in figure 21.7, the
    API function publishes a message with a random event ID, and that’s the message
    the handler picks up. If you refresh your to-do list in the browser, you’ll see
    the new item is there.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 消息架构使得这种新的功能变得简单。消息处理程序监听当创建新项目时的事件，并将它们保存到数据库中。事件来源无关紧要。如图21.7所示，API函数发布了一条带有随机事件ID的消息，这就是处理程序接收到的消息。如果您在浏览器中刷新待办事项列表，您会看到新项目已经在那里。
- en: '![](../Images/21-7.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/21-7.jpg)'
- en: Figure 21.7 An API for the to-do app running as a serverless function in under
    20 lines of code
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图21.7 在20行代码内运行的待办应用API
- en: Serverless functions fit nicely with event-driven architectures because they
    can just plug into the message stream, generating or consuming different types
    of event. That doesn’t mean messaging is a requirement, because functions can
    always integrate with apps at different levels. Without the message queue, the
    new API function could have used database integration and written a new row into
    the table. It’s better to have higher-level integrations where you can let components
    own their own data, but your function code can do whatever fits with your current
    architecture.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 无服务器函数非常适合事件驱动架构，因为它们可以简单地连接到消息流，生成或消费不同类型的事件。这并不意味着消息是必需的，因为函数始终可以以不同级别与应用程序集成。没有消息队列，新的API函数可以使用数据库集成并写入新行到表中。更好的是拥有高级别的集成，这样您可以让组件拥有自己的数据，但您的函数代码可以执行与您当前架构相匹配的任何操作。
- en: Right now you have Services for the to-do web app and the API function. The
    next stage is to publish them both using Ingress. You can choose your URL structure
    when you mingle serverless functions with an existing app. In this case, I’m going
    to use a subdomain for the function so the app will be available at `todo.kiamol.local`
    and the function at `api.todo.kiamol.local`. To make that work, you’ll need to
    deploy an ingress controller and set up some domain names in your hosts file.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 目前您已经有了待办事项Web应用的服务和API功能。下一步是将它们两者都通过Ingress发布。当您将无服务器函数与现有应用混合时，您可以选择您的URL结构。在这种情况下，我将为函数使用一个子域名，因此应用将在`todo.kiamol.local`上可用，而函数在`api.todo.kiamol.local`上。为了使其工作，您需要部署一个ingress控制器并在您的hosts文件中设置一些域名。
- en: Try it now Deploy an ingress controller, and add some domains to your hosts
    file. You’ll need to run your terminal as Administrator on Windows and use sudo
    on Linux or macOS.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下：部署一个入口控制器，并将一些域名添加到你的hosts文件中。在Windows上，你需要以管理员身份运行终端，而在Linux或macOS上使用sudo。
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You’ll see in that exercise that the ingress rules hide all the details about
    app Pods and function Pods, and consumers just use URLs, which appear to be different
    parts of one big application. A tiny screenshot in figure 21.8 shows two items
    in the list; both were added by the new API function, but they behave in the same
    way as if they’d been added in the website.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在那个练习中，你会发现入口规则隐藏了关于应用Pod和函数Pod的所有细节，消费者只使用URL，这些URL看起来像是单个大型应用程序的不同部分。图21.8中的一个小截图显示了列表中的两个项目；这两个项目都是由新的API函数添加的，但它们的行为就像它们是在网站上添加的一样。
- en: '![](../Images/21-8.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图21.8](../Images/21-8.jpg)'
- en: Figure 21.8 Ingress rules hide the internal architecture, which could be one
    app or multiple functions.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图21.8 入口规则隐藏了内部架构，这可能是一个应用程序或多个函数。
- en: You can build an entire API from serverless functions using a different function
    for each path, but for large APIs, that’s going to mean a lot of Pods, which each
    have their own compute requirements. Kubeless doesn’t apply resource requests
    or limits by default, so running hundreds of function Pods is more likely to put
    your nodes under memory pressure than running a dozen replicas of a single API
    Pod. The eviction scenarios we covered in chapter 19 are more likely if you rely
    heavily on serverless functions, because every function will use some memory to
    load the language runtime.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用无服务器函数构建整个API，每个路径使用不同的函数，但对于大型API，这意味着会有很多Pod，每个Pod都有自己的计算需求。Kubeless默认不应用资源请求或限制，因此运行数百个函数Pod更有可能让你的节点承受内存压力，而不是运行单个API
    Pod的数十个副本。如果你严重依赖无服务器函数，我们讨论的第19章中提到的驱逐场景更有可能出现，因为每个函数都会使用一些内存来加载语言运行时。
- en: That’s not to say a serverless API isn’t feasible; it just needs some additional
    planning. You can add a resource block to function specs if you create the custom
    resource yourself in YAML rather than using the Kubeless CLI. You’ll also want
    to think carefully about the runtimes you use because image size affects your
    ability to scale quickly, and larger images provide a bigger surface area for
    attacks. As of Kubeless 1.0.7, the Go runtime image is under 60 MB, and the Node.js
    image is 10 times the size.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是说无服务器API不可行；只是需要一些额外的规划。如果你在YAML中自己创建自定义资源而不是使用Kubeless CLI，你可以向功能规范中添加资源块。你还需要仔细考虑你使用的运行时，因为镜像大小会影响你快速扩展的能力，并且更大的镜像提供了更大的攻击面。截至Kubeless
    1.0.7版本，Go运行时镜像小于60 MB，而Node.js镜像的大小是其10倍。
- en: Now that you see how serverless functions can extend an existing application,
    we’ll round off the to-do app with a few more features using different languages
    and different triggers.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到了无服务器函数如何扩展现有应用程序，我们将使用不同的语言和不同的触发器添加一些更多功能来完善待办事项应用。
- en: 21.3 Triggering functions from events and schedules
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 21.3 从事件和计划触发函数
- en: All serverless platforms have a similar architecture where functions can be
    invoked by different triggers; HTTP requests, messages arriving on a queue, and
    schedules are the common types of trigger. Separating the trigger from the function
    itself simplifies the code because the platform wires everything up for you, and
    you can call the same function in different ways. We can use a message queue trigger
    to add an auditing feature to the to-do app that logs when new items are created.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 所有无服务器平台都具有类似的架构，其中函数可以通过不同的触发器被调用；HTTP请求、队列上到达的消息和计划是常见的触发类型。将触发器与函数本身分离简化了代码，因为平台为你连接一切，你可以以不同的方式调用同一个函数。我们可以使用消息队列触发器为待办事项应用添加审计功能，记录新项目创建的时间。
- en: The new feature will listen for the same new-item message that the existing
    message handler uses to save items to the database. Queues like NATS support a
    publish-subscribe pattern, which means any number of subscribers can listen for
    the new-item messages, and they will all get a copy. Kubeless will subscribe to
    the queue and call the function when there are incoming events, so there’s no
    special messaging code inside the function. The audit handler writes a log entry
    for every item it sees, and the function code is just the two lines of Python,
    shown in listing 21.3.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 新功能将监听现有消息处理器用于将项目保存到数据库的相同新项目消息。像NATS这样的队列支持发布-订阅模式，这意味着可以有任意数量的订阅者监听新项目消息，并且他们都会收到一份副本。Kubeless将订阅队列，并在有传入事件时调用函数，因此函数内部无需特殊消息代码。审计处理器为它看到的每个项目写入日志条目，函数代码只是Python中显示的21.3列表中的两行。
- en: Listing 21.3 audit.py, a Python auditing function
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 列表21.3 audit.py，一个Python审计函数
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: There’s no difference in the setup of the function; Kubeless provides the standard
    event and context objects, no matter what type of trigger invokes the function.
    The `call` command in the Kubeless CLI works in the same way, too, so you can
    deploy this function and verify it by sending fake data in the same format as
    the new-item message.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的设置没有差异；Kubeless提供标准的事件和上下文对象，无论哪种类型的触发器调用函数。Kubeless CLI中的`call`命令也以相同的方式工作，因此您可以部署此函数，并通过发送与新项目消息格式相同的数据来验证它。
- en: Try it now Deploy the Python audit function, and invoke it directly with the
    Kubeless CLI to test it.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试吧 部署Python审计函数，并使用Kubeless CLI直接调用它以测试它。
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Figure 21.9 shows this is a simple developer experience. When the function is
    deployed, there are no default triggers, so there’s no way to invoke it except
    from the Kubeless CLI (or by proxying access to the function Service). Developers
    can quickly deploy a function and test it, iterate over the code using the `kubeless`
    `update` command, and publish a trigger to wire up the function only when they’re
    happy with it.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图21.9显示这是一个简单的开发者体验。当函数部署时，没有默认触发器，因此除了从Kubeless CLI（或通过代理访问函数服务）之外，没有其他方式可以调用它。开发者可以快速部署函数并测试它，使用`kubeless`
    `update`命令迭代代码，并且只有在他们对它满意时才发布触发器来连接函数。
- en: '![](../Images/21-9.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图21-9](../Images/21-9.jpg)'
- en: 'Figure 21.9 This is the value of the serverless workflow: deployment and test
    with single commands.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图21.9 这就是无服务器工作流的值：使用单个命令进行部署和测试。
- en: Kubeless natively supports message triggers for the Kafka messaging system,
    and it has a pluggable architecture so you can add a trigger for NATS. The Kubeless
    project maintains that trigger (along with other plugins, like a trigger for streams
    of data from AWS Kinesis), and you can deploy it to create a new CRD and controller
    for NATS trigger resources.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Kubeless原生支持Kafka消息系统的消息触发器，并且它具有可插拔的架构，因此您可以添加一个NATS触发器。Kubeless项目维护该触发器（以及其他插件，如AWS
    Kinesis数据流触发器），您可以将它部署以创建一个新的CRD和控制器，用于NATS触发器资源。
- en: Try it now Deploy the NATS plugin for Kubeless, and add a NATS trigger to invoke
    the audit function when messages are published to the new-item queue.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试吧 部署Kubeless的NATS插件，并为新项目队列添加一个NATS触发器，以便在消息发布到新项目队列时调用审计函数。
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The full logs from a function Pod are quite verbose because they include entries
    for the HTTP requests from the container’s liveness probe. My output in figure
    21.10 is snipped, but you can see the new workflow in action: an item is added
    using the API function through its HTTP trigger, that function drops a message
    onto the queue, and that triggers the audit function, which writes the log entry.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 函数Pod的完整日志相当冗长，因为它们包括来自容器存活探测的HTTP请求条目。我在图21.10中的输出被截断，但您可以看到新工作流程的实际操作：通过API函数使用其HTTP触发器添加项目，该函数将消息放入队列，这触发了审计函数，该函数写入日志条目。
- en: '![](../Images/21-10.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图21-10](../Images/21-10.jpg)'
- en: Figure 21.10 Message queues decouple components; here the audit function is
    invoked when the API function publishes a message, without the functions communicating
    directly.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图21.10 显示消息队列解耦组件；在这里，当API函数发布消息时，会调用审计函数，而函数之间没有直接通信。
- en: This is another good example of how a flexible architecture helps you add features
    quickly and easily—and safely, because there’s no change to the existing application.
    Heavily regulated industries like banking often have product backlogs that are
    almost entirely driven by new laws, and the ability to inject logic into existing
    workflows is a powerful argument for serverless. Behind the scenes, the NATS trigger
    controller subscribes to the event messages, and when they arrive, it invokes
    the function using its HTTP endpoint. That’s all abstracted from the function
    code, which can just focus on the task.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这又是灵活架构如何帮助您快速、轻松地添加功能的一个好例子——而且安全，因为现有应用程序没有任何改变。像银行这样的高度监管行业通常有几乎完全由新法律驱动的产品积压，而将逻辑注入现有工作流程的能力是服务器无服务器架构的一个强大论据。幕后，NATS
    触发控制器订阅事件消息，当它们到达时，它使用其 HTTP 端点调用函数。所有这些都从函数代码中抽象出来，函数代码只需专注于任务。
- en: 'One more example for this section will round off the main features of Kubeless:
    using a scheduled trigger and creating functions through YAML instead of with
    the CLI. The Kubeless CLI is just a wrapper that creates custom resources for
    you. In the `todo-mutating-handler` folder are two YAML manifests for custom resources:
    one for a Function and one for a CronJobTrigger. I won’t echo the specs here,
    but if you look at the Function, you’ll see it uses PHP and the source code is
    inside the custom resource spec. This approach works nicely with CI/CD pipelines
    because you can deploy using kubectl without needing to craft Kubeless commands.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将再举一个例子，以总结 Kubeless 的主要功能：使用计划触发器和通过 YAML 创建函数而不是使用 CLI。Kubeless CLI 只是一个包装器，为您创建自定义资源。在
    `todo-mutating-handler` 文件夹中有两个自定义资源的 YAML 清单：一个用于函数，一个用于 CronJobTrigger。我不会在这里重复规格说明，但如果您查看函数，您会看到它使用
    PHP，源代码位于自定义资源规范内部。这种方法与 CI/CD 管道配合得很好，因为您可以使用 kubectl 部署而无需构建 Kubeless 命令。
- en: Try it now Deploy the new function as a custom resource. You don’t need the
    Kubeless CLI for this workflow, so you don’t need to connect to a session in the
    CLI Pod.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试看。将新函数作为自定义资源部署。您不需要 Kubeless CLI 来完成此工作流程，因此不需要连接到 CLI Pod 中的会话。
- en: '[PRE12]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You’ll see when you run this exercise that it adds some much-needed functionality
    to the to-do app to sanitize the data that comes in. The CronJob makes a function
    call once every minute, and the PHP script executes to clean up the data and make
    sure the to-do list items are useful tasks. My output appears in figure 21.11.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行此练习时，您会看到它为待办事项应用程序添加了一些急需的功能，以清理传入的数据。CronJob 每分钟调用一次函数，PHP 脚本执行以清理数据并确保待办事项列表项是有用的任务。我的输出如图
    21.11 所示。
- en: '![](../Images/21-11.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图 21.11](../Images/21-11.jpg)'
- en: Figure 21.11 This handler has some unusual behavior, but it shows what you can
    do with functions.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图 21.11 此处理程序有一些不寻常的行为，但它展示了您可以使用函数做什么。
- en: Kubeless is a great way to get started with serverless and see if the functions-as-a-service
    model works for you. The focus on code makes Kubeless one of the better platforms
    for going serverless with Kubernetes, but the project hasn’t been very active
    lately, partly because all of the main features have been stable for a while.
    When you bring any open source project into your organization, you need to accept
    the risk that it might go stale, and you’ll need to spend your own engineering
    time helping to support it. You can mitigate that in this case by abstracting
    the serverless implementation using a generic project called Serverless.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Kubeless 是一种很好的入门服务器无服务器的方式，看看函数即服务模型是否适合您。对代码的关注使 Kubeless 成为使用 Kubernetes
    进行服务器无服务器的一个更好的平台之一，但该项目最近不太活跃，部分原因是因为所有主要功能已经稳定了一段时间。当您将任何开源项目引入您的组织时，您需要接受它可能变得过时的风险，并且您需要投入自己的工程时间来帮助支持它。您可以通过使用名为
    Serverless 的通用项目来抽象服务器无服务器实现来减轻这种情况。
- en: 21.4 Abstracting serverless functions with Serverless
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 21.4 使用 Serverless 抽象服务器无服务器函数
- en: Pay close attention to the capitalization in this section—*Serverless* is a
    project that standardizes function definitions and integrates with an underlying
    *serverless* platform to do the actual work. So you can deploy Serverless on top
    of Kubeless and use Serverless specs for your functions instead of using Kubeless
    directly. That means if you want to move away from Kubeless at some point to Knative
    or OpenWhisk or Fn Project, you can do it with a minimum amount of work, because
    Serverless supports those platforms, too. Figure 21.12 shows the architecture
    of Serverless with Kubeless.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意本节中的大小写——*Serverless* 是一个标准化函数定义并集成底层 *无服务器* 平台以执行实际工作的项目。因此，你可以在 Kubeless
    之上部署 Serverless，并使用 Serverless 规范为你的函数而不是直接使用 Kubeless。这意味着如果你想在某个时候从 Kubeless
    转移到 Knative 或 OpenWhisk 或 Fn Project，你可以通过最小的工作量来完成，因为 Serverless 也支持这些平台。图 21.12
    展示了 Serverless 与 Kubeless 的架构。
- en: '![](../Images/21-12.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/21-12.jpg)'
- en: Figure 21.12 Serverless introduces its own specification language but uses an
    underlying serverless platform to run functions.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图 21.12 说明了 Serverless 引入了自己的规范语言，但使用底层的无服务器平台来运行函数。
- en: Serverless isn’t quite as clean as Kubeless because it adds an extra YAML specification
    for the function, so you can’t just bring your code file and set it running. On
    the plus side the specification is quite simple, and it includes the function
    definition and the triggers in one place. Listing 21.4 shows the specification
    for the to-do API function. This file sits in the project folder along with the
    source code, and the code file itself is identical to what you deployed with Kubeless
    in section 21.2.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Serverless 并不完全像 Kubeless 那样干净利落，因为它为函数添加了一个额外的 YAML 规范，所以你无法直接带上代码文件并启动它。优点在于这个规范相当简单，它将函数定义和触发器放在一个地方。列表
    21.4 展示了 to-do API 函数的规范。这个文件位于项目文件夹中，与源代码一起，代码文件本身与你在 21.2 节中用 Kubeless 部署的文件相同。
- en: Listing 21.4 serverless.yml, a Serverless function spec
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 21.4 serverless.yml，一个 Serverless 函数规范
- en: '[PRE13]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The Serverless developer experience isn’t quite as clean as Kubeless, either.
    Serverless uses a command-line tool, which is a Node.js package, so you need to
    install Node.js and then install Serverless, which downloads a ton of dependencies.
    I’ve packaged the CLI in a container image so you don’t need to do that, and in
    this section, we’ll replace the Kubeless functions with Serverless versions of
    the same code.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Serverless 开发者体验也不如 Kubeless 那么干净。Serverless 使用一个命令行工具，这是一个 Node.js 包，所以你需要安装
    Node.js，然后安装 Serverless，这将下载大量的依赖项。我已经将 CLI 打包在一个容器镜像中，这样你就不需要这样做，在本节中，我们将用 Serverless
    的版本替换 Kubeless 函数。
- en: Try it now Remove the Kubeless functions, and deploy them again using Serverless
    as the abstraction layer.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试看！移除 Kubeless 函数，并使用 Serverless 作为抽象层重新部署它们。
- en: '[PRE14]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The Serverless CLI uses *providers* to adapt the generic function spec into
    platform components. It effectively replaces the Kubeless CLI, using the Kubeless
    provider and a Kubernetes client library to create custom resources, which the
    normal Kubeless controllers manage. Figure 21.13 shows the CLI is installed and
    running, but that’s not quite all you need. The provider and the Kubernetes client
    library need to be installed in the project folder together with about 100 other
    dependencies.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Serverless CLI 使用 *提供者* 将通用的函数规范适配为平台组件。它实际上替换了 Kubeless CLI，使用 Kubeless 提供者和
    Kubernetes 客户端库来创建自定义资源，这些资源由正常的 Kubeless 控制器管理。图 21.13 展示了 CLI 已安装并正在运行，但这还不是你需要的全部。提供者和
    Kubernetes 客户端库需要与大约 100 个其他依赖项一起安装到项目文件夹中。
- en: '![](../Images/21-13.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/21-13.jpg)'
- en: Figure 21.13 Serverless provides an alternative deployment experience, which
    will ultimately create the same function resources with Kubeless.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图 21.13 Serverless 提供了一种替代的部署体验，最终会创建与 Kubeless 相同的函数资源。
- en: Serverless is not a simple project, but it’s extremely popular. It isn’t only
    for serverless platforms running in Kubernetes, either. You can use it as an abstraction
    layer for AWS Lambda and Azure Functions, too. You can’t just lift functions written
    for Kubeless and deploy them as Azure Functions because the platforms invoke methods
    in different ways with different parameters, but the core of the function code
    will be the same. Next, we’ll see how the deployment looks for the to-do API function
    using Serverless.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 无服务器不是一个简单的项目，但它非常受欢迎。它不仅适用于在 Kubernetes 上运行的无服务器平台，还可以用作 AWS Lambda 和 Azure
    Functions 的抽象层。你不能直接将为 Kubeless 编写的函数提升并作为 Azure Functions 部署，因为平台以不同的方式使用不同的参数调用方法，但函数代码的核心将是相同的。接下来，我们将看到使用
    Serverless 部署待办事项 API 函数的部署情况。
- en: Try it now Create the to-do API function again with the same code file but using
    Serverless to define and deploy it.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试看 再次使用相同的代码文件创建待办事项 API 函数，但使用 Serverless 来定义和部署它。
- en: '[PRE15]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You can see in figure 21.14 that the net result of installing the Serverless
    function using Kubeless as the provider is the same as using the Kubeless CLI
    or deploying custom resources directly. You must perform the setup stage for each
    project, but only the first time you deploy it or if you upgrade the provider,
    because Serverless is really just a client-side tool for deploying and managing
    functions.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从图 21.14 中看到，使用 Kubeless 作为提供者的无服务器函数的安装结果与使用 Kubeless CLI 或直接部署自定义资源相同。你必须为每个项目执行设置阶段，但只有在第一次部署它或升级提供者时才需要这样做，因为
    Serverless 实际上只是一个用于部署和管理函数的客户端工具。
- en: '![](../Images/21-14.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图 21.14](../Images/21-14.jpg)'
- en: Figure 21.14 Serverless is an abstraction over a serverless platform. This deployment
    creates a Kubeless function and trigger.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图 21.14 无服务器是一个无服务器平台的抽象。这个部署创建了一个 Kubeless 函数和触发器。
- en: We won’t deploy the mutating function because I expect you got the message in
    the last section, but we’ll go ahead and deploy the auditing function and then
    confirm everything still works as expected. Serverless supports different event
    types to trigger functions, and the audit function spec includes a queue trigger
    for the NATS new-item messages.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会部署修改函数，因为我预计你在上一节已经收到了消息，但我们将继续部署审计函数，并确认一切仍然按预期工作。Serverless 支持不同的事件类型来触发函数，审计函数规范包括一个用于
    NATS 新项目消息的队列触发器。
- en: Try it now Still in your Serverless CLI session, switch to the folder for the
    auditing function, and deploy it with the message queue trigger.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试看 仍然处于你的无服务器 CLI 会话中，切换到审计函数的文件夹，并使用消息队列触发器部署它。
- en: '[PRE16]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: My output is shown in figure 21.15, where you see the result is the same whether
    you use the Kubeless CLI, the Serverless CLI, or kubectl to apply custom resource
    specs. Those are all different abstractions around the serverless model, which
    itself is an abstraction over the standard Kubernetes application model.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我的输出如图 21.15 所示，你可以看到无论你使用 Kubeless CLI、Serverless CLI 还是 kubectl 应用自定义资源规范，结果都是相同的。这些都是围绕无服务器模型的不同抽象，而该模型本身是标准
    Kubernetes 应用模型的一个抽象。
- en: '![](../Images/21-15.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![图 21.15](../Images/21-15.jpg)'
- en: Figure 21.15 Functions with different types of trigger are defined in the Serverless
    YAML spec and deployed in the same way,
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图 21.15 不同触发类型的函数在 Serverless YAML 规范中定义，并以相同的方式部署。
- en: One limitation with Serverless is that the CLI operates only within the context
    of a single function—you need to run commands in the function directory so the
    CLI can read the spec and find the function. You can group multiple functions
    in one folder and one Serverless spec, but they all have to use the same runtime,
    so that’s not an option for the polyglot functions in this section. In practice,
    if you use Serverless, you’ll be mixing the Serverless CLI with kubectl to get
    a full management experience. Now that the functions and the triggers are deployed,
    we actually don’t need to use Serverless at all to interact with them.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Serverless 的一项限制是 CLI 只在单个函数的上下文中运行——你需要在该函数目录中运行命令，以便 CLI 可以读取规范并找到函数。你可以将多个函数分组在一个文件夹和一个
    Serverless 规范中，但它们都必须使用相同的运行时，所以这不适合本节的多语言函数。实际上，如果你使用 Serverless，你将混合使用 Serverless
    CLI 和 kubectl 来获得完整的管理体验。现在函数和触发器都已部署，我们实际上根本不需要使用 Serverless 来与之交互。
- en: Try it now The HTTP trigger for the API function uses the same ingress rule,
    and the NATS trigger for the audit function uses the same queue, so the end-to-end
    can be tested in the same way.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试看 API 函数的 HTTP 触发器使用相同的入口规则，审计函数的 NATS 触发器使用相同的队列，因此端到端可以以相同的方式进行测试。
- en: '[PRE17]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: It will be clear from this exercise and from figure 21.16 that Kubeless and
    Serverless layer on abstractions at the build and deploy stages, but they don’t
    need to be used in the run stage. Functions can be delivered from single code
    files without a complex CI/CD pipeline and even without a container image build.
    The deployed components are just standard Kubernetes resources, which you can
    manage in the usual way. If you have centralized logging and monitoring set up
    in your cluster, your serverless functions integrate with them in the same way
    as your other applications.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个练习和图 21.16 可以清楚地看出，Kubeless 和 Serverless 在构建和部署阶段添加了抽象层，但在运行阶段并不需要使用它们。函数可以直接从单个代码文件中交付，而不需要复杂的
    CI/CD 管道，甚至不需要构建容器镜像。部署的组件只是标准的 Kubernetes 资源，你可以像往常一样管理它们。如果你在集群中设置了集中的日志记录和监控，你的无服务器函数将以与其他应用程序相同的方式与它们集成。
- en: '![](../Images/21-16.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/21-16.jpg)'
- en: Figure 21.16 The functions deployed with Serverless behave in the same way with
    the Kubeless provider.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 图 21.16 使用 Serverless 部署的函数与 Kubeless 提供程序的行为方式相同。
- en: That’s as far as we’ll go with serverless (and Serverless). It’s a useful architecture,
    and it’s good to have some experience using it with Kubernetes so you can understand
    how the transition from code to Pod works.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们就到这里讨论无服务器（以及无服务器）了。它是一个有用的架构，并且在使用 Kubernetes 的过程中积累一些经验是很好的，这样你可以理解从代码到
    Pod 的转换是如何工作的。
- en: 21.5 Understanding where serverless functions fit
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 21.5 理解无服务器函数的位置
- en: The promise of a cloud-based serverless platform is that you bring your code
    and you forget about the operations side—deployment is simple, and the platform
    keeps your code running and scales up and down with demand without any engagement
    from you. It’s compelling for a lot of use cases, but it has the major disadvantage
    that the serverless components of your app are different from all the other components.
    The processes around serverless are minimal, but they’re still needed, which leaves
    you with deployment pipelines, monitoring tools, and troubleshooting workflows
    that are different from all your other apps.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 云端无服务器平台所承诺的是，你带来你的代码，你就可以忘记操作方面——部署很简单，平台会根据需求自动扩展和缩减，而不需要你任何干预。这对于许多用例来说非常有吸引力，但它有一个主要的缺点，那就是你的应用程序的无服务器组件与其他所有组件都不同。围绕无服务器的流程是最小的，但它们仍然是必需的，这让你有了与所有其他应用程序不同的部署管道、监控工具和故障排除工作流程。
- en: That’s where serverless on Kubernetes comes in. It’s a compromise because you
    don’t get the zero-ops promise of a cloud serverless platform, and you don’t get
    to scale at will because you need to balance compute resources with your other
    apps. But as you’ve seen in this chapter, you do get the slick developer workflow,
    and you do get to manage your serverless functions in the same way as your other
    Kubernetes deployments. It may not be something you bring into your cluster on
    day 2, but it’s a powerful tool to have as an option.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 Kubernetes 上的无服务器的作用所在。这是一个折衷方案，因为你不会得到云无服务器平台的零操作承诺，你也不能随意扩展，因为你需要平衡计算资源与你的其他应用程序。但正如你在本章中看到的，你确实得到了流畅的开发者工作流程，并且你可以像管理你的其他
    Kubernetes 部署一样管理你的无服务器函数。这可能不是你第二天就带到你的集群中的东西，但它是一个作为选项的强大工具。
- en: 'Which just leaves the question: which tool, exactly? As of 2021, no serverless
    projects are under the CNCF, and the options I’ve mentioned in this chapter are
    a mixture of open source and commercial projects with pretty varied adoption and
    activity rates. Kubeless and Knative are the major options right now, and it’s
    worth evaluating both, bearing in mind that the Serverless project is useful for
    isolating you from the underlying platform, at the cost of taking on more YAML
    specs. The CNCF ran a serverless working group, which morphed into CloudEvents,
    a generic specification for events that trigger functions and the structure of
    their data, which is bringing standardization to serverless platforms.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这就留下了一个问题：究竟哪个工具？截至 2021 年，没有无服务器项目在 CNCF 下，我在本章中提到的选项是开源和商业项目的混合体，它们的采用率和活跃度相当多样。目前，Kubeless
    和 Knative 是主要的选择，值得对两者都进行评估，考虑到 Serverless 项目在隔离你与底层平台的同时，需要承担更多的 YAML 规范。CNCF
    运行了一个无服务器工作组，该工作组演变成了 CloudEvents，这是一个通用的规范，用于触发函数及其数据结构的事件，这正在为无服务器平台带来标准化。
- en: And that brings us to the end, so all that’s left is to tidy up and try the
    lab.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这就带我们到了结尾，所以剩下的就是整理一下，然后尝试实验室。
- en: Try it now Remove the Kubeless components, which will remove all the running
    functions, and then clean up the rest of the deployments.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下。移除 Kubeless 组件，这将移除所有正在运行的功能，然后清理其余的部署。
- en: '[PRE18]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 21.6 Lab
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 21.6 实验室
- en: I’ve mentioned Knative a few times in this chapter, and now it’s your turn to
    try it out. Your task is to deploy a Knative version of the to-do list API, which
    is available at the same URL you used in section 21.4\. The Docker image is already
    built, but an experienced Kubernetes user like you won’t need many hints. This
    is your chance to navigate the Knative documentation and see if you prefer the
    approach to Kubeless.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我在本章中提到了 Knative 几次，现在轮到你来尝试了。你的任务是部署一个 Knative 版本的待办事项 API，该 API 可在 21.4 节中使用的相同
    URL 上找到。Docker 镜像已经构建完成，但像你这样的经验丰富的 Kubernetes 用户不需要太多提示。这是你探索 Knative 文档并看看你是否更喜欢
    Kubeless 方法的时机。
- en: The image for your API is called `kiamol/ch21-todo-api`. You can create it as
    a Knative function using the Knative CLI or with a custom resource definition.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的 API 镜像名为 `kiamol/ch21-todo-api`。你可以使用 Knative CLI 或自定义资源定义来创建它作为一个 Knative
    函数。
- en: The lab folder contains a Knative deployment and a new release of the to-do
    app.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实验室文件夹包含一个 Knative 部署和待办事项应用的新版本。
- en: This Knative setup uses a CNCF project called Contour as the ingress controller.
    The IP address to access your apps is in the `envoy` Service in the `contour-external`
    namespace.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个 Knative 设置使用了一个名为 Contour 的 CNCF 项目作为入口控制器。访问你的应用的 IP 地址位于 `contour-external`
    命名空间中的 `envoy` 服务中。
- en: Knative uses the name of the Knative Service and the Kubernetes namespace to
    build the ingress domain name, so you’ll need to be careful how you deploy your
    function.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Knative 使用 Knative Service 的名称和 Kubernetes 命名空间来构建入口域名，因此你在部署函数时需要小心谨慎。
- en: 'Quite a few hints actually. This one may take some investigating, but don’t
    be disheartened—the solution is straightforward, although you’ll have to align
    a lot of stars to get the function running as you expect. My solution is on GitHub:
    [https://github.com/sixeyed/kiamol/blob/master/ch21/lab/README.md](https://github.com/sixeyed/kiamol/blob/master/ch21/lab/README.md).'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上有很多提示。这个可能需要一些调查，但不要气馁——解决方案很简单，尽管你需要调整很多因素才能使函数按预期运行。我的解决方案在 GitHub 上：[https://github.com/sixeyed/kiamol/blob/master/ch21/lab/README.md](https://github.com/sixeyed/kiamol/blob/master/ch21/lab/README.md)。
