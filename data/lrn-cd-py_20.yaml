- en: Lesson 16\. Repeating tasks with loops
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第16课：使用循环重复任务
- en: After reading [lesson 16](#ch16), you’ll be able to
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读[第16课](#ch16)之后，你将能够
- en: Understand what it means for a line of code to repeat execution
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解代码重复执行的含义
- en: Write a loop in a program
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在程序中编写循环
- en: Repeat actions a certain number of times
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重复执行特定次数的操作
- en: The programs you’ve seen so far have statements that are executed once, at most.
    In the preceding unit, you learned to add decision points in your programs, which
    can break up the flow by making the program react to input. The decision points
    are governed by conditional statements that may cause your program to take a detour
    to execute other lines of code if a certain condition holds.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 你迄今为止看到的程序中都有只执行一次的语句。在前一个单元中，你学习了如何在程序中添加决策点，通过使程序对输入做出反应来打断流程。决策点由条件语句控制，如果满足某个条件，程序可能会绕道执行其他代码行。
- en: These kinds of programs still have a type of linearity to them; statements are
    executed top to bottom, and a statement can be executed either zero times or at
    most one time. Therefore, the maximum number of statements that can be executed
    in your program is the maximum number of lines in the program.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型的程序仍然具有某种线性；语句按顺序执行，一个语句可以执行零次或最多一次。因此，程序中可以执行的最大语句数是程序中行数的最大值。
- en: '|  |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Consider this**'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '**考虑以下内容**'
- en: It’s a new year, and your resolution is to do 10 push-ups and 20 sit-ups every
    day. Look at the following flowchart to determine the number of sit-ups and push-ups
    you’ll do in one year.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 新年伊始，你的决心是每天做10个俯卧撑和20个仰卧起坐。查看以下流程图，以确定你一年内将做多少次仰卧起坐和俯卧撑。
- en: '![](images/144fig01.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![](images/144fig01.jpg)'
- en: A flowchart illustrating how you can repeat certain tasks. Sit-ups are repeated
    10 times, and push-ups are repeated 20 times. Both sit-ups and push-up sequences
    are done every day of the year
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 一个流程图，说明了你可以如何重复执行某些任务。仰卧起坐重复10次，俯卧撑重复20次。仰卧起坐和俯卧撑序列每天都在进行。
- en: 'Answer: 3,650 sit-ups and 7,300 push-ups'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：3,650次仰卧起坐和7,300次俯卧撑
- en: '|  |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 16.1\. Repeating a task
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.1\. 重复任务
- en: The power of computers comes from their capability to do computations quickly.
    Using what you’ve learned so far, if you wanted to execute a statement or a slight
    variation on a statement more than once, you’d have to type it in your program
    again so that the interpreter sees it as a separate command. Doing this defeats
    the purpose of having a computer do the work for you. In this lesson, you’ll construct
    loops, which tell the interpreter to repeat a certain task (represented by a set
    of statements) many times.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机的强大之处在于它们能够快速进行计算。使用你迄今为止学到的知识，如果你想多次执行一个语句或语句的微小变化，你必须在程序中再次输入它，以便解释器将其视为一个单独的命令。这样做就违背了让计算机为你工作的目的。在本课中，你将构建循环，告诉解释器重复执行某个任务（由一组语句表示）多次。
- en: 16.1.1\. Adding nonlinearity to programs
  id: totrans-16
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 16.1.1\. 向程序添加非线性
- en: In your everyday life, you often repeat a certain task while changing a small
    part of it. For example, when you arrive at work or school, you might greet people
    with “Hi Joe” and then “Hi Beth” and then “Hi Alice.” This task has something
    in common among all the repetitions (the word *Hi*), but a small part is changed
    with every repetition (a person’s name). As another example, your shampoo bottle
    might indicate “lather, rinse, repeat.” To *lather* and to *rinse* can be thought
    of as smaller subtasks that are both done, in the same order, with every repetition.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的日常生活中，你经常在改变一小部分的同时重复执行某个任务。例如，当你到达工作或学校时，你可能会用“嗨，乔”和“嗨，贝丝”然后“嗨，爱丽丝”来问候人们。所有重复操作中都有一些共同之处（单词*嗨*），但每次重复都会改变一小部分（一个人的名字）。作为另一个例子，你的洗发水瓶上可能标有“起泡，冲洗，重复”。*起泡*和*冲洗*可以被认为是每次重复都要执行，且顺序相同的小子任务。
- en: One of the many uses of computers is their capability to perform many computations
    in a short time. Doing repetitive tasks is what computers are best at, and programming
    a task such as playing every song in a playlist is easy. Every programming language
    has a way to tell the computer how to repeat a certain set of commands.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机的一个许多用途是它们能够在短时间内执行许多计算。执行重复性任务是计算机最擅长的事情，编写播放列表中每首歌曲的播放任务很容易。每种编程语言都有一种方法来告诉计算机如何重复执行一组特定的命令。
- en: 16.1.2\. Infinite repetitions
  id: totrans-19
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 16.1.2\. 无限重复
- en: Computers do only what you tell them to do, so you must be careful and explicit
    in your instructions. They can’t guess your intentions. Suppose you write a program
    to implement the “lather, rinse, repeat” procedure. Pretend you’ve never used
    shampoo before and you’re following the instructions without applying any other
    logic or reasoning. Notice anything wrong with the instructions? It’s unclear
    when to stop the “lather, rinse” steps. How many times should you “lather and
    rinse”? If there’s no set number of repetitions, when do you stop? These particular
    instructions are so vague that if you told a computer to do them, it would perform
    the “lather, rinse” procedure infinitely. A better instruction would be “lather,
    rinse, repeat as needed.” The flowchart in [figure 16.1](#ch16fig01) shows what
    happens when you tell a computer to “lather-rinse-repeat” and when you add an
    “as needed” clause to stop it from infinitely repeating.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机只会做你告诉它们做的事情，所以你必须小心并明确你的指令。它们不能猜测你的意图。假设你编写了一个程序来实现“泡沫、冲洗、重复”的过程。假设你以前从未使用过洗发水，你现在正在按照指示操作，没有应用任何其他逻辑或推理。你注意到指令有什么问题吗？不清楚何时停止“泡沫、冲洗”步骤。你应该“泡沫和冲洗”多少次？如果没有设定的重复次数，何时停止？这些特定的指令如此含糊，如果你告诉计算机执行，它将无限期地执行“泡沫、冲洗”过程。更好的指令是“泡沫、冲洗、需要时重复”。图16.1中的流程图显示了当你告诉计算机“泡沫-冲洗-重复”以及添加“需要时”条款以停止其无限重复时会发生什么。
- en: Figure 16.1\. The difference between (A) a lather-rinse-repeat instruction,
    which doesn’t ever terminate if taken literally and (B) a lather-rinse-repeat
    as needed instruction, which asks whether to repeat every time
  id: totrans-21
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图16.1. (A) 一种泡沫-冲洗-重复的指令，如果字面理解，永远不会终止，以及(B) 需要时泡沫-冲洗-重复的指令，每次都会询问是否重复
- en: '![](images/16fig01.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](images/16fig01.jpg)'
- en: 'Because computers do only what they’re told, they can’t make the decision of
    whether to repeat a set of commands on their own. You have to be careful to be
    specific when telling the computer to repeat commands: are there a certain number
    of times you want the commands to be repeated, or is there a condition that determines
    whether to repeat again? In the lather-rinse example, “as needed” was a condition
    that determined whether you were going to repeat lather-rinse. Alternatively,
    you might say that you want to lather-rinse three times and then stop.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 因为计算机只会做它们被告知的事情，所以它们不能自己决定是否重复一组命令。当告诉计算机重复命令时，你必须小心并具体说明：你希望命令重复多少次，或者是否存在一个条件来决定是否再次重复？在泡沫-冲洗的例子中，“需要时”是一个决定你是否要重复泡沫-冲洗的条件。或者，你可以说你想要泡沫-冲洗三次然后停止。
- en: '|  |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Thinking like a programmer**'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**像程序员一样思考**'
- en: Humans can fill in knowledge gaps and infer certain ideas in different situations.
    Computers do only what they’re told. When writing code, the computer will execute
    everything you write according to the rules of the programming language. A bug
    doesn’t spontaneously appear in your code. If a bug exists, it’s because you put
    it there. [Lesson 36](kindle_split_053.html#ch36) discusses formal ways to debug
    your programs.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 人类可以在不同情况下填补知识空白并推断某些想法。计算机只会做它们被告知的事情。当编写代码时，计算机将根据编程语言的规则执行你写的每一行代码。错误不会在代码中自发出现。如果存在错误，那是因为你将其放入其中。[第36课](kindle_split_053.html#ch36)讨论了调试程序的形式化方法。
- en: '|  |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 16.2\. Looping a certain number of times
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.2. 循环特定次数
- en: In programming, you achieve repetition by constructing loops. One way to stop
    a program from infinitely repeating a set of instructions is to tell it the number
    of times to repeat the instructions. The name for this type of loop is a `for`
    *loop*.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在编程中，通过构建循环来实现重复。停止程序无限重复一组指令的一种方法是指定重复指令的次数。这种循环的名称是`for`循环。
- en: 16.2.1\. for loops
  id: totrans-30
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 16.2.1. for循环
- en: 'In Python, the keyword that tells you how to loop a certain number of times
    is `for`. To start, here’s one way to use the keyword to repeat a command many
    times:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，告诉你如何循环特定次数的关键字是`for`。为了开始，这里有一种使用关键字重复命令多次的方法：
- en: '| Without using loops | Using loops |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| 不使用循环 | 使用循环 |'
- en: '| --- | --- |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '|'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '|'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Without using loops, you have to repeat the same command as many times as you
    need to. In this case, the command is printing the word *echo* four times. But
    using loops, you can condense the code into only two lines. The first line tells
    the Python interpreter the number of times to repeat a certain command. The second
    line tells the interpreter the command to repeat.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 不使用循环，你必须重复执行相同的命令，次数取决于你需要多少次。在这种情况下，命令是打印单词 *echo* 四次。但使用循环，你可以将代码压缩成只有两行。第一行告诉Python解释器重复某个命令的次数。第二行告诉解释器要重复的命令。
- en: '|  |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quick check 16.1**'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查16.1**'
- en: '**[1](kindle_split_056.html#app01qa66q0a1)**'
  id: totrans-42
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1](kindle_split_056.html#app01qa66q0a1)**'
- en: ''
  id: totrans-43
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write a piece of code that prints the word *crazy* eight times on separate lines.
  id: totrans-44
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 编写一段代码，将单词 *crazy* 在单独的行上打印八次。
- en: '**[2](kindle_split_056.html#app01qa66q0a2)**'
  id: totrans-45
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[2](kindle_split_056.html#app01qa66q0a2)**'
- en: ''
  id: totrans-46
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write a piece of code that prints the word *centipede* 100 times on separate
    lines.
  id: totrans-47
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 编写一段代码，将单词 *centipede* 在单独的行上打印100次。
- en: '|  |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Now suppose you’re playing a board game; on your turn, you have to roll the
    dice three times. After each roll, you move your game piece that many steps. Suppose
    the player rolls a 4, then a 2, and then a 6.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设你正在玩一个棋盘游戏；在你的回合，你必须掷三次骰子。每次掷骰子后，你都要移动你的棋子这么多步。假设玩家掷出了4，然后是2，然后是6。
- en: '[Figure 16.2](#ch16fig02) shows a flowchart of every step. With only three
    rolls, it’s easy to model the game by writing commands to do the dice roll and
    move the piece, repeating those two actions three times. But this would get messy
    quickly if you allowed the player to do 100 rolls on their turn. Instead, it’s
    better to model the player’s turn by using a `for` loop.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '[图16.2](#ch16fig02) 展示了每个步骤的流程图。通过仅掷三次骰子，通过编写命令进行掷骰子和移动棋子，重复这两个动作三次，就可以轻松地模拟游戏。但如果允许玩家在他们的回合中进行100次掷骰子，这会很快变得混乱。相反，最好通过使用
    `for` 循环来模拟玩家的回合。'
- en: Figure 16.2\. In both (A) and (B), you roll a dice three times to give you values
    4, 2, 6\. (A) represents how you can move a game piece by explicitly writing out
    commands step-by-step. (B) shows how you can represent doing the same thing, except
    that you’re using a `for` loop that iterates over the values representing each
    dice roll and you’re generalizing the values by using a variable `n`.
  id: totrans-51
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图16.2。在(A)和(B)中，你掷三次骰子得到值4、2、6。 (A) 表示你可以通过逐个写出命令来显式地移动棋子。 (B) 显示了你可以用 `for`
    循环来表示相同的事情，只是你正在使用一个遍历代表每次掷骰子值的循环，并且通过使用变量 `n` 来泛化这些值。
- en: '![](images/16fig02_alt.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](images/16fig02_alt.jpg)'
- en: The player rolls the dice three times to get a sequence of values. Represent
    the number on the dice as a variable `n`. The loop goes through the sequence representing
    the dice rolls, starting with the first number—in this case `n = 4`. Using this
    variable for the number of steps to take, you move the piece `n` steps. Then you
    go to the next number in the sequence, `n = 2`, and move the piece `2` steps.
    Lastly, you go to the final number in the sequence, `n = 6`, and move the piece
    `6` steps. Because there are no more numbers in the sequence, you can stop moving
    your piece, and your turn ends.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家掷三次骰子得到一个值序列。将骰子的数字表示为变量 `n`。循环遍历代表掷骰子的序列，从第一个数字开始——在这个例子中是 `n = 4`。使用这个变量作为移动步数的数量，你将棋子移动
    `n` 步。然后你转到序列中的下一个数字，`n = 2`，并将棋子移动 `2` 步。最后，你转到序列中的最后一个数字，`n = 6`，并将棋子移动 `6`
    步。因为序列中没有更多的数字，你可以停止移动你的棋子，你的回合结束。
- en: '[Listing 16.1](#ch16ex01) shows the general structure of a `for` loop. The
    same structure can be visualized using the flowchart in [figure 16.3](#ch16fig03).
    The idea is that you’re given a sequence of values. The body of the loop repeats
    execution as many times as there are values. With each repetition, you’re changing
    a loop variable to be an item in the sequence of values. The loop stops repeating
    when you’ve gone through all the values in the sequence.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表16.1](#ch16ex01) 展示了 `for` 循环的一般结构。可以使用 [图16.3](#ch16fig03) 中的流程图来可视化相同的结构。想法是，你给出一个值序列。循环体重复执行，直到序列中的值全部执行完毕。每次重复时，你都会改变循环变量，使其成为值序列中的一个项目。当序列中的所有值都已执行完毕时，循环停止重复。'
- en: Listing 16.1\. A general way to write a `for` loop
  id: totrans-55
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表16.1。编写 `for` 循环的一般方法
- en: '[PRE2]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '***1* Indicates beginning of loop. <loop_variable> systematically takes on
    the value of each item in <values>.**'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 表示循环的开始。 <loop_variable> 系统性地取 <values> 中每个项目的值。**'
- en: '***2* Code block to execute for each item in <values>**'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 为 <values> 中的每个项目执行代码块**'
- en: Figure 16.3\. A general way of writing a `for` loop. You start with the first
    item in the sequence of values and then execute the body of the loop by using
    that item. You get the next item in the sequence of values and execute the body
    of the loop using that item. The loop ends when you’ve gone through and executed
    the body of the loop by using every item in the sequence.
  id: totrans-59
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图16.3\. 编写`for`循环的一般方法。你从值序列的第一个项开始，然后使用该项执行循环体。你得到值序列的下一个项，并使用该项执行循环体。当你已经通过并使用序列中的每个项执行了循环体时，循环结束。
- en: '![](images/16fig03.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](images/16fig03.jpg)'
- en: 'A `for` loop consists of two parts: the `for` loop line definition, and the
    code block that gets executed a certain number of times.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`for`循环由两部分组成：`for`循环行定义和执行一定次数的代码块。'
- en: The keyword `for` tells Python you’re introducing a block that will be repeated
    a certain number of times. After the keyword, you name a loop variable. This can
    be any valid variable name you want. This loop variable automatically changes
    its value for every repetition, with subsequent values taken from the values determined
    by what comes after the keyword `in`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字`for`告诉Python你正在引入一个将被重复一定次数的块。在关键字之后，你命名一个循环变量。这可以是任何你想要的合法变量名。这个循环变量会自动在每次重复时改变其值，后续值从关键字`in`之后确定的值中获取。
- en: As with conditionals, indentation matters with loops. The indented code block
    tells Python that everything in that code block is part of the loop.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 与条件语句一样，循环中的缩进很重要。缩进的代码块告诉Python，该代码块中的所有内容都是循环的一部分。
- en: 16.3\. Looping N times
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.3\. 循环N次
- en: In the previous section, you didn’t impose any constraints on the sequence of
    values. It’s often useful to have loops whose sequence of values follows a pattern.
    For example, a common and useful pattern is to have the items in a sequence of
    values be sequentially increasing 1, 2, 3... until some value *N*. Because in
    computer science counting starts from 0, an even more common sequence of numbers
    is 0, 1, 2... until some value *N* – 1, to give a total of *N* items in a sequence.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，你没有对值的序列施加任何约束。有时，有一个遵循模式的值的序列的循环是有用的。例如，一个常见且有用的模式是，序列中的项按顺序递增1, 2, 3...直到某个值*N*。因为在计算机科学中计数从0开始，一个更常见的数字序列是0,
    1, 2...直到某个值*N* – 1，以在序列中给出*N*个项。
- en: 16.3.1\. Loops over the common sequence 0 to N – 1
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 16.3.1\. 对0到N-1的常见序列进行循环
- en: If you want to loop *N* times, you replace the `<values>` in [listing 16.1](#ch16ex01)
    with the expression `range(N)`, where `N` is an integer number. `range` is a special
    procedure in Python. The expression `range(N)` yields the sequence 0, 1, 2, 3,
    ... N – 1.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想循环*N*次，你将[代码列表16.1](#ch16ex01)中的`<values>`替换为表达式`range(N)`，其中`N`是一个整数。`range`是Python中的一个特殊过程。表达式`range(N)`产生序列0,
    1, 2, 3, ... N – 1。
- en: '|  |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Quick check 16.2**'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速检查16.2**'
- en: What sequence of values does the following evaluate to?
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表达式评估得到什么序列的值？
- en: '**[1](kindle_split_056.html#app01qa67q0a1)**'
  id: totrans-71
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[1](kindle_split_056.html#app01qa67q0a1)**'
- en: ''
  id: totrans-72
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`range(1)`'
  id: totrans-73
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`range(1)`'
- en: '**[2](kindle_split_056.html#app01qa67q0a2)**'
  id: totrans-74
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[2](kindle_split_056.html#app01qa67q0a2)**'
- en: ''
  id: totrans-75
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`range(5)`'
  id: totrans-76
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`range(5)`'
- en: '**[3](kindle_split_056.html#app01qa67q0a3)**'
  id: totrans-77
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[3](kindle_split_056.html#app01qa67q0a3)**'
- en: ''
  id: totrans-78
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`range(100)`'
  id: totrans-79
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`range(100)`'
- en: '|  |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '[Listing 16.2](#ch16ex02) shows a simple `for` loop that repeatedly prints
    the value of the loop variable `v`. In [listing 16.2](#ch16ex02), the loop variable
    is `v`, the sequence of values that the loop variable takes on is given by `range(3)`,
    and the body of the loop is one `print` statement.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '[代码列表16.2](#ch16ex02)展示了一个简单的`for`循环，该循环重复打印循环变量`v`的值。在[代码列表16.2](#ch16ex02)中，循环变量是`v`，循环变量所取值的序列由`range(3)`给出，循环体是一个`print`语句。'
- en: When the program in [listing 16.2](#ch16ex02) runs, and it first encounters
    the `for` loop with `range(3)`, it first assigns `0` to the loop variable `v`
    and then executes the `print` statement. Then it assigns `1` to the loop variable
    `v` and executes the `print` statement. Then it assigns `2` to the loop variable
    `v` and executes the `print` statement. In this example, this process is repeated
    three times, effectively assigning the loop variable the numbers 0, 1, 2.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序在[代码列表16.2](#ch16ex02)运行时，它首先遇到`for`循环和`range(3)`，它首先将`0`赋值给循环变量`v`，然后执行`print`语句。然后它将`1`赋值给循环变量`v`并执行`print`语句。然后它将`2`赋值给循环变量`v`并执行`print`语句。在这个例子中，这个过程重复了三次，实际上将循环变量赋值为0,
    1, 2。
- en: Listing 16.2\. A `for` loop that prints the loop variable value
  id: totrans-83
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 代码列表16.2\. 打印循环变量值的`for`循环
- en: '[PRE3]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '***1* v is the loop variable.**'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* v是循环变量。**'
- en: '***2* Prints the loop variable**'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 打印循环变量**'
- en: You can generalize the behavior in [listing 16.2](#ch16ex02) by using a different
    variable, say `n_times,` instead of `3`, to give a sequence of numbers denoted
    by `range(n_times)`. Then the loop will repeat `n_times` times. Every time the
    loop variable takes on a different value, the statements inside the code block
    are executed.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用不同的变量，比如 `n_times`，而不是 `3`，来泛化 [列表 16.2](#ch16ex02) 中的行为，以给出由 `range(n_times)`
    表示的数字序列。然后循环将重复 `n_times` 次。每次循环变量取不同的值时，都会执行代码块内的语句。
- en: 16.3.2\. Unrolling loops
  id: totrans-88
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 16.3.2\. 展开循环
- en: You can also think of loops in a different way. [Listing 16.3](#ch16ex03) shows
    how to unroll a loop (write the repeated steps) to see exactly how Python executes
    the code in [listing 16.2](#ch16ex02). In [listing 16.3](#ch16ex03), you see that
    the variable `v` is assigned a different value. The lines that print the variable
    are the same for every different value of `v`. This code is inefficient, boring,
    and error-prone to write because the line to print the value of the variable `v`
    is repeated. Using loops instead of this code is much more efficient to write
    and easier to read.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以用不同的方式思考循环。 [列表 16.3](#ch16ex03) 展示了如何展开循环（写出重复的步骤）以查看 Python 如何执行 [列表 16.2](#ch16ex02)
    中的代码。在 [列表 16.3](#ch16ex03) 中，你可以看到变量 `v` 被分配了不同的值。打印变量的那些行对于 `v` 的每一个不同值都是相同的。由于打印变量
    `v` 值的行被重复，因此编写此代码既低效又无聊，且容易出错。使用循环而不是这段代码要高效得多，也更容易阅读。
- en: Listing 16.3\. Unrolled `for` loop from [listing 16.2](#ch16ex02)
  id: totrans-90
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 16.3\. 从 [列表 16.2](#ch16ex02) 中的展开 `for` 循环
- en: '[PRE4]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '***1* The variable v (assigned to 0 here) is the loop variable from [listing
    16.2](#ch16ex02).**'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 变量 `v`（此处分配为 0）是 [列表 16.2](#ch16ex02) 中的循环变量。**'
- en: '***2* Manually change the value of v to be 1.**'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 手动将 `v` 的值更改为 1。**'
- en: '***3* Manually change the value of v to be 2.**'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 手动将 `v` 的值更改为 2。**'
- en: Summary
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: In this lesson, my objective was to teach you why loops are useful. You saw
    what a `for` loop does and how to set up a `for` loop in code. At a high level,
    a `for` loop repeats statements that are part of its code block a certain number
    of times. A loop variable is a variable whose value changes with every loop repetition
    going through items in the loop sequence.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在本课中，我的目标是教你为什么循环有用。你看到了 `for` 循环的作用以及如何在代码中设置 `for` 循环。从高层次来看，`for` 循环重复其代码块中的语句一定次数。循环变量是一个变量，其值随着每次循环重复通过循环序列中的项目而改变。
- en: 'Sequences can be a series of integers. You saw a special sequence created by
    the expression `range(N)`, where `N` is an integer. This expression creates the
    sequence 0, 1, 2, ... N – 1\. Here are the major takeaways:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 序列可以是一系列整数。你看到了由表达式 `range(N)` 创建的特殊序列，其中 `N` 是一个整数。这个表达式创建了一个序列 0, 1, 2, ...
    N – 1。以下是主要收获：
- en: Loops are useful for writing concise and easy-to-read code.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 循环对于编写简洁且易于阅读的代码非常有用。
- en: A `for` loop uses a loop variable that takes on values from a sequence of items;
    the items can be integers.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`for` 循环使用一个循环变量，该变量从一系列元素中取值；这些元素可以是整数。'
- en: When the items in the sequence are integers, you can use a special `range` expression
    to create special sequences.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当序列中的元素是整数时，你可以使用特殊的 `range` 表达式来创建特殊的序列。
- en: Let’s see if you got this...
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看你是否理解了...
- en: '**[Q16.1](kindle_split_056.html#app01qa68q0a1)**'
  id: totrans-102
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**[Q16.1](kindle_split_056.html#app01qa68q0a1)**'
- en: ''
  id: totrans-103
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Write a piece of code that asks the user for a number. Then write a loop that
    iterates that number of times and prints `Hello` every time. Is it possible to
    write this code without using a `for` loop?
  id: totrans-104
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 编写一段代码，要求用户输入一个数字。然后编写一个循环，该循环迭代该次数，并且每次打印 `Hello`。是否可以不使用 `for` 循环来编写此代码？
