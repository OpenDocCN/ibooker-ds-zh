- en: '18 Sessions: Remote control with less work'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 18 会话：减少工作量进行远程控制
- en: In chapter 13, we introduced you to PowerShell’s remoting features. In that
    chapter, you used two primary cmdlets—`Invoke-Command` and `Enter-PSSession`—to
    access both one-to-many and one-to-one remote control. Those two cmdlets work
    by creating a new remoting connection, doing whatever work you specify, and then
    closing that connection.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 13 章中，我们向您介绍了 PowerShell 的远程功能。在那个章节中，您使用了两个主要的命令——`Invoke-Command` 和 `Enter-PSSession`——来访问一对一和多对一的远程控制。这两个命令通过创建一个新的远程连接，执行您指定的任何工作，然后关闭该连接来工作。
- en: There’s nothing wrong with that approach, but it can be tiring to have to continually
    specify computer names, credentials, alternative port numbers, and so on. In this
    chapter, you’ll look at an easier, more reusable way to tackle remoting. You’ll
    also learn about a third way to use remoting called *implicit remoting*, which
    will allow you to add proxy commands by importing a module from a remote machine
    into your remote session.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法没有问题，但不断地指定计算机名称、凭据、替代端口号等可能会让人感到疲倦。在本章中，你将了解一种更简单、更可重用的方法来处理远程控制。你还将了解使用远程控制的第三种方法，称为*隐式远程控制*，这将允许你通过将远程机器上的模块导入到你的远程会话中，添加代理命令。
- en: Anytime you need to connect to a remote computer, using either `Invoke-Command`
    or `Enter-PSSession`, you have to at least specify the computer’s name (or names,
    if you’re invoking a command on multiple computers). Depending on your environment,
    you may also have to specify alternative credentials, which means being prompted
    for a password. You might also need to specify alternative ports or authentication
    mechanisms, depending upon how your organization has configured remoting.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 无论何时你需要连接到远程计算机，无论是使用 `Invoke-Command` 还是 `Enter-PSSession`，你至少需要指定计算机的名称（或者名称列表，如果你在多台计算机上执行命令）。根据你的环境，你可能还需要指定替代凭据，这意味着需要输入密码。你可能还需要指定替代端口或身份验证机制，这取决于你的组织如何配置远程访问。
- en: 'None of that is difficult to specify, but it can be tedious to have to repeat
    the process again and again. Fortunately, we know of a better way: reusable sessions.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然指定这些内容并不困难，但重复这个过程可能会很繁琐。幸运的是，我们知道有一种更好的方法：可重用会话。
- en: Note The examples in this chapter can only be completed if you have another
    computer to connect to and if you have enabled PS remoting. Reference chapter
    13 for more information.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：本章中的示例只能在您有另一台计算机可以连接并且已启用 PS 远程访问的情况下完成。有关更多信息，请参考第 13 章。
- en: 18.1 Creating and using reusable sessions
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 18.1 创建和使用可重用会话
- en: A *session* is a persistent connection between your copy of PowerShell and a
    remote copy of PowerShell. When the session is active, both your computer and
    the remote machine devote a small amount of memory and processor time toward maintaining
    the connection. However, there’s little network traffic involved in the connection.
    PowerShell maintains a list of all the sessions you’ve opened, and you can use
    those sessions to invoke commands or to enter a remote shell.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*会话*是您的 PowerShell副本与远程 PowerShell 副本之间的一种持久连接。当会话处于活动状态时，您的计算机和远程机器都会分配一小部分内存和处理器时间来维护连接。然而，在连接中涉及的网络流量很少。PowerShell
    维护一个您已打开的所有会话的列表，您可以使用这些会话来调用命令或进入远程外壳。'
- en: 'To create a new session, use the `New-PSSession` cmdlet. Specify the computer
    name or hostname (or names), and, if necessary, specify an alternative username,
    port, authentication mechanism, and so forth. Let’s also not forget that we can
    use SSH as opposed to WinRM by using the `-hostname` parameter. Either way, the
    result will be a session object, which is stored in PowerShell’s memory:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个新的会话，请使用 `New-PSSession` 命令。指定计算机名称或主机名（或名称列表），如果需要，指定替代用户名、端口、身份验证机制等。我们也不应忘记，我们可以通过使用
    `-hostname` 参数来使用 SSH 而不是 WinRM。无论如何，结果都将是一个会话对象，该对象存储在 PowerShell 的内存中：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To retrieve those sessions, run `Get-PSSession`:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要检索这些会话，请运行 `Get-PSSession`：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Tip As mentioned in chapter 13, when using the `-computername` parameter, we
    are using the WinRM (HTTP/HTTPS) protocol. When we use the `-hostname` parameter,
    we are specifying to use SSH as our communication protocol.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：如第 13 章所述，当使用 `-computername` 参数时，我们使用的是 WinRM（HTTP/HTTPS）协议。当我们使用 `-hostname`
    参数时，我们指定使用 SSH 作为我们的通信协议。
- en: 'Although that works, we prefer to create the sessions and immediately store
    them in a variable to access the session later. For example, Julie has multiple
    web servers that she routinely reconfigures by using `Invoke-Command`. To make
    the process easier, she stores those sessions in a specific variable:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这可行，但我们更喜欢创建会话并立即将它们存储在变量中以供以后访问。例如，朱莉有多个网络服务器，她通常通过使用 `Invoke-Command` 来定期重新配置它们。为了使过程更容易，她将这些会话存储在特定的变量中：
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Never forget that those sessions consume resources. If you close the shell,
    they’ll close automatically, but if you’re not actively using them, it’s a good
    idea to manually close them even if you’re planning to continue using the shell
    for other tasks so that you are not tying up resources on your machine or the
    remote machine.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 永远不要忘记那些会话会消耗资源。如果你关闭外壳，它们会自动关闭，但如果你没有积极使用它们，即使你打算继续使用外壳进行其他任务，手动关闭它们也是一个好主意，这样你就不必在你的机器或远程机器上占用资源。
- en: 'To close a session, use the `Remove-PSSession` cmdlet. For example, to close
    only the IIS sessions, use the following command:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要关闭会话，请使用 `Remove-PSSession` 命令。例如，要仅关闭 IIS 会话，请使用以下命令：
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Or, if you want to close all open sessions, use this next command:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果你想关闭所有打开的会话，请使用以下命令：
- en: '[PRE4]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: That’s easy enough.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单。
- en: 'But once you get some sessions up and running, what will you do with them?
    For the next couple of sections, we’ll assume you’ve created a variable named
    `$sessions` that contains at least two sessions. We’ll use `localhost` and `SRV02`
    (you should specify your own computer names). Using `localhost` isn’t cheating:
    PowerShell starts up a real remoting session with another copy of itself. Keep
    in mind that this will work only if you’ve enabled remoting on all computers to
    which you’re connected, so revisit chapter 13 if you haven’t enabled remoting.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 但是一旦你启动了一些会话，你会如何使用它们？在接下来的几节中，我们假设你已经创建了一个名为 `$sessions` 的变量，它包含至少两个会话。我们将使用
    `localhost` 和 `SRV02`（你应该指定你自己的计算机名称）。使用 `localhost` 并不是作弊：PowerShell 会启动一个与自身另一个副本的真实远程会话。请记住，这只有在您已启用所有连接的计算机的远程访问时才会工作，所以如果您还没有启用远程访问，请回顾第
    13 章。
- en: Try it Now Start to follow along and run these commands, and be sure to use
    valid computer names. If you have only one computer, use both its name and `localhost`.
    Hopefully, you will also have a machine running macOS or Linux that you can follow
    along with.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试看 开始跟随并运行这些命令，并确保使用有效的计算机名称。如果你只有一台计算机，请使用其名称和 `localhost`。希望你也会有一台运行 macOS
    或 Linux 的机器可以跟随。
- en: Above and beyond
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 超越
- en: 'There’s a cool syntax that allows you to create multiple sessions with one
    command and have each session assigned to a unique variable (instead of having
    them all lumped into one variable, as we previously did):'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种酷炫的语法允许你使用一条命令创建多个会话，并且每个会话都分配给一个唯一的变量（而不是像我们之前那样将它们全部合并到一个变量中）：
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This syntax puts the session for `SRV02` into `$s_server1`, and the session
    for `DC01` into `$s_server2`, which can make it easier to use those sessions independently.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这种语法将 `SRV02` 的会话放入 `$s_server1`，将 `DC01` 的会话放入 `$s_server2`，这可以使得独立使用这些会话变得更容易。
- en: 'But use caution: We’ve seen instances where the sessions aren’t created in
    exactly the order you specify, so `$s_server1` might end up containing the session
    for `DC01` instead of `SRV02`. You can display the variable’s contents to see
    which computer it’s connected to.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 但要小心：我们见过会话并不是按照你指定的顺序创建的情况，所以 `$s_server1` 可能最终包含 `DC01` 的会话而不是 `SRV02`。你可以显示变量的内容来查看它连接到哪台计算机。
- en: 'Here’s how we’ll get our sessions up and running:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们如何启动会话的方法：
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Remember that we’ve already enabled remoting on these computers, and the Windows
    machines are all in the same domain. Again, revisit chapter 13 if you’d like a
    refresher on how to enable remoting.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 记住我们已经在这些计算机上启用了远程访问，Windows 机器都在同一个域中。再次提醒，如果你想要复习如何启用远程访问，请回顾第 13 章。
- en: 18.2 Enter-PSSession with session objects
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 18.2 使用会话对象进入-PSSession
- en: 'Okay, now that you know all about the reasons for using sessions, let’s see
    how, exactly, to use them. As we hope you recall from chapter 13, the `Enter-PSSession`
    cmdlet is the one you use to engage a one-to-one remote interactive shell with
    a single remote computer. Rather than specifying a computer name or hostname with
    the cmdlet, you can specify a single session object. Because our `$session01`
    and `$session02` variables have more than one session object, we must specify
    one of them using an index (which you first learned to do in chapter 16):'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在你已经了解了使用会话的所有原因，让我们看看如何具体使用它们。正如我们希望你能从第13章回忆起来，`Enter-PSSession` cmdlet是你用来与单个远程计算机建立一对一远程交互式shell的命令。而不是使用该cmdlet指定计算机名或主机名，你可以指定一个会话对象。因为我们的`$session01`和`$session02`变量包含多个会话对象，我们必须使用索引（你是在第16章首次学习如何使用索引）来指定其中一个：
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You can see that our prompt changes to indicate that we’re now controlling
    a remote computer. `Exit-PSSession` returns us to the local prompt, but the session
    remains open for further use:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，我们的提示符已经改变，表明我们现在正在控制一台远程计算机。`Exit-PSSession`将我们返回到本地提示符，但会话仍然保持打开状态以供进一步使用：
- en: '[PRE8]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'What do you do if you have multiple sessions and forget the index number a
    particular session has? You can take the session variable and pipe it to `Get-Member`
    and examine the session object’s properties. For example, when we pipe `$session02`
    to `Get-Member`, we get the following output:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有多会话而忘记了特定会话的索引号怎么办？你可以将会话变量通过管道传递给`Get-Member`并检查会话对象的属性。例如，当我们通过管道将`$session02`传递给`Get-Member`时，我们得到以下输出：
- en: '[PRE9]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the preceding output, you can see that the session object has a `ComputerName`
    property, which means you can filter for that session:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中，你可以看到会话对象有一个`ComputerName`属性，这意味着你可以针对该会话进行筛选：
- en: '[PRE10]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: That’s awkward syntax, though. If you need to use a single session from a variable,
    and you can’t remember which index number is which, it might be easier to forget
    about using the variable.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种语法有些尴尬。如果你需要从一个变量中使用单个会话，而你又记不起哪个索引号对应哪个会话，可能更容易忘记使用变量。
- en: 'Even though you stored your session objects in the variable, they’re also still
    stored in PowerShell’s master list of open sessions. You can access them by using
    `Get-PSSession`:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你将会话对象存储在变量中，它们也仍然存储在PowerShell的开放会话主列表中。你可以通过使用`Get-PSSession`来访问它们：
- en: '[PRE11]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`Get-PSSession` retrieves the session having the computer named `SRV02` and
    passes it to the `-session` parameter of `Enter-PSSession`.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`Get-PSSession`检索名为`SRV02`的会话并将其传递给`Enter-PSSession`的`-session`参数。'
- en: 'When we first figured out that technique, we were impressed, but it also led
    us to dig a bit deeper. We pulled up the full help for `Enter-PSSession` and read
    more closely about the `-session` parameter. Here’s what we looked at:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们第一次弄懂那种技术时，我们感到印象深刻，但它也引导我们进一步深入挖掘。我们调出了`Enter-PSSession`的全局帮助，并更仔细地阅读了关于`-session`参数的内容。以下是我们的观察结果：
- en: '[PRE12]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If you think back to chapter 9, you’ll find that pipeline input information
    near the end of the help interesting. It tells us that the `-session` parameter
    can accept a `PSSession` object from the pipeline. We know that `Get-PSSession`
    produces `PSSession` objects, so the following syntax should also work:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你回想起第9章，你会在帮助文档的末尾发现一些有趣的管道输入信息。它告诉我们`-session`参数可以接受来自管道的`PSSession`对象。我们知道`Get-PSSession`会产生`PSSession`对象，所以以下语法也应该有效：
- en: '[PRE13]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: And it does work. We think that’s a much more elegant way to retrieve a single
    session, even if you’ve stored them all in a variable.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 它确实有效。我们认为这是一种检索单个会话的更优雅的方式，即使你将它们全部存储在变量中。
- en: Tip Storing sessions in a variable is fine as a convenience. But keep in mind
    that PowerShell is already storing a list of all open sessions. Having them in
    a variable is useful only when you want to refer to a bunch of sessions at once,
    as you’ll see in the next section.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士：将会话存储在变量中作为便利性是可行的。但请记住，PowerShell已经存储了所有开放会话的列表。将它们存储在变量中只有在你想一次性引用多个会话时才有用，正如你将在下一节中看到的。
- en: 18.3 Invoke-Command with session objects
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 18.3 使用会话对象的Invoke-Command
- en: 'Sessions show their usefulness with `Invoke-Command`, which you’ll remember
    you use to send a command (or an entire script) to multiple remote computers in
    parallel. With our sessions in a `$session01` variable, we can easily target them
    all with the following command:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 会话通过`Invoke-Command`展示了它们的有用性，你可能记得，这是用来向多个远程计算机并行发送命令（或整个脚本）的。在我们的会话存储在`$session01`变量中时，我们可以轻松地使用以下命令来针对它们：
- en: '[PRE14]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `-session` parameter of `Invoke-Command` can also be fed with a parenthetical
    command, much as we’ve done with computer names in previous chapters. For example,
    the following sends a command to every session connected to a computer whose name
    is listed:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`Invoke-Command`的`-session`参数也可以接收一个括号内的命令，就像我们在前面的章节中处理计算机名时所做的那样。例如，以下命令会向列出的每个计算机的会话发送命令：'
- en: '[PRE15]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You might expect that `Invoke-Command` would be able to receive session objects
    from the pipeline, as you know `Enter-PSSession` can. But a glance at the full
    help for `Invoke-Command` shows that it can’t do that particular pipeline trick.
    Too bad, but the preceding example of using a parenthetical expression provides
    the same functionality without too difficult a syntax.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能期望`Invoke-Command`能够从管道接收会话对象，就像你知道`Enter-PSSession`可以那样。但查看`Invoke-Command`的完整帮助文档显示，它不能执行那个特定的管道技巧。真遗憾，但前面使用括号表达式提供的功能没有太复杂的语法。
- en: '18.4 Implicit remoting: Importing a session'
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 18.4 隐式远程操作：导入会话
- en: Implicit remoting, for us, is one of the coolest and most useful—possibly *the*
    coolest and *the* most useful—feature a command-line interface has ever had, on
    any operating system, ever. Yet it’s barely documented in PowerShell. Sure, the
    necessary commands are well documented, but how they come together to form this
    incredible capability isn’t mentioned. Fortunately, we have you covered on this
    one.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们来说，隐式远程操作是我们认为最酷和最有用的——可能是*最酷和最有用的——功能，这是一个命令行界面在任何操作系统上都有过，而且几乎在PowerShell中几乎没有文档记录。当然，必要的命令有很好的文档记录，但它们如何组合形成这种令人难以置信的能力并没有提到。幸运的是，我们在这方面为你提供了覆盖。
- en: 'Let’s review the scenario: You already know that Microsoft is shipping more
    and more modules with Windows Server and other products, but sometimes you can’t
    install those modules on your local computer for one reason or another. The `ActiveDirectory`
    module, which shipped for the first time with Windows Server 2008 R2, is a perfect
    example: it exists only on domain controllers and on servers/clients with the
    Remote Server Administration Tools (RSAT) installed. Let’s look at the entire
    process in a single example:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下场景：你已经知道微软正在将越来越多的模块与Windows Server和其他产品一起发货，但有时由于各种原因，你无法在本地计算机上安装这些模块。`ActiveDirectory`模块，首次随Windows
    Server 2008 R2一起发货，是一个完美的例子：它只存在于域控制器以及安装了远程服务器管理工具（RSAT）的服务器/客户端上。让我们通过一个单独的例子来看整个过程：
- en: '[PRE16]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: ❶ Establishes a connection
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 建立连接
- en: ❷ Loads a remote module
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 加载远程模块
- en: ❸ Imports remote commands
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 导入远程命令
- en: ❹ Reviews the temporary local module
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 检查临时本地模块
- en: 'Here is what’s happening in that example:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是这个例子中发生的情况：
- en: We start by establishing a session with a remote computer that has the Active
    Directory module installed.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先与安装了Active Directory模块的远程计算机建立会话。
- en: We tell the remote computer to import its local Active Directory module. That’s
    just one example; we could have chosen to load any module. Because the session
    is still open, the module stays loaded on the remote computer.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们告诉远程计算机导入其本地的Active Directory模块。这只是其中一个例子；我们本可以选择加载任何模块。因为会话仍然打开，模块会保留在远程计算机上。
- en: We then tell our computer to import the commands from that remote session. We
    want only the commands in the Active Directory module, and when they’re imported,
    we want a `rem` prefix to be added to each command’s noun. That allows us to keep
    track of the remote commands more easily. It also means the commands won’t conflict
    with any same-named commands already loaded into our shell.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们告诉我们的计算机从那个远程会话中导入命令。我们只想导入Active Directory模块中的命令，并且当它们被导入时，我们希望为每个命令的名词添加一个`rem`前缀。这使我们能够更容易地跟踪远程命令。这也意味着命令不会与已经加载到我们的shell中的任何同名的命令冲突。
- en: PowerShell creates a temporary module on our computer that represents the remote
    commands. The commands aren’t copied over; instead, PowerShell creates shortcuts
    for them, and those shortcuts point to the remote machine.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: PowerShell在我们计算机上创建了一个临时模块，代表远程命令。命令并没有被复制过来；相反，PowerShell为它们创建了快捷方式，而这些快捷方式指向远程机器。
- en: Now we can run the Active Directory module commands or even ask for help. Instead
    of running `New-ADUser`, we run `New-remADUser`, because we added that `rem` prefix
    to the commands’ nouns. The commands remain available until we either close the
    shell or close that session with the remote computer. When we open a new shell,
    we have to repeat this process to regain access to the remote commands.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以运行Active Directory模块命令或甚至请求帮助。我们不是运行`New-ADUser`，而是运行`New-remADUser`，因为我们已经将`rem`前缀添加到命令的名词中。这些命令在我们关闭shell或关闭与远程计算机的会话之前都可用。当我们打开一个新的shell时，我们必须重复此过程才能重新获得对远程命令的访问权限。
- en: When we run these commands, they don’t execute on our local machine. Instead,
    they’re implicitly remoted to the remote computer. It executes them for us and
    sends the results to our computer.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行这些命令时，它们不会在我们的本地计算机上执行。相反，它们被隐式地远程到远程计算机上。它为我们执行它们并将结果发送到我们的计算机。
- en: We can envision a world where we don’t ever install administrative tools on
    our computers again. What a hassle we’d avoid. Today, you need tools that can
    run on your computer’s operating system and talk to whatever remote server you’re
    trying to manage—and getting everything to match up can be impossible. In the
    future, you won’t do that. You’ll use implicit remoting. Servers will offer their
    management features as another service, via Windows PowerShell.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以想象一个不再需要在我们的计算机上安装管理工具的世界。我们将会避免多少麻烦。今天，您需要能够在您的计算机操作系统上运行并与您试图管理的任何远程服务器通信的工具——让所有这些匹配起来可能是无法实现的。在未来，您将不会这样做。您将使用隐式远程。服务器将通过Windows
    PowerShell提供他们的管理功能作为另一个服务。
- en: 'Now for the bad news: The results brought to your computer through implicit
    remoting are all deserialized, meaning that the objects’ properties are copied
    into an XML file for transmission across the network. The objects you receive
    this way don’t have any methods. In most cases, that’s not a problem, but some
    modules and snap-ins produce objects that you’re meant to use in a more programmatic
    way, and those don’t lend themselves to implicit remoting. We hope you’ll encounter
    few (if any) objects with this limitation, as a reliance on methods violates some
    PowerShell design practices. If you do run into such objects, you won’t be able
    to use them through implicit remoting.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在来说说坏消息：通过隐式远程传递到您计算机上的结果都是反序列化的，这意味着对象的属性被复制到一个XML文件中，以便在网络中传输。通过这种方式接收到的对象没有任何方法。在大多数情况下，这不会成为问题，但有些模块和插件生成的对象是您打算以更程序化的方式使用的，而这些对象不适合隐式远程。我们希望您很少（如果有的话）会遇到具有这种限制的对象，因为依赖于方法违反了一些PowerShell设计原则。如果您确实遇到了这样的对象，您将无法通过隐式远程使用它们。
- en: 18.5 Using disconnected sessions
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 18.5 使用断开连接的会话
- en: PowerShell v3 introduced two improvements to its remote control capabilities.
    First, sessions are much less fragile, meaning they can survive brief network
    hiccups and other transient interruptions. You get that benefit even if you aren’t
    explicitly using a session object. Even if you’ve used `Enter-PSSession` and its
    `-ComputerName` parameter, you’re technically still using a session under the
    hood, so you get the more-robust connectivity.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell v3对其远程控制能力引入了两个改进。首先，会话变得更加稳固，这意味着它们可以承受短暂的网络中断和其他短暂的干扰。即使您没有明确使用会话对象，您也能获得这种好处。即使您已经使用了`Enter-PSSession`及其`-ComputerName`参数，技术上您仍然在使用底层的会话，因此您获得了更稳健的连接性。
- en: 'The other new feature introduced in v3 is one you have to explicitly use: disconnected
    sessions. Say you’re sitting on `COMPUTER1`, logged in as `Admin1` (who is a member
    of the Domain Admins group), and you create a new connection to `COMPUTER2`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: v3版本中引入的另一个新特性是您必须显式使用的：断开连接的会话。假设您坐在`COMPUTER1`上，以`Admin1`（他是域管理员组的成员）的身份登录，并创建到`COMPUTER2`的新连接：
- en: '[PRE17]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You can then disconnect that session. You still do this on `COMPUTER1`, where
    you’re sitting, and it disengages the connection between the two computers, but
    it leaves the copy of PowerShell up and running on `COMPUTER2`. Note that you
    do this by specifying the session’s ID number, which was displayed when you first
    created the session:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以断开该会话。您仍然在您所在的`COMPUTER1`上这样做，它会断开两个计算机之间的连接，但会保留在`COMPUTER2`上运行的PowerShell副本。请注意，您通过指定会话的ID号来完成此操作，该ID号在您首次创建会话时显示：
- en: '[PRE18]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This is something you obviously need to think about—you’re leaving a copy of
    PowerShell running on `COMPUTER2`. Assigning useful idle time-out periods and
    so forth becomes important. In earlier versions of PowerShell, a session that
    you disconnected went away, so you had no cleanup. Starting with v3, it’s possible
    to litter your environment with running sessions, which means you have to exercise
    a bit more responsibility.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这显然是你需要考虑的事情——你正在`COMPUTER2`上运行PowerShell的一个副本。分配有用的空闲超时时间等变得很重要。在PowerShell的早期版本中，你断开连接的会话会消失，所以你没有清理工作要做。从v3开始，你可以在环境中随意放置正在运行的会话，这意味着你必须承担更多的责任。
- en: 'But here’s the cool part: we’ll log into another computer, `COMPUTER3`, as
    the same domain admin named `Admin1`, and retrieve a list of sessions running
    on `COMPUTER2`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 但这里有个酷的地方：我们将以同一域管理员`Admin1`的身份登录到另一台计算机`COMPUTER3`，并检索在`COMPUTER2`上运行的会话列表：
- en: '[PRE19]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Neat, right? You couldn’t see this session if you’d logged in as a different
    user, even as another administrator; you can see only the sessions you created
    on `COMPUTER2`. But now, having seen it, you can reconnect it. This will allow
    you to reconnect to a session that you disconnected from either intentionally
    or unintentionally, and you will be able to pick up right where you left your
    session:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 真是整洁，对吧？如果你以不同的用户身份登录，即使是另一位管理员，你也看不到这个会话；你只能看到你在`COMPUTER2`上创建的会话。但现在，既然你已经看到了它，你可以重新连接它。这将允许你重新连接到一个你故意或无意中断的会话，并且你将能够从你离开的地方继续你的会话：
- en: '[PRE20]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Let’s spend some time talking about managing these sessions. In PowerShell’s
    WSMan drive, you’ll find settings that can help you keep disconnected sessions
    under control. You can also centrally configure most of these via Group Policy.
    The key settings to look for include the following:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们花些时间来谈谈管理这些会话。在PowerShell的WSMan驱动器中，你可以找到可以帮助你控制断开连接会话的设置。你还可以通过组策略集中配置这些设置中的大多数。要查找的关键设置包括以下内容：
- en: 'In WSMan:\localhost\Shell:'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '在 WSMan:\localhost\Shell:'
- en: '`IdleTimeout`—Specifies the amount of time a session can be idle before it’s
    shut down automatically. The default is about 2,000 hours (expressed in seconds),
    or about 84 days.'
  id: totrans-86
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IdleTimeout`—指定会话在自动关闭之前可以空闲的时间。默认值约为2,000小时（以秒为单位），或约84天。'
- en: '`MaxConcurrentUsers`—Specifies the number of users who can have a session open
    at once.'
  id: totrans-87
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MaxConcurrentUsers`—指定一次可以打开会话的用户数量。'
- en: '`MaxShellRunTime`—Determines the maximum amount of time a session can be open.
    The default is, for all practical purposes, infinite. Keep in mind that `IdleTimeout`
    can override this if the shell is sitting idle, as opposed to running commands.'
  id: totrans-88
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MaxShellRunTime`—确定会话可以打开的最大时间。从所有实际目的来看，默认值是无限的。请注意，如果shell处于空闲状态，`IdleTimeout`可以覆盖此设置，而不是运行命令。'
- en: '`MaxShellsPerUser`—Sets a limit on the number of sessions a single user can
    have open at once. Multiply this by `MaxConcurrentUsers` to figure out the maximum
    possible number of sessions, for all users, on the computer.'
  id: totrans-89
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MaxShellsPerUser`—设置单个用户一次可以打开的会话数量上限。将此值乘以`MaxConcurrentUsers`，可以计算出所有用户在计算机上可能的最大会话数量。'
- en: 'In WSMan:\localhost\Service:'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '在 WSMan:\localhost\Service:'
- en: '`MaxConnections`—Sets the upper limit on incoming connections to the entire
    remoting infrastructure. Even if you allow a larger number of shells per user
    or a maximum number of users, `MaxConnections` is the absolute limit on incoming
    connections.'
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MaxConnections`—设置整个远程基础设施的传入连接的上限。即使你允许每个用户或最大用户数有更多的shell，`MaxConnections`也是传入连接的绝对限制。'
- en: As an administrator, you obviously have a higher level of responsibility than
    a standard user. It’s up to you to keep track of your sessions, particularly if
    you’ll be disconnecting and reconnecting. Sensible time-out settings can help
    ensure that shell sessions don’t sit around idling for long stretches of time.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 作为管理员，你显然比标准用户有更高的责任。跟踪你的会话是你的责任，尤其是如果你会断开和重新连接。合理的时间超时设置可以帮助确保shell会话不会长时间空闲。
- en: 18.6 Lab
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 18.6 实验室
- en: Note For this lab, you need a Windows Server 2016, macOS, or Linux machine running
    PowerShell v7 or later. If you have access to only a client computer (running
    Windows 10 or later), you won’t be able to complete tasks 6 through 9 of this
    lab.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：对于这个实验室，你需要一台运行PowerShell v7或更高版本的Windows Server 2016、macOS或Linux机器。如果你只能访问客户端计算机（运行Windows
    10或更高版本），你将无法完成这个实验室的第6项至第9项任务。
- en: 'To complete this lab, you should have two computers: one to remote from and
    another to remote to. If you have only one computer, use its computer name to
    remote to it. You should get a similar experience that way:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个实验，你应该有两台计算机：一台用于远程连接，另一台用于远程到。如果你只有一台计算机，请使用其计算机名来远程连接到它。这样你将获得类似的经验：
- en: Close all open sessions in your shell.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭你在 shell 中打开的所有会话。
- en: Establish a session to a remote computer. Save the session in a variable named
    `$session`.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 建立到远程计算机的会话。将会话保存在名为 `$session` 的变量中。
- en: Use the `$session` variable to establish a one-to-one remote shell session with
    the remote computer. Display a list of processes and then exit.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `$session` 变量与远程计算机建立一对一的远程shell会话。显示进程列表然后退出。
- en: Use the `$session` variable with `Invoke-Command` and list the time zone of
    the remote machine.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `$session` 变量与 `Invoke-Command` 列出远程机器的时间区域。
- en: If you are on a Windows client, use `Get-PSSession` and `Invoke-Command` to
    get a list of the 20 most recent security event log entries from the remote computer.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你是在 Windows 客户端，使用 `Get-PSSession` 和 `Invoke-Command` 从远程计算机获取最近的 20 条安全事件日志条目列表。
- en: If you are on a macOS or Linux client, count the number of items in the `/var`
    directory. *Tasks 7–10 can only be performed on a Windows machine.*
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你在 macOS 或 Linux 客户端，计算 `/var` 目录中的项目数量。*任务 7-10 只能在 Windows 机器上执行。*
- en: Use `Invoke-Command` and your `$session` variable to load the `ServerManager`
    module on the remote computer.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `Invoke-Command` 和 `$session` 变量在远程计算机上加载 `ServerManager` 模块。
- en: Import the `ServerManager` module’s commands from the remote computer to your
    computer. Add the prefix `rem` to the imported commands’ nouns.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从远程计算机导入 `ServerManager` 模块的命令到你的计算机。给导入命令的名词添加前缀 `rem`。
- en: Run the imported `Get-WindowsFeature` command.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行导入的 `Get-WindowsFeature` 命令。
- en: Close the session that’s in your `$session` variable.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭 `$session` 变量中的会话。
- en: 18.7 Lab answers
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 18.7 实验答案
- en: '`get-pssession | Remove-PSSession`'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`get-pssession | Remove-PSSession`'
- en: '`$session=new-pssession –computername localhost`'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`$session=new-pssession –computername localhost`'
- en: '`enter-pssession $session`'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`enter-pssession $session`'
- en: '`Get-Process`'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Get-Process`'
- en: '`Exit`'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Exit`'
- en: '`invoke-command -ScriptBlock { get-timezone } -Session $session`'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`invoke-command -ScriptBlock { get-timezone } -Session $session`'
- en: '`Invoke-Command -ScriptBlock {get-eventlog -LogName System`'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Invoke-Command -ScriptBlock {get-eventlog -LogName System`'
- en: '`-Newest 20} -Session (Get-PSSession)`'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`-Newest 20} -Session (Get-PSSession)`'
- en: '`Get-ChildItem -Path /var | Measure-Object | select count`'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Get-ChildItem -Path /var | Measure-Object | select count`'
- en: '`Invoke-Command -ScriptBlock {Import-Module ServerManager}`'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Invoke-Command -ScriptBlock {Import-Module ServerManager}`'
- en: '`-Session $session`'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`-Session $session`'
- en: '`Import-PSSession -Session $session -Prefix rem`'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Import-PSSession -Session $session -Prefix rem`'
- en: '`-Module ServerManager`'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`-Module ServerManager`'
- en: '`Get-RemWindowsFeature`'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Get-RemWindowsFeature`'
- en: '`Remove-PSSession -Session $session`'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Remove-PSSession -Session $session`'
- en: 18.8 Further exploration
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 18.8 进一步探索
- en: 'Take a quick inventory of your environment: What PowerShell-enabled products
    do you have? Exchange Server? SharePoint Server? VMware vSphere? System Center
    Virtual Machine Manager? These and other products all include PowerShell modules,
    many of which are accessible via PowerShell remoting.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 快速盘点你的环境：你有哪些 PowerShell 启用的产品？Exchange 服务器？SharePoint 服务器？VMware vSphere？System
    Center 虚拟机管理器？这些和其他产品都包含 PowerShell 模块，其中许多可以通过 PowerShell 远程访问。
