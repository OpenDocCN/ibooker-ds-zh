- en: 2 Preparing for package development
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2 准备包开发
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Managing virtual environments using venv
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用venv管理虚拟环境
- en: Isolating project dependencies using virtual environments
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用虚拟环境隔离项目依赖
- en: Managing virtual environment creation and activation using venv
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用venv管理虚拟环境的创建和激活
- en: Listing installed dependencies using pip
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用pip列出已安装的依赖项
- en: At the beginning of a project, you’re likely eager to get started and accomplish
    something tangible. This is understandable—building things and solving problems
    can be rewarding. But it’s valuable to move slowly at first so you can move quickly
    later and longer as a project matures. When you’re exploring a new technology
    or process, it can also be helpful to practice with it first so you can use it
    deftly. A bit of planning up front can go a long way toward your productivity
    and resulting morale. In this chapter, you’ll use asdf and venv to create a development
    environment for the package you’ll work on for the rest of this book.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目开始时，你可能会急于开始并取得一些有形的结果。这是可以理解的——构建事物和解决问题是有回报的。但一开始缓慢移动是有价值的，这样你就可以在项目成熟后更快、更持久地移动。当你探索新技术或流程时，先练习它也可以很有帮助，这样你就可以熟练地使用它。一些初步的计划可以大大提高你的生产力和最终的情绪。在本章中，你将使用asdf和venv为你在本书剩余部分要工作的包创建一个开发环境。
- en: Important Before reading on, visit appendix A to install the tools you’ll need
    for this chapter.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 重要 在继续阅读之前，请访问附录A以安装本章所需的工具。
- en: 2.1 Managing Python virtual environments
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2.1 管理Python虚拟环境
- en: As you think more about the potential success of your CarCorp engagement, you
    realize that if the package you’re working to publish becomes popular, people
    using a variety of Python versions might want to install and use it. It isn’t
    likely that they’ll always be running the latest version of Python on their production
    systems. It’s a good practice to explicitly state the range of Python versions
    your package supports and test your package across all those versions. Because
    you’re leveraging the power of asdf and python-launcher from appendix A, you’ve
    already got most of the power you need. The last step is to create a virtual environment
    for use in local development of your package.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当你更多地思考你在CarCorp合作中的潜在成功时，你会意识到，如果你正在努力发布的包变得流行，使用各种Python版本的人可能想要安装并使用它。他们不太可能总是在他们的生产系统上运行Python的最新版本。明确声明你的包支持的Python版本范围，并在所有这些版本上测试你的包是一个好习惯。因为你正在利用附录A中的asdf和python-launcher的力量，你已经拥有了大部分你需要的力量。最后一步是为你的包的本地开发创建一个虚拟环境。
- en: When you install Python, it ships with the packages that are available in Python’s
    *standard library*.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当你安装Python时，它附带了一些在Python的*标准库*中可用的包。
- en: Definition A *standard library* defines which functionality is considered the
    core part of a programming language. The standard library of a language is built
    into the language or its installation process and is available by default after
    installing the language’s software on your system.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 一个*标准库*定义了哪些功能被认为是编程语言的核心部分。一种语言的标准库是构建到语言或其安装过程中，并在你在系统上安装该语言的软件后默认可用。
- en: Python’s standard library is extensive compared to some languages, but even
    then, it doesn’t provide all the functionality you might need for your projects.
    Python packages, the Python Package Index (PyPI), and the pip package manager
    exist to share software that extends beyond, or provides alternatives to, the
    Python standard library.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 与一些语言相比，Python的标准库非常广泛，但即使如此，它也不提供你可能需要的所有功能，用于你的项目。Python包、Python包索引（PyPI）和pip包管理器存在是为了共享超出Python标准库或提供替代品的软件。
- en: Imagine that when you first started your project with CarCorp, you used pip
    to install a few packages like `requests`. You also had some other packages installed
    from an earlier project for Vehicle Ventures. Did you notice that all these packages
    ended up together in one place, regardless of the project you were using them
    for?
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，当你最初与CarCorp合作开始你的项目时，你使用pip安装了一些包，比如`requests`。你还安装了一些来自早期项目Vehicle Ventures的其他包。你注意到所有这些包最终都集中在一个地方，无论你使用它们的项目是什么？
- en: By default, pip installs packages in a location related to the Python version
    with which pip itself was installed, known as the *site packages* directory. That
    is, when you install Python 3.7 and use the copy of pip that comes with it, packages
    you install will be stored in Python 3.7’s site packages directory. Installing
    all packages to this site packages directory might be manageable enough for a
    while, but what happens when you need different package versions for different
    projects? What happens if you need to list the minimum dependencies required for
    a single project? With the site packages directory full of packages from any and
    every project, these hurdles become difficult or impossible to address.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，pip 将包安装在与 pip 本身安装的 Python 版本相关的位置，称为*site packages*目录。也就是说，当你安装 Python
    3.7 并使用其附带的 pip 复制时，你安装的包将存储在 Python 3.7 的 site packages 目录中。将所有包安装到这个 site packages
    目录可能在一开始是可管理的，但当你需要为不同的项目使用不同的包版本时会发生什么？如果你需要列出单个项目所需的最低依赖项会发生什么？随着 site packages
    目录中充满了来自任何和每个项目的包，这些障碍变得难以解决或无法解决。
- en: One way to solve these problems is to *isolate* the packages for each project.
    In isolation, you can keep a list of each project’s minimum required dependencies.
    What’s more, one project is free to use `requests==2.1.0` even though another
    project uses `requests==2.24.0`. You learned about the value of decoupling in
    chapter 1\. Isolation of package dependencies decouples your projects from each
    other. You can achieve this isolation in Python using *virtual environments*.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这些问题的方法之一是*隔离*每个项目的包。在隔离状态下，你可以保留每个项目所需的最小依赖项列表。更重要的是，一个项目可以自由使用 `requests==2.1.0`，即使另一个项目使用
    `requests==2.24.0`。你在第一章中学习了解耦的价值。包依赖项的隔离使你的项目彼此解耦。你可以在 Python 中使用*虚拟环境*来实现这种隔离。
- en: Definition Python *virtual environments* are an isolated copy of Python with
    an isolated site packages directory. The copy of pip in the virtual environment’s
    Python installs packages to its isolated site packages directory, keeping them
    separate from other environments.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 定义 Python *虚拟环境* 是一个具有独立 site packages 目录的独立 Python 副本。虚拟环境中的 pip 副本将包安装到其独立的
    site packages 目录中，从而将它们与其他环境隔离开来。
- en: A virtual environment isn’t all that different conceptually from a normal Python
    installation. Instead of installing Python 3.7 and installing all your projects’
    dependencies into it, imagine installing Python 3.7 several times and giving each
    installation a unique name corresponding to each of your projects. You could then
    use each uniquely named Python installation for its corresponding project (see
    figure 2.1). This isn’t far off from how virtual environments work in practice.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟环境在概念上与正常的 Python 安装并没有太大的区别。不是安装 Python 3.7 并将所有项目的依赖项安装到其中，而是想象安装 Python
    3.7 多次，并为每个安装赋予一个与你的每个项目相对应的唯一名称。然后你可以为每个具有唯一名称的 Python 安装使用其对应的项目（见图 2.1）。这在实际操作中与虚拟环境的工作方式非常相似。
- en: '![](../../OEBPS/Images/02-01.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/02-01.png)'
- en: Figure 2.1 Virtual environments create isolated copies of Python and pip with
    their own installation directory for packages.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1 虚拟环境为 Python 和 pip 创建了具有各自安装目录的隔离副本。
- en: When you use Python within a virtual environment, you’ll be using a *copy* of
    the base Python version that created the environment.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在虚拟环境中使用 Python 时，你将使用创建该环境的基 Python 版本的*副本*。
- en: To test your package, you need to install packages not only in isolation from
    other projects but also across many base versions of Python. As the number of
    Python versions your project supports grows, it can become tedious to manage all
    the virtual environments and their Python installations manually (see figure 2.2).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试你的包，你需要安装的包不仅要从其他项目中隔离，还要跨越许多基础版本的 Python。随着你的项目支持的 Python 版本数量增加，手动管理所有虚拟环境和它们的
    Python 安装可能会变得繁琐（见图 2.2）。
- en: '![](../../OEBPS/Images/02-02.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/02-02.png)'
- en: Figure 2.2 Many base Python versions, each with many virtual environments created
    from them, may exist on a single system.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.2 在单个系统上可能存在许多基础 Python 版本，每个版本都创建了多个虚拟环境。
- en: You might be starting to see the value that tooling has in keeping all these
    things organized. Whereas asdf helps you install and manage base Python versions,
    venv helps you create virtual environments from those base Python versions.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能开始意识到工具在保持所有这些事物有序方面所具有的价值。 whereas asdf 帮助你安装和管理基础 Python 版本，venv 则帮助你从这些基础
    Python 版本创建虚拟环境。
- en: 2.1.1 Creating virtual environments with venv
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2.1.1 使用 venv 创建虚拟环境
- en: To make a base Python version available on your system, you use asdf to install
    it from the source code on the internet. To create a virtual environment, you
    make a copy of an installed base Python version with a unique name.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 要在你的系统上使一个基础Python版本可用，你使用asdf从互联网上的源代码安装它。要创建一个虚拟环境，你创建一个具有唯一名称的已安装基础Python版本的副本。
- en: 'To create a virtual environment, use the `venv` module from the base Python
    version, and pass it a name for the virtual environment’s directory. It’s a common
    convention to call this directory .venv/. Now create a virtual environment in
    your project by running the following commands:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个虚拟环境，使用基础Python版本的`venv`模块，并传递一个虚拟环境目录的名称。通常约定将此目录命名为.venv/。现在通过运行以下命令在你的项目中创建一个虚拟环境：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ Uses python-launcher so you can choose a base Python version
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用python-launcher以便你可以选择基础Python版本
- en: ❷ Passes a Python version flag
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 传递一个Python版本标志
- en: ❸ Creates a new virtual environment using the built-in venv module
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用内置的venv模块创建一个新的虚拟环境
- en: ❹ Creates a .venv/ directory in the current working directory
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 在当前工作目录中创建一个.venv/目录
- en: 'You won’t see any output if the command is successful, but you should see a
    .venv/ directory created. python-launcher on Unix systems will pick up on the
    presence of this new virtual environment and use it by default whenever you’re
    in this directory or its child directories. The Python launcher for Windows will
    pick up the virtual environment if that virtual environment is currently active.
    You can verify this by running the `py` command with no arguments. The interpreter
    that starts will match the base Python version you used to create the virtual
    environment, and you can use the following code to be sure it’s the virtual environment’s
    copy of Python:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果命令成功，你将看不到任何输出，但你应该看到一个创建的.venv/目录。Unix系统上的python-launcher会检测到这个新的虚拟环境，并在你在这个目录或其子目录中时默认使用它。Windows上的Python启动器如果当前激活了虚拟环境，也会检测到虚拟环境。你可以通过不带参数运行`py`命令来验证这一点。启动的解释器将与创建虚拟环境时使用的基Python版本相匹配，你可以使用以下代码来确保它是虚拟环境的Python副本：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If you pass a version flag to python-launcher, you’ll still get the base version.
    As an example, you should see something similar to the following when using `py
    -3.9`:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你传递了版本标志给python-launcher，你仍然会得到基础版本。例如，当你使用`py -3.9`时，你应该看到类似以下的内容：
- en: '[PRE2]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To prove that your virtual environment is isolated from the base Python version
    from which it was created, first run the following commands from your project’s
    directory to install the `requests` package in the virtual environment and check
    the resulting list of installed packages:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为了证明你的虚拟环境与创建它的基础Python版本是隔离的，首先从你的项目目录运行以下命令，在虚拟环境中安装`requests`包并检查安装后的包列表：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now confirm that these packages aren’t installed in the base Python version
    by explicitly passing the `-3.10` version flag:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在通过明确传递`-3.10`版本标志来确认这些包没有安装到基础Python版本中：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You can see that, by default, a virtual environment only has the `pip` and
    `setuptools` packages installed after you create it. These default packages and
    their versions are determined by the base Python installation. It’s good to get
    into the habit of updating pip and Setuptools to their latest available versions
    and installing the `wheel` package so you can install packages that have been
    prebuilt for your system instead of compiling them yourself. Install these now:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，默认情况下，创建虚拟环境后，它只安装了`pip`和`setuptools`包。这些默认包及其版本由基础Python安装决定。养成将pip和Setuptools更新到最新可用版本并安装`wheel`包的习惯是好的，这样你可以安装为你的系统预先构建的包，而不是自己编译。现在安装这些包：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Going forward, you’ll be able to use the `py` command in your project and be
    sure you’re always getting the copy of Python from your project’s virtual environment
    unless you explicitly ask for a different (base) Python. This can reduce your
    cognitive load, because you don’t need to remember to activate or deactivate the
    virtual environment manually each time you start or stop work on the project.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在未来，你将能够在你的项目中使用`py`命令，并且可以确信你总是从项目的虚拟环境中获取Python的副本，除非你明确要求不同的（基础）Python版本。这可以减少你的认知负担，因为你不需要每次开始或停止项目工作时要手动激活或关闭虚拟环境。
- en: Tip If you’re used to using your virtual environments automatically in an IDE
    like PyCharm ([https://www.jetbrains.com/pycharm/](https://www.jetbrains.com/pycharm/))
    or Visual Studio Code ([https://code.visualstudio.com/](https://code.visualstudio.com/)),
    you can still do so here even though you’re using python-launcher at the command
    line; the .venv/ directory is still a standard virtual environment.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：如果你习惯在PyCharm ([https://www.jetbrains.com/pycharm/](https://www.jetbrains.com/pycharm/))
    或 Visual Studio Code ([https://code.visualstudio.com/](https://code.visualstudio.com/))这样的IDE中自动使用虚拟环境，即使你在这里使用python-launcher命令行工具，你仍然可以这样做；.venv/目录仍然是一个标准的虚拟环境。
- en: You’ve learned the ins and outs of managing Python versions and virtual environments
    with asdf and venv. You’re ready to move on to creating the contents of your first
    Python package.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经掌握了使用asdf和venv管理Python版本和虚拟环境的方方面面。你现在可以继续前进，创建你的第一个Python包的内容。
- en: Summary
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Virtual environments decouple and isolate the dependencies of your different
    Python projects.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚拟环境将你的不同Python项目的依赖项解耦和隔离。
- en: Use python-launcher to reliably get the right version of Python.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用python-launcher可以可靠地获取正确的Python版本。
