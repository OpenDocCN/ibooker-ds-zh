- en: 1 Vert.x, asynchronous programming, and reactive systems
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1 Vert.x、异步编程和反应式系统
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: What Vert.x is
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是Vert.x
- en: Why distributed systems cannot be avoided
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么分布式系统无法避免
- en: The challenges in programming resource-efficient networked applications
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编程资源高效网络应用程序的挑战
- en: What asynchronous and non-blocking programming is
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是异步和非阻塞编程
- en: What a reactive application is, and why asynchronous programming is not enough
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反应式应用程序是什么，以及为什么异步编程不够
- en: Alternatives to Vert.x
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vert.x的替代方案
- en: We developers live in an industry of buzzwords, technologies, and practices
    hype cycles. I have long taught university students the elements of designing,
    program-ming, integrating, and deploying applications, and I have witnessed first-hand
    how complicated it can be for newcomers to navigate the wild ocean of current
    technologies.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们开发者生活在充满术语、技术和实践炒作周期的行业中。我长期以来一直教授大学生设计、编程、集成和部署应用程序的要素，并且亲眼目睹了新来者如何在新技术的汪洋大海中导航可能会多么复杂。
- en: '*Asynchronous* and *reactive* are important topics in modern applications,
    and my goal with this book is to help developers understand the core concepts
    behind these terms, gain practical experience, and recognize *when* there are
    benefits to these approaches. We will use *Eclipse Vert.x*, a toolkit for writing
    asynchronous applications that has the added benefit of providing solutions for
    the different definitions of what “reactive” means.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*异步*和*反应式*是现代应用程序中的重要主题，我的目标是帮助开发者理解这些术语背后的核心概念，获得实践经验，并认识到*何时*这些方法有好处。我们将使用*Eclipse
    Vert.x*，这是一个用于编写异步应用程序的工具包，它还提供了针对“反应式”不同定义的解决方案。'
- en: Ensuring that you understand the concepts is a priority for me in this book.
    While I want to give you a solid understanding of how to write Vert.x applications,
    I also want to make sure that you can translate the skills you learn here to other
    similar and possibly competing technologies, now or five years down the road.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，确保你理解这些概念是我的首要任务。虽然我希望你能够牢固地理解如何编写Vert.x应用程序，但我还想要确保你能够将在这里学到的技能应用到其他类似甚至可能竞争的技术中，无论是现在还是五年后。
- en: 1.1 Being distributed and networked is the norm
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.1 分布式和网络化是常态
- en: It was common 20 years ago to deploy business applications that could perform
    all operations while running isolated on a single machine. Such applications typically
    exhibited a graphical user interface, and they had local databases or custom file
    management for storing data. This is, of course, a gross exaggeration, as networking
    was already in use, and business applications could take advantage of database
    servers over the network, networked file storage, and various remote code operations.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 20年前，部署可以在单机上独立运行并执行所有操作的业务应用是很常见的。这类应用通常具有图形用户界面，并拥有本地数据库或自定义文件管理来存储数据。当然，这只是一个夸张的说法，因为当时网络已经投入使用，并且业务应用可以利用网络上的数据库服务器、网络化文件存储以及各种远程代码操作。
- en: Today, an application is more naturally exposed to end users through web and
    mobile interfaces. This naturally brings the network into play, and hence distributed
    systems. Also, *service-oriented architectures* allow the reuse of some functionality
    by issuing requests to other services, possibly controlled by a third-party provider.
    Examples would be delegating authentication in a consumer application to popular
    account providers like Google, Facebook, or Twitter, or delegating payment processing
    to Stripe or PayPal.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，应用程序更自然地通过Web和移动界面向最终用户暴露。这自然引入了网络，因此产生了分布式系统。此外，*面向服务的架构*通过向其他服务发出请求来重用某些功能，这些服务可能由第三方提供商控制。例如，将消费者应用程序中的身份验证委托给流行的账户提供商，如Google、Facebook或Twitter，或将支付处理委托给Stripe或PayPal。
- en: 1.2 Not living on an isolated island
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.2 不生活在孤岛上
- en: 'Figure 1.1 is a fictional depiction of what a modern application is: a set
    of networked services interacting with each other. Here are some of these networked
    services:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1是现代应用程序的一个虚构描述：一组相互交互的网络服务。以下是一些这些网络化服务：
- en: A database like PostgreSQL or MongoDB stores data.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类似PostgreSQL或MongoDB这样的数据库存储数据。
- en: A search engine like Elasticsearch allows finding information that was previously
    indexed, such as products in a catalog.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类似Elasticsearch这样的搜索引擎允许查找之前已索引的信息，例如目录中的产品。
- en: A durable storage service like *Amazon S3* provides persistent and replicated
    data storage of documents.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类似于 *Amazon S3* 的持久化存储服务提供文档的持久和复制数据存储。
- en: A messaging service can be
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息服务可以是
- en: An *SMTP* server to programmatically send emails.
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于程序发送电子邮件的 *SMTP* 服务器。
- en: A bot for interacting with users over messaging platforms, such as Slack, Telegram,
    or Facebook Messenger.
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于通过消息平台（如 Slack、Telegram 或 Facebook Messenger）与用户交互的机器人。
- en: An integration messaging protocol for application-to-application integration,
    like AMQP.
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于应用程序到应用程序集成的集成消息协议，如 AMQP。
- en: An identity management service like Keycloak provides authentication and role
    management for user and service interactions.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类似于 Keycloak 的身份管理服务为用户和服务交互提供身份验证和角色管理。
- en: Monitoring with libraries like Micrometer exposes health statuses, metrics,
    and logs so that external orchestration tools can maintain proper quality of service,
    possibly by starting new service instances or killing existing ones when they
    fail.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Micrometer 等库进行监控可以暴露健康状态、指标和日志，以便外部编排工具可以维护适当的服务质量，可能通过启动新的服务实例或终止失败的服务实例来实现。
- en: '![](../Images/CH01_F01_Ponge.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH01_F01_Ponge.png)'
- en: Figure 1.1 A networked application/service
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.1 一个网络化应用程序/服务
- en: Later in this book you will see examples of typical services such as API endpoints,
    stream processors, and edge services.[1](#pgfId-1012156) The preceding list is
    not exhaustive, of course, but the key point is that services rarely live in isolation,
    as they need to talk to other services over the network to function.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的后面部分，您将看到典型服务的示例，例如 API 端点、流处理程序和边缘服务。[1](#pgfId-1012156) 前面的列表当然不是详尽的，但关键点是服务很少孤立存在，因为它们需要通过网络与其他服务进行通信才能运行。
- en: 1.3 There is no free lunch on the network
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.3 网络上没有免费的午餐
- en: 'The network is exactly where a number of things may go wrong in computing:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 计算中可能出现问题的正是网络：
- en: The bandwidth can fluctuate a lot, so data-intensive interactions between services
    may suffer. Not all services can enjoy fast bandwidth inside the same data center,
    and even so, it remains slower than communications between processes on the same
    machine.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带宽可能会波动很大，因此服务之间密集的数据交互可能会受到影响。并非所有服务都能在同一个数据中心内享受快速带宽，即便如此，它仍然比同一台机器上进程之间的通信要慢。
- en: The latency fluctuates a lot, and because services need to talk to services
    that talk to additional services to process a given request, all network-induced
    latency adds to the overall request-processing times.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 延迟波动很大，因为服务需要与处理特定请求的附加服务进行通信，所以所有由网络引起的延迟都会加到总的请求处理时间上。
- en: 'Availability should not be taken for granted: Networks fail. Routers fail.
    Proxies fail. Sometimes someone runs into a network cable and disconnects it.
    When the network fails, a service that sends a request to another service may
    not be able to determine if it is the other service or the network that is down.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可用性不应被视为理所当然：网络会失败。路由器会失败。代理会失败。有时有人碰到网络电缆并将其断开。当网络失败时，向另一个服务发送请求的服务可能无法确定是另一个服务还是网络出现了故障。
- en: In essence, modern applications are made of distributed and networked services.
    They are accessed over networks that themselves introduce problems, and each service
    needs to maintain several incoming and outgoing connections.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，现代应用程序是由分布式和网络化服务组成的。它们通过网络访问，这些网络本身会引入问题，每个服务都需要维护多个传入和传出的连接。
- en: 1.4 The simplicity of blocking APIs
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.4 阻塞 API 的简单性
- en: Services need to manage connections to other services and requesters. The traditional
    and widespread model for managing concurrent network connections is to allocate
    a thread for each connection. This is the model in many technologies, such as
    Servlets in Jakarta EE (before additions in version 3), Spring Framework (before
    additions in version 5), Ruby on Rails, Python Flask, and many more. This model
    has the advantage of simplicity, as it is *synchronous*.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 服务需要管理与其他服务和请求者的连接。管理并发网络连接的传统和广泛使用的模型是为每个连接分配一个线程。这是许多技术中的模型，例如 Jakarta EE
    中的 Servlets（在版本 3 之前的添加）、Spring 框架（在版本 5 之前的添加）、Ruby on Rails、Python Flask 以及更多。这种模型的优势在于简单性，因为它具有
    *同步* 的特性。
- en: Let’s look at an example where a TCP server echoes input text back to the client
    until it sees a `/quit` terminal input (shown in listing 1.3).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子，其中 TCP 服务器将输入文本回显给客户端，直到它看到 `/quit` 终端输入（如列表 1.3 所示）。
- en: The server can be run using the Gradle `run` task from the book’s full example
    project (`./gradlew run -PmainClass=chapter1.snippets.SynchronousEcho` in a terminal).
    By using the `netcat` command-line tool, we can send and receive text.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器可以使用书中的完整示例项目中的Gradle `run`任务来运行（在终端中`./gradlew run -PmainClass=chapter1.snippets.SynchronousEcho`）。通过使用`netcat`命令行工具，我们可以发送和接收文本。
- en: Listing 1.1 Client-side output of a `netcat` session
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 列表1.1 `netcat`会话的客户端输出
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ This line is the user input on the command line.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 这一行是命令行上的用户输入。
- en: ❷ This line is sent by the TCP server.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 这一行是由TCP服务器发送的。
- en: Tip You may need to install `netcat` (or `nc`) on your operating system.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：您可能需要在您的操作系统上安装`netcat`（或`nc`）。
- en: On the server side, we can see the following trace.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器端，我们可以看到以下跟踪。
- en: Listing 1.2 Server-side trace
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 列表1.2 服务器端跟踪
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The code in the following listing provides the TCP server implementation. It
    is a classical use of the `java.io` package that provides synchronous I/O APIs.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表中的代码提供了TCP服务器实现。这是`java.io`包的经典用法，该包提供了同步I/O API。
- en: Listing 1.3 Synchronous echo TCP protocol
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 列表1.3 同步回显TCP协议
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ The main application thread plays the role of an accepting thread, as it receives
    socket objects for all new connections. The operation blocks when no connection
    is pending. A new thread is allocated for each connection.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 主要应用程序线程扮演着接受线程的角色，因为它接收所有新连接的套接字对象。当没有挂起的连接时，操作会阻塞。为每个连接分配一个新的线程。
- en: ❷ Reading from a socket may block the thread allocated to the connection, such
    as when insufficient data is being read.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 从套接字读取可能会阻塞分配给连接的线程，例如，当读取的数据不足时。
- en: ❸ Writing to a socket may also block, such as until the underlying TCP buffer
    data has been sent over the network.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 向套接字写入时也可能阻塞，例如，直到底层TCP缓冲区数据已通过网络发送。
- en: The server uses the main thread for accepting connections, and each connection
    is allocated a new thread for processing I/O. The I/O operations are synchronous,
    so threads may block on I/O operations.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器使用主线程来接受连接，并为每个连接分配一个新的线程来处理I/O。I/O操作是同步的，因此线程可能会在I/O操作上阻塞。
- en: 1.5 Blocking APIs waste resources, increase costs
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.5 阻塞API浪费资源，增加成本
- en: The main problem with the code in listing 1.3 is that it allocates a new thread
    for each incoming connection, and threads are anything but cheap resources. A
    thread needs memory, and the more threads you have, the more you put pressure
    on the operating system kernel scheduler, as it needs to give CPU time to the
    threads. We could improve the code in listing 1.3 by using a thread pool to reuse
    threads after a connection has been closed, but we still need *n* threads for
    *n* connections at any given point in time.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 列表1.3中的代码的主要问题是它为每个传入连接分配一个新的线程，而线程并不是廉价的资源。线程需要内存，并且线程越多，对操作系统内核调度器的压力就越大，因为它需要为线程分配CPU时间。我们可以通过使用线程池在连接关闭后重用线程来改进列表1.3中的代码，但我们在任何给定时间点仍然需要*n*个线程来处理*n*个连接。
- en: '![](../Images/CH01_F02_Ponge.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图1.2](../Images/CH01_F02_Ponge.png)'
- en: Figure 1.2 Threads and blocking I/O operations
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.2 线程和阻塞I/O操作
- en: 'This is illustrated in figure 1.2, where you can see the CPU usage over time
    of three threads for three concurrent network connections. Input/output operations
    such as `readLine` and `write` may *block* the thread, meaning that it is being
    parked by the operating system. This happens for two reasons:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这在图1.2中得到了说明，您可以看到三个并发网络连接的三个线程随时间变化的CPU使用率。如`readLine`和`write`之类的输入/输出操作可能会*阻塞*线程，这意味着线程被操作系统挂起。这种情况发生有两个原因：
- en: A read operation may be waiting for data to arrive from the network.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取操作可能正在等待从网络到达的数据。
- en: A write operation may have to wait for buffers to be drained if they are full
    from a previous write operation.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果缓冲区因之前的写操作而已满，写操作可能需要等待缓冲区被清空。
- en: A modern operating system can properly deal with a few thousand concurrent threads.
    Not every networked service will face loads with so many concurrent requests,
    but this model quickly shows its limits when we are talking about tens of thousands
    of concurrent connections.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现代操作系统可以正确处理几千个并发线程。并非每个网络服务都会面临如此多的并发请求的负载，但当我们谈论数万个并发连接时，这种模型很快就会显示出其局限性。
- en: It is also important to recall that we often need more threads than incoming
    network connections. To take a concrete example, suppose that we have an HTTP
    service that offers the best price for a given product, which it does by requesting
    prices from four other HTTP services, as illustrated in figure 1.3\. This type
    of service is often called an *edge service* or an *API gateway*. Requesting each
    service in sequence and then selecting the lowest price would render our service
    very slow, as each request adds to our own service’s latency. The efficient way
    is to start four concurrent requests from our service, and then wait and gather
    their responses. This translates to starting four more threads; if we had 1,000
    concurrent network requests, we might be using up to 5,000 threads in the worst
    naive case, where all requests need to be processed at the same time and we don’t
    use thread pooling or maintain persistent connections from the edge service to
    the requested services.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要记住，我们通常需要的线程比传入的网络连接多。以一个具体的例子来说明，假设我们有一个提供特定产品最佳价格的 HTTP 服务，它是通过请求四个其他 HTTP
    服务的价格来实现的，如图 1.3 所示。这类服务通常被称为 *边缘服务* 或 *API 网关*。按顺序请求每个服务并选择最低价格会使我们的服务非常慢，因为每个请求都会增加我们自己的服务延迟。有效的方法是从我们的服务开始四个并发请求，然后等待并收集它们的响应。这相当于启动四个额外的线程；如果我们有
    1,000 个并发网络请求，在最坏的情况下，我们可能需要使用多达 5,000 个线程，这时所有请求都需要同时处理，我们没有使用线程池或从边缘服务到请求服务的持久连接。
- en: '![](../Images/CH01_F03_Ponge.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.3 边缘服务中的请求处理](../Images/CH01_F03_Ponge.png)'
- en: Figure 1.3 Request processing in an edge service
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.3 边缘服务中的请求处理
- en: Last, but not least, applications are often deployed to containerized or virtualized
    environments. This means that applications may not see all the available CPU cores,
    and their allocated CPU time may be limited. Available memory for processes may
    also be restricted, so having too many threads also eats into the memory budget.
    Such applications have to share CPU resources with other applications, so if all
    applications use blocking I/O APIs, there can quickly be too many threads to manage
    and schedule, which requires starting more server/container instances as traffic
    ramps up. This translates directly to increased operating costs.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，应用程序通常部署到容器化或虚拟化环境中。这意味着应用程序可能看不到所有可用的 CPU 核心，并且它们分配的 CPU 时间可能有限。进程可用的内存也可能受到限制，因此拥有太多的线程也会消耗内存预算。这类应用程序必须与其他应用程序共享
    CPU 资源，所以如果所有应用程序都使用阻塞 I/O API，那么在流量增加时，可能会有太多线程需要管理和调度，这需要启动更多的服务器/容器实例，这直接导致运营成本增加。
- en: 1.6 Asynchronous programming with non-blocking I/O
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.6 使用非阻塞 I/O 的异步编程
- en: Instead of waiting for I/O operations to complete, we can shift to *non-blocking*
    I/O. You may have already sampled this with the `select` function in C.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以转向 *非阻塞* I/O 而不是等待 I/O 操作完成。你可能已经通过 C 中的 `select` 函数体验过这种非阻塞 I/O。
- en: The idea behind non-blocking I/O is to request a (blocking) operation, and move
    on to doing other tasks until the operation result is ready. For example a non-blocking
    read may ask for up to 256 bytes over a network socket, and the execution thread
    does other things (like dealing with another connection) until data has been put
    into the buffers, ready for consumption in memory. In this model, many concurrent
    connections can be multiplexed on a single thread, as network latency typically
    exceeds the CPU time it takes to read incoming bytes.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 非阻塞 I/O 的理念是请求一个（阻塞的）操作，然后继续做其他任务，直到操作结果准备好。例如，非阻塞读取可能请求网络套接字上的多达 256 字节，执行线程会做其他事情（比如处理另一个连接），直到数据被放入缓冲区，准备在内存中消费。在这个模型中，许多并发连接可以在单个线程上复用，因为网络延迟通常超过读取传入字节所需的
    CPU 时间。
- en: Java has long had the `java.nio` (Java NIO) package, which offers non-blocking
    I/O APIs over files and networks. Going back to our previous example of a TCP
    service that echoes incoming data, listings 1.4 through 1.7 show a possible implementation
    with Java non-blocking I/O.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Java 很早就有了 `java.nio` (Java NIO) 包，它提供了文件和网络上的非阻塞 I/O API。回到我们之前关于 TCP 服务回显传入数据的例子，列表
    1.4 到 1.7 展示了使用 Java 非阻塞 I/O 的可能实现。
- en: 'Listing 1.4 Asynchronous variant of the echo service: main loop'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1.4 异步版本的 echo 服务：主循环
- en: '[PRE3]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ We need to put the channel into non-blocking mode.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们需要将通道置于非阻塞模式。
- en: ❷ The selector will notify of incoming connections.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 选择器将通知传入的连接。
- en: ❸ This collects all non-blocking I/O notifications.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 这收集了所有非阻塞 I/O 通知。
- en: ❹ We have a new connection.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 我们有一个新的连接。
- en: ❺ A socket has received data.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 套接字已收到数据。
- en: ❻ A socket is ready for writing again.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 套接字再次准备好写入。
- en: ❼ Selection keys need to be manually removed, or they will be available again
    in the next loop iteration.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 需要手动删除选择键，否则它们将在下一次循环迭代中再次可用。
- en: Listing 1.4 shows the server socket channel preparation code. It opens the server
    socket channel and makes it non-blocking, then registers an NIO key selector for
    processing events. The main loop iterates over the selector keys that have events
    ready for processing and dispatches them to specialized methods depending on the
    event type (new connections, data has arrived, or data can be sent again).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1.4 展示了服务器套接字通道准备代码。它打开服务器套接字通道并将其设置为非阻塞，然后注册一个 NIO 键选择器以处理事件。主循环遍历已准备好处理事件的选择键，并根据事件类型（新连接、数据到达或数据可以再次发送）将它们调度到专门的方法。
- en: 'Listing 1.5 Asynchronous variant of the echo service: accepting connections'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1.5 异步版本的 echo 服务：接受连接
- en: '[PRE4]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ The Context class keeps state related to the handling of a TCP connection.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ Context 类保存与处理 TCP 连接相关的状态。
- en: ❷ We set the channel to non-blocking and declare interest in read operations.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 我们将通道设置为非阻塞并声明对读取操作的兴趣。
- en: ❸ We keep all connection states in a hash map.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 我们将所有连接状态保存在一个哈希表中。
- en: Listing 1.5 shows how new TCP connections are dealt with. The socket channel
    that corresponds to the new connection is configured as non-blocking and then
    is tracked for further reference in a hash map, where it is associated to some
    *context object*. The context depends on the application and protocol. In our
    case, we track the current line and whether the connection is closing, and we
    maintain a connection-specific NIO buffer for reading and writing data.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1.5 展示了如何处理新的 TCP 连接。对应于新连接的套接字通道被配置为非阻塞，然后在哈希表中跟踪以供进一步参考，其中它与某个 *上下文对象*
    关联。上下文取决于应用程序和协议。在我们的情况下，我们跟踪当前行和连接是否正在关闭，并维护一个特定于连接的 NIO 缓冲区用于读取和写入数据。
- en: 'Listing 1.6 Asynchronous variant of the echo service: echoing data'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1.6 异步版本的 echo 服务：回显数据
- en: '[PRE5]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ If we find a line ending with /quit, we terminate the connection.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 如果我们找到一个以 /quit 结尾的行，我们将终止连接。
- en: '❷ Java NIO buffers need positional manipulations: the buffer has read data,
    so to write it back to the client, we need to flip and return to the start position.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ Java NIO 缓冲区需要进行位置操作：缓冲区中有读取的数据，因此要将它写回客户端，我们需要翻转并返回到起始位置。
- en: ❸ It may happen that not all data can be written, so we stop looking for read
    operations and declare interest in a notification indicating when the channel
    can be written to again.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 可能会发生的情况是并非所有数据都可以写入，因此我们停止寻找读取操作，并声明对通知的兴趣，该通知指示何时可以再次写入通道。
- en: 'Listing 1.6 has the code for the `echo` method. The processing is very simple:
    we read data from the client socket, and then we attempt to write it back. If
    the write operation was only partial, we stop further reads, declare interest
    in knowing when the socket channel is writable again, and then ensure all data
    is written.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1.6 包含 `echo` 方法的代码。处理非常简单：我们从客户端套接字读取数据，然后尝试将其写回。如果写入操作只是部分完成，我们停止进一步的读取，声明对知道套接字通道何时可写的兴趣，并确保所有数据都已写入。
- en: 'Listing 1.7 Asynchronous variant of the echo service: continuing and closing'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1.7 异步版本的 echo 服务：继续和关闭
- en: '[PRE6]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ We remain in this state until all data has been written back. Then we drop
    our write interest and declare read interest.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们保持在这个状态，直到所有数据都已写回。然后我们取消写入兴趣并声明读取兴趣。
- en: Finally, listing 1.7 shows the methods for closing the TCP connection and for
    finishing writing a buffer. When all data has been written in `continueEcho`,
    we register interest again in reading data.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，列表 1.7 展示了关闭 TCP 连接和完成写入缓冲区的方法的代码。在 `continueEcho` 中所有数据都已写入后，我们再次注册对读取数据的兴趣。
- en: 'As this example shows, using non-blocking I/O is doable, but it significantly
    increases the code complexity compared to the initial version that used blocking
    APIs. The echo protocol needs two states for reading and writing back data: reading,
    or finishing writing. For more elaborate TCP protocols, you can easily anticipate
    the need for more complicated state machines.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 正如这个示例所示，使用非阻塞 I/O 是可行的，但与使用阻塞 API 的初始版本相比，它显著增加了代码的复杂性。echo 协议需要两个状态来读取和写回数据：读取或完成写入。对于更复杂的
    TCP 协议，你可以很容易地预测需要更复杂的状态机。
- en: It is also important to note that like most JDK APIs, `java.nio` focuses solely
    on what it does (here, I/O APIs). It does not provide higher-level protocol-specific
    helpers, like for writing HTTP clients and servers. Also, `java.nio` does not
    prescribe a threading model, which is still important to properly utilize CPU
    cores, nor does it handle asynchronous I/O events or articulate the application
    processing logic.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要注意的是，与大多数JDK API一样，`java.nio`仅关注它所做的事情（在这里，I/O API）。它不提供高级协议特定的辅助工具，例如编写HTTP客户端和服务器。此外，`java.nio`不指定线程模型，这对于正确利用CPU核心仍然很重要，它也不处理异步I/O事件或阐述应用程序处理逻辑。
- en: Note This is why, in practice, developers rarely deal with Java NIO. Networking
    libraries like Netty and Apache MINA solve the shortcomings of Java NIO, and many
    toolkits and frameworks are built on top of them. As you will soon discover, Eclipse
    Vert.x is one of them.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：这就是为什么在实际中，开发者很少直接处理Java NIO。像Netty和Apache MINA这样的网络库解决了Java NIO的不足，许多工具包和框架都是建立在它们之上的。你很快会发现，Eclipse
    Vert.x就是其中之一。
- en: '1.7 Multiplexing event-driven processing: The case of the event loop'
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.7 事件驱动处理的复用：事件循环的案例
- en: A popular threading model for processing asynchronous events is that of the
    event loop. Instead of polling for events that may have arrived, as we did in
    the previous Java NIO example, events are pushed to an *event loop*.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 处理异步事件的流行线程模型是事件循环。与我们在之前的Java NIO示例中那样轮询可能到达的事件不同，事件被推送到一个*事件循环*。
- en: As you can see in figure 1.4, events are queued as they arrive. They can be
    I/O events, such as data being ready for consumption or a buffer having been fully
    written to a socket. They can also be any *other* event, such as a timer firing.
    A single thread is assigned to an event loop, and processing events shouldn’t
    perform any blocking or long-running operation. Otherwise, the thread blocks,
    defeating the purpose of using an event loop.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如图1.4所示，事件在到达时被排队。它们可以是I/O事件，例如数据准备好消费或缓冲区已完全写入套接字。它们也可以是任何*其他*事件，例如定时器触发。一个线程被分配给一个事件循环，处理事件不应执行任何阻塞或长时间运行的操作。否则，线程会阻塞，违背了使用事件循环的目的。
- en: '![](../Images/CH01_F04_Ponge.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH01_F04_Ponge.png)'
- en: Figure 1.4 Processing events using an event loop
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.4 使用事件循环处理事件
- en: 'Event loops are quite popular: JavaScript code running in web browsers runs
    on top of an event loop. Many graphical interface toolkits, such as Java Swing,
    also have an event loop.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 事件循环非常流行：在浏览器中运行的JavaScript代码是在事件循环之上运行的。许多图形界面工具包，如Java Swing，也有事件循环。
- en: Implementing an event loop is easy.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 实现事件循环很简单。
- en: Listing 1.8 Using a simple event loop
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 列表1.8 使用简单的事件循环
- en: '[PRE7]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ A first thread that dispatches events every second to the event loop
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 一个每秒向事件循环调度事件的第一个线程
- en: ❷ A second thread that dispatches two events at 2500 ms and 3300 ms
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 一个每2500毫秒和3300毫秒调度两个事件的第二个线程
- en: ❸ Events dispatched from the main thread
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 从主线程派发的事件
- en: ❹ Event handlers defined as Java lambda functions
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 定义为Java lambda函数的事件处理器
- en: ❺ This method wraps a possibly checked exception into an unchecked exception
    to avoid polluting the main method code with exception-handling logic.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 此方法将可能抛出的检查异常包装为未检查异常，以避免将异常处理逻辑污染主方法代码。
- en: The code in listing 1.8 shows the use of an event-loop API whose execution gives
    the following console output.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 列表1.8中的代码展示了使用事件循环API的使用情况，其执行会给出以下控制台输出。
- en: Listing 1.9 Console output from the event-loop example
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 列表1.9 事件循环示例的控制台输出
- en: '[PRE8]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: More sophisticated event-loop implementations are possible, but the one in the
    following listing relies on a queue of events and a map of handlers.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 更复杂的事件循环实现是可能的，但以下列表中的实现依赖于事件队列和处理程序映射。
- en: Listing 1.10 A simple event-loop implementation
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 列表1.10 简单事件循环实现
- en: '[PRE9]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ❶ Handlers are stored in a map where each key has a handler.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 处理器存储在一个映射中，其中每个键都有一个处理器。
- en: ❷ Dispatching is pushing events to a queue.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 调度是将事件推送到队列中。
- en: ❸ The event loop looks for events and finds a handler based on event keys.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 事件循环查找事件并根据事件键找到处理器。
- en: The event loop runs on the thread that calls the `run` method, and events can
    be safely sent from other threads using the `dispatch` method.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 事件循环在调用`run`方法的线程上运行，可以使用`dispatch`方法从其他线程安全地发送事件。
- en: Last, but not least, an event is simply a pair of a key and data, as shown in
    the following, which is a static inner class of `EventLoop`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，一个事件简单来说就是一对键和数据的组合，如下所示，这是`EventLoop`的静态内部类。
- en: Listing 1.11 A simple event-loop implementation
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 列表1.11 简单的事件循环实现
- en: '[PRE10]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 1.8 What is a reactive system?
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.8 什么是反应式系统？
- en: 'So far we have discussed how to do the following:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了以下内容：
- en: Leverage asynchronous programming and non-blocking I/O to handle more concurrent
    connections and use less threads
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用异步编程和非阻塞I/O来处理更多并发连接并使用更少的线程
- en: Use one threading model for asynchronous event processing (the event loop)
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用一个线程模型进行异步事件处理（事件循环）
- en: By combining these two techniques, we can build scalable and resource-efficient
    applications. Let’s now discuss what a *reactive system* is and how it goes beyond
    “just” asynchronous programming.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 通过结合这两种技术，我们可以构建可伸缩和资源高效的程序。现在让我们讨论一下什么是*反应式系统*以及它是如何超越“仅仅”异步编程的。
- en: 'The four properties of reactive systems are exposed in *The Reactive Manifesto*:
    *responsive*, *resilient*, *elastic*, and *message-driven* ([www.reactivemanifesto.org/](http://www.reactivemanifesto.org/)).
    We are not going to paraphrase the manifesto in this book, so here is a brief
    take on what these properties are about:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 反应式系统的四个特性在*《反应式宣言》*中得到了体现：*响应性*、*弹性*、*可伸缩性*和*消息驱动*([www.reactivemanifesto.org/](http://www.reactivemanifesto.org/))。我们不会在这本书中重述宣言，所以这里简要说明一下这些特性是什么：
- en: '*Elastic* --Elasticity is the ability for the application to work with a variable
    number of instances. This is useful, as elasticity allows the app to respond to
    traffic spikes by starting new instances and load-balancing traffic across instances.
    This has an interesting impact on the code design, as shared state across instances
    needs to be well identified and limited (e.g., server-side web sessions). It is
    useful for instances to report *metrics*, so that an orchestrator can decide when
    to start or stop instances based on both network traffic and reported metrics.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*可伸缩性* -- 可伸缩性是应用程序能够与可变数量的实例一起工作的能力。这很有用，因为可伸缩性允许应用程序通过启动新实例和跨实例负载均衡流量来响应流量峰值。这对代码设计有有趣的影响，因为实例之间的共享状态需要被很好地识别和限制（例如，服务器端Web会话）。对于实例报告*指标*很有用，这样协调器就可以根据网络流量和报告的指标来决定何时启动或停止实例。'
- en: '*Resilient* --Resiliency is partially the flip side of elasticity. When one
    instance crashes in a group of elastic instances, resiliency is naturally achieved
    by redirecting traffic to other instances, and a new instance can be started if
    necessary. That being said, there is more to resiliency. When an instance cannot
    fulfill a request due to some conditions, it still tries to answer in *degraded
    mode*. Depending on the application domain, it may be possible to respond with
    older cached values, or even to respond with empty or default data. It may also
    be possible to forward a request to some other, non-error instance. In the worst
    case, an instance can respond with an error, but in a timely fashion.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*弹性* -- 弹性部分是弹性的反面。当一个弹性实例崩溃时，通过将流量重定向到其他实例，弹性自然地实现了，如果需要的话，还可以启动一个新的实例。但话又说回来，弹性还有更多。当一个实例由于某些条件无法满足请求时，它仍然会尝试以*降级模式*进行响应。根据应用领域，它可能可以使用较旧的缓存值进行响应，甚至可以响应空或默认数据。也可能将请求转发到某些其他非错误实例。在最坏的情况下，实例可以响应错误，但必须及时。'
- en: '*Responsive* --Responsivity is the result of combining elasticity and resiliency.
    Consistent response times provide strong service-level agreement guarantees. This
    is achieved both thanks to the ability to start new instances if need be (to keep
    response times acceptable), and also because instances still respond quickly when
    errors arise. It is important to note that responsivity is not possible if one
    component relies on a non-scalable resource, like a single central database. Indeed,
    starting more instances does not solve the problem if they all issue requests
    to one resource that is quickly going to be overloaded.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*响应性* -- 响应性是弹性和弹性的结合结果。一致的反应时间提供了强大的服务级别协议保证。这既得益于在需要时启动新实例的能力（以保持可接受的反应时间），也得益于实例在出现错误时仍然能够快速响应。重要的是要注意，如果一个组件依赖于非可伸缩的资源，如单个中央数据库，则响应性是不可能的。确实，如果它们都向一个很快就会过载的资源发出请求，那么启动更多实例并不能解决问题。'
- en: '*Message-driven* --Using asynchronous message passing rather than blocking
    paradigms like remote procedure calls is the key enabler of elasticity and resiliency,
    which lead to responsiveness. This also enables messages to be dispatched to more
    instances (making the system elastic) and controls the flow between message producers
    and message consumers (this is *back-pressure*, and we will explore it later in
    this book).'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*消息驱动* --使用异步消息传递而不是像远程过程调用这样的阻塞范式是弹性性和弹性的关键推动者，这导致了响应性。这也使得消息可以被发送到更多的实例（使系统具有弹性），并控制消息生产者和消息消费者之间的流量（这就是**反馈压力**，我们将在本书后面探讨它）。'
- en: A reactive system exhibits these four properties, which make for *dependable*
    and *resource-efficient* systems.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 一个反应式系统表现出这四个特性，这使得系统**可靠**且**资源高效**。
- en: Does asynchronous imply reactive?
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 异步是否意味着反应式？
- en: This is an important question, as being asynchronous is often presented as being
    a magic cure for software woes. Clearly, reactive implies asynchronous, but the
    converse is not necessarily true.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个重要的问题，因为异步通常被宣传为软件问题的神奇疗法。显然，反应式意味着异步，但反之不一定成立。
- en: As a (not so) fictitious example, consider a shopping web application where
    users can put items in a shopping cart. This is classically done by storing items
    in a server-side web session. When sessions are being stored in memory or in local
    files, the system is not reactive, even if it internally uses non-blocking I/O
    and asynchronous programming. Indeed, an instance of the application cannot take
    over another one because sessions are application state, and in this case that
    state is not being replicated and shared across nodes.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 作为（并非如此）虚构的例子，考虑一个购物网站应用程序，用户可以将商品放入购物车。这通常是通过将商品存储在服务器端Web会话中实现的。当会话存储在内存或本地文件中时，即使系统内部使用非阻塞I/O和异步编程，系统也不是反应式的。实际上，应用程序的一个实例不能接管另一个实例，因为会话是应用程序状态，在这种情况下，该状态没有被复制并在节点之间共享。
- en: A reactive variant of this example would use a memory grid service (e.g., Hazelcast,
    Redis, or Infinispan) to store the web sessions, so that incoming requests could
    be routed to any instance.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子的一种反应式变体会使用内存网格服务（例如，Hazelcast、Redis或Infinispan）来存储Web会话，以便将传入的请求路由到任何实例。
- en: 1.9 What else does reactive mean?
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.9 反应式还意味着什么？
- en: As *reactive* is a trendy term, it is also being used for very different purposes.
    You just saw what a *reactive system* is, but there are two other popular reactive
    definitions, summarized in table 1.1.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 由于**反应式**是一个流行的术语，它也被用于非常不同的目的。您刚刚看到了**反应式系统**是什么，但还有两个其他流行的反应式定义，总结在表1.1中。
- en: Table 1.1 All the reactive things
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 表1.1 所有反应式事物
- en: '| Reactive? | Description |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| 反应式？ | 描述 |'
- en: '| Systems | Dependable applications that are message-driven, resilient, elastic,
    and responsive. |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| 系统 | 依赖性强、消息驱动、弹性好、响应快的应用程序。 |'
- en: '| Programming | A means of reacting to changes and events. Spreadsheet programs
    are a great example of reactive programming: when cell data changes, cells having
    formulas depending on affected cells are recomputed automatically. Later in this
    book you will see RxJava, a popular reactive extensions API for Java that greatly
    helps coordinate asynchronous event and data processing. There is also functional
    reactive programming, a style of programming that we won’t cover in this book
    but for which Functional Reactive Programming by Stephen Blackheath and Anthony
    Jones (Manning, 2016) is a fantastic resource. |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| 编程 | 一种对变化和事件做出反应的方式。电子表格程序是反应式编程的一个很好的例子：当单元格数据发生变化时，依赖于受影响单元格的公式所在的单元格会自动重新计算。在本书的后面部分，您将看到RxJava，这是一个流行的Java反应式扩展API，它极大地帮助协调异步事件和数据处理。还有函数式反应式编程，这是一种编程风格，我们在这本书中不会涉及，但Stephen
    Blackheath和Anthony Jones的《函数式反应式编程》（Manning, 2016）是一本极好的资源。 |'
- en: '| Streams | When systems exchange continuous streams of data, the classical
    producer/consumer problems arise. It is especially important to provide back-pressure
    mechanisms so that a consumer can notify a producer when it is emitting too fast.
    With reactive streams ([www.reactive-streams.org](http://www.reactive-streams.org)),
    the main goal is to reach the best throughput between systems. |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| 流 | 当系统交换连续的数据流时，会出现经典的生产者/消费者问题。提供反馈压力机制特别重要，以便消费者可以在发出太快时通知生产者。通过反应式流([www.reactive-streams.org](http://www.reactive-streams.org))，主要目标是实现系统之间最佳的数据吞吐量。
    |'
- en: 1.10 What is Vert.x?
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.10 什么是Vert.x？
- en: According to the Vert.x website ([https://vertx.io/](https://vertx.io/)), “Eclipse
    Vert.x is a tool-kit for building reactive applications on the JVM.”
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 Vert.x 网站 ([https://vertx.io/](https://vertx.io/))，“Eclipse Vert.x 是在 JVM
    上构建反应式应用程序的工具包。”
- en: Initiated by Tim Fox in 2012, Vert.x is a project now fostered at the vendor-neutral
    Eclipse Foundation. While the first project iterations were aimed at being a “Node.js
    for the JVM,” Vert.x has since significantly deviated toward providing an asynchronous
    programming foundation tailored for the specifics of the JVM.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 由 Tim Fox 于 2012 年发起，Vert.x 是一个现在由供应商中立的 Eclipse 基金会培养的项目。虽然最初的项目迭代旨在成为“JVM
    上的 Node.js”，但 Vert.x 自那时起已经显著偏离，转向提供针对 JVM 特定性的异步编程基础。
- en: The essence of Vert.x
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Vert.x 的本质
- en: As you may have guessed from the previous sections of this chapter, the focus
    of Vert.x is processing asynchronous events, mostly coming from non-blocking I/O,
    and the threading model processes events in an event loop.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从本章前面的部分所猜测的那样，Vert.x 的重点是处理异步事件，这些事件主要来自非阻塞 I/O，而线程模型在事件循环中处理事件。
- en: 'It is very important to understand that Vert.x is a *toolkit* and not a *framework*:
    it does not provide a predefined foundation for your application, so you are free
    to use Vert.x as a library inside a larger code base. Vert.x is largely unopinionated
    on the build tools that you should be using, how you want to structure your code,
    how you intend to package and deploy it, and so on. A Vert.x application is an
    assembly of modules providing exactly what you need, and nothing more. If you
    don’t need to access a database, then your project does not need to depend on
    database-related APIs.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 非常重要的是要理解 Vert.x 是一个 *工具包* 而不是一个 *框架*：它不提供您应用程序的预定义基础，因此您可以在更大的代码库中使用 Vert.x
    作为库。Vert.x 在您应该使用的构建工具、您想要如何结构化代码、您打算如何打包和部署它等方面几乎没有意见。一个 Vert.x 应用程序是模块的集合，提供您确切需要的东西，没有更多。如果您不需要访问数据库，那么您的项目就不需要依赖于数据库相关的
    API。
- en: 'The Vert.x project is organized in composable modules, with figure 1.5 showing
    the structure of a random Vert.x application:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Vert.x 项目的组织结构是可组合的模块，图 1.5 展示了一个随机 Vert.x 应用的结构：
- en: A core project, called `vertx-core`, provides the APIs for asynchronous programming,
    non-blocking I/O, streaming, and convenient access to networked protocols such
    as TCP, UDP, DNS, HTTP, or WebSockets.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个核心项目，名为 `vertx-core`，提供了异步编程、非阻塞 I/O、流式处理以及方便访问网络协议（如 TCP、UDP、DNS、HTTP 或 WebSockets）的
    API。
- en: A set of modules that are part of the community-supported Vert.x stack, such
    as a better web API (`vertx-web`) or data clients (`vertx-kafka-client`, `vertx-redis`,
    `vertx-mongo`, etc.) provide functionality for building all kinds of applications.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一组属于社区支持的 Vert.x 栈的模块，例如更好的 Web API (`vertx-web`) 或数据客户端 (`vertx-kafka-client`、`vertx-redis`、`vertx-mongo`
    等)，为构建各种应用程序提供了功能。
- en: A wider ecosystem of projects provides even more functionality, such as connecting
    with Apache Cassandra, non-blocking I/O to communicate between system processes,
    and so on.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个更广泛的生态系统项目提供了更多的功能，例如与 Apache Cassandra 连接、非阻塞 I/O 在系统进程之间通信等。
- en: '![](../Images/CH01_F05_Ponge.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH01_F05_Ponge.png)'
- en: Figure 1.5 Overview of the structure of a Vert.x application
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.5 Vert.x 应用程序结构的概述
- en: 'Vert.x is *polyglot* as it supports most of the popular JVM languages: JavaScript,
    Ruby, Kotlin, Scala, Groovy, and more. Interestingly, these languages are not
    just supported through their interoperability with Java. Idiomatic bindings are
    being generated, so you can write Vert.x code that still feels natural in these
    languages. For example, the Scala bindings use the Scala future APIs, and the
    Kotlin bindings leverage custom DSLs and functions with named parameters to simplify
    some code constructs. And, of course, you can mix and match different supported
    languages within the same Vert.x application.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Vert.x 是一种 *多语言* 支持，因为它支持大多数流行的 JVM 语言：JavaScript、Ruby、Kotlin、Scala、Groovy 等。有趣的是，这些语言不仅通过与
    Java 的互操作性得到支持，而且正在生成惯用绑定，因此您可以编写在 Vert.x 中仍然感觉自然的 Vert.x 代码。例如，Scala 绑定使用 Scala
    future API，而 Kotlin 绑定利用自定义 DSL 和带命名参数的函数来简化某些代码结构。当然，您还可以在同一个 Vert.x 应用程序中混合和匹配不同的支持语言。
- en: 1.11 Your first Vert.x application
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.11 您的第一个 Vert.x 应用程序
- en: It’s finally time for us to write a Vert.x application!
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们终于可以编写 Vert.x 应用程序了！
- en: 'Let’s continue with the echo TCP protocol that we have used in various forms
    in this chapter. It will still expose a TCP server on port 3000, where any data
    is sent back to the client. We will add two other features:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续使用本章中已以各种形式使用的 echo TCP 协议。它仍然会在端口 3000 上公开一个 TCP 服务器，任何数据都会发送回客户端。我们将添加两个其他功能：
- en: The number of open connections will be displayed every five seconds.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每隔五秒将显示打开的连接数。
- en: An HTTP server on port 8080 will respond with a string giving the current number
    of open connections.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在端口 8080 上运行的 HTTP 服务器将返回一个字符串，表示当前打开的连接数。
- en: 1.11.1 Preparing the project
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.11.1 准备项目
- en: While not strictly necessary for this example, it is easier to use a build tool.
    In this book, I will show examples with Gradle, but you can find the equivalent
    Maven build descriptors in the book’s source code Git repository.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在这个例子中不是严格必要的，但使用构建工具会更简单。在这本书中，我将使用 Gradle 举例，但你可以在书籍的源代码 Git 仓库中找到等效的 Maven
    构建描述符。
- en: For this project, the only third-party dependency that we need is the `vertx-core`
    artifact plus its dependencies. This artifact is on Maven Central under the `io.vertx`
    group identifier.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，我们需要的唯一第三方依赖项是 `vertx-core` 艺术品及其依赖项。这个艺术品位于 Maven Central 的 `io.vertx`
    组标识符下。
- en: An integrated development environment (IDE) like IntelliJ IDEA Community Edition
    is great, and it knows how to create Maven and Gradle projects. You can equally
    use Eclipse, NetBeans, or even Visual Studio Code.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 一个集成开发环境（IDE）如 IntelliJ IDEA Community Edition 非常好，它知道如何创建 Maven 和 Gradle 项目。你也可以同样使用
    Eclipse、NetBeans，甚至是 Visual Studio Code。
- en: Tip [You can also use the Vert.x starter web application at](https://start.vertx.io)
    https://start.vertx .io and generate a project skeleton to download.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士：[你还可以使用 Vert.x 启动器 Web 应用程序在](https://start.vertx.io) https://start.vertx.io
    生成项目骨架以下载。
- en: For this chapter let’s use Gradle. A suitable build.gradle.kts file would look
    like the next listing.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，让我们使用 Gradle。一个合适的 build.gradle.kts 文件看起来像下面的列表。
- en: Listing 1.12 Gradle configuration to build and run `VertxEcho`
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1.12 构建 和 运行 `VertxEcho` 的 Gradle 配置
- en: '[PRE11]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ❶ Replace VERSION with a release version of Vert.x like 3.9.1 or 4.0.0.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将 VERSION 替换为 Vert.x 的发布版本，如 3.9.1 或 4.0.0。
- en: ❷ This is the fully qualified name of the class containing a main method so
    that we can use the run Gradle task.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 这是包含 main 方法的类的完全限定名称，这样我们就可以使用运行 Gradle 任务。
- en: Tip You may be more familiar with Apache Maven than Gradle. This book uses Gradle
    because it is a modern, efficient, and flexible build tool. It also uses a concise
    domain-specific language for writing build files, which works better than Maven
    XML files in the context of a book. You will find Maven build descriptors equivalent
    to those of Gradle in the source code Git repository.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士：你可能比 Gradle 更熟悉 Apache Maven。这本书使用 Gradle，因为它是一个现代、高效且灵活的构建工具。它还使用简洁的领域特定语言来编写构建文件，这在书籍的上下文中比
    Maven XML 文件表现更好。你将在源代码 Git 仓库中找到与 Gradle 相当的 Maven 构建描述符。
- en: 1.11.2 The VertxEcho class
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.11.2 `VertxEcho` 类
- en: The `VertxEcho` class implementation is shown in listing 1.15\. You can run
    the application with Gradle using the `run` task (`gradle run` or `./gradlew run`),
    as follows.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`VertxEcho` 类的实现如列表 1.15 所示。你可以使用 Gradle 的 `run` 任务（`gradle run` 或 `./gradlew
    run`）运行应用程序，如下所示。'
- en: Listing 1.13 Running `VertxEcho`
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1.13 运行 `VertxEcho`
- en: '[PRE12]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Tip If you prefer Maven, run `mvn compile exec:java` instead of `./gradlew run`
    from the chapter1 folder in the book’s source code Git repository.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士：如果你更喜欢 Maven，请从书籍源代码 Git 仓库中的 chapter1 文件夹运行 `mvn compile exec:java` 而不是
    `./gradlew run`。
- en: You can, of course, interact with the service with the `netcat` command to echo
    text, and you can make an HTTP request to see the number of open connections,
    as shown in the following listing.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 你当然可以使用 `netcat` 命令与该服务交互以回显文本，你还可以通过以下列表中的示例发送 HTTP 请求来查看打开的连接数。
- en: Listing 1.14 Interacting with `VertxEcho` over TCP and HTTP
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1.14 通过 TCP 和 HTTP 与 `VertxEcho` 交互
- en: '[PRE13]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Tip The `http` command comes from the HTTPie project at [https:// httpie.org](https://httpie.org).
    This tool is a developer-friendly alternative to `curl`, and you can easily install
    it on your operating system.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士：`http` 命令来自 [https://httpie.org](https://httpie.org) 的 HTTPie 项目。这个工具是 `curl`
    的开发者友好替代品，你可以在你的操作系统上轻松安装它。
- en: Let’s now see the code of `VertxEcho`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在看看 `VertxEcho` 的代码。
- en: Listing 1.15 Implementation of the `VertxEcho` class
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1.15 `VertxEcho` 类的实现
- en: '[PRE14]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: ❶ As you will see in the next chapter, event handlers are always executed on
    the same thread, so there is no need for JVM locks or using AtomicInteger.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 正如你将在下一章中看到的，事件处理器总是在同一个线程上执行，因此不需要JVM锁或使用AtomicInteger。
- en: ❷ Creating a TCP server requires passing a callback for each new connection.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 创建TCP服务器需要为每个新连接传递一个回调。
- en: ❸ This defines a periodic task with a callback being executed every five seconds.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 这定义了一个周期性任务，回调每五秒执行一次。
- en: ❹ Similar to a TCP server, an HTTP server is configured by giving the callback
    to be executed for each HTTP request.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 与TCP服务器类似，HTTP服务器通过提供为每个HTTP请求执行的回调来配置。
- en: ❺ The buffer handler is invoked every time a buffer is ready for consumption.
    Here we just write it back, and we use a convenient string conversion helper to
    look for a terminal command.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 每当缓冲区准备好消费时，都会调用缓冲区处理器。这里我们只是将其写回，并使用方便的字符串转换助手来查找终止命令。
- en: ❻ Another event is when the connection closes. We decrement a connections counter
    that was incremented upon connection.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 另一个事件是连接关闭。我们减少一个在连接时增加的连接计数器。
- en: This example is interesting in that it has few lines of code. It is centered
    around a plain old Java `main` method, because there is no framework to bootstrap.
    All we need to create is a `Vertx` context, which in turns offers methods to create
    tasks, servers, clients, and more, as you will discover in the next chapters.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子很有趣，因为它只有很少的代码行。它围绕着一个普通的Java `main` 方法展开，因为没有框架来引导启动。我们只需要创建一个 `Vertx`
    上下文，它进而提供了创建任务、服务器、客户端等方法，你将在下一章中了解到。
- en: While it’s not apparent here, an event loop is managing the processing of events,
    be it a new TCP connection, the arrival of a buffer, a new HTTP request, or a
    periodic task that is being fired. Also, every event handler is being executed
    on the same (event-loop) thread.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在这里不明显，但事件循环正在管理事件的处理，无论是新的TCP连接、缓冲区的到达、新的HTTP请求，还是正在触发的周期性任务。此外，每个事件处理器都在同一个（事件循环）线程上执行。
- en: 1.11.3 The role of callbacks
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.11.3 回调的作用
- en: As you just saw in listing 1.15, *callbacks* are the primary method Vert.x uses
    to notify the application code of asynchronous events and pass them to some handlers.
    Combined with lambda expressions in Java, callbacks make for a concise way to
    define event handling.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在列表1.15中看到的，*回调*是Vert.x用来通知应用程序代码异步事件并将其传递给某些处理器的首选方法。结合Java中的lambda表达式，回调为定义事件处理提供了一种简洁的方式。
- en: You may have heard or experienced the infamous *callback hell* where callbacks
    get nested into callbacks, leading to code that is difficult to read and reason
    about.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能听说过或经历过臭名昭著的 *回调地狱*，其中回调嵌套在回调中，导致代码难以阅读和理解。
- en: Listing 1.16 Callback hell illustrated
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 列表1.16 回调地狱示例
- en: '[PRE15]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Be reassured: although the Vert.x core APIs indeed use callbacks, Vert.x provides
    support for more programming models. Callbacks are the canonical means for notification
    in event-driven APIs, but as you will see in upcoming chapters, it is possible
    to build other abstractions on top of callbacks, such as futures and promises,
    reactive extensions, and coroutines.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 请放心：尽管Vert.x核心API确实使用回调，但Vert.x提供了对更多编程模型的支持。回调是事件驱动API中通知的规范手段，但正如你将在接下来的章节中看到的，可以在回调之上构建其他抽象，例如future和promise、响应式扩展和协程。
- en: While callbacks have their issues, there are many cases with minimal levels
    of nesting where they remain a very good programming model with minimal dispatch
    overhead.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然回调有其问题，但在嵌套级别较低的情况下，它们仍然是一个非常优秀的编程模型，具有最小的调度开销。
- en: 1.11.4 So is this a reactive application?
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.11.4 那这是一个响应式应用程序吗？
- en: This is a very good question to ask. It is important to remember that while
    Vert.x is a toolkit for building reactive applications, using the Vert.x API and
    modules does not “auto-magically” make an application a reactive one. Yet the
    event-driven, non-blocking APIs that Vert.x provides tick the first box.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常好的问题。重要的是要记住，虽然Vert.x是构建响应式应用程序的工具包，但使用Vert.x API和模块并不能“自动魔法”地使应用程序成为响应式的。然而，Vert.x提供的基于事件驱动、非阻塞的API确实满足了第一个条件。
- en: The short answer is that no, this application is not reactive. Resiliency is
    not the issue, as the only errors that can arise are I/O related--and they simply
    result in discarding the connections. The application is also responsive, as it
    does not perform any complicated processing. If we benchmarked the TCP and HTTP
    servers, we would get very good latencies with low deviation and very few outliers.
    The following listing shows an imperfect, yet telling, quick benchmark with `wrk`
    ([https://github.com/ wg/wrk](https://github.com/wg/wrk)) running from a terminal.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 简短的回答是，不，这个应用程序不是响应式的。弹性不是问题，因为唯一可能出现的错误是 I/O 相关的——它们只是简单地导致丢弃连接。该应用程序也是响应式的，因为它不执行任何复杂的处理。如果我们对
    TCP 和 HTTP 服务器进行基准测试，我们会得到非常好的延迟，低偏差和非常少的异常值。以下列表显示了使用 `wrk`（[https://github.com/wg/wrk](https://github.com/wg/wrk)）从终端运行的一个不完美但很有说明性的快速基准测试。
- en: Listing 1.17 Output of a benchmark session with `wrk`
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1.17 使用 `wrk` 的基准测试会话输出
- en: '[PRE16]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The culprit for not being reactive clearly is elasticity. Indeed, if we create
    new instances, each instance maintains its own connection counter. The counter
    scope is the application, so it should be a shared global counter between all
    instances.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 不响应的罪魁祸首显然是弹性。确实，如果我们创建新的实例，每个实例都会维护自己的连接计数器。计数器的范围是应用程序，因此它应该在所有实例之间共享的全局计数器。
- en: As this example shows, designing reactive applications is more subtle than just
    implementing responsive and resource-efficient systems. Ensuring that an application
    can run as many replaceable instances is surprisingly more engaging, especially
    as we need to think about *instance state* versus *application state* to make
    sure that instances are interchangeable.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 正如这个示例所示，设计响应式应用程序比仅仅实现响应和资源高效的系统要微妙得多。确保应用程序可以运行尽可能多的可替换实例，这出人意料地更有吸引力，尤其是在我们需要考虑
    *实例状态* 与 *应用程序状态* 以确保实例可以互换时。
- en: What if I am a Windows user?
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我是 Windows 用户怎么办？
- en: '`wrk` is a command-line tool that works on Unix systems like Linux and macOS.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`wrk` 是一个在类似 Linux 和 macOS 的 Unix 系统上运行的命令行工具。'
- en: In this book we prefer Unix-style tooling and command-line interfaces over graphical
    user interfaces. We will use Unix tools that are powerful, intuitive, and maintained
    by active open source communities.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们更倾向于使用 Unix 风格的工具和命令行界面，而不是图形用户界面。我们将使用功能强大、直观，并由活跃的开源社区维护的 Unix 工具。
- en: 'Fortunately, you don’t have to leave Windows to benefit from these tools! While
    some of these tools work natively on Windows, starting from Windows 10 you can
    install the Windows Subsystem for Linux (WSL) and benefit from a genuine Linux
    environment alongside your more traditional Windows desktop environment. Microsoft
    markets WSL as a major feature for developers on Windows, and I can only recommend
    that you invest some time and get familiar with it. You can see Microsoft’s WSL
    FAQ for more details: [https://docs.microsoft.com/en-us/windows/wsl/faq](https://docs.microsoft.com/en-us/windows/wsl/faq).'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，您不必离开 Windows 就能从这些工具中受益！虽然其中一些工具在 Windows 上原生运行，但从 Windows 10 开始，您可以安装
    Windows Subsystem for Linux (WSL) 并从真正的 Linux 环境中受益，同时保持您更传统的 Windows 桌面环境。微软将
    WSL 作为 Windows 开发者的一个主要功能进行推广，我只能建议您花些时间熟悉它。您可以查看微软的 WSL 常见问题解答以获取更多详细信息：[https://docs.microsoft.com/en-us/windows/wsl/faq](https://docs.microsoft.com/en-us/windows/wsl/faq)。
- en: 1.12 What are the alternatives to Vert.x?
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.12 什么是 Vert.x 的替代方案？
- en: As you will see in this book, Vert.x is a compelling technology for building
    end-to-end reactive applications. Reactive application development is a trendy
    topic, and it is more important to understand the principles than to blindly become
    an expert in one specific technology. What you will learn in this book easily
    transfers to other technologies, and I highly encourage you to check them out.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您将在本书中看到的那样，Vert.x 是构建端到端响应式应用程序的有力技术。响应式应用程序开发是一个热门话题，了解原则比盲目成为某一特定技术的专家更重要。您在本书中学到的知识可以轻松转移到其他技术，我强烈建议您去探索它们。
- en: 'Here are the most popular alternatives to Vert.x for asynchronous and reactive
    programming:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这里列出了 Vert.x 在异步和响应式编程中最受欢迎的替代方案：
- en: '*Node.js* --Node.js is an event-driven runtime for writing asynchronous JavaScript
    applications. It is based on the V8 JavaScript engine that is used by Google Chrome.
    At first sight, Vert.x and Node.js have lots of similarities. Still, they differ
    greatly. Vert.x runs multiple event loops by default, unlike Node.js. Also, the
    JVM has a better JIT compiler and garbage collector, so the JVM is better suited
    for long-running processes. Last, but not least, Vert.x supports JavaScript.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Node.js* -- Node.js 是一个用于编写异步 JavaScript 应用程序的事件驱动运行时环境。它基于 Google Chrome
    所使用的 V8 JavaScript 引擎。乍一看，Vert.x 和 Node.js 有很多相似之处。然而，它们之间存在着很大的差异。Vert.x 默认运行多个事件循环，而
    Node.js 则不是。此外，JVM 拥有更好的 JIT 编译器和垃圾回收器，因此 JVM 更适合长时间运行的过程。最后但同样重要的是，Vert.x 支持
    JavaScript。'
- en: '*Akka* --Akka is a faithful implementation of the *actor* model. It runs on
    the JVM and primarily offers Scala APIs, although Java bindings are also being
    promoted. Akka is particularly interesting, as actors are message driven and location
    transparent, and actors offer supervision features that are interesting for error
    recovery. Akka clearly targets the design of reactive applications. As you will
    see in this book, Vert.x is no less capable for the task. Vert.x has a concept
    of *verticles*, a loose form of actors, that are used for processing asynchronous
    events. Interestingly, Vert.x is significantly faster than Akka and most alter-natives
    in established benchmarks, such as TechEmpower benchmarks ([www .techempower.com/benchmarks/](http://www.techempower.com/benchmarks/)).'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Akka* -- Akka 是对 *actor* 模型的忠实实现。它运行在 JVM 上，主要提供 Scala API，尽管也在推广 Java 绑定。Akka
    特别有趣，因为演员是消息驱动的且位置透明，演员还提供了对错误恢复感兴趣的管理功能。Akka 明确针对响应式应用程序的设计。正如你将在本书中看到的那样，Vert.x
    在这项任务上同样能胜任。Vert.x 有一个名为 *verticles* 的概念，这是一种松散的演员形式，用于处理异步事件。有趣的是，Vert.x 在 TechEmpower
    等现有基准测试（[www.techempower.com/benchmarks/](http://www.techempower.com/benchmarks/)）中比
    Akka 和大多数替代品都要快得多。'
- en: '*Spring Framework* --The older and widespread Spring Framework now integrates
    a reactive stack. It is based on Project Reactor, an API for reactive programming
    that is very similar to RxJava. The focus of the Spring reactive stack is essentially
    on reactive programming APIs, but it does not necessarily lead to end-to-end reactive
    applications. Many parts of the Spring Framework employ blocking APIs, so extra
    care must be taken to limit the exposure to blocking operations. Project Reactor
    is a compelling alternative to RxJava, but the Spring reactive stack is tied to
    this API, and it may not always be the best way to express certain asynchronous
    constructions. Vert.x provides more flexibility as it supports callbacks, futures,
    Java `CompletionStage`, Kotlin coroutines, RxJava, and fibers. This means that
    with Vert.x it is easier to select the right asynchronous programming model for
    a certain task. Also like with Akka, Vert.x remains significantly faster in TechEmpower
    benchmarks, and applications boot faster than Spring-based ones.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Spring Framework* -- 较老且广泛使用的 Spring Framework 现在集成了响应式堆栈。它基于 Project Reactor，这是一个与
    RxJava 非常相似的响应式编程 API。Spring 响应式堆栈的焦点本质上在于响应式编程 API，但它并不一定导致端到端的响应式应用程序。Spring
    Framework 的许多部分都使用了阻塞 API，因此必须格外小心以限制对阻塞操作的暴露。Project Reactor 是 RxJava 的一个有吸引力的替代品，但
    Spring 响应式堆栈与这个 API 相关联，并且可能并不总是表达某些异步结构的最优方式。Vert.x 提供了更多的灵活性，因为它支持回调、未来、Java
    `CompletionStage`、Kotlin 协程、RxJava 和纤维。这意味着使用 Vert.x，更容易为特定任务选择正确的异步编程模型。同样，与
    Akka 类似，Vert.x 在 TechEmpower 基准测试中保持显著的速度优势，并且应用程序启动速度比基于 Spring 的应用程序更快。'
- en: '*Quarkus* --Quarkus is a new framework for developing Java applications that
    run exceptionally well in container environments like Kubernetes ([https:// quarkus.io](https://quarkus.io)).
    Indeed, in such environments, boot time and memory consumption are critical cost-saving
    factors. Quarkus employs techniques at compilation time to make sensible gains
    when running using traditional Java virtual machines and as native executables.
    It is based on popular libraries like Hibernate, Eclipse MicroProfile, RESTEasy,
    and Vert.x. Quarkus unifies imperative and reactive programming models, and Vert.x
    is a cornerstone of the framework. Vert.x is not just used to power some pieces
    of the networking stack; some client modules are directly based on those from
    Vert.x, such as the Quarkus mail service and reactive routes. You can also use
    Vert.x APIs in a Quarkus application, with the unification between reactive and
    imperative helping you to bridge both worlds. Vert.x and Quarkus have different
    programming paradigms: Vert.x will appeal to developers who prefer a toolkit approach,
    or developers who have affinities with Node.js. In contrast, Quarkus will appeal
    to developers who prefer an opinionated stack approach with dependency injection
    and convention over configuration. In the end, both projects work together, and
    anything you develop with Vert.x can be reused in Quarkus.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Quarkus* -- Quarkus 是一个用于开发在容器环境（如 Kubernetes）中运行得特别出色的 Java 应用程序的新框架（[https://
    quarkus.io](https://quarkus.io)）。确实，在这样的环境中，启动时间和内存消耗是关键的成本节约因素。Quarkus 在编译时采用技术，以便在运行传统的
    Java 虚拟机和原生可执行文件时获得合理的收益。它基于流行的库，如 Hibernate、Eclipse MicroProfile、RESTEasy 和 Vert.x。Quarkus
    统一了命令式和反应式编程模型，Vert.x 是该框架的基石。Vert.x 不仅用于提供网络堆栈的一些组件的动力；一些客户端模块直接基于 Vert.x 的那些，例如
    Quarkus 邮件服务和反应式路由。你还可以在 Quarkus 应用程序中使用 Vert.x API，反应式和命令式之间的统一可以帮助你连接这两个世界。Vert.x
    和 Quarkus 有不同的编程范式：Vert.x 将吸引那些更喜欢工具箱方法的开发者，或者那些对 Node.js 有亲和力的开发者。相比之下，Quarkus
    将吸引那些更喜欢具有依赖注入和约定优于配置的偏见的堆栈方法的开发者。最终，这两个项目是协同工作的，你用 Vert.x 开发的任何内容都可以在 Quarkus
    中重用。'
- en: '*Netty* --The Netty framework provides non-blocking I/O APIs for the JVM. It
    provides abstractions and platform-specific bug fixes compared to using raw NIO
    APIs. It also provides threading models. The target of Netty is low-latency and
    high-performance network applications. While you can certainly build reactive
    applications with Netty, the APIs remain somewhat low-level. Vert.x is one of
    the many technologies built on top of Netty (Spring Reactive and Akka have Netty
    integration), and you can get all the performance benefits of Netty with the simpler
    APIs of Vert.x.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Netty* -- Netty 框架为 JVM 提供了非阻塞 I/O API。与使用原始 NIO API 相比，它提供了抽象和平台特定的错误修复。它还提供了线程模型。Netty
    的目标是低延迟和高性能的网络应用程序。虽然你当然可以用 Netty 构建反应式应用程序，但 API 仍然相当低级。Vert.x 是建立在 Netty 之上的许多技术之一（Spring
    Reactive 和 Akka 都有 Netty 集成），你可以通过 Vert.x 的更简单 API 获得所有 Netty 的性能优势。'
- en: '*Scripting languages* --Scripting languages such as Python and Ruby also provide
    non-blocking I/O libraries, such as Async (Ruby) and Twisted (Python). You can
    certainly build reactive systems with them. Again, the JVM performance is an advantage
    for Vert.x, along with the ability to use alternative JVM languages (Ruby is officially
    supported by Vert.x).'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*脚本语言* -- 脚本语言，如 Python 和 Ruby，也提供了非阻塞 I/O 库，例如 Async（Ruby）和 Twisted（Python）。你当然可以用它们构建反应式系统。再次强调，JVM
    性能是 Vert.x 的优势之一，同时它还支持使用替代 JVM 语言（Ruby 由 Vert.x 正式支持）。'
- en: '*Native languages* --Native languages are becoming trendy again. Instead of
    using the venerable C/C++ languages, Go, Rust, and Swift are gaining mindshare.
    They all tick the boxes for building highly scalable applications, and they certainly
    can be used for creating reactive applications. That being said, most efficient
    libraries in these languages are fairly low-level, and ultimately the JVM-based
    Vert.x/Netty combination still ranks favorably in benchmarks.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*本地语言* -- 本地语言再次变得流行起来。不再使用传统的 C/C++ 语言，Go、Rust 和 Swift 正在获得越来越多的关注。它们都符合构建高度可扩展应用程序的要求，并且确实可以用于创建反应式应用程序。尽管如此，这些语言中最有效的库相当低级，最终基于
    JVM 的 Vert.x/Netty 组合在基准测试中仍然具有优势。'
- en: 'The following books are good resources for many of the preceding topics:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 以下书籍是许多先前主题的良好资源：
- en: '*Node.js in Action* by Mike Cantelon, Marc Harter, T.J. Holowaychuk, and Nathan
    Rajlich (Manning, 2013)'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 《Mike Cantelon、Marc Harter、T.J. Holowaychuk 和 Nathan Rajlich 著的 *Node.js in
    Action*》（Manning，2013年）
- en: '*Akka in Action* by Raymond Roestenburg, Rob Bakker, and Rob Williams (Manning,
    2016)'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《Akka实战》* 由Raymond Roestenburg、Rob Bakker和Rob Williams著（Manning, 2016）'
- en: '*Reactive Application Development* by Duncan K. DeVore, Sean Walsh, and Brian
    Hanafee (Manning, 2018)'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《响应式应用开发》* 由Duncan K. DeVore、Sean Walsh和Brian Hanafee著（Manning, 2018）'
- en: '*Spring in Action*, fifth edition, by Craig Walls (Manning, 2018)'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《Spring实战》* 第五版，由Craig Walls著（Manning, 2018）'
- en: '*Netty in Action* by Norman Maurer and Marvin Allen Wolfthal (Manning, 2015)'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《Netty实战》* 由Norman Maurer和Marvin Allen Wolfthal著（Manning, 2015）'
- en: '*Go in Action* by William Kennedy with Brian Ketelsen and Erik St. Martin (Manning,
    2015)'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《Go实战》* 由William Kennedy与Brian Ketelsen和Erik St. Martin合著（Manning, 2015）'
- en: '*Rust in Action* by Tim McNamara (Manning, 2019)'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《Rust实战》* 由Tim McNamara著（Manning, 2019）'
- en: '*Swift in Depth* by Tjeerd in ''t Veen (Manning, 2018)'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*《Swift深度解析》* 由Tjeerd in ''t Veen著（Manning, 2018）'
- en: In the next chapter, we will dissect the fundamentals of asynchronous programming
    with Vert.x.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将剖析Vert.x异步编程的基础。
- en: Summary
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Asynchronous programming allows you to multiplex multiple networked connections
    on a single thread.
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步编程允许你在单个线程上多路复用多个网络连接。
- en: Managing non-blocking I/O is more complex than the equivalent imperative code
    based on blocking I/O, even for simple protocols.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理非阻塞I/O比基于阻塞I/O的等效命令式代码更复杂，即使是对于简单的协议也是如此。
- en: The event loop and the reactor pattern simplify asynchronous event processing.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件循环和反应器模式简化了异步事件处理。
- en: A reactive system is both scalable and resilient, producing responses with consistent
    latencies despite demanding workloads and failures.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个响应式系统既可扩展又具有弹性，即使在负载和故障要求下，也能以一致的延迟产生响应。
- en: Vert.x is an approachable, efficient toolkit for writing asynchronous and reactive
    applications on the JVM.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vert.x是一个易于使用、高效的工具包，用于在JVM上编写异步和响应式应用程序。
- en: '* * *'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: 1.For readers already familiar with microservice patterns, “edge service” is,
    in my opinion, a better term than “API gateway.”
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 对于已经熟悉微服务模式的读者来说，在我看来，“边缘服务”比“API网关”是一个更好的术语。
