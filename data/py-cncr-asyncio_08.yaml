- en: 8 Streams
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8 流
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Transports and protocols
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传输和协议
- en: Using streams for network connections
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用流进行网络连接
- en: Processing command-line input asynchronously
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步处理命令行输入
- en: Creating client/server applications with streams
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用流创建客户端/服务器应用程序
- en: When writing network applications, such as our echo clients in prior chapters,
    we’ve employed the socket library to read from and write to our clients. While
    directly using sockets is useful when building low-level networking libraries,
    they are ultimately complex creatures with nuances outside the scope of this book.
    That said, many use cases of sockets rely on a few conceptually simple operations,
    such as starting a server, waiting for client connections, and sending data to
    clients. The designers of asyncio realized this and built network stream APIs
    to abstract away handling the nuances of sockets for us. These higher-level APIs
    are much easier to work with than sockets, making any client-server applications
    easier to build and more robust than using sockets ourselves. Using streams is
    the recommended way to build network-based applications in asyncio.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写网络应用程序时，例如在前几章中的回声客户端，我们已经使用了套接字库来读取和写入我们的客户端。虽然直接使用套接字在构建低级网络库时很有用，但它们最终是复杂的生物，其细微之处超出了本书的范围。话虽如此，许多套接字用例依赖于一些概念上简单的操作，例如启动服务器、等待客户端连接以及向客户端发送数据。asyncio的设计者意识到了这一点，并构建了网络流API来为我们抽象掉套接字的细微之处。这些高级API比套接字更容易使用，使得任何客户端/服务器应用程序的构建都更加容易，并且比我们自己使用套接字更加健壮。在asyncio中，使用流是构建基于网络的应用程序的首选方式。
- en: In this chapter, we’ll first learn using the lower-level transport and protocol
    APIs by building a simple HTTP client. Learning about these APIs will give us
    the foundation for understanding how the higher-level stream APIs work in the
    background. We’ll then use this knowledge to learn about stream readers and writers
    and use them to build a non-blocking command-line SQL client. This application
    will asynchronously process user input, allowing us to run multiple queries concurrently
    from the command line. Finally, we’ll learn how to use asyncio’s server API to
    create client and server applications, building a functional chat server and chat
    client.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先将通过构建一个简单的HTTP客户端来学习使用低级传输和协议API。了解这些API将为我们理解高级流API在后台如何工作打下基础。然后，我们将利用这些知识来学习流读取器和写入器，并使用它们构建一个非阻塞的命令行SQL客户端。此应用程序将异步处理用户输入，使我们能够从命令行并发运行多个查询。最后，我们将学习如何使用asyncio的服务器API来创建客户端和服务器应用程序，构建一个功能性的聊天服务器和聊天客户端。
- en: 8.1 Introducing streams
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.1 流的介绍
- en: In asyncio, *streams* are a high-level set of classes and functions that create
    and manage network connections and generic streams of data. Using them, we can
    create client connections to read and write to servers, or even create servers
    and manage them ourselves. These APIs abstract a lot of knowledge around managing
    sockets, such as dealing with SSL or lost connections, making our lives as developers
    a little easier.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在asyncio中，*流*是一组高级类和函数，用于创建和管理网络连接以及通用的数据流。使用它们，我们可以创建客户端连接以读取和写入服务器，甚至可以创建服务器并自行管理它们。这些API抽象了很多关于管理套接字的知识，例如处理SSL或丢失连接，使我们的开发生活变得稍微容易一些。
- en: The stream APIs are built on top of a lower-level set of APIs known as *transports*
    and *protocols*. These APIs directly wrap the sockets we used in previous chapters
    (generally, any generic stream of data), providing us with a clean API for reading
    and writing data to sockets.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 流API建立在称为*传输*和*协议*的低级API之上。这些API直接封装了我们之前使用的套接字（通常，任何通用的数据流），为我们提供了一个干净的API来读取和写入套接字数据。
- en: These APIs are structured a little differently from others in that they use
    a callback style design. Instead of actively waiting for data from a socket like
    we did previously, a method on a class we implement is called for us when data
    is available. We then process the data we receive in this method as needed. To
    get started learning how these callback-based APIs work, let’s first see how to
    use the lower-level transport and protocol APIs by building a basic HTTP client.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这些API的结构与其他API略有不同，因为它们使用回调式设计。与之前我们像等待套接字数据那样主动等待不同，当我们实现的一个类上的方法被调用时，数据就可用。然后，我们根据需要处理在这个方法中接收到的数据。为了开始学习这些基于回调的API是如何工作的，让我们首先通过构建一个基本的HTTP客户端来了解如何使用低级传输和协议API。
- en: 8.2 Transports and protocols
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.2 传输和协议
- en: At a high level, a transport is an abstraction for communication with an arbitrary
    stream of data. When we communicate with a socket or any data stream such as standard
    input, we work with a familiar set of operations. We read data from or write data
    to a source, and when we’re finished working with it, we close it. A socket cleanly
    fits how we’ve defined this transport abstraction; that is, we read and write
    data to it and once we’ve finished, we close it. In short, a transport provides
    definitions for sending and receiving data to and from a source. Transports have
    several implementations depending on which type of source we’re using. We’re mainly
    concerned with `ReadTransport`, `WriteTransport`, and `Transport`, though there
    are others for dealing with UDP connections and subprocess communication. Figure
    8.1 illustrates the class hierarchy of transports.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 从高层次来看，传输是与任意数据流进行通信的抽象。当我们与套接字或任何数据流（如标准输入）通信时，我们使用一组熟悉的操作。我们从源读取数据或向源写入数据，当我们完成与它的交互后，我们关闭它。套接字完美地符合我们定义的这个传输抽象；也就是说，我们向它读取和写入数据，一旦完成，我们就关闭它。简而言之，传输为从源发送和接收数据提供了定义。根据我们使用的源类型，传输有几种实现方式。我们主要关注`ReadTransport`、`WriteTransport`和`Transport`，尽管还有其他用于处理UDP连接和子进程通信的传输。图8.1展示了传输的类层次结构。
- en: '![08-01](Images/08-01.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![08-01](Images/08-01.png)'
- en: Figure 8.1 The class hierarchy of transports
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1 传输的类层次结构
- en: Transmitting data to and from a socket is only part of the equation. What about
    the lifecycle of a socket? We establish a connection; we write data and then process
    any response we get. These are the set of operations a protocol owns. Note that
    a protocol simply refers to a Python class here and not a protocol like HTTP or
    FTP. A transport manages data transmission and calls methods on a protocol when
    events occur, such as a connection being established or data being ready to process,
    as shown in figure 8.2.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据从套接字发送和接收只是方程的一部分。那么套接字的生命周期又是怎样的呢？我们建立连接；写入数据然后处理我们收到的任何响应。这些都是协议所拥有的操作集。请注意，这里的协议仅仅是指一个Python类，而不是像HTTP或FTP这样的协议。传输管理数据传输，并在事件发生时调用协议上的方法，例如连接建立或数据准备好处理，如图8.2所示。
- en: '![08-02](Images/08-02.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![08-02](Images/08-02.png)'
- en: Figure 8.2 A transport calls methods on a protocol when events happen. A protocol
    can write data to a transport.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2 当事件发生时，传输在协议上调用方法。协议可以向传输写入数据。
- en: To understand how transports and protocols work together, we’ll build a basic
    application to run a single HTTP GET request. The first thing we’ll need to do
    is define a class that extends `asyncio.Protocol`. We’ll implement a few methods
    from the base class to make the request, receive data from the request, and handle
    any errors with the connection.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解传输和协议是如何协同工作的，我们将构建一个基本的应用程序来运行单个HTTP GET请求。我们首先需要做的是定义一个扩展`asyncio.Protocol`的类。我们将实现基类中的几个方法来发送请求、接收请求的数据以及处理连接中的任何错误。
- en: The first protocol method we’ll need to implement is `connection_made`. The
    transport calls this method when the underlying socket has successfully connected
    with the HTTP server. This method employs a `Transport` as an argument that we
    can use to communicate with the server. In this case, we’ll use the transport
    to send the HTTP request immediately.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要实现的第一个协议方法是`connection_made`。当底层套接字成功连接到HTTP服务器时，传输会调用这个方法。这个方法使用`Transport`作为参数，我们可以用它来与服务器通信。在这种情况下，我们将使用传输立即发送HTTP请求。
- en: The second method we’ll need to implement is `data_received`. The transport
    calls this method whenever it receives data, passing it to us as bytes. This method
    can be called multiple times, so we’ll need to create an internal buffer to store
    the data.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要实现的第二个方法是`data_received`。每当传输接收到数据时，它都会调用这个方法，并将数据作为字节传递给我们。这个方法可以被多次调用，因此我们需要创建一个内部缓冲区来存储数据。
- en: The question now becomes, how do we tell when our response is finished? To answer
    this, we’ll implement a method called `eof_received`. This method is called when
    we receive the *end of file*, which, in the case of a socket, happens when the
    server closes the connection. Once this method is called, we are guaranteed that
    `data_ received` will never be called again. The `eof_received` method returns
    a `Boolean` value that determines how to shut down the transport (close the client
    socket in this example). Returning `False` ensures that the transport will shut
    itself down, whereas `True` means that the protocol implementation we wrote will
    shut things down. In this case, as we don’t need to do any special logic on shutdown,
    our method should return `False,` so we don’t need to handle closing the transport
    ourselves.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的问题变成了，我们如何知道我们的响应已经完成？为了回答这个问题，我们将实现一个名为 `eof_received` 的方法。当接收到 *文件结束符*
    时，这个方法会被调用，对于套接字来说，这发生在服务器关闭连接的时候。一旦这个方法被调用，我们就可以保证 `data_received` 将不会被再次调用。`eof_received`
    方法返回一个 `Boolean` 值，用于确定如何关闭传输（在这个例子中是关闭客户端套接字）。返回 `False` 确保传输会自行关闭，而返回 `True`
    则意味着我们编写的协议实现将关闭连接。在这种情况下，由于我们不需要在关闭时执行任何特殊逻辑，我们的方法应该返回 `False`，因此我们不需要自己处理关闭传输。
- en: With what we’ve described, we have only a way to store things in an internal
    buffer. So, how do consumers of our protocol get the result once the request is
    finished? To do this, we can create a `Future` internally to hold the result when
    it is complete. Then, in the `eof_received` method we’ll set the result of the
    `future` to the result of the HTTP response. We’ll then define a coroutine we’ll
    name `get_response` that will await the future.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们描述的，我们只有一种方法可以将东西存储在内部缓冲区中。那么，我们的协议的消费者如何在请求完成后获取结果呢？为了做到这一点，我们可以在内部创建一个
    `Future` 来保存完成时的结果。然后，在 `eof_received` 方法中，我们将 `future` 的结果设置为 HTTP 响应的结果。然后，我们将定义一个名为
    `get_response` 的协程，它将等待这个 `future`。
- en: Let’s take what we’ve described above and implement it as our own protocol.
    We’ll call it `HTTPGetClientProtocol`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将上面描述的内容实现为我们自己的协议。我们将称之为 `HTTPGetClientProtocol`。
- en: Listing 8.1 Running a HTTP request with transports and protocols
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.1 使用传输和协议运行 HTTP 请求
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ Await the internal future until we get a response from the server.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 等待内部 `future` 直到从服务器收到响应。
- en: ❷ Create the HTTP request.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 创建 HTTP 请求。
- en: ❸ Once we’ve established a connection, use the transport to send the request.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 一旦建立了连接，使用传输发送请求。
- en: ❹ Once we have data, save it to our internal buffer.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 一旦我们有数据，将其保存到我们的内部缓冲区。
- en: ❺ Once the connection closes, complete the future with the buffer.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 一旦连接关闭，使用缓冲区完成 `future`。
- en: ❻ If the connection closes without error, do nothing; otherwise, complete the
    future with an exception.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 如果连接在没有错误的情况下关闭，则不执行任何操作；否则，使用异常完成 `future`。
- en: Now that we’ve implemented our protocol, let’s use it to make a real request.
    To do this, we’ll need to learn a new coroutine method on the asyncio event loop
    named `create_connection`. This method will create a socket connection to a given
    host and wrap it in an appropriate transport. In addition to a host and port,
    it takes in a *protocol factory*. A protocol factory is a function that creates
    protocol instances; in our case, an instance of the `HTTPGetClientProtocol` class
    we just created. When we call this coroutine, we’re returned both the transport
    that the coroutine created along with the protocol instance the factory created.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经实现了我们的协议，让我们用它来发送一个真实的请求。为此，我们需要在 asyncio 事件循环中学习一个新的协程方法，名为 `create_connection`。此方法将创建一个到指定主机的套接字连接，并将其包装在一个适当的传输中。除了主机和端口外，它还接受一个
    *协议工厂*。协议工厂是一个创建协议实例的函数；在我们的例子中，是我们刚刚创建的 `HTTPGetClientProtocol` 类的实例。当我们调用这个协程时，我们得到了协程创建的传输以及工厂创建的协议实例。
- en: Listing 8.2 Using the protocol
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.2 使用协议
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We first define a `make_request` method that takes in the host and port we’d
    like to make a request to, and the server’s response. Inside this method, we create
    an inner method for our protocol factory that creates a new `HTTPGetClientProtocol`.
    We then call `create_connection` with the host and port that returns both a transport
    and the protocol our factory created. We won’t need the transport, and we ignore
    it, but we will need the protocol because we’ll want to use the `get_response`
    coroutine; therefore, we’ll keep track of it in the `protocol` variable. Finally,
    we await the `get_response` coroutine of our protocol that will wait until the
    HTTP server has responded with a result. In our main coroutine, we await `make_request`
    and print the response. Executing this, you should see a HTTP response like the
    following (we’ve omitted the HTML body for brevity):'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义了一个`make_request`方法，该方法接受我们想要请求的主机和端口，以及服务器的响应。在这个方法内部，我们为我们的协议工厂创建了一个内部方法，用于创建一个新的`HTTPGetClientProtocol`。然后，我们使用主机和端口调用`create_connection`，它返回我们的工厂创建的传输和协议。我们不需要传输，所以我们忽略它，但我们需要协议，因为我们想使用`get_response`协程；因此，我们将它在`protocol`变量中跟踪。最后，我们等待协议的`get_response`协程，该协程将等待HTTP服务器响应结果。在我们的主协程中，我们等待`make_request`并打印响应。执行此操作后，你应该看到如下HTTP响应（为了简洁，我们省略了HTML正文）：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We’ve learned to use transports and protocols. These APIs are lower-level and,
    as such, aren’t the recommended way to work with streams in asyncio. Let’s see
    how to use *streams*, a higher-level abstraction that expands on transports and
    protocols.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学会了使用传输和协议。这些API是低级别的，因此不是在asyncio中处理流的推荐方式。让我们看看如何使用*流*，这是一个高级抽象，它扩展了传输和协议。
- en: 8.3 Stream readers and stream writers
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.3 流读取器和流写入器
- en: Transports and protocols are lower-level APIs that are best suited for when
    we need direct control over what is happening as we send and receive data. As
    an example, if we’re designing a networking library or web framework, we may consider
    transports and protocols. For most applications, we don’t need this level of control,
    and using transports and protocols would involve us writing a bunch of repetitive
    code.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 传输和协议是低级别的API，最适合我们需要直接控制发送和接收数据时的情况。例如，如果我们正在设计一个网络库或Web框架，我们可能会考虑使用传输和协议。对于大多数应用程序，我们不需要这种级别的控制，使用传输和协议将涉及我们编写大量重复的代码。
- en: 'The designers of asyncio realized this and created the higher-level *streams*
    APIs. This API encapsulates the standard use cases of transports and protocols
    into two classes that are easy to understand and use: `StreamReader` and `StreamWriter`.
    As you can guess, they handle reading from and writing to streams, respectively.
    Using these classes is the recommended way to develop networking applications
    in asyncio.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: asyncio的设计者意识到了这一点，并创建了高级的*流*API。这个API将传输和协议的标准用例封装到两个易于理解和使用的类中：`StreamReader`和`StreamWriter`。正如你所猜到的，它们分别处理从流中读取和写入。使用这些类是推荐在asyncio中开发网络应用程序的方式。
- en: To get an understanding of how to use these APIs, let’s take our example of
    making a HTTP GET request and translate it into streams. Instead of directly instantiating
    `StreamReader` and `StreamWriter` instances, asyncio provides a library coroutine
    function named `open_connection` that will create them for us. This coroutine
    takes in a host and port that we’ll connect to and returns a `StreamReader` and
    a `StreamWriter` as a tuple. Our plan will be to use the `StreamWriter` to send
    out the HTTP request and the `StreamReader` to read the response. `StreamReader`
    methods are easy to understand, and we have a convenient `readline` coroutine
    that waits until we have a line of data. Alternatively, we could also use `StreamReader`’s
    `read` coroutine that waits for a specified number of bytes to arrive.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解如何使用这些API，让我们以我们的HTTP GET请求示例为例，并将其转换为流。我们不是直接实例化`StreamReader`和`StreamWriter`实例，asyncio提供了一个名为`open_connection`的库协程函数，它将为我们创建它们。这个协程接受我们将要连接的主机和端口，并返回一个包含`StreamReader`和`StreamWriter`的元组。我们的计划是使用`StreamWriter`发送HTTP请求，使用`StreamReader`读取响应。`StreamReader`的方法易于理解，我们有一个方便的`readline`协程，它等待我们有一行数据。或者，我们也可以使用`StreamReader`的`read`协程，它等待指定数量的字节到达。
- en: '`StreamWriter` is a little more complex. It has a `write` method as we’d expect,
    but it is a plain method and *not* a coroutine. Internally, stream writers try
    to write to a socket’s output buffer right away, but this buffer can be full.
    If the socket’s write buffer is full, the data is instead stored in an internal
    queue where it can later go into to the buffer. This poses a potential problem
    in that calling `write` does not necessarily send out data immediately. This can
    cause potential memory issues. Imagine our network connection becomes slow, able
    to send out 1 KB per second, but our application is writing out 1 MB per second.
    In this case, our application’s write buffer will fill up at a much faster rate
    than we can send the data out to the socket’s buffer, and eventually we’ll start
    to hit memory limits on the machine, inviting a crash.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`StreamWriter` 稍微复杂一些。它有一个我们预期的 `write` 方法，但它是一个普通方法，*而不是* 协程。内部，流写入器会立即尝试写入套接字的输出缓冲区，但这个缓冲区可能已满。如果套接字的写入缓冲区已满，数据将存储在内部队列中，稍后可以进入缓冲区。这可能导致潜在的问题，因为调用
    `write` 并不一定立即发送数据。这可能会导致潜在的内存问题。想象一下，我们的网络连接变得缓慢，每秒只能发送 1 KB，但我们的应用程序每秒写入 1 MB。在这种情况下，我们的应用程序的写入缓冲区将比我们发送数据到套接字缓冲区的速度更快地填满，最终我们将开始达到机器的内存限制，从而引发崩溃。'
- en: How can we wait until all our data is properly sent out? To solve this issue,
    we have a coroutine method called `drain`. This coroutine will block until all
    queued data gets sent to the socket, ensuring we’ve written everything before
    moving on. The pattern we’ll want to use functions after we call `write` we’ll
    always `await` a call to `drain`. Technically, it’s not necessary to call `drain`
    after every `write`, but it is a good idea to help prevent bugs.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何等待所有数据都正确发送出去？为了解决这个问题，我们有一个名为 `drain` 的协程方法。这个协程将阻塞，直到所有排队的数据都发送到套接字，确保我们在继续之前已经写完了所有内容。我们希望在调用
    `write` 之后使用函数的模式，我们总是会 `await` 一个对 `drain` 的调用。技术上讲，在每次 `write` 之后调用 `drain`
    不是必需的，但这是一个好主意，可以帮助防止错误。
- en: Listing 8.3 A HTTP request with stream readers and writers
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.3 使用流读取器和写入器的 HTTP 请求
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ Read a line and decode it until we don’t have any left.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 读取一行并解码，直到没有剩余的行。
- en: ❷ Write the http request, and drain the writer.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 写入 HTTP 请求，并排空写入器。
- en: ❸ Read each line, and store it in a list.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 读取每一行，并将其存储在列表中。
- en: ❹ Close the writer, and wait for it to finish closing.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 关闭写入器，并等待其完成关闭。
- en: In the preceding listing, we first create a convenience async generator to read
    all lines from a `StreamReader`, decoding them into strings until we don’t have
    any left to process. Then, in our main coroutine we open a connection to example.com,
    creating a `StreamReader` and `StreamWriter` instance in the process. We then
    write the request and drain the stream writer, using `write` and `drain`, respectively.
    Once we’ve written our request, we use our async generator to get each line from
    the response back, storing them in the `responses` list. Finally, we close the
    `StreamWriter` instance by calling `close` and then awaiting the `wait_closed`
    coroutine. Why do we need to call a method *and* a coroutine here? The reason
    is that when we call `close` a few things happen, such as deregistering the socket
    and calling the underlying transport’s `connection_lost` method. These all happen
    asynchronously on a later iteration of the event loop, meaning that immediately
    after we call `close` our connection isn’t closed until sometime later. If you
    need to wait for the connection to close before proceeding or are concerned about
    any exceptions that may happen while you’re closing, calling `wait_ closed` is
    best practice.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的列表中，我们首先创建了一个便利的异步生成器，用于从 `StreamReader` 读取所有行，将它们解码成字符串，直到没有剩余的行需要处理。然后，在我们的主协程中，我们打开到
    example.com 的连接，在这个过程中创建了一个 `StreamReader` 和 `StreamWriter` 实例。然后我们写入请求并排空流写入器，分别使用
    `write` 和 `drain`。一旦我们写完了请求，我们使用我们的异步生成器从响应中获取每一行，并将它们存储在 `responses` 列表中。最后，我们通过调用
    `close` 关闭 `StreamWriter` 实例，然后等待 `wait_closed` 协程。为什么在这里需要调用一个方法和一个协程？原因是当我们调用
    `close` 时，会发生一些事情，比如注销套接字和调用底层传输的 `connection_lost` 方法。这些都是在事件循环的后续迭代中异步发生的，这意味着在我们调用
    `close` 之后，我们的连接不会立即关闭，而是在稍后某个时间。如果你需要在继续之前等待连接关闭，或者担心在关闭过程中可能发生的任何异常，调用 `wait_closed`
    是最佳实践。
- en: We’ve now learned the basics around the stream APIs by making web requests.
    The usefulness of these classes extends beyond web- and network-based applications.
    Next, we’ll see how to utilize stream readers to create non-blocking command-line
    applications.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 通过进行网络请求，我们已经学会了关于流API的基础知识。这些类的作用不仅限于基于Web和网络的应用程序。接下来，我们将看到如何利用流读取器创建非阻塞的命令行应用程序。
- en: 8.4 Non-blocking command-line input
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.4 非阻塞命令行输入
- en: Traditionally in Python, when we need to get user input, we use the `input`
    function. This function will stop execution flow until the user has provided input
    and presses Enter. What if we want to run code in the background while remaining
    responsive to input? For example, we may want to let the user launch multiple
    long-running tasks concurrently, such as long-running SQL queries. In the case
    of a command-line chat application, we likely want the user to be able to type
    a message while receiving messages from other users.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，当我们需要获取用户输入时，我们通常使用`input`函数。这个函数会停止执行流程，直到用户提供了输入并按下Enter键。如果我们想在后台运行代码的同时保持对输入的响应呢？例如，我们可能希望让用户能够并发启动多个长时间运行的任务，比如长时间运行的SQL查询。在命令行聊天应用程序的情况下，我们可能希望用户能够在接收其他用户的消息的同时输入一条消息。
- en: Since asyncio is single-threaded, using `input` in an asyncio application means
    we stop the event loop from running until the user provides input, halting our
    entire application. Even using tasks to kick off an operation in the background
    won’t work. To demonstrate this, let’s attempt to create an application where
    the user enters a time for the application to sleep. We’d like to be able to run
    multiple of these sleep operations concurrently while still accepting user input,
    so we’ll ask for the number of seconds to sleep and create a `delay` task in a
    loop.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 由于asyncio是单线程的，在asyncio应用程序中使用`input`意味着我们停止事件循环运行，直到用户提供输入，这会停止我们整个应用程序。即使使用任务在后台启动操作也不会起作用。为了演示这一点，让我们尝试创建一个应用程序，用户可以输入应用程序睡眠的时间。我们希望能够在接受用户输入的同时并发运行多个睡眠操作，所以我们将要求用户输入睡眠的秒数并在循环中创建一个`delay`任务。
- en: Listing 8.4 Attempting background tasks
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.4 尝试后台任务
- en: '[PRE4]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If this code worked the way we intended, after we input a number we’d expect
    to see `sleeping` `for` `n` `second(s)` printed out followed by `finished` `sleeping`
    `for` `n` `second(s)` *n* seconds later. However, this isn’t the case, and we
    see nothing except our prompt to enter a time to sleep. This is because there
    is no `await` inside our code and, therefore, the task never gets a chance to
    run on the event loop. We can hack around this by putting `await` `asyncio.sleep(0)`
    after the `create_task` line that will schedule the task (this is known as ”yielding
    to the event loop” and will be covered in chapter 14). Even with this trick, as
    it stops the entire thread the `input` call still blocks any background task we
    create from running to completion.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这段代码按我们的预期工作，在我们输入一个数字后，我们预计会看到`sleeping` `for` `n` `second(s)`打印出来，然后`finished`
    `sleeping` `for` `n` `second(s)` *n* 秒后。然而，情况并非如此，我们什么也没有看到，除了提示我们输入睡眠时间的提示符。这是因为我们的代码中没有`await`，因此任务从未有机会在事件循环上运行。我们可以通过在`create_task`行之后放置`await`
    `asyncio.sleep(0)`来解决这个问题，这将安排任务（这被称为“让出事件循环”，将在第14章中介绍）。即使有了这个技巧，因为它停止了整个线程，`input`调用仍然会阻止我们创建的任何后台任务运行到完成。
- en: What we really want is for the `input` function to be a coroutine instead, so
    we could write something like `delay_time` `=` `await` `input('Enter` `a` `time`
    `to` `sleep:').` If we could do this, our task would schedule properly and continue
    to run while we waited for user input. Unfortunately, there is no coroutine variant
    of `input`, so we’ll need to do something else.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们真正想要的是让`input`函数成为一个协程，这样我们就可以编写类似`delay_time` `=` `await` `input('Enter`
    `a` `time` `to` `sleep:').`的东西。如果我们能这样做，我们的任务就会正确地安排，并在我们等待用户输入时继续运行。不幸的是，没有`input`的协程版本，所以我们需要做些其他的事情。
- en: This is where protocols and stream readers can help us out. Recall that a stream
    reader has the `readline` coroutine that is the type of coroutine we’re looking
    for. If we had a way to hook a stream reader to standard input, we could then
    use this coroutine for user input.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是协议和流读取器能帮我们解决问题的地方。回想一下，流读取器有一个`readline`协程，这正是我们正在寻找的协程类型。如果我们能将流读取器连接到标准输入，我们就可以使用这个协程来处理用户输入。
- en: asyncio has a coroutine method on the event loop called `connect_read_pipe`
    that connects a protocol to a file-like object, which is almost what we want.
    This coroutine method accepts a *protocol factory* and a *pipe*. A protocol factory
    is just a function that creates a protocol instance. A pipe is a file-like object,
    which is defined as an object with methods such as `read` and `write` on it. The
    `connect_read_pipe` coroutine will then connect the pipe to the protocol the factory
    creates, taking data from the pipe and sending it to the protocol.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: asyncio在事件循环上有一个名为`connect_read_pipe`的协程方法，它将一个协议连接到一个文件对象，这几乎是我们想要的。这个协程方法接受一个*协议工厂*和一个*管道*。协议工厂只是一个创建协议实例的函数。管道是一个文件对象，它被定义为具有`read`和`write`等方法的对象。然后`connect_read_pipe`协程将管道连接到工厂创建的协议，从管道获取数据并将其发送到协议。
- en: In terms of standard console input, `sys.stdin` fits the bill of a file-like
    object that we can pass in to `connect_read_pipe`. Once we call this coroutine,
    we’ll get a tuple of the protocol our factory function created and a `ReadTransport`.
    The question now becomes what protocol should we create in our factory, and how
    do we connect this with a `StreamReader` that has the `readline` coroutine we’d
    like to use?
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在标准控制台输入方面，`sys.stdin`符合我们可以传递给`connect_read_pipe`的文件对象。一旦我们调用这个协程，我们将得到一个元组，包含我们的工厂函数创建的协议和一个`ReadTransport`。现在的问题是，我们应该在工厂中创建什么协议，以及我们如何将这个协议与具有我们想要使用的`readline`协程的`StreamReader`连接起来？
- en: asyncio provides a utility class called `StreamReaderProtocol` for connecting
    instances of stream readers to protocols. When we instantiate this class, we pass
    in an instance of a stream reader. The protocol class then delegates to the stream
    reader we created, allowing us to use the stream reader to read data from standard
    input. Putting all these pieces together, we can create a command-line application
    that does not block the event loop when waiting for user input.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: asyncio提供了一个名为`StreamReaderProtocol`的实用类，用于将流读取器的实例连接到协议。当我们实例化这个类时，我们传递一个流读取器的实例。然后协议类将委托给我们所创建的流读取器，允许我们使用流读取器从标准输入读取数据。将这些部件组合在一起，我们可以创建一个在等待用户输入时不会阻塞事件循环的命令行应用程序。
- en: For Windows users
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Windows用户
- en: Unfortunately, on Windows `connect_read_pipe` will not work with `sys.stdin`.
    This is due to an unfixed bug caused by the way Windows implements file descriptors.
    For this to work on Windows, you’ll need to call `sys.stdin.readline()` in a separate
    thread using techniques we explored in chapter 7\. You can read more about this
    issue at [https://bugs.python.org/issue26832](https://bugs.python.org/issue26832).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，在Windows上`connect_read_pipe`将无法与`sys.stdin`一起工作。这是由于Windows实现文件描述符的方式导致的未修复的bug。为了在Windows上工作，您需要在一个单独的线程中调用`sys.stdin.readline()`，使用我们在第7章中探索的技术。您可以在[https://bugs.python.org/issue26832](https://bugs.python.org/issue26832)了解更多关于此问题的信息。
- en: Since we’ll be reusing the asynchronous standard in reader throughout the rest
    of the chapter, let’s create it in its own file, `listing_8_5.py`. We’ll then
    import it in the rest of the chapter.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将在本章的其余部分重复使用异步标准输入读取器，让我们将其创建在自己的文件`listing_8_5.py`中。然后我们将在本章的其余部分导入它。
- en: Listing 8.5 An asynchronous standard input reader
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.5 异步标准输入读取器
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the preceding listing, we create a reusable coroutine named `create_stdin_reader`
    that creates a `StreamReader` that we’ll use to asynchronously read standard input.
    We first create a stream reader instance and pass it to a stream reader protocol.
    We then call `connect_read_pipe`, passing in a protocol factory as a lambda function.
    This lambda returns the stream reader protocol we created earlier. We also pass
    `sys.stdin` to connect standard input to our stream reader protocol. Since we
    won’t need them, we ignore the transport and protocol that `connect_read_pipe`
    returns. We can now use this function to asynchronously read from standard input
    and build our application.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的列表中，我们创建了一个可重用的协程`create_stdin_reader`，它创建一个`StreamReader`，我们将使用它来异步读取标准输入。我们首先创建一个流读取器实例，并将其传递给一个流读取器协议。然后我们调用`connect_read_pipe`，传入一个作为lambda函数的协议工厂。这个lambda函数返回我们之前创建的流读取器协议。我们还传递`sys.stdin`来将标准输入连接到我们的流读取器协议。由于我们不需要它们，我们忽略了`connect_read_pipe`返回的传输和协议。现在我们可以使用这个函数来异步地从标准输入读取并构建我们的应用程序。
- en: Listing 8.6 Using stream readers for input
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.6 使用流读取器进行输入
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In our main coroutine, we call `create_stdin_reader` and loop forever, waiting
    for input from the user with the `readline` coroutine. Once user presses Enter
    on the keyboard, this coroutine will deliver the input text entered. Once we have
    input from the user, we convert it into an integer (note here that for a real
    application, we should add code to handle bad input, as we’ll crash if we pass
    in a string right now) and create a `delay` task. Running this, you’ll be able
    to run multiple `delay` tasks concurrently while still entering command-line input.
    For instance, entering delays of 5, 4, and 3 seconds, respectively, you should
    see the following output:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的主协程中，我们调用 `create_stdin_reader` 并无限循环，等待用户通过 `readline` 协程输入。一旦用户在键盘上按下
    Enter 键，这个协程将传递输入的文本。一旦我们收到用户的输入，我们将它转换为一个整数（注意在这里，对于实际的应用程序，我们应该添加代码来处理不良输入，因为我们现在传递一个字符串会导致崩溃）并创建一个
    `delay` 任务。运行这个任务，你将能够同时运行多个 `delay` 任务，同时还能输入命令行输入。例如，分别输入 5 秒、4 秒和 3 秒的延迟，你应该看到以下输出：
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This works, but this approach has a critical flaw. What happens if a message
    appears on the console while we’re typing an input delay time? To test this out,
    we’ll enter a delay time of 3 seconds and then start rapidly pressing 1\. Doing
    this, we’ll see something like the following:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这可行，但这种方法有一个关键的缺陷。如果我们输入输入延迟时间时控制台上出现消息，会发生什么？为了测试这个问题，我们将输入一个 3 秒的延迟时间，然后开始快速按下
    1。这样做，我们会看到以下类似的情况：
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: While we were typing, the message from our delay task prints out, disrupting
    our input line and forcing it to continue on the next line. In addition, the input
    buffer is now only `11`, meaning if we press Enter, we’ll create a `delay` task
    for that amount of time, losing the first few pieces of input. This is because,
    by default, the terminal runs in *cooked* mode. In this mode, the terminal echoes
    user input to standard output, and also processes special keys, such as Enter
    and CTRL-C. This issue arises because the `delay` coroutine writes to standard
    out at the same time the terminal is echoing output, causing a race condition.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们输入时，来自我们的延迟任务的消息打印出来，打断了我们的输入行，并迫使它继续在下一行。此外，输入缓冲区现在只有 `11`，这意味着如果我们按下 Enter，我们将创建一个持续该时间的
    `delay` 任务，丢失了前几部分输入。这是因为默认情况下，终端以 *cooked* 模式运行。在这种模式下，终端将用户输入回显到标准输出，并处理特殊键，如
    Enter 和 CTRL-C。这个问题出现是因为 `delay` 协程在终端回显输出时写入标准输出，导致竞争条件。
- en: There is also a single position on the screen where standard out writes to.
    This is known as a *cursor* and is much like a cursor you’d see in a word processor.
    As we enter input, the cursor rests on the line where our keyboard input prints
    out. This means that any output messages from other coroutines will print on the
    same line as our input, since this is where the cursor is, causing odd behavior.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 屏幕上还有一个位置，标准输出会写入。这被称为 *光标*，它就像在文字处理程序中看到的光标一样。当我们输入时，光标停留在我们的键盘输入打印出的行上。这意味着任何来自其他协程的输出消息都会打印在我们的输入所在的同一行，因为这是光标所在的位置，导致奇怪的行为。
- en: To solve these issues, we need a combination of two solutions. The first is
    to bring the echoing of input from the terminal into our Python application. This
    will ensure that, while echoing input from the user, we don’t write any output
    messages from other coroutines as we’re single-threaded. The second is to move
    the cursor around the screen when we write output messages, ensuring that we don’t
    write output messages on the same line as our input. We can do these by manipulating
    the settings of our terminal and using escape sequences.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这些问题，我们需要两种解决方案的组合。第一个是将终端的输入回显引入我们的 Python 应用程序。这将确保，当我们回显用户输入时，我们不会在单线程的情况下写入来自其他协程的任何输出消息。第二个是在我们写入输出消息时移动屏幕上的光标，确保我们不将输出消息写入我们的输入所在的同一行。我们可以通过操作终端设置和使用转义序列来实现这些操作。
- en: 8.4.1 Terminal raw mode and the read coroutine
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.4.1 终端 raw 模式和 read 协程
- en: Because our terminal is running in cooked mode, it handles echoing user input
    on `readline` for us outside of our application. How can we bring this processing
    into our application, so we can avoid the race conditions we saw previously?
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的终端以 cooked 模式运行，它会在我们的应用程序外部为我们处理 `readline` 上的用户输入。我们如何将这种处理引入我们的应用程序，以便我们避免之前看到的竞争条件？
- en: The answer is switching the terminal to *raw* mode. In raw mode, instead of
    the terminal doing buffering, preprocessing, and echoing for us, every keystroke
    is sent to the application. It is then up to us to echo and preprocess as we’d
    like. While this means we must do extra work, it also means we have fine-grained
    control around writing to standard out, giving us the needed power to avoid race
    conditions.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是将终端切换到**raw**模式。在raw模式下，终端不再为我们进行缓冲、预处理和回显，每个按键都会发送到应用程序。然后，就由我们来决定如何回显和预处理。虽然这意味着我们必须做额外的工作，但它也意味着我们可以在写入标准输出方面拥有更精细的控制，从而给我们提供避免竞争条件所需的权力。
- en: 'Python allows us to change the terminal to raw mode but also allows for `cbreak`
    mode. This mode behaves like raw mode with the difference being that keystrokes
    like CTRL-C will still be interpreted for us, saving us some work. We can enter
    raw mode by using the `tty` module and the `setcbreak` function like so:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Python允许我们更改终端到raw模式，但也允许`cbreak`模式。这种模式的行为类似于raw模式，不同之处在于像CTRL-C这样的按键仍然会被为我们解释，从而节省我们一些工作。我们可以通过使用`tty`模块和`setcbreak`函数来进入raw模式，如下所示：
- en: '[PRE9]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Once we’re in `cbreak` mode, we’ll need to rethink how we designed our application.
    The `readline` coroutine will no longer work, as it won’t echo any input for us
    in raw mode. Instead, we’ll want to read one character at a time and store it
    in our own internal buffer, echoing each character typed in. The standard input
    stream reader we created has a method called `read` that takes in a number of
    bytes to read from the stream. Calling `read(1)` will read one character at a
    time, which we can then store in a buffer and echo to standard out.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们进入`cbreak`模式，我们就需要重新思考我们的应用程序设计。`readline`协程将不再工作，因为在raw模式下，它不会为我们回显任何输入。相反，我们希望一次读取一个字符并将其存储在我们的内部缓冲区中，回显每个输入的字符。我们创建的标准输入流读取器有一个名为`read`的方法，该方法接受从流中读取的字节数。调用`read(1)`将一次读取一个字符，然后我们可以将其存储在缓冲区中并回显到标准输出。
- en: We now have two pieces of the puzzle to solve this, entering `cbreak` mode and
    reading one input character at a time, echoing it to standard out. We need to
    think through how to display the output of the `delay` coroutines, so it won’t
    interfere with our input.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有两块拼图要解决这个难题，进入`cbreak`模式和一次读取一个输入字符，将其回显到标准输出。我们需要思考如何显示`delay`协程的输出，以确保它不会干扰我们的输入。
- en: 'Let’s define a few requirements to make our application more user-friendly
    and solve the issue with output writing on the same line as input. We’ll then
    let these requirements inform how we implement things:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义一些要求，使我们的应用程序更加用户友好，并解决输出写入与输入同一行的问题。然后，我们将让这些要求指导我们的实现：
- en: The user input field should always remain at the bottom of the screen.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户输入字段应始终保持在屏幕底部。
- en: Coroutine output should start from the top of the screen and move down.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 协程输出应从屏幕顶部开始并向下移动。
- en: When there are more messages than available lines on the screen, existing messages
    should scroll up.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当屏幕上的消息行数超过可用行数时，现有消息应向上滚动。
- en: Given these requirements, how can we display the output from the `delay` coroutine?
    Given that we want to scroll messages up when there are more messages than available
    lines, writing directly to standard out with print will prove tricky. Instead
    of doing this, the approach we’ll take is keeping a *deque* (double-ended queue)
    of the messages we want to write to standard out. We’ll set the maximum number
    of elements in the deque to the number of rows on the terminal screen. This will
    give us the scrolling behavior we want when the deque is full, as items in the
    back of the deque will be discarded. When a new message is appended to the deque,
    we’ll move to the top of the screen and redraw each message. This will get us
    the scrolling behavior we desire without having to keep much information about
    the state of standard out. This makes our application flow look like the illustration
    in figure 8.3.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 给定这些要求，我们如何显示`delay`协程的输出？鉴于我们希望在消息行数超过可用行数时向上滚动消息，直接使用print将标准输出会变得很棘手。为此，我们将采取的方法是保持一个要写入标准输出的消息的*deque*（双端队列）。我们将设置deque中元素的最大数量为终端屏幕上的行数。当deque满时，这将给我们想要的滚动行为，因为deque后面的项目将被丢弃。当新的消息被追加到deque中时，我们将移动到屏幕顶部并重新绘制每个消息。这将使我们得到所需的滚动行为，而无需保留太多关于标准输出状态的信息。这使得我们的应用程序流程看起来像图8.3中的插图。
- en: '![08-03](Images/08-03.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![08-03](Images/08-03.png)'
- en: Figure 8.3 The delay console application
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3 延迟控制台应用程序
- en: 'Our game plan for the application will then be as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对该应用程序的计划如下：
- en: Move the cursor to the bottom of the screen, and when a key is pressed, append
    it to our internal buffer, and echo the keypress to standard out.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将光标移动到屏幕底部，当按下键时，将其追加到我们的内部缓冲区，并将按键回显到标准输出。
- en: When the user presses Enter, create a `delay` task. Instead of writing output
    messages to standard out, we’ll append them to a deque with a maximum number of
    elements equal to the number of rows on the console.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当用户按下Enter键时，创建一个`delay`任务。我们不会将输出消息写入标准输出，而是将它们追加到一个双端队列中，其元素的最大数量等于控制台上的行数。
- en: Once a message goes into the deque, we’ll redraw the output on the screen. We
    first move the cursor to the top left of the screen. We then print out all messages
    in the deque. Once we’re done, we return the cursor to the input row and column
    where it was before.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦消息进入双端队列，我们将在屏幕上重新绘制输出。我们首先将光标移动到屏幕的左上角。然后，我们将打印出双端队列中的所有消息。完成后，我们将光标返回到之前的输入行和列。
- en: To implement the application in this way, we’ll first need to learn how to move
    the cursor around the screen. We can use ANSI *escape codes* to do this. These
    are special codes we can write to standard out performing actions like changing
    the color of text, moving the cursor up or down, and deleting lines. Escape sequences
    are first introduced with an escape code; in Python, we can do this by printing
    `\033` to the console. Many of the escape sequences we’ll need to use are introduced
    by *control sequence introducers*, which are started by printing `\033[.` To better
    understand this, let’s see how to move the cursor to five lines below where it
    currently is.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 要以这种方式实现应用程序，我们首先需要学习如何移动光标在屏幕上。我们可以使用ANSI *转义码*来完成这项任务。这些是我们可以写入标准输出的特殊代码，可以执行诸如更改文本颜色、移动光标上下和删除行等操作。转义序列首先由一个转义码引入；在Python中，我们可以通过向控制台打印`\033`来实现。我们将需要使用的大多数转义序列都是由*控制序列引入符*引入的，它以打印`\033[`开始。为了更好地理解这一点，让我们看看如何将光标移动到当前光标下方五行的位置。
- en: '[PRE10]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This escape sequence starts with the control sequence introducer followed by
    `5E`. 5 represents the number of rows from the current cursor row we’d like to
    move down, and E is the code for “move the cursor down this number of lines.”
    Escape sequences are terse and a little hard to follow. In the next listing, we’ll
    create several functions with clear names to explain what each escape code does,
    and we’ll import them in future listings. If you’d like more explanation on ANSI
    escape sequences and how they work, the Wikipedia article on the subject has great
    information at [https://en .wikipedia.org/wiki/ANSI_escape_code](https://en.wikipedia.org/wiki/ANSI_escape_code).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这个转义序列以控制序列引入符开头，后跟`5E`。5代表从当前光标行开始我们希望下移的行数，而E是“向下移动这么多行”的代码。转义序列简洁且稍难理解。在下一个列表中，我们将创建几个具有清晰名称的函数来解释每个转义码的作用，并在未来的列表中导入它们。如果您想了解更多关于ANSI转义序列及其工作原理的解释，Wikipedia上关于该主题的文章提供了很好的信息，链接为[https://en.wikipedia.org/wiki/ANSI_escape_code](https://en.wikipedia.org/wiki/ANSI_escape_code)。
- en: 'Let’s think through how we’ll need to move the cursor around the screen to
    figure out which functions we’ll need to implement. First, we’ll need to move
    the cursor to the bottom of the screen to accept user input. Then, once the user
    presses Enter, we’ll need to clear any text they have entered. To print coroutine
    output messages from the top of the screen, we’ll need to be able to move to the
    first line of the screen. We’ll also need to save and restore the current position
    of the cursor, since while we’re typing a message from a coroutine it may print
    a message, meaning we’ll need to move it back to the proper spot. We can do these
    with the following escape code functions:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们思考一下我们需要如何移动光标来屏幕周围，以确定我们需要实现哪些函数。首先，我们需要将光标移动到屏幕底部以接受用户输入。然后，一旦用户按下Enter键，我们需要清除他们输入的任何文本。为了从屏幕顶部打印协程输出消息，我们需要能够移动到屏幕的第一行。我们还需要保存和恢复光标当前的位置，因为在从协程中输入消息时，它可能会打印一条消息，这意味着我们需要将其移回正确的位置。我们可以使用以下转义码函数来完成这些操作：
- en: Listing 8.7 Escape sequence convenience functions
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.7 转义序列便利函数
- en: '[PRE11]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now that we have a set of reusable functions to move the cursor around the screen,
    let’s implement a reusable coroutine for reading standard input one character
    at a time. We’ll use the `read` coroutine to do this. Once we have read a character,
    we’ll write it to standard output, storing the character in an internal buffer.
    Since we also want to handle a user pressing Delete, we’ll watch for the Delete
    key. When a user presses it, we’ll delete the character from the buffer and standard
    output.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一组可重用的函数来在屏幕上移动光标，让我们实现一个可重用的协程，用于逐个读取标准输入。我们将使用 `read` 协程来完成此操作。一旦我们读取了一个字符，我们将将其写入标准输出，并将字符存储在内部缓冲区中。由于我们还想处理用户按下
    Delete 的情况，我们将监视 Delete 键。当用户按下它时，我们将从缓冲区和标准输出中删除字符。
- en: Listing 8.8 Reading input one character at a time
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.8 逐个读取输入
- en: '[PRE12]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ❶ Convenience function to delete the previous character from standard output
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 删除标准输出中前一个字符的便利函数
- en: ❷ If the input character is backspace, remove the last character.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 如果输入字符是退格键，则删除最后一个字符。
- en: ❸ If the input character is not backspace, append it to the buffer and echo.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 如果输入字符不是退格键，将其追加到缓冲区并回显。
- en: Our coroutine takes in a stream reader that we’ve attached to standard input.
    We then define a convenience function to erase the previous character from standard
    output, as we’ll need this when a user presses Delete. We then enter a `while`
    loop reading character by character until the user hits Enter. If the user presses
    Delete, we remove the last character from the buffer and from standard out. Otherwise,
    we append it to the buffer and echo it. Once the user presses Enter, we clear
    the input line and return the contents of the buffer.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的协程接收一个流读取器，该读取器已连接到标准输入。然后我们定义一个便利函数来擦除标准输出的前一个字符，因为我们将在用户按下 Delete 键时需要这个功能。然后我们进入一个
    `while` 循环，逐个读取字符，直到用户按下 Enter。如果用户按下 Delete，我们将从缓冲区和标准输出中删除最后一个字符。否则，我们将它追加到缓冲区并回显。一旦用户按下
    Enter，我们将清除输入行并返回缓冲区的内容。
- en: Next, we’ll need to define the queue where we’ll store the messages we want
    to print to standard out. Since we want to redraw output whenever we append a
    message, we’ll define a class that wraps a deque and takes in a callback awaitable.
    The callback we pass in will be responsible for redrawing output. We’ll also add
    an `append` coroutine method to our class that will append items to the deque
    and call the callback with the current set of items in the deque.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要定义一个队列，我们将存储想要打印到标准输出的消息。由于我们希望在追加消息时重新绘制输出，我们将定义一个类，该类封装一个双端队列并接受一个可等待的回调。我们传递的回调将负责重新绘制输出。我们还将为我们的类添加一个
    `append` 协程方法，该方法将项目追加到双端队列并使用当前双端队列中的项目集调用回调。
- en: Listing 8.9 A message store
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.9 消息存储
- en: '[PRE13]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now, we have all the pieces to create the application. We’ll rewrite our `delay`
    coroutine to add messages to the message store. Then, in our main coroutine, we’ll
    create a helper coroutine to redraw messages in our deque to standard out. This
    is the callback we’ll pass to our `MessageStore`. Then, we’ll use the `read_line`
    coroutine we implemented earlier to accept user input, creating a delay task when
    the user hits Enter.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有了创建应用程序的所有部件。我们将重写我们的 `delay` 协程，以便向消息存储中添加消息。然后，在我们的主协程中，我们将创建一个辅助协程来重新绘制双端队列中的消息到标准输出。这是我们传递给
    `MessageStore` 的回调。然后，我们将使用我们之前实现的 `read_line` 协程来接受用户输入，当用户按下 Enter 时创建一个延迟任务。
- en: Listing 8.10 The asynchronous delay application
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.10 异步延迟应用程序
- en: '[PRE14]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: ❶ Append the output messages to the message store.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将输出消息追加到消息存储中。
- en: ❷ Callback to move the cursor to the top of the screen; redraw output and move
    the cursor back.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 回调用于将光标移动到屏幕顶部；重新绘制输出并将光标移回。
- en: Running this, you’ll be able to create delays and watch input write to the console
    even as you type. While it is more complicated than our first attempt, we’ve built
    an application that avoids the problems writing to standard out that we faced
    earlier.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此程序，您将能够创建延迟并观察输入写入控制台，即使您在输入时也是如此。虽然它比我们的第一次尝试更复杂，但我们已经构建了一个避免我们之前在写入标准输出时遇到的问题的应用程序。
- en: What we’ve built works for the `delay` coroutine, but what about something more
    real-world? The pieces we’ve just defined are robust enough we can make more useful
    applications by reusing them. For example, let’s think through how to create a
    command-line SQL client. Certain queries may take a long time to execute, but
    we may want to run other queries in the meantime or cancel a running query. Using
    what we’ve just built, we can create this type of client. Let’s build one using
    our previous e-commerce product database from chapter 5, where we created a schema
    with a set of clothing brands, products, and SKUs. We’ll create a connection pool
    to connect to our database, and we’ll reuse our code from previous examples to
    accept and run queries. We’ll output basic information about the queries to the
    console—for now, just the number of rows returned.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们构建的适用于 `delay` 协程，但对于更实际的应用又如何呢？我们刚刚定义的组件足够健壮，我们可以通过重用它们来创建更有用的应用程序。例如，让我们思考一下如何创建一个命令行
    SQL 客户端。某些查询可能需要很长时间才能执行，但在此期间我们可能想运行其他查询或取消正在运行的查询。使用我们刚刚构建的组件，我们可以创建这种类型的客户端。让我们使用第
    5 章中创建的之前的电子商务产品数据库来构建一个，其中我们创建了一个包含一系列服装品牌、产品和 SKU 的模式。我们将创建一个连接池来连接到我们的数据库，并重用之前示例中的代码来接受和运行查询。我们将输出查询的基本信息到控制台——目前，只是返回的行数。
- en: Listing 8.11 An asynchronous command-line sql client
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.11 一个异步命令行 SQL 客户端
- en: '[PRE15]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Our code is almost the same as before, with the difference that instead of a
    `delay` coroutine, we create a `run_query` coroutine. Instead of just sleeping
    for an arbitrary amount of time, this runs a query the user entered that can take
    an arbitrary amount of time. This lets us issue new queries from the command line
    while others are still running; it and also lets us see output from completed
    ones even as we are typing in new queries.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码几乎和之前一样，区别在于我们不是创建一个 `delay` 协程，而是创建一个 `run_query` 协程。它不是简单地等待任意时间，而是运行用户输入的查询，这可能需要任意时间。这使得我们可以在其他查询仍在运行时从命令行发出新的查询；它还允许我们在输入新查询的同时看到已完成查询的输出。
- en: We now know how to create command-line clients that can handle input while other
    code executes and writes to the console. Next, we’ll learn how to create servers
    using higher-level asyncio APIs.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在知道如何创建在执行其他代码并写入控制台的同时可以处理输入的命令行客户端。接下来，我们将学习如何使用更高层次的 asyncio API 创建服务器。
- en: 8.5 Creating servers
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.5 创建服务器
- en: When we have built servers, such as our echo server, we’ve created a server
    socket, bound it to a port and waited for incoming connections. While this works,
    asyncio lets us create servers at a higher level of abstraction, meaning we can
    create them without ever worrying about managing sockets. Creating servers this
    way simplifies the code we need to write with sockets, and as such, using these
    higher-level APIs is the recommended way to create and manage servers using asyncio.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们构建服务器，例如我们的回声服务器时，我们已经创建了一个服务器套接字，将其绑定到一个端口并等待传入的连接。虽然这可行，但 asyncio 允许我们以更高层次的抽象创建服务器，这意味着我们可以创建服务器而无需担心管理套接字。以这种方式创建服务器简化了我们需要编写的套接字代码，因此，使用这些高级
    API 是推荐的方式来创建和管理使用 asyncio 的服务器。
- en: 'We can create a server with the `asyncio.start_server` coroutine. This coroutine
    takes in several optional parameters to configure things such as SSL, but the
    main parameters we’ll be interested in are the `host`, `port`, and `client_connected_cb`.
    The host and port are like what we’ve seen before: the address that the server
    socket will listen for connections. The more interesting piece is `client_connected_cb`,
    which is either a callback function or a coroutine that will run whenever a client
    connects to the server. This callback takes in a `StreamReader` and `StreamWriter`
    as parameters that will let us read from and write to the client that connected
    to the server.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `asyncio.start_server` 协程来创建一个服务器。这个协程接受几个可选参数来配置诸如 SSL 之类的设置，但我们最感兴趣的参数是
    `host`、`port` 和 `client_connected_cb`。主机和端口就像我们之前看到的：服务器套接字将监听连接的地址。更有趣的部分是 `client_connected_cb`，它是一个回调函数或协程，每当客户端连接到服务器时都会运行。这个回调函数接受一个
    `StreamReader` 和 `StreamWriter` 作为参数，这将使我们能够从连接到服务器的客户端读取和写入。
- en: When we await `start_server`, it will return an `AbstractServer` object. This
    class lacks many interesting methods that we’ll need to use, other than `serve_forever`,
    which runs the server forever until we terminate it. This class is also an asynchronous
    context manager. This means we can use an instance of it with `async` `with` syntax
    to have the server properly shut down on exit.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们等待 `start_server` 时，它将返回一个 `AbstractServer` 对象。除了 `serve_forever` 方法外，这个类缺少许多我们需要的有趣方法，`serve_forever`
    方法将服务器无限期运行，直到我们终止它。这个类也是一个异步上下文管理器。这意味着我们可以使用它的一个实例与 `async` `with` 语法一起使用，以便在退出时正确关闭服务器。
- en: To get a handle on creating servers, let’s create an echo server again but make
    it a little more advanced. Instead of just echoing back output, we’ll display
    information about how many other clients are connected. We’ll also display information
    when a client disconnects from the server. To manage this, we’ll create a class
    we’ll call `ServerState` to manage how many users are connected. Once a user connects,
    we’ll add them to the server state and notify other clients that they connected.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 为了掌握创建服务器的技巧，让我们再次创建一个回声服务器，但让它更高级一些。我们不仅会回显输出，还会显示有关连接了多少其他客户端的信息。当客户端从服务器断开连接时，我们也会显示信息。为了管理这些，我们将创建一个名为
    `ServerState` 的类来管理连接的用户数量。一旦用户连接，我们将他们添加到服务器状态，并通知其他客户端他们已连接。
- en: Listing 8.12 Creating an echo server with server objects
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.12 使用服务器对象创建回声服务器
- en: '[PRE16]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: ❶ Add a client to the server state, and create an echo task.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将客户端添加到服务器状态，并创建一个回声任务。
- en: ❷ On a new connection, tell the client how many users are online, and notify
    others of a new user.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在新的连接上，告诉客户端有多少用户在线，并通知其他新用户。
- en: ❸ Handle echoing user input when a client disconnects, and notify other users
    of a disconnect.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 当客户端断开连接时，处理回声用户输入，并通知其他用户断开连接。
- en: ❹ Helper method to send a message to all other users. If a message fails to
    send, remove that user.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 辅助方法，用于向所有其他用户发送消息。如果消息发送失败，则移除该用户。
- en: ❺ When a client connects, add that client to the server state.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 当客户端连接时，将该客户端添加到服务器状态。
- en: ❻ Start the server, and start serving forever.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 启动服务器，并永久提供服务。
- en: When a user connects to our server, our `client_connected` callback responds
    with a reader and writer for that user, which in turn calls the server state’s
    `add_client` coroutine. In the `add_client` coroutine, we store the `StreamWriter`,
    so we can send messages to all connected clients and remove it when a client disconnects.
    We then call `_on_connect`, which sends a message to the client informing them
    how many other users are connected. In `_on_connect`, we also notify any other
    connected clients that a new user has connected.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户连接到我们的服务器时，我们的 `client_connected` 回调会返回该用户的读取器和写入器，这反过来又调用服务器状态的 `add_client`
    协程。在 `add_client` 协程中，我们存储 `StreamWriter`，这样我们就可以向所有已连接客户端发送消息，并在客户端断开连接时移除它。然后我们调用
    `_on_connect`，向客户端发送一条消息，告知他们有多少其他用户已连接。在 `_on_connect` 中，我们还通知任何其他已连接客户端有新用户已连接。
- en: The`_echo` coroutine is similar to what we’ve done in the past with the twist
    being that when a user disconnects, we notify any other connected clients that
    someone disconnected. When running this, you should have a functioning echo server
    that lets each individual client know when a new user connects and disconnects
    from the server.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`_echo` 协程类似于我们过去所做，但有一个转折，即当用户断开连接时，我们通知任何其他已连接客户端有人断开连接。在运行此操作时，你应该有一个功能正常的回声服务器，让每个客户端都知道何时有新用户连接到或从服务器断开连接。'
- en: We’ve now seen how to create an asyncio server that is a little more advanced
    than what we’ve done previously. Next, let’s build on top of this knowledge and
    create a chat server and chat client—something even more advanced.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何创建一个比之前更高级的 asyncio 服务器。接下来，让我们在此基础上构建，创建一个聊天服务器和聊天客户端——这将是更高级的内容。
- en: 8.6 Creating a chat server and client
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.6 创建聊天服务器和客户端
- en: We now know how to both create servers and handle asynchronous command-line
    input. We can combine what we know in these two areas to create two applications.
    The first is a chat server that accepts multiple chat clients at the same time,
    and the second is a chat client that connects to the server and sends and receives
    chat messages.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在知道如何创建服务器并处理异步命令行输入。我们可以将这两个领域的知识结合起来，创建两个应用程序。第一个是一个聊天服务器，可以同时接受多个聊天客户端，第二个是一个连接到服务器并发送接收聊天消息的聊天客户端。
- en: 'Before we begin designing our application, let’s start with some requirements
    that will help us make the correct design choices. First, for our server:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始设计应用程序之前，让我们先从一些将帮助我们做出正确设计选择的需求开始。首先，对于我们的服务器：
- en: A chat client should be able to connect to the server when they provide a username.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个聊天客户端应该能够在提供用户名时连接到服务器。
- en: Once a user is connected, they should be able to send chat messages to the server,
    and each message should be sent to every user connected to the server.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦用户连接上了，他们应该能够向服务器发送聊天消息，并且每条消息都应该发送给服务器上所有连接的用户。
- en: To prevent idle users taking up resources, if a user is idle for more than one
    minute, the server should disconnect them.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了防止空闲用户占用资源，如果一个用户空闲超过一分钟，服务器应该断开他们的连接。
- en: 'Second, for our client:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，对于我们的客户端：
- en: When a user starts the application, the client should prompt for a username
    and attempt to connect to the server.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当用户启动应用程序时，客户端应该提示输入用户名并尝试连接到服务器。
- en: Once connected, the user will see any messages from other clients scroll down
    from the top of the screen.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦连接，用户将看到来自其他客户端的消息从屏幕顶部滚动下来。
- en: The user should have an input field at the bottom of the screen. When the user
    presses Enter, the text in the input should be sent to the server and then to
    all other connected clients.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户应该在屏幕底部有一个输入字段。当用户按下Enter键时，输入框中的文本应该发送到服务器，然后发送给所有其他已连接的客户端。
- en: Given these requirements, let’s first think through what our communication between
    the client and server should look like. First, we’ll need to send a message from
    the client to the server with our username. We need to disambiguate connecting
    with a username from a message send, so we’ll introduce a simple command protocol
    to indicate that we’re sending a username. To keep things simple, we’ll just pass
    a string with a command name called `CONNECT` followed by the user-provided username.
    For example, `CONNECT` `MissIslington` will be the message we’ll send to the server
    to connect a user with the username “MissIslington.”
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 给定这些需求，让我们首先思考一下客户端和服务器之间的通信应该是什么样的。首先，我们需要从客户端向服务器发送一条包含我们用户名的消息。我们需要区分使用用户名连接和发送消息，因此我们将引入一个简单的命令协议来指示我们正在发送用户名。为了简化，我们将只传递一个包含命令名称的字符串，命令名称为`CONNECT`，后跟用户提供的用户名。例如，`CONNECT`
    `MissIslington`将是我们将发送到服务器的消息，以将用户名“MissIslington”的用户连接到服务器。
- en: Once we’ve connected, we’ll just send messages directly to the server, which
    will then send the message to all connected clients (including ourselves; as needed,
    you could optimize this away). For a more robust application, you may want to
    consider a command that the server sends back to the client to acknowledge that
    the message was received, but we’ll skip this for brevity.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们连接上了，我们只需直接向服务器发送消息，然后服务器会将消息发送给所有已连接的客户端（包括我们自己；如有需要，你可以优化这一点）。为了使应用程序更健壮，你可能想要考虑一个服务器发送回客户端的命令来确认消息已被接收，但为了简洁起见，我们将跳过这一点。
- en: With this in mind, we have enough to start designing our server. We’ll create
    a `ChatServerState` class similar to what we did in the previous section. Once
    a client connects, we’ll wait for them to provide a username with the `CONNECT`
    command. Assuming they provide it, we’ll create a task to listen for messages
    from the client and write them to all other connected clients. To keep track of
    connected clients, we’ll keep a dictionary of the connected usernames to their
    `StreamWriter` instances. If a connected user is idle for more than a minute,
    we’ll disconnect them and remove them from the dictionary, sending a message to
    other users that they left the chat.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个想法，我们就有足够的内容开始设计我们的服务器了。我们将创建一个类似于上一节所做的一个`ChatServerState`类。一旦客户端连接，我们将等待他们使用`CONNECT`命令提供用户名。假设他们提供了，我们将创建一个任务来监听来自客户端的消息并将它们写入所有其他已连接的客户端。为了跟踪已连接的客户端，我们将保持一个包含已连接用户名到其`StreamWriter`实例的字典。如果一个已连接的用户空闲超过一分钟，我们将断开他们的连接并将他们从字典中移除，同时向其他用户发送消息，告知他们有人离开了聊天。
- en: Listing 8.13 A chat server
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.13 一个聊天服务器
- en: '[PRE17]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: ❶ Wait for the client to provide a valid username command; otherwise, disconnect
    them.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 等待客户端提供有效的用户名命令；否则，断开连接。
- en: ❷ Store a user’s stream writer instance and create a task to listen for messages.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 存储用户的流写入实例并创建一个任务来监听消息。
- en: ❸ Once a user connects, notify all others that they have connected.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 一旦用户连接，通知其他人他们也已连接。
- en: ❹ Listen for messages from a client and send them to all other clients, waiting
    a maximum of a minute for a message.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 监听来自客户端的消息并发送给所有其他客户端，等待最多一分钟接收消息。
- en: ❺ Send a message to all connected clients, removing any disconnected users.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 向所有已连接的客户端发送消息，移除任何断开连接的用户。
- en: Our `ChatServer` class encapsulates everything about our chat server in one
    clean interface. The main entry point is the `start_chat_server` coroutine. This
    coroutine starts a server on the specified host and port, and calls `serve_forever`.
    For our server’s client connected callback, we use our `client_connected` coroutine.
    This coroutine waits for the first line of data from the client, and if it receives
    a valid `CONNECT` command, it calls `_add_user` and then`_on_connect`; otherwise,
    it terminates the connection.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `ChatServer` 类封装了我们聊天服务器的所有内容，提供了一个干净的接口。主要入口点是 `start_chat_server` 协程。这个协程在指定的主机和端口上启动服务器，并调用
    `serve_forever`。对于我们的服务器客户端连接回调，我们使用我们的 `client_connected` 协程。这个协程等待客户端的第一行数据，如果它收到一个有效的
    `CONNECT` 命令，它将调用 `_add_user` 然后调用 `_on_connect`；否则，它终止连接。
- en: The `_add_user` function stores the username and user’s stream writer in an
    internal dictionary and then creates a task to listen for chat messages from the
    user. The `_on_connect` coroutine sends a message to the client welcoming them
    to the chat room and then notifies all other connected clients that the user connected.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`_add_user` 函数将用户名和用户的流写入器存储在一个内部字典中，然后创建一个任务来监听来自用户的聊天消息。`_on_connect` 协程向客户端发送一条欢迎消息，然后通知所有其他已连接的客户端用户已连接。'
- en: When we called `_add_user`, we created a task for the `_listen_for_messages`
    coroutine. This coroutine is where the meat of our application lies. We loop forever,
    reading messages from the client until we see an empty line, indicating the client
    disconnected. Once we get a message, we call `_notify_all` to send the chat message
    to all connected clients. To satisfy the requirement that a client should be disconnected
    after being idle for a minute, we wrap our `readline` coroutine in `wait_for`.
    This will throw a `TimeoutError` if the client has idled for longer than a minute.
    In this case, we have a broad exception clause that catches `TimeoutError` and
    any other exceptions thrown. We handle any exception by removing the client from
    the `_username_to_writer` dictionary, so we stop sending messages to them.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用 `_add_user` 时，我们为 `_listen_for_messages` 协程创建了一个任务。这个协程是我们应用程序的核心。我们无限循环，从客户端读取消息，直到我们看到一个空行，这表示客户端断开连接。一旦我们收到一条消息，我们就调用
    `_notify_all` 将聊天消息发送给所有已连接的客户端。为了满足客户端在空闲一分钟后被断开的要求，我们将 `readline` 协程包装在 `wait_for`
    中。如果客户端空闲时间超过一分钟，这将抛出一个 `TimeoutError`。在这种情况下，我们有一个广泛的异常处理子句，它捕获 `TimeoutError`
    和抛出的任何其他异常。我们通过从 `_username_to_writer` 字典中删除客户端来处理任何异常，这样我们就停止向他们发送消息。
- en: We now have a complete server, but the server is meaningless without a client
    to connect to it. We’ll implement the client similarly to the command-line SQL
    client we wrote earlier. We’ll create a coroutine to listen for messages from
    the server and append them to a message store, redrawing the screen when a new
    message comes in. We’ll also put the input at the bottom of the screen, and when
    the user presses Enter, we’ll send the message to the chat server.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个完整的服务器，但没有客户端连接，服务器就没有意义。我们将以我们之前编写的命令行 SQL 客户端类似的方式实现客户端。我们将创建一个协程来监听来自服务器的消息并将它们追加到消息存储中，当有新消息到来时重绘屏幕。我们还将输入放在屏幕底部，当用户按下
    Enter 键时，我们将消息发送到聊天服务器。
- en: Listing 8.14 The chat client
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.14 聊天客户端
- en: '[PRE18]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: ❶ Listen for messages from the server, appending them to the message store.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 监听来自服务器的消息，并将它们追加到消息存储中。
- en: ❷ Read input from the user, and send it to the server.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 从用户读取输入，并将其发送到服务器。
- en: ❸ Open a connection to the server, and send the connect message with the username.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 打开到服务器的连接，并发送带有用户名的连接消息。
- en: ❹ Create a task to listen for messages, and listen for input; wait until one
    finishes.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 创建一个任务来监听消息，并监听输入；等待其中一个完成。
- en: 'We first ask the user for their username, and once we have one, we send our
    `CONNECT` message to the server. Then, we create two tasks: one to listen for
    messages from the server and one to continuously read chat messages and send them
    to the server. We then take these two tasks and wait for whichever one completes
    first by wrapping them in `asyncio.wait`. We do this because the server could
    disconnect us, or the input listener could throw an exception. If we just `await`ed
    each task independently, we may find ourselves stuck. For instance, if the server
    disconnected us, we’d have no way to stop the input listener if we had awaited
    that task first. Using the `wait` coroutine prevents this issue because if either
    the message listener or input listener finishes, our application will exit. If
    we wanted to have more robust logic here, we could do this by checking the `done`
    and `pending` sets `wait` returns. For instance, if the input listener threw an
    exception, we could cancel the message listener task.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先向用户请求他们的用户名，一旦我们得到一个，我们就向服务器发送我们的`CONNECT`消息。然后，我们创建两个任务：一个用于监听来自服务器的消息，另一个用于持续读取聊天消息并将它们发送到服务器。然后，我们将这两个任务包装在`asyncio.wait`中，等待任何一个先完成。我们这样做是因为服务器可能会断开我们的连接，或者输入监听器可能会抛出异常。如果我们独立地`await`每个任务，我们可能会发现自己陷入了困境。例如，如果服务器断开了我们的连接，如果我们首先`await`了那个任务，我们就无法停止输入监听器。使用`wait`协程可以防止这个问题，因为如果消息监听器或输入监听器完成，我们的应用程序将退出。如果我们想在这里有更健壮的逻辑，我们可以通过检查`wait`返回的`done`和`pending`集合来实现。例如，如果输入监听器抛出了异常，我们可以取消消息监听器任务。
- en: 'If you first run the server, then run a couple of chat clients, you’ll be able
    to send and receive messages in the client like a normal chat application. For
    example, two users connecting to the chat may produce output like the following:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你首先运行服务器，然后运行几个聊天客户端，你将能够在客户端发送和接收消息，就像一个正常的聊天应用程序一样。例如，两个连接到聊天的用户可能会产生以下输出：
- en: '[PRE19]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We’ve built a chat server and client that can handle multiple users connected
    simultaneously with only one thread. This application could stand to be more robust.
    For example, you may want to consider retrying message sends on failure or a protocol
    to acknowledge a client received a message. Making this a production-worthy application
    is rather complex and is outside the scope of this book, though it might be a
    fun exercise for the reader, as there are many failure points to think through.
    Using similar concepts to what we’ve explored in this example, you’ll be able
    to create robust client and server applications to suit your needs.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们构建了一个聊天服务器和客户端，它可以仅使用一个线程同时处理多个用户的连接。这个应用程序可以更加健壮。例如，你可能想要考虑在失败时重试消息发送或一个协议来确认客户端已收到消息。将这个应用程序变成一个生产级别的应用相当复杂，并且超出了本书的范围，尽管这可能是一个有趣的练习，因为有许多故障点需要考虑。通过使用我们在本例中探索的类似概念，你将能够创建满足你需求的健壮的客户端和服务器应用程序。
- en: Summary
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: We’ve learned how to use the lower-level transport and protocol APIs to build
    a simple HTTP client. These APIs are the bedrock of the higher-level stream asyncio
    stream APIs and are generally not recommended for general use.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已经学会了如何使用低级别的传输和协议API构建简单的HTTP客户端。这些API是高级流异步io流API的基础，通常不推荐用于通用用途。
- en: We’ve learned how to use the `StreamReader` and `StreamWriter` classes to build
    network applications. These higher-level APIs are the recommended approach to
    work with streams in asyncio.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已经学会了如何使用`StreamReader`和`StreamWriter`类来构建网络应用程序。这些高级API是异步io中处理流的推荐方法。
- en: We’ve learned how to use streams to create non-blocking command-line applications
    that can remain responsive to user input while running tasks in the background.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已经学会了如何使用流来创建非阻塞的命令行应用程序，这些应用程序可以在后台运行任务的同时保持对用户输入的响应。
- en: We’ve learned how to create servers using the `start_server` coroutine. This
    approach is the recommended way to create servers in asyncio, as opposed to using
    sockets directly.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已经学会了如何使用`start_server`协程来创建服务器。这种方法是异步io中创建服务器的推荐方式，而不是直接使用套接字。
- en: We’ve learned how to create responsive client and server applications using
    streams and servers. Using this knowledge, we can create network-based applications,
    such as chat servers and clients.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已经学会了如何使用流和服务器创建响应式的客户端和服务器应用程序。利用这些知识，我们可以创建基于网络的程序，例如聊天服务器和客户端。
