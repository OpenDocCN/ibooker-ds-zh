- en: Part 3\. Beyond web development
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 3 部分：超越 Web 开发
- en: Millions of people depend on apps that are built with Node. If you’ve ever used
    Slack or Visual Studio Node, you’ve used applications that are powered by Node.
    This part introduces both Electron and modules for writing command-line tools
    with Node. If you’ve ever wanted to make an app for Linux, macOS, or Windows,
    now you can.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 数百万的人依赖于用 Node 构建的应用程序。如果你曾经使用过 Slack 或 Visual Studio Node，你就使用过由 Node 提供动力的应用程序。这部分介绍了
    Electron 和用于用 Node 编写命令行工具的模块。如果你曾经想要为 Linux、macOS 或 Windows 制作应用程序，现在你可以做到了。
- en: Chapter 11\. Writing command-line applications
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 11 章：编写命令行应用程序
- en: '*This chapter covers*'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Designing command-line applications by using common conventions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用常见约定设计命令行应用程序
- en: Communicating with pipes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过管道进行通信
- en: Using exit codes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用退出码
- en: Node command-line utilities are used everywhere, from project automation tools,
    such as Gulp and Yeoman, to XML and JSON parsers. If you’ve ever wondered how
    to build command-line tools with Node, this chapter will show you everything you
    need to know to get started. You’ll learn how Node programs accept command-line
    arguments and how to handle I/O with pipes. We’ve also included shell tips that
    will help you use the command line more effectively.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Node 命令行实用工具被广泛应用于各个领域，从项目自动化工具，如 Gulp 和 Yeoman，到 XML 和 JSON 解析器。如果你曾经想知道如何使用
    Node 构建命令行工具，这一章将向你展示你需要知道的一切来开始。你将学习 Node 程序如何接受命令行参数以及如何通过管道处理 I/O。我们还包含了有助于你更有效地使用命令行的
    shell 小贴士。
- en: Although writing command-line tools with Node isn’t hard, it’s important to
    follow community conventions. This chapter includes many of these conventions
    so you’ll be able to write tools that other people can use, without too much documentation.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然使用 Node 构建命令行工具并不难，但遵循社区约定很重要。这一章包括了这些约定中的许多，这样你就能编写其他人可以使用而无需过多文档的工具。
- en: 11.1\. Understanding conventions and philosophy
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.1. 理解约定和哲学
- en: 'A big part of command-line development is understanding the conventions used
    by established programs. As a real-world example, take a look at Babel:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 命令行开发的一个重要部分是理解现有程序使用的约定。作为一个现实世界的例子，看看 Babel：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Several points are worth noting here. The first is the use of both `-h` and
    `--help` for printing help: this is a flag that many programs use. The second
    flag is `-f` for filename—this is an easy mnemonic to learn. Lots of flags are
    based on mnemonics. Using `-q` for quiet output is also a popular convention,
    and so is `-v` for showing the program’s version. Your applications should include
    these flags.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里有几个要点值得注意。第一个是使用 `-h` 和 `--help` 打印帮助：这是一个许多程序使用的标志。第二个标志是 `-f` 用于文件名——这是一个容易记忆的助记符。许多标志都是基于助记符的。使用
    `-q` 进行安静输出也是一个流行的约定，同样 `-v` 用于显示程序的版本。你的应用程序应该包括这些标志。
- en: 'This user interface isn’t merely a convention, however. The use of the hyphen
    and double hyphen (`--`) is recognized by the Open Group’s Utility Conventions.^([[1](#ch11fn01)])
    This document even specifies how they should be used:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个用户界面不仅仅是一个约定。使用连字符和双连字符 (`--`) 的做法得到了开放组实用约定（Utility Conventions）的认可。[1](#ch11fn01)
    这份文件甚至指定了它们应该如何使用：
- en: ¹
  id: totrans-14
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-15
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The Open Group Base Specifications Issue 7,” [http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap11.html](http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap11.html).
  id: totrans-16
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “开放组基础规范第 7 版”，[http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap11.html](http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap11.html)。
- en: '***Guideline 4—*** All options should be preceded by the `-` delimiter character.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***指南 4—*** 所有选项都应该以 `-` 分隔符字符开头。'
- en: '***Guideline 10—*** The first `--` argument that’s not an option-argument should
    be accepted as a delimiter indicating the end of options. Any following arguments
    should be treated as operands, even if they begin with the `-` character.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***指南 10—*** 第一个不是选项参数的 `--` 参数应该被接受为分隔符，表示选项的结束。任何随后的参数都应该被视为操作数，即使它们以 `-`
    字符开头。'
- en: Another aspect of command-line application design is philosophy. This dates
    back to the creators of UNIX, who wanted to design “small, sharp tools” that could
    be used together with a simple, text-based interface.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 命令行应用程序设计的另一个方面是哲学。这可以追溯到 UNIX 的创造者，他们希望设计“小巧、锋利”的工具，这些工具可以与简单的基于文本的界面一起使用。
- en: '*This is the UNIX philosophy: Write programs that do one thing and do it well.
    Write programs to work together. Write programs to handle text streams, because
    that is a universal interface.*'
  id: totrans-20
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*这是 UNIX 哲学：编写只做一件事并且做得好的程序。编写可以一起工作的程序。编写可以处理文本流的程序，因为这是一个通用的接口。*'
- en: ''
  id: totrans-21
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Doug McIlroy^([[2](#ch11fn02)])*'
  id: totrans-22
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*Doug McIlroy^([[2](#ch11fn02)])*'
- en: ²
  id: totrans-23
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ²
- en: ''
  id: totrans-24
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Basics of the Unix Philosophy”, [www.catb.org/~esr/writings/taoup/html/ch01s06.html](http://www.catb.org/~esr/writings/taoup/html/ch01s06.html).
  id: totrans-25
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Unix哲学基础”， [www.catb.org/~esr/writings/taoup/html/ch01s06.html](http://www.catb.org/~esr/writings/taoup/html/ch01s06.html)。
- en: In this chapter, we provide a broad overview of shell techniques and UNIX conventions
    so you can design command-line tools that other people can use. We offer guidance
    for Windows-specific usage as well, but for the most part, your Node tools should
    be cross-platform by default.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们提供了一个关于shell技术和UNIX约定的广泛概述，以便你可以设计其他人可以使用的命令行工具。我们还提供了Windows特定使用的指导，但就大部分而言，你的Node工具应该默认是跨平台的。
- en: '|  |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Shell tips: getting help**'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**Shell技巧：获取帮助**'
- en: If you get stuck when using the shell, try typing `man <cmd>`. This loads the
    manual page for the command.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在使用shell时遇到困难，尝试输入 `man <cmd>`。这将加载该命令的手册页。
- en: If you can’t remember the command’s name, you can use `apropos <cmd>` to search
    the database of system commands.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你记不住命令的名称，可以使用 `apropos <cmd>` 来搜索系统命令的数据库。
- en: '|  |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 11.2\. Introducing parse-json
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2\. 介绍 parse-json
- en: For JavaScript programmers, one of the simplest useful applications reads JSON
    and prints it if it’s valid. By following this chapter, you’ll re-create this
    tool.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 对于JavaScript程序员来说，一个最简单且有用的应用程序是读取JSON并在它有效时打印它。通过遵循本章，你将重新创建这个工具。
- en: 'Let’s start with what a command line for this application should look like.
    The following snippet shows how to invoke such a program:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从这个应用程序的命令行应该是什么样子开始。以下代码片段显示了如何调用这样的程序：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The first thing you need to do is figure out how to grab `-f my.json` from the
    command line; these are the program’s arguments. You also need to read input from
    stdin. Read on to learn how to do both of these things.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要做的第一件事是弄清楚如何从命令行获取 `-f my.json`；这些是程序的参数。你还需要从标准输入读取输入。继续阅读以了解如何完成这两件事。
- en: 11.3\. Using command-line arguments
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3\. 使用命令行参数
- en: Most—but not all—command-line programs accept arguments. Node has a built-in
    way to handle these arguments, but third-party modules on npm offer extra features.
    You need these features in order to implement some widely used conventions. Read
    on to learn more.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数但并非所有命令行程序都接受参数。Node有一个内置的方式来处理这些参数，但npm上的第三方模块提供了额外的功能。你需要这些功能来实现一些广泛使用的约定。继续阅读以了解更多。
- en: 11.3.1\. Parsing command-line arguments
  id: totrans-39
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.3.1\. 解析命令行参数
- en: Command-line arguments can be accessed by using the `process.argv` array. The
    items in the array are the strings passed to the shell when running a command.
    So if you split up the command, you can figure out what each item in the array
    is. The item at `process.argv[0]` is `node`, the item at `process.argv[1]` is
    `parse-json.js`, `[2]` is `-f`, and so forth.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过使用 `process.argv` 数组来访问命令行参数。数组中的项是在运行命令时传递给shell的字符串。因此，如果你拆分了命令，就可以弄清楚数组中的每个项是什么。`process.argv[0]`
    项是 `node`，`process.argv[1]` 项是 `parse-json.js`，`[2]` 是 `-f`，以此类推。
- en: 'If you’ve ever used command-line applications before, you may have seen arguments
    with `-` or `--`. These prefixes are special conventions for passing options to
    applications: `--` denotes a full string for an option name, and `-` denotes a
    single character for an option name. The `npm` command-line binary is a great
    example of this with `-h` and `--help`.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你以前使用过命令行应用程序，你可能见过带有 `-` 或 `--` 的参数。这些前缀是向应用程序传递选项的特殊约定：`--` 表示选项名称的完整字符串，而
    `-` 表示选项名称的单个字符。`npm` 命令行二进制文件是这种约定的一个很好的例子，其中 `-h` 和 `--help`。
- en: '|  |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Argument conventions**'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**参数约定**'
- en: 'Other argument conventions are as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 其他参数约定如下：
- en: '`--version` to print the version of your application'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--version` 打印应用程序的版本'
- en: '`-y` or `--yes` to use default values for any missing options'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-y` 或 `--yes` 使用任何缺失选项的默认值'
- en: '|  |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Adding aliases for arguments, such as `-h` and `–-help`, makes parsing awkward
    after you add support for several options, but luckily there’s a module for parsing
    arguments called *yargs*. The following snippet shows how yargs works in the simplest
    case. All you need to do is require yargs, and then access the `argv` property
    to inspect the arguments that were passed to the script:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为参数添加别名，如 `-h` 和 `–-help`，在添加了对多个选项的支持后会使解析变得困难，但幸运的是有一个名为 *yargs* 的模块用于解析参数。以下代码片段显示了yargs在最简单情况下的工作方式。你所需要做的就是引入yargs，然后访问
    `argv` 属性来检查传递给脚本的参数：
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[Figure 11.1](#ch11fig01) shows how Node’s built-in version of the command-line
    arguments differs from the object generated by yargs.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '[图11.1](#ch11fig01)显示了Node内置的命令行参数与yargs生成的对象之间的差异。'
- en: Figure 11.1\. Node’s argv compared to yargs
  id: totrans-51
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图11.1\. Node的argv与yargs的比较
- en: '![](Images/11fig01.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/11fig01.jpg)'
- en: Although an options object is useful, it doesn’t provide much structure for
    validating arguments and generating usage text. The next section shows how to
    describe and validate arguments.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然选项对象很有用，但它并没有为验证参数和生成使用文本提供太多结构。下一节将展示如何描述和验证参数。
- en: 11.3.2\. Validating arguments
  id: totrans-54
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.3.2\. 验证参数
- en: The yargs module includes methods for validating the arguments. The following
    listing shows how to use yargs to parse the `-f` argument that your JSON parser
    will need, and it uses the `describe` and `nargs` methods to enforce the expected
    argument format.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: yargs模块包括用于验证参数的方法。以下列表展示了如何使用yargs解析您的JSON解析器所需的`-f`参数，并使用`describe`和`nargs`方法强制执行预期的参数格式。
- en: Listing 11.1\. Using yargs to parse command-line arguments
  id: totrans-56
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表11.1\. 使用yargs解析命令行参数
- en: '![](Images/11lis01_alt.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/11lis01_alt.jpg)'
- en: 'Using yargs is easier than manipulating the `process.argv` array, and it’s
    better because rules can be enforced. [Listing 11.1](#ch11ex01) uses `demand`
    to force an argument, and then declares that it requires a single parameter, which
    will be the JSON file to parse. To make the program easier to use, you can provide
    usage text with yargs as well. The convention here is to print the usage text
    when `-h` or `--help` is passed. You can add these with the help of yargs, as
    shown in this snippet:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 使用yargs比操作`process.argv`数组更容易，而且更好，因为可以强制执行规则。[列表11.1](#ch11ex01)使用`demand`强制一个参数，然后声明它需要一个参数，这个参数将是解析的JSON文件。为了使程序更容易使用，您还可以使用yargs提供使用文本。这里的约定是在传递`-h`或`--help`时打印使用文本。您可以使用yargs添加这些，如下面的代码片段所示：
- en: '[PRE3]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now your JSON parser can accept a file argument and process the file. File handling
    isn’t yet finished for this project, however, because it also needs to accept
    stdin. Read on to learn how to do that with a common UNIX convention.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您的JSON解析器可以接受文件参数并处理文件。然而，对于这个项目来说，文件处理还没有完成，因为它还需要接受stdin。继续阅读，了解如何使用常见的UNIX约定来完成这一点。
- en: '|  |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Shell tips: history**'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**Shell技巧：历史记录**'
- en: Your shell stores a log of the commands you’ve typed previously. Type `history`
    to view the log; this is often aliased to `h`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 您的shell存储了您之前输入的命令记录。输入`history`来查看记录；这通常被别名`h`。
- en: '|  |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 11.3.3\. Passing stdin as a file
  id: totrans-65
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.3.3\. 将stdin作为文件传递
- en: If a file parameter is given as a hyphen (`-f -`), it means grab the data from
    stdin. This is another common command-line convention. You can use the mississippi
    package to do this easily. You have to concatenate all the data piped to your
    application prior to calling `JSON.parse`, though, because it expects a full JSON
    string to parse. With the mississippi module, the example now looks like the following
    listing.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文件参数以连字符（`-f -`）给出，这意味着从stdin获取数据。这是另一个常见的命令行约定。您可以使用mississippi包轻松完成此操作。但是，在调用`JSON.parse`之前，您必须将所有管道到您的应用程序的数据连接起来，因为它期望一个完整的JSON字符串来解析。使用mississippi模块，示例现在看起来如下所示。
- en: Listing 11.2\. Reading a file from stdin
  id: totrans-67
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表11.2\. 从stdin读取文件
- en: '[PRE4]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This code loads mississippi and calls it `concat`. It then uses `concat` with
    the stdin stream. Because mississippi accepts a function that receives the final
    full set of data, the original `parse` function from [listing 11.1](#ch11ex01)
    can still be used. This is done only when the filename is `-`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码加载mississippi并将其命名为`concat`。然后使用`concat`与stdin流。因为mississippi接受一个接收最终完整数据集的函数，所以原始的[列表11.1](#ch11ex01)中的`parse`函数仍然可以使用。这仅在文件名为`-`时进行。
- en: 11.4\. Sharing command-line tools with npm
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.4\. 使用npm共享命令行工具
- en: Any application that you want others to be able to use should be easily installed
    with npm. The simplest way to make npm see a command-line application is to use
    the `bin` field in package.json. This field makes npm install an executable available
    to any scripts in the current project. The `bin` field also tells npm to install
    the executable globally if you use `npm install --global`. This isn’t useful only
    for Node developers, but also for anyone else who might want to use your scripts.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望他人能够使用的任何应用程序都应该能够通过npm轻松安装。使npm能够识别命令行应用程序的最简单方法是在package.json中使用`bin`字段。此字段使得npm安装的可执行文件对当前项目的任何脚本都可用。如果使用`npm
    install --global`，`bin`字段还会告诉npm全局安装可执行文件。这不仅仅对Node开发者有用，对任何可能想要使用您的脚本的任何人也是如此。
- en: 'This snippet and the `#!/usr/bin/env node` line in [listing 11.2](#ch11ex02)
    are all you need for the JSON parser example in this chapter:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这个片段和[列表11.2](#ch11ex02)中的`#!/usr/bin/env node`行就是本章中JSON解析器示例所需的所有内容：
- en: '[PRE5]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If you install this package with `npm install –global`, it will make the parse-json
    command available systemwide. To try it, open a terminal (or command prompt in
    Windows) and type `parse-json`. Note that this works even in Windows, because
    npm will automatically install a wrapper enabling it to work in Windows transparently.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用`npm install –global`安装此包，它将使parse-json命令在系统范围内可用。要尝试它，打开一个终端（或在Windows中的命令提示符）并输入`parse-json`。请注意，即使在Windows上，这也适用，因为npm会自动安装一个包装器，使其在Windows上透明地工作。
- en: 11.5\. Connecting scripts with pipes
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.5\. 使用管道连接脚本
- en: The parse-json program is simple—it accepts text and validates it. What if you
    have other command-line tools that you want to use it with? Imagine you have a
    program that can add syntax highlighting to JSON files. It would be great if the
    JSON could be parsed first and then highlighted. In this section, you’ll learn
    about pipes, which can do all of this and more.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: parse-json程序很简单——它接受文本并验证它。如果你有其他想要与之一起使用的命令行工具怎么办？想象一下，你有一个程序可以为JSON文件添加语法高亮。如果JSON首先被解析然后高亮显示，那就太好了。在本节中，你将了解管道，它可以做所有这些以及更多。
- en: You’ll be using parse-json and other programs to perform fancy workflows with
    pipes. Windows and Unix shells differ, but the important bits are (luckily) the
    same in both shells. A few differences arise during debugging, but they shouldn’t
    affect you when you’re writing command-line applications.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用parse-json和其他程序通过管道执行复杂的工怍流程。Windows和Unix shell不同，但幸运的是，两者的重要部分是相同的。在调试期间会出现一些差异，但它们不应该影响你编写命令行应用程序时的情况。
- en: 11.5.1\. Piping data into parse-json
  id: totrans-78
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.5.1\. 将数据管道输入到parse-json
- en: 'The main way to connect command-line applications is called *piping*. Piping
    is taking an application’s stdout and attaching it to a different process’s stdin
    stream. It’s the central component of interprocess communication: enabling programs
    to talk to each other. You can access stdin in Node with `process.stdin` because
    it’s a readable stream. Look at the following code to parse JSON coming in from
    stdin:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 连接命令行应用程序的主要方式称为*管道*。管道是将一个应用程序的stdout连接到另一个进程的stdin流。它是进程间通信的核心组件：使程序能够相互通信。你可以在Node中使用`process.stdin`访问stdin，因为它是一个可读流。查看以下代码以解析来自stdin的JSON：
- en: '[PRE6]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Notice the `|` character. This tells the shell that `echo '{}'` should send
    its output to parse-json’s stdin.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到`|`字符。这告诉shell，`echo '{}'`应该将其输出发送到parse-json的stdin。
- en: '|  |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Shell tips: keyboard shortcuts**'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**Shell技巧：键盘快捷键**'
- en: 'Now that you’ve seen how pipes work, you can search the command history by
    combining `history` with `grep`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到了管道的工作方式，你可以通过将`history`与`grep`结合来搜索命令历史：
- en: '[PRE7]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: An even better way to access previous commands is by using the up and down arrows
    on the keyboard. People do this all the time—but there’s an even better way! Type
    Ctrl-R to recursively search through the command history. This lets you fish out
    lengthy commands based on a partial text match.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 访问先前命令的更好方法是使用键盘上的上箭头和下箭头。人们经常这样做——但还有更好的方法！输入Ctrl-R以递归搜索命令历史。这让你可以根据部分文本匹配查找长命令。
- en: 'Here are more shortcuts: Ctrl-S does a forward search, and Ctrl-G aborts the
    search. You can also edit text more efficiently with these shortcuts: Ctrl-W deletes
    words, ALT-F/B moves forward or backward one word, and Ctrl-A/E moves to the start
    or end of the line.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些快捷键：Ctrl-S执行正向搜索，Ctrl-G终止搜索。你还可以使用这些快捷键更有效地编辑文本：Ctrl-W删除单词，ALT-F/B向前或向后移动一个单词，Ctrl-A/E移动到行的开始或结束。
- en: '|  |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 11.5.2\. Working with errors and exit codes
  id: totrans-89
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.5.2\. 与错误和退出码一起工作
- en: Right now the program doesn’t output anything. But if you give it incorrect
    data, how do you know that it was able to complete successfully, even if you don’t
    know the expected output of an executable? The answer is the exit code. You can
    see the exit code of the last command you ran, but note that the `echo` and `node`
    commands are treated as a single command unit because of piping.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 目前程序没有输出任何内容。但如果你给它错误的数据，你怎么知道它能够成功完成，即使你不知道可执行文件的预期输出？答案是退出码。你可以看到你运行的最后一个命令的退出码，但请注意，由于管道，`echo`和`node`命令被视为一个单独的命令单元。
- en: 'On Windows, you can inspect the exit code with the following:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows上，你可以使用以下方法检查退出码：
- en: '[PRE8]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'On UNIX, you can see the exit code by using this command:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在UNIX上，你可以使用以下命令查看退出码：
- en: '[PRE9]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If a command is successful, it has an exit code of 0 (zero). So if you feed
    incorrect JSON to the script, it should exit with a nonzero value:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果命令成功，它有一个退出代码为0（零）。所以如果你向脚本提供错误的JSON，它应该以非零值退出：
- en: '[PRE10]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If you run this, the application will exit with a nonzero status and print a
    message indicating the reason. This is because when an error is thrown but not
    caught, Node automatically exits and prints the error message.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行这个程序，它将以非零状态退出并打印出错误信息，表明原因。这是因为当错误被抛出但未被捕获时，Node会自动退出并打印错误信息。
- en: error streams
  id: totrans-98
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 错误流
- en: 'Although printing your output to the console can be useful, saving it to a
    file to read is even better, because you can keep it for debugging purposes. Luckily,
    you can do this with the shell by redirecting the stdout stream:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然将输出打印到控制台可能很有用，但将其保存到文件以便阅读更好，因为你可以将其保留用于调试目的。幸运的是，你可以通过shell重定向stdout流来实现这一点：
- en: '[PRE11]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'When you try this with invalid JSON, it would make sense for parse-json to
    save the error message:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当你尝试使用无效的JSON时，parse-json保存错误信息是有意义的：
- en: '[PRE12]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'But doing this won’t log any errors. This is the expected behavior once you
    understand the difference between stderr and stdout:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 但这样做不会记录任何错误。一旦你理解了stderr和stdout之间的区别，这将是预期的行为：
- en: stdout is for other command-line applications to consume.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: stdout是供其他命令行应用程序消费的。
- en: stderr is for developers to consume.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: stderr是供开发者消费的。
- en: Node logs to stderr when `console.error` is called or an error is thrown. This
    is different from `echo`, which logs to stdout, just like `console.log`. With
    that knowledge, you may want to redirect stderr to a file instead of to stdout.
    Luckily, that’s a simple change.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用`console.error`或抛出错误时，Node会将日志记录到stderr。这与`echo`不同，`echo`将日志记录到stdout，就像`console.log`一样。有了这些知识，你可能希望将stderr重定向到文件而不是stdout。幸运的是，这是一个简单的更改。
- en: 'The stdin, stdout, and stderr streams all have associated numbers, from 0 to
    2, respectively. stderr has a stream number of 2\. You can redirect it by using
    `2> out.log`, which tells the shell the stream number you want to redirect and
    the file in which to place the output:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: stdin、stdout和stderr流分别与0到2的数字相关联。stderr的流号为2。你可以通过使用`2> out.log`来重定向它，这告诉shell你想要重定向的流号以及放置输出的文件：
- en: '[PRE13]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Redirecting output is what piping does, but with processes instead of files.
    Take the following snippet:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 重定向输出是管道所做的，但使用的是进程而不是文件。以下是一个示例片段：
- en: '[PRE14]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You’re logging `null` and piping it to parse-json. `null` won’t be logged to
    the console here because it’s being piped to only the next command. Say you do
    something similar, but use `console.error`:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 你正在记录`null`并将其通过管道传递给parse-json。在这里，`null`不会被记录到控制台，因为它只被传递到下一个命令。假设你做类似的事情，但使用`console.error`：
- en: '[PRE15]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You’ll see an error because no text is being sent over to parse-json to consume.
    `null` was logged to stderr and will be printed to the console. The *data* should
    be piped to stdout and not stderr.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到一个错误，因为没有文本被发送到parse-json进行消费。`null`被记录到stderr并将打印到控制台。*数据*应该通过stdout而不是stderr进行管道传输。
- en: '[Figure 11.2](#ch11fig02) shows how pipes and numbered output streams can be
    used to connect programs and then route the output into separate files.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '[图11.2](#ch11fig02)展示了如何使用管道和编号输出流来连接程序，然后将输出路由到单独的文件中。'
- en: Figure 11.2\. Combining pipes and output streams
  id: totrans-115
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图11.2. 结合管道和输出流
- en: '![](Images/11fig02.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![图片11fig02](Images/11fig02.jpg)'
- en: Node also has an API for working with pipes. It’s based on Node streams, so
    you can use it with anything that implements Node’s stream classes. Read on to
    learn more about pipes in Node.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Node还有一个用于处理管道的API。它基于Node流，因此你可以用它来处理实现了Node流类的任何东西。继续阅读，了解更多关于Node中管道的信息。
- en: '|  |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Shell tips: clearing a line**'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '**Shell技巧：清除一行**'
- en: Some of these commands are pretty long; what do you do when you need to delete
    a long command and don’t want to run it? One useful shortcut is Ctrl-U, which
    deletes the current line. If you type Ctrl-Y, you’ll get the line back, so you
    can use these keyboard commands as you’d use copy and paste.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一些命令相当长；当你需要删除一个长命令但又不想运行它时，你会怎么做？一个有用的快捷键是Ctrl-U，它可以删除当前行。如果你输入Ctrl-Y，你会得到该行，所以你可以像使用复制和粘贴一样使用这些键盘命令。
- en: '|  |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 11.5.3\. Using pipes in Node
  id: totrans-122
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.5.3. 在Node中使用管道
- en: You’re now going to learn how pipes work by using Node’s API. To do this, you’ll
    write a short script that displays how long it takes a program to run, without
    interrupting piping.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在将通过使用Node的API来学习管道的工作原理。为此，你需要编写一个简短的脚本，显示程序运行所需的时间，而不会中断管道。
- en: 'A program can monitor a pipe without interrupting it by waiting for stdin to
    close and then piping the results to stdout. Because Node programs end when there’s
    no more input to consume, you can print a message when the program is exiting.
    Here’s an example, which you can save as time.js to try it out:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 一个程序可以通过等待stdin关闭然后管道传输结果到stdout来监控管道而不会中断它。因为Node程序在没有更多输入可消费时结束，所以你可以在程序退出时打印一条消息。以下是一个示例，你可以将其保存为time.js来尝试：
- en: '[PRE16]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'By piping to stdout again, you can put time.js in the middle of commands you
    pipe together and still have them work! In fact, both parse-json and time.js can
    easily be used together with pipes. For example, this shows how long it takes
    to parse JSON and send the data:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 通过再次将数据管道传输到stdout，你可以在管道命令的中间放置time.js，并且它们仍然可以正常工作！实际上，parse-json和time.js都可以很容易地与管道一起使用。例如，这显示了解析JSON并发送数据所需的时间：
- en: '[PRE17]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now that you have a basic idea of what to output and how to get input from other
    applications, you can start making applications that are much more complex. But
    first, we should talk about timing while processes are piping to each other.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经对输出内容以及如何从其他应用程序获取输入有了基本的了解，你可以开始制作更复杂的应用程序。但首先，我们应该讨论在进程之间管道传输时的计时问题。
- en: '|  |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Shell tips: completion**'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '**Shell技巧：完成**'
- en: In addition to providing command history, most shells are capable of matching
    commands or files when the Tab key is pressed. Some even allow you to see the
    completions with Alt-?.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 除了提供命令历史记录外，大多数shell在按下Tab键时能够匹配命令或文件。有些甚至允许你使用Alt-?查看完成情况。
- en: '|  |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 11.5.4\. Pipes and command execution order
  id: totrans-133
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.5.4\. 管道和命令执行顺序
- en: When you pipe commands, each command starts immediately. The commands don’t
    wait for each other in any way. This means piping data won’t wait for any command
    to exit, and you can consume only the data it gives you. Because the commands
    don’t wait, you can’t know how the previous command exited.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用管道命令时，每个命令都会立即开始执行。命令之间不会以任何方式等待彼此。这意味着管道传输的数据不会等待任何命令退出，你只能消费它给出的数据。因为命令不会等待，所以你无法知道前一个命令是如何退出的。
- en: Imagine you want to log a message only when JSON is successfully parsed. To
    do this, you need new operators. The `&&` and `||` operators act similarly in
    a shell to the way they do in JavaScript when used on numbers. Using `&&` executes
    the next command if the previous exit code is zero, and `||` executes the next
    command if the exit code is a nonzero number.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你只想在JSON成功解析时记录一条消息。为此，你需要新的运算符。`&&`和`||`运算符在shell中的行为与在JavaScript中使用数字时的行为相似。使用`&&`会在前一个退出代码为零时执行下一个命令，而`||`会在退出代码为非零数时执行下一个命令。
- en: 'Let’s see how to make a little script that logs a message when a process is
    exiting over stderr. It’s important to note that this is different from `echo`,
    because it’s printing to stderr—it’s meant for developers to use rather than other
    programs. All you need to do is listen for the `process` exit event, and then
    write the arguments to stderr:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何编写一个小脚本，当进程通过stderr退出时记录一条消息。重要的是要注意，这与`echo`不同，因为它是在stderr上打印——它是为开发者使用而不是其他程序而设计的。你只需要监听`process`退出事件，然后将参数写入stderr：
- en: '[PRE18]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Using `&&`, you can call exit-message.js if the JSON parsed successfully:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`&&`，如果JSON解析成功，你可以调用exit-message.js：
- en: '[PRE19]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: But exit-message.js won’t get the output of parse-json. The `&&` operator must
    wait for parse-json.js to finish, to see whether it should execute the next command.
    While using `&&`, there’s no automatic redirection as there is when piping.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，exit-message.js不会获取parse-json的输出。`&&`运算符必须等待parse-json.js完成，以确定是否应该执行下一个命令。在使用`&&`时，没有像管道那样自动重定向。
- en: Redirecting input
  id: totrans-141
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 重定向输入
- en: 'You’ve already seen how to redirect output, but you can also redirect input
    in a similar fashion. This is a rare need, but can be a valuable asset if an executable
    doesn’t accept a filename as an argument. If you want a command to read a file
    into stdin, use `<filename` to do so:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了如何重定向输出，但你也可以以类似的方式重定向输入。这虽然是一个罕见的需求，但如果可执行程序不接受文件名作为参数，它可能是一个宝贵的资产。如果你想使命令读取文件到stdin，使用`<filename`来完成：
- en: '[PRE20]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'By combining both forms of redirection, you can use a temporary file to recover
    the output of parse-json:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 通过结合两种重定向形式，你可以使用临时文件来恢复parse-json的输出：
- en: '[PRE21]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now that you’ve learned how to handle streams, exit codes, and command order,
    you should be able to write scripts with Node commands for your own packages.
    The next section demonstrates how to use Browserify and UglifyJS together using
    pipes.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经学会了如何处理流、退出码和命令顺序，你应该能够为你的包编写使用 Node 命令的脚本。下一节将演示如何使用管道结合 Browserify 和
    UglifyJS。
- en: '|  |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Shell tips: clearing the display**'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '**Shell 小贴士：清除显示**'
- en: You may sometimes cat binary data to the terminal and basically break it. Like
    a scene from *The Matrix*, garbled characters will appear everywhere. In cases
    like this, you can either press Ctrl-L to refresh the display or type `reset`
    to reset the terminal.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 你有时可能会将二进制数据发送到终端，并基本上将其破坏。就像《黑客帝国》中的一个场景，乱码字符会出现在各个地方。在这种情况下，你可以按 Ctrl-L 来刷新显示，或者输入
    `reset` 来重置终端。
- en: '|  |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 11.6\. Interpreting real-world scripts
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.6. 解释现实世界的脚本
- en: 'You’re ready to start writing your own `scripts` fields in package.json files.
    As an example, let’s look at how to combine the browserify and uglifyjs packages
    from npm. Browserify ([http://browserify.org/](http://browserify.org/)) is an
    application that takes Node modules and bundles them up for use in the browser.
    UglifyJS ([https://github.com/mishoo/UglifyJS2](https://github.com/mishoo/UglifyJS2))
    is an application that minifies a JavaScript file so that it takes up less bandwidth
    and time to send to a browser. Your script will take a file called main.js (found
    in the book’s listings under ch11-command-line/snippets/uglify-example), concatenate
    it for use in a browser, and then minify the concatenated script:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以开始编写自己的 package.json 文件中的 `scripts` 字段了。作为一个例子，让我们看看如何结合 npm 中的 browserify
    和 uglifyjs 包。Browserify ([http://browserify.org/](http://browserify.org/)) 是一个应用程序，它将
    Node 模块打包起来以便在浏览器中使用。UglifyJS ([https://github.com/mishoo/UglifyJS2](https://github.com/mishoo/UglifyJS2))
    是一个应用程序，它将 JavaScript 文件压缩，以便在发送到浏览器时占用更少的带宽和时间。你的脚本将处理一个名为 main.js 的文件（在本书的 ch11-command-line/snippets/uglify-example
    列表中找到），将其连接起来以便在浏览器中使用，然后压缩连接后的脚本：
- en: '[PRE22]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You can run the build script by typing `npm run build`. The build script in
    this example makes bundle.js. Then, if creating bundle.js is successful, the script
    creates bundle.min.js. By using the `&&` operator, you can ensure that the second
    stage runs only if the first stage succeeds.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过输入 `npm run build` 来运行构建脚本。本例中的构建脚本会生成 bundle.js。然后，如果创建 bundle.js 成功，脚本会创建
    bundle.min.js。通过使用 `&&` 操作符，你可以确保只有在第一阶段成功的情况下，第二阶段才会运行。
- en: Using the techniques demonstrated in this chapter, you can create and use command-line
    applications. Remember, you can always use the command lines to combine scripts
    from other languages together—if you have a useful Python, Ruby, or Haskell command-line
    program, you can easily use it with your Node programs.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 使用本章中展示的技术，你可以创建和使用命令行应用程序。记住，你总是可以使用命令行将其他语言的脚本组合在一起——如果你有一个有用的 Python、Ruby
    或 Haskell 命令行程序，你可以轻松地与你的 Node 程序一起使用。
- en: 11.7\. Summary
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.7. 摘要
- en: Command-line arguments can be read from process.argv.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令行参数可以从 process.argv 中读取。
- en: Modules such as yargs make it easier to parse and validate arguments.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如 yargs 这样的模块使得解析和验证参数变得更加容易。
- en: A handy way to add scripts to your Node projects is by defining npm scripts
    in the package.json file.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 package.json 文件中定义 npm 脚本是一种方便地将脚本添加到你的 Node 项目的快捷方式。
- en: Data is read and written to command-line programs by using standard I/O pipes.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用标准 I/O 管道，数据被读取和写入到命令行程序中。
- en: Standard input, output, and errors can be redirected to different processes
    and files.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准输入、输出和错误可以被重定向到不同的进程和文件。
- en: Programs emit exit codes that are used to determine whether they ran successfully.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 程序会发出退出码，用于确定它们是否成功运行。
- en: Command-line programs adhere to established conventions that other users will
    expect.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令行程序遵循其他用户期望的既定惯例。
- en: Chapter 12\. Conquering the desktop with Electron
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 12 章. 使用 Electron 征服桌面
- en: '*This chapter covers*'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Building desktop apps with Electron
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Electron 构建桌面应用程序
- en: Showing desktop menus
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示桌面菜单
- en: Sending desktop notifications
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送桌面通知
- en: Creating cross-platform builds
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建跨平台构建
- en: 'In the preceding chapter, you learned about building command-line tools with
    Node. Node is starting to become prominent in another area, however: desktop software.
    Programmers are increasingly harnessing web technology to solve the problems of
    cross-platform development. In this chapter, you’ll learn how to make a desktop
    web application based on native desktop features, Node, and client-side web technology.
    You can develop and run this application in Linux, macOS, and Windows. You’ll
    also use Node modules in a model that isn’t too far removed from client-server
    web application development.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，您学习了如何使用Node构建命令行工具。然而，Node正在开始成为另一个领域的突出人物：桌面软件。程序员越来越多地利用网络技术来解决跨平台开发的问题。在本章中，您将学习如何基于原生桌面功能、Node和客户端网络技术制作桌面网络应用程序。您可以在Linux、macOS和Windows上开发和运行此应用程序。您还将使用与客户端-服务器网络应用程序开发不太脱离的模型中的Node模块。
- en: 12.1\. Introducing Electron
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.1. 介绍电子
- en: '*Electron*, originally known as Atom Shell, enables you to build desktop applications
    with web technology. The application and user interface are left up to you to
    create with HTML, CSS, and JavaScript, but some of the “hard parts” of desktop
    software are provided for you. These include the following:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '*电子*，最初被称为原子壳，允许您使用网络技术构建桌面应用程序。应用程序和用户界面由您使用HTML、CSS和JavaScript创建，但一些桌面软件的“难点”已经为您提供了。以下是一些包括的内容：'
- en: Automatic updates
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动更新
- en: Crash reporting
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 崩溃报告
- en: Installers for Microsoft Windows
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微软Windows安装程序
- en: Debugging
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试
- en: Native menus and notifications
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原生菜单和通知
- en: Some famous applications have been made with Electron. The first was Atom, GitHub’s
    text editor, but more recent applications include Slack, the popular chat service,
    and Visual Studio Code by Microsoft, shown in [figure 12.1](#ch12fig01).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 一些著名的应用程序是用电子制作的。第一个是Atom，GitHub的文本编辑器，但更近期的应用程序包括流行的聊天服务Slack和微软的Visual Studio
    Code，如图12.1所示。[figure 12.1](#ch12fig01)。
- en: Figure 12.1\. Visual Studio Code’s application window and a native context menu
  id: totrans-179
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图12.1. Visual Studio Code的应用程序窗口和原生上下文菜单
- en: '![](Images/12fig01_alt.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/12fig01_alt.jpg)'
- en: You should try out some of these applications to see the kinds of things that
    are possible with Electron. It’s exciting to think that armed with Node and JavaScript
    skills, you can build compelling desktop software.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该尝试一些这些应用程序，看看使用电子可以实现哪些类型的事情。想到有了Node和JavaScript技能，您可以构建引人注目的桌面软件，这令人兴奋。
- en: 12.1.1\. Electron’s stack
  id: totrans-182
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.1.1. 电子的堆栈
- en: 'Before getting started with Electron, you should familiarize yourself with
    the way Electron fits in with Node, HTML, and CSS. An Electron app has the following
    components:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始使用电子之前，您应该熟悉电子如何与Node、HTML和CSS结合。一个电子应用程序具有以下组件：
- en: '***The main process—*** A Node script that boots the application and provides
    access to native Node modules'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***主进程——*** 启动应用程序并提供对原生Node模块的访问的Node脚本'
- en: '***The render process—*** A web page managed by Chromium'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***渲染进程——*** 由Chromium管理的网页'
- en: 'A real application, however, has several other dependencies. The previous list
    can be fleshed out as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一个真实的应用程序还有几个其他的依赖。前面的列表可以扩展如下：
- en: Includes the main process
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包括主进程
- en: Connects to a native database (for example, SQLite)
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接到原生数据库（例如，SQLite）
- en: Communicates with web APIs
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与Web API通信
- en: Reads and writes any local files (for example, configuration files)
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取和写入任何本地文件（例如，配置文件）
- en: Provides access to native features (for example, context menus)
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供对原生功能的访问（例如，上下文菜单）
- en: Includes the render process
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包括渲染进程
- en: Shows a modern rich web application using your preferred client-side technology
    (for example, React or Angular)
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示使用您首选的客户端技术（例如，React或Angular）的现代丰富网络应用程序
- en: Triggers native features (for example, context menus and notifications)
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 触发原生功能（例如，上下文菜单和通知）
- en: Provides build scripts
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供构建脚本
- en: Generates the front-end JavaScript by using your preferred build system (Grunt,
    Gulp, npm scripts)
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用您首选的构建系统（Grunt、Gulp、npm脚本）生成前端JavaScript
- en: Prepares releases for distribution
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 准备分发版本
- en: '[Figure 12.2](#ch12fig02) shows an overview of the three main parts of a typical
    Electron app. As you can see, Node is used to run the main process and to communicate
    with the operating system for services including opening files, reading and writing
    to a database, and communicating with web services. Although a large part of the
    focus is on the UI in the rendering process, Node is still used for a critical
    part of the application’s architecture.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 12.2](#ch12fig02) 展示了典型 Electron 应用程序三个主要部分的概述。正如你所见，Node 用于运行主进程并与操作系统通信，包括打开文件、读写数据库以及与网络服务通信。尽管渲染过程中的大部分重点都在
    UI 上，但 Node 仍然用于应用程序架构的关键部分。'
- en: Figure 12.2\. The main parts of a typical Electron application
  id: totrans-199
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 12.2。典型 Electron 应用程序的主要部分
- en: '![](Images/12fig02.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/12fig02.jpg)'
- en: 12.1.2\. Interface design
  id: totrans-201
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.1.2。界面设计
- en: Now that you’ve seen the main components of an Electron app, let’s look at how
    to design suitable interfaces. Electron applications are based on HTML, CSS, and
    Java-Script, so you can’t pull in native widgets. Imagine that you want to make
    a native Mac-style interface. You can fake the macOS toolbar by using CSS gradients.
    Using native fonts provided by macOS and Windows is possible through CSS, and
    you can even tweak the antialiasing to look like a native application. You can
    also remove text selection for certain UI components, and make the UI work with
    drag-and-drop. Currently, most Electron apps use CSS that uses the same colors,
    border styles, icons, and gradients as macOS and Windows.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到了 Electron 应用程序的主要组件，让我们来看看如何设计合适的界面。Electron 应用程序基于 HTML、CSS 和 Java-Script，因此你不能引入原生小部件。想象一下，你想要制作一个类似
    Mac 风格的原生界面。你可以通过使用 CSS 渐变来伪造 macOS 工具栏。通过 CSS 可以使用 macOS 和 Windows 提供的原生字体，你甚至可以调整抗锯齿效果，使其看起来像原生应用程序。你也可以为某些
    UI 组件移除文本选择，并使 UI 支持拖放。目前，大多数 Electron 应用程序使用的 CSS 与 macOS 和 Windows 的颜色、边框样式、图标和渐变相同。
- en: Some applications go the extra mile in terms of duplicating the native experience;
    one example is the N1 email application ([https://github.com/nylas/N1](https://github.com/nylas/N1)).
    Other applications, such as Slack ([https://slack.com/](https://slack.com/)),
    have their own unique branding and identity that’s clean enough to work well without
    too much modification on each platform.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 一些应用程序在复制原生体验方面做得更多；一个例子是 N1 邮件应用程序（[https://github.com/nylas/N1](https://github.com/nylas/N1)）。其他应用程序，如
    Slack（[https://slack.com/](https://slack.com/)），有自己的独特品牌和身份，足够干净，无需太多修改就能在各个平台上良好工作。
- en: When you build your own Electron apps, you’ll have to decide which approach
    is right for your project. If you want to make an app that looks like it uses
    native desktop widgets, you have to create styles that suit each platform. That
    requires more time designing each target UI. Your customers may prefer it, but
    it may also result in more overhead when deploying new features.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 当你构建自己的 Electron 应用程序时，你必须决定哪种方法适合你的项目。如果你想制作一个看起来像使用原生桌面小部件的应用程序，你必须创建适合每个平台的样式。这需要更多的时间来设计每个目标
    UI。你的客户可能更喜欢它，但这也可能导致在部署新功能时产生更多开销。
- en: In the next section, you’ll use a skeleton Electron application to create a
    new one. This is the standard way to build new projects with Electron.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将使用 Electron 应用程序的骨架来创建一个新的应用程序。这是使用 Electron 构建新项目的标准方式。
- en: 12.2\. Creating an Electron app
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.2。创建 Electron 应用程序
- en: The easiest way to get started with Electron is to use the electron-quick-start
    project, available on GitHub ([https://github.com/atom/electron-quick-start](https://github.com/atom/electron-quick-start)).
    This small repository contains the dependencies necessary to run a basic Electron
    application.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用 Electron，最简单的方法是使用 GitHub 上的 electron-quick-start 项目（[https://github.com/atom/electron-quick-start](https://github.com/atom/electron-quick-start)）。这个小型仓库包含了运行基本
    Electron 应用程序所需的依赖项。
- en: 'To use it, check out the repository and install the dependencies with npm:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用它，请检出仓库并使用 npm 安装依赖项：
- en: '[PRE23]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: After everything has finished downloading, you can start the main process with
    `npm start`. It’s safe to use this project as the basis for the rest of your Electron
    application; you shouldn’t need to create your own project from scratch.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 下载完成后，你可以使用 `npm start` 启动主进程。将此项目作为你其余 Electron 应用程序的基础是安全的；你不需要从头创建自己的项目。
- en: 'When the application starts, you should see a window with a web page and the
    Chromium Developer Tools. If you’re a web developer who uses Chrome, this might
    not seem that exciting: the app looks like a web page with no CSS rendering in
    Chrome. But a lot more is going on under the hood to make this work. [Figure 12.3](#ch12fig03)
    shows what this looks like in macOS.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序启动时，你应该会看到一个包含网页和 Chromium 开发者工具的窗口。如果你是一个使用 Chrome 的网页开发者，这可能不会显得那么令人兴奋：应用程序看起来像是一个没有
    CSS 渲染的网页。但在幕后还有很多工作要做，才能使这一切工作。![图 12.3](#ch12fig03) 展示了它在 macOS 中的样子。
- en: Figure 12.3\. The electron-quick-start project running in macOS
  id: totrans-212
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 12.3\. 在 macOS 中运行的 electron-quick-start 项目
- en: '![](Images/12fig03_alt.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![图片 12.3](Images/12fig03_alt.jpg)'
- en: 'This is a self-contained macOS application bundle: it includes a version of
    Node that’s different from the one running on my system, and it has its own menu
    items and About window.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个自包含的 macOS 应用程序包：它包含了一个与我的系统上运行的不同的 Node 版本，并且有自己的菜单项和关于窗口。
- en: At this point, you can start to build your web application in index.html by
    using HTML, JavaScript, and CSS. But as a Node programmer, you’re probably eager
    to use Node for something, so let’s see how to do that first.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你可以通过使用 HTML、JavaScript 和 CSS 在 index.html 中开始构建你的 web 应用程序。但作为一个 Node
    程序员，你可能渴望使用 Node 做些事情，所以让我们先看看如何做到这一点。
- en: Electron comes with a module called *remote* that uses interprocess communication
    (IPC) between the rendering process and the main Node process. The remote module
    can even provide access to Node modules. To try it, add a file called readfile.js
    to your Electron project, and add the code in the following listing.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: Electron 内置了一个名为 *remote* 的模块，该模块通过进程间通信（IPC）在渲染进程和主 Node 进程之间进行通信。远程模块甚至可以提供对
    Node 模块的访问。要尝试它，请将一个名为 readfile.js 的文件添加到您的 Electron 项目中，并在以下列表中添加代码。
- en: Listing 12.1\. A simple Node module
  id: totrans-217
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.1\. 一个简单的 Node 模块
- en: '[PRE24]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Now open index.html and change it to add an element with an ID of `source`,
    and a script that loads readfile.js, as shown in the next listing.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开 index.html 并将其修改为添加一个具有 ID `source` 的元素，以及一个加载 readfile.js 的脚本，如以下列表所示。
- en: Listing 12.2\. Loading Node modules from the rendering process
  id: totrans-220
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.2\. 从渲染进程加载 Node 模块
- en: '[PRE25]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[Listing 12.2](#ch12ex02) uses the remote module to load readfile.js and then
    run it on the main process. The interaction between the two processes is seamless,
    so it doesn’t seem that much different from using standard Node modules. The only
    real difference is the use of `require(''remote'').require(file)`.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 12.2](#ch12ex02) 使用远程模块加载 readfile.js 并在主进程中运行它。两个进程之间的交互无缝，所以它看起来与使用标准
    Node 模块并没有太大的不同。唯一的真正区别是使用了 `require(''remote'').require(file)`。'
- en: 12.3\. Building a full desktop application
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.3\. 构建完整的桌面应用程序
- en: Now that you’ve seen how to create a basic Electron app and how to use Node
    modules, let’s go a step further and see how to build a fully fledged desktop
    app with native features. The application you’ll create is intended to be a developer
    tool for making and viewing HTTP requests. Think of it as a GUI for the request
    module ([www.npmjs.com/package/request](http://www.npmjs.com/package/request)).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到了如何创建一个基本的 Electron 应用程序以及如何使用 Node 模块，让我们更进一步，看看如何构建一个具有原生功能的完整桌面应用程序。你将创建的应用程序旨在成为一个用于制作和查看
    HTTP 请求的开发者工具。把它想象成请求模块的 GUI ([www.npmjs.com/package/request](http://www.npmjs.com/package/request))。
- en: 'Although you can build Electron apps with pure HTML, JavaScript, CSS, and Node,
    for this example you’ll use modern front-end development tools to make the app
    more maintainable and extensible. Here’s a list of what you’ll use:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以使用纯 HTML、JavaScript、CSS 和 Node 构建 Electron 应用程序，但在这个例子中，你将使用现代前端开发工具来使应用程序更易于维护和扩展。以下是你将使用的内容列表：
- en: electron-quick-start as the basis for the project
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以 electron-quick-start 作为项目的基础
- en: request module for making HTTP requests
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求模块用于发送 HTTP 请求
- en: React for the user-interface code
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于用户界面代码的 React
- en: Babel for converting modern ES6 into browser-friendly ES5
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Babel 用于将现代 ES6 转换为浏览器友好的 ES5
- en: webpack for building the client-side app
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: webpack 用于构建客户端应用程序
- en: '[Figure 12.4](#ch12fig04) shows what the finished application should look like.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 12.4](#ch12fig04) 展示了完成的应用程序应该看起来是什么样子。'
- en: Figure 12.4\. The HTTP Master Electron application
  id: totrans-232
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 12.4\. HTTP Master Electron 应用程序
- en: '![](Images/12fig04_alt.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![图片 12.4](Images/12fig04_alt.jpg)'
- en: Next you’ll learn how to set up a React-based project with webpack and Babel.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将学习如何使用 webpack 和 Babel 设置基于 React 的项目。
- en: 12.3.1\. Bootstrapping React and Babel
  id: totrans-235
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.3.1\. 引入 React 和 Babel
- en: The biggest challenge in building a new app with a sophisticated front end is
    setting up libraries such as React and Babel with a maintainable build system.
    You have many choices, including Grunt, Gulp, and webpack. And what makes things
    even more difficult is that these libraries change over time, so books and tutorials
    quickly become out-of-date.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用复杂的前端构建新应用时，最大的挑战是设置如 React 和 Babel 这样的库，并构建一个可维护的构建系统。你有许多选择，包括 Grunt、Gulp
    和 webpack。而且，使事情更加困难的是，这些库会随时间变化，因此书籍和教程很快就会过时。
- en: To mitigate the fast-paced world of front-end development, we specify the exact
    versions of each dependency, so you should be able to follow the tutorial and
    obtain similar results. If you get lost, you can use tools such as Yeoman ([http://yeoman.io/](http://yeoman.io/))
    to generate a skeleton app. Then you can modify it to work like the app outlined
    in this chapter.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 为了缓解前端开发的快节奏世界，我们指定了每个依赖的确切版本，因此你应该能够遵循教程并获得类似的结果。如果你迷失了方向，可以使用如 Yeoman ([http://yeoman.io/](http://yeoman.io/))
    这样的工具生成骨架应用。然后你可以修改它，使其像本章概述的应用一样工作。
- en: 12.3.2\. Installing the dependencies
  id: totrans-238
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.3.2\. 安装依赖
- en: 'Create a new electron-quick-start project. To recap, you must clone the project
    from GitHub:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的 electron-quick-start 项目。为了回顾，你必须从 GitHub 克隆项目：
- en: '[PRE26]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now install react, react-dom, and babel-core:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 现在安装 react、react-dom 和 babel-core：
- en: '[PRE27]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Next, you need to install Babel plugins. The main one is babel-preset-es2015,
    which may be overkill for a project limited to Chromium, but including it makes
    it easier for you to experiment with ES2015 features that Chromium doesn’t yet
    support. Use these commands for installation:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要安装 Babel 插件。主要的一个是 babel-preset-es2015，对于一个仅限于 Chromium 的项目来说可能有些过度，但包括它会使你更容易实验
    Chromium 尚不支持 ES2015 特性。使用以下命令进行安装：
- en: '[PRE28]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This plugin adds JSX support to Babel:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 此插件为 Babel 添加 JSX 支持：
- en: '[PRE29]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then install webpack:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 然后安装 webpack：
- en: '[PRE30]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'You also need babel-loader for webpack to work with Babel:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要为 webpack 使用 babel-loader：
- en: '[PRE31]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now that most of the dependencies are ready, add a .babelrc file to your project.
    It tells Babel to use the ES2015 and React plugins:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 现在大多数依赖项都已准备就绪，向你的项目中添加一个 .babelrc 文件。它告诉 Babel 使用 ES2015 和 React 插件：
- en: '[PRE32]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Finally, open package.json and update the `scripts` property to include a webpack
    invocation:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，打开 package.json 并更新 `scripts` 属性以包含 webpack 调用：
- en: '[PRE33]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This allows the application to be built with `npm run build`. Webpack plugins
    are available for React hot-loading, but we don’t cover that here. If you want
    to automatically build your client-side code when files change, you could use
    something like fswatch or nodemon.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许应用程序通过 `npm run build` 构建。Webpack 插件可用于 React 热加载，但这里我们不涉及。如果你想在文件更改时自动构建客户端代码，可以使用
    fswatch 或 nodemon 等工具。
- en: 12.3.3\. Setting up webpack
  id: totrans-256
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.3.3\. 设置 webpack
- en: 'To use webpack, you need a webpack.config.js file. Add it to the root of your
    project. The basic format is JavaScript, using a Node-style CommonJS module:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 webpack，你需要一个 webpack.config.js 文件。将其添加到项目的根目录。基本格式是 JavaScript，使用 Node-style
    CommonJS 模块：
- en: '[PRE34]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Our project requires settings for finding React files (.jsx), loading the entry
    point (/app/index.jsx), and then placing the output in a place where the Electron
    UI can find it (js/app.js). The React files also have to be processed with Babel.
    Putting those requirements together produces the file in the following listing.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的项目需要设置以查找 React 文件 (.jsx)，加载入口点 (/app/index.jsx)，然后将输出放置在 Electron UI 可以找到的地方（js/app.js）。React
    文件也必须通过 Babel 处理。将这些要求结合起来，产生以下列表中的文件。
- en: Listing 12.3\. webpack.config.js
  id: totrans-260
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.3\. webpack.config.js
- en: '[PRE35]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In this listing, webpack is told to transform .jsx (React) files with Babel
    through the `module.loaders` property. Babel has already been set up to handle
    React files with transform-react-jsx in .babelrc. Next, the `entry` property is
    used to define the main entry point for the React code. This works well because
    React components are based on HTML elements. Because HTML elements must have one
    parent node, a single entry point can encompass the entire application.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在此列表中，webpack 通过 `module.loaders` 属性告诉 Babel 使用 Babel 转换 .jsx（React）文件。Babel
    已经在 .babelrc 中设置好，以处理 React 文件。接下来，使用 `entry` 属性定义 React 代码的主要入口点。这很有效，因为 React
    组件基于 HTML 元素。因为 HTML 元素必须有一个父节点，一个单独的入口点可以涵盖整个应用程序。
- en: The `resolve.extensions` property tells webpack that .jsx files must be treated
    as modules. If you use a statement such as `import {Class} from 'class'`, it’ll
    check class.js and class.jsx.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '`resolve.extensions` 属性告诉 webpack .jsx 文件必须被视为模块。如果你使用 `import {Class} from
    ''class''` 这样的语句，它将检查 class.js 和 class.jsx。'
- en: Finally, the `output` property tells webpack where to write the output file.
    Here I’ve used js/, but you could use any path that’s accessible to the Electron
    UI.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`output` 属性告诉 webpack 将输出文件写入何处。这里我使用了 js/，但你可以使用任何对 Electron UI 可访问的路径。
- en: This is a good time to start fleshing out the React app. Let’s start by looking
    at the main entry point and how it’ll pull in the request and response UI elements.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是开始充实 React 应用程序的好时机。让我们先看看主入口点以及它如何引入请求和响应 UI 元素。
- en: 12.4\. The React app
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.4. React 应用程序
- en: 'In [figure 12.4](#ch12fig04), you saw a preview of what this app should look
    like. It has two main groups of UI components that can be divided into seven items:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [图 12.4](#ch12fig04) 中，你看到了这个应用程序的预览。它有两个主要的 UI 组件组，可以分成七个项目：
- en: Request
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求
- en: 'URL: String'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: URL：字符串
- en: 'Method: String'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法：字符串
- en: 'Headers: Object of string pairs'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 头部：字符串对的集合
- en: Response
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应
- en: HTTP status code
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP 状态码
- en: 'Headers: Object of string pairs'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 头部：字符串对的集合
- en: 'Body: String'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主体：字符串
- en: 'Errors: String'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误：字符串
- en: 'But in React, you can’t render two things side by side: they need to be contained
    by a single parent. You need a top-level app object, which contains the UI elements
    for the request and response.'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 但在 React 中，你不能并排渲染两个东西：它们需要被单个父级包含。你需要一个顶级应用对象，它包含请求和响应的 UI 元素。
- en: Given classes for `Request` and `Response`, which you’ll implement later, the
    `App` class itself should look like the following listing.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 给定 `Request` 和 `Response` 类（你将在稍后实现），`App` 类本身应如下所示。
- en: Listing 12.4\. The `App` class
  id: totrans-279
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.4. `App` 类
- en: '[PRE36]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Save this file as app/index.jsx. It first loads the `Request` and `Response`
    classes, and then renders them in a div. The last line uses ReactDOM to render
    the DOM nodes for the `App` class. React allows you to refer to the `App` class
    with `<App />`.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 将此文件保存为 app/index.jsx。它首先加载 `Request` 和 `Response` 类，然后在 div 中渲染它们。最后一行使用 ReactDOM
    渲染 `App` 类的 DOM 节点。React 允许你使用 `<App />` 引用 `App` 类。
- en: To make this work, you also need to define the `Request` and `Response` components.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 要使这生效，你还需要定义 `Request` 和 `Response` 组件。
- en: 12.4.1\. Defining the Request component
  id: totrans-283
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.4.1. 定义请求组件
- en: The `Request` class takes input for the URL and HTTP method, and then generates
    a request that’s posted with the Node request module. It renders the interface
    by using JSX, but unlike the previous example, it doesn’t render the element directly
    with ReactDOM; this happens when it’s included into the main app class in app/index.jsx.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '`Request` 类接受 URL 和 HTTP 方法的输入，然后使用 Node 请求模块生成一个请求。它通过 JSX 渲染界面，但与上一个示例不同，它不是直接使用
    ReactDOM 渲染元素；这是在 app/index.jsx 中的主应用类中包含时发生的。'
- en: The following listing (app/request.js) contains the code for the full class.
    We’ve removed the header-editing capability to reduce the length of the example;
    for an example with more features, including header editing, see our HTTP Wizard
    GitHub repository ([https://github.com/alexyoung/http-wizard](https://github.com/alexyoung/http-wizard)).
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表（app/request.js）包含了完整类的代码。我们已删除编辑标题的功能以缩短示例的长度；对于包含标题编辑等更多功能的示例，请参阅我们的 HTTP
    Wizard GitHub 仓库 ([https://github.com/alexyoung/http-wizard](https://github.com/alexyoung/http-wizard))。
- en: Listing 12.5\. The `Request` class
  id: totrans-286
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.5. `Request` 类
- en: '[PRE37]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The bulk of the listing is taken up by the `render` method’s HTML. Let’s focus
    on the rest before going over how the UI is built up. First, we’ve used a descendent
    of Node’s `EventEmitter` in app/events.jsx to communicate between this component
    and the response component. The following snippet is app/events.jsx:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 列表的大部分内容由 `render` 方法的 HTML 组成。在介绍如何构建 UI 之前，让我们先关注其余部分。首先，我们在 app/events.jsx
    中使用 Node 的 `EventEmitter` 的子类来在组件之间进行通信。以下片段是 app/events.jsx：
- en: '[PRE38]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Notice that `Request` is a `React.Component` descendant class. It defines a
    constructor that sets up a default state: the `state` property is special in React
    and can be set this way only in a constructor. Elsewhere, you must use `this.setState`.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`Request` 是 `React.Component` 的子类。它定义了一个构造函数，用于设置默认状态：`state` 属性在 React 中是特殊的，只能在构造函数中这样设置。在其他地方，你必须使用
    `this.setState`。
- en: 'The `handleChange` method sets state based on the HTML element’s `name` attribute.
    To understand how this works, skip ahead to the URL `<input>` element in the `render`
    method:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '`handleChange` 方法根据 HTML 元素的 `name` 属性设置状态。要了解这是如何工作的，请跳转到 `render` 方法中的 URL
    `<input>` 元素：'
- en: '[PRE39]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The name specified here is used to set the URL when it’s edited. Setting the
    state also causes `render` to run, and React will update the value attribute with
    the updated state. Let’s move on to look at how the request module is used by
    this class.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这里指定的名称用于在编辑时设置 URL。设置状态也会导致 `render` 运行，React 将更新值属性以反映更新的状态。让我们继续看看这个类是如何使用请求模块的。
- en: 'This class is client-side code that runs in a web view, so you need a way of
    accessing the request module to make HTTP requests. Electron provides a way of
    loading remote modules without any unnecessary boilerplate. Near the top of the
    class, you use the global `remote` object to require the Node request module:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类是运行在网页中的客户端代码，所以你需要一种方法来访问请求模块以发起 HTTP 请求。Electron 提供了一种方法来加载远程模块，而不需要任何不必要的样板代码。在类的顶部附近，你使用全局
    `remote` 对象来引入 Node 请求模块：
- en: '[PRE40]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Then later in `makeRequest`, the HTTP request can be made with a simple call
    to `request()`. The arguments for the request have been set in the class’s state,
    so all you need to do is handle the callback that runs when the request is complete.
    Here that’s very little imperative code: the class’s state is set based on the
    outcome of the request, and then the result is emitted so the `Response` component
    can use it. A desktop notification is also displayed; if the request is slow,
    the user will be notified visually by using the operating system’s notification
    pop-up:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在 `makeRequest` 中，可以通过简单的 `request()` 调用来发起 HTTP 请求。请求的参数已经在类的状态中设置，所以你只需要处理请求完成时运行的回调。在这里，这非常少的命令式代码：类的状态基于请求的结果设置，然后结果被发射出来，以便
    `Response` 组件可以使用它。还会显示桌面通知；如果请求缓慢，用户将通过操作系统通知弹出窗口进行视觉通知：
- en: '[PRE41]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[Figure 12.5](#ch12fig05) shows a typical notification.'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 12.5](#ch12fig05) 展示了一个典型的通知。'
- en: Figure 12.5\. A desktop notification
  id: totrans-299
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 12.5\. 桌面通知
- en: '![](Images/12fig05_alt.jpg)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![Images/12fig05_alt.jpg]'
- en: Now let’s look at how the `Response` component displays the HTTP response.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看 `Response` 组件是如何显示 HTTP 响应的。
- en: 12.4.2\. Defining the Response component
  id: totrans-302
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.4.2\. 定义响应组件
- en: The `Response` component listens for `result` events and then sets its state
    to contain the results of the last request. It displays the results by using a
    table for headers, and divs for the request body and any errors.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '`Response` 组件监听 `result` 事件，然后将其状态设置为包含上次请求的结果。它通过使用表格显示标题，div 显示请求正文和任何错误来显示结果。'
- en: The following listing has the whole `Response` component. This file is app/response.jsx.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了整个 `Response` 组件。此文件位于 app/response.jsx。
- en: Listing 12.6\. The `Response` component
  id: totrans-305
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.6\. `Response` 组件
- en: '[PRE42]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The `Response` component doesn’t have any code specific to handling HTTP responses;
    it displays its state in various HTML elements. It’s able to switch tabs by binding
    an `onclick` event to the `handleSelectTab` method that switches between the body
    and errors by using an attribute (`data-tab`).
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '`Response` 组件没有处理 HTTP 响应的特定代码；它通过各种 HTML 元素显示其状态。它能够通过绑定一个 `onclick` 事件到 `handleSelectTab`
    方法来切换标签页，该方法通过使用属性 (`data-tab`) 在正文和错误之间切换。'
- en: 'The `Response` component uses another component, `Headers`, to render the HTTP
    response headers. Breaking components into ever smaller components is standard
    practice in React. The values of each header are passed to the subcomponent by
    using an attribute; in React, these are known as *props*, or *properties*:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '`Response` 组件使用另一个组件 `Headers` 来渲染 HTTP 响应头。将组件分解成越来越小的组件是 React 中的标准做法。每个头的值通过属性传递给子组件；在
    React 中，这些被称为 *props* 或 *属性*：'
- en: '[PRE43]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The following listing shows the `Headers` component. This is in the app/headers.jsx
    file.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了 `Headers` 组件。此文件位于 app/headers.jsx。
- en: Listing 12.7\. The `Headers` component
  id: totrans-311
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.7\. `Headers` 组件
- en: '[PRE44]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Notice how the props are accessed near the top of the `render()` method, at
    `this.props.headers`.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在 `render()` 方法的顶部附近是如何访问 props 的，在 `this.props.headers`。
- en: 12.4.3\. Communicating between React components
  id: totrans-314
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.4.3\. React 组件之间的通信
- en: The `Request` and `Response` classes are fairly well isolated; they’re focused
    on solving their particular tasks without directly calling each other. React has
    other, more sophisticated state-management approaches, but they’re beyond the
    scope of this chapter. This example application doesn’t need a sophisticated communication
    mechanism, because it has only two main components, so instead it uses `EventEmitter`
    from Node to communicate.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '`Request`和`Response`类相当隔离；它们专注于解决特定的任务，而不直接相互调用。React有其他更复杂的状态管理方法，但它们超出了本章的范围。这个示例应用程序不需要复杂通信机制，因为它只有两个主要组件，所以它使用Node的`EventEmitter`来通信。'
- en: 'To use `EventEmitter` this way, instantiate it inside its own file and then
    export the instance. This file is app/events.jsx in the example project for this
    chapter:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 要以这种方式使用`EventEmitter`，在它自己的文件中实例化它，然后导出实例。这个文件是本章示例项目中的app/events.jsx：
- en: '[PRE45]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now components can require `events` and either emit events or attach listeners
    to communicate. The `Request` component does this in the `makeRequest` method,
    with the result of the HTTP request:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 现在组件可以要求`events`并发出事件或附加监听器来通信。`Request`组件在`makeRequest`方法中这样做，使用HTTP请求的结果：
- en: '[PRE46]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Then in the `Response` class, you can capture results by setting up a listener
    early in the component’s life cycle:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在`Response`类中，你可以在组件的生命周期早期设置一个监听器来捕获结果：
- en: '[PRE47]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: As an application grows, this pattern becomes harder to maintain. One particular
    problem is tracking the names of events. Because they’re strings, it’s easy to
    forget them or write them incorrectly. An extension of this pattern is to use
    a list of constants for event names. If you extend this pattern again to split
    the responsibility of dispatching events and storing data, you end up with something
    similar to Facebook’s Redux state container ([http://redux.js.org/](http://redux.js.org/)),
    which is why many React programmers use it to design and build larger applications.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 随着应用程序的增长，这种模式变得越来越难以维护。一个特别的问题是跟踪事件名称。因为它们是字符串，所以很容易忘记它们或写错。这种模式的扩展是使用事件名称的常量列表。如果你再次扩展这种模式以分割分发事件和存储数据的责任，你最终会得到类似于Facebook的Redux状态容器([http://redux.js.org/](http://redux.js.org/))的东西，这就是为什么许多React程序员使用它来设计和构建大型应用程序的原因。
- en: 12.5\. Builds and distribution
  id: totrans-323
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.5. 构建和分发
- en: 'Now that you have a usable desktop application, you can bundle it for macOS,
    Linux, and Windows. App distribution with Electron has three stages:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经有一个可用的桌面应用程序，你可以将其捆绑成macOS、Linux和Windows版本。使用Electron进行应用分发有三个阶段：
- en: Rebrand the Electron app with your application’s name and icon
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Electron应用重命名为你的应用程序名称和图标
- en: Package your app into a file
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的应用程序打包成一个文件
- en: Create a binary for each platform
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为每个平台创建一个二进制文件
- en: The electron-quick-start project is already almost suitable for distribution.
    You just need to copy your code into Electron’s Contents/Resources/app folder
    in macOS, or electron/resources/app in Windows and Linux.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 电子快速入门项目已经几乎适合分发。你只需将你的代码复制到macOS中的Electron的Contents/Resources/app文件夹，或在Windows和Linux中的electron/resources/app。
- en: But manually copying files isn’t the best way to build a redistributable binary.
    A more foolproof method is to use electron-packager ([www.npmjs.com/package/electron-packager](http://www.npmjs.com/package/electron-packager))
    by Max Ogden. This package provides a command-line tool for building executables
    for Windows, Linux, and macOS.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 但手动复制文件并不是构建可分发二进制文件的最佳方式。一个更可靠的方法是使用Max Ogden的electron-packager ([www.npmjs.com/package/electron-packager](http://www.npmjs.com/package/electron-packager))。这个包提供了一个用于为Windows、Linux和macOS构建可执行文件的命令行工具。
- en: 12.5.1\. Building with Electron Packager
  id: totrans-330
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.5.1. 使用Electron Packager构建
- en: 'To install electron-packager, install it globally. This will allow you to build
    any project that you want to create platform-specific binaries for:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装electron-packager，全局安装它。这将允许你为任何你想为特定平台创建二进制文件的项目构建：
- en: '[PRE48]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'After it’s installed, you can run it from your application’s directory. You
    must invoke it with the path to your application, the application name, platform,
    architecture (32- or 64-bit), and the Electron version:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 安装后，你可以从你的应用程序目录中运行它。你必须使用应用程序的路径、应用程序名称、平台、架构（32位或64位）和Electron版本来调用它：
- en: '[PRE49]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This downloads Electron version 1.4.5 and generates binaries for all supported
    platforms and architectures. This may take some time (Electron is about 40 MB),
    but when it’s done, you’ll have binaries that can be run on all major operating
    systems.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 这将下载Electron版本1.4.5并为所有支持的平台和架构生成二进制文件。这可能需要一些时间（Electron大约40 MB），但完成后，你将拥有可以在所有主要操作系统上运行的二进制文件。
- en: '|  |'
  id: totrans-336
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Hiding the developer tools**'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '**隐藏开发者工具**'
- en: 'Before sharing builds, you should remove or change the line in main.js that
    opens the Chromium development tools:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在共享构建之前，您应该删除或更改main.js中打开Chromium开发工具的行：
- en: '[PRE50]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Alternatively, you could wrap this with a flag to hide it when working on the
    app:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以使用标志将其包装起来，在开发应用程序时隐藏它：
- en: '[PRE51]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '|  |'
  id: totrans-342
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 12.5.2\. Packaging
  id: totrans-343
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.5.2\. 打包
- en: To further improve your application’s performance, you can package the client-side
    and Node JavaScript file by using Atom Shell archives ([https://github.com/atom/asar](https://github.com/atom/asar)).
    These archives are known as *asar files*, and they work like the UNIX `tar` command.
    They hide your JavaScript but don’t obscure it enough to stop people from decoding
    the packages, so you can’t use it to truly obfuscate code. But they solve the
    issue of long filenames breaking in Windows, which you might run into if you have
    deeply nested dependencies.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 要进一步提高应用程序的性能，您可以使用Atom Shell存档打包客户端和Node JavaScript文件([https://github.com/atom/asar](https://github.com/atom/asar))。这些存档被称为*asar文件*，它们类似于UNIX的`tar`命令。它们隐藏了您的JavaScript，但不足以阻止人们解码包，因此您不能用它真正混淆代码。但它们解决了在Windows中由于深层嵌套依赖项而导致的文件名过长的问题。
- en: In Electron, Chromium can read asar files as well as Node, so you don’t have
    to do anything special to support it. Also, electron-packager can create asar
    packages for you with the `--asar` command-line option.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 在Electron中，Chromium可以读取asar文件以及Node，因此您不需要做任何特殊的事情来支持它。此外，electron-packager可以使用`--asar`命令行选项为您创建asar包。
- en: '[Figure 12.6](#ch12fig06) shows what an application packaged without asar looks
    like.'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '[图12.6](#ch12fig06) 展示了未使用asar打包的应用程序的外观。'
- en: Figure 12.6\. A typical Electron application bundle’s contents
  id: totrans-347
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图12.6\. 典型的Electron应用程序包的内容
- en: '![](Images/12fig06_alt.jpg)'
  id: totrans-348
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/12fig06_alt.jpg)'
- en: Notice that you can open the JavaScript files to view the source. The only binary
    files in an Electron application are resources such as images, or binary Node
    modules.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，您可以打开JavaScript文件来查看源代码。Electron应用程序中唯一的二进制文件是资源，如图像或二进制Node模块。
- en: 'To generate a build with asar files, you can use electron-packager with the
    `--asar` flag:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用asar文件生成构建，您可以使用带有`--asar`标志的electron-packager：
- en: '[PRE52]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'This is the easiest way to do it, because electron-packager runs all the necessary
    commands. To do it manually, you need to install asar, and then you need to invoke
    the command-line tool to create a package:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最简单的方法，因为electron-packager会运行所有必要的命令。要手动完成，您需要安装asar，然后需要调用命令行工具来创建一个包：
- en: '[PRE53]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: After you have the asar archive, download an Electron binary ([https://github.com/atom/electron/releases](https://github.com/atom/electron/releases))
    for the platform you want to support, and add the archive to the resources directory,
    as shown in [figure 12.6](#ch12fig06). Running the application executable or bundle
    should cause your application to run.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在您拥有asar存档后，下载您想要支持的平台的Electron二进制文件([https://github.com/atom/electron/releases](https://github.com/atom/electron/releases))，并将存档添加到资源目录中，如图12.6所示。运行应用程序的可执行文件或包应该会导致您的应用程序运行。
- en: Editing the vendor-supplied binaries is also how Electron applications are branded.
    You can change the application’s name and icons this way. If you run an Electron
    binary with no modifications, it provides a window that allows you to run Electron
    apps made with the electron-quick-start repository.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 通过编辑供应商提供的二进制文件，也是Electron应用程序品牌化的方式。您可以通过这种方式更改应用程序的名称和图标。如果您运行未经修改的Electron二进制文件，它将提供一个窗口，允许您运行使用electron-quick-start存储库制作的Electron应用程序。
- en: 12.6\. Summary
  id: totrans-356
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.6\. 总结
- en: Using Electron, you can make desktop applications with Node, JavaScript, HTML,
    and CSS.
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Electron，您可以使用Node、JavaScript、HTML和CSS制作桌面应用程序。
- en: You can generate native menus and notifications without using C++, C#, or Objective-C.
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以生成原生菜单和通知，而无需使用C++、C#或Objective-C。
- en: If you have useful Node modules, you can use them from the client-side Java-Script
    within the Electron application’s UI.
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您有有用的Node模块，您可以在Electron应用程序的UI中从客户端JavaScript中使用它们。
- en: Electron uses a fully fledged browser, so you can build UIs with the latest
    Java-Script technology, such as React or Angular.
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Electron使用完整的浏览器，因此您可以使用最新的Java-Script技术，如React或Angular来构建UI。
