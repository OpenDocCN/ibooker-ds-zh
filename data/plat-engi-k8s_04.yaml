- en: '4 Environment pipelines: Deploying cloud-native applications'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4 环境管道：部署云原生应用程序
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Deploying produced artifacts into environments
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将生成的工件部署到环境中
- en: Using environment pipelines and GitOps to manage environments
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用环境管道和GitOps来管理环境
- en: Using Argo CD with Helm to deliver software efficiently
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Helm与Argo CD高效交付软件
- en: 'This chapter introduces the concept of *environment pipelines*. We cover the
    steps required to deploy the artifacts created by service pipelines into concrete
    running environments all the way to production. We will look into a common practice
    that has emerged in the cloud-native space called GitOps, which allows us to define
    and configure our environments using a Git repository. Finally, we will look at
    a project called Argo CD, which implements a GitOps approach for managing applications
    on top of Kubernetes. This chapter is divided into three main sections:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了*环境管道*的概念。我们涵盖了将服务管道创建的工件部署到具体运行环境直至生产的步骤。我们将探讨在云原生领域出现的一种常见做法，称为GitOps，它允许我们使用Git存储库来定义和配置我们的环境。最后，我们将探讨一个名为Argo
    CD的项目，它实现了在Kubernetes上管理应用程序的GitOps方法。本章分为三个主要部分：
- en: Environment pipelines
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 环境管道
- en: Environment pipelines in action using Argo CD
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Argo CD实现的环境管道
- en: Service + environment pipelines working together
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务+环境管道协同工作
- en: 4.1 Environment pipelines
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.1 环境管道
- en: We can build as many services as we want and produce new versions, but if these
    versions cannot flow freely across different environments to be tested and finally
    used by our customers, our organization will struggle to have a smooth end-to-end
    software delivery practice. Environment pipelines are in charge of configuring
    and maintaining our environments.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以构建尽可能多的服务并产生新版本，但如果这些版本不能自由地跨越不同的环境进行测试，最终被我们的客户使用，我们的组织将难以拥有顺畅的端到端软件交付实践。环境管道负责配置和维护我们的环境。
- en: It is quite common for companies to have different environments for different
    purposes, for example, a staging environment where developers can deploy their
    latest versions of the services or a quality assurance (QA) environment where
    manual testing happens and one or more production environments, which are where
    the real users interact with our applications. These (staging, QA, and production)
    are just examples. There shouldn’t be any hard limit on how many environments
    we can have. Figure 4.1 shows how a single release flows throughout different
    environments until it reaches production, where it is going to be live in front
    of our application’s users.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 对于公司来说，根据不同的目的拥有不同的环境是很常见的，例如，一个预发布环境，开发者可以部署他们服务的最新版本；一个质量保证（QA）环境，在这里进行手动测试；以及一个或多个生产环境，这是真实用户与我们的应用程序交互的地方。这些（预发布、QA和生产）只是例子。我们拥有的环境数量不应该有任何硬性限制。图4.1展示了单个发布版本如何在不同的环境中流动，直到达到生产环境，在那里它将面向我们的应用程序用户公开。
- en: '![](../../OEBPS/Images/04-01.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/04-01.png)'
- en: Figure 4.1 Released service moving throughout different environments
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1 发布的服务在不同环境中的流动
- en: Each environment (development, staging, QA, and production) will have one environment
    pipeline. These pipelines will be responsible for keeping the environment configuration
    in sync with the hardware running the live version of the environment. These environment
    pipelines use as the source of truth a repository that contains the environment
    configurations, including which services and which version of each service needs
    to be deployed (figure 4.2).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 每个环境（开发、预发布、QA和生产）将有一个环境管道。这些管道将负责保持环境配置与运行环境硬件同步。这些环境管道使用包含环境配置的存储库作为真相来源，包括需要部署哪些服务和每个服务的哪个版本（图4.2）。
- en: '![](../../OEBPS/Images/04-02.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/04-02.png)'
- en: Figure 4.2 Promoting services to different environments means updating environment
    configurations
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2 将服务推广到不同环境意味着更新环境配置
- en: If you are using this approach, each environment will have its configuration
    repository. Promoting a newly released version means changing the environment
    configuration repository to add a new service or updating the configuration to
    point to the newly released version. Some organizations keep all sensitive environment
    configurations all together in a single repository; this helps with centralizing
    the credentials required to read and modify these configurations.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用这种方法，每个环境都将有自己的配置存储库。推广新发布的版本意味着更改环境配置存储库以添加新服务或更新配置以指向新发布的版本。一些组织将所有敏感环境配置都保存在单个存储库中；这有助于集中管理读取和修改这些配置所需的凭证。
- en: These configuration changes can be automated or require manual intervention.
    For more sensitive environments, such as the production environment, you might
    require different stakeholders to sign off before adding or updating a service.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这些配置更改可以是自动化的，或者需要手动干预。对于更敏感的环境，例如生产环境，你可能需要在添加或更新服务之前要求不同的利益相关者签字。
- en: But where do environment pipelines come from? And why wouldn’t you have heard
    of them before? Before jumping into the details about what an environment pipeline
    would look like, we need to get a bit of background on why this matters in the
    first place.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 但环境管道是从哪里来的？为什么你之前没有听说过它们？在深入探讨环境管道可能看起来像什么之前，我们需要了解为什么这从一开始就很重要。
- en: 4.1.1 How did this work in the past, and what has changed lately?
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.1 过去这是如何工作的，最近又发生了什么变化？
- en: Traditionally, creating new environments was hard and costly. Creating new environments
    on demand wasn’t a thing for these two reasons. First, the differences between
    the environment that a developer used to create an application and where the application
    ran for end users were completely different. These differences, not only in computing
    power, caused huge stress on operations teams responsible for running these applications.
    Depending on the environment’s capabilities, they needed to fine-tune the application’s
    configurations (that they didn’t design). Second, tools for automating the provisioning
    and configuration of complex setups have become mainstream. With the help of containers
    and Kubernetes, there has been a standardization around how these tools are designed
    and work across cloud providers. These tools had reached a point where developers
    can codify infrastructure using their programming language of choice or rely on
    the Kubernetes API to create these definitions.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，创建新的环境既困难又昂贵。由于这两个原因，按需创建新环境并不是一件事情。首先，开发人员用来创建应用程序的环境和应用程序为最终用户运行的环境之间的差异完全不同。这些差异，不仅在计算能力上，给负责运行这些应用程序的运维团队带来了巨大的压力。根据环境的能力，他们需要调整应用程序的配置（他们没有设计）。其次，自动化复杂设置配置的工具已经变得主流。借助容器和Kubernetes，这些工具的设计和工作方式在云提供商之间实现了标准化。这些工具已经达到了开发者可以使用他们选择的编程语言来编码基础设施，或者依赖Kubernetes
    API来创建这些定义的程度。
- en: Before the rise of cloud–native applications, deploying a new application or
    a new version of an application required shutting down the server, running some
    scripts, copying some binaries, and then starting the server again with the new
    version running. After the server starts again, the application could fail to
    start. Hence more configuration tuning might be needed. Most of these configurations
    were done manually in the server itself, making it difficult to remember and keep
    track of what was changed and why.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在云原生应用兴起之前，部署一个新的应用程序或应用程序的新版本需要关闭服务器，运行一些脚本，复制一些二进制文件，然后再次启动服务器，使新版本运行。服务器再次启动后，应用程序可能会失败启动。因此可能需要更多的配置调整。大多数这些配置都是在服务器本身手动完成的，这使得很难记住并跟踪更改了什么以及为什么。
- en: 'As part of automating these processes, tools like Jenkins ([https://www.jenkins.io/](https://www.jenkins.io/),
    a very popular pipeline engine) and/or scripts were used to simplify deploying
    new binaries. So instead of manually stopping servers and copying binaries, an
    operator can run a Jenkins Job defining which versions of the artifacts they wanted
    to deploy, and Jenkins will run the job notifying the operator about the output.
    This approach had two main advantages:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 作为自动化这些流程的一部分，像Jenkins ([https://www.jenkins.io/](https://www.jenkins.io/),
    一个非常流行的管道引擎) 和/或脚本这样的工具被用来简化新二进制的部署。因此，而不是手动停止服务器并复制二进制文件，操作员可以运行一个Jenkins作业，定义他们想要部署的工件版本，Jenkins将运行作业并通知操作员关于输出的信息。这种方法有两个主要优点：
- en: Tools like Jenkins can have access to the environment’s credentials, avoiding
    manual access to the servers by the operators.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 像Jenkins这样的工具可以访问环境的凭证，避免操作员手动访问服务器。
- en: Tools like Jenkins log every job execution and the parameters, allowing us to
    keep track of what was done and the result of the execution.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 像Jenkins这样的工具会记录每次作业执行和参数，使我们能够跟踪执行了什么以及执行结果。
- en: While automating with tools like Jenkins was a big improvement compared to manually
    deploying new versions, there were still some problems, such as having fixed environments
    completely different from where the software was being developed and tested. We
    needed to specify how the environment is created and configured to the operating
    system’s version and the software installed into the machines or virtual machines
    to reduce the difference between different environments. Virtual machines helped
    greatly with this task, because we can easily create two or more virtual machines
    configured similarly.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 与手动部署新版本相比，虽然使用像Jenkins这样的工具进行自动化是一个很大的改进，但仍然存在一些问题，例如具有固定环境的环境与软件开发和测试的地方完全不同。我们需要指定环境是如何创建和配置的，包括操作系统的版本和安装到机器或虚拟机中的软件，以减少不同环境之间的差异。虚拟机在完成这项任务时非常有帮助，因为我们可以轻松地创建两个或更多配置相似的虚拟机。
- en: We can even give our developers these virtual machines to work. But now we have
    a new problem. We will need new tools to manage, run, maintain, and store our
    virtual machines. If we have multiple physical machines where we want to run virtual
    machines, we don’t want our operations team to start these VMs in each server
    manually. Hence, we will need a hypervisor to monitor and run VMs in a cluster
    of physical computers.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以将这些虚拟机提供给我们的开发者使用。但现在我们遇到了一个新的问题。我们需要新的工具来管理、运行、维护和存储我们的虚拟机。如果我们有多个物理机想要在上面运行虚拟机，我们不希望我们的运维团队在每个服务器上手动启动这些虚拟机。因此，我们需要一个虚拟化软件来监控和运行物理计算机集群中的虚拟机。
- en: Using tools like Jenkins and virtual machines (with hypervisors) were a huge
    improvement. Because we implemented some automation, operators didn’t need to
    access servers or VMs to change configurations manually, and our environments
    were created using a configuration predefined in a fixed virtual machine configuration.
    Tools like Ansible ([https://www.ansible.com/](https://www.ansible.com/)) and
    Puppet ([https://www.puppet.com/](https://www.puppet.com/)) are built on top of
    these concepts.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 使用像Jenkins和虚拟机（带有虚拟化软件）这样的工具是一个巨大的改进。因为我们实现了一些自动化，操作员不需要访问服务器或虚拟机来手动更改配置，并且我们的环境是通过在固定的虚拟机配置中预定义的配置创建的。像Ansible
    ([https://www.ansible.com/](https://www.ansible.com/)) 和Puppet ([https://www.puppet.com/](https://www.puppet.com/))
    这样的工具就是建立在这些概念之上的。
- en: Figure 4.3 shows Jenkins Jobs configured to create virtual machines that host
    our applications. But beware, these virtual machines host an entire operating
    system. All the tools bundled with that operating system will run beside your
    applications!
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3显示了配置为创建托管我们应用程序的虚拟机的Jenkins作业。但请注意，这些虚拟机托管了一个完整的操作系统。该操作系统捆绑的所有工具都将与你的应用程序一起运行！
- en: '![](../../OEBPS/Images/04-03.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/04-03.png)'
- en: Figure 4.3 Jenkins Jobs or scripts encapsulated the operational knowledge of
    how to do deployments in an imperative way, defining step-by-step what needs to
    be done. This is a complex task, hard to maintain and modify, and very specific
    to the tool we're using. On the other hand, virtual machines are resource-intensive
    and not portable across cloud providers.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3中的Jenkins作业或脚本以命令式的方式封装了如何进行部署的操作知识，定义了需要按步骤完成的操作。这是一个复杂且难以维护和修改的任务，并且非常特定于我们使用的工具。另一方面，虚拟机资源密集且不可跨云提供商迁移。
- en: 'While this approach is still common in the industry, there is a lot of room
    for improvement, for example, in the following areas:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种方法在业界仍然很常见，但还有很多改进的空间，例如以下方面：
- en: Jenkins Jobs and scripts are imperative by nature, meaning they specify step-by-step
    what needs to be done. This has a great disadvantage, because if something changes—let’s
    say a server is no longer there or requires more data to authenticate against
    a service—the logic of the pipeline will fail, and it will need to be manually
    updated.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jenkins作业和脚本本质上是命令式的，这意味着它们指定了需要按步骤执行的操作。这有一个很大的缺点，因为如果有什么变化——比如说服务器不再存在或者需要更多数据来验证服务——管道的逻辑将失败，并且需要手动更新。
- en: Virtual machines are heavy. Every time you start a virtual machine, you start
    a complete instance of an operating system. Running the operating system processes
    does not add any business value; the larger the cluster, the bigger the operating
    system overhead. On the VM’s requirements, running VMs in developers’ environments
    may not be possible.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚拟机很重。每次你启动一个虚拟机时，你都在启动一个操作系统的完整实例。运行操作系统进程不会增加任何业务价值；集群越大，操作系统开销就越大。在开发者的环境中运行虚拟机可能是不可能的。
- en: Environments’ configurations are hidden and not versioned. Most of the environment
    configurations and how the deployments are done are encoded inside tools like
    Jenkins, where complex pipelines tend to grow out of control, making the changes
    very risky and migration to newer tools and stacks very difficult.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 环境的配置是隐藏的，并且没有版本控制。大多数环境配置以及部署是如何进行的都被编码在像Jenkins这样的工具中，其中复杂的管道往往会失去控制，使得更改非常危险，迁移到新的工具和堆栈也非常困难。
- en: Each cloud provider has a non-standard way of creating virtual machines. This
    can push us into a vendor lock-in situation. If we created VMs for Amazon Web
    Services, we could not run these VMs into the Google Cloud Platform or Microsoft
    Azure.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个云服务提供商都有创建虚拟机的不标准方式。这可能会使我们陷入供应商锁定的情况。如果我们为亚马逊网络服务创建了虚拟机，我们就无法将这些虚拟机运行在谷歌云平台或微软Azure上。
- en: How are teams approaching this with modern tooling? That is an easy question.
    We now have Kubernetes and containers that aim to solve the overhead caused by
    VMs and the cloud-provider portability by relying on containers and the widely
    adopted Kubernetes APIs. Kubernetes also provides the building blocks to ensure
    we don’t need to shut down our servers to deploy new applications or change their
    configurations. If we do things in the Kubernetes way, we shouldn’t have any downtime
    in our applications.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 团队是如何使用现代工具来处理这个问题的？这是一个简单的问题。我们现在有Kubernetes和容器，它们旨在通过依赖容器和广泛采用的Kubernetes
    API来解决由虚拟机和云提供商的可移植性带来的开销。Kubernetes还提供了构建块，确保我们不需要关闭服务器来部署新应用程序或更改它们的配置。如果我们按照Kubernetes的方式行事，我们的应用程序不应该有任何停机时间。
- en: But Kubernetes alone doesn’t solve the process of configuring the clusters themselves.
    How we apply changes to their configurations, or the process and tooling involved
    into deploying applications to these clusters, also matter. That’s why you might
    have heard about GitOps.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 但仅Kubernetes本身并不能解决配置集群本身的过程。我们如何应用更改到它们的配置，或者部署应用程序到这些集群涉及的过程和工具，也同样重要。这就是为什么你可能听说过GitOps。
- en: What is GitOps, and how does it relate to our environment pipelines? We’ll answer
    that question next.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是GitOps，它与我们的环境管道有何关联？我们将在下一节回答这个问题。
- en: 4.1.2 What is GitOps, and how does it relate to environment pipelines?
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.2 什么是GitOps，它与环境管道有何关联？
- en: If we don’t want to encode all of our operational knowledge in a tool like Jenkins,
    where it is difficult to maintain, change, and keep track of it, we need a different
    approach.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不希望在像Jenkins这样的工具中编码所有的操作知识，那里很难维护、更改和跟踪它，我们需要不同的方法。
- en: 'The term GitOps, defined by the CNCF’s GitOps Working Group ([https://opengitops.dev/](https://opengitops.dev/)),
    defines the process of creating, maintaining, and applying the configuration of
    our environments and applications declaratively using Git as the source of truth.
    OpenGitOps defines four core principles that we need to consider when we talk
    about GitOps:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: GitOps这个术语是由CNCF的GitOps工作组定义的（[https://opengitops.dev/](https://opengitops.dev/)），它定义了使用Git作为真相来源，以声明性方式创建、维护和应用我们环境和应用程序配置的过程。OpenGitOps定义了我们在谈论GitOps时需要考虑的四个核心原则：
- en: '*Declarative:* A system ([https://github.com/open-gitops/documents/blob/v1.0.0/GLOSSARY.md#software-system](https://github.com/open-gitops/documents/blob/v1.0.0/GLOSSARY.md#software-system))
    managed by GitOps must have its desired state expressed declaratively ([https://github.com/open-gitops/documents/blob/v1.0.0/GLOSSARY.md#declarative-description](https://github.com/open-gitops/documents/blob/v1.0.0/GLOSSARY.md#declarative-description)).
    We have this covered if we use Kubernetes manifest, because we define what needs
    to be deployed and how that needs to be configured using declarative resources
    that Kubernetes will reconcile.'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*声明式*: 由GitOps管理的系统([https://github.com/open-gitops/documents/blob/v1.0.0/GLOSSARY.md#software-system](https://github.com/open-gitops/documents/blob/v1.0.0/GLOSSARY.md#software-system))必须以声明式([https://github.com/open-gitops/documents/blob/v1.0.0/GLOSSARY.md#declarative-description](https://github.com/open-gitops/documents/blob/v1.0.0/GLOSSARY.md#declarative-description))表达其所需状态。如果我们使用Kubernetes清单，我们就有了这个保障，因为我们使用Kubernetes将进行协调的声明性资源来定义需要部署的内容以及如何配置。'
- en: '*Versioned and immutable:* The desired state is stored ([https://github.com/open-gitops/documents/blob/v1.0.0/GLOSSARY.md#state-store](https://github.com/open-gitops/documents/blob/v1.0.0/GLOSSARY.md#state-store))
    in a way that enforces immutability and versioning and retains a complete version
    history. The OpenGitOps initiative doesn’t enforce the use of Git. As soon as
    our definitions are stored, versioned, and immutable, we can consider it as GitOps.
    This opens the door to storing files in, for example, S3 buckets, which are also
    versioned and immutable.'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*版本化和不可变*: 所需状态以强制执行不可变性和版本化并保留完整版本历史记录的方式存储([https://github.com/open-gitops/documents/blob/v1.0.0/GLOSSARY.md#state-store](https://github.com/open-gitops/documents/blob/v1.0.0/GLOSSARY.md#state-store))。OpenGitOps倡议不强制使用Git。一旦我们的定义被存储、版本化和不可变，我们就可以将其视为GitOps。这为将文件存储在例如S3存储桶中打开了大门，这些存储桶也是版本化和不可变的。'
- en: '*Pulled automatically:* Software agents automatically pull the desired state
    declarations from the source. The GitOps software pulls the changes from the source
    periodically in an automated way. Users shouldn’t worry about when the changes
    are pulled.'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*自动拉取*: 软件代理自动从源中拉取所需状态声明。GitOps软件以自动化的方式定期从源中拉取更改。用户无需担心何时拉取更改。'
- en: '*Continuously reconciled:* Software agents continuously ([https://github.com/open-gitops/documents/blob/v1.0.0/GLOSSARY.md#continuous](https://github.com/open-gitops/documents/blob/v1.0.0/GLOSSARY.md#continuous))
    observe the system state and attempt to apply ([https://github.com/open-gitops/documents/blob/v1.0.0/GLOSSARY.md#reconciliation](https://github.com/open-gitops/documents/blob/v1.0.0/GLOSSARY.md#reconciliation))
    the desired state. This continuous reconciliation helps us to build resilience
    in our environments and the entire delivery process, because we have components
    that are in charge of applying the desired state and monitoring our environments
    from configuration drifts. If the reconciliation fails, GitOps tools will notify
    us about the problems and keep trying to apply the changes until the desired state
    is achieved.'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*持续协调*: 软件代理持续([https://github.com/open-gitops/documents/blob/v1.0.0/GLOSSARY.md#continuous](https://github.com/open-gitops/documents/blob/v1.0.0/GLOSSARY.md#continuous))观察系统状态，并尝试应用([https://github.com/open-gitops/documents/blob/v1.0.0/GLOSSARY.md#reconciliation](https://github.com/open-gitops/documents/blob/v1.0.0/GLOSSARY.md#reconciliation))所需状态。这种持续的协调有助于我们在环境和整个交付过程中建立弹性，因为我们有负责应用所需状态并监控环境配置漂移的组件。如果协调失败，GitOps工具将通知我们问题，并持续尝试应用更改，直到达到所需状态。'
- en: By storing the configuration of our environments and applications in a Git repository,
    we can track and version the changes we make. By relying on Git, we can easily
    roll back changes if these changes don’t work as expected. GitOps covers the configuration
    storage and how these configurations are applied to the computing resources where
    the applications run.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将环境和应用程序的配置存储在Git仓库中，我们可以跟踪和版本化我们所做的更改。通过依赖Git，如果这些更改不符合预期，我们可以轻松地回滚更改。GitOps涵盖了配置存储以及这些配置如何应用到应用程序运行的计算资源中。
- en: GitOps was coined in the context of Kubernetes, but this approach is not new,
    because configuration management tools have existed for a long time. Instead,
    GitOps represents a refinement of these tried and tested approaches that can be
    applied to any software operation, not just Kubernetes. With the rise in popularity
    of cloud providers’ tools for managing Infrastructure as Code, tools like Chef
    ([https://www.chef.io/](https://www.chef.io/)), Ansible ([https://www.ansible.com/](https://www.ansible.com/)),
    Terraform ([https://www.terraform.io/](https://www.terraform.io/)), and Pulumi
    ([https://www.pulumi.com/](https://www.pulumi.com/)) are loved by operations teams,
    because these tools allow them to define how to configure cloud resources and
    configure them together in a reproducible way. If you need a new environment,
    you just run this Terraform script or Pulumi app, and then voila, the environment
    is up and running. These tools are also equipped to communicate with the cloud
    provider’s APIs to create Kubernetes clusters so that we can automate the creation
    of these clusters.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: GitOps是在Kubernetes的背景下提出的，但这种方法并不新颖，因为配置管理工具已经存在很长时间了。相反，GitOps代表了这些经过验证的方法的改进，这些方法可以应用于任何软件操作，而不仅仅是Kubernetes。随着云提供商管理基础设施即代码的工具的普及，像Chef
    ([https://www.chef.io/](https://www.chef.io/))、Ansible ([https://www.ansible.com/](https://www.ansible.com/))、Terraform
    ([https://www.terraform.io/](https://www.terraform.io/))和Pulumi ([https://www.pulumi.com/](https://www.pulumi.com/))这样的工具受到运维团队的喜爱，因为这些工具允许他们定义如何配置云资源，并以可重复的方式一起配置它们。如果您需要一个新的环境，只需运行这个Terraform脚本或Pulumi应用程序，然后，环境就绪并运行。这些工具还配备了与云提供商的API通信的能力，以便我们可以自动化这些集群的创建。
- en: With GitOps, we manage configuration and rely on the Kubernetes APIs as the
    standard way to deploy our applications to Kubernetes clusters. With GitOps, we
    use a Git repository as the source of truth for our environment’s internal configurations
    (Kubernetes YAML files) while removing the need to interact manually with the
    Kubernetes clusters to avoid configuration drifts and security problems. When
    using GitOps tools, we can expect to have software agents in charge of pulling
    from the source of truth (Git repository in this example) periodically and constantly
    monitoring the environment to provide a continuous reconciliation loop. This ensures
    that the GitOps tool will do its best to ensure that the desired state expressed
    in the repository is what we have in our live environments.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 使用GitOps，我们管理配置并依赖于Kubernetes API作为将我们的应用程序部署到Kubernetes集群的标准方式。使用GitOps，我们将Git仓库作为我们环境内部配置（Kubernetes
    YAML文件）的真相来源，同时消除了手动与Kubernetes集群交互的需求，以避免配置漂移和安全问题。当使用GitOps工具时，我们可以期待有软件代理定期从真相来源（本例中的Git仓库）拉取，并持续监控环境以提供连续的协调循环。这确保GitOps工具将尽最大努力确保仓库中表达的期望状态与我们的实际环境相符。
- en: We can reconfigure any Kubernetes cluster to have the same configuration stored
    in our Git repository by running an environment pipeline. Figure 4.4 shows how
    these pieces fit together. On the left, we have Infrastructure as Code tools that
    can create cloud resources, including Kubernetes clusters and application infrastructure
    for our environments. Once the environment is set up, an environment pipeline
    using a GitOps approach can sync all the configurations for our environment into
    the target Kubernetes cluster, regularly checking that the configuration stored
    in Git is in sync with the cluster.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过运行环境管道重新配置任何Kubernetes集群，使其具有存储在我们Git仓库中的相同配置。图4.4展示了这些组件是如何组合在一起的。在左侧，我们有可以创建云资源（包括Kubernetes集群和我们的环境的应用程序基础设施）的基础设施即代码工具。一旦环境设置完成，使用GitOps方法的环境管道可以将我们环境的所有配置同步到目标Kubernetes集群，并定期检查Git中存储的配置是否与集群同步。
- en: '![](../../OEBPS/Images/04-04.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/04-04.png)'
- en: Figure 4.4 Infrastructure as Code, GitOps, and environment pipelines working
    together. Infrastructure as code tools run scripts to create cloud resources in
    a reproducible way. We can create our Kubernetes clusters to be all the same using
    these tools. GitOps tools run environment pipelines to continuously reconcile
    declarative configuration, which is stored in a versioned and immutable repository.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4 基础设施即代码、GitOps和环境管道协同工作。基础设施即代码工具通过运行脚本以可重复的方式创建云资源。我们可以使用这些工具创建出所有相同的Kubernetes集群。GitOps工具运行环境管道以持续地协调声明性配置，这些配置存储在版本化和不可变的仓库中。
- en: By separating the infrastructure and application concerns, our environment pipelines
    allow us to ensure that our environments are easy to reproduce and update whenever
    needed. By relying on Git as the source of truth, we can roll back our infrastructural
    and application changes as needed. It is also important to understand that because
    we are working with the Kubernetes APIs, our environment’s definitions are now
    expressed in a declarative way, supporting changes in the context where these
    configurations are applied and letting Kubernetes deal with how to achieve the
    desired state expressed by these configurations.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 通过分离基础设施和应用关注点，我们的环境管道使我们能够确保我们的环境易于复制和更新，无论何时需要。通过依赖 Git 作为真相的来源，我们可以根据需要回滚我们的基础设施和应用更改。重要的是要理解，因为我们正在使用
    Kubernetes API，我们的环境定义现在以声明式的方式表达，支持在应用这些配置的上下文中进行更改，并让 Kubernetes 处理如何实现这些配置所表达的状态。
- en: Figure 4.5 shows these interactions, where operation teams only make changes
    to the Git repository that contains our environment configuration, and then a
    pipeline (a set of steps) is executed to ensure that this configuration is in
    sync with the target environment.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.5 展示了这些交互，其中操作团队仅更改包含我们环境配置的 Git 仓库，然后执行一个管道（一系列步骤）来确保此配置与目标环境保持同步。
- en: '![](../../OEBPS/Images/04-05.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/04-05.png)'
- en: Figure 4.5 Defining the state of the cluster using the configuration in Git
    (GitOps). Environment pipelines monitor configuration changes on a Git repository
    and apply those changes to the infrastructure (Kubernetes cluster) whenever a
    new change is detected. Following this approach allows us to roll back changes
    in the infrastructure by reverting commits on Git. We can also replicate the exact
    environment configuration by just running the same pipeline against another cluster.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.5 使用 Git 中的配置定义集群状态（GitOps）。环境管道监控 Git 仓库中的配置更改，并在检测到新更改时将这些更改应用到基础设施（Kubernetes
    集群）中。遵循这种方法允许我们通过在 Git 上回滚提交来撤销基础设施中的更改。我们还可以通过在另一个集群上运行相同的管道来复制确切的环境配置。
- en: When you start using environment pipelines, you aim to stop interacting, changing,
    or modifying the environment’s configuration manually, and all interactions are
    done exclusively by these pipelines. To give a very concrete example, instead
    of executing `kubectl apply -f` or `helm install` into our Kubernetes cluster,
    an operator will be in charge of running these commands based on the contents
    of a Git repository that has the definitions and configurations of what needs
    to be installed in the cluster.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当您开始使用环境管道时，目标是停止手动交互、更改或修改环境的配置，所有交互都仅通过这些管道进行。为了给出一个非常具体的例子，我们不是直接在我们的 Kubernetes
    集群中执行 `kubectl apply -f` 或 `helm install`，而是由一个操作员负责根据包含集群中需要安装的定义和配置的 Git 仓库的内容来运行这些命令。
- en: In theory, an operator that monitors a Git repository and reacts to changes
    is all you need, but in practice, a set of steps is needed to ensure we have full
    control of what is deployed to our environments. Hence, thinking about GitOps
    as a pipeline helps us understand that for some scenarios, we will need to add
    extra steps to these pipelines triggered every time an environment configuration
    is changed.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，一个监控 Git 仓库并对更改做出反应的操作员就是您所需要的，但在实践中，需要一系列步骤来确保我们对部署到我们环境中的内容有完全的控制。因此，将
    GitOps 视为一个管道有助于我们理解，对于某些场景，我们可能需要在每次环境配置更改时触发的这些管道中添加额外的步骤。
- en: Let’s look at these steps with more concrete tools commonly found in real-life
    scenarios.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用更具体的工具来看这些步骤，这些工具在现实场景中很常见。
- en: 4.1.3 Steps involved in an environment pipeline
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.3 环境管道中涉及到的步骤
- en: 'No matter what kind of applications you are deploying to different environments,
    environment pipelines usually include a set of predefined steps. Figure 4.6 shows
    these steps as a sequence, as most of the time these steps are defined inside
    scripts or encoded in tools that are in charge of checking that each step was
    executed correctly. Let’s dig deeper into the details of these steps:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您将何种应用程序部署到不同的环境中，环境管道通常包含一系列预定义的步骤。图 4.6 展示了这些步骤作为一个序列，因为大多数情况下，这些步骤是在脚本内部定义的，或者编码在负责检查每个步骤是否正确执行的工具中。让我们更深入地探讨这些步骤的细节：
- en: '*Reacting to changes in the configuration:* This can be done by polling or
    pushing:'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*响应配置变化*：这可以通过轮询或推送来完成：'
- en: '*Polling for changes:* A component can pull the repository and check if there
    have been new commits since the last time it checked. If new changes are detected,
    a new environment pipeline instance is created.'
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*对更改进行投票:* 组件可以拉取仓库并检查自上次检查以来是否有新的提交。如果检测到新更改，则会创建一个新的环境管道实例。'
- en: '*Pushing changes using webhooks:* If the repository supports webhooks, the
    repository can notify our environment pipelines that there are new changes to
    sync. Remember, the GitOps principles state “pulled automatically,” which means
    we can use webhooks, but we should not rely entirely on them for getting config
    change updates.'
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 webhooks 推送更改:* 如果仓库支持 webhooks，仓库可以通知我们的环境管道有新的更改需要同步。记住，GitOps 原则声明“自动拉取”，这意味着我们可以使用
    webhooks，但不应该完全依赖它们来获取配置更改更新。'
- en: '![](../../OEBPS/Images/04-06.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/04-06.png)'
- en: Figure 4.6 Environment pipeline for a Kubernetes environment
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.6 Kubernetes 环境的环境管道
- en: '*Clone the source code from the repository, which contains the desired state
    for our environment:* This step fetches the configuration from a remote Git repository
    that contains the environment configurations. Tools like Git fetch only the delta
    between the remote repository and what we have locally.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*从包含我们环境所需状态的仓库中克隆源代码:* 此步骤从包含环境配置的远程 Git 仓库中获取配置。像 Git 这样的工具仅获取远程仓库与我们本地拥有的内容之间的差异。'
- en: '*Apply the desired state to a live environment:* This usually includes doing
    a `kubectl apply -f` or a `helm install` command to install new versions of the
    artifacts. Notice that with both `kubectl` and `helm`, Kubernetes is smart enough
    to recognize where the changes are and only apply the differences. Once the pipeline
    has all the configurations locally accessible, it will use a set of credentials
    to apply these changes to a Kubernetes cluster. Notice that we can fine-tune the
    access rights that the pipelines have to the cluster to ensure they are not exploited
    from a security point of view. This also allows you to remove access from individual
    team members to the clusters where the services are deployed.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*将所需状态应用到实际环境中:* 这通常包括执行 `kubectl apply -f` 或 `helm install` 命令来安装新版本的工件。请注意，无论是使用
    `kubectl` 还是 `helm`，Kubernetes 都足够智能，能够识别更改的位置，并且只应用差异。一旦管道在本地拥有所有配置，它将使用一组凭证将这些更改应用到
    Kubernetes 集群。请注意，我们可以微调管道对集群的访问权限，以确保它们不会被从安全角度滥用。这也允许您从部署服务的集群中移除个别团队成员的访问权限。'
- en: '*Verify that the changes are applied and that the state matches what is described
    inside the Git repository (deal with configuration drift**):* Once the changes
    are applied to the live cluster, checking that the new versions of services are
    up and running is needed to identify if we need to revert to a previous version.
    It is quite simple if we need to revert changes, because all the history is stored
    in Git. Applying the previous version is just looking at the previous commit in
    the repository.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*验证更改是否已应用，并且状态与 Git 仓库内描述的一致（处理配置漂移**）:* 一旦更改应用到生产集群，需要检查新版本的服务是否正常运行，以确定是否需要回滚到之前的版本。如果需要回滚更改，由于所有历史记录都存储在
    Git 中，所以操作非常简单。应用上一个版本只需查看仓库中的上一个提交。'
- en: '*Validate that your workloads are working as expected:* Once the configurations
    are applied correctly, we need to validate that the applications deployed are
    working as expected and doing what they are supposed to do.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*验证您的应用程序按预期工作:* 一旦配置正确应用，我们需要验证部署的应用程序是否按预期工作，并且正在执行它们应该执行的操作。'
- en: 'For the environment pipeline to work, a component that can apply the changes
    to the environment is needed, and it needs to be configured accordingly with the
    right access credentials. The main idea behind this component is to make sure
    that nobody will change the environment configuration by manually interacting
    with the cluster. This component is the only one allowed to change the environment
    configuration, deploy new services, upgrade versions, or remove services from
    the environment. For an environment pipeline to work, the following two considerations
    need to be met:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使环境管道工作，需要一个能够将更改应用到环境的组件，并且需要根据正确的访问凭证进行相应配置。这个组件背后的主要思想是确保没有人会通过手动与集群交互来更改环境配置。这个组件是唯一允许更改环境配置、部署新服务、升级版本或从环境中删除服务的组件。为了使环境管道工作，需要满足以下两个条件：
- en: The repository containing the desired state for the environment must have all
    the necessary configurations to create and configure the environment successfully.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储环境所需状态的仓库必须包含所有必要的配置，以确保环境能够成功创建和配置。
- en: The Kubernetes cluster where the environment will run needs to be configured
    with the correct credentials for allowing the state to be changed by the pipelines.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 环境将运行的 Kubernetes 集群需要配置正确的凭证，以便管道可以更改状态。
- en: The term *environment pipeline* refers to the fact that each environment will
    have a pipeline associated with it. Because multiple environments are usually
    required (development, staging, production) for delivering applications, each
    will have a pipeline in charge of deploying and upgrading the components running
    in them. By using this approach, promoting services between different environments
    is achieved by sending pull requests/change requests to the environment’s repository.
    The pipeline will reflect the changes in the target cluster.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: “环境管道”这个术语指的是每个环境都将有一个与之关联的管道。由于通常需要多个环境（开发、测试、生产）来交付应用程序，因此每个环境都将有一个负责部署和升级其中运行的组件的管道。通过使用这种方法，通过向环境的仓库发送拉取请求/更改请求来实现不同环境之间服务的提升。管道将在目标集群中反映这些更改。
- en: 4.1.4 Environment pipeline requirements and different approaches
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.1.4 环境管道的要求和不同方法
- en: So, what are the contents of these environment’s repositories? As you will see
    in figure 4.7, the contents of the environment repository are just the definition
    of which services need to be present in the environment. The environment pipeline
    then can just apply these Kubernetes manifests to the target cluster.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这些环境仓库的内容是什么呢？如图 4.7 所示，环境仓库的内容仅仅是定义了哪些服务需要存在于环境中。然后，环境管道就可以将这些 Kubernetes
    清单应用到目标集群中。
- en: '![](../../OEBPS/Images/04-07.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/04-07.png)'
- en: Figure 4.7 Environment configuration options
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.7 环境配置选项
- en: 'The first option (simple layout) is to store all the Kubernetes YAML files
    in a Git repository, and then the environment pipeline will just use `kubectl
    apply -f *` against the configured cluster. While this approach is simple, there
    is one big drawback: if you have your Kubernetes YAML files for each service in
    the service repository, then the environment repository will have these files
    duplicated, and they can go out of sync. Imagine if you have several environments,
    you must maintain all the copies in sync, which might become challenging.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个选项（简单布局）是将所有 Kubernetes YAML 文件存储在 Git 仓库中，然后环境管道将直接对配置的集群使用 `kubectl apply
    -f *`。虽然这种方法很简单，但有一个很大的缺点：如果你在服务仓库中有每个服务的 Kubernetes YAML 文件，那么环境仓库将会有这些文件的重复，并且它们可能会不同步。想象一下，如果你有多个环境，你必须维护所有副本的同步，这可能会变得具有挑战性。
- en: The second option (using Helm Charts) is a bit more elaborate now that we are
    using Helm to define the state of the cluster. You can use Helm dependencies to
    create a parent chart that will include as dependencies all the services that
    should be present in the environment. If you do so, the environment pipeline can
    use `helm update .` to apply the chart into a cluster. Something I don’t like
    about this approach is that you create one Helm release per change, and there
    are no separate releases for each service. This approach uses Helm dependencies
    to fetch each service definition, so a prerequisite for this approach is to have
    every service package as a Helm Chart.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个选项（使用 Helm 图表）现在使用 Helm 定义集群状态后，变得更加复杂。你可以使用 Helm 依赖关系创建一个父图表，它将包括所有应该存在于环境中的服务作为依赖项。如果你这样做，环境管道可以使用
    `helm update .` 将图表应用到集群中。我不喜欢这种方法的一点是，你为每次更改创建一个 Helm 发布，而且没有为每个服务创建单独的发布。这种方法使用
    Helm 依赖关系来获取每个服务定义，因此这种方法的一个先决条件是每个服务包都必须是一个 Helm 图表。
- en: The third option is to use a project called `helmfile` ([https://github.com/helmfile/helmfile](https://github.com/helmfile/helmfile)),
    designed for this very specific purpose, to define environment configurations.
    A `helmfile` allows you to declaratively define what Helm releases need to be
    present in our cluster. These Helm releases will be created when we run `helmfile
    sync`, having defined a `helmfile` containing the helm releases we want in the
    cluster.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个选择是使用一个名为`helmfile`的项目（[https://github.com/helmfile/helmfile](https://github.com/helmfile/helmfile)），专为这个特定目的设计，用于定义环境配置。`helmfile`允许你声明性地定义集群中需要存在的Helm发布。当我们运行`helmfile
    sync`并定义了一个包含我们希望在集群中存在的Helm发布的`helmfile`时，这些Helm发布将被创建。
- en: Whether you use any of these approaches or other tools to do this, the expectation
    is clear. You have a repository with the configuration (one repository per environment
    or a directory per environment), and a pipeline is in charge of picking up the
    configuration and using a tool to apply it to a cluster.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你使用这些方法中的任何一种还是其他工具来完成这项任务，期望都是明确的。你有一个包含配置的仓库（每个环境一个仓库或每个环境一个目录），一个管道负责获取配置并使用工具将其应用到集群中。
- en: It is common to have several environments (staging, QA, production), even allowing
    teams to create on-demand environments for running tests or day-to-day development
    tasks. If you use the “one environment per namespace” approach, as shown in figure
    4.8, it is common to have a separate Git repository for each environment, because
    it helps keep access to environments isolated and secure. This approach is simple,
    but it doesn’t provide enough isolation on the Kubernetes cluster, because Kubernetes
    Namespaces were designed for logical partitioning of the cluster. In this case,
    the staging environment will share with the production environment the cluster
    resources.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 通常会有几个环境（预发布、QA、生产），甚至允许团队创建按需环境来运行测试或日常开发任务。如果你使用图4.8所示的“每个命名空间一个环境”的方法，通常为每个环境有一个单独的Git仓库，因为这有助于保持对环境的访问隔离和安全。这种方法很简单，但它在Kubernetes集群上提供的隔离性不足，因为Kubernetes命名空间是为了集群的逻辑分区而设计的。在这种情况下，预发布环境将与生产环境共享集群资源。
- en: '![](../../OEBPS/Images/04-08.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图4.8](../../OEBPS/Images/04-08.png)'
- en: Figure 4.8 One environment per Kubernetes namespace approach. One strategy is
    to use namespaces for different environments. While this simplifies the configurations
    required for the pipelines to deploy services to different environments, namespaces
    don’t provide strong isolation guarantees.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.8展示了每个Kubernetes命名空间一个环境的方法。一种策略是使用不同的命名空间来区分不同的环境。虽然这样做简化了将服务部署到不同环境所需的配置，但命名空间并不提供强大的隔离保证。
- en: An alternative approach can be to use an entirely new cluster for each environment.
    The main difference is isolation and access control. By having a cluster per environment,
    you can be stricter in defining who and which components can deploy and upgrade
    things in these environments and have different hardware configurations for each
    cluster, such as multi-region setups and other scalability concerns that might
    not make sense to have in your staging and testing environments. Using different
    clusters, you can also aim for a multi-cloud setup, where different cloud providers
    can host different environments.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是为每个环境使用一个全新的集群。主要区别在于隔离和访问控制。通过为每个环境拥有一个集群，你可以更严格地定义谁和哪些组件可以部署和升级这些环境中的内容，并为每个集群配置不同的硬件配置，例如多区域设置和其他可能在预发布和测试环境中没有意义的可扩展性关注点。使用不同的集群，你还可以追求多云设置，其中不同的云提供商可以托管不同的环境。
- en: Figure 4.9 shows how you can use the namespace approach for development environments,
    which will be created by different teams and then have separated clusters for
    staging and production. The idea here is to have the staging and production cluster
    configured as similarly as possible, so applications deployed onto different environments
    behave the same.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.9展示了如何使用命名空间方法为开发环境，这些环境将由不同的团队创建，然后分别有用于预发布和生产的不同集群。这里的想法是将预发布和生产的集群配置得尽可能相似，以便部署到不同环境中的应用程序表现一致。
- en: '![](../../OEBPS/Images/04-09.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图4.9](../../OEBPS/Images/04-09.png)'
- en: Figure 4.9 Different environment configurations, based on requirements. A more
    realistic approach can use the same cluster for multiple teams doing day-to-day
    work, while more sensitive environments like staging and production are separated
    on their own clusters and Git repositories to store their configurations. For
    a service to be promoted to a new environment, a pull request needs to be submitted
    to the corresponding Git repository.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.9 不同环境配置，基于需求。更现实的方法可以使用相同的集群为多个团队进行日常工作，而更敏感的环境，如预发布和生产，则在自己的集群和Git仓库中分离，以存储它们的配置。要将服务提升到新环境，需要向相应的Git仓库提交一个拉取请求。
- en: Okay, but how can we implement these pipelines? Should we implement these pipelines
    using Tekton? In the next section, we will look at Argo CD ([https://argo-cd.readthedocs.io/en/stable/](https://argo-cd.readthedocs.io/en/stable/)),
    a tool that has encoded the environment pipeline logic and best practices into
    a very specific tool for continuous deployment.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，但我们如何实现这些管道？我们应该使用Tekton来实现这些管道吗？在下一节中，我们将探讨Argo CD ([https://argo-cd.readthedocs.io/en/stable/](https://argo-cd.readthedocs.io/en/stable/))，这是一个将环境管道逻辑和最佳实践编码到非常具体的持续部署工具中的工具。
- en: 4.2 Environment pipelines in action
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.2 环境管道的实际应用
- en: You can implement an environment pipeline as described in the previous section
    using Tekton or Dagger. This has been done in projects like Jenkins X ([https://jenkins-x.io](https://jenkins-x.io)),
    but nowadays, the steps for an environment pipeline are encoded in specialized
    tools for continuous deployment like Argo CD ([https://argo-cd.readthedocs.io/en/stable/](https://argo-cd.readthedocs.io/en/stable/)).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用Tekton或Dagger实现如前所述的环境管道。这在像Jenkins X ([https://jenkins-x.io](https://jenkins-x.io))这样的项目中已经实现，但如今，环境管道的步骤被编码在像Argo
    CD ([https://argo-cd.readthedocs.io/en/stable/](https://argo-cd.readthedocs.io/en/stable/))这样的持续部署专用工具中。
- en: In contrast with service pipelines, where we might need specialized tools to
    build our artifacts depending on which technology stack we use, environment pipelines
    for Kubernetes are well-standardized today under the GitOps umbrella. Considering
    that all our artifacts are being built and published by our service pipelines,
    we first need to create our environment Git repository, which will contain the
    environment configuration, including the services deployed to that environment.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 与服务管道不同，我们可能需要根据所使用的特定技术栈使用专门的工具来构建我们的工件，Kubernetes的环境管道在GitOps的框架下已经得到了很好的标准化。考虑到所有我们的工件都是由我们的服务管道构建和发布的，我们首先需要创建我们的环境Git仓库，它将包含环境的配置，包括部署到该环境的服务。
- en: Argo CD provides a very opinionated but flexible GitOps implementation. We will
    delegate all the steps required to deploy software into our environments to Argo
    CD. Argo CD can out-of-the-box monitor a Git repository that contains our environment(s)
    configuration and periodically apply the configuration to a live cluster. This
    enables us to remove manual interactions with the target clusters, which reduces
    configuration drifts as Git becomes our source of truth.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Argo CD提供了一个非常具有意见但非常灵活的GitOps实现。我们将把将软件部署到我们的环境中所需的全部步骤委托给Argo CD。Argo CD可以开箱即用地监控包含我们的环境（们）配置的Git仓库，并定期将配置应用到实时集群。这使得我们能够减少与目标集群的手动交互，因为Git成为了我们的真相来源。
- en: Using tools like Argo CD allows us to declaratively define what we want to install
    in our environments, while Argo CD is in charge of notifying us when something
    goes wrong or our clusters are out of sync. Argo CD is not limited to a single
    cluster, meaning our environment can live in separate clusters, even in different
    cloud providers. Figure 4.10 shows Argo CD managing different environments on
    different clusters, using different Git repositories as the source of truth to
    keep the configuration of each environment.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 使用像Argo CD这样的工具允许我们声明性地定义我们想在环境中安装的内容，而Argo CD则负责在出现问题时或我们的集群不同步时通知我们。Argo CD不仅限于单个集群，这意味着我们的环境可以存在于不同的集群中，甚至在不同的云服务提供商中。图4.10显示了Argo
    CD在不同的集群上管理不同的环境，使用不同的Git仓库作为真相来源来保持每个环境的配置。
- en: '![](../../OEBPS/Images/04-10.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/04-10.png)'
- en: Figure 4.10 Argo CD will sync environments, configurations from Git to live
    clusters
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.10 Argo CD将同步环境，从Git到实时集群的配置
- en: In the same way that we now have separate service pipelines for each service,
    we can have separate repositories, branches, or directories to configure our environments.
    Argo CD can monitor repositories or directories inside repositories for changes
    to sync our environments configurations.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们现在为每个服务都有单独的服务管道一样，我们也可以为我们的环境配置拥有单独的仓库、分支或目录。Argo CD 可以监控仓库或仓库内部的目录，以同步我们的环境配置。
- en: We will install Argo CD in our Kubernetes cluster for this example and configure
    our staging environment using a GitOps approach. For that, we need a Git repository
    that serves as our source of truth. You can follow a step-by-step tutorial located
    at [https://github.com/salaboy/platforms-on-k8s/blob/main/chapter-4/README.md](https://github.com/salaboy/platforms-on-k8s/blob/main/chapter-4/README.md).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将安装 Argo CD 到我们的 Kubernetes 集群中，并使用 GitOps 方法配置我们的预发布环境。为此，我们需要一个 Git
    仓库作为我们的真相来源。你可以遵循位于 [https://github.com/salaboy/platforms-on-k8s/blob/main/chapter-4/README.md](https://github.com/salaboy/platforms-on-k8s/blob/main/chapter-4/README.md)
    的分步教程。
- en: For installing Argo CD, I recommend you check their Getting Started guide that
    you can find at [https://argo-cd.readthedocs.io/en/stable/getting_started/](https://argo-cd.readthedocs.io/en/stable/getting_started/).
    This guide installs all the components required for Argo CD to work, so after
    finishing this guide, we should have all we need to get our staging environment
    going. It also guides you through the installation of the `argocd` CLI (Command-Line
    Interface), which sometimes is very handy. In the following sections, we will
    focus on the user interface, but you can access the same functionality using the
    CLI. Argo CD comes with a very useful user interface that lets you monitor how
    your environments and applications are doing and quickly find out if there are
    any problems.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 对于安装 Argo CD，我建议你查看他们的入门指南，你可以在 [https://argo-cd.readthedocs.io/en/stable/getting_started/](https://argo-cd.readthedocs.io/en/stable/getting_started/)
    找到。此指南安装了 Argo CD 运作所需的所有组件，因此完成此指南后，我们应该拥有启动我们的预发布环境所需的一切。它还指导你安装 `argocd` CLI（命令行界面），这在某些情况下非常有用。在接下来的章节中，我们将关注用户界面，但你也可以使用
    CLI 访问相同的功能。Argo CD 提供了一个非常有用的用户界面，让你可以监控你的环境和应用程序的表现，并快速找出是否存在任何问题。
- en: The main objective of this section is to replicate what we did in section 2.1.3
    in chapter 2, where we installed and interacted with the application, but here
    we aim to fully automate the process for an environment that will be configured
    using a git repository. Once again, we will use Helm to define the environment
    configuration as Argo CD provides an out-of-the-box Helm integration.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的主要目标是复制我们在第 2 章第 2.1.3 节中做的事情，在那里我们安装并交互了应用程序，但在这里我们旨在完全自动化使用 git 仓库配置的环境的过程。再次，我们将使用
    Helm 来定义环境配置，因为 Argo CD 提供了开箱即用的 Helm 集成。
- en: Note Argo CD used a different nomenclature than the one we used here. In Argo
    CD you configure applications instead of environments. In the following screenshots,
    you will see that we will be configuring an Argo CD application to represent our
    staging environment. As there are no restrictions on what you can include in a
    Helm Chart, we will be using a Helm Chart to configure our Conference application
    into this environment.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：Argo CD 使用了与这里不同的命名约定。在 Argo CD 中，你配置应用程序而不是环境。在下面的屏幕截图中，你会看到我们将配置一个 Argo
    CD 应用程序来表示我们的预发布环境。由于 Helm 图表中没有包含内容的限制，我们将使用 Helm 图表来配置我们的会议应用程序到这个环境中。
- en: 4.2.1 Creating an Argo CD application
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.1 创建 Argo CD 应用程序
- en: If you access the Argo CD user interface, you will see right in the top left
    corner of the screen the + New App button (figure 4.11).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你访问 Argo CD 用户界面，你会在屏幕的左上角看到 + 新应用按钮（图 4.11）。
- en: '![](../../OEBPS/Images/04-11.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.11](../../OEBPS/Images/04-11.png)'
- en: Figure 4.11 Argo CD user interface—new application creation
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.11 Argo CD 用户界面—创建新应用程序
- en: Go ahead and hit that button to see the application creation form. Besides adding
    a name and selecting a Project where our Argo CD application will live (we will
    select the `default` project), we will check the `Auto-Create Namespace` option,
    as shown in figure 4.12.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 按下那个按钮，看看应用程序创建表单。除了添加一个名称并选择我们的 Argo CD 应用程序将驻留的项目（我们将选择 `default` 项目）外，我们还将检查
    `自动创建命名空间` 选项，如图 4.12 所示。
- en: '![](../../OEBPS/Images/04-12.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.12](../../OEBPS/Images/04-12.png)'
- en: Figure 4.12 New application parameters, manual sync, and auto-create namespace
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.12 新的应用参数、手动同步和自动创建命名空间
- en: By associating our environment with a new namespace in our cluster, we can only
    use the Kubernetes RBAC mechanism to allow administrators to modify the Kubernetes
    resources in that namespace. Remember that by using Argo CD, we want to ensure
    that developers don’t accidentally change the application configuration or manually
    apply configuration changes to the cluster. Argo CD will sync the resources defined
    in a Git repository. So where is that Git repository? That’s exactly what we need
    to configure next (figure 4.13).
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将我们的环境与集群中的新命名空间关联起来，我们只能使用Kubernetes RBAC机制来允许管理员修改该命名空间中的Kubernetes资源。记住，通过使用Argo
    CD，我们希望确保开发者不会意外更改应用程序配置或手动将配置更改应用到集群中。Argo CD将同步Git仓库中定义的资源。那么那个Git仓库在哪里？这正是我们需要配置的下一个步骤（图4.13）。
- en: '![](../../OEBPS/Images/04-13.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/04-13.png)'
- en: Figure 4.13 Argo CD application’s configuration repository, revision, and path
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.13 Argo CD应用的配置仓库、修订版本和路径
- en: As mentioned, we will use a directory inside the [https://github.com/salaboy/platforms-on-k8s/](https://github.com/salaboy/platforms-on-k8s/)
    repository to define our staging environment. You should fork this repository
    (and then use your fork URL) to make any changes you want to the environment configuration.
    The directory that contains the environment configuration can be found under chapter-4/argo-cd/staging/.
    As shown in figure 4.14, you can also select between different branches and tags,
    allowing you to have fine-grain control of where the configuration is coming from
    and how that configuration evolves.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们将在[https://github.com/salaboy/platforms-on-k8s/](https://github.com/salaboy/platforms-on-k8s/)仓库内部的一个目录中定义我们的预发布环境。你应该复制这个仓库（然后使用你的复制URL）来对环境配置进行任何你想要的更改。包含环境配置的目录可以在chapter-4/argo-cd/staging/下找到。如图4.14所示，你还可以在不同的分支和标签之间进行选择，这允许你对配置的来源和配置如何演变有更精细的控制。
- en: '![](../../OEBPS/Images/04-14.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/04-14.png)'
- en: Figure 4.14 Configuration destination, for this example, is the cluster where
    Argo CD is installed
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.14 配置目标，在本例中，是安装了Argo CD的集群
- en: The next step is to define where Argo CD will apply this environment configuration.
    We can use Argo CD to install and sync environments in different clusters, but
    for this example, we will be using the same Kubernetes cluster where we installed
    Argo CD and the `staging` namespace. There is an option for Argo CD to create
    this namespace for you, or you can create it manually when setting up the cluster
    and the permissions for different namespaces.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是定义Argo CD将应用此环境配置的位置。我们可以使用Argo CD在不同的集群中安装和同步环境，但在这个例子中，我们将使用我们安装Argo CD和`staging`命名空间的同一个Kubernetes集群。Argo
    CD有一个选项可以为你创建这个命名空间，或者你可以在设置集群和不同命名空间的权限时手动创建它。
- en: Finally, because it makes sense to reuse the same configuration for similar
    environments, Argo CD enables us to configure different parameters specific to
    this installation. Since we are using Helm and the Argo CD user interface is smart
    enough to scan the content of the repository/path we have entered, it knows it
    is dealing with a Helm Chart. If we were not using a Helm Chart, Argo CD allows
    us to set up environment variables as parameters for our configuration scripts
    (figure 4.15).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，由于在类似环境中重用相同的配置是有意义的，Argo CD使我们能够配置特定于此安装的不同参数。由于我们使用Helm，并且Argo CD用户界面足够智能，可以扫描我们输入的仓库/路径的内容，因此它知道它正在处理Helm
    Chart。如果我们没有使用Helm Chart，Argo CD允许我们为配置脚本设置环境变量作为参数（图4.15）。
- en: '![](../../OEBPS/Images/04-15.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/04-15.png)'
- en: Figure 4.15 Helm configuration parameters for the staging environment
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.15 预发布环境的Helm配置参数
- en: As you can see in the previous image, Argo CD also identified an empty values.yaml
    file inside the repository path that we have provided. If the values.yaml file
    had any parameters, the user interface will parse them and show them for you to
    validate. We can add more parameters to the `VALUES` text box to override any
    other chart (or sub-charts) configurations.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，Argo CD还识别出我们在提供的仓库路径内部的一个空的values.yaml文件。如果values.yaml文件有任何参数，用户界面将解析它们并显示给你进行验证。我们可以在`VALUES`文本框中添加更多参数来覆盖任何其他图表（或子图表）的配置。
- en: After we provide all this configuration, we are ready to hit the Create button
    at the top of the form. Argo CD will create the application and automatically
    sync the changes, as we selected the Automatic Sync option (figure 4.16).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们提供所有这些配置后，我们就可以点击表单顶部的创建按钮。Argo CD将创建应用程序并自动同步更改，因为我们选择了自动同步选项（图4.16）。
- en: '![](../../OEBPS/Images/04-16.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/04-16.png)'
- en: Figure 4.16 Application created and automatically synced
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.16 创建的应用程序和自动同步
- en: If you click into the application, you will drill down to the application’s
    full view, which shows you the state of all the resources associated with the
    application, as shown in figure 4.17.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你点击进入应用程序，你将深入到应用程序的完整视图，该视图显示了与应用程序关联的所有资源的状态，如图4.17所示。
- en: '![](../../OEBPS/Images/04-17.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/04-17.png)'
- en: Figure 4.17 Our staging environment is healthy, and all the services are running.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.17 我们的中转环境运行正常，所有服务都在运行。
- en: 'If you are creating the environment in a local cluster or a real Kubernetes
    cluster, you should access the application and interact with it. Let’s recap what
    we have achieved:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在一个本地集群或真实的Kubernetes集群中创建环境，你应该访问应用程序并与它交互。让我们回顾一下我们已经取得的成果：
- en: We have installed Argo CD into our Kubernetes cluster. Using the provided Argo
    CD Dashboard (user interface), we have created a new Argo CD application for our
    staging environment.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已经将Argo CD安装到我们的Kubernetes集群中。使用提供的Argo CD仪表板（用户界面），我们为我们的中转环境创建了一个新的Argo
    CD应用程序。
- en: We have created our staging environment configuration in a Git repository hosted
    in GitHub, which uses a Helm Chart definition to configure our Conference application
    services and their dependencies (Redis, PostgreSQL, and Kafka).
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在GitHub上托管的Git仓库中创建了我们的中转环境配置，该配置使用Helm Chart定义来配置我们的会议应用程序服务及其依赖项（Redis、PostgreSQL和Kafka）。
- en: We have synced the configuration to a namespace (`staging`) in the same cluster
    where we installed Argo CD.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已经将配置同步到了与安装Argo CD的同一集群中的命名空间（`staging`）。
- en: Most importantly, we have removed the need for manual interaction against the
    target cluster. Theoretically, there will be no need to execute `kubectl` against
    the `staging` namespace.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最重要的是，我们已经消除了与目标集群手动交互的需求。理论上，将不再需要针对`staging`命名空间执行`kubectl`命令。
- en: For this setup to work, we need to make sure that the artifacts that the Helm
    Charts (and the Kubernetes resources inside them) are available for the target
    cluster to pull. I strongly recommend you follow the step-by-step tutorial ([https://github.com/salaboy/platforms-on-k8s/tree/main/chapter-4](https://github.com/salaboy/platforms-on-k8s/tree/main/chapter-4))
    to get hands-on with Argo CD to understand how this tool works and how it can
    help your teams to continuously deploy their applications to multiple environments.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使此设置生效，我们需要确保Helm Charts（以及它们内部的Kubernetes资源）中的工件对目标集群可用以便拉取。我强烈建议你遵循逐步教程([https://github.com/salaboy/platforms-on-k8s/tree/main/chapter-4](https://github.com/salaboy/platforms-on-k8s/tree/main/chapter-4))，以亲身体验Argo
    CD，了解这个工具的工作原理以及它如何帮助你的团队将应用程序持续部署到多个环境中。
- en: 4.2.2 Dealing with changes the GitOps way
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.2 以GitOps方式处理更改
- en: Imagine now that the team in charge of developing the user interface (`frontend`)
    decides to introduce a new feature. They create a pull request to the `frontend`
    repository. Once this pull request is merged with the `main`, the team can decide
    to create a new release for the service. The release process should include the
    creation of tagged artifacts using the release number. The creation of these artifacts
    is the responsibility of the service pipeline, as we saw in previous sections.
    Figure 4.18 shows how Argo CD, in this case, syncs the configuration changes from
    the staging configuration repository.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 假设现在负责开发用户界面（`frontend`）的团队决定引入一个新功能。他们向`frontend`仓库提交了一个pull request。一旦这个pull
    request与`main`分支合并，团队就可以决定为服务创建一个新的版本。发布过程应包括使用发布号创建标记的工件。这些工件创建的责任属于服务管道，正如我们在前面的章节中看到的。图4.18显示了Argo
    CD在这种情况下如何同步从中转配置仓库的配置更改。
- en: '![](../../OEBPS/Images/04-18.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/04-18.png)'
- en: Figure 4.18 Components to set up the staging environment with Argo CD
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.18 使用Argo CD设置中转环境的组件
- en: 'Once we have the released artifacts, we can now update the environment. We
    can update the staging environment by submitting a pull request to our GitHub
    repository that can be reviewed before merging to the main branch, the branch
    we used to configure our Argo CD application. The changes in the environment configuration
    repository are going to be usually about:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了发布的工件，我们现在可以更新环境。我们可以通过向我们的 GitHub 仓库提交拉取请求来更新预发布环境，该请求在合并到主分支之前可以进行审查，主分支是我们用于配置
    Argo CD 应用程序的分支。环境配置存储库中的更改通常包括：
- en: '*Bumping up or reverting a service version:* For our example, this is as simple
    as changing the version of the chart of one or more services. Rolling back one
    of the services to the previous is as simple as reverting the version number in
    the environment chart or even reverting the commit that increased the version
    in the first place. Notice that reverting commits is always recommended, as rolling
    back to a previous version might also include configuration changes to the services
    that, if they are not applied, old versions might not work.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*提升或回滚服务版本：* 对于我们的示例，这就像更改一个或多个服务的图表版本一样简单。将其中一个服务回滚到上一个版本就像在环境图表中回退版本号，甚至回退最初增加版本号的提交。请注意，回退提交始终是推荐的，因为回滚到上一个版本可能还包括对服务的配置更改，如果这些更改未应用，旧版本可能无法工作。'
- en: '*Adding or removing a service:* Adding a new service is a bit more complicated,
    because you will need to add both the chart reference and the service configuration
    parameters. For this to work, the chart definition needs to be reachable by the
    Argo CD installation. Suppose the service(s)’ chart(s) are available, and the
    configuration parameters are valid. In that case, the next time we sync our Argo
    CD application, the new service(s) will be deployed to the environment. Removing
    services is more straightforward, because the moment you remove the dependency
    from the environment Helm Chart, the service will be removed from the environment.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*添加或删除服务：* 添加新服务稍微复杂一些，因为你需要添加图表引用和服务配置参数。为了使其工作，图表定义需要可通过 Argo CD 安装访问。假设服务（的）图表可用，配置参数有效。在这种情况下，下一次我们同步
    Argo CD 应用程序时，新的服务（们）将被部署到环境中。删除服务更为直接，因为一旦你从环境 Helm 图表中删除依赖项，服务将从环境中删除。'
- en: '*Tweaking charts parameters:* Sometimes, we don’t want to change any service
    version, and we might be trying to fine-tune the application parameters to accommodate
    performance or scalability requirements, monitoring configurations, or the log
    level for a set of services. These changes are also versioned and should be treated
    as new features and bug fixes.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*调整图表参数：* 有时，我们不想更改任何服务版本，我们可能正在尝试微调应用程序参数以适应性能或可扩展性要求、监控配置或一组服务的日志级别。这些更改也是版本化的，应被视为新功能和错误修复。'
- en: We will quickly notice the differences if we compare this with manually installing
    Helm to install the application into the cluster. First, a developer might have
    the environment configuration on their laptop, making the environment very difficult
    to replicate from a different location. Changes to the environment configuration
    that are not tracked using a version control system will be lost, and we will
    not have any way to verify whether these changes are working in a live cluster.
    Configuration drifts are much more difficult to track down and troubleshoot.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将此与手动安装 Helm 将应用程序安装到集群中进行比较，我们会很快注意到差异。首先，开发者可能在自己的笔记本电脑上拥有环境配置，这使得环境很难从不同位置复制。未使用版本控制系统跟踪的环境配置更改将会丢失，我们将无法验证这些更改是否在实时集群中工作。配置漂移的跟踪和故障排除要困难得多。
- en: This automated approach with Argo CD can open the door to more advanced scenarios.
    For example, we can create preview environments (figure 4.19) for our pull requests
    to test changes before they get merged and artifacts are released.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Argo CD 的这种自动化方法可以为更高级的场景打开大门。例如，我们可以为我们的拉取请求创建预览环境（图 4.19），以便在合并和发布工件之前测试更改。
- en: '![](../../OEBPS/Images/04-19.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/04-19.png)'
- en: Figure 4.19 Preview environments for faster iterations
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.19 预览环境以加快迭代
- en: Using preview environments can help iterate faster and enable teams to validate
    changes before merging them into the project’s main branch. Preview environments
    can also be notified when the pull request is merged, making an automated clean-up
    mechanism straightforward to implement.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 使用预览环境可以帮助更快地迭代，并使团队能在合并到项目的主要分支之前验证更改。当拉取请求合并时，预览环境也可以收到通知，这使得实现自动清理机制变得简单。
- en: NOTE Another important detail to mention when using Argo CD and Helm is that
    compared with using Helm Charts manually, where Helm will create release resources
    every time we update a chart in our cluster, Argo CD will not use this Helm feature.
    Argo CD takes the approach of using a Helm template to render the Kubernetes resources
    YAML, and then it applies the output using `kubectl apply`. This approach relies
    on the fact that everything is versioned in Git and allows the unification of
    different templating engines for YAML. In addition to some security benefits,
    this is key to enabling diffing in Argo CD, which allows us to specify which resources
    should be managed by Argo CD and which elements may be managed by different controllers.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在使用Argo CD和Helm时，还有一个重要的细节需要提及，那就是与手动使用Helm Charts相比，每次我们在集群中更新图表时，Helm都会创建发布资源，而Argo
    CD不会使用这个Helm功能。Argo CD采用使用Helm模板来渲染Kubernetes资源YAML的方法，然后使用`kubectl apply`应用输出。这种方法依赖于Git中的一切都是版本化的，并允许统一不同的YAML模板引擎。除了某些安全优势外，这是在Argo
    CD中启用diff功能的关键，它允许我们指定哪些资源应由Argo CD管理，哪些元素可能由不同的控制器管理。
- en: Finally, to tie things together, let’s see how service and environment pipelines
    interact to provide end-to-end automation, from code changes to deploying new
    versions into multiple environments.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了使事情更加连贯，让我们看看服务管道和环境管道是如何交互以提供端到端自动化，从代码更改到将新版本部署到多个环境。
- en: 4.3 Service + environment pipelines
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.3 服务+环境管道
- en: Let’s look at how service pipelines and environment pipeline connect. The connection
    between these two pipelines happens via pull/change requests to Git repositories,
    because the pipelines will be triggered when changes are submitted and merged
    (figure 4.20).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看服务管道和环境管道是如何连接的。这两个管道之间的连接是通过Git仓库的拉取/更改请求来实现的，因为当提交和合并更改时，管道将被触发（图4.20）。
- en: '![](../../OEBPS/Images/04-20.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图4.20](../../OEBPS/Images/04-20.png)'
- en: Figure 4.20 A service pipeline can trigger an environment pipeline via a pull
    request.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.20 一个服务管道可以通过拉取请求触发环境管道。
- en: Developers, when they finish a new feature, create a pull/change request to
    the repository’s main branch. This pull/change request can be reviewed and built
    by a specialized service pipeline. When this new feature is merged into the repository’s
    main branch, a new instance of the service pipeline is triggered. This instance
    creates a new release and all the artifacts needed to deploy the service’s new
    version into a Kubernetes cluster. As we saw in chapter 3, this includes a binary
    with the compiled source code, a container image, and Kubernetes Manifests that
    can be packaged using tools like Helm.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者完成一个新功能后，会向仓库的主要分支创建一个拉取/更改请求。这个拉取/更改请求可以被专门的服务管道审查和构建。当这个新功能合并到仓库的主要分支时，会触发一个新的服务管道实例。这个实例创建一个新的发布，以及部署服务新版本到Kubernetes集群所需的所有工件。正如我们在第3章中看到的，这包括一个包含编译源代码的二进制文件、一个容器镜像以及可以使用Helm等工具打包的Kubernetes
    Manifests。
- en: As the last step of the service pipeline, you can include a notification step
    that can notify the interested environments that there is a new version of a service
    that they are running available. This notification is usually an automated pull/change
    request into the environment’s repository. Alternatively, you monitor (or subscribe
    to notifications) your artifact repositories, and when a new version is detected,
    a pull/change request is created to the configured environments.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 作为服务管道的最后一步，你可以包含一个通知步骤，该步骤可以通知感兴趣的运行环境，它们正在运行的服务有新版本可用。这种通知通常是一个自动的拉取/更改请求到环境的仓库。或者，你可以监控（或订阅通知）你的工件仓库，当检测到新版本时，就会创建一个拉取/更改请求到配置的环境。
- en: The pull/change requests created to environment repositories can be automatically
    tested by a specialized environment pipeline. In the same way as we did with service
    pipelines, and for low-risk environments, these pull/change requests can be automatically
    merged without any human intervention.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 为环境仓库创建的拉取/变更请求可以由专门的环境管道自动测试。与我们对服务管道所做的方式相同，对于低风险环境，这些拉取/变更请求可以自动合并，无需任何人工干预。
- en: By implementing this flow, we can enable developers to focus on fixing bugs
    and creating new features that will be automatically released and promoted to
    low-risk environments. Once the new versions are tested in environments like staging,
    and we know that these new versions or configurations are not causing any problems,
    a pull/change request can be created for the repository that contains the production
    environment configuration.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实施此流程，我们可以让开发者专注于修复错误和创建新功能，这些功能将自动发布并推广到低风险环境。一旦新版本在预发布等环境中经过测试，并且我们知道这些新版本或配置没有引起任何问题，就可以为包含生产环境配置的仓库创建拉取/变更请求。
- en: The more sensitive the environments are, the more required checks and validations.
    In this case, as shown in figure 4.21, to promote a new service version to the
    production environment, a new test environment will be created to validate and
    test the changes introduced in the pull/change request submitted. Once those validations
    are done, a manual sign-off is required to merge the pull request and trigger
    the environment pipeline synchronization.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 环境越敏感，所需的检查和验证就越多。在这种情况下，如图4.21所示，要将新服务版本推送到生产环境，需要创建一个新的测试环境来验证和测试在提交的拉取/变更请求中引入的更改。一旦完成这些验证，就需要手动签核以合并拉取请求并触发环境管道同步。
- en: '![](../../OEBPS/Images/04-21.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/04-21.png)'
- en: Figure 4.21 Promoting changes to the production environment
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.21 推送到生产环境的更改
- en: Environment pipelines are the mechanism you use to encode your organization’s
    requirements to release and promote software to different environments. We have
    seen in this chapter what a tool like Argo CD can do for us. Next, we need to
    evaluate if a single Argo CD installation would be enough and who will manage
    it and keep it secure. Do you need to extend Argo CD with custom hook points?
    Do you need to integrate it with other tools? We will explore these questions
    in chapter 6, so before closing this chapter, let’s look at how environment pipelines
    and tools like Argo CD fit into the platform engineering story.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 环境管道是您用来编码组织需求以将软件发布和推广到不同环境的机制。在本章中，我们已经看到了像Argo CD这样的工具能为我们做什么。接下来，我们需要评估单个Argo
    CD安装是否足够，以及谁将负责管理和保持其安全性。您是否需要通过自定义钩点扩展Argo CD？您是否需要将其与其他工具集成？我们将在第6章探讨这些问题，因此在结束本章之前，让我们看看环境管道和像Argo
    CD这样的工具如何融入平台工程的故事。
- en: 4.4 Linking back to platform engineering
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.4 回到平台工程
- en: From a platform engineering perspective, providing a GitOps approach is becoming
    increasingly popular for teams to configure different environments. With the popularity
    of tools like Argo CD, more people feel comfortable storing and manipulating environment
    configurations on version control systems like Git. As a platform engineering
    team, you can enable your teams to use this approach without pushing them to learn
    how to install, maintain, and configure these tools.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 从平台工程的角度来看，为团队提供GitOps方法正变得越来越流行，以便配置不同的环境。随着像Argo CD这样的工具的普及，越来越多的人对在版本控制系统（如Git）上存储和操作环境配置感到舒适。作为平台工程团队，您可以使团队能够使用这种方法，而无需强迫他们学习如何安装、维护和配置这些工具。
- en: Platforms can automate the creation of environment repositories and make sure
    that the right teams have access to read and write configurations to promote services.
    Consumers of these platforms are expected to know how to interact with their environments,
    but not how the tools provided by the platform work or how they are configured.
    There are cases, for example, in development environments, where using a GitOps
    approach might not work, because some development teams will want direct access
    to clusters, and your platform should be flexible enough to allow this access
    when needed.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 平台可以自动化创建环境仓库，并确保正确的团队有权读取和写入配置以推广服务。这些平台的消费者预计知道如何与其环境交互，但不知道平台提供的工具是如何工作或如何配置的。例如，在开发环境中，使用GitOps方法可能不起作用，因为某些开发团队可能希望直接访问集群，而您的平台应该足够灵活，以便在需要时允许这种访问。
- en: As discussed in section 4.3, service and environment pipelines work hand in
    hand to produce software artifacts and move them between environments. Both service
    and environment pipelines are key mechanisms to get in place to implement what
    is known as golden paths. The more mature your platform becomes, the coordination
    between environment pipelines becomes essential to automate how your new software
    releases go from source to production environments and are validated by your end
    users (customers). These golden paths are automated workflows to move the changes
    that our teams are producing to our production environments where customers will
    be able to access them. Figure 4.22 shows from a high level what a golden path
    looks like for our applications.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如第 4.3 节所述，服务和环境管道协同工作，生成软件工件并在环境之间移动。服务和环境管道是实现所谓的黄金路径的关键机制。随着平台日益成熟，环境管道之间的协调变得至关重要，以自动化新软件发布从源到生产环境的过程，并经过最终用户（客户）的验证。这些黄金路径是自动化工作流程，将我们团队产生的更改移动到我们的生产环境中，以便客户能够访问它们。图
    4.22 从高层次展示了我们的应用程序的黄金路径是什么样的。
- en: '![](../../OEBPS/Images/04-22.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.22](../../OEBPS/Images/04-22.png)'
- en: Figure 4.22 What does it take to promote new releases to our production environments?
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.22 将新版本提升到我们的生产环境需要哪些步骤？
- en: Think about how many service and environment pipelines will need to be executed
    to take the software produced in our development environments to our production
    clusters, where customers can access the release of a single service. How are
    these pipelines coordinated and wired to ensure our deployments work as expected?
    How many manual verifications do you need in this whole process? And most importantly,
    what can you automate for your teams not to worry about all these complex interactions?
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一下需要执行多少服务和环境管道才能将我们在开发环境中产生的软件带到我们的生产集群中，客户可以访问单个服务的发布。这些管道是如何协调和连接的，以确保我们的部署按预期工作？在整个过程中你需要进行多少手动验证？最重要的是，你能为你的团队自动化哪些内容，以便他们不必担心所有这些复杂的交互？
- en: So far, we have covered how to install an application into a Kubernetes cluster,
    build and package the application services into containers, and package and distribute
    the configuration files needed to deploy these services into a Kubernetes cluster.
    This chapter adds to the picture of how to manage different environments where
    this application will run using a GitOps approach. Figure 4.23 shows all the pieces
    together.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经介绍了如何将应用程序安装到 Kubernetes 集群中，构建和打包应用程序服务到容器中，以及打包和分发部署这些服务到 Kubernetes
    集群所需的配置文件。本章补充了如何使用 GitOps 方法管理应用程序将运行的不同环境的情况。图 4.23 展示了所有部件的组合。
- en: '![](../../OEBPS/Images/04-23.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.23](../../OEBPS/Images/04-23.png)'
- en: Figure 4.23 Adding GitOps to manage multiple environments
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.23 将 GitOps 添加到管理多个环境
- en: 'Before digging deeper into golden paths (in chapter 6), we must explore one
    more challenge we face when we deploy our applications to different environments:
    application infrastructure, in the next chapter.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入探讨黄金路径（第 6 章）之前，我们必须探索我们在将应用程序部署到不同环境时面临的另一个挑战：应用基础设施，下一章将介绍。
- en: Summary
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Environment pipelines are responsible for deploying software artifacts to live
    environments. Environment pipelines avoid teams interacting directly with the
    cluster where the applications run, reducing errors and misconfigurations. Environment
    pipelines should check that environments are fully operational after updating
    their configuration.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 环境管道负责将软件工件部署到实际环境中。环境管道避免团队直接与运行应用程序的集群交互，从而减少错误和配置错误。环境管道应在更新其配置后检查环境是否完全运行。
- en: Using tools like Argo CD, you can define the content of each environment into
    a Git repository that is used as the source of truth for what the environment
    configuration should look like. Argo CD will keep track of the state of the cluster
    where the environment is running and ensure no drift in the configuration applied
    in the cluster.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用像 Argo CD 这样的工具，你可以将每个环境的内容定义到一个 Git 仓库中，该仓库用作环境配置应如何看起来的事实来源。Argo CD 将跟踪运行环境所在集群的状态，并确保在集群中应用配置时没有漂移。
- en: Teams can upgrade or downgrade the versions of the services running in an environment
    by submitting pull/change requests to the repository where the environment configuration
    is stored. A team or an automated process can validate these changes, and when
    approved and merged, these changes will be reflected in the live environment.
    Changes can be rolled back if things go wrong by reverting commits to the git
    repository.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 团队可以通过向存储环境配置的仓库提交拉取/更改请求来升级或降级环境中运行的服务版本。一个团队或自动化流程可以验证这些更改，一旦获得批准并合并，这些更改将在实际环境中体现。如果出现问题，可以通过回滚git仓库中的提交来回滚更改。
- en: If you followed the step-by-step tutorial, you got hands-on experience on how
    to deploy application workloads following a GitOps approach by using Argo CD.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你遵循了逐步教程，你将获得通过使用Argo CD采用GitOps方法部署应用程序工作负载的动手经验。
