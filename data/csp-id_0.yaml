- en: Part 1\. C# in context
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第一部分\. C#的背景
- en: When I was studying computer science at university, a fellow student corrected
    the lecturer about a detail he’d written on the blackboard. The lecturer looked
    mildly exasperated and answered, “Yes, I know. I was simplifying. I’m obscuring
    the truth here to demonstrate a bigger truth.” Although I hope I’m not obscuring
    much in [part 1](#part01), it’s definitely about the bigger truth.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当我在大学学习计算机科学时，一位同学纠正了讲师在黑板上写的细节。讲师显得有些不耐烦，回答说：“是的，我知道。我在简化。我在这里掩盖真相是为了展示更大的真相。”虽然我希望我在[第一部分](#part01)中并没有太多地掩盖真相，但它确实关乎更大的真相。
- en: Most of this book looks at C# close up, occasionally putting it under a microscope
    to see the finest details. Before we start doing that, [chapter 1](kindle_split_015_split_000.html#ch01)
    pulls back the lens to see the broader sweep of the history of C# and how C# fits
    into the wider context of computing.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的大部分内容都近距离地审视C#，偶尔将其置于显微镜下以观察最细微的细节。在我们开始这样做之前，[第一章](kindle_split_015_split_000.html#ch01)将镜头拉远，以查看C#的历史和C#在更广泛的计算背景中的位置。
- en: You’ll see some code as an appetizer before I serve the main course of the rest
    of the book, but the details don’t matter at this stage. This part is more about
    the ideas and themes of C#’s development to get you in the best frame of mind
    to appreciate how those ideas are implemented.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在我提供本书其余部分的主要内容之前，您将看到一些代码作为开胃菜，但在这个阶段细节并不重要。这部分更多地关于C#的发展理念和主题，以使您处于最佳心态来欣赏这些想法是如何实现的。
- en: Let’s go!
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们出发吧！
- en: Chapter 1\. Survival of the sharpest
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第一章\. 最敏锐者的生存
- en: '|  |'
  id: totrans-6
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**This chapter covers**'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '**本章涵盖**'
- en: How C#’s rapid evolution has made developers more productive
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C#的快速进化如何使开发者更加高效
- en: Selecting minor versions of C# to use the latest features
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择C#的次要版本以使用最新功能
- en: Being able to run C# in more environments
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够在更多环境中运行C#
- en: Benefitting from an open and engaged community
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从一个开放和积极参与的社区中受益
- en: The book’s focus on old and new C# versions
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本书关注旧版和新版C#版本
- en: '|  |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Choosing the most interesting aspects of C# to introduce here was difficult.
    Some are fascinating but are rarely used. Others are incredibly important but
    are now commonplace to C# developers. Features such as async/await are great in
    many ways but are hard to describe briefly. Without further ado, let’s look at
    how far C# has come over time.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 选择在这里介绍C#最有趣的部分是有难度的。有些部分非常迷人但很少使用。其他部分极其重要，但对C#开发者来说现在已经司空见惯。例如，async/await这样的功能在很多方面都很出色，但很难简要描述。无需多言，让我们看看C#随着时间的推移走了多远。
- en: 1.1\. An evolving language
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.1\. 一个不断发展的语言
- en: In previous editions of this book, I provided a single example that showed the
    evolution of the language over the versions covered by that edition. That’s no
    longer feasible in a way that would be interesting to read. Although a large application
    may use almost all of the new features, any single piece of code that’s suitable
    for the printed page would use only a subset of them.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的前几版中，我提供了一个示例，展示了该版所涵盖的语言版本的演变。但这种方式已经不再可行，因为它的阅读体验不再有趣。尽管大型应用程序可能使用几乎所有的新功能，但任何适合印刷页面的单个代码片段可能只会使用其中的一小部分。
- en: Instead, in this section I choose what I consider to be the most important themes
    of C# evolution and give brief examples of improvements. This is far from an exhaustive
    list of features. It’s also not intended to teach you the features; instead, it’s
    a reminder of how far features you already know about have improved the language
    and a tease for features you may not have seen yet.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，在这一节中，我选择了我认为C#进化中最重要的一些主题，并给出了改进的简要示例。这远非一个详尽无遗的功能列表。这也不是为了教你这些功能；相反，它是对你已知的功能如何改进语言的一个提醒，以及对你可能尚未见过的功能的诱惑。
- en: If you think some of these features imitate other languages you’re familiar
    with, you’re almost certainly right. The C# team does not hesitate to take great
    ideas from other languages and reshape them to feel at home within C#. This is
    a great thing! F# is particularly worth mentioning as a source of inspiration
    for many C# features.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您认为其中一些功能模仿了您熟悉的其他语言，您几乎肯定是对的。C#团队毫不犹豫地从其他语言中汲取伟大的想法，并将它们重塑以在C#中感到舒适。这是一件好事！F#特别值得提及，它是许多C#功能的灵感来源。
- en: '|  |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-20
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: It’s possible that F#’s greatest impact isn’t what it enables for F# developers
    but its influence on C#. This isn’t to underplay the value of F# as a language
    in its own right or to suggest that it shouldn’t be used directly. But currently,
    the C# community is significantly larger than the F# community, and the C# community
    owes a debt of gratitude to F# for inspiring the C# team.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 有可能F#最大的影响不是它为F#开发者带来的能力，而是它对C#的影响。这并不是要低估F#作为一门语言的价值，或者暗示它不应该直接使用。但当前，C#社区比F#社区大得多，C#社区对F#团队表示感激之情，因为F#启发了C#团队。
- en: '|  |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Let’s start with one of the most important aspects of C#: its type system.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从C#最重要的一个方面开始：其类型系统。
- en: 1.1.1\. A helpful type system at large and small scales
  id: totrans-24
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.1.1. 大规模和小规模的有用类型系统
- en: 'C# has been a statically typed language from the start: your code specifies
    the types of variables, parameters, values returned from methods, and so on. The
    more precisely you can specify the shape of the data your code accepts and returns,
    the more the compiler can help you avoid mistakes.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: C#从一开始就是一种静态类型语言：你的代码指定了变量的类型、参数、方法返回的值等等。你越能精确地指定代码接受和返回的数据形状，编译器就越能帮助你避免错误。
- en: That’s particularly true as the application you’re building grows. If you can
    see all the code for your whole program on one screen (or at least hold it all
    in your head at one time), a statically typed language doesn’t have much benefit.
    As the scale increases, it becomes increasingly important that your code concisely
    and effectively communicates what it does. You can do that through documentation,
    but static typing lets you communicate in a machine-readable way.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这尤其适用于你构建的应用程序增长时。如果你能在单屏上看到整个程序的所有代码（或者至少一次能将它们全部记在脑海中），静态类型语言的好处就不大了。随着规模的增加，你的代码简洁有效地传达其功能变得越来越重要。你可以通过文档来实现这一点，但静态类型让你能够以机器可读的方式传达信息。
- en: 'As C# has evolved, its type system has allowed more fine-grained descriptions.
    The most obvious example of this is *generics*. In C# 1, you might have had code
    like this:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 随着C#的发展，其类型系统允许更精细的描述。最明显的例子是*泛型*。在C# 1中，你可能会有这样的代码：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'What type is each item in the `Books` sequence? The type system doesn’t tell
    you. With generics in C# 2, you can communicate more effectively:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`Books`序列中的每个项目是什么类型？类型系统不会告诉你。在C# 2中，通过泛型你可以更有效地沟通：'
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: C# 2 also brought *nullable value types*, thereby allowing the absence of information
    to be expressed effectively without resorting to magic values such as –1 for a
    collection index or `DateTime.MinValue` for a date.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: C# 2也引入了*可空值类型*，从而允许有效地表达信息的缺失，而无需依赖于像集合索引的-1或日期的`DateTime.MinValue`这样的魔法值。
- en: C# 7 gave us the ability to tell the compiler that a user-defined struct should
    be immutable using `readonly struct` declarations. The primary goal for this feature
    may have been to improve the efficiency of the code generated by the compiler,
    but it has additional benefits for communicating intent.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: C# 7为我们提供了使用`readonly struct`声明来告诉编译器用户定义的结构应该是不可变的能力。这个特性的主要目标可能是提高编译器生成的代码的效率，但它对传达意图也有额外的益处。
- en: 'The plans for C# 8 include *nullable reference types*, which will allow even
    more communication. Up to this point, nothing in the language lets you express
    whether a reference (either as a return value, a parameter, or just a local variable)
    might be null. This leads to error-prone code if you’re not careful and boilerplate
    validation code if you are careful, neither of which is ideal. C# 8 will expect
    that anything not explicitly nullable is intended not to be nullable. For example,
    consider a method declaration like this:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: C# 8的计划包括*可空引用类型*，这将允许更多的沟通。到目前为止，语言中没有任何东西让你表达一个引用（无论是作为返回值、参数还是局部变量）可能为null。如果你不小心，这会导致错误代码；如果你小心，则会导致样板验证代码，这两种情况都不理想。C#
    8将期望任何未明确指定为可空的项都不是可空的。例如，考虑以下方法声明：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The parameter types indicate that the argument corresponding to `x` shouldn’t
    be null but that the argument corresponding to `y` may be null. The return type
    indicates that the method won’t return null.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 参数类型表明与`x`对应的参数不应该为null，而与`y`对应的参数可能为null。返回类型表明该方法不会返回null。
- en: 'Other changes to the type system in C# are aimed at a smaller scale and focus
    on how one method might be implemented rather than how different components in
    a large system relate to each other. C# 3 introduced *anonymous types* and *implicitly
    typed local variables* (`var`). These help address the downside of some statically
    typed languages: verbosity. If you need a particular data shape within a single
    method but nowhere else, creating a whole extra type just for the sake of that
    method is overkill. Anonymous types allow that data shape to be expressed concisely
    without losing the benefits of static typing:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: C# 类型系统的其他更改旨在更小的规模上，并关注一个方法可能如何实现，而不是大型系统中的不同组件如何相互关联。C# 3 引入了 *匿名类型* 和 *隐式类型局部变量*
    (`var`)。这些有助于解决某些静态类型语言的缺点：冗长。如果你需要在单个方法内使用特定的数据形状，但其他地方不需要，只为该方法创建一个全新的类型就过于冗余了。匿名类型允许以简洁的方式表达这种数据形状，同时不失去静态类型的好处：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '***1* Name and type are still checked by the compiler**'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 名称和类型仍然由编译器检查**'
- en: Anonymous types are primarily used within LINQ queries, but the principle of
    creating a type just for a single method doesn’t depend on LINQ.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名类型主要用于 LINQ 查询，但创建仅用于单个方法的类型的原理并不依赖于 LINQ。
- en: 'Similarly, it seems redundant to explicitly specify the type of a variable
    that is initialized in the same statement by calling the constructor of that type.
    I know which of the following declarations I find cleaner:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，似乎没有必要显式指定通过调用该类型的构造函数初始化的变量的类型。我知道以下哪种声明我觉得更简洁：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '***1* Explicit typing**'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 显式类型**'
- en: '***2* Implicit typing**'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 隐式类型**'
- en: Although implicit typing is necessary when working with anonymous types, I’ve
    found it increasingly useful when working with regular types, too. It’s important
    to distinguish between *implicit* typing and *dynamic* typing. The preceding `map2`
    variable is still statically typed, but you didn’t have to write the type explicitly.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在处理匿名类型时需要隐式类型，但我发现它在处理常规类型时也越来越有用。区分 *隐式* 类型化和 *动态* 类型化很重要。前面的 `map2` 变量仍然是静态类型化的，但你不必显式编写类型。
- en: 'Anonymous types help only within a single block of code; for example, you can’t
    use them as method parameters or return types. C# 7 introduced *tuples*: value
    types that effectively act to collect variables together. The framework support
    for these tuples is relatively simple, but additional language support allows
    the elements of tuples to be named. For example, instead of the preceding anonymous
    type, you could use the following:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名类型仅在单个代码块内有所帮助；例如，你不能将它们用作方法参数或返回类型。C# 7 引入了 *元组*：一种有效收集变量的值类型。这些元组的框架支持相对简单，但额外的语言支持允许为元组的元素命名。例如，你可以在前面的匿名类型之外使用以下方式：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Tuples can replace anonymous types in some cases but certainly not all. One
    of their benefits is that they *can* be used as method parameters and return types.
    At the moment, I advise that these be kept within the internal API of a program
    rather than exposed publicly, because tuples represent a simple composition of
    values rather than encapsulating them. That’s why I still regard them as contributing
    to simpler code at the implementation level rather than improving overall program
    design.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，元组可以替代匿名类型，但并非所有情况。它们的其中一个好处是，*可以*用作方法参数和返回类型。目前，我建议将这些保留在程序的内部 API 中，而不是公开暴露，因为元组代表的是值的简单组合，而不是封装它们。这就是为什么我仍然认为它们在实现层面上有助于编写更简单的代码，而不是改进整体程序设计。
- en: 'I should mention a feature that *might* come in C# 8: *record types*. I think
    of these as named anonymous types to some extent, at least in their simplest form.
    They’d provide the benefits of anonymous types in terms of removing boilerplate
    code but then allow those types to gain extra behavior just as regular classes
    do. Watch this space!'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我应该提到一个可能在 C# 8 中出现的特性：*记录类型*。我认为这在某种程度上可以被视为命名的匿名类型，至少在其最简单的形式中。它们将提供匿名类型在移除样板代码方面的好处，但允许这些类型获得与常规类相同的行为。请关注这个领域！
- en: 1.1.2\. Ever more concise code
  id: totrans-49
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.1.2\. 代码更加简洁
- en: One of the recurring themes within new features of C# has been the ability to
    let you express your ideas in ways that are increasingly concise. The type system
    is part of this, as you’ve seen with anonymous types, but many other features
    also contribute to this. There are lots of words you might hear for this, especially
    in terms of what can be removed with the new features in place. C#’s features
    allow you to reduce *ceremony*, remove *boilerplate* code, and avoid *cruft*.
    These are just different ways of talking about the same effect. It’s not that
    any of the now-redundant code was wrong; it was just distracting and unnecessary.
    Let’s look at a few ways that C# has evolved in this respect.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 的新特性中，一个反复出现的主题一直是让你能够以越来越简洁的方式表达你的想法。类型系统是其中的一部分，正如你通过匿名类型所看到的，但许多其他特性也对此做出了贡献。你可能会听到很多关于这个话题的词汇，尤其是在使用新特性可以移除的内容方面。C#
    的特性允许你减少 *仪式感*，移除 *样板代码*，并避免 *冗余*。这只是对同一效果的不同的描述方式。并不是说现在多余的代码有什么错误；它只是分散注意力且不必要的。让我们看看
    C# 在这方面的一些演变方式。
- en: Construction and initialization
  id: totrans-51
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 构造和初始化
- en: 'First, we’ll consider how you create and initialize objects. Delegates have
    probably evolved the most and in multiple stages. In C# 1, you had to write a
    separate method for the delegate to refer to and then create the delegate itself
    in a long-winded way. For example, here’s what you’d write to subscribe a new
    event handler to a button’s `Click` event in C# 1:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将考虑如何创建和初始化对象。委托可能经历了最大的演变，并且是多阶段的。在 C# 1 中，你必须为委托编写一个单独的方法来引用，然后以冗长的方式创建委托本身。例如，在
    C# 1 中，你会这样编写代码来订阅一个新的事件处理器到按钮的 `Click` 事件：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '***1* C# 1**'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* C# 1**'
- en: 'C# 2 introduced *method group conversions* and *anonymous methods*. If you
    wanted to keep the `HandleButtonClick` method, method group conversions would
    allow you to change the preceding code to the following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: C# 2 引入了 *方法组转换* 和 *匿名方法*。如果你想保留 `HandleButtonClick` 方法，方法组转换将允许你将前面的代码更改为以下内容：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '***1* C# 2**'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* C# 2**'
- en: 'If your click handler is simple, you might not want to bother with a separate
    method at all and instead use an anonymous method:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的点击处理器很简单，你可能根本不想使用单独的方法，而是使用匿名方法：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '***1* C# 2**'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* C# 2**'
- en: 'Anonymous methods have the additional benefit of acting as *closures*: they
    can use local variables in the context within which they’re created. They’re not
    used often in modern C# code, however, because C# 3 provided us with *lambda expressions*,
    which have almost all the benefits of anonymous methods but shorter syntax:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名方法还有一个额外的优点，可以作为 *闭包* 使用：它们可以使用创建它们的上下文中的局部变量。然而，在现代 C# 代码中，它们并不常用，因为 C# 3
    提供了 *lambda 表达式*，它几乎具有匿名方法的所有优点，但语法更简洁：
- en: '[PRE9]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '***1* C# 3**'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* C# 3**'
- en: '|  |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-65
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: 'In this case, the lambda expression is longer than the anonymous method because
    the anonymous method uses the one feature that lambda expressions don’t have:
    the ability to ignore parameters by not providing a parameter list.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，lambda 表达式比匿名方法更长，因为匿名方法使用了 lambda 表达式没有的一个特性：通过不提供参数列表来忽略参数的能力。
- en: '|  |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: I used event handlers as an example for delegates because that was their main
    use in C# 1\. In later versions of C#, delegates are used in more varied situations,
    particularly in LINQ.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用事件处理器作为委托的例子，因为在 C# 1 中，委托的主要用途就是作为事件处理器。在 C# 的后续版本中，委托被用于更多样化的场景，尤其是在 LINQ
    中。
- en: 'LINQ also brought other benefits for initialization in the form of *object
    initializers* and *collection initializers*. These allow you to specify a set
    of properties to set on a new object or items to add to a new collection within
    a single expression. It’s simpler to show than describe, and I’ll borrow an example
    from [chapter 3](kindle_split_018_split_000.html#ch03). Consider code that you
    might previously have written like this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: LINQ 还通过 *对象初始化器* 和 *集合初始化器* 的形式带来了初始化的其他好处。这些允许你在单个表达式中指定要设置在新对象上的属性集或要添加到新集合中的项目。这比描述起来更简单，我将借用
    [第 3 章](kindle_split_018_split_000.html#ch03) 中的一个示例。考虑你可能之前这样编写的代码：
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The object and collection initializers introduced in C# 3 make this so much
    clearer:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: C# 3 引入的对象和集合初始化器使这一点更加清晰：
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: I don’t suggest reading either of these examples in detail; what’s important
    is the simplicity of the second form over the first.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我不建议详细阅读这两个示例；重要的是第二种形式比第一种形式的简单性。
- en: Method and property declarations
  id: totrans-74
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 方法和属性声明
- en: 'One of the most obvious examples of simplification is through *automatically
    implemented properties*. These were first introduced in C# 3 but have been further
    improved in later versions. Consider a property that would’ve been implemented
    in C# 1 like this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 简化的最明显例子之一是通过**自动实现属性**。这些属性最初在 C# 3 中引入，但在后续版本中得到了进一步改进。考虑一个在 C# 1 中可能这样实现的属性：
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Automatically implemented properties allow this to be written as a single line:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 自动实现属性允许将其写为单行：
- en: '[PRE13]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Additionally, C# 6 introduced *expression-bodied members* that remove more
    ceremony. Suppose you’re writing a class that wraps an existing collection of
    strings, and you want to effectively delegate the `Count` and `GetEnumerator()`
    members of your class to that collection. Prior to C# 6, you would’ve had to write
    something like this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，C# 6 引入了**表达式主体成员**，这减少了更多的仪式。假设您正在编写一个包装现有字符串集合的类，并且您希望有效地将您类的 `Count` 和
    `GetEnumerator()` 成员委托给该集合。在 C# 6 之前，您可能需要编写如下内容：
- en: '[PRE14]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This is a strong example of ceremony: a lot of syntax that the language used
    to require with little benefit. In C# 6, this is significantly cleaner. The `=>`
    syntax (already used by lambda expressions) is used to indicate an expression-bodied
    member:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个仪式的强烈例子：语言曾经要求的大量语法，而好处却很少。在 C# 6 中，这变得更加简洁。使用 `=>` 语法（已经被 lambda 表达式使用）来指示表达式主体成员：
- en: '[PRE15]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Although the value of using expression-bodied members is a personal and subjective
    matter, I’ve been surprised by just how much difference they’ve made to the readability
    of my code. I love them! Another feature I hadn’t expected to use as much as I
    now do is string interpolation, which is one of the string-related improvements
    in C#.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然使用表达式主体成员的价值是个人和主观的，但我对它们对我的代码可读性带来的影响感到惊讶。我爱它们！另一个我没有预料到会像现在这样频繁使用的功能是字符串插值，这是
    C# 中与字符串相关的改进之一。
- en: String handling
  id: totrans-84
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 字符串处理
- en: 'String handling in C# has had three significant improvements:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: C# 中的字符串处理经历了三项重大改进：
- en: C# 5 introduced *caller information attributes*, including the ability for the
    compiler to automatically populate method and filenames as parameter values. This
    is great for diagnostic purposes, whether in permanent logging or more temporary
    testing.
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C# 5 引入了**调用者信息属性**，包括编译器自动将方法和文件名作为参数值填充的能力。这对于诊断目的非常有用，无论是永久性日志记录还是更临时的测试。
- en: C# 6 introduced the `nameof` operator, which allows names of variables, types,
    methods, and other members to be represented in a refactoring-friendly form.
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C# 6 引入了 `nameof` 操作符，它允许变量、类型、方法和其他成员以重构友好的形式表示。
- en: C# 6 also introduced *interpolated string literals*. This isn’t a new concept,
    but it makes constructing a string with dynamic values much simpler.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C# 6 也引入了**插值字符串字面量**。这不是一个新概念，但它使得使用动态值构造字符串变得更加简单。
- en: For the sake of brevity, I’ll demonstrate just the last point. It’s reasonably
    common to want to construct a string with variables, properties, the result of
    method calls, and so forth. This might be for logging purposes, user-oriented
    error messages (if localization isn’t required), exception messages, and so forth.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁起见，我将仅演示最后一点。构造包含变量、属性、方法调用结果等字符串的情况相当常见。这可能是用于日志记录目的、面向用户的错误消息（如果不需要本地化），异常消息等。
- en: 'Here’s an example from my Noda Time project. Users can try to find a calendar
    system by its ID, and the code throws a `KeyNotFoundException` if that ID doesn’t
    exist. Prior to C# 6, the code might have looked like this:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个来自我的 Noda Time 项目的例子。用户可以尝试通过其 ID 查找一个日历系统，如果该 ID 不存在，代码将抛出 `KeyNotFoundException`。在
    C# 6 之前，代码可能看起来像这样：
- en: '[PRE16]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Using explicit string formatting, it looks like this:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 使用显式字符串格式化，它看起来像这样：
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '|  |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-95
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: See [section 1.4.2](kindle_split_015_split_000.html#ch01lev2sec8) for information
    about Noda Time. You don’t need to know about it to understand this example.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 Noda Time 的信息，请参阅[第 1.4.2 节](kindle_split_015_split_000.html#ch01lev2sec8)。您不需要了解它就能理解这个示例。
- en: '|  |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'In C# 6, the code becomes just a little simpler with an interpolated string
    literal to include the value of `id` in the string directly:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 6 中，通过插值字符串字面量直接包含 `id` 的值，代码变得更加简洁：
- en: '[PRE18]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This doesn’t look like a big deal, but I’d hate to have to work without string
    interpolation now.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来可能不是什么大问题，但我现在真的很讨厌没有字符串插值工作。
- en: 'These are just the most prominent features that help improve the signal-to-noise
    ratio of your code. I could’ve shown `using static` directives and the null conditional
    operator in C# 6 as well as pattern matching, deconstruction, and out variables
    in C# 7\. Rather than expand this chapter to mention every feature in every version,
    let’s move on to a feature that’s more revolutionary than evolutionary: LINQ.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是帮助提高代码信号与噪声比的最显著特性。我本可以展示 C# 6 中的 `using static` 指令和空条件运算符，以及 C# 7 中的模式匹配、解构和
    out 变量。而不是将本章扩展到提及每个版本中的每个特性，让我们继续到一个比进化更革命性的特性：LINQ。
- en: 1.1.3\. Simple data access with LINQ
  id: totrans-102
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.1.3\. 使用 LINQ 进行简单数据访问
- en: 'If you ask C# developers what they love about C#, they’ll likely mention LINQ.
    You’ve already seen some of the features that build up to LINQ, but the most radical
    is query expressions. Consider this code:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你询问 C# 开发者他们喜欢 C# 的哪些地方，他们很可能会提到 LINQ。你已经看到了一些构建 LINQ 的特性，但最激进的特性是查询表达式。考虑以下代码：
- en: '[PRE19]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: That doesn’t look anything like old-school C#. Imagine traveling back to 2007
    to show that code to a developer using C# 2 and then explaining that this has
    compile-time checking and IntelliSense support and that it results in an efficient
    database query. Oh, and that you can use the same syntax for regular collections
    as well.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来与传统的 C# 完全不同。想象一下回到 2007 年，向一个使用 C# 2 的开发者展示这段代码，并解释说这具有编译时检查和 IntelliSense
    支持，并且可以高效地执行数据库查询。哦，你还可以使用相同的语法来处理常规集合。
- en: Support for querying out-of-process data is provided via *expression trees*.
    These represent code as data, and a LINQ provider can analyze the code to convert
    it into SQL or other query languages. Although this is extremely cool, I rarely
    use it myself, because I don’t work with SQL databases often. I do work with in-memory
    collections, though, and I use LINQ all the time, whether through query expressions
    or method calls with lambda expressions.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 *表达式树* 提供了对进程外数据的查询支持。这些表示代码为数据，LINQ 提供商可以分析代码将其转换为 SQL 或其他查询语言。尽管这非常酷，但我自己很少使用它，因为我很少与
    SQL 数据库打交道。不过，我确实处理内存中的集合，并且我经常使用 LINQ，无论是通过查询表达式还是使用 lambda 表达式的方法调用。
- en: LINQ didn’t just give C# developers new tools; it encouraged us to think about
    data transformations in a new way based on functional programming. This affects
    more than data access. LINQ provided the initial impetus to take on more functional
    ideas, but many C# developers have embraced those ideas and taken them further.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: LINQ 不仅为 C# 开发者提供了新的工具；它还鼓励我们以函数式编程为基础，以新的方式思考数据转换。这不仅仅影响数据访问。LINQ 提供了初步的动力去接受更多的函数式思想，但许多
    C# 开发者已经接受了这些思想并将它们进一步发展。
- en: C# 4 made a radical change in terms of dynamic typing, but I don’t think that
    affected as many developers as LINQ. Then C# 5 came along and changed the game
    again, this time with respect to asynchrony.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: C# 4 在动态类型方面进行了激进的变化，但我认为这并没有影响到像 LINQ 那样多的开发者。然后 C# 5 出现了，再次改变了游戏规则，这次是关于异步的。
- en: 1.1.4\. Asynchrony
  id: totrans-109
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.1.4\. 异步
- en: 'Asynchrony has been difficult in mainstream languages for a long time. More
    niche languages have been created with asynchrony in mind from the start, and
    some functional languages have made it relatively easy as just one of the things
    they handle neatly. But C# 5 brought a new level of clarity to programming asynchrony
    in a mainstream language with a feature usually referred to as *async/await*.
    The feature consists of two complementary parts around async methods:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 异步编程在主流语言中一直是个难题。一些从一开始就考虑异步的语言已经创建出来，而一些函数式语言则使它相对容易，因为它们可以很好地处理它。但 C# 5 通过通常称为
    *async/await* 的特性，为主流语言中的异步编程带来了新的清晰度。这个特性包括围绕异步方法的两个互补部分：
- en: Async methods produce a result representing an asynchronous operation with no
    effort on the part of the developer. This result type is usually `Task` or `Task<T>`.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步方法无需开发者做任何努力就能产生表示异步操作的结果。这个结果类型通常是 `Task` 或 `Task<T>`。
- en: Async methods use await expressions to consume asynchronous operations. If the
    method tries to await an operation that hasn’t completed yet, the method pauses
    asynchronously until the operation completes and then continues.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步方法使用 await 表达式来消费异步操作。如果方法尝试等待尚未完成的操作，方法将异步暂停，直到操作完成然后继续。
- en: '|  |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-114
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: More properly, I could call these asynchronous *functions,* because anonymous
    methods and lambda expressions can be asynchronous, too.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 更确切地说，我可以把这些称为异步 *函数*，因为匿名方法和 lambda 表达式也可以是异步的。
- en: '|  |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Exactly what’s meant by *asynchronous operation* and *pausing asynchronously*
    is where things become tricky, and I won’t attempt to explain this now. But the
    upshot is that you can write code that’s asynchronous but looks mostly like the
    synchronous code you’re more familiar with. It even allows for concurrency in
    a natural way. As an example, consider this asynchronous method that might be
    called from a Windows Forms event handler:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '*异步操作*和*异步暂停*的确切含义是事情变得复杂的地方，我现在不会尝试解释这一点。但结果是，你可以编写看起来主要像你更熟悉的同步代码的异步代码。它甚至以自然的方式允许并发。作为一个例子，考虑这个可能从Windows
    Forms事件处理器调用的异步方法：'
- en: '[PRE20]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '***1* Starts two operations concurrently**'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 同时启动两个操作**'
- en: '***2* Asynchronously waits for them to complete**'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 异步等待它们完成**'
- en: '***3* Updates the userinterface**'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 更新用户界面**'
- en: In addition to starting two operations concurrently and then awaiting their
    results, this demonstrates how async/await is aware of synchronization contexts.
    You’re updating the user interface, which can be done only in a UI thread, despite
    also starting and waiting for long-running operations. Before async/await, this
    would’ve been complex and error prone.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 除了同时启动两个操作并等待它们的结果之外，这还展示了async/await如何了解同步上下文。你正在更新用户界面，这只能在UI线程中完成，尽管也在启动和等待长时间运行的操作。在async/await之前，这将会很复杂且容易出错。
- en: I don’t claim that async/await is a silver bullet for asynchrony. It doesn’t
    magically remove all the complexity that naturally comes with the territory. Instead,
    it lets you focus on the inherently difficult aspects of asynchrony by taking
    away a lot of the boilerplate code that was previously required.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我不声称async/await是异步问题的银弹。它并不能神奇地消除随之而来的所有复杂性。相反，它通过移除之前所需的大量样板代码，让你能够专注于异步固有的困难方面。
- en: All of the features you’ve seen so far aim to make code simpler. The final aspect
    I want to mention is slightly different.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 你迄今为止看到的所有功能都是为了使代码更简单。我想提到的最后一个方面略有不同。
- en: 1.1.5\. Balancing efficiency and complexity
  id: totrans-125
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.1.5\. 平衡效率和复杂性
- en: I remember my first experiences with Java; it was entirely interpreted and painfully
    slow. After a while, optional just-in-time (JIT) compilers became available, and
    eventually it was taken almost for granted that any Java implementation would
    be JIT-compiled.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我记得我第一次接触Java的经历；它完全是解释执行的，速度慢得令人痛苦。过了一段时间，可选的即时编译器（JIT）变得可用，最终几乎可以想当然地认为任何Java实现都会进行JIT编译。
- en: Making Java perform well took a lot of effort. This effort wouldn’t have happened
    if the language had been a flop. But developers saw the potential and already
    felt more productive than they had before. Speed of development and delivery can
    often be more important than application speed.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让Java表现良好需要付出很多努力。如果这种语言失败了，这种努力就不会发生。但开发者看到了潜力，并且已经感觉比以前更有效率。开发速度和交付速度往往比应用程序速度更重要。
- en: C# was in a slightly different situation. The Common Language Runtime (CLR)
    was pretty efficient right from the start. The language support for easy interop
    with native code and for performance-sensitive unsafe code with pointers helps,
    too. C# performance continues to improve over time. (I note with a wry smile that
    Microsoft is now introducing tiered JIT compilation broadly like the Java HotSpot
    JIT compiler.)
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: C#处于一个稍微不同的位置。公共语言运行时（CLR）从一开始就相当高效。语言对与本地代码轻松互操作以及性能敏感的不安全代码的支持也有帮助。C#的性能随着时间的推移持续改进。（我带着一丝苦笑指出，微软现在正在广泛引入分层JIT编译，就像Java
    HotSpot JIT编译器一样。）
- en: But different workloads have different performance demands. As you’ll see in
    [section 1.2](kindle_split_015_split_000.html#ch01lev1sec2), C# is now in use
    across a surprising variety of platforms, including gaming and microservices,
    both of which can have difficult performance requirements.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 但不同的工作负载有不同的性能需求。正如你将在[第1.2节](kindle_split_015_split_000.html#ch01lev1sec2)中看到的那样，C#现在被用于各种令人惊讶的平台，包括游戏和微服务，这两者都可能对性能有很高的要求。
- en: Asynchrony helps address performance in some situations, but C# 7 is the most
    overtly performance-sensitive release. Read-only structs and a much larger surface
    area for `ref` features help to avoid redundant copying. The `Span<T>` feature
    present in modern frameworks and supported by ref-like struct types reduces unnecessary
    allocation and garbage collection. The hope is clearly that when used carefully,
    these techniques will cater to the requirements of specific developers.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 异步有助于在某些情况下提高性能，但C# 7是最明显关注性能的发布。只读结构和更大的`ref`特性表面面积有助于避免冗余复制。现代框架中存在的`Span<T>`特性，以及由类似ref的结构类型支持的特性，有助于减少不必要的分配和垃圾回收。显然，希望当这些技术被谨慎使用时，它们将满足特定开发者的需求。
- en: I have a slight sense of unease around these features, as they still feel complex
    to me. I can’t reason about a method using an `in` parameter as clearly as I can
    about regular value parameters, and I’m sure it will take a while before I’m comfortable
    with what I can and can’t do with ref locals and ref returns.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我对这些特性有一丝不安的感觉，因为它们对我来说仍然感觉复杂。我无法像对常规值参数那样清晰地推理使用`in`参数的方法，并且我相信在适应我可以和不能使用ref局部变量和ref返回值之前，还需要一段时间。
- en: My hope is that these features will be used in moderation. They’ll simplify
    code in situations that benefit from them, and they will no doubt be welcomed
    by the developers who maintain that code. I look forward to experimenting with
    these features in personal projects and becoming more comfortable with the balance
    between improved performance and increased code complexity.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望这些特性能够适度使用。它们会在有利的情境中简化代码，无疑会受到维护这些代码的开发者的欢迎。我期待在个人项目中尝试这些特性，并更加适应性能提升和代码复杂度之间的平衡。
- en: 'I don’t want to sound this note of caution too loudly. I suspect the C# team
    made the right choice to include the new features regardless of how much or little
    I’ll use them in my work. I just want to point out that you don’t have to use
    a feature just because it’s there. Make your decision to opt into complexity a
    conscious one. Speaking of opting in, C# 7 brought a new meta-feature to the table:
    the use of minor version numbers for the first time since C# 1.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我不想过于强调这个警告。我怀疑C#团队在包含新特性时做出了正确的选择，无论我在工作中使用它们的频率高低。我只是想指出，你不必仅仅因为某个特性存在就使用它。做出选择加入复杂性的决定应该是经过深思熟虑的。说到选择加入，C#
    7带来了一个新的元特性：自C# 1以来首次使用次要版本号。
- en: '1.1.6\. Evolution at speed: Using minor versions'
  id: totrans-134
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.1.6. 快速演变：使用次要版本
- en: 'The set of version numbers for C# is an odd one, and it is complicated by the
    fact that many developers get understandably confused between the framework and
    the language. (There’s no C# 3.5, for example. The .NET Framework version 3.0
    shipped with C# 2, and .NET 3.5 shipped with C# 3.) C# 1 had two releases: C#
    1.0 and C# 1.2\. Between C# 2 and C# 6 inclusive, there were only major versions
    that were usually backed by a new version of Visual Studio.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: C#的版本号集合是奇怪的，而且由于许多开发者可能会在框架和语言之间产生混淆，这使得问题更加复杂。（例如，没有C# 3.5。.NET Framework
    3.0与C# 2一起发布，.NET 3.5与C# 3一起发布。）C# 1有两个发布版本：C# 1.0和C# 1.2。在C# 2和C# 6（包括）之间，只有通常由Visual
    Studio新版本支持的次要版本。
- en: 'C# 7 bucked that trend: there were releases of C# 7.0, C# 7.1, C# 7.2, and
    C# 7.3, which were all available in Visual Studio 2017\. I consider it highly
    likely that this pattern will continue in C# 8\. The aim is to allow new features
    to evolve quickly with user feedback. The majority of C# 7.1–7.3 features have
    been tweaks or extensions to the features introduced in C# 7.0.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: C# 7打破了这一趋势：有C# 7.0、C# 7.1、C# 7.2和C# 7.3的发布，这些版本都在Visual Studio 2017中可用。我认为这种模式在C#
    8中很可能继续。目标是允许新特性快速地根据用户反馈进行演变。C# 7.1–7.3的大多数特性都是对C# 7.0中引入特性的调整或扩展。
- en: Volatility in language features can be disconcerting, particularly in large
    organizations. A lot of infrastructure may need to be changed or upgraded to make
    sure the new language version is fully supported. A lot of developers may learn
    and adopt new features at different paces. If nothing else, it can be a little
    uncomfortable for the language to change more often than you’re used to.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 语言特性的波动可能会让人感到不安，尤其是在大型组织中。许多基础设施可能需要改变或升级，以确保新语言版本得到全面支持。许多开发者可能以不同的速度学习和采用新特性。如果其他什么都没有，那么语言比你习惯的更频繁地改变可能会让人感到有些不舒服。
- en: 'For this reason, the C# compiler defaults to using the earliest minor version
    of the latest major version it supports. If you use a C# 7 compiler and don’t
    specify any language version, it will restrict you to C# 7.0 by default. If you
    want to use a later minor version, you need to specify that in your project file
    and opt into the new features. You can do this in two ways, although they have
    the same effect. You can edit your project file directly to add a `<LangVersion>`
    element in a `<PropertyGroup>`, like this:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，C# 编译器默认使用它支持的最新主要版本的最早次版本。如果你使用 C# 7 编译器并且没有指定任何语言版本，它将默认限制你使用 C# 7.0。如果你想使用更晚的次版本，你需要在项目文件中指定它并选择新功能。你可以通过两种方式来做这件事，尽管它们的效果相同。你可以直接编辑你的项目文件，在
    `<PropertyGroup>` 中添加一个 `<LangVersion>` 元素，如下所示：
- en: '[PRE21]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '***1* Other properties**'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 其他属性**'
- en: '***2* Specifies the language version of the project**'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 指定项目的语言版本**'
- en: If you don’t like editing project files directly, you can go to the project
    properties in Visual Studio, select the Build tab, and then click the Advanced
    button at the bottom right. The Advanced Build Settings dialog box, shown in [figure
    1.1](kindle_split_015_split_000.html#ch01fig01), will open to allow you to select
    the language version you wish to use and other options.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不喜欢直接编辑项目文件，你可以转到 Visual Studio 中的项目属性，选择“生成”选项卡，然后单击右下角的“高级”按钮。将打开高级生成设置对话框，如[图
    1.1](kindle_split_015_split_000.html#ch01fig01)所示，允许你选择希望使用的语言版本和其他选项。
- en: Figure 1.1\. Language version settings in Visual Studio
  id: totrans-143
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 1.1\. Visual Studio 中的语言版本设置
- en: '![](../Images/01fig01_alt.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/01fig01_alt.jpg)'
- en: 'This option in the dialog box isn’t new, but you’re more likely to want to
    use it now than in previous versions. The values you can select are as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 对话框中的此选项并非新功能，但现在你更有可能想要使用它，比之前的版本更频繁。你可以选择以下值：
- en: '*default*—The first release of the latest major version'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*默认*—最新主要版本的第一个发布版本'
- en: '*latest*—The latest version'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*最新版*—最新版本'
- en: '*A specific version number*—For example, 7.0 or 7.3'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*特定版本号*—例如，7.0 或 7.3'
- en: This doesn’t change the version of the compiler you run; it changes the set
    of language features available to you. If you try to use something that isn’t
    available in the version you’re targeting, the compiler error message will usually
    explain which version is required for that feature. If you try to use a language
    feature that’s entirely unknown to the compiler (using C# 7 features with a C#
    6 compiler, for example), the error message is usually less clear.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这不会改变你运行的编译器的版本；它改变的是你可以使用的语言功能集。如果你尝试使用在你目标版本中不可用的功能，编译器错误信息通常会解释需要哪个版本才能使用该功能。如果你尝试使用编译器完全不了解的语言功能（例如，使用
    C# 7 功能与 C# 6 编译器），错误信息通常不太明确。
- en: C# as a language has come a long way since its first release. What about the
    platform it runs on?
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: C# 作为一种语言，自从其首次发布以来已经走得很远了。那么它所运行的平台呢？
- en: 1.2\. An evolving platform
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.2\. 一个不断发展的平台
- en: The last few years have been exhilarating for .NET developers. A certain amount
    of frustration exists as well, as both Microsoft and the .NET community come to
    terms with the implications of a more open development model. But the overall
    result of the hard work by so many people is remarkable.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，.NET 开发者感到非常兴奋。同时，也存在一定程度的挫折感，因为微软和 .NET 社区都在逐步接受更加开放的开发模式的影响。但这么多人的辛勤工作所带来的整体成果是显著的。
- en: For many years, running C# code would almost always mean running on Windows.
    It would usually mean either a client-side app written in Windows Forms or Windows
    Presentation Foundation (WPF) or a server-side app written with ASP.NET and probably
    running behind Internet Information Server (IIS). Other options have been available
    for a long time, and the Mono project in particular has a rich history, but the
    mainstream of .NET development was still on Windows.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，运行 C# 代码几乎总是意味着在 Windows 上运行。这通常意味着一个用 Windows Forms 或 Windows Presentation
    Foundation (WPF) 编写的客户端应用程序，或者一个用 ASP.NET 编写的服务器端应用程序，可能运行在 Internet Information
    Server (IIS) 后面。其他选项已经存在很长时间了，特别是 Mono 项目有着丰富的历史，但 .NET 开发的主流仍然是在 Windows 上。
- en: As I write this in June 2018, the .NET world is very different. The most prominent
    development is .NET Core, a runtime and framework that is portable and open source,
    is fully supported by Microsoft on multiple operating systems, and has streamlined
    development tooling. Only a few years ago, that would’ve been unthinkable. Add
    to that a portable and open source IDE in the form of Visual Studio Code, and
    you get a flourishing .NET ecosystem with developers working on all kinds of local
    platforms and then deploying to all kinds of server platforms.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当我在 2018 年 6 月写下这些内容时，.NET 世界已经非常不同。最显著的发展是 .NET Core，这是一个可移植且开源的运行时和框架，由微软在多个操作系统上全面支持，并具有简化的开发工具。仅在几年前，这还是不可想象的。再加上一个可移植且开源的
    IDE，即 Visual Studio Code，你将得到一个繁荣的 .NET 生态系统，开发者们在各种本地平台上工作，然后将它们部署到各种服务器平台上。
- en: It would be a mistake to focus too heavily on .NET Core and ignore the many
    other ways C# runs these days. Xamarin provides a rich multiplatform mobile experience.
    Its GUI framework (Xamarin Forms) allows developers to create user interfaces
    that are fairly uniform across different devices where that’s appropriate but
    that can take advantage of the underlying platform, too.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 过分关注 .NET Core 并忽视 C# 当今运行的其他许多方式将会是一个错误。Xamarin 提供了丰富的多平台移动体验。其 GUI 框架（Xamarin
    Forms）允许开发者创建在不同设备上相当统一但也能利用底层平台的用户界面。
- en: Unity is one of the most popular game-development platforms in the world. With
    a customized Mono runtime and ahead-of-time compilation, it can provide challenges
    to C# developers who are used to more-traditional runtime environments. But for
    many developers, this is their first or perhaps their only experience with the
    language.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 是世界上最受欢迎的游戏开发平台之一。它拥有定制的 Mono 运行时和即时编译，可以为习惯于更传统运行时环境的 C# 开发者提供挑战。但对于许多开发者来说，这可能是他们第一次，也许也是他们唯一一次使用这种语言的经验。
- en: These widely adopted platforms are far from the only ones making C#. I’ve recently
    been working with Try .NET and Blazor for very different forms of browser/C# interaction.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这些广泛采用的平台远非唯一使用 C# 的平台。我最近一直在使用 Try .NET 和 Blazor 进行不同形式的浏览器/C# 交互。
- en: Try .NET allows users to write code in a browser, with autocompletion, and then
    build and run that code. It’s great for experimenting with C# with a barrier to
    entry that’s about as low as it can be.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试 .NET 允许用户在浏览器中编写代码，具有自动完成功能，然后构建并运行该代码。这对于用尽可能低的门槛进行 C# 实验来说非常棒。
- en: Blazor is a platform for running Razor pages directly in a browser. These aren’t
    pages rendered by a server and then displayed in the browser; the user-interface
    code runs within the browser using a version of the Mono runtime converted into
    Web-Assembly. The idea of a whole runtime executing Intermediate Language (IL)
    via the JavaScript engine in a browser, not only on full computers but also on
    mobile phones, would’ve struck me as absurd just a few years ago. I’m glad other
    developers have more imagination. A lot of the innovation in this space has been
    made possible only by a more collaborative and open community than ever before.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Blazor 是一个可以在浏览器中直接运行 Razor 页面的平台。这些页面不是由服务器渲染并在浏览器中显示的；用户界面代码是在浏览器中运行的，使用的是将
    Mono 运行时转换为 Web-Assembly 的版本。几年前，整个运行时通过浏览器中的 JavaScript 引擎执行中间语言 (IL)，不仅在全功能计算机上，而且在手机上，这个想法在我看来是荒谬的。我很高兴其他开发者有更多的想象力。在这个领域的大部分创新都得益于比以往任何时候都更加协作和开放的社区。
- en: 1.3\. An evolving community
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.3. 一个不断发展的社区
- en: I’ve been involved in the C# community since the C# 1.0 days, and I’ve never
    seen it as vibrant as it is today. When I started using C#, it was very much seen
    as an “enterprise” programming language, and there was relatively little sense
    of fun and exploration.^([[1](kindle_split_015_split_000.html#ch01fn1)]) With
    that background, the open source C# ecosystem grew fairly slowly compared with
    other languages, including Java, which was also considered an enterprise language.
    Around the time of C# 3, the alt.NET community was looking beyond the mainstream
    of .NET development, and this was seen as being against Microsoft in some senses.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我从 C# 1.0 时代就参与了 C# 社区，我从未见过它像今天这样充满活力。当我开始使用 C# 时，它被视为一种“企业”编程语言，而且相对较少有乐趣和探索的感觉。[^1](kindle_split_015_split_000.html#ch01fn1)
    在这种背景下，与 Java（也被视为一种企业语言）相比，开源的 C# 生态系统增长相当缓慢。在 C# 3 时代，alt.NET 社区正在超越 .NET 开发的主流，这在某些意义上被视为与微软对抗。
- en: ¹
  id: totrans-162
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-163
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Don’t get me wrong; it was a pleasant community to be part of, and there have
    always been people experimenting with C# for fun.
  id: totrans-164
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 请不要误解；这是一个令人愉快的社区，而且一直有人为了乐趣而尝试C#。
- en: In 2010, the NuGet (initially NuPack) package manager was launched, which made
    it much easier to produce and consume class libraries, whether commercial or open
    source. Even though the barrier of downloading a zip file, copying a DLL into
    somewhere appropriate, and then adding a reference to it doesn’t sound hugely
    significant, every point of friction can put developers off.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 2010年，NuGet（最初为NuPack）包管理器被推出，这使得生产和使用类库（无论是商业的还是开源的）变得更加容易。尽管下载zip文件、将DLL复制到适当的位置，然后添加引用似乎并不特别重要，但每一个摩擦点都可能让开发者望而却步。
- en: '|  |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-167
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Package managers other than NuGet were developed even earlier, and the OpenWrap
    project developed by Sebastien Lambla was particularly influential.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 除了NuGet之外，其他包管理器早在之前就已经开发出来，由Sebastien Lambla开发的OpenWrap项目尤其有影响力。
- en: '|  |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Fast-forward to 2014, and Microsoft announced that its Roslyn compiler platform
    was going to become open source under the umbrella of the new .NET Foundation.
    Then .NET Core was announced under the initial codename Project K; DNX came later,
    followed by the .NET Core tooling that’s now released and stable. Then came ASP.NET
    Core. And Entity Framework Core. And Visual Studio Code. The list of products
    that truly live and breathe on GitHub goes on.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 快进到2014年，微软宣布其Roslyn编译器平台将成为新的.NET基金会的开源项目。随后宣布了.NET Core，最初代号为Project K；DXN随后出现，然后是现在发布和稳定的.NET
    Core工具集。接着是ASP.NET Core。还有Entity Framework Core。还有Visual Studio Code。真正在GitHub上生存和发展的产品名单还在继续。
- en: The technology has been important, but the new embrace of open source by Microsoft
    has been equally vital for a healthy community. Third-party open source packages
    have blossomed, including innovative uses for Roslyn and integrations within .NET
    Core tooling that just feel right.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 技术很重要，但微软对开源的新拥抱对于健康社区同样至关重要。第三方开源包蓬勃发展，包括对Roslyn的创新使用和.NET Core工具集内的集成，这些都感觉恰到好处。
- en: None of this has happened in a vacuum. The rise of cloud computing makes .NET
    Core even more important to the .NET ecosystem than it would’ve been otherwise;
    support for Linux isn’t optional. But because .NET Core is available, there’s
    now nothing special about packaging up an ASP.NET Core service in a Docker image,
    deploying it with Kubernetes, and using it as just one part of a larger application
    that could involve many languages. The cross-pollination of good ideas between
    many communities has always been present, but it is stronger than ever right now.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都不是在真空中发生的。云计算的兴起使得.NET Core比其他情况下对.NET生态系统更加重要；对Linux的支持不是可选项。但由于.NET Core的可用性，现在将ASP.NET
    Core服务打包到Docker镜像中、使用Kubernetes部署，并将其用作一个可能涉及多种语言的大型应用程序的一部分，已经不再特殊。许多社区之间优秀思想的交叉融合一直存在，但现在比以往任何时候都要强烈。
- en: You can learn C# in a browser. You can run C# anywhere. You can ask questions
    about C# on Stack Overflow and myriad other sites. You can join in the discussion
    about the future of the language on the C# team’s GitHub repository. It’s not
    perfect; we still have collective work to do in order to make the C# community
    as welcoming as it possibly can be for everyone, but we’re in a great place already.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在浏览器中学习C#。你可以在任何地方运行C#。你可以在Stack Overflow和其他众多网站上询问有关C#的问题。你可以在C#团队的GitHub仓库中参与关于语言未来的讨论。它并不完美；我们仍然需要共同努力，以便让C#社区尽可能对每个人开放，但我们已经处于一个非常好的位置。
- en: I’d like to think that *C# in Depth* has its own small place in the C# community,
    too. How has this book evolved?
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望认为*C#深入理解*在C#社区中也有自己的一席之地。这本书是如何演变的？
- en: 1.4\. An evolving book
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.4. 一本不断演变的书
- en: You’re reading the fourth edition of *C# in Depth*. Although the book hasn’t
    evolved at the same pace as the language, platform, or community, it also has
    changed. This section will help you understand what is covered in this book.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 你正在阅读*C#深入理解*的第四版。尽管这本书的演变速度没有语言、平台或社区快，但它也发生了变化。本节将帮助你了解这本书涵盖了哪些内容。
- en: 1.4.1\. Mixed-level coverage
  id: totrans-177
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.4.1. 混合级别覆盖
- en: The first edition of *C# in Depth* came out in April 2008, which was coincidentally
    the same time that I joined Google. Back then, I was aware that a lot of developers
    knew C# 1 fairly well, but they were picking up C# 2 and C# 3 as they went along
    without a firm grasp of how all the pieces fit together. I aimed to address that
    gap by diving into the language at a depth that would help readers understand
    not only what each feature did but why it was designed that way.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 《C# 深入》的第一版于 2008 年 4 月出版，这恰好是我加入谷歌的时间。当时，我知道很多开发者对 C# 1 比较熟悉，但他们边走边学 C# 2 和
    C# 3，并没有牢固地掌握所有部分是如何结合在一起的。我旨在通过深入语言来填补这一空白，帮助读者不仅理解每个特性做了什么，还理解为什么是这样设计的。
- en: Over time, the needs of developers change. It seems to me that the community
    has absorbed a deeper understanding of the language almost by osmosis, at least
    for earlier versions. Attaining deeper understanding of the language won’t be
    a universal experience, but for the fourth edition, I wanted the emphasis to be
    on the newer versions. I still think it’s useful to understand the evolution of
    the language version by version, but there’s less need to look at every detail
    of the features in C# 2–4.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，开发者的需求会发生变化。在我看来，社区似乎通过渗透作用几乎自然而然地吸收了对语言的更深入理解，至少对于早期版本来说是这样。对语言的深入理解不会是每个人的普遍体验，但对于第四版来说，我希望重点放在新版本上。我仍然认为理解语言版本的演变是有用的，但不需要查看
    C# 2–4 中每个特性的每一个细节。
- en: '|  |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-181
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Looking at the language one version at a time isn’t the best way to learn the
    language from scratch, but it’s useful if you want to understand it deeply. I
    wouldn’t use the same structure to write a book for C# beginners.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 逐个版本地查看语言并不是从头学习语言的最佳方式，但如果你想深入理解它，这很有用。我不会用同样的结构来为 C# 初学者写一本书。
- en: '|  |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: I’m also not keen on thick books. I don’t want *C# in Depth* to be intimidating,
    hard to hold, or hard to write in. Keeping 400 pages of coverage for C# 2–4 just
    didn’t feel right. For that reason, I’ve compressed my coverage of those versions.
    Every feature is mentioned, and I go into detail where I feel it’s appropriate,
    but there’s less depth than in the third edition. Use the coverage in the fourth
    edition as a review of topics you already know and to help you determine topics
    you want to read more about in the third edition. You can find a link to access
    an electronic copy of the third edition at [www.manning.com/books/c-sharp-in-depth-fourth-edition](http://www.manning.com/books/c-sharp-in-depth-fourth-edition).
    Versions 5–7 of the language are covered in more detail in this edition. Asynchrony
    is still a tough topic to understand, and the third edition obviously doesn’t
    cover C# 6 or 7 at all.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我也不喜欢厚重的书籍。我不想让《C# 深入》显得令人畏惧、难以把握或难以书写。仅仅为了涵盖 C# 2–4 的 400 页内容似乎并不合适。因此，我对这些版本的内容进行了压缩。每个特性都被提及，我在认为合适的地方进行了详细说明，但深度不如第三版。你可以使用第四版的内容来回顾你已经了解的主题，并帮助你确定在第三版中想要了解更多信息的话题。你可以在
    [www.manning.com/books/c-sharp-in-depth-fourth-edition](http://www.manning.com/books/c-sharp-in-depth-fourth-edition)
    找到访问第三版电子版链接。本版详细介绍了语言 5–7 版本。异步仍然是一个难以理解的话题，第三版显然完全没有涵盖 C# 6 或 7。
- en: Writing, like software engineering, is often a balancing act. I hope the balance
    I’ve struck between detail and brevity works for you.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 写作，就像软件工程一样，通常是一种平衡的艺术。我希望我在细节和简洁之间找到的平衡能对你有所帮助。
- en: '|  |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-187
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you have a physical copy of this book, I strongly encourage you to write
    in it. Make note of places where you disagree or parts that are particularly useful.
    The act of doing this will reinforce the content in your memory, and the notes
    will serve as reminders later.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你拥有这本书的实体副本，我强烈建议你在上面做笔记。记录下你不同意的地方或特别有用的部分。这样做将加强你在记忆中的内容，而笔记将在以后作为提醒。
- en: '|  |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 1.4.2\. Examples using Noda Time
  id: totrans-190
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.4.2\. 使用 Noda Time 的示例
- en: Most of the examples I provide in the book are standalone. But to make a more
    compelling case for some features, it’s useful to be able to point to where I
    use them in production code. Most of the time, I use Noda Time for this.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我在书中提供的多数示例都是独立的。但为了更有效地说明某些特性，能够指出我在生产代码中使用它们的地方是有用的。大多数情况下，我会使用 Noda Time
    来做这件事。
- en: 'Noda Time is an open source project I started in 2009 to provide a better date
    and time library for .NET. It serves a secondary purpose, though: it’s a great
    sandbox project for me. It helps me hone my API design skills, learn more about
    performance and benchmarking, and test new C# features. All of this without breaking
    users, of course.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: Noda Time是一个我在2009年开始的开源项目，旨在为.NET提供更好的日期和时间库。尽管如此，它还有一个次要目的：它是我一个很好的沙盒项目。它帮助我磨练API设计技能，了解更多关于性能和基准测试的知识，并测试新的C#功能。当然，这一切都不会破坏用户的使用。
- en: Every new version of C# has introduced features that I’ve been able to use in
    Noda Time, so I think it makes sense to use those as concrete examples in this
    book. All of the code is available on GitHub, which means you can clone it and
    experiment for yourself. The purpose of using Noda Time in examples isn’t to persuade
    you to use the library, but I’m not going to complain if that happens to be a
    side effect.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 每一个C#的新版本都引入了我在Noda Time中能够使用的功能，因此我认为在本书中使用这些功能作为具体示例是有意义的。所有代码都可在GitHub上找到，这意味着你可以克隆它并亲自实验。在示例中使用Noda
    Time的目的并不是为了说服你使用这个库，但如果这成为了一个副作用，我也不会抱怨。
- en: 'In the rest of the book, I’ll assume that you know what I’m talking about when
    I refer to Noda Time. In terms of making it suitable for examples, the important
    aspects of it are as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的其余部分，我将假设当提到Noda Time时，你知道我在说什么。为了使其适合示例，其重要方面如下：
- en: The code needs to be as readable as possible. If a language feature lets me
    refactor for readability, I’ll jump at the chance.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码需要尽可能易于阅读。如果语言特性允许我为了可读性而重构，我会抓住这个机会。
- en: Noda Time follows semantic versioning, and new major versions are rare. I pay
    attention to the backward-compatibility aspects of applying new language features.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Noda Time遵循语义版本控制，并且新的大版本发布很少。我关注新语言特性的向后兼容性方面。
- en: I don’t have concrete performance goals, because Noda Time can be used in many
    contexts with different requirements. I do pay attention to performance and will
    embrace features that improve efficiency, so long as they don’t make the code
    much more complex.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我没有具体的性能目标，因为Noda Time可以在许多具有不同要求的上下文中使用。我确实关注性能，并且会接受那些提高效率的功能，只要它们不会使代码变得过于复杂。
- en: To find out more about the project and check out its source code, visit [https://nodatime.org](https://nodatime.org)
    or [https://github.com/nodatime/nodatime](https://github.com/nodatime/nodatime).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于该项目及其源代码的信息，请访问[https://nodatime.org](https://nodatime.org)或[https://github.com/nodatime/nodatime](https://github.com/nodatime/nodatime)。
- en: 1.4.3\. Terminology choices
  id: totrans-199
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 1.4.3. 术语选择
- en: I’ve tried to follow the official C# terminology as closely as I can within
    the book, but occasionally I’ve allowed clarity to take precedence over precision.
    For example, when writing about asynchrony, I often refer to *async methods* when
    the same information also applies to asynchronous anonymous functions. Likewise,
    object initializers apply to accessible fields as well as properties, but it’s
    simpler to mention that once and then refer only to properties within the rest
    of the explanation.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我尽量在书中尽可能接近官方C#术语，但有时我会让清晰度优先于精确度。例如，在撰写关于异步性的内容时，我经常提到*异步方法*，尽管相同的信息也适用于异步匿名函数。同样，对象初始化器适用于可访问字段以及属性，但只需提及一次并在此后的解释中仅提及属性会更简单。
- en: Sometimes the terms within the specification are rarely used in the wider community.
    For example, the specification has the notion of a *function member*. That’s a
    method, property, event, indexer, user-defined operator, instance constructor,
    static constructor, or finalizer. It’s a term for any type member that can contain
    executable code, and it’s useful when describing language features. It’s not nearly
    as useful when you’re looking at your own code, which is why you may never have
    heard of it before. I’ve tried to use terms like this sparingly, but my view is
    that it’s worth becoming somewhat familiar with them in the spirit of getting
    closer to the language.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 有时规范中的术语在更广泛的社区中很少使用。例如，规范中有“函数成员”的概念。这是一个方法、属性、事件、索引器、用户定义的操作符、实例构造函数、静态构造函数或终结器。这是一个可以包含可执行代码的类型成员的术语，当描述语言特性时很有用。当你查看自己的代码时，它几乎没什么用，这就是为什么你可能从未听说过它。我尽量少用这样的术语，但我的观点是，为了更接近语言，了解它们是有价值的。
- en: Finally, some concepts don’t have any official terminology but are still useful
    to refer to in a shorthand form. The one I’ll use most often is probably *unspeakable
    names*. This term, coined by Eric Lippert, refers to an identifier generated by
    the compiler to implement features such as iterator blocks or lambda expressions.^([[2](kindle_split_015_split_000.html#ch01fn2)])
    The identifier is valid for the CLR but not valid in C#; it’s a name that can’t
    be “spoken” within the language, so it’s guaranteed not to clash with your code.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一些概念没有官方的术语，但仍然可以用简短的形式来引用。我可能最常使用的是*不可言说的名称*。这个术语是由埃里克·利珀特提出的，指的是编译器生成的标识符，用于实现迭代块或lambda表达式等功能。[[2](kindle_split_015_split_000.html#ch01fn2)])
    这个标识符在CLR中是有效的，但在C#中不是，它是一个在语言内部不能“说出”的名字，因此可以保证不会与你的代码冲突。
- en: ²
  id: totrans-203
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ²
- en: ''
  id: totrans-204
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'We think it was Eric, anyway. Eric can’t remember for sure and thinks Anders
    Hejlsberg may have come up with the term first. I’ll always associate it with
    Eric, though, along with his classification for exceptions: fatal, boneheaded,
    vexing, or exogenous.'
  id: totrans-205
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们认为这应该是埃里克。埃里克不确定，但认为Anders Hejlsberg可能是第一个提出这个术语的人。不过，我总是将这个术语与埃里克联系在一起，以及他对异常的分类：致命的、愚蠢的、令人烦恼的或外生的。
- en: Summary
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: I love C#. It’s both comfortable and exciting, and I love seeing where it’s
    going next. I hope this chapter has passed on some of that excitement to you.
    But this has been only a taste. Let’s get onto the real business of the book without
    further delay.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢C#。它既舒适又令人兴奋，我也喜欢看到它未来的发展方向。我希望这一章已经将其中的一些兴奋传递给了你。但这仅仅是一个尝试。让我们不再拖延，直接进入这本书的真正内容。
