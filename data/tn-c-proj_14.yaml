- en: 14 Lotto picks
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 14 彩票选择
- en: Back when I was a C programmer hatchling, I returned from a trip to Las Vegas
    eager to write my own keno program. Keno is a random-number game, a cross between
    the lottery and bingo. You pick several numbers in the range from 1 through 80\.
    Payouts depend on how many numbers you choose and guess correctly.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在我还是一个C程序员新手的时候，我从拉斯维加斯旅行回来，渴望编写自己的keno程序。keno是一种随机数字游戏，是彩票和宾果游戏的结合。你从1到80的范围内选择几个数字。奖金取决于你选择了多少个数字并且猜对了多少。
- en: In the process of writing the code, it became apparent that the payouts offered
    in the casino were nowhere close to the true odds. For example, if you pick 10
    numbers and guess correctly, you win $200,000\. But the odds of picking 10 out
    of 10 numbers in a range of 80 numbers are 1:8,911,712\. You should win $8,911,712,
    right? But at least they have killer shrimp cocktail for a dollar. Or they once
    did.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写代码的过程中，很明显，赌场提供的奖金远远低于真实概率。例如，如果你选择了10个数字并且猜对了，你将赢得20万美元。但在80个数字中选择10个数字的概率是1:8,911,712。你应该赢得8,911,712美元，对吧？但至少他们有一美元的杀手虾鸡尾酒。或者他们曾经有过。
- en: 'The process of programming games of chance clues you in to several interesting
    and useful coding areas, including these:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 编程机会游戏的过程让你了解到几个有趣和有用的编程领域，包括这些：
- en: Understanding the odds and probability
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解概率和概率
- en: Calculating the odds
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算概率
- en: Exploring random numbers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索随机数字
- en: Simulating drawing lotto balls
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟抽取彩票球
- en: Running simulations to test the odds
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行模拟来测试概率
- en: I acknowledge that I’m not a math genius. I understand math, but I got a D in
    calculus, which was a passing grade, so that’s my limit. I’m not up to par when
    it comes to the realms of probability and such. After all, it’s the computer that
    does the math. Your job is to plug in the proper equation and do all those programming
    things that keep the computer from crashing. The odds on this skill are pretty
    good.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我承认我不是一个数学天才。我理解数学，但我微积分只得了个D，这是一个及格的分数，所以这就是我的极限。在概率等领域，我并不擅长。毕竟，是计算机在做数学。你的工作是输入正确的方程式，并做所有那些防止计算机崩溃的编程工作。这个技能的概率相当高。
- en: 14.1 A tax for those who are bad at math
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.1 对数学不好的征税
- en: I play the Powerball, even though my rational brain knows that I have scant
    chance of winning. My emotional brain argues, “Well, someone has to win!” Satisfied,
    I dump $20 on a sheaf of random lotto picks and fantasize about what I’ll do with
    my never-to-appear loot.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我玩Powerball，尽管我的理性大脑知道我赢得的机会很小。我的情感大脑争辩说：“好吧，总得有人赢！”满意了，我扔下20美元在一张随机彩票上，幻想着我将如何处理那些永远不会出现的财富。
- en: It’s this hope that keeps people playing games of chance. Whether it’s the lotto,
    keno, or any casino game (except for poker and perhaps blackjack), people rely
    upon desire more than a clean understanding of the math. That’s because the math
    isn’t in your favor.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 正是这种希望让人们继续玩机会游戏。无论是彩票、keno还是任何赌场游戏（除了扑克和可能还有21点），人们更多地依赖欲望而不是对数学的清晰理解。这是因为数学并不对你有利。
- en: 14.1.1 Playing the lottery
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.1.1 玩彩票
- en: Rumor has it that a lottery financed the Great Wall of China. Even if the rumor
    is untrue, governments have used lotteries for centuries to finance various projects.
    The early United States used a lottery to fund defense.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 传言说，彩票资助了中国的长城。即使这个传言是不真实的，政府几个世纪以来一直使用彩票来资助各种项目。早期的美国使用彩票来资助国防。
- en: Lotteries are used for other purposes as well. The Great Council of Genoa used
    a lottery to choose its members, drawing several names from a larger pool. Citizens
    would wager on the winners, calling the game *lotto*. It eventually grew so popular
    that lotteries were held by drawing numbers instead of names.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 彩票也被用于其他目的。热那亚大议会使用彩票来选择其成员，从更大的池子中抽取几个名字。市民会赌赢家，称这种游戏为“彩票”。它最终变得如此受欢迎，以至于彩票是通过抽取数字而不是名字来举行的。
- en: The goal of a good lottery is to raise funds, either for a project or to distribute
    as prize money. A portion of the funds always goes to pay the winners. To keep
    the lottery successful and popular, the prize money is typically spread across
    many winners. For most humans, seeing a return of two or three dollars after buying
    $20 worth of tickets is “winning.”
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好彩票的目标是筹集资金，无论是为了一个项目还是作为奖金分配。一部分资金总是用来支付赢家。为了保持彩票的成功和受欢迎，奖金通常会在许多赢家之间分配。对于大多数人来说，在购买了价值20美元的彩票后看到两三美元的回报就是“赢”。
- en: In the multistate Powerball lottery, numbers are printed on palm-size balls
    and drawn sequentially from a machine. After five white balls are drawn, with
    a range from 1 through 69, a single red “power ball” is drawn, with a range from
    1 to 26\. Various side bets are available, but the desire is to match all five
    numbers drawn, plus the red power ball, to win the grand prize. If no one guesses
    all six numbers, the prize money rolls over—sometimes accumulating to the hundreds
    of millions of dollars.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在多州Powerball彩票中，数字印在手掌大小的球上，并依次从机器中抽取。抽取了五个白色球，范围从1到69，然后抽取一个单独的红色“强力球”，范围从1到26。有多种边注可供选择，但目标是匹配抽取的所有五个数字，加上红色强力球，以赢得大奖。如果没有人猜对所有六个数字，奖金就会滚存——有时会积累到数亿美元。
- en: The kind of lottery simulated for the programs in this chapter is a random-number
    lottery, like Powerball. Random numbers are drawn to represent the balls from
    the Powerball lottery. Important to the simulation is not to draw the same number
    twice, which is impossible in a physical lottery. Two methods of preventing duplicate
    numbers from being drawn are offered in this chapter.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中模拟的彩票类型是一种随机数彩票，类似于Powerball。随机数被抽取来代表Powerball彩票中的球。对于模拟来说，重要的是不要重复抽取相同的数字，这在物理彩票中是不可能的。本章提供了两种防止重复抽取数字的方法。
- en: 14.1.2 Understanding the odds
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.1.2 理解赔率
- en: To dampen your glee over potential lottery winnings, I must discuss the odds.
    These are the numbers that explain the ratio of the probability of something happening
    or not happening. I desire not to get too heavily into the math, nor to discuss
    the difference between statistical odds and gambling odds. Just stare at figure
    14.1.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减少你对潜在彩票赢利的喜悦，我必须讨论赔率。这些数字解释了某事发生或不发生的概率比率。我不希望深入数学，也不讨论统计赔率和赌博赔率之间的区别。只需盯着图14.1看。
- en: '![14-01](Images/14-01.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![14-01](Images/14-01.png)'
- en: Figure 14.1 Some math formula-things explain the odds.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.1 一些数学公式解释了赔率。
- en: 'Suppose that you’re betting on the roll of a die. Here is how you would calculate
    your odds of guessing the right number, one out of six:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你在投掷骰子上下注。以下是计算你猜对数字的概率，即六个数字中的一个的概率：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You have a 16.6% chance of guessing correctly. To calculate your odds of losing,
    change the numerator in the top equation in figure 14.1 so that *Chances of losing*
    replaces *Chances of winning*. Here’s the math for the dice roll:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 你有16.6%的几率猜对。为了计算你输的概率，将图14.1顶部方程中的分子改为*输的几率*代替*赢的几率*。以下是投掷骰子的数学计算：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You have an 83.3% chance of losing. See how much stating the odds in this manner
    dashes all hope? It’s depressing.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你有83.3%的几率会输。看看这样陈述赔率是如何让人所有的希望都破灭的吗？这真是令人沮丧。
- en: 'Odds are also expressed as a colon ratio, as shown on the bottom in figure
    14.1\. For the dice example, your odds of winning are 1 in 5, often expressed
    as 5:1 or “five to one.” The odds aren’t 1:6 because one of the choices wins but
    five lose. Therefore, the odds are expressed 5:1 with the same win/lose percentages:
    16.6 and 83.3.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 赔率也可以用冒号比表示，如图14.1底部所示。对于骰子示例，你赢得的概率是1比5，通常表示为5:1或“五比一”。赔率不是1:6，因为有一个选择会赢但五个会输。因此，赔率以5:1表示，具有相同的赢/输百分比：16.6和83.3。
- en: For a game like Powerball, the odds are calculated as numbers are drawn but
    also considering that the balls aren’t drawn in any order. These items must be
    considered to properly calculate the odds.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 对于像Powerball这样的游戏，赔率是在抽取数字时计算的，同时也考虑到球不是按任何顺序抽取的。为了正确计算赔率，必须考虑这些因素。
- en: 'For example, if you could bet on only one ball (and the minimum bet for Powerball
    is three numbers), the odds are 68:1 or 1/(68+1), which is a 1.45 percent chance
    of winning. If you bet on drawing two balls, the odds for the second ball become
    67:1, and then 66:1 for the third ball, and so on. If you do the math, you get
    a very small number:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你只能对一球下注（Powerball的最小投注是三个数字），赔率是68:1或1/(68+1)，即1.45%的赢率。如果你对抽取两球下注，第二个球的赔率变为67:1，然后是第三个球的66:1，以此类推。如果你做数学计算，你会得到一个非常小的数字：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Inverting the result, you see that your probability of winning is 1:1,348,621,560\.
    The problem with this value is that the permutations of the numbers drawn must
    also be considered. If your guesses are 1, 2, 3, 5, and 8, the first ball could
    be any of those numbers. The second ball could be any four of those numbers, and
    so on. The number of balls from which the numbers are drawn—69, 68, 67, 66, 65—must
    be divided by 5 * 4 * 3 * 2 * 1, or 5! (five factorial):'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 反转结果，你会发现你获胜的概率是 1:1,348,621,560。这个值的问题在于必须考虑抽取的数字的排列。如果你的猜测是 1、2、3、5 和 8，第一个球可以是这些数字中的任何一个。第二个球可以是这些数字中的任意四个，以此类推。从抽取数字的球数（69、68、67、66、65）必须除以
    5 * 4 * 3 * 2 * 1，即 5!（五阶乘）：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Your chance of correctly picking five numbers from a 69-ball lottery is 1:11,268,513\.
    Incidentally, the Powerball lottery pays $1 million if you succeed in accurately
    picking the five numbers. The probability is 11 times that.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 从 69 个球中正确选择五个数字的概率是 1:11,268,513。顺便说一下，如果你成功准确地选择了五个数字，Powerball 彩票会支付 100
    万美元。这个概率是 11 倍。
- en: 14.1.3 Programming the odds
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.1.3 编程赔率
- en: At university, I avoided computers because I thought you had to be a math genius
    to understand them. Poppycock! It’s the computer that does the math. The preceding
    section introduced the formulas for calculating the odds. The next step is to
    program them.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在大学时，我避免使用电脑，因为我认为你必须是一个数学天才才能理解它们。胡说！是电脑在做数学。前面一节介绍了计算赔率的公式。下一步是编写程序。
- en: The next listing shows the code for a simple odds calculator. You input the
    chances of something happening, such as guessing the correct roll of a dice. Then
    you input the chances of it not happening. The computer uses the formula shown
    earlier (refer to figure 14.1) to output the results. The source code is available
    in the online repository as odds01.c.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个列表显示了简单赔率计算器的代码。你输入某事发生的概率，例如猜测骰子的正确点数。然后你输入它不发生的概率。电脑使用前面展示的公式（参见图 14.1）来输出结果。源代码可在在线存储库中找到，作为
    odds01.c。
- en: Listing 14.1 Source code for odds01.c
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 14.1 odds01.c 的源代码
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ ow = odds of winning, ol = odds of losing
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ ow = 获胜赔率，ol = 失败赔率
- en: ❷ Two percent signs are used in the format string to output a single percent
    sign.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在格式字符串中使用两个百分号来输出单个百分号。
- en: ❸ The equation
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 方程式
- en: 'To test the program, use the dice example shown earlier in this section:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试程序，使用本节前面展示的骰子示例：
- en: '[PRE5]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If you guess one of the six sides of a die, the chances of it happening are
    one, and the chances of it not happening are five. The odds of winning are 16.7%,
    or one in five.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你猜中骰子的六个面之一，它发生的概率是 1，不发生的概率是 5。获胜的赔率是 16.7%，或者说五分之一。
- en: 'Say you want to calculate the odds of drawing a heart from a deck of cards:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想计算从一副牌中抽到红桃的赔率：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Because hearts is one of four suits, your odds are 25% or one in four—though
    the program doesn’t reduce the ratio. Even so, the answer is accurate.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 因为红桃是四种花色之一，所以你的赔率是 25% 或四分之一——尽管程序没有减少这个比例。即便如此，答案仍然是准确的。
- en: 'To calculate multiple draws, as in a lottery, more math is required: The decreasing
    number of balls must be multiplied, as well as permutations of the number guessed.
    This formula is shown earlier, but coded in the following listing. The product
    of the total items is calculated in variable i; the product of the items to draw
    is calculated in variable d.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算多次抽取，例如在彩票中，需要更多的数学知识：必须将球的数量相乘，以及猜测的数字的排列。这个公式之前已经展示过，但以下代码块中进行了编码。总项目的乘积在变量
    i 中计算；抽取项目的乘积在变量 d 中计算。
- en: Listing 14.2 Source code for odds02.c
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 14.2 odds02.c 的源代码
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ Even an unsigned long value may not be large enough to handle the odds for
    some calculations.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 即使是无符号长整型值也可能不足以处理某些计算的赔率。
- en: ❷ Loops through the number of draws
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 循环遍历抽取次数
- en: ❸ Obtains the product of each item, decreasing in value
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 获得每个项目的乘积，数值递减
- en: ❹ Obtains the product of each drawing permutation, decreasing in value
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 获得每个抽取排列的乘积，数值递减
- en: ❺ Casts the variables to obtain an accurate result
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 将变量转换为以获得准确的结果
- en: 'I had to keep enlarging the storage space for variables i and d in the code,
    from *int* to *long*, to *unsigned long*. The product of multiple values grows
    quickly. Still, the code renders accurate results for the Powerball odds (not
    counting the Powerball itself):'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我不得不在代码中不断增大变量 i 和 d 的存储空间，从 *int* 到 *long*，再到 *unsigned long*。多个值的乘积增长得很快。尽管如此，代码仍然为
    Powerball 赔率（不包括 Powerball 本身）提供了准确的结果：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This result matches the value shown earlier, 11,238,513\. As usual, many modifications
    to the code are possible.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结果与之前显示的值匹配，11,238,513。像往常一样，代码可以进行许多修改。
- en: Exercise 14.1
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 14.1
- en: One thing that’s missing from the source code for odds02.c is error-checking.
    What happens if the user inputs 10 items but 12 to draw? What happens when 0 is
    input for either value? Your task for this exercise is to modify the code to confirm
    that the input of either value isn’t 0, and that the number of items drawn doesn’t
    exceed the number of items available.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: odds02.c 的源代码中缺少了一个错误检查。如果用户输入了 10 项但抽取了 12 项会发生什么？如果输入的任一值为 0 会发生什么？本练习的任务是修改代码以确认任一值的输入不是
    0，并且抽取的项目数量不超过可用的项目数量。
- en: My solution, chock-full of comments, is available in the online repository as
    odds03.c. Use the source code for odds02.c as your starting point.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我的解决方案，注释详尽，可在在线存储库中的 odds03.c 文件中找到。以 odds02.c 的源代码作为起点。
- en: Exercise 14.2
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 14.2
- en: 'Another good improvement to the code is to add commas to the output. After
    all, which is better: 1:11238513 or 1:11,238,513? Human eyeballs appreciate commas.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的另一个良好改进是向输出中添加逗号。毕竟，哪个更好：1:11238513 还是 1:11,238,513？人类的眼睛喜欢逗号。
- en: Your task for this exercise is to add commas to the odds numeric output. I recommend
    that you write a function to accept a floating-point value as input. Assume that
    the value has no decimal portion. Return a string that represents the value, but
    with commas placed every three positions, as shown earlier. My solution is the
    *commify()* function, available in the source code file oddsd04.c, found in the
    online repository.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 本练习的任务是向中奖号码的数值输出中添加逗号。我建议你编写一个函数，该函数接受一个浮点数作为输入。假设该值没有小数部分。返回一个表示该值的字符串，但每三位放置一个逗号，如之前所示。我的解决方案是
    *commify()* 函数，可在在线存储库中找到的源代码文件 oddsd04.c 中找到。
- en: 14.2 Here are your winning numbers
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.2 这里是你的中奖号码
- en: Those lottery numbers you find on a fortune cookie fortune were most likely
    computer generated. I find this development disappointing. Instead, wouldn’t it
    be charming to imagine some wise old Chinese woman sitting in an incense-filled
    room, actively consulting with the spirit world for inspiration? But, no. The
    truth is that the numbers were spewed forth from a computer—randomly generated.
    Sure, they could be correct guesses and win you a fortune, but the odds are against
    it.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你在 fortune cookie 的祝福语中找到的彩票号码很可能是计算机生成的。我发现这种发展令人失望。相反，想象一位智慧的老妇人坐在充满香气的房间里，积极与灵界交流以获得灵感，这不是很迷人吗？但是，事实是这些数字是从计算机中喷涌而出的——随机生成的。当然，它们可能是正确的猜测并赢得你的财富，但几率很小。
- en: To have the computer pick your lottery winners requires programming random numbers.
    These must simulate the randomness of the magical lottery-ball machine that generates
    the actual numbers drawn in Powerball. Unlike in the real world, your lottery
    simulation must ensure that the values drawn are in range. Further, you can’t
    draw the same number twice. Your lottery picks must be unique, just like in the
    real world.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 要让计算机选择你的彩票中奖号码，需要编程随机数。这些数必须模拟产生 Powerball 实际抽取号码的神奇彩票球机的随机性。与现实世界不同，你的彩票模拟必须确保抽取的值在范围内。此外，你不能抽取相同的数字两次。你的彩票选择必须像现实世界一样是唯一的。
- en: 14.2.1 Generating random values
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.2.1 生成随机值
- en: I can’t think of a computer game that doesn’t rely upon random numbers. Even
    complex chess-playing software must still decide its first move. A spin of the
    old random-number generator is what makes the decision.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我想不出一款不依赖于随机数的电脑游戏。即使是复杂的棋类软件也必须决定它的第一步。转动古老的随机数生成器就是做出这个决定的方法。
- en: 'Computers don’t generate truly random numbers. The values are referred to as
    *pseudo random* because, if you had all the data, you could predict the values.
    Still, random-number generation is central to setting up an interesting game—or
    picking lottery numbers. The required tool is the *rand()* function, prototyped
    in the stdlib.h header file:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机不会生成真正的随机数。这些值被称为*伪随机*，因为如果你有所有数据，你可以预测这些值。尽管如此，随机数生成对于设置一个有趣的游戏——或者选择彩票号码——仍然是核心的。所需的工具是*rand()*函数，该函数在stdlib.h头文件中进行了原型定义：
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The function takes no arguments and returns an integer value in the range zero
    through RAND_MAX. This value for most compilers is set to 0x7ffffffff or 2,147,483,647\.
    An improved version of the function, *random()*, works similarly to *rand()*,
    though this function isn’t a part of the standard C library.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数不接受任何参数，并返回一个范围在 0 到 RAND_MAX 之间的整数值。对于大多数编译器，这个值被设置为 0x7ffffffff 或 2,147,483,647。该函数的改进版本
    *random()* 与 *rand()* 类似，尽管这个函数不是标准 C 库的一部分。
- en: The source code shown next works like one of the first programs I ever wrote
    in BASIC, years ago. It spews out a grid of random numbers, five rows by five
    columns. The *rand()* function generates the value saved in variable r and output
    in a *printf()* statement.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的源代码类似于我多年前用 BASIC 编写的第一个程序。它输出一个随机数网格，五行五列。*rand()* 函数生成变量 r 中保存的值，并在 *printf()*
    语句中输出。
- en: Listing 14.3 Source code for random01.c
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 14.3 random01.c 的源代码
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ❶ For the *rand()* function
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 对于 *rand()* 函数
- en: ❷ Nested loop to process the grid
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 嵌套循环处理网格
- en: ❸ Obtains the random integer
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 获取随机整数
- en: ❹ Outputs the random integer
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 输出随机整数
- en: ❺ Ends the row
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 结束行
- en: 'The code shown in listing 14.3 serves its purpose. It generates 25 random values,
    and the output is completely ugly:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 14.3 中显示的代码完成了它的任务。它生成了 25 个随机值，输出看起来非常糟糕：
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The numbers are huge, which is within the range generated by the *rand()* function,
    from zero through RAND_MAX. To output values in a different range, you can employ
    the modulo operator. Here is the expression I use:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数字非常大，在 *rand()* 函数生成的范围之内，从 0 到 RAND_MAX。要输出不同范围的值，你可以使用取模运算符。以下是我使用的表达式：
- en: '[PRE12]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The variable value is between 0 and the value of range. If you want the value
    to be between 1 and range, I use this version of the expression:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 变量的值在 0 和范围值之间。如果你想使值在 1 和范围之间，我使用这个版本的表达式：
- en: '[PRE13]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To set the random-number output to values from 1 through 100, change two statements
    to modify the source code for random01.c:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 要将随机数输出设置为 1 到 100 之间的值，需要更改两个语句来修改 random01.c 的源代码：
- en: '[PRE14]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The first statement limits the *rand()* function’s output to the range of 1
    through 100\. The second statement aligns output, restricting the value to a three-character-wide
    frame, followed by a space. These changes are incorporated into the source code
    file random02.c, available in the online repository. Here is the updated output:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 第一条语句限制了 *rand()* 函数的输出范围在 1 到 100 之间。第二条语句对输出进行了对齐，将值限制在一个三个字符宽的框架内，后面跟一个空格。这些更改已纳入源代码文件
    random02.c，可在在线仓库中找到。以下是更新后的输出结果：
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Alas, if you run the program twice, the same numbers are generated. This result
    doesn’t bode well for your lottery picks because the desire is to be random.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 可惜，如果你运行程序两次，会生成相同的数字。这个结果对你的彩票选择不利，因为目标是随机。
- en: 'If you’ve ever coded random numbers, you know that the solution is to seed
    the randomizer. The *srand()* function, also prototyped in the stdlib.h header
    file, handles the task:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经编写过随机数代码，你知道解决方案是给随机数生成器设置种子。*srand()* 函数，也在 stdlib.h 头文件中声明，负责这项任务：
- en: '[PRE16]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The seed argument is a positive integer value, which the *rand()* function
    uses in its random-number calculations. The *srand()* function needs to be called
    only once. It’s often used with the *time()* function, which returns the current
    clock-tick value as a seed:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 种子参数是一个正整数，*rand()* 函数在它的随机数计算中使用这个值。*srand()* 函数只需要调用一次。它通常与 *time()* 函数一起使用，该函数返回当前的时钟滴答值作为种子：
- en: '[PRE17]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The *time()* function is typecast to *unsigned* and given the NULL argument.
    This format ensures that the clock-tick value is properly consumed by the *srand()*
    function, and a new slate of random numbers is generated every time the program
    runs.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*time()* 函数被转换为 *unsigned* 类型，并传递了 NULL 参数。这种格式确保了时钟滴答值被 *srand()* 函数正确消耗，并且每次程序运行时都会生成一个新的随机数序列。'
- en: (If you use the *random()* function, it has a similar seed function, *srandom()*.)
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: （如果你使用 *random()* 函数，它有一个类似的种子函数，*srandom()*.）
- en: 'Improvements to the random02.c code are included with random03.c, available
    in the online repository. The time.h header file is also included. Here is a sample
    run:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: random02.c 代码的改进包含在 random03.c 中，可在在线仓库中找到。同时还包括了 time.h 头文件。以下是一个示例运行结果：
- en: '[PRE18]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'And here’s another sample run, just to show a different slate of random numbers:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一个示例运行结果，只是为了展示不同的随机数序列：
- en: '[PRE19]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: By the way, because a *time_t* value (returned from the *time()* function) is
    used, if you run the program rapidly in succession, you see the same values generated.
    This is a weakness of seeding the randomizer with a clock-tick value, but it shouldn’t
    be a problem for most applications.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，因为使用了 *time_t* 值（由 *time()* 函数返回），如果你连续快速运行程序，你会看到相同的值生成。这是用时钟滴答值初始化随机数生成器的弱点，但这不应该对大多数应用造成问题。
- en: 14.2.2 Drawing lotto balls
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.2.2 抽取彩票球
- en: Into the tumbler fall 69 balls, numbered 1 through 69\. The balls are agitated,
    popping up and down as they stir for a few tense moments. Using some sort of magic,
    a single ball is drawn from the lot, rolling down a tube onto a slide. Eager but
    stupid people tighten their focus to witness the number revealed. No, it probably
    wasn’t one of their picks—but they have four more chances! Hope remains high.
    This process is how the Powerball lottery works.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 69 个球落入摇奖机，编号为 1 到 69。球在搅拌时上下跳动，紧张地搅拌了几分钟。通过某种魔法，从摇奖机中抽取一个球，沿着管子滚到滑梯上。渴望但愚蠢的人们集中注意力，见证揭示的数字。不，这很可能不是他们选择的数字——但他们还有四次机会！希望仍然很高。这个过程就是
    Powerball 彩票的工作方式。
- en: 'For my lottery simulation, I use the basic premise of the Powerball: randomly
    draw five numbers in the range from 1 through 69\. The sixth, the Powerball, adds
    another level of complexity, and it can be programmed later, but not in this chapter.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我的彩票模拟，我使用 Powerball 的基本前提：随机抽取 1 到 69 范围内的五个数字。第六个数字，Powerball，增加了另一个复杂度，稍后可以编程实现，但不是在本章中。
- en: Drawing lottery numbers is like drawing any random sequence of items, such as
    playing cards. My first attempt at the simulation is shown in the next listing,
    the source code for lotto01.c. It borrows from the random series of programs shown
    earlier in this chapter but uses a *for* loop to output five random numbers in
    the range from 1 through 69.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 抽取彩票号码就像抽取任何随机序列的项目一样，例如玩扑克牌。我在下一个列表中展示了模拟的第一个尝试，即 lotto01.c 的源代码。它借鉴了本章前面展示的随机序列程序，但使用一个
    *for* 循环来输出 1 到 69 范围内的五个随机数。
- en: Listing 14.4 Source code for lottt01.c
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 14.4 lottt01.c 的源代码
- en: '[PRE20]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: ❶ Sets the constants to represent total balls and number to draw
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 设置常数以表示总球数和抽取的数字
- en: ❷ Seeds the randomizer
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 初始化随机数生成器
- en: ❸ Informs the user
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 通知用户
- en: ❹ Loops to draw the given number of balls
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 循环抽取指定数量的球
- en: ❺ Generates a random value in range
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 在范围内生成随机值
- en: ❻ Outputs the value
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 输出值
- en: 'Sometimes I think the code used to generate lottery winners on fortune cookie
    fortunes is just as simple as that presented in listing 14.4\. Here is the output:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我想，用于在幸运饼干上生成彩票赢家的代码可能和列表 14.4 中展示的代码一样简单。以下是输出：
- en: '[PRE21]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'True, the output could be prettier. An update is presented in a few pages.
    But if you run the code often enough, you eventually see output like this:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 确实，输出可以更美观。更新将在几页后展示。但如果你经常运行代码，最终你会看到如下输出：
- en: '[PRE22]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Because the code doesn’t check previous numbers drawn, values can repeat. Such
    output it not only unrealistic—it’s unlucky.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 因为代码没有检查之前抽取的数字，值可能会重复。这样的输出不仅不现实——而且不吉利。
- en: The code can’t determine whether a value drawn is a repeat unless the values
    drawn are stored and examined. To do so, an array is necessary, dimensioned to
    the number of balls drawn. Each random value drawn must be stored in the array,
    and then the array is examined to ensure that no two values repeat.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 代码无法确定抽取的值是否重复，除非将抽取的值存储并检查。为此，需要一个数组，其维度与抽取的球数相同。每个抽取的随机值都必须存储在数组中，然后检查数组以确保没有两个值重复。
- en: For my first approach to this problem, I use the winners[] array, shown next,
    an update to the lotto01.c code. A *for* loop fills the array with random values.
    Next, a nested *for* loop works like a bubble sort to compare each value in the
    array with other values. When two values match, the second is replaced with a
    new random value, and the loop is reset to scan again.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我对这个问题的第一个方法，我使用 winners[] 数组，如下所示，这是对 lotto01.c 代码的更新。一个 *for* 循环用随机值填充数组。接下来，一个嵌套的
    *for* 循环像冒泡排序一样工作，将数组中的每个值与其他值进行比较。当两个值匹配时，第二个值被替换为一个新的随机值，然后循环重置以再次扫描。
- en: Listing 14.5 Source code for lottt02.c
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 14.5 lottt02.c 的源代码
- en: '[PRE23]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: ❶ Dimensions the array to hold the number of draws
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将数组维度设置为存储抽取的数量
- en: ❷ Fills the array with random values, one through balls
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 用随机值填充数组，从第一个球开始
- en: ❸ The outer loop moves through the array to the next-to-last element, draw-1.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 外循环遍历数组到倒数第二个元素，draw-1。
- en: ❹ The inner loop moves through the array from the x+1 element to the last element.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 内循环从 x+1 元素遍历到数组的最后一个元素。
- en: ❺ Compares each value to the rest of the values
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 将每个值与所有其他值进行比较
- en: ❻ For a match, draws the repeated value again
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 对于匹配，再次抽取重复的值
- en: ❼ Forces the y loop to stop by setting the termination value
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 通过设置终止值强制 y 循环停止
- en: ❽ Resets the x loop back to start (-1 because the loop increments x each time
    it runs)
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 将 x 循环重置回起始位置（-1，因为每次循环运行时循环都会增加 x）
- en: ❾ Outputs the results
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: ❾ 输出结果
- en: The improved version of the lotto program checks for repeated values and replaces
    them. The output looks the same as for the first version of the program, but no
    numbers repeat. You’re all ready to plunk down your money for a chance at riches,
    yet the code presents room for improvement.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 改进的彩票程序版本会检查重复的值并替换它们。输出看起来与程序的第一版相同，但没有数字重复。你现在可以准备好投下你的钱，为财富的机会而战，但代码中仍有改进的空间。
- en: Exercise 14.3
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 14.3
- en: 'The output from the existing rendition of the *lotto* program is tacky. It
    looks nothing like the back of a fortune cookie fortune. Two ways to improve it
    are to sort the numbers and output them on a single line to improve readability.
    For example:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现有版本的 *lotto* 程序的输出很俗气。它看起来根本不像幸运饼干背面的祝福。有两种方法可以改进它：对数字进行排序并将它们输出到单行以提高可读性。例如：
- en: '[PRE24]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The output is now linear, ready for printing and saving that old Chinese woman
    time that she can spend with her grandkids. My solution for this exercise is titled
    lotto03.c, and it’s available in the online repository.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的输出是线性的，可以打印并节省那位老妇人时间，让她可以和她的孙子辈们共度时光。我为此练习的解决方案命名为 lotto03.c，并在在线仓库中可用。
- en: 14.2.3 Avoiding repeated numbers, another approach
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.2.3 避免重复数字，另一种方法
- en: The key to any lottery simulation is to ensure that no two numbers are drawn
    twice. The preceding section offered one method. Another method, one that I’ve
    used many times, is to simulate all the numbers or balls in an array. As random
    numbers are generated, elements of the array are updated to reflect that the ball
    is no longer available. I find this approach much easier to code, though perhaps
    not as easy to explain.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 任何彩票模拟的关键是确保没有两个数字被抽取两次。前面的部分提供了一种方法。另一种方法，我多次使用的方法，是在数组中模拟所有数字或球。当生成随机数时，数组元素会更新以反映球不再可用。我发现这种方法编码起来更容易，尽管可能不是那么容易解释。
- en: Figure 14.2 illustrates an array numbers[] that’s been initialized with all
    zeros. The array’s elements represent balls in a lottery. When an element has
    the value zero, it means that the ball hasn’t yet been drawn. When a ball is drawn,
    its corresponding element in the array is set to 1, as shown in the figure. For
    example, if the random number generator returns 12, the 12th element of the array
    is set to one.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.2 展示了一个初始化为所有零的数组 numbers[]。数组的元素代表彩票中的球。当一个元素的值为零时，意味着该球尚未被抽取。当一个球被抽取时，数组中对应的元素被设置为
    1，如图所示。例如，如果随机数生成器返回 12，则数组中的第 12 个元素被设置为 1。
- en: '![14-02](Images/14-02.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![14-02](Images/14-02.png)'
- en: Figure 14.2 Elements in an array representing lotto balls
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.2 代表彩票球的数组元素
- en: 'To confirm that a number is available to draw, the code tests the related array
    element. If the element is 0, the number is available and it’s set to 1\. If the
    element is 1, it’s skipped and another random number is generated. The following
    code performs this test:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确认一个数字是否可用于抽取，代码会测试相关的数组元素。如果元素是 0，则该数字可用，并将其设置为 1。如果元素是 1，则跳过并生成另一个随机数。以下代码执行此测试：
- en: '[PRE25]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The numbers[] array represents the simulated lotto balls. It’s dimensioned to
    the number of balls available, 69\. Variable draw is the number of balls to draw—five,
    in this instance.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: numbers[] 数组代表模拟的彩票球。它的大小设置为可用球的数量，69。变量 draw 是要抽取的球的数量——在这个例子中是五个。
- en: 'The *do-while* loop repeats whenever the random array element numbers[r] is
    equal to 1\. This test ensures that a ball isn’t drawn twice. Otherwise, if the
    element is zero, meaning that the ball is available, it’s “drawn” by setting its
    value to one: numbers[r] = 1. This statement flags the ball as drawn and prevents
    it from being drawn again.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 当随机数组元素 numbers[r] 等于 1 时，*do-while* 循环会重复。这个测试确保球不会被抽取两次。否则，如果元素是零，意味着球可用，它会被“抽取”通过将其值设置为
    1：numbers[r] = 1。这个语句将球标记为已抽取，并防止它再次被抽取。
- en: 'The variable balls helps to truncate, via the modulus operator, the *rand()*
    function’s return value: r=rand()%balls. However, this value isn’t increased by
    1\. Because the code deals with an array, the first value must be 0\. Therefore,
    the numbers drawn are in the range of 0 to balls-minus-1, or 68 in this example.
    This result can be adjusted during output to reflect the true lottery ball number.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 变量 balls 通过取模运算符帮助截断 *rand()* 函数的返回值：r=rand()%balls。然而，这个值并没有加 1。因为代码处理数组，第一个值必须是
    0。因此，抽取的数字范围是 0 到 balls 减 1，在这个例子中是 68。这个结果可以在输出时进行调整，以反映真实的彩票球号。
- en: The rest of the code to simulate a lottery drawing is presented in the following
    listing. The numbers[] array is initialized, the balls are drawn, and then the
    result is output. Because the numbers[] array is processed sequentially in the
    final for loop, the winning numbers need not be sorted before they’re output.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟彩票抽取的其余代码如下所示。初始化 numbers[] 数组，抽取球，然后输出结果。因为 numbers[] 数组在最终的 for 循环中按顺序处理，所以输出前不需要对中奖号码进行排序。
- en: Listing 14.6 Source code for lotto04.c
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 14.6 lotto04.c 的源代码
- en: '[PRE26]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: ❶ Initializes the array
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 初始化数组
- en: ❷ Selects the random values
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 选择随机值
- en: ❸ Processes the array to cull the winning numbers
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 处理数组以筛选中奖号码
- en: ❹ If the element is nonzero (1), the ball was drawn.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 如果元素非零（1），则抽中了球。
- en: ❺ Outputs the ball number, plus one to account for the array starting at element
    0
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 输出球号，加一以考虑数组从元素 0 开始
- en: ❻ After all but the last number, outputs a dash separator
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 在最后一个数字之前，输出一个破折号分隔符
- en: 'The lotto04.c source code file shown in listing 14.6 is available in the online
    repository. Here is the output:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 14.6 中所示的 lotto04.c 源代码文件可在在线存储库中找到。以下是输出结果：
- en: '[PRE27]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: No numbers are repeated, and the output is sorted. Good luck!
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 没有重复的数字，输出是排序的。祝你好运！
- en: 14.3 Never tell me the odds
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 14.3 永远不要告诉我概率
- en: If only you could play the lottery forever. Or perhaps you’re eccentric enough
    to believe that you can purchase 11,238,513 tickets, each with a different number
    combination, and somehow come out ahead. But the system just doesn’t work that
    way. Oh, I could wax on about the various techniques to “win” the lottery, but
    foo on all that.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你能永远地玩彩票该多好。或者也许你足够古怪，以至于相信你可以购买 11,238,513 张彩票，每张彩票上的数字组合都不同，并且以某种方式脱颖而出。但系统根本不会这样运作。哦，我可以大谈特谈各种“赢得”彩票的技术，但这一切都是胡说八道。
- en: Fortunately, you don’t need to purchase a bunch of lottery tickets to see how
    well you would fare playing a game. The computer can not only generate lotto picks
    but also match those picks with other picks. You can run simulations to determine
    how many random draws it takes before the computer guesses which numbers the computer
    chose. As long as the coding is proper, you can put the odds to the test. Alas,
    you just don’t win any money.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，你不需要购买一大堆彩票来看到你玩游戏的表现如何。计算机不仅可以生成彩票选择，还可以将这些选择与其他选择匹配。你可以运行模拟来确定计算机猜测它选择的数字需要多少次随机抽取。只要编码正确，你就可以测试概率。唉，你只是赢不到钱。
- en: 14.3.1 Creating the lotto() function
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.3.1 创建 lotto() 函数
- en: To simulate multiple draws in a lottery, you must modify the existing *lotto*
    code so that the balls are drawn in a function, which I call *lotto()*. This improvement
    to the code allows the function to be called repeatedly, representing the original
    numbers to match as well as the guesses made.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 要模拟彩票的多次抽取，你必须修改现有的 *lotto* 代码，以便在函数中抽取球，我称之为 *lotto()*。这种代码改进允许函数被重复调用，以表示原始号码的匹配以及所做的猜测。
- en: 'I toiled a few times writing the *lotto()* function: should it return the random
    numbers drawn, or should they be passed in an array? I finally chose to pass an
    array, which works as a pointer within the function. This method allows the array’s
    elements to be modified directly, so the function returns nothing.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我多次努力编写了 *lotto()* 函数：它应该返回抽取的随机数字，还是应该将它们作为数组传入？我最终选择传入一个数组，这在函数中作为一个指针工作。这种方法允许直接修改数组的元素，因此函数不返回任何内容。
- en: 'The *lotto()* function, shown next, uses similar statements as the *main()*
    function in the *lotto* series of programs shown earlier in this chapter: the
    numbers[] array now dwells within the *lotto()* function because its contents
    need not be retained between calls. After the array is initialized, a *for* loop
    sets the random element values representing numbers drawn. This operation is followed
    by a second *for* loop that processes the entire numbers[] array, filling elements
    from the passed array.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的 *lotto()* 函数与本章前面展示的 *lotto* 系列程序中的 *main()* 函数使用类似的语句：numbers[] 数组现在位于
    *lotto()* 函数内部，因为其内容在调用之间不需要保留。初始化数组后，一个 *for* 循环设置代表抽取数字的随机元素值。此操作之后，第二个 *for*
    循环处理整个 numbers[] 数组，从传入的数组中填充元素。
- en: Listing 14.7 The *lotto()* function from lotto05.c
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 14.7 来自 lotto05.c 的 *lotto()* 函数
- en: '[PRE28]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: ❶ The array is referenced as a pointer in this function.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在此函数中，数组作为指针进行引用。
- en: ❷ This array stays local to the *lotto()* function.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 此数组仅限于 *lotto()* 函数内部使用。
- en: ❸ Initializes the numbers[] array
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 初始化 numbers[] 数组
- en: ❹ Randomly draws items in the array
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 随机抽取数组中的项目
- en: ❺ Variable y serves as an index into the passed array.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 变量 y 作为传入数组的索引。
- en: ❻ Fills the passed array’s elements with the random numbers drawn
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 将抽取的随机数字填充到传入数组的元素中
- en: ❼ If the ball has been drawn . . .
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 如果球已经被抽取 . . .
- en: ❽ . . . sets the element number in the passed array
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ . . . 设置传入数组中的元素编号
- en: ❾ Increments the index
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: ❾ 增加索引
- en: ❿ If the passed array is full, breaks the loop early
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: ❿ 如果传入的数组已满，则提前中断循环
- en: The defined constants BALLS and DRAW are the same as the *const int* values
    shown in early versions of the lotto programs. These are made into defined constants
    so that their values are available to all functions in the source code file.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 定义常量 BALLS 和 DRAW 与早期版本的 lotto 程序中显示的 *const int* 值相同。这些值被定义为常量，以便在源代码文件中的所有函数中可用。
- en: The *main()* function calls the *lotto()* function, and then it outputs the
    contents of the array passed. The next listing shows the *main()* function, which
    again is based on parts of the *lotto* series shown earlier in this chapter.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '*main()* 函数调用 *lotto()* 函数，然后输出传入数组的元素。下一个列表显示了 *main()* 函数，它再次基于本章前面展示的 *lotto*
    系列程序的部分内容。'
- en: Listing 14.8 The *main()* function from lotto05.c
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 14.8 来自 lotto05.c 的 *main()* 函数
- en: '[PRE29]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: ❶ Uses an array as the argument for the lotto function
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将数组作为 lotto 函数的参数使用
- en: ❷ Calls the *lotto()* function, filling array match
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 调用 *lotto()* 函数，填充 match 数组
- en: ❸ Outputs the array’s elements, the lottery “winners”
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 输出数组的元素，即彩票“中奖者”
- en: 'The full source code for lotto05.c is available in the online repository. Here
    is a sample run:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: lotto05.c 的完整源代码可在在线仓库中找到。以下是一个示例运行：
- en: '[PRE30]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The output looks like all the other *lotto* programs so far, though with the
    *lotto()* function set, it’s now possible to draw multiple lottery numbers in
    the same code. After all, the prompt above says, “Trying to match.” The next step
    in the program’s generation is to obtain another set of random lottery ball picks
    to see whether they match the first numbers drawn.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 输出看起来与其他 *lotto* 程序类似，尽管现在可以通过设置 *lotto()* 函数在同一代码中抽取多个彩票数字。毕竟，上面的提示说，“试图匹配。”程序生成的下一步是获取另一组随机彩票球抽取，以查看它们是否与第一次抽取的数字匹配。
- en: 14.3.2 Matching lottery picks
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.3.2 匹配彩票选择
- en: 'The *lotto()* function allows the code to repeatedly pull lottery numbers over
    and over, trying to match the original draw. To do so, I duplicated the *for*
    loop and output statements in the lotto05.c code, but with a second array, guess[].
    This change appears in the source code file lotto06.c, which outputs a second
    round of lottery numbers to see whether the two draws match. Here is sample output:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '*lotto()* 函数允许代码反复抽取彩票数字，试图匹配原始抽取。为此，我在 lotto05.c 代码中复制了 *for* 循环和输出语句，但使用了第二个数组
    guess[]。这个更改出现在源代码文件 lotto06.c 中，它输出第二轮彩票数字，以查看两次抽取是否匹配。以下是示例输出：'
- en: '[PRE31]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: I’m not showing the full source code here because it doesn’t do anything new—it
    just repeats the same block of code but with a new array, guess[]. This array
    is passed to the *lotto()* function and then output, as shown earlier. The result
    is two lottery number draws. Do they match? Probably not.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里不展示完整的源代码，因为它没有做任何新的事情——它只是重复了相同的代码块，但使用了新的数组 guess[]。这个数组被传递给 *lotto()*
    函数，然后输出，如前所述。结果是两次彩票数字抽取。它们匹配吗？可能不匹配。
- en: Even if the two arrays matched, you must perform a visual inspection to confirm.
    In the previous sample output, they don’t. But why do the work yourself when the
    computer is not only bored but all too eager?
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 即使两个数组匹配，你也必须进行视觉检查以确认。在前面的示例输出中，它们没有匹配。但为什么自己工作，当计算机不仅无聊，而且过于渴望呢？
- en: To make the comparison between two sets of lottery ball draws, I use the *winner()*
    function, shown here. As arguments, it consumes two arrays, referenced as integer
    pointers. Nested *for* loops compare each array value from the first array with
    each array value in the second array. Pointer notation is used to make the comparison.
    When a match is found, variable c is incremented. The total number of matches,
    ranging from zero through DRAW, is returned.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 为了比较两组彩票球抽取，我使用了*winner()* 函数，如下所示。作为参数，它消耗两个数组，作为整数指针引用。嵌套 *for* 循环将第一个数组中的每个数组值与第二个数组中的每个数组值进行比较。使用指针表示法进行比较。当找到匹配时，变量
    c 增加。返回的总匹配数，范围从 0 到 DRAW。
- en: Listing 14.9 The *winner()* function from lotto07.c
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 14.9 从 lotto07.c 的 *winner()* 函数
- en: '[PRE32]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: ❶ Both arrays are passed as integer pointers, m for match and g for guess.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 两个数组都作为整数指针传递，m 为匹配，g 为猜测。
- en: ❷ Initializes the matching count to 0
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将匹配计数初始化为 0
- en: ❸ Loops through all DRAW numbers in the first array
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 遍历第一个数组中的所有 DRAW 数字
- en: ❹ Loops through each DRAW number in the second array
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 遍历第二个数组中的每个 DRAW 数字
- en: ❺ Compares each element value
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 比较每个元素值
- en: ❻ Increments the variable y if two values match
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 如果两个值匹配，则增加变量 y
- en: ❼ Returns the number of matches
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 返回匹配数
- en: 'The *main()* function calls the *winner()* function immediately after array
    guess[] is filled by the *lotto()* function:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *lotto()* 函数填充数组 guess[] 后，*main()* 函数立即调用 *winner()* 函数：
- en: '[PRE33]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The arrays are passed by name. In the *winner()* function, these arrays are
    recognized as integer pointers. Back in the *main()* function, the values for
    array *guess[]* are output, along with a final *printf()* statement that reports
    the number of matches.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是通过名称传递的。在 *winner()* 函数中，这些数组被识别为整数指针。回到 *main()* 函数，输出数组 *guess[]* 的值，以及一个最终的
    *printf()* 语句，报告匹配数。
- en: 'The full code is available in the online repository as lotto07.c. Here is a
    sample run:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的代码可在在线仓库中找到，作为 lotto07.c。以下是一个示例运行：
- en: '[PRE34]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As luck would have it, one of the values matched between the two simulated lottery
    drawings the first time I ran the code (shown above). The *winner()* function
    returned one in variable c, as both arrays share the value 27\. I’m pleased that
    I didn’t need to run the code several times to show a match. Yet, it’s this step
    of repeatedly running the program that inspired me to code the program’s final
    version, covered in the next section.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 真是幸运，在我第一次运行代码（如上所示）时，两个模拟彩票抽奖之间的一个值匹配了。*winner()* 函数返回变量 c 中的一个值，因为两个数组共享值
    27。我很高兴我不需要多次运行代码来展示匹配。然而，正是这一步反复运行程序激发了我编写程序的最终版本，这在下一节中介绍。
- en: 14.3.3 Testing the odds
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.3.3 测试赔率
- en: 'In the Powerball game, you can’t just match a single ball to win. No, you must
    match a single ball and the Powerball to win some paltry amount. Ditto for two
    balls: two balls plus the Powerball equals some modest payout. You can, however,
    match three main numbers to win $7 on a $2 bet. Garsh! Of course, I didn’t code
    any of the Powerball nonsense, so my *lotto* programs are straightforward, and
    the prize money is consistently zero.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Powerball 游戏中，你只能匹配一个球来获胜。不，你必须匹配一个球和 Powerball 才能赢得一些微不足道的金额。同样，对于两个球：两个球加上
    Powerball 等于一些适度的回报。然而，你可以匹配三个主要数字，以 2 美元的赌注赢得 7 美元。哎呀！当然，我没有编写任何关于 Powerball
    的无聊代码，所以我的 *lotto* 程序很简单，奖金始终为零。
- en: The odds of matching one number and the Powerball are 1:92\. This value means
    that if you play the game 92 times, you’ll probably match one value and the Powerball
    at least once—but it’s not a guarantee. I won’t get into the math, but it could
    take you several hundred times to see a match or you could match the first time.
    It’s this unpredictability that entices people to gamble—even when the odds are
    stupidly high.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配一个数字和 Powerball 的概率是 1:92。这个值意味着如果你玩 92 次，你可能会至少匹配一次一个值和 Powerball，但这并不是保证。我不会涉及数学，但可能需要几百次才能看到匹配，或者你可能会在第一次就匹配。正是这种不可预测性吸引了人们去赌博——即使赔率愚蠢地高。
- en: Rather than run the lotto program over and over, I decided to program a loop
    to output guesses until at least two numbers match. The next listing shows the
    *main()* function from an updated—the final—version of the *lotto* series of programs.
    The *lotto()* and *winner()* functions are unchanged, but to the *main()* function
    I added a constant, tomatch. It sets the minimum number of balls to match before
    a *do-while* loop stops drawing random lotto balls. Nothing is output until a
    match is found, which shaves several seconds from the processing time.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免反复运行彩票程序，我决定编写一个循环，直到至少有两个数字匹配为止输出猜测。下一列表显示了更新版——最终版 *lotto* 系列程序的 *main()*
    函数。*lotto()* 和 *winner()* 函数保持不变，但我向 *main()* 函数添加了一个常量，tomatch。它设置在 *do-while*
    循环停止抽取随机彩票球之前需要匹配的最小球数。直到找到匹配，否则不输出任何内容，这可以节省几秒钟的处理时间。
- en: Listing 14.10 The *main()* function from lotto08.c
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 14.10 从 lotto08.c 中的 *main()* 函数
- en: '[PRE35]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: ❶ Determines how many balls to match
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 确定要匹配的球数
- en: ❷ The two arrays—one to hold the numbers to match and the other the guesses
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 两个数组——一个用于存储要匹配的数字，另一个用于存储猜测
- en: ❸ Outputs the numbers to match
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 输出要匹配的数字
- en: ❹ Tracks how many draws are attempted
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 跟踪尝试了多少次抽奖
- en: ❺ Grabs the simulated lottery draw
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 获取模拟的彩票抽奖结果
- en: ❻ Sees whether any balls match
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 检查是否有球匹配
- en: ❼ Increments the count
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 增加计数
- en: ❽ Keeps looping as long as the number of balls matching is less than the goal
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 只要匹配的球数少于目标，就继续循环
- en: ❾ Informs the user of the result, how many draws were required
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: ❾ 通知用户结果，需要多少次抽奖
- en: ❿ Outputs the winning draw
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: ❿ 输出中奖抽奖结果
- en: 'The complete code for lotto08.c is available in the online repository. The
    program keeps drawing random lottery picks until the minimum match value, stored
    in variable tomatch, is met. Here is a sample run:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: lotto08.c 的完整代码可在在线仓库中找到。程序会持续抽取随机彩票号码，直到变量 tomatch 中存储的最小匹配值被满足。以下是一个示例运行过程：
- en: '[PRE36]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The computer took five loops to find two matches—1 and 37, according to the
    output. You can run the program multiple times to see how many loops it takes
    to match at least two balls from five out of a total of 69\. Again, I don’t know
    the precise odds, but it’s less than 100.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 根据输出，计算机进行了五次循环找到了两个匹配——1 和 37。你可以多次运行程序，看看需要多少次循环才能从总共 69 个号码中至少匹配到五个球。再次强调，我不知道确切的概率，但肯定小于
    100。
- en: 'The fun part comes when you modify the code: alter the tomatch constant to
    the value 5, and then run the program. Here is sample output after I made this
    modification:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 当你修改代码时，有趣的部分就来了：将 tomatch 常量改为 5，然后运行程序。以下是修改后我的示例输出：
- en: '[PRE37]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Above, it took 5,907,933 spins of the *do-while* loop before an exact match
    of the five balls was achieved.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面，在达到五个球完全匹配之前，需要旋转 *do-while* 循环 5,907,933 次。
- en: I don’t know whether this code convinces anyone of the futility of playing a
    lottery. The issue is never the math; it’s the human misunderstanding of odds
    and probability. The notion that “someone’s gotta win” trumps logic and common
    sense every time.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我不知道这段代码是否能让任何人相信玩彩票的无用。问题从来不是数学；而是人类对概率和机会的误解。每次“总有人会赢”的观念都战胜了逻辑和常识。
- en: Exercise 14.4
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 14.4
- en: The computer mindlessly and effortlessly simulates as many lottery ball draws
    as you’re willing to let it perform. The lotto08.c code shows that even when attempting
    to match five out of five balls, the program runs rather quickly. Yet, more coding
    can always be done, especially to sate the curious mind.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机无意识地、毫不费力地模拟了您愿意让它执行的所有彩票球抽奖。lotto08.c 代码显示，即使尝试匹配五个球中的五个，程序运行也相当快。然而，总是可以进行更多的编码，特别是为了满足好奇的心。
- en: Your task for this exercise is modify the lotto08.c code with the goal of determining
    the average number of plays required to match all five balls from 69 possible
    numbers. Run the simulation 100 times, each time recording how many repeated calls
    to the *lotto()* function were required to achieve a match. Store each value,
    and then report the average number of plays it took to make a match.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 本练习的任务是修改 lotto08.c 代码，目标是确定匹配 69 个可能号码中的所有五个球所需的平均游戏次数。运行模拟 100 次，每次记录需要多少次重复调用
    *lotto()* 函数才能实现匹配。存储每个值，然后报告制作匹配所需的平均游戏次数。
- en: 'Here is sample output from my solution, which is available in the online repository
    as lotto09.c:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是来自我的解决方案的示例输出，该解决方案可在在线仓库中找到，作为 lotto09.c：
- en: '[PRE38]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: On average, it took 11,566,729 calls to the *lotto()* function to match the
    original numbers drawn. Remember from earlier in this chapter that the calculated
    odds of drawing the same five numbers from 69 lotto balls is 11,238,513\. Darn
    close.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 平均而言，需要调用*lotto()*函数11,566,729次才能匹配上原始抽取的数字。记得在本章前面提到，从69个彩票球中抽取相同五个数字的计算概率是11,238,513。差得真是不多。
- en: Comments in my solution explain my approach, though please attempt this exercise
    on your own before you see what I did. The modifications aren’t that involved,
    because most of the coding necessary is already in the lotto08.c source code file.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我解决方案中的注释解释了我的方法，尽管请在看到我所做之前尝试这个练习。修改并不复杂，因为大部分必要的编码已经在`lotto08.c`源代码文件中。
- en: Oh! And the solution program takes a while to run. On my fastest system, I timed
    it at almost 9 minutes to churn out the results. Be patient.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 哦！解决方案程序运行需要一段时间。在我的最快系统上，我计时了几乎9分钟才生成结果。请耐心等待。
