- en: Part 3\. React application architecture
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第三部分\. React应用程序架构
- en: By the end of [part 2](kindle_split_013.xhtml#part02), you will have transformed
    the Letters Social sample application from a bare-bones static page to a dynamic
    user interface with routing, authentication, and dynamic data. In [part 3](#part03),
    you’ll add to what you’ve created by exploring some advanced topics in React.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到[第二部分](kindle_split_013.xhtml#part02)结束时，你将把Letters Social示例应用程序从裸骨静态页面转变为具有路由、身份验证和动态数据的动态用户界面。在[第三部分](#part03)中，你将通过探索React的一些高级主题来扩展你已创建的内容。
- en: In [chapters 10](kindle_split_022_split_000.xhtml#ch10) and [11](kindle_split_023_split_000.xhtml#ch11),
    you’ll explore the Flux application architecture and implement Redux. Redux is
    a variation of the Flux pattern that has become the de facto state management
    solution for sizeable React applications. You’ll explore the concepts of Redux
    and transition your React application to use Redux as the state management solution.
    As you do this, you’ll continue to add features to Letters Social, including comments
    and the ability to like posts.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第10章](kindle_split_022_split_000.xhtml#ch10)和[第11章](kindle_split_023_split_000.xhtml#ch11)中，你将探索Flux应用程序架构并实现Redux。Redux是Flux模式的一种变体，已成为大型React应用程序的事实上的状态管理解决方案。你将探索Redux的概念，并将你的React应用程序过渡到使用Redux作为状态管理解决方案。在这个过程中，你将继续为Letters
    Social添加功能，包括评论和点赞帖子。
- en: In [chapter 12](kindle_split_024_split_000.xhtml#ch12), we’ll take things a
    step further and explore how you can use React on the server. Thanks to the availability
    of the node.js server runtime, you can execute React code on the server. You’ll
    explore server-side rendering with React and even integrate your Redux state management
    into the process. You’ll also integrate React Router, a popular routing library
    for React.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第12章](kindle_split_024_split_000.xhtml#ch12)中，我们将更进一步，探讨如何使用React在服务器上。得益于node.js服务器运行时的可用性，你可以在服务器上执行React代码。你将探索使用React进行服务器端渲染，甚至将你的Redux状态管理集成到该过程中。你还将集成React
    Router，这是一个流行的React路由库。
- en: Finally, you’ll make a minor departure from React for the web in [chapter 13](kindle_split_025_split_000.xhtml#ch13)
    and explore React Native. React Native is another React project that gives you
    the ability to write React applications that can run on iOS and Android mobile
    devices.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在[第13章](kindle_split_025_split_000.xhtml#ch13)中，你将稍微偏离React Web，并探索React
    Native。React Native是另一个React项目，它让你能够编写可以在iOS和Android移动设备上运行的React应用程序。
- en: By the end of [part 3](#part03), you’ll have created an entire application that
    takes full advantage of React, Redux, and server side rendering. You’ll have completed
    your initial foray into React, but you’ll be able to further your abilities with
    React and explore other advanced topics like React Native.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 到[第三部分](#part03)结束时，你将创建一个充分利用React、Redux和服务器端渲染的完整应用程序。你将完成对React的初步探索，但将能够通过React进一步发展你的能力，并探索其他高级主题，如React
    Native。
- en: Chapter 10\. Redux application architecture
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第10章\. Redux应用程序架构
- en: '*This chapter covers*'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Redux actions, stores, reducers, and middleware
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Redux动作、存储、还原器和中间件
- en: Simple testing of Redux actions, stores, reducers, and middleware
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Redux动作、存储、还原器和中间件的简单测试
- en: 'By this point, you can create React applications that are tested, handle dynamic
    data, accept user input, and can communicate with remote APIs. That’s a lot and
    covers most of what a typical web app will do; you may feel like the only thing
    left to do is practice. Putting your skills to use will help you master React,
    but there’s still an important area you’ll need to cover to build larger, more
    complex applications: application architecture. *Application architecture* is
    “the process of defining a structured solution that meets all of the technical
    and operational requirements, while optimizing common quality attributes such
    as performance, security, and manageability” (from *Microsoft Application Architecture
    Guide*, 2nd Edition). Architecture asks, “Okay, we can do this, but now how do
    we do it better and consistently?” It’s about how and how well the application
    is organized, how data moves around, and how responsibility is delegated to different
    parts of a system.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你可以创建经过测试的React应用程序，处理动态数据，接受用户输入，并且可以与远程API通信。这已经很多了，涵盖了典型Web应用将执行的大部分内容；你可能觉得剩下的唯一事情就是练习。将你的技能付诸实践将帮助你掌握React，但仍然有一个重要的领域你需要覆盖，那就是构建更大、更复杂的应用程序：应用程序架构。“应用程序架构”是“定义一个结构化解决方案的过程，该解决方案满足所有技术和管理要求，同时优化常见的质量属性，如性能、安全性和可管理性”（来自《微软应用程序架构指南》，第二版）。架构询问：“好吧，我们可以这样做，但现在我们如何更好地、更一致地做呢？”这关乎应用程序是如何组织的，数据是如何流动的，以及责任是如何委派给系统不同部分的。
- en: Every application has an implicit architecture of sorts simply because it has
    a structure and does things in a particular way. What I’m talking about here are
    strategies and paradigms for building complex applications. React errs on the
    side of being a more minimal or unopinionated framework focused on UI, so it doesn’t
    come with a built-in strategy for you to follow as you build more complex applications.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 每个应用程序都有某种隐含的架构，仅仅因为它有一个结构，并以特定的方式做事。我这里所说的是构建复杂应用程序的策略和范式。React更倾向于成为一个更简约或无偏见的框架，专注于UI，因此它没有内置的策略供你在构建更复杂的应用程序时遵循。
- en: Just because there isn’t a built-in strategy for you to use doesn’t mean there
    aren’t options out there, though. There are many approaches to building complex
    applications with React, and many of them are based on the Flux model popularized
    by engineers at Facebook. Flux differs from the popular MVC architecture by promoting
    unidirectional data flow, introducing new concepts (dispatchers, actions, stores),
    and in other ways. Flux and MVC are concerned with things “above” what an application
    looks like or even some of the specific libraries or technologies it is built
    with. They are more concerned with how the application is organized, how data
    moves around, and how responsibility is delegated to different parts of a system.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然没有内置的策略供你使用，但这并不意味着没有其他选择。有许多方法可以用React构建复杂的应用程序，其中许多方法基于Facebook工程师推广的Flux模型。Flux与流行的MVC架构不同，它通过促进单向数据流、引入新概念（调度器、动作、存储）等方式进行区分。Flux和MVC关注的是应用程序的外观“之上”的事情，甚至是一些特定的库或技术。它们更关注应用程序是如何组织的，数据是如何流动的，以及责任是如何委派给系统不同部分的。
- en: 'This chapter explores one of the most widely used and well-regarded variants
    of the Flux pattern: Redux. It’s extremely common to see Redux used with React
    applications, but in fact it can be used with most JavaScript frameworks (in-house
    or otherwise). This chapter and the next cover the core concepts of Redux (actions,
    middleware, reducers, the store, and others) and then the integration of Redux
    with your React app. *Actions* in Redux represent work being done (fetching user
    data, logging the user in, and so on), *reducers* determine how state should change,
    the *store* holds a centralized copy of state, and *middleware* allows you to
    inject custom behavior into the process.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章探讨了Flux模式中最广泛使用和最受好评的变体之一：Redux。Redux与React应用程序一起使用非常普遍，但实际上它可以与大多数JavaScript框架（内部或外部）一起使用。本章和下一章涵盖了Redux的核心概念（动作、中间件、还原器、存储和其他），然后是Redux与你的React应用程序的集成。Redux中的*动作*代表正在执行的工作（获取用户数据、登录用户等），*还原器*决定状态应该如何改变，*存储*持有状态的中心化副本，而*中间件*允许你在过程中注入自定义行为。
- en: '|  |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**How do I get the code for this chapter?**'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**我如何获取本章的代码？**'
- en: As with every chapter, you can check out the source code for this chapter by
    going to the GitHub repository at [https://github.com/react-in-action/letters-social](https://github.com/react-in-action/letters-social).
    If you want to start this chapter with a clean slate and follow along, you can
    use your existing code from [chapter 9](kindle_split_020_split_000.xhtml#ch09)
    (if you followed along and built out the examples yourself) or check out the chapter-specific
    branch (chapter-10-11).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 与每一章一样，你可以通过访问GitHub仓库[https://github.com/react-in-action/letters-social](https://github.com/react-in-action/letters-social)来查看本章的源代码。如果你想从这个章节开始，从零开始，并跟随操作，你可以使用[第9章](kindle_split_020_split_000.xhtml#ch09)（如果你跟随并自己构建了示例）中的现有代码，或者查看特定章节的分支（chapter-10-11）。
- en: Remember, each branch corresponds to the code at the end of the chapter (for
    example, the branch chapter-10-11 corresponds to the code as it will be at the
    end of these chapters). You can execute one of the following terminal commands
    in the directory of your choice to get the code for the current chapter.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，每个分支都对应于章节末尾的代码（例如，分支chapter-10-11对应于这些章节末尾的代码）。你可以在你选择的目录中执行以下终端命令之一来获取当前章节的代码。
- en: 'If you don’t have the repository at all, type the following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你根本就没有仓库，请输入以下内容：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If you already have the repository cloned:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经克隆了仓库：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You may have come here from another chapter, so it’s always a good idea to
    ensure you have all the right dependencies installed:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能是从另一章来到这里的，所以确保你已经安装了所有正确的依赖项总是一个好主意：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '|  |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 10.1\. The Flux application architecture
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1. Flux应用程序架构
- en: Modern applications must do more than ever before and are correspondingly more
    complex—internally and externally. Developers have long been aware of the mess
    that can be made of a complex application that grows without coherent design patterns
    in place. Spaghetti-code codebases aren’t only not fun to work with, they slow
    down developers and thus business units. Remember the last time you had to work
    in a large codebase full of one-off solutions and jQuery plugins? Probably not
    fun. To combat disorganization, developers have developed paradigms like MVC (Model-View-Controller)
    to organize the functionality of an application and guide development. Flux (and
    by extension Redux) is an effort in the same vein that helps you deal with increased
    complexity in an application.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现代应用程序必须比以往任何时候都要做更多的事情，因此它们在内部和外部都变得更加复杂。开发者们早已意识到，如果没有合适的设计模式，一个复杂的应用程序可能会变得一团糟。意大利面式的代码库不仅不便于工作，还会减慢开发者的工作效率，从而影响业务部门。你还记得上次不得不在一个充满一次性解决方案和jQuery插件的庞大代码库中工作的经历吗？可能不是那么愉快。为了对抗混乱，开发者们开发了像MVC（模型-视图-控制器）这样的范式来组织应用程序的功能并指导开发。Flux（以及由此扩展的Redux）是同一方向上的努力，它帮助你处理应用程序中增加的复杂性。
- en: 'Don’t worry if you’re not especially familiar with the MVC paradigm; we won’t
    spend much time getting into it. But before we talk about Flux and Redux, it might
    be helpful to briefly discuss MVC for the sake of comparison. If you’re interested
    in learning more, Jeff Atwood has some helpful thoughts at [https://blog.codinghorror.com/understanding-model-view-controller/](https://blog.codinghorror.com/understanding-model-view-controller/),
    and there are many other resources available online. Here are the basics:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对MVC范式不是特别熟悉，不必担心；我们不会花太多时间深入探讨它。但在我们讨论Flux和Redux之前，为了进行比较，简要地讨论一下MVC可能会有所帮助。如果你有兴趣了解更多，Jeff
    Atwood在[https://blog.codinghorror.com/understanding-model-view-controller/](https://blog.codinghorror.com/understanding-model-view-controller/)有一些有用的想法，网上还有很多其他资源。以下是基础知识：
- en: '***Model*—** The data for your application. Usually a noun like User, Account,
    or Post, for example. Your model should at least have the basic methods to manipulate
    associated data. In the most abstract sense, the model represents raw data or
    knowledge. It’s where the data intersects with your application code. For example,
    the database might store several properties like `access-Scopes`, `authenticated`,
    and so on. But the model will be able to use this data for a method like `isAllowedAccessForResource()`
    on it that will act on the underlying data to model. The model is where raw data
    converges with your application code.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***模型*—** 您应用程序的数据。通常是一个名词，如 User、Account 或 Post 等。您的模型至少应该有操作相关数据的基本方法。在最抽象的意义上，模型代表原始数据或知识。它是数据与您的应用程序代码相交的地方。例如，数据库可能存储多个属性，如
    `access-Scopes`、`authenticated` 等。但模型将能够使用这些数据来执行 `isAllowedAccessForResource()`
    等方法，这些方法将作用于底层数据以建模。模型是原始数据与您的应用程序代码相交的地方。'
- en: '***View*—** A representation of your model. The view is often the user interface
    itself. The view shouldn’t have any logic in it that isn’t related to presentation
    of the data. For front-end frameworks, this would generally mean that a particular
    view was directly associated with a resource and would have CRUD (create, read,
    update, delete) actions associated with it. This isn’t how front-end applications
    are always built anymore.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***视图*—** 您模型的表示。视图通常是用户界面本身。视图不应包含任何与数据展示无关的逻辑。对于前端框架来说，这通常意味着特定的视图直接关联到一个资源，并且会与它关联
    CRUD（创建、读取、更新、删除）操作。但现在的前端应用不再总是这样构建。'
- en: '***Controller*—** Controllers are the “glue” that binds the model and view
    together. Controllers should usually be only glue and not much more (for example,
    they shouldn’t have complex view or database logic in them). You should generally
    expect controllers to have far less ability to mutate data than the models they
    interact with.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***控制器*—** 控制器是绑定模型和视图的“胶水”。控制器通常只应该是胶水，而不应该是更多（例如，它们不应该包含复杂的视图或数据库逻辑）。您通常期望控制器比它们交互的模型具有更少的数据修改能力。'
- en: The paradigms we’re going to focus on in this chapter (Flux and Redux) depart
    from these concepts but still have the goal of helping you create a scalable,
    sensible, and effective application architecture.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 本章（Flux 和 Redux）我们将关注的范例与这些概念有所不同，但仍然旨在帮助您创建一个可扩展、合理且有效的应用程序架构。
- en: 'Redux owes its origin and design to a pattern popularized at Facebook, called
    *Flux*. If you’re familiar with the popular MVC pattern that Ruby on Rails and
    other application frameworks use, Flux might be a departure from what you’re used
    to. Rather than break parts of your application into models, views, and controllers,
    Flux defines several different parts to it:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Redux 的起源和设计归功于在 Facebook 流行的一种模式，称为 *Flux*。如果您熟悉 Ruby on Rails 和其他应用程序框架使用的流行
    MVC 模式，Flux 可能与您习惯的不同。Flux 不是将应用程序的部分拆分为模型、视图和控制器，而是定义了几个不同的部分：
- en: '***Store*—** Stores contain the application state and logic; they’re somewhat
    like a model in a traditional MVC. However, instead of representing a single database
    record, they manage the state of many objects. Unlike a model, you represent the
    data however it makes sense, unconstrained by resources.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***存储*—** 存储包含应用程序状态和逻辑；它们在传统 MVC 中类似于模型。然而，它们不是代表单个数据库记录，而是管理许多对象的状态。与模型不同，您可以根据需要表示数据，不受资源限制。'
- en: '***Actions*—** Rather than update state directly, Flux apps modify their state
    by creating actions that modify state.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***动作*—** 相比直接更新状态，Flux 应用通过创建修改状态的动作来改变其状态。'
- en: '***View*—** The user interface, usually React, but Flux doesn’t require React.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***视图*—** 用户界面，通常是 React，但 Flux 不要求使用 React。'
- en: '***Dispatcher*—** A central coordinator of actions and updates to stores.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***调度器*—** 行动和存储更新的中央协调者。'
- en: '[Figure 10.1](kindle_split_022_split_001.xhtml#ch10fig01) shows an overview
    of Flux.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 10.1](kindle_split_022_split_001.xhtml#ch10fig01) 展示了 Flux 的概述。'
- en: Figure 10.1\. A simple Flux overview
  id: totrans-38
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 10.1\. 一个简单的 Flux 概述
- en: '![](Images/10fig01_alt.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/10fig01_alt.jpg)'
- en: 'In the Flux pattern, as shown in [figure 10.1](kindle_split_022_split_001.xhtml#ch10fig01),
    actions are created from views—this might be a user clicking something. From there,
    the dispatcher handles incoming actions. Actions are then sent to the appropriate
    store to update state. State, having changed, notifies a view that new data should
    be used (if applicable). Notice how this would differ from a typical MVC-style
    framework, where the view and a model (like the store here) would both be able
    to update the other. This bidirectional data flow differs from the more unidirectional
    flow typical in Flux architectures. Also, note that middleware is missing here:
    although possible to create in Flux, it is less of a first-class citizen than
    in Redux, so we omit it here.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在Flux模式中，如图10.1[图10.1](kindle_split_022_split_001.xhtml#ch10fig01)所示，动作是由视图创建的——这可能是用户点击了某个东西。从那里，分发器处理传入的动作。然后，动作被发送到适当的存储库以更新状态。状态发生变化后，会通知视图使用新的数据（如果适用）。注意，这与典型的MVC风格框架不同，在MVC风格框架中，视图和模型（如这里的存储库）都可以更新对方。这种双向数据流与Flux架构中典型的单向流不同。此外，请注意这里缺少了中间件：虽然在Flux中可以创建中间件，但它不如Redux中的第一类公民重要，所以我们在这里省略了它。
- en: If some of these parts sound familiar, the way data flows in Flux might not
    be if you’ve worked with MVC-style applications before. As mentioned, data flows
    more unidirectionally in the Flux paradigm, which differs from the bidirectional
    manner MVC-type implementations tend to enforce. This usually means that there’s
    no single place in an app where data flows from; many different parts of the system
    have authority to modify state, and state is often decentralized throughout the
    application. This approach works well in many cases, but in larger apps, it can
    be confusing to debug and work with.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些部分听起来很熟悉，那么如果你之前使用过MVC风格的应用程序，Flux中数据流动的方式可能就不一样了。如前所述，在Flux范式下，数据流动更具有单向性，这与MVC类型实现通常强制执行的双向方式不同。这通常意味着在应用程序中没有单一的地方数据是从那里流动出来的；系统的许多不同部分都有修改状态的权限，并且状态通常在应用程序中分散。这种方法在许多情况下都很好用，但在大型应用中，调试和工作可能会变得令人困惑。
- en: Think what this might look like in a medium-to-large application. Say you had
    a collection of models (user, account, and authentication) that were associated
    with their own controllers and views. At any given place in the application, it
    could be difficult to pin down the exact location of state because it’s distributed
    across parts of the application (information about a user could be found on any
    of the three models I mentioned).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下这在中型到大型应用中的样子。比如说，你有一组与自己的控制器和视图关联的模型（用户、账户和身份验证）。在应用程序的任何位置，确定状态的精确位置可能都很困难，因为状态分布在整个应用程序的各个部分（关于用户的信息可能存在于我提到的三个模型中的任何一个）。
- en: This might not necessarily be a problem for smaller apps and can even be made
    to work well for larger applications, but it can become more difficult in nontrivial
    client-side applications. For example, what happens when things you need in order
    to modify a model’s use in 50 different locations and 60 different controllers
    need to know about changes to state? Making matters more complicated is the fact
    that views sometimes act like models in some front-end frameworks (so state is
    even more decentralized). Where’s the source of truth for your data? If it’s spread
    across views and many different models, and all in a moderately complex setup,
    mentally keeping track of everything is going to be difficult. This can also result
    in inconsistent application state that causes application bugs, so it’s not just
    a “developer-only” problem—end-users are directly affected as well.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能对小型应用来说不一定是个问题，甚至可以使其在大型应用中也能良好运行，但在非平凡的客户端应用中可能会变得更加困难。例如，当你需要修改模型在50个不同位置和60个不同控制器中的应用时，这些部分需要知道状态的变化会发生什么？使问题更加复杂的是，在某些前端框架中，视图有时会像模型一样行动（因此状态更加分散）。你的数据真相来源在哪里？如果它分布在视图和许多不同的模型中，并且在一个相当复杂的设置中，心理上跟踪所有这些内容将会很困难。这也可能导致应用程序状态不一致，从而引发应用程序错误，所以这不仅仅是一个“仅开发者”的问题——最终用户也会直接受到影响。
- en: Part of the reason why this is difficult is that people generally aren’t good
    at reasoning about change that occurs over time. To drive this home, imagine a
    checkers board in your head. It’s not so hard to hold maybe one or even a few
    snapshots of the board in your head. But would you be able to keep track of every
    snapshot of the board after 20 turns? Thirty? The entire game? We should be building
    systems that are easier for us to think about and use because keeping mental track
    of asynchronous changes to data over time is hard. For example, think of calling
    a remote API and using the data to update your application state. Simple for a
    handful of cases, but what if you have to call 50 different endpoints and need
    to keep track of the incoming responses while a user is still using the app and
    making changes that could result in more API interaction? It can be hard to mentally
    line them all up in a row and predict what the result of changes would be.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这之所以困难的部分原因是因为人们通常不擅长推理随时间发生的变化。为了说明这一点，想象一下你心中的跳棋盘。在脑海中保持可能一个或甚至几个棋盘快照并不难。但你能否在20次移动后跟踪棋盘的每个快照？30次？整个游戏？我们应该构建更容易思考和使用的系统，因为随着时间的推移，跟踪数据异步变化是困难的。例如，考虑调用远程API并使用数据更新你的应用程序状态。对于少数情况来说很简单，但如果你必须调用50个不同的端点，并在用户仍在使用应用程序并做出可能导致更多API交互的更改时跟踪传入的响应，这可能会很困难。在心理上很难将它们全部排列成一行并预测变化的结果。
- en: You may already notice some similarities between React and Flux. They’re both
    relatively new approaches to building user interfaces and they both aim to improve
    the mental model a developer works with. In each, changes should be easy to reason
    about, and you should be able to build your UI in a way that empowers you instead
    of hinders you.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到了React和Flux之间的某些相似之处。它们都是相对较新的构建用户界面的方法，它们都旨在改善开发者工作的心理模型。在每个中，变化应该是容易推理的，你应该能够以赋予你力量而不是阻碍你的方式构建你的UI。
- en: What does Flux look like in code? It’s primarily a paradigm, so there are plenty
    of libraries available that implement the core ideas of Flux. They’re all slightly
    different from one another in how they implement Flux. Redux does this, too, even
    though its particular flavor of Flux has gained the most use and mindshare. Other
    Flux libraries include Flummox, Fluxxor, Reflux, Fluxible, Lux, McFly, and MartyJS
    (though in practice you’ll see little use of these compared to Redux).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，Flux看起来是什么样子？它主要是一种范式，因此有大量的库可供选择，它们实现了Flux的核心思想。它们在实现Flux的方式上彼此略有不同。Redux也是如此，尽管它特有的Flux风格获得了最广泛的使用和认知。其他Flux库包括Flummox、Fluxxor、Reflux、Fluxible、Lux、McFly和MartyJS（但在实践中，与Redux相比，你很少会看到这些库的使用）。
- en: '10.1.1\. Meet Redux: A variation on Flux'
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.1.1. 认识Redux：Flux的一种变体
- en: Perhaps the most widely used and well-known library that implements the ideas
    behind Flux is Redux. Redux is a library that implements the ideas of Flux in
    a slightly modified way. Redux is described by its own documentation as “a predictable
    state container for JavaScript apps.” In concrete terms, this means it’s a library
    that puts into practice the concepts and ideas of Flux in its own way.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 可能最广泛使用且知名度最高的实现Flux背后思想的库是Redux。Redux是一个以略微修改的方式实现Flux思想的库。Redux的官方文档将其描述为“JavaScript应用的预测状态容器。”具体来说，这意味着它是一个将Flux的概念和思想以自己的方式付诸实践的库。
- en: 'Nailing down exact definitions of what is and isn’t considered Flux is not
    important here, but I should cover some of the important differences between the
    Flux and Redux paradigms:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，精确定义什么是Flux以及什么不是Flux并不重要，但我应该介绍一些Flux和Redux范式之间的重要区别：
- en: '***Redux uses a single store*—** Rather than locate state information in multiple
    stores across the app, Redux apps keep everything in one place. In Flux, you can
    have many different stores. Redux breaks from this and enforces a single global
    store.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***Redux使用单个store*—** 与在应用中的多个store中定位状态信息不同，Redux应用将所有内容都保存在一个地方。在Flux中，你可以有多个不同的store。Redux打破了这种做法，并强制执行一个单一的全球store。'
- en: '***Redux introduces reducers*—** Reducers are a more immutable approach to
    mutation. In Redux, state is changed in a predictable and deterministic way, one
    part of state at a time, and only in one place (the global store).'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***Redux引入了reducers*—** Reducers是一种更不可变的方法来处理变更。在Redux中，状态以可预测和确定的方式改变，一次只改变状态的一部分，并且只在一个地方（全局store）。'
- en: '***Redux introduces middleware*—** Because actions and data flow in a unidirectional
    way, you can add middleware to your Redux app and inject custom behavior as data
    is updated.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***Redux 引入了中间件*——** 因为动作和数据以单向方式流动，您可以在 Redux 应用程序中添加中间件，并在数据更新时注入自定义行为。'
- en: '***Redux actions are decoupled from the store*—** Action-creators don’t dispatch
    anything to the store; instead, they return action objects that a central dispatcher
    uses.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***Redux 动作与存储解耦*——** 动作创建者不会向存储发送任何内容；相反，它们返回中央分发器使用的动作对象。'
- en: These may be subtle differences to you, and that’s okay—your goal is learning
    about Redux, not doing a “spot the differences” exercise. [Figure 10.2](kindle_split_022_split_001.xhtml#ch10fig02)
    shows an overview of the Redux architecture. You’ll dive into each of the different
    sections, explore how they work, and develop a Redux architecture for your app.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这些可能对您来说很微妙，但这没关系——您的目标是学习 Redux，而不是做“找出不同”的练习。[图 10.2](kindle_split_022_split_001.xhtml#ch10fig02)展示了
    Redux 架构的概览。您将深入研究每个不同的部分，探索它们是如何工作的，并为您的应用程序开发一个 Redux 架构。
- en: Figure 10.2\. An overview of Redux
  id: totrans-55
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 10.2\. Redux 概览
- en: '![](Images/10fig02_alt.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/10fig02_alt.jpg)'
- en: As you can see in [figure 10.2](kindle_split_022_split_001.xhtml#ch10fig02),
    actions, a store, and reducers make up the bulk of the Redux architecture. Redux
    uses a single centralized state object that’s updated in specific, deterministic
    ways. An action is created when you want to update state (usually due to an event
    like a click). The action will have a type that a certain reducer will handle.
    The reducer that handles the given action type will make a copy of the current
    state, modify it with data from the action, and then return the new state. When
    the store is updated, view layers (React in our case) can listen to updates and
    respond accordingly. Also note that in the figure the views are just reading in
    updates from the store—they don’t care about the data being communicated to them.
    The `React-redux` library handles passing new props to components when the store
    changes, but views still just receive and display data.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在[图 10.2](kindle_split_022_split_001.xhtml#ch10fig02)中看到的，动作、存储和减少器构成了 Redux
    架构的主体。Redux 使用一个单一的集中式状态对象，该对象以特定的、确定的方式更新。当您想要更新状态（通常是由于点击等事件）时，会创建一个动作。该动作将有一个特定减少器将处理的类型。处理给定动作类型的减少器将复制当前状态，使用动作中的数据对其进行修改，然后返回新状态。当存储更新时，视图层（在我们的案例中是
    React）可以监听更新并相应地做出反应。此外，请注意，在图中，视图只是从存储中读取更新——它们不关心传达给它们的数据。《React-redux》库在存储更改时处理将新属性传递给组件，但视图仍然只是接收和显示数据。
- en: 10.1.2\. Getting set up for Redux
  id: totrans-58
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.1.2\. 为 Redux 准备设置
- en: Redux is a paradigm for your application architecture, but it’s also a library
    you can install. This is one area where Redux shines over a “raw” Flux implementation.
    There are so many implementations of the Flux paradigm—Flummox, Fluxxor, Reflux,
    Fluxible, Lux, McFly, and MartyJS, to name a few—and they all have varying degrees
    of community support and different APIs. Redux enjoys strong community support,
    but the Redux library itself has a small, powerful API that has helped it become
    one of the most popular and relied-upon libraries for React application architecture.
    In fact, it’s so common to see Redux used with React that the core teams for each
    library often interact with each other and ensure compatibility and feature-awareness.
    Some people are even on both teams, so there’s generally great visibility and
    communication between the projects.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Redux 是您应用程序架构的范式，但它也是一个您可以安装的库。这是 Redux 在“原始”Flux 实现上发光的一个领域。有如此多的 Flux 范式实现——Flummox、Fluxxor、Reflux、Fluxible、Lux、McFly
    和 MartyJS 等——它们都有不同程度的社区支持以及不同的 API。Redux 拥有强大的社区支持，但 Redux 库本身有一个小而强大的 API，这有助于它成为
    React 应用程序架构中最受欢迎和依赖的库之一。事实上，Redux 与 React 一起使用如此普遍，以至于每个库的核心团队通常相互交流，确保兼容性和功能意识。甚至有些人同时在两个团队中，因此项目之间通常有很好的可见性和沟通。
- en: 'To get set up to use Redux, you’re going to need to do a few things:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置使用 Redux，你需要做几件事情：
- en: Make sure you’ve run `npm install` with the source code from the current chapter
    so all the right dependencies are installed locally. In this chapter, you’ll start
    to take advantage of some new libraries, including `js-cookie`, `redux-mock-store`,
    and `redux`.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保您已经使用当前章节的源代码运行了 `npm install`，以便所有正确的依赖项都已在本地上安装。在本章中，您将开始利用一些新的库，包括 `js-cookie`、`redux-mock-store`
    和 `redux`。
- en: Install the Redux developer tools. You can use them to inspect the Redux store
    and actions in the browser.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 Redux 开发者工具。您可以使用它们在浏览器中检查 Redux 存储和动作。
- en: 'Redux is predictable by design and that makes it easy to create some amazing
    debugging tools. Engineers like Dan Abramov and others who work on the Redux and
    React libraries have helped create some powerful tools for working with Redux
    applications. Because the state in Redux changes in predictable ways, debugging
    in new ways is possible: you can track individual changes to your app state, inspect
    differences between changes, and even rewind and replay your app state over time.
    The Redux Dev Tools extension lets you do all this and more and comes bundled
    as a browser extension. To install it for your browser, follow the instructions
    at [https://github.com/zalmoxisus/redux-devtools-extension](https://github.com/zalmoxisus/redux-devtools-extension).
    [Figure 10.3](kindle_split_022_split_001.xhtml#ch10fig03) shows a sneak peek of
    what’s available with the Redux Dev Tools.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Redux 是按设计可预测的，这使得创建一些惊人的调试工具变得容易。像 Dan Abramov 这样的工程师以及其他在 Redux 和 React 库上工作的工程师已经帮助创建了一些用于处理
    Redux 应用的强大工具。由于 Redux 中的状态以可预测的方式变化，因此以新的方式进行调试成为可能：您可以跟踪应用程序状态的个别更改，检查更改之间的差异，甚至可以在时间上回放和重播应用程序状态。Redux
    Dev Tools 扩展程序让您能够做到这一切，并且作为浏览器扩展程序捆绑提供。要为您的浏览器安装它，请遵循[https://github.com/zalmoxisus/redux-devtools-extension](https://github.com/zalmoxisus/redux-devtools-extension)上的说明。[图
    10.3](kindle_split_022_split_001.xhtml#ch10fig03) 展示了 Redux Dev Tools 可用的预览。
- en: Figure 10.3\. The Redux Dev Tools extension bundles the popular Redux Dev Tools
    library from Dan Abramov in a convenient browser extension. With it, you can rewind
    and replay your Redux app, inspect changes one by one, examine diffs between changes
    in state, review your entire app state in one area, generate testing boilerplate,
    and more.
  id: totrans-64
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 10.3\. Redux Dev Tools 扩展程序将 Dan Abramov 的流行 Redux Dev Tools 库打包成一个方便的浏览器扩展。有了它，您可以回放和重播您的
    Redux 应用，逐个检查更改，检查状态更改之间的差异，在一个区域中查看您的整个应用程序状态，生成测试模板，等等。
- en: '![](Images/10fig03_alt.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/10fig03_alt.jpg)'
- en: After installing the extension, you should see the new Dev Tools icon in your
    browser toolbar. As of the time of writing, it only appears colorized when it
    detects a Redux app instance in development mode, so if you visit the app or other
    sites that don’t have Redux set up, the extension won’t work yet. But once you
    configure the app, you’ll see the icon appear with color, and clicking it will
    open the tools.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 安装扩展后，您应该在浏览器工具栏中看到新的 Dev Tools 图标。截至写作时，它仅在检测到开发模式下的 Redux 应用实例时才会着色显示，因此如果您访问没有设置
    Redux 的应用或其他网站，扩展程序将无法工作。但一旦您配置了应用，您将看到带有颜色的图标出现，点击它将打开工具。
- en: 10.2\. Creating actions in Redux
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2\. 在 Redux 中创建动作
- en: In Redux, actions are payloads of information that send data from your application
    to your store. Apart from an action, the store doesn’t have any other way to get
    data. Actions are used throughout a Redux application to initiate changes in data,
    although they themselves are not responsible for updating the state (store) of
    the app. Reducers are more involved with that part of the architecture, and we’ll
    look at those after actions. If you’re used to being able to update the state
    of your app however you like, you may not like actions at first. They can take
    some getting used to, but they lead to apps that are usually more predictable
    and easier to debug. If the way data changes in your app is tightly controlled,
    you can easily predict what should and shouldn’t have changed in your app. [Figure
    10.4](kindle_split_022_split_002.xhtml#ch10fig04) shows where actions fit into
    the broader picture. We’re starting with actions and will work our way through
    the Redux flow, through the store, reducers, and eventually back to React to complete
    the data flow.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Redux 中，动作是信息负载，用于将数据从您的应用程序发送到您的存储。除了动作之外，存储没有其他方式获取数据。动作在整个 Redux 应用程序中用于启动数据变化，尽管它们本身并不负责更新应用程序的状态（存储）。与架构的这一部分更相关的是
    Reducers，我们将在动作之后查看它们。如果您习惯于按自己的喜好更新应用程序的状态，您可能一开始不会喜欢动作。它们可能需要一些时间来适应，但它们会导致应用程序通常更可预测且更容易调试。如果您的应用程序中数据变化的方式受到严格控制，您可以轻松预测应用程序中应该和不应该发生变化的内容。[图
    10.4](kindle_split_022_split_002.xhtml#ch10fig04) 显示了动作在更广泛画面中的位置。我们从动作开始，将逐步通过
    Redux 流，通过存储、Reducers，最终回到 React 以完成数据流。
- en: Figure 10.4\. Actions are how your Redux application knows to change; they have
    a type and any additional information that your app needs.
  id: totrans-69
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.4. 操作是Redux应用程序知道如何更改的方式；它们有一个类型和任何其他应用程序需要的附加信息。
- en: '![](Images/10fig04_alt.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/10fig04_alt.jpg)'
- en: What does a Redux action look like? It’s a plain old JavaScript object (POJO)
    with a required *type* key and anything else you want on it. The type key will
    be used by reducers and other Redux tools to associate a set of changes together.
    Every unique type of action should have a unique type key. Types should typically
    be defined as string constants, and you’re free to use whatever unique names you
    like for these, although coming up with a naming pattern to follow is a good idea.
    [Listing 10.1](kindle_split_022_split_002.xhtml#ch10ex01) shows a few examples
    of the action type names you might come up with.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Redux操作看起来是什么样子？它是一个普通的JavaScript对象（POJO），包含一个必需的 *type* 键和任何其他你想要的内容。类型键将由reducer和其他Redux工具用来关联一系列更改。每个独特的操作类型都应该有一个独特的类型键。类型通常定义为字符串常量，你可以自由地使用你喜欢的任何独特名称，尽管制定一个遵循的命名模式是个好主意。[列表10.1](kindle_split_022_split_002.xhtml#ch10ex01)展示了你可能想出的几个操作类型名称的例子。
- en: In general, you should keep your actions so they only have the information on
    them that they absolutely need. That way, you’ll avoid passing extra data around
    and have less information to think about. The next listing shows two simple actions,
    one with additional data on it and one without. Note that you can name the additional
    keys on actions whatever you want, but this can be confusing if you aren’t consistent
    and is especially problematic for teams.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，你应该确保你的操作只包含它们绝对需要的那些信息。这样，你就可以避免传递额外的数据，并且需要思考的信息也会更少。下面的列表展示了两个简单的操作，一个包含额外的数据，另一个则没有。请注意，你可以根据需要为操作上的额外键命名，但如果你不一致，这可能会造成混淆，尤其是在团队中尤其如此。
- en: Listing 10.1\. Some simple Redux actions
  id: totrans-73
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.1. 一些简单的Redux操作
- en: '[PRE3]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '***1* An action can contain info that will tell your application about how
    it should change, like a new user email address, error diagnostics, or other info.**'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** 一个操作可以包含信息，告诉你的应用程序如何更改，比如新的用户电子邮件地址、错误诊断或其他信息。'
- en: '***2* Every action must have a type—without a type, your app doesn’t know what
    sort of changes you need to make to the store.**'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** 每个操作都必须有一个类型——没有类型，你的应用程序不知道需要对存储进行何种更改。'
- en: '***3* Types are usually uppercase string constants so you can tell them apart
    from regular values in your app, but here I use a name-spacing scheme to ensure
    actions are unique but readable.**'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** 类型通常是大写字符串常量，这样你就可以在应用程序中将它们与常规值区分开来，但在这里我使用了一个命名空间方案来确保操作是唯一的但可读的。'
- en: 10.2.1\. Defining action types
  id: totrans-78
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.2.1. 定义操作类型
- en: Although you may add more later in the chapter, you can start transitioning
    your Letters Social app to a Redux architecture by laying out some action types.
    These will usually map to user actions such as logging in, logging out, changing
    a form value, and so on, but they don’t necessarily have to be user actions. You
    may want to create action types for an opened, resolved, or errored network request
    or any other number of things that don’t directly pertain to a user.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以在本章的后面添加更多内容，但你可以通过列出一些操作类型来开始将你的Letters Social应用程序过渡到Redux架构。这些类型通常映射到用户操作，如登录、登出、更改表单值等，但它们不一定是用户操作。你可能想要为打开、解决或错误的网络请求或其他不直接涉及用户的事情创建操作类型。
- en: It’s also worth noting that in a smaller app, you might not necessarily have
    to define your action types in a constants file; you could just as well remember
    to pass them in when you create actions or hardcode them yourself. The downside
    is that as your app grows, keeping track of action types will be a pain point
    and could lead to difficult debugging or refactoring situations. In most real-world
    cases, you’ll define your actions, so that’s what you’ll do here, too.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，在一个较小的应用程序中，你可能不一定需要在常量文件中定义你的操作类型；你可以在创建操作时记住传递它们，或者自己硬编码它们。缺点是，随着你的应用程序的增长，跟踪操作类型将是一个痛点，可能会导致困难的调试或重构情况。在大多数实际情况下，你会定义你的操作，所以这里你也会这样做。
- en: You’ll sketch out a few action types that you can expect to use, but you can
    feel free to add or remove them over time as needed. You’ll use the name-spacing
    approach to action types here, but remember when creating your own actions that
    you can follow whatever pattern you feel is best as long as they are unique. You’ll
    also “bundle” similar action types together in objects, but they could just as
    easily be spread out and exported as individual constants. The advantage to bundling
    is that you can group them together and use shorter names (`GET`, `CREATE`, and
    so on) without having to build those into the variable names themselves (`UPDATE_USER_PROFILE`,
    `CREATE_NEW_POST`, and so on). [Listing 10.2](kindle_split_022_split_002.xhtml#ch10ex02)
    shows how to create your initial action types. You’ll put these in src/constants/types.js.
    You’re creating all the actions you’ll need for this chapter right now so you
    can reference them and don’t have to constantly go back to the file.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 您将草拟一些您预期会使用的动作类型，但您可以随时根据需要添加或删除它们。您将使用名称空间方法来处理动作类型，但请记住，在创建自己的动作时，只要它们是唯一的，您可以遵循您认为最好的任何模式。您还可以将类似动作类型“捆绑”到对象中，但它们也可以轻松地分散并作为单个常量导出。捆绑的优势在于，您可以将它们分组在一起，并使用更短的名字（如
    `GET`、`CREATE` 等），而无需将它们构建到变量名本身中（如 `UPDATE_USER_PROFILE`、`CREATE_NEW_POST` 等）。[列表
    10.2](kindle_split_022_split_002.xhtml#ch10ex02) 展示了如何创建您的初始动作类型。您将把它们放在 src/constants/types.js
    中。您现在正在创建本章所需的全部动作，这样您可以引用它们，而无需不断回到文件中。
- en: Listing 10.2\. Defining action types (src/contstants/types.js)
  id: totrans-82
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.2\. 定义动作类型（src/contstants/types.js）
- en: '[PRE4]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: When using the Redux developer tools, these action types will show up in a timeline
    of your app’s state changes, so grouping names in a URL-like fashion like in [listing
    10.2](kindle_split_022_split_002.xhtml#ch10ex02) can make them easier to read
    when you have many actions and action types. You could also use `:` characters
    to separate them (`namespace:action_name:status`) or use whatever convention makes
    the most sense to you.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 Redux 开发者工具时，这些动作类型将显示在您应用程序状态变化的时序图中，因此像 [列表 10.2](kindle_split_022_split_002.xhtml#ch10ex02)
    中的那样以 URL 样式分组名称可以使它们在您有许多动作和动作类型时更容易阅读。您也可以使用 `:` 字符来分隔它们（`namespace:action_name:status`）或使用您认为最有意义的任何约定。
- en: 10.2.2\. Creating actions in Redux
  id: totrans-85
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.2.2\. 在 Redux 中创建动作
- en: 'Now that you have some types defined, you can start doing something with actions.
    You’ll reuse logic from preexisting parts of the app, so a lot of the code may
    look familiar to you. This is actually a good point to reflect on briefly: most
    of a Redux app shouldn’t be a complete redo of any existing application logic.
    Hopefully, you’re able to clean it up, but the main work of converting it to use
    Redux can potentially just be mapping the different aspects of your application
    state to the patterns Redux enforces. At any rate, we need to get started with
    actions.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经定义了一些类型，您就可以开始使用动作做一些事情了。您将重用应用程序现有部分的逻辑，因此大部分代码可能对您来说都很熟悉。这实际上是一个值得简要反思的好点：Redux
    应用程序的大部分内容不应该是对任何现有应用程序逻辑的完全重做。希望您能够对其进行清理，但将应用程序状态的不同方面映射到 Redux 强制执行的模式上可能只是转换到使用
    Redux 的主要工作。无论如何，我们需要开始处理动作。
- en: Actions are how you initiate state changes in Redux applications; you can’t
    just modify a property directly like you might in other frameworks. Actions are
    created with *action creators*—functions that return an action object—and dispatched
    by the store using a `dispatch` function.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 动作是您在 Redux 应用程序中启动状态变化的方式；您不能像在其他框架中那样直接修改属性。动作是通过 *动作创建器*（函数返回动作对象）创建的，并通过
    `dispatch` 函数由存储库分发。
- en: We don’t want to get too far ahead of ourselves here. I’ll just cover the action
    creators themselves first. You’ll start simple and create some actions that should
    indicate to your app when loading has started and completed. You won’t need to
    pass any additional information in this time, but I’ll cover parameterized action
    creators next. The next listing shows how to create two action creators for loading
    and loaded actions. To keep things organized, you’ll put any action creators under
    the actions directory. The same will go for other Redux-related files; reducers
    and the store will get their own directories, too.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不想在这里走得太远。我首先会介绍动作创建器本身。您将从简单开始，创建一些动作，以指示您的应用程序何时开始和完成加载。在这个时候，您不需要传递任何额外的信息，但我会在下一节介绍参数化动作创建器。下一个列表显示了如何创建加载和加载动作的两个动作创建器。为了保持组织结构，您将把任何动作创建器放在动作目录下。对于其他与
    Redux 相关的文件也是如此；还原器和存储库将有自己的目录。
- en: Listing 10.3\. `loading` and `loaded` action creators (src/actions/loading.js)
  id: totrans-89
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.3\. `loading`和`loaded`动作创建器（src/actions/loading.js）
- en: '[PRE5]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '***1* Import your types from the constants file.**'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 从常量文件导入你的类型。**'
- en: '***2* Return an action object with required type key using loading type you
    defined earlier**'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 使用你之前定义的加载类型返回一个包含所需type键的动作对象**'
- en: '***3* Export an action creator for a loaded action.**'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 导出一个加载动作的动作创建器。**'
- en: 10.2.3\. Creating the Redux store and dispatching actions
  id: totrans-94
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.2.3\. 创建Redux store和分发动作
- en: Action creators won’t do anything by themselves to change your app state (they
    just return objects). You need to use the dispatcher provided by Redux in order
    for the action creators to have any effect. The `dispatch` function is provided
    by the Redux store itself and will be the way you send actions into Redux to be
    handled. You’ll set up the Redux store next so you can use its `dispatch` function
    with your actions.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 动作创建器本身不会做任何事情来改变你的应用状态（它们只是返回对象）。你需要使用Redux提供的分发器，以便动作创建器产生任何效果。`dispatch`函数由Redux
    store本身提供，并将是你将动作发送到Redux以进行处理的方式。你将设置Redux store，以便你可以使用其`dispatch`函数与你的动作一起使用。
- en: 'Before you set up your store, you’ll need to create a root reducer file that
    will allow you to create a valid store; the reducer won’t do anything until later
    when you look at reducers and build them out. You’ll create a folder called reducers
    in src and inside it a file, root.js. In this file, you’ll use the `combineReducers`
    function provided by Redux to set up where your future reducers will go. This
    function does exactly what it sounds like it does: combines multiple reducers
    into one.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在你设置store之前，你需要创建一个根reducer文件，这将允许你创建一个有效的store；reducer在稍后查看reducer并构建它们之前不会做任何事情。你将在src中创建一个名为reducers的文件夹，并在其中创建一个文件，名为root.js。在这个文件中，你将使用Redux提供的`combineReducers`函数来设置未来reducer的位置。这个函数确实做了它听起来应该做的事情：将多个reducer合并为一个。
- en: Without the ability to combine reducers, you’d run into issues with conflicts
    between multiple reducers and would have to find ways to merge reducers or route
    actions. This is one area where the benefits of Redux can be tangibly observed.
    There’s a bit more work in setting everything up, but once the work is done, Redux
    makes it easier to scale application state management. The next listing shows
    how to create the root reducer file.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 没有合并reducer的能力，你会遇到多个reducer之间的冲突问题，并需要找到合并reducer或路由动作的方法。这是Redux优势可以具体观察到的领域之一。设置一切需要更多的工作，但一旦完成工作，Redux会使应用状态管理更容易扩展。下一个列表展示了如何创建根reducer文件。
- en: Listing 10.4\. Creating the root store (src/reducers/root.js)
  id: totrans-98
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.4\. 创建根store（src/reducers/root.js）
- en: '[PRE6]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '***1* Import the combineReducers tool from Redux.**'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 从Redux导入combineReducers工具。**'
- en: '***2* Create the root reducer using combineReducers with empty object for now**'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 使用combineReducers创建根reducer，目前使用空对象**'
- en: '***3* Export the root reducer.**'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 导出根reducer。**'
- en: 'Now that you have a reducer set up for Redux to use, you’ll configure and set
    up the store. Create a folder called store and create several files inside it:
    store.js, stores/store.prod.js, and stores/store.dev.js. These files are responsible
    for exporting a function that creates your store for you and, if you’re in development
    mode, integrates the developer tools. [Listing 10.5](kindle_split_022_split_002.xhtml#ch10ex05)
    shows creating the store-related files side by side in the same listing. You’re
    using different files for each environment here because you might want to include
    different middleware and other libraries for development and production environments.
    This just a convention—there’s nothing about Redux that requires you to put functions
    in many files or one.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经为Redux设置了一个reducer，接下来你需要配置和设置store。创建一个名为store的文件夹，并在其中创建几个文件：store.js、stores/store.prod.js和stores/store.dev.js。这些文件负责导出一个函数，为你创建store，并在开发模式下集成开发者工具。[列表10.5](kindle_split_022_split_002.xhtml#ch10ex05)展示了在同一列表中创建与store相关的文件。在这里，你使用不同的文件为每个环境，因为你可能希望在开发环境和生产环境中包含不同的中间件和其他库。这只是一个约定——Redux没有要求你必须将函数放在多个文件或一个文件中。
- en: Listing 10.5\. Creating the Redux store
  id: totrans-104
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.5\. 创建Redux store
- en: '[PRE7]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '***1* This file makes it easier to use the store in your app without having
    to determine if you want the development or production store.**'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 此文件使得在使用你的应用中的store时，无需确定是使用开发环境还是生产环境的store变得更容易。**'
- en: '***2* Pass in initial state to your configuration for Redux to use**'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将初始状态传递给你的Redux配置**'
- en: '***3* Use Redux createStore method to create your store**'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 使用 Redux createStore 方法创建您的存储**'
- en: '***4* Import compose utility from Redux, which will let you combine middleware**'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 从 Redux 中导入 compose 工具，这将允许您组合中间件**'
- en: '***5* Make sure you’re accessing the same store consistently—this ensures you
    return the same store if another file accesses an already-created store.**'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 确保您始终访问相同的存储——这确保了如果另一个文件访问已创建的存储，则返回相同的存储。**'
- en: '***6* If dev tools extension is installed, this will hook into it**'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 如果已安装开发工具扩展，这将连接到它**'
- en: Now that you have a store configured and ready to use, you can try dispatching
    some actions and see how they work. Before long, you’ll hook Redux up to React,
    but remember that you don’t have to use Redux with React or with any library or
    framework. There are other open-source projects using Redux to integrate with
    frameworks like Angular, Vue, and more.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经配置好并准备好使用存储，您可以尝试分发一些动作并查看它们的工作方式。不久，您将把 Redux 连接到 React，但请记住，您不必在 React
    或任何库或框架中使用 Redux。还有其他开源项目使用 Redux 与 Angular、Vue 等框架集成。
- en: 'The Redux store exposes a couple of important functions that you’ll use throughout
    working with Redux: `getState` and `dispatch`. `getState` will be used to grab
    a snapshot of your Redux store state at a given point in time, and `dispatch`
    is how you’ll send actions to the Redux store. When calling the dispatch method,
    you pass in an action that’s the result of calling an action creator. Using the
    `store.dispatch()` method is the only way to trigger a state change in Redux,
    so you’ll be using it all over the place. Next you’ll try using the store to dispatch
    a few actions using the `loading` action creators that you set up before. The
    following listing shows how to dispatch a few actions using a temporary file (src/store/exampleUse.js).
    This file is just for demonstration purposes and won’t be needed to make the main
    app work.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: Redux 存储公开了一些重要的函数，您将在整个使用 Redux 的过程中使用它们：`getState` 和 `dispatch`。`getState`
    将用于在特定时间点获取 Redux 存储状态的快照，而 `dispatch` 是您向 Redux 存储发送动作的方式。调用 dispatch 方法时，您传入一个动作，该动作是调用动作创建器的结果。使用
    `store.dispatch()` 方法是触发 Redux 中状态变化的唯一方式，因此您将到处使用它。接下来，您将尝试使用存储来分发一些动作，使用您之前设置的
    `loading` 动作创建器。以下列表显示了如何使用临时文件（src/store/exampleUse.js）分发一些动作。此文件仅用于演示目的，不会用于使主应用工作。
- en: Listing 10.6\. Dispatching actions (src/store/exampleUse.js)
  id: totrans-114
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.6\. 分发动作（src/store/exampleUse.js）
- en: '[PRE8]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '***1* Import configureStore method and use it to create a store**'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 导入 configureStore 方法并使用它来创建存储**'
- en: '***2* Call store’s dispatch method and pass in invoked action creator; will
    return object for dispatch method to use**'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 调用存储的 dispatch 方法并传入调用的动作创建器；将为 dispatch 方法返回一个对象**'
- en: '***3* Dispatch another action.**'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 分发另一个动作。**'
- en: To dispatch these actions, all you need to do is import the exampleUse file
    into your main app file, and it will run when you open the app. [Listing 10.7](kindle_split_022_split_002.xhtml#ch10ex07)
    shows the minor modification you need to make to src/index.js. Once you connect
    Redux to React, you’ll interact with Redux through React components and won’t
    need to manually dispatch actions like you are here for demonstration purposes.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 要分发这些动作，您只需将 exampleUse 文件导入到主应用文件中，它将在您打开应用时运行。[列表 10.7](kindle_split_022_split_002.xhtml#ch10ex07)
    显示您需要对 src/index.js 进行的一些微小修改。一旦将 Redux 连接到 React，您将通过 React 组件与 Redux 交互，而无需像在这里进行演示那样手动分发动作。
- en: Listing 10.7\. Importing the exampleUse file (src/index.js)
  id: totrans-120
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.7\. 导入 exampleUse 文件（src/index.js）
- en: '[PRE9]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '***1* Import the store file so it will run when you open the app.**'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 导入存储文件，以便在打开应用时运行。**'
- en: If you load the app in development mode (using `npm run dev`), you should see
    that the Redux dev tools icon is enabled. When the app runs now, the imported
    file that you’ve created will run and invoke the store dispatcher several times,
    sending actions off to the store. Right now, there isn’t any handling set up for
    the actions (via reducers), and you haven’t hooked anything up to React, so there
    won’t be any meaningful changes. But if you open the developer tools and look
    at the action history, you should see an action dispatched and recorded for each
    of the loading actions you dispatched. [Figure 10.5](kindle_split_022_split_002.xhtml#ch10fig05)
    shows the actions being dispatched in the context of your diagram and the results
    you should see in the Redux developer tools.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你以开发模式加载应用（使用 `npm run dev`），你应该会看到 Redux 开发者工具图标已启用。现在，当应用运行时，你导入的文件将运行并多次调用存储分发器，将动作发送到存储。目前，还没有为动作设置处理程序（通过减少器），而且你没有将任何东西连接到
    React，所以不会有任何有意义的更改。但如果你打开开发者工具并查看动作历史，你应该会看到你分发的每个加载动作都分发了并记录了动作。[图 10.5](kindle_split_022_split_002.xhtml#ch10fig05)
    显示了在您的图表上下文中分发的动作以及你应在 Redux 开发者工具中看到的输出。
- en: Figure 10.5\. When you run your app, the example store you created will receive
    the results of your action creators and dispatch them to the store. Right now,
    you don’t have any reducers set up to do anything, so little will happen. Once
    you have reducers set up, Redux will determine what changes to state need to be
    made depending on what type of action is dispatched.
  id: totrans-124
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 10.5\. 当你运行你的应用时，你创建的示例存储将接收你的动作创建者的结果并将它们分发给存储。目前，你没有设置任何减少器来执行任何操作，所以几乎不会发生什么。一旦你设置了减少器，Redux
    将根据分发的动作类型确定需要做出的状态更改。
- en: '![](Images/10fig05_alt.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/10fig05_alt.jpg)'
- en: 10.2.4\. Asynchronous actions and middleware
  id: totrans-126
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.2.4\. 异步操作和中间件
- en: 'You can dispatch actions, but right now they’re only synchronous. There are
    many cases where you’ll want to make a change to your app based on an *asynchronous*
    action. These might be a network request, reading a value back from the browser
    (via local storage, cookie stores, and so forth), working with WebSockets, or
    any other async action. Redux doesn’t have support for asynchronous actions out
    of the box because it expects actions to just be objects (not Promises or anything
    else). But you can enable it by integrating a library you’ve already installed:
    `redux-thunk`.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以分发动作，但现在是同步的。有许多情况下，你将想要根据异步动作更改你的应用。这些可能是一个网络请求，从浏览器中读取值（通过本地存储、cookie 存储等等），使用
    WebSocket，或任何其他异步动作。Redux 默认不支持异步动作，因为它期望动作只是对象（不是 Promise 或其他）。但你可以通过集成你已安装的库来启用它：`redux-thunk`。
- en: '`redux-thunk` is a Redux *middleware* library, which means it works as a sort
    of “on the way” or pass-through mechanism for Redux. You’ve probably used other
    APIs that make use of this concept, like Express or Koa (server-side frameworks
    for Node.js). Middleware works by letting you hook into a cycle or process of
    some kind in a composable way, meaning that you can create and use multiple middleware
    functionalities independent of each other in a single project.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`redux-thunk` 是一个 Redux *中间件* 库，这意味着它作为 Redux 的某种“途中”或传递机制。你可能已经使用过其他利用这个概念的
    API，比如 Express 或 Koa（Node.js 的服务器端框架）。中间件通过以可组合的方式让你钩入某种周期或过程，这意味着你可以在单个项目中独立创建和使用多个中间件功能。'
- en: Redux middleware is, in the words of the Redux docs, a “third-party extension
    point between dispatching an action and the moment it reaches the reducer.” This
    means you have one or more opportunities to act on or because of an action before
    it gets handled by a reducer. You’ll use Redux middleware to create an error-handling
    solution next, but right now you can use the `redux-thunk` middleware to enable
    asynchronous action creation in your application. [Listing 10.8](kindle_split_022_split_002.xhtml#ch10ex08)
    shows how to integrate the `redux-thunk` middleware into your app. Note that you
    should add the middleware to both your production and development stores (configureStore.prod.js
    and configureStore.dev.js). Remember, you can choose whatever production/development
    store setup makes the most sense for your situation—I only broke them into two
    here to make clear which one gets used for each environment.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Redux文档的描述，Redux中间件是“在分发动作和动作到达reducer之间的第三方扩展点。”这意味着在动作被reducer处理之前，您有一个或多个机会对动作进行操作或因为动作而采取行动。您将使用Redux中间件来创建一个错误处理解决方案，但现在您可以使用`redux-thunk`中间件来在应用程序中启用异步动作创建。[列表10.8](kindle_split_022_split_002.xhtml#ch10ex08)展示了如何将`redux-thunk`中间件集成到您的应用程序中。请注意，您应该将中间件添加到您的生产环境和开发存储（configureStore.prod.js和configureStore.dev.js）中。记住，您可以选择最适合您情况的任何生产/开发存储设置——我只是将它们分成两部分，以便清楚地说明每个环境使用哪个。
- en: Listing 10.8\. Enabling asynchronous action creators via redux-thunk
  id: totrans-130
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.8\. 通过redux-thunk启用异步动作创建
- en: '[PRE10]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '***1* To integrate middleware into your Redux store, pull in applyMiddleware
    utility**'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 要将中间件集成到您的Redux存储中，请引入applyMiddleware实用工具**'
- en: '***2* Insert and order middleware in Redux within the applyMiddleware function—here
    you’re inserting the redux-thunk middleware into your store.**'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 在applyMiddleware函数中插入并排序Redux中的中间件——在这里，您正在将redux-thunk中间件插入到您的存储中。**'
- en: You can create async action creators now that you have the `redux-thunk` middleware
    installed. Why do I say *async action creators* and not *asynchronous actions*?
    Because even when you’re doing asynchronous things like making network requests,
    the actions you create aren’t the asynchronous tasks themselves. Instead, `redux-thunk`
    teaches your Redux store to evaluate a Promise when it comes through. The course
    of that Promise is how you dispatch actions for your store. Nothing has really
    changed about Redux. The actions are still synchronous, but Redux now knows to
    wait for Promises to resolve when you pass them into the dispatch function.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经安装了`redux-thunk`中间件，可以创建异步动作创建器了。我为什么说*异步动作创建器*而不是*异步动作*？因为即使您在进行异步操作，如进行网络请求时，您创建的动作本身并不是异步任务。相反，`redux-thunk`教会您的Redux存储在动作通过时评估一个Promise。这个Promise的流程就是您为存储分发动作的方式。Redux实际上并没有发生真正的变化。动作仍然是同步的，但现在Redux知道当您将Promise传递到dispatch函数时，要等待Promise解决。
- en: In earlier chapters, you created some logic to fetch posts from your API using
    the `isomorphic-fetch` library and display them using React. Actions like these
    that perform asynchronous work will often require multiple actions to be dispatched
    (usually loading, success, and failure actions). For example, say you want to
    let a user upload files to a server that sends back progress data over the duration
    of the upload. One way of mapping actions to the different parts of this process
    would be to create an action to indicate that the upload has started, an action
    to tell the rest of the app that something is loading, an action for progress
    updates from the server, an action for the completion of the upload, and an action
    to handle errors.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，您使用`isomorphic-fetch`库创建了一些逻辑来从您的API获取帖子，并使用React来显示它们。这类执行异步工作的操作通常需要分发多个动作（通常是加载、成功和失败动作）。例如，假设您想让用户上传文件到服务器，该服务器在上传过程中发送进度数据。将动作映射到这个过程的不同部分的一种方法可以是创建一个动作来指示上传已开始，一个动作来告诉应用程序的其他部分正在加载，一个动作用于从服务器接收进度更新，一个动作用于上传完成，以及一个动作来处理错误。
- en: '`redux-thunk` works by wrapping the dispatch method of a store so that it will
    handle dispatching something other than plain objects (like Promises, an API dealing
    with asynchronous flows). The middleware will dispatch created actions asynchronously
    (at the beginning and end of a request, for example) as the Promise is executed
    and let you handle those changes appropriately. As already noted, the key distinction
    here is that actions themselves are still synchronous, but when they get dispatched
    and sent to reducers they are asynchronous. [Figure 10.6](kindle_split_022_split_002.xhtml#ch10fig06)
    shows how this works.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`redux-thunk` 通过包装存储的 dispatch 方法来工作，使其能够处理除了普通对象（如 Promises、处理异步流的 API）之外的其他内容。中间件将异步地（例如在请求的开始和结束时）分发创建的动作，当
    Promise 执行时让你适当地处理这些变化。正如已经提到的，这里的关键区别是动作本身仍然是同步的，但它们在分发到 reducers 时是异步的。[图 10.6](kindle_split_022_split_002.xhtml#ch10fig06)
    展示了这是如何工作的。'
- en: Figure 10.6\. Asynchronous action creators are enabled by a middleware library
    like `redux-thunk`, which allows you to dispatch something besides an action like
    a Promise (a way to do asynchronous work that’s part of the JavaScript specification).
    It will resolve the Promise and let you dispatch actions at different points over
    the lifetime of the Promise (before execution, on completion, on error, and so
    on).
  id: totrans-137
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 10.6\. 异步动作创建器由像 `redux-thunk` 这样的中间件库启用，它允许你分发除了动作之外的内容，如 Promise（这是 JavaScript
    规范中异步工作的一部分）。它将解析 Promise，并允许你在 Promise 生命周期的不同点分发动作（在执行之前，在完成时，在出错时等等）。
- en: '![](Images/10fig06_alt.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/10fig06_alt.jpg)'
- en: Next you’ll use what you know about async action creators to write some action
    creators that will handle fetching and creating posts. Because `redux-thunk` wraps
    the store’s dispatch method, you can return a function from your action creator
    that receives the dispatch method as a function, allowing you to dispatch multiple
    actions over the course of a Promise execution. [Listing 10.9](kindle_split_022_split_002.xhtml#ch10ex09)
    shows what this sort of action creator looks like. You’ll create several async
    action creators and a synchronous one. You’ll start by creating a handful of actions
    you’ll need to handle user interactions with posts and comments. First up is an
    error action that you’ll use to show the user error information if something goes
    wrong. In a larger application, you’ll probably need to create more than one way
    to handle errors, but for our purposes this should suffice. You can use this error
    action here and also in any component error boundaries. `componentDidCatch` will
    provide error information you can dispatch to the store.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将使用你关于异步动作创建器的知识来编写一些将处理获取和创建帖子的动作创建器。因为 `redux-thunk` 包装了存储的 dispatch
    方法，所以你可以从你的动作创建器中返回一个函数，该函数接收 dispatch 方法作为一个函数，这允许你在 Promise 执行过程中分发多个动作。[列表
    10.9](kindle_split_022_split_002.xhtml#ch10ex09) 展示了这种类型的动作创建器看起来是什么样子。你将创建几个异步动作创建器和一个同步动作创建器。你将从创建一些你需要处理用户与帖子评论交互的动作开始。首先是错误动作，你将使用它来显示用户错误信息，如果发生错误。在一个较大的应用程序中，你可能需要创建多种处理错误的方法，但对我们来说，这应该足够了。你可以在这里使用这个错误动作，也可以在任何组件错误边界中使用它。`componentDidCatch`
    将提供你可以分发到存储的错误信息。
- en: Listing 10.9\. Creating the error action (src/actions/error.js)
  id: totrans-140
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.9\. 创建错误动作（src/actions/error.js）
- en: '[PRE11]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '***1* This action creator is parameterized—you want to send error information
    to your store.**'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 这个动作创建器是参数化的——你想要将错误信息发送到你的存储。**'
- en: '***2* This action has generic app error type—in larger apps you’ll have many
    types of errors**'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 这个操作具有通用的应用程序错误类型——在较大的应用程序中，你会有许多类型的错误**'
- en: '***3* Pass along actual error and info**'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 传递实际错误和信息**'
- en: 'Now that you have a way to handle errors, you can start to write some async
    action creators. You’ll start with comments and move on to posts. The posts and
    comments actions should look similar overall with some minor differences in how
    each set of actions works. You want the ability to do a few things related to
    comments: show and hide them, load them, and create a new comment for a given
    post. [Listing 10.10](kindle_split_022_split_002.xhtml#ch10ex10) shows the comment
    actions you’ll create.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有了处理错误的方法，你可以开始编写一些异步动作创建器。你将从注释开始，然后转向帖子。帖子动作和评论动作在整体上应该看起来很相似，但在每个动作集的工作方式上会有一些细微的差别。你想要能够做一些与评论相关的事情：显示和隐藏它们，加载它们，并为给定的帖子创建一个新的评论。[列表
    10.10](kindle_split_022_split_002.xhtml#ch10ex10) 展示了你将创建的评论动作。
- en: As you create these and other actions, you’ll continue to use the `isomorphic-fetch`
    library to do network requests, but the Fetch API that it follows is becoming
    more standard in browsers and is now the de facto way to do network requests.
    When possible, you’ll keep using the Web platform APIs or libraries that follow
    the same specifications.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建这些和其他动作时，你将继续使用 `isomorphic-fetch` 库来进行网络请求，但它遵循的 Fetch API 正在浏览器中变得更加标准化，并且现在成为进行网络请求的事实标准。当可能时，你将继续使用
    Web 平台 API 或遵循相同规范的库。
- en: Listing 10.10\. Creating comment actions (src/actions/comments.js)
  id: totrans-147
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.10\. 创建评论动作（src/actions/comments.js）
- en: '[PRE12]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '***1* Import your API helpers.**'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 导入你的 API 辅助函数。**'
- en: '***2* Create parameterized action creator so you can show a particular comments
    section.**'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 创建参数化动作创建者，以便你可以显示特定的评论部分。**'
- en: '***3* You want the ability to toggle a comment section.**'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 你想要能够切换评论部分。**'
- en: '***4* Create ability to get comments—your async action creators in this file
    will use this function**'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 创建获取评论的能力——你在这个文件中的异步动作创建者将使用此函数**'
- en: '***5* Create comment from a given payload; return a function instead of a plain
    object**'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 从给定的有效负载中创建评论；返回一个函数而不是一个普通对象**'
- en: '***6* The Fetch API implements Promise-based methods like json() and blob().**'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* Fetch API 实现了基于 Promise 的方法，如 json() 和 blob()。**'
- en: '***7* Dispatch create comment action with comment JSON you get back from server**'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 使用从服务器获取的评论 JSON 创建派发评论动作**'
- en: '***8* If you receive an error, send it to store using createError action**'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8* 如果收到错误，请使用 createError 动作将其发送到存储**'
- en: '***9* Fetch comments for a particular post and use updateAvailable-Comments
    action**'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***9* 获取特定帖子的评论并使用 updateAvailable-Comments 动作**'
- en: '***10* Handle the error, if any.**'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***10* 处理任何错误。**'
- en: Now that you’ve created actions for comments, you can move on to creating actions
    for posts. The actions for posts will be similar to the ones you’ve just created
    but will also use some comment actions. The ability to mix and match different
    actions across your application is another reason Redux works well as your application
    architecture. It provides a structured, repeatable way to create functionality
    with actions and then utilize that functionality across your app.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经创建了评论的动作，你可以继续创建帖子相关的动作。帖子相关的动作将与你刚刚创建的动作类似，但也会使用一些评论动作。能够在你的应用程序中混合和匹配不同的动作是
    Redux 作为你的应用程序架构工作良好的另一个原因。它提供了一种结构化、可重复的方式来使用动作创建功能，然后在整个应用程序中利用这些功能。
- en: Next you’ll keep creating actions and add some functionality to your posts.
    In earlier chapters, you created functionality for fetching and creating posts.
    Now you’ll also create ways to like and unlike posts. The next listing shows the
    action creators related to posts in your application. You’ll start with four action
    creators for now and then explore a few more in the next listing.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将继续创建动作，并为你的帖子添加一些功能。在早期章节中，你创建了获取和创建帖子的功能。现在你还将创建点赞和取消赞帖子的方式。下一个列表显示了与你的应用程序中的帖子相关的动作创建者。你现在将开始使用四个动作创建者，然后在下一个列表中探索更多。
- en: Listing 10.11\. Creator async and synchronous actions (src/actions/posts.js)
  id: totrans-161
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.11\. 创建异步和同步动作（src/actions/posts.js）
- en: '[PRE13]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '***1* JSON API uses Link headers to indicate paging options**'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* JSON API 使用 Link 头部来指示分页选项**'
- en: '***2* As you did with comments, this action creator will pass along new comments
    to store.**'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 就像你对评论所做的那样，这个动作创建者会将新的评论传递到存储中。**'
- en: '***3* Update pagination links in store accordingly**'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 根据需要更新存储中的分页链接**'
- en: '***4* Like a particular post using its ID.**'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 使用帖子的 ID 点赞特定的帖子。**'
- en: '***5* Return function will have the dispatch and getState methods injected
    into it by Redux**'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 返回的函数将由 Redux 注入 dispatch 和 getState 方法**'
- en: '***6* Dispatch LIKE action with post attached as metadata**'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 派发带有帖子的 LIKE 动作作为元数据**'
- en: '***7* Unliking a post involves same flow, but dispatches a different action
    type**'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 取消赞一个帖子涉及相同的流程，但派发不同的动作类型**'
- en: You still need to create a few more action types for posts. You can like and
    unlike posts, but you still haven’t ported over the post creation you previously
    created. You also need a way to fetch a number of posts and single posts individually.
    [Listing 10.12](kindle_split_022_split_002.xhtml#ch10ex12) shows the corresponding
    action creators you’ll need to create.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 你仍然需要为帖子创建更多动作类型。你可以点赞和取消赞帖子，但你还没有将之前创建的帖子创建迁移过来。你还需要一种方式来获取多个帖子以及单个帖子。[列表 10.12](kindle_split_022_split_002.xhtml#ch10ex12)
    显示了你需要创建的相应的动作创建者。
- en: Hopefully by now you’re starting to get the hang of asynchronous action creators.
    In many apps, these sorts of action creators are pretty common. But the possibilities
    don’t end here. I’ve found using `redux-thunk` by itself to be sufficient for
    most applications that need asynchronous action creation, but people have created
    plenty of other libraries to address this need. For example, check out Redux Saga
    at [https://github.com/redux-saga/redux-saga](https://github.com/redux-saga/redux-saga).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 希望到现在你已经开始掌握异步动作创建者的技巧了。在许多应用中，这类动作创建者相当常见。但可能性并不止于此。我发现仅使用`redux-thunk`本身对于大多数需要异步动作创建的应用来说已经足够了，但人们已经创建了大量的其他库来满足这一需求。例如，可以查看Redux
    Saga在[https://github.com/redux-saga/redux-saga](https://github.com/redux-saga/redux-saga)。
- en: Listing 10.12\. Creating more post action creators (src/actions/posts.js)
  id: totrans-172
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.12\. 创建更多帖子动作创建者（src/actions/posts.js）
- en: '[PRE14]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '***1* As before, use getState function to access snapshot of state**'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 如前所述，使用`getState`函数访问状态快照**'
- en: '***2* Embed user ID on new post**'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 在新帖子中嵌入用户ID**'
- en: '***3* Dispatch a create post action.**'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 分发创建帖子动作。**'
- en: '***4* Grab pagination state object**'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 获取分页状态对象**'
- en: '***5* Use link header parser and pass in Link header**'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 使用链接头解析器并传入链接头**'
- en: '***6* Dispatch link action**'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 分发链接动作**'
- en: '***7* Dispatch update posts action**'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 分发更新帖子动作**'
- en: '***8* Load post from API and fetch its associated comments**'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8* 从API加载帖子并获取其相关评论**'
- en: 10.2.5\. To Redux or not to Redux?
  id: totrans-182
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.2.5\. 是使用Redux还是不使用Redux？
- en: 'With those action creators done, you’ve created the initial functionality for
    creating posts and comments. You’re still missing one area, though: authentication
    for the user. In previous chapters, you were using Firebase helpers to check for
    the user’s authentication state and update the local component state with that.
    Do you need to do the same thing with authentication? That brings up another good
    question: what belongs in Redux and what doesn’t? Let’s look at this somewhat
    contentious question before moving on.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些动作创建者完成之后，你已经创建了创建帖子评论的初始功能。尽管如此，你仍然缺少一个区域：用户的身份验证。在前面的章节中，你使用Firebase助手检查用户的身份验证状态，并使用它更新本地组件状态。你需要对身份验证做同样的事情吗？这又引出了另一个好问题：什么属于Redux，什么不属于？在我们继续之前，让我们看看这个有些争议的问题。
- en: Opinions in the React/Redux community vary from “put whatever you want in the
    store” to “absolutely everything must go in the store.” There’s also a tendency
    for engineers who have only worked with React in a Redux context to see that as
    the only way to go and think of React and Redux as one and the same. People are
    often limited by their experience, but my hope is that we can take time to consider
    the facts and tradeoffs before forming an immovable opinion.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: React/Redux社区中的观点从“把你想放什么进存储”到“绝对一切都必须放入存储”不等。还有一些工程师，他们只在Redux环境下使用React，可能会认为这是唯一的方法，并将React和Redux视为一体。人们常常受限于他们的经验，但我希望我们能够花时间考虑事实和权衡，然后再形成不可动摇的观点。
- en: For one, it’s important to remember that although React and Redux fit well together,
    the technologies themselves aren’t intrinsically linked. You don’t need Redux
    to build React applications. I hope you’ve seen that in this book. Redux is just
    another tool available to engineers—it’s not the only way to build your React
    applications and is certainly not something that invalidates “normal” React concepts
    (local component state, for example). There are some cases where you might simply
    be adding overhead by bringing a component’s state into Redux.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，重要的是要记住，尽管React和Redux配合得很好，但这两项技术本身并没有内在的联系。你不需要Redux来构建React应用。我希望你在本书中已经看到了这一点。Redux只是工程师可用的另一个工具——它不是构建React应用的唯一方式，当然也不是否定“正常”React概念（例如本地组件状态）的东西。有些情况下，你可能只是通过将组件的状态带入Redux而增加了开销。
- en: What should you do? So far, Redux has proven to be a great way to give your
    application a robust architecture that has already helped you better organize
    code and functionality (and we haven’t even gotten to reducers yet!). Based on
    your experience so far, you may be tempted to quickly agree with the “absolutely
    everything should be in the Redux store” point of view. But I want to caution
    against this impulse and look at the tradeoffs instead.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该怎么做？到目前为止，Redux已经证明是给你的应用提供一个强大架构的绝佳方式，这已经帮助你更好地组织代码和功能（我们还没有谈到reducers呢！）。根据你到目前为止的经验，你可能倾向于迅速同意“绝对一切都应该在Redux存储中”的观点。但我想对此冲动提出警告，并看看权衡的结果。
- en: 'In my experience, there are a couple questions we can ask to guide decisions
    about what does and doesn’t belong in the Redux store. The first one is this:
    do many other parts of the application need to know about this piece of state
    or functionality? If so, it should probably go in the Redux store. If the state
    is completely localized to a component, you should consider leaving it out of
    the Redux store. One example is something like a dropdown menu that doesn’t need
    to be controlled except by the user. If your app needs to control whether the
    dropdown is open or closed and respond to it opening or closing, those state changes
    should probably go through the store. But if not, keeping the state local to the
    component is fine.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我的经验，我们可以提出一些问题来指导关于哪些内容应该或不应该包含在 Redux 存储中的决策。第一个问题是这样的：应用的其他许多部分是否需要了解这一部分状态或功能？如果是这样，它可能应该放在
    Redux 存储中。如果状态完全局限于一个组件，你应该考虑将其排除在 Redux 存储之外。一个例子是像下拉菜单这样的东西，除了用户之外不需要被控制。如果你的应用需要控制下拉菜单是打开还是关闭，并对其打开或关闭做出响应，那么这些状态变化可能应该通过存储进行。但如果不是这样，将状态保留在组件本地是完全可以的。
- en: Another question is whether the state you’re dealing with would be simplified
    or better expressed in Redux. If you’re taking the state and actions for a component
    and translating them into Redux for the sake of doing so, you’re probably introducing
    additional complexity for yourself and not getting much for it. But if your state
    is complicated or particular enough that Redux would make it easier to work with,
    you might want to include it in the store.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个问题是你正在处理的状态是否可以通过 Redux 简化或更好地表达。如果你正在将组件的状态和动作转换为 Redux，仅仅是为了这样做，你可能会为自己引入额外的复杂性，而从中得到的很少。但如果你的状态复杂或足够特殊，Redux
    会使其更容易处理，你可能会希望将其包含在存储中。
- en: With those things in mind, let’s revisit the question of whether you should
    integrate the user and authentication logic into Redux. Do other parts of the
    application need to know about the user? They certainly do. Would you be able
    to better express the user logic in Redux? Without centralizing it in the store,
    you might need to replicate the logic across different pages in your application,
    and that might not be ideal. For the time being it looks like it makes sense to
    integrate the user and authentication logic into Redux.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这些因素，让我们重新审视是否应该将用户和身份验证逻辑集成到 Redux 中的问题。应用的其他部分是否需要了解用户？当然需要。你能否在 Redux
    中更好地表达用户逻辑？如果不将其集中存储在存储中，你可能需要在应用的不同页面中复制逻辑，这可能不是最佳选择。目前来看，将用户和身份验证逻辑集成到 Redux
    中似乎是合理的。
- en: Let’s see how to create some actions! [Listing 10.13](kindle_split_022_split_002.xhtml#ch10ex13)
    shows the user-related actions you’ll create. You’ll use a modern feature of the
    JavaScript language in these examples, `async/await`. If you’re unfamiliar with
    how this part of the language works, it might help to read through the Mozilla
    Developer Network documentation ([https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function))
    and the chapter on `async/await` in *Exploring ES2016 and ES2017* by Dr. Axel
    Rauschmayer (Leanpub, 2017; [http://exploringjs.com/es2016-es2017/ch_async-functions.html](http://exploringjs.com/es2016-es2017/ch_async-functions.html)).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何创建一些操作！[列表 10.13](kindle_split_022_split_002.xhtml#ch10ex13) 展示了你将创建的用户相关操作。在这些例子中，你将使用
    JavaScript 语言的现代特性 `async/await`。如果你对这部分语言的工作方式不熟悉，阅读 Mozilla 开发者网络文档（[https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function)）和
    Dr. Axel Rauschmayer 所著的《探索 ES2016 和 ES2017》一书中关于 `async/await` 的章节（Leanpub，2017；[http://exploringjs.com/es2016-es2017/ch_async-functions.html](http://exploringjs.com/es2016-es2017/ch_async-functions.html)）可能会有所帮助。
- en: Listing 10.13\. Creating user-related actions (src/actions/auth.js)
  id: totrans-191
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.13\. 创建用户相关操作（src/actions/auth.js）
- en: '[PRE15]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '***1* Import modules you’ll need for your auth-related actions.**'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 导入你将需要的用于身份验证相关动作的模块。**'
- en: '***2* Create login and logout action creators—login action will be parameterized
    to accept user and token**'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 创建登录和注销动作创建者——登录动作将被参数化以接受用户和令牌**'
- en: '***3* Log user out using Firebase**'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 使用 Firebase 注销用户**'
- en: '***4* Push user to login page, dispatch logout action, and clear user context
    (for error-tracking library)**'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 将用户推送到登录页面，分发注销动作，并清除用户上下文（用于错误跟踪库）**'
- en: '***5* Log user in with Firebase**'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 使用 Firebase 登录用户**'
- en: '***6* Async/await uses try...catch error-handling semantics**'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* Async/await 使用 try...catch 错误处理语义**'
- en: '***7* Get user and token from Firebase using await**'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 使用 await 从 Firebase 获取用户和令牌**'
- en: '***8* Try finding user you got back from Firebase with API—if they don’t exist
    (404), must sign them up using info from Firebase**'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8* 尝试使用 API 查找从 Firebase 获取的用户——如果他们不存在（404），必须使用 Firebase 的信息注册他们**'
- en: '***9* Create new user**'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***9* 创建新用户**'
- en: '***10* Dispatch login actions with new user and return from function**'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***10* 使用新用户分发登录动作并从函数中返回**'
- en: '***11* If user already existed, dispatch appropriate login actions and return**'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***11* 如果用户已存在，则分发适当的登录操作并返回**'
- en: '***12* Catch error in login process and dispatch it to store**'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***12* 在登录过程中捕获错误并将其分发到存储**'
- en: 'After all that, you’ve created actions for user-related actions, comments,
    posts, loading, and errors. If that seemed like a lot, you’ll be glad to know
    that what you’ve done is create the bulk of the raw functionality of the app.
    You still need to teach Redux how to respond to state changes with reducers in
    the next section and then wire everything up to React, but the actions you’ve
    re-created represent all the basic ways you (or a user) can interact with your
    application. This is another strength of Redux: you end up doing work to turn
    functionality into actions, but in the end you have a pretty comprehensive collection
    of what actions someone could take in your app. This can be much clearer than
    spaghetti-code–filled codebases where there’s no way to get an accurate way of
    the application, much less the different actions you can take.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些之后，你已经为用户相关动作、评论、帖子、加载和错误创建了动作。如果这看起来很多，你会很高兴知道你所做的是创建了应用程序原始功能的大部分。你仍然需要在下一节中教
    Redux 如何通过还原器响应状态变化，然后将一切连接到 React，但你重新创建的动作代表了（你或用户）与你的应用程序交互的所有基本方式。这是 Redux
    的另一个优点：你最终将功能转换为动作的工作，但最终你拥有一个相当全面的动作集合，这些动作是某人在你的应用程序中可以采取的。这比那些代码混乱、无法准确了解应用程序（更不用说不同的动作了）的代码库要清晰得多。
- en: 10.2.6\. Testing actions
  id: totrans-206
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.2.6\. 测试动作
- en: Next you’ll write some quick tests for these actions before we move on to reducers.
    For the sake of expediency, I won’t cover writing the tests for every single reducer
    or action that you set up, but I want to make sure you have some representative
    examples to get an idea of how to test different parts of a Redux app. If you’d
    like to see more examples, check out the application source code and look in the
    test directory.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续到还原器之前，你将编写一些针对这些动作的快速测试。为了方便起见，我不会涵盖为每个设置的还原器或动作编写测试，但我想要确保你有一些代表性的例子，以便了解如何测试
    Redux 应用程序的不同部分。如果你想看到更多示例，请查看应用程序源代码并查看测试目录。
- en: Redux makes testing action creators, reducers, and other parts of your Redux
    architecture straightforward. Even better, they can be tested and maintained mostly
    independently of your front-end framework. This can be especially important in
    larger applications where testing is a nontrivial endeavor (say, a business application
    instead of a weekend side project). For actions, the general idea is to assert
    that expected action type or types, and any necessary payload information is created
    based on a given action.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: Redux 使得测试动作创建者、还原器以及 Redux 架构的其他部分变得简单直接。更好的是，它们可以主要独立于前端框架进行测试和维护。这在大型应用程序中尤为重要，在这些应用程序中，测试是一项非平凡的任务（比如，一个商业应用程序而不是周末的副项目）。对于动作，一般的思想是断言预期的动作类型或类型，以及基于给定动作创建的任何必要的有效载荷信息。
- en: Most action creators can be easily tested because they usually return an object
    with a type and payload information. Sometimes, though, you need to do some additional
    setup to accommodate things like async action creators. To test async action creators,
    you’ll use the mock store you installed at the beginning of the chapter (`redux-mock-store`—see
    more at [https://github.com/arnaudbenard/redux-mock-store](https://github.com/arnaudbenard/redux-mock-store))
    and configure it with `redux-thunk`. That way, you can assert that an async action
    creator dispatches certain actions and verify that it’s working as expected. The
    next listing shows how you can go about testing actions in Redux.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数动作创建者都可以轻松测试，因为它们通常返回一个包含类型和有效载荷信息的对象。有时，尽管如此，你需要进行一些额外的设置来适应像异步动作创建者这样的东西。为了测试异步动作创建者，你将使用你在本章开头安装的模拟存储（`redux-mock-store`——更多信息请参阅[https://github.com/arnaudbenard/redux-mock-store](https://github.com/arnaudbenard/redux-mock-store)）并使用
    `redux-thunk` 进行配置。这样，你可以断言异步动作创建者分发某些动作，并验证它是否按预期工作。下面的列表显示了如何在 Redux 中测试动作。
- en: Listing 10.14\. Testing actions in Redux (src/actions/comments.test.js)
  id: totrans-210
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.14\. 测试 Redux 中的动作（src/actions/comments.test.js）
- en: '[PRE16]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '***1* Use Jest to mock HTTP file so you don’t make network requests**'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 使用 Jest 模拟 HTTP 文件以避免进行网络请求**'
- en: '***2* Import mock store and redux middleware so you can create mock store to
    mirror yours**'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 导入模拟存储和 Redux 中间件，以便创建模拟存储以反映你的存储**'
- en: '***3* Import actions you’ll need to test**'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 导入你需要测试的动作**'
- en: '***4* import API so you can mock out specific functions on it**'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 导入 API 以模拟其上的特定函数**'
- en: '***5* Create mock store and reinitialize it before each test**'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 创建模拟存储并在每次测试之前重新初始化它**'
- en: '***6* Assert that an action creator will output an action with the right type
    and data**'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 断言动作创建者将输出具有正确类型和数据的动作**'
- en: '***7* Create mock comment to pass to action creator**'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 创建模拟评论以传递给动作创建者**'
- en: '***8* Mock out createComment method from API module using Jest**'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8* 使用 Jest 模拟 API 模块中的 createComment 方法**'
- en: '***9* Dispatch action and use await to wait for promise to resolve**'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***9* 分发动作并使用 await 等待承诺解决**'
- en: '***10* Assert that actions were created as expected**'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***10* 断言动作被创建为预期的那样**'
- en: 10.2.7\. Creating custom Redux middleware for crash reporting
  id: totrans-222
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.2.7\. 创建用于崩溃报告的自定义 Redux 中间件
- en: You have some actions created, but before you move on to reducers you can add
    some of your own middleware. *Middleware* is Redux’s way of letting you hook into
    the data flow process (actions dispatched to store, handled by reducer, state
    updated, listeners notified). Redux’s approach to middleware is similar to other
    tools like Express or Koa (web server frameworks for Node.js), although it solves
    a different problem. [Figure 10.7](kindle_split_022_split_002.xhtml#ch10fig07)
    shows an example of a middleware-focused flow as it might appear in something
    like Express or Koa.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经创建了一些动作，但在你转向 reducer 之前，你可以添加一些自己的中间件。*中间件* 是 Redux 允许你钩入数据流过程（动作分发到存储，由
    reducer 处理，状态更新，监听器通知）的方式。Redux 对中间件的方法类似于 Express 或 Koa 等其他工具（Node.js 的网络服务器框架），尽管它解决的是不同的问题。[图
    10.7](kindle_split_022_split_002.xhtml#ch10fig07) 展示了在类似 Express 或 Koa 的东西中可能出现的以中间件为重点的流程示例。
- en: Figure 10.7\. Middleware sits between a process’s start and end points and lets
    you do various things in between.
  id: totrans-224
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 10.7\. 中间件位于进程的开始和结束点之间，允许你在其中进行各种操作。
- en: '![](Images/10fig07_alt.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/10fig07_alt.jpg)'
- en: 'Sometimes you may want to interrupt the flow, send data off to another API,
    or solve any other application-wide problems. [Figure 10.7](kindle_split_022_split_002.xhtml#ch10fig07)
    shows a few different use cases for middleware: data modification, flow interruption,
    and performing side effects. One key point here is that the middleware should
    be composable—you should be able to reorder any of these and not worry about them
    affecting each other.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你可能想要中断流程，将数据发送到另一个 API，或解决任何其他应用程序范围的问题。[图 10.7](kindle_split_022_split_002.xhtml#ch10fig07)
    展示了中间件的几个不同用例：数据修改、流程中断和执行副作用。这里的一个关键点是中间件应该是可组合的——你应该能够重新排列这些中的任何一个，而不用担心它们会相互影响。
- en: Redux middleware lets you act between the point that an action is dispatched
    and when it reaches a reducer (see the “Middleware” section of [figure 10.7](kindle_split_022_split_002.xhtml#ch10fig07)).
    It’s a great place to focus on issues that are common to all parts of your Redux
    app and would otherwise require duplicate code in many places.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: Redux 中间件允许你在动作被分发和到达 reducer 之间进行操作（参见 [图 10.7](kindle_split_022_split_002.xhtml#ch10fig07)
    中的“中间件”部分）。这是一个关注 Redux 应用程序所有部分共同问题并避免在许多地方重复代码的绝佳地方。
- en: '|  |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Definitions**'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '**定义**'
- en: 'Match the term to its definition:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 将术语与其定义匹配：
- en: Store
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 存储
- en: Reducer
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Reducer
- en: Action
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 动作
- en: Action creator
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 动作创建者
- en: ___ The central state object in Redux; source of truth.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: ___ Redux 中的中心状态对象；真相的来源。
- en: ___ Objects that contain change-related information. They must have a type and
    can contain any additional information needed to communicate that something happened.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: ___ 包含变更相关信息的对象。它们必须有一个类型，并且可以包含任何其他必要的信息来传达发生了什么。
- en: ___ Functions used by Redux to compute changes to state based on something happening.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: ___ Redux 用于根据某些事件计算状态变化的函数。
- en: ___ Functions that are used to create type and payload information about something
    that happened in the application.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: ___ 用于创建有关应用程序中发生的事件的类型和有效负载信息的函数。
- en: '|  |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: For example, using middleware can be a great way to centralize error handling,
    send analytics data off to a third-party API, do logging, and more. You’ll implement
    a simple crash-reporting middleware that will make sure that any unhandled exceptions
    get reported to your error-tracking and management system. I’m using Sentry ([https://sentry.io](https://sentry.io)),
    an app that tracks and records exceptions for later analysis, but you could use
    whatever option is best for you or your team (Bugsnag is another great option—check
    it out at [https://bugsnag.com](https://bugsnag.com)). [Listing 10.15](kindle_split_022_split_002.xhtml#ch10ex15)
    shows how to create some basic error-reporting middleware that will log out errors
    and send them to Sentry when they’re encountered by Redux. Usually, engineers
    will get notifications of some kind (immediately or in a dashboard) when exceptions
    occur in an app; Sentry records those errors and lets you know when they happened.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，使用中间件可以是一个集中处理错误、将分析数据发送到第三方 API、进行日志记录等的好方法。你将实现一个简单的崩溃报告中间件，确保任何未处理的异常都会报告给你的错误跟踪和管理系统。我正在使用
    Sentry ([https://sentry.io](https://sentry.io))，一个跟踪和记录异常以供后续分析的应用程序，但你也可以使用对你或你的团队最佳的选择（Bugsnag
    是另一个不错的选择——请访问 [https://bugsnag.com](https://bugsnag.com)）。[列表 10.15](kindle_split_022_split_002.xhtml#ch10ex15)
    展示了如何创建一些基本的错误报告中间件，当 Redux 遇到错误时会记录并发送到 Sentry。通常，当应用程序中出现异常时，工程师会收到某种类型的通知（立即或在仪表板上）；Sentry
    记录这些错误并通知你它们发生的时间。
- en: Listing 10.15\. Creating simple crash-reporting Redux middleware
  id: totrans-241
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.15\. 创建简单的崩溃报告 Redux 中间件
- en: '[PRE17]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '***1* Redux middleware is comprised of composed functions that Redux will inject
    into.**'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* Redux 中间件由 Redux 将其注入的组成函数组成。**'
- en: '***2* If no errors, move to the next action**'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 如果没有错误，则移动到下一个动作**'
- en: '***3* Report error, if any**'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 报告错误，如果有**'
- en: '***4* Get user and send along with error; dispatch error to store**'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 获取用户并发送错误；将错误派发到 store**'
- en: '***5* Pull in middleware to be used in production.**'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 拉入用于生产的中间件。**'
- en: '***6* Add middleware for production environment**'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 为生产环境添加中间件**'
- en: This is only a taste of what you can do with Redux middleware. The extensive
    documentation contains a wealth of Redux information and insight into design and
    API usage as well as offering excellent examples. See [http://redux.js.org/docs/advanced/Middleware.html#seven-examples](http://redux.js.org/docs/advanced/Middleware.html#seven-examples)
    for more great examples of Redux middleware.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是 Redux 中间件可以做到的一小部分。丰富的文档包含了大量的 Redux 信息，以及对设计和 API 使用的见解，同时还提供了优秀的示例。有关
    Redux 中间件的更多优秀示例，请参阅 [http://redux.js.org/docs/advanced/Middleware.html#seven-examples](http://redux.js.org/docs/advanced/Middleware.html#seven-examples)。
- en: 10.3\. Summary
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3\. 摘要
- en: 'Here are the main points covered in this chapter:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主要要点：
- en: Redux is a library and application architecture that doesn’t have to be used
    with any particular library or framework. It works especially well with React
    and enjoys immense popularity as the tool of choice for state management and application
    architecture in many React apps.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Redux 是一个库和应用程序架构，不需要与任何特定的库或框架一起使用。它与 React 工作得特别出色，在许多 React 应用程序中作为状态管理和应用程序架构的首选工具而广受欢迎。
- en: Redux focuses on predictability and enforces strict ways of working with data.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Redux 专注于可预测性并强制执行严格的数据处理方式。
- en: A *store* is an object that serves as the source of truth for an application;
    it is the global state of the app.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*store* 是一个对象，作为应用程序的真相来源；它是应用程序的全局状态。'
- en: Flux allows you to have multiple stores, but Redux only allows one.
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Flux 允许你拥有多个 store，但 Redux 只允许一个。
- en: Reducers are functions used by Redux to compute changes to state based on a
    given action.
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Reducers 是 Redux 用于根据给定操作计算状态变化的函数。
- en: Redux is similar to Flux in many ways, but introduces the idea of reducers,
    has a single store, and its action creators don’t directly dispatch actions.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Redux 在许多方面与 Flux 相似，但引入了 reducers 的概念，拥有单个 store，并且其动作创建者不会直接派发动作。
- en: Actions contain information about something that happened. They must have a
    type but can contain any other information that your store and reducers will need
    to determine how state should be updated. In Redux, there’s a single state tree
    for the entire application; state all lives in one area and can only be updated
    through specific APIs.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动作包含有关发生的事情的信息。它们必须有一个类型，但可以包含您的 store 和 reducers 需要的任何其他信息，以确定如何更新状态。在 Redux
    中，整个应用程序有一个单一的状态树；所有状态都生活在同一个区域，并且只能通过特定的 API 进行更新。
- en: Action creators are functions that return actions that can be dispatched by
    the store. With certain middleware (see next item) in place, you can create asynchronous
    action creators that are useful for doing things like calling remote APIs.
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Action creators 是返回可以由存储分发的动作的函数。在有某些中间件（见下一条）的情况下，你可以创建异步动作创建器，这对于调用远程 API
    等操作非常有用。
- en: Redux allows you to write middleware, a place for injecting custom behavior
    into the Redux state management process. Middleware is executed before reducers
    are fired off and allow you to perform side effects or implement global solutions
    for your app.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Redux 允许你编写中间件，这是一个将自定义行为注入 Redux 状态管理过程的地方。中间件在触发 reducer 之前执行，并允许你执行副作用或为你的应用实现全局解决方案。
- en: In the next chapter, you’ll continue to work with Redux as you learn about reducers
    and integrate them into your React app.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将在学习 reducer 并将其集成到你的 React 应用中时继续使用 Redux。
- en: Chapter 11\. More Redux and integrating Redux with React
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 11 章\. 更多 Redux 和将 Redux 与 React 集成
- en: '*This chapter covers*'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Reducers, Redux’s way of determining how state should change
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Reducer，Redux 确定状态如何变化的方式
- en: Using Redux with React
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Redux 与 React
- en: Converting Letters Social to use the Redux application architecture
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 Letters Social 转换为使用 Redux 应用架构
- en: Adding like and comment functionality to your app
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为你的应用添加点赞和评论功能
- en: In this chapter, you’ll continue the work you did in the last chapter to build
    out the basic elements of your Redux architecture. You’ll work to integrate React
    with your Redux actions and store, and explore how reducers work. Redux is a variant
    of the Flux pattern that was designed with React in mind, and it works well with
    React’s unidirectional data flow and APIs. Although it’s not the universal choice,
    many large React applications will consider Redux as one of the top choices when
    implementing a state management solution. You’ll follow suit and do so for Letters
    Social.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将继续上一章的工作，构建你的 Redux 架构的基本元素。你将努力将 React 与你的 Redux 动作和存储进行集成，并探索 reducer
    的工作原理。Redux 是一个针对 React 设计的 Flux 模式的变体，它与 React 的单向数据流和 API 一起工作得很好。尽管它不是通用的选择，但许多大型
    React 应用在实现状态管理解决方案时，会将 Redux 作为首选方案之一。你将效仿此做法，并在 Letters Social 中这样做。
- en: '|  |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**How do I get the code for this chapter?**'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '**我如何获取本章的代码？**'
- en: As with every chapter, you can check out the source code for this chapter by
    going to the GitHub repository at [https://github.com/react-in-action/letters-social](https://github.com/react-in-action/letters-social).
    If you want to start this chapter with a clean slate and follow along, you can
    use your existing code from [chapters 7](kindle_split_018_split_000.xhtml#ch07)
    and [8](kindle_split_019_split_000.xhtml#ch08) (if you followed along and built
    out the examples yourself) or check out the chapter-specific branch (chapter-10-11).
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 与每一章一样，你可以通过访问 GitHub 仓库 [https://github.com/react-in-action/letters-social](https://github.com/react-in-action/letters-social)
    来查看本章的源代码。如果你想从一张白纸开始，并跟随学习，你可以使用你现有的 [第 7 章](kindle_split_018_split_000.xhtml#ch07)
    和 [第 8 章](kindle_split_019_split_000.xhtml#ch08) 的代码（如果你跟随并自己构建了示例）或检出特定章节的分支（chapter-10-11）。
- en: Remember, each branch corresponds to the code at the *end* of the chapter (for
    example, the branch chapter-10-11 corresponds to the code as it will be at the
    end of this chapter). You can execute one of the following terminal commands in
    the directory of your choice to get the code for the current chapter.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，每个分支都对应着章节末尾的代码（例如，分支 chapter-10-11 对应着本章末尾的代码）。你可以在你选择的目录中执行以下终端命令之一，以获取当前章节的代码。
- en: 'If you don’t have the repository at all, type the following:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你根本就没有仓库，请输入以下内容：
- en: '[PRE18]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If you already have the repository cloned:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经克隆了仓库：
- en: '[PRE19]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You may have come here from another chapter, so it’s always a good idea to
    ensure you have all the right dependencies installed:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能从另一章来到这里，所以始终确保你已经安装了所有正确的依赖项：
- en: '[PRE20]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '|  |'
  id: totrans-279
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 11.1\. Reducers determine how state should change
  id: totrans-280
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.1\. Reducer 确定状态如何变化
- en: You can create and dispatch actions and handle errors, but these don’t do anything
    to change your state yet. To handle the incoming actions, you need to set up reducers.
    Remember, actions are just ways to describe that something happened and specify
    some info about what happened, but nothing more. The job of reducers is to specify
    how the store state should change in response to these actions. [Figure 11.1](kindle_split_023_split_001.xhtml#ch11fig01)
    shows how reducers fit into the broader picture of Redux we’ve been looking at.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以创建和分发动作并处理错误，但这些动作还没有做任何事情来改变你的状态。要处理传入的动作，你需要设置reducer。记住，动作只是描述发生了什么以及发生了什么的一些信息的方式，但仅此而已。reducer的职责是指定状态应该如何响应这些动作。![图11.1](Images/11fig01_alt.jpg)展示了reducer如何融入我们一直在研究的Redux更广泛的画面中。
- en: Figure 11.1\. Reducers are just functions that help determine what changes should
    be made to the state. You can think of them as sort of a gateway to your app state
    that tightly controls incoming changes.
  id: totrans-282
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图11.1。Reducer只是帮助确定应该对状态进行哪些更改的函数。你可以把它们看作是进入应用程序状态的某种类型的网关，它紧密控制着传入的更改。
- en: '![](Images/11fig01_alt.jpg)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![图11.1](Images/11fig01_alt.jpg)'
- en: 'But what are reducers? If you’ve enjoyed the straightforward simplicity of
    Redux so far, you won’t be disappointed by reducers: they’re just more simple
    functions that have a single purpose. *Reducers* are pure functions that receive
    the previous state and an action as arguments and return the next state. According
    to the Redux documentation, they’re called reducers because their method signature
    looks like what you would pass to `Array.prototype.reduce` (for example, `[1,2,3].reduce((a,
    b) => a + b, 0`).'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 但什么是reducer呢？如果你到目前为止一直喜欢Redux的简单直接，那么你不会对reducer感到失望：它们只是具有单一目的的更简单的函数。*Reducer*
    是纯函数，它们接收先前的状态和一个动作作为参数，并返回下一个状态。根据Redux文档，它们被称为reducer，因为它们的函数签名看起来就像你会传递给 `Array.prototype.reduce`
    的内容（例如，`[1,2,3].reduce((a, b) => a + b, 0)`）。
- en: 'Reducers must be *pure* functions, meaning that given an input they will produce
    the same associated output every time. This contrasts with actions or middleware,
    where side effects are produced and API calls are often made. Doing anything asynchronous
    or impure (like calling `Date.now` or `Math.random()`) in reducers is an anti-pattern
    and could degrade performance or reliability in your app. The Redux docs drive
    this point home: “Given the same arguments, it should calculate the next state
    and return it. No surprises. No side effects. No API calls. No mutations. Just
    a calculation.” For more on this, see [https://redux.js.org/basics/reducers](https://redux.js.org/basics/reducers).'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: Reducers必须是*纯*函数，这意味着给定一个输入，它们将每次都产生相同的关联输出。这与产生副作用或进行API调用的动作或中间件形成对比。在reducer中进行任何异步或不纯的操作（如调用`Date.now`或`Math.random()`）是一种反模式，可能会降低应用程序的性能或可靠性。Redux文档强调了这一点：“给定相同的参数，它应该计算下一个状态并返回它。没有惊喜。没有副作用。没有API调用。没有突变。只是一个计算。”关于这一点，请参阅[https://redux.js.org/basics/reducers](https://redux.js.org/basics/reducers)。
- en: 11.1.1\. State shape and initial state
  id: totrans-286
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.1.1。状态形状和初始状态
- en: Reducers will start to work on modifying the single Redux store, so it’s a good
    time to talk about what shape that store will take. Designing the state shape
    of any app will both affect and be affected by how the UI of your app works, but
    it’s generally a good idea to keep the “raw” data separated from the UI data as
    much as possible. One way to do this is to store things like IDs separate from
    their counterparts and use the IDs to look up data.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: Reducers将开始修改单个Redux存储，因此这是一个讨论该存储将采取什么形状的好时机。设计任何应用程序的状态形状将既会影响又会受到应用程序UI工作方式的影响，但通常一个好的做法是尽可能地将“原始”数据与UI数据分开。做到这一点的一种方法是将像ID这样的东西与其对应物分开存储，并使用ID来查找数据。
- en: You’ll create an initial state file that will help you determine your state
    shape and structure. In the constants folder, create a file named initialState.js.
    This will be the state of your Redux app before any actions have been dispatched
    or any changes have been made. You’ll include information for error and loading
    states, as well as some information about posts, comments, and the user. You’ll
    store the IDs for comments and posts in arrays and the main information for these
    in objects that you can easily reference. The following listing shows an example
    of setting up the initial state.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 你将创建一个初始状态文件，这将帮助你确定状态形状和结构。在constants文件夹中，创建一个名为initialState.js的文件。这将是在任何动作被分发或任何更改之前你的Redux应用的状态。你将包括错误和加载状态的信息，以及有关帖子、评论和用户的一些信息。你将把评论和帖子的ID存储在数组中，并将这些对象的主要信息存储在可以轻松引用的对象中。以下列表显示了设置初始状态的示例。
- en: Listing 11.1\. Initial state and state shape (src/constants/initialState.js)
  id: totrans-289
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表11.1\. 初始状态和状态形状（src/constants/initialState.js）
- en: '[PRE21]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '***1* Object that Redux will use for its initial state**'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* Redux将用于其初始状态的对象**'
- en: '***2* Store comment and post IDs separate from the actual data.**'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将存储评论和帖子的ID与实际数据分开。**'
- en: '***3* Store pagination links (received via HTTP headers)—this is just one approach
    to pagination.**'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 存储分页链接（通过HTTP头接收）——这只是分页的一种方法。**'
- en: '***4* Store information about user’s authentication state**'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 存储有关用户认证状态的信息**'
- en: 11.1.2\. Setting up reducers to respond to incoming action
  id: totrans-295
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.1.2\. 设置reducer以响应传入的动作
- en: With your initial state set up, you should create some reducers to handle incoming
    actions so your store can be updated. Reducers usually use a `switch` statement
    to match incoming action types to make updates to state. They return a new copy
    of the state (not the same version with changes) that will then be used to update
    the store. Reducers also perform catch-all behavior to ensure that unknown actions
    just return the existing state. We’ve noted it before, but it’s important to say
    again that reducers are performing calculations and should return the same output
    every time based on a given input; no side effects or impure processes should
    be initiated.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置好初始状态后，你应该创建一些reducer来处理传入的动作，以便你的store能够更新。Reducer通常使用`switch`语句来匹配传入的动作类型，以便更新状态。它们返回状态的新副本（而不是带有更改的同一版本），然后将被用来更新store。Reducer还执行捕获所有行为的操作，以确保未知动作只返回现有状态。我们之前已经提到过，但重要的是再次强调，reducer正在执行计算，并且应该根据给定的输入每次都返回相同的输出；不应启动任何副作用或不纯过程。
- en: Reducers are responsible for calculating how the store should change. In most
    apps, you’ll have many reducers that will each be responsible for a slice of your
    store. This helps keep files uncluttered and focused. You’ll ultimately use the
    `combineReducers` method available from Redux to, well, combine your reducers
    into one. Most reducers use a `switch` statement with cases for different action
    types and a default catch-all at the bottom to ensure that unknown action types
    (probably created by accident, if anything) don’t have any unintentional effects
    on state.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: Reducer负责计算store应该如何变化。在大多数应用中，你将有许多reducer，每个reducer将负责store的一部分。这有助于保持文件整洁并保持专注。你最终将使用Redux提供的`combineReducers`方法，将你的reducer合并为一个。大多数reducer使用`switch`语句，其中包含不同动作类型的案例，并在底部有一个默认的捕获所有行为的案例，以确保未知动作类型（可能是意外创建的）不会对状态产生任何意外的效果。
- en: Reducers also make copies of state and don’t directly mutate the existing store
    state. If you look back at [figure 11.1](kindle_split_023_split_001.xhtml#ch11fig01),
    you’ll see that the reducers use state as they perform their jobs. This approach
    is similar to the way that immutable data structures generally work; modified
    copies are made instead of direct mutations. [Listing 11.2](kindle_split_023_split_001.xhtml#ch11ex02)
    shows how to set up the loading reducer. Note that in this case you’re only dealing
    with a “flat” slice of state—the Boolean `loading` property—so you just return
    either `true` or `false` for the new state. You’ll frequently be working with
    a state object that has many keys or nested properties, and your reducer will
    need to do more than just return `true` or `false`.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: Reducer 还会复制状态，并且不会直接修改现有的存储状态。如果你回顾一下 [图 11.1](kindle_split_023_split_001.xhtml#ch11fig01)，你会看到
    reducer 在执行其任务时使用状态。这种方法类似于不可变数据结构通常工作的方式；修改的是副本而不是直接修改。[列表 11.2](kindle_split_023_split_001.xhtml#ch11ex02)
    展示了如何设置加载 reducer。注意，在这种情况下，你只处理一个“扁平”的状态切片——布尔 `loading` 属性——所以你只需为新的状态返回 `true`
    或 `false`。你将经常处理具有许多键或嵌套属性的 state 对象，并且你的 reducer 需要做的不仅仅是返回 `true` 或 `false`。
- en: Listing 11.2\. Setting up the loading reducer (src/reducers/loading.js)
  id: totrans-299
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 11.2\. 设置加载 reducer（src/reducers/loading.js）
- en: '[PRE22]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '***1* Function that takes two parameters, state and an action**'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 函数接受两个参数，状态和动作**'
- en: '***2* Usually, you’ll use a switch statement to explicitly handle each type
    of action and return state by default.**'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 通常，你会使用 switch 语句显式处理每种类型的动作并返回状态。**'
- en: '***3* If action has loading type, return true for new state value**'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 如果动作具有加载类型，则返回新状态值为 true**'
- en: '***4* Handle loaded case and return appropriate false case**'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 处理已加载情况并返回适当的 false 情况**'
- en: '***5* Return existing state by default**'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 默认返回现有状态**'
- en: Now when a loading-related action gets dispatched, the Redux store will be able
    to do something about it. When an action comes in and has made it through any
    existing middleware, Redux will invoke reducers to determine what new state should
    be created based on the action. There wasn’t a way for your store to know about
    change information contained in an action before you had set up any reducers.
    To visualize this, [figure 11.2](kindle_split_023_split_001.xhtml#ch11fig02) cuts
    out the reducers from the flow; see how there’s no way for actions to reach the
    store?
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当加载相关动作被分发时，Redux 存储将能够对此做出响应。当一个动作到来并且通过了任何现有的中间件，Redux 将调用 reducer 来确定应该基于该动作创建什么新状态。在你设置任何
    reducer 之前，你的存储无法知道动作中包含的更改信息。为了可视化这一点，[图 11.2](kindle_split_023_split_001.xhtml#ch11fig02)
    切除了 reducer 从流程中；看看是否有办法让动作达到存储？
- en: Figure 11.2\. With reducers in place, Redux will know how to make changes to
    the store when actions are dispatched. In a moderately complex app, you’ll usually
    have many different reducers that are each responsible for their own “slice” of
    the store state.
  id: totrans-307
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 11.2\. 当 reducer 设置到位后，Redux 将知道在动作分发时如何更改存储。在一个中等复杂的应用中，你通常会有许多不同的 reducer，每个
    reducer 负责存储状态的“切片”。
- en: '![](Images/11fig02_alt.jpg)'
  id: totrans-308
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/11fig02_alt.jpg)'
- en: Next, you’ll create another reducer to put your Redux skills to work. After
    all, many reducers won’t be just returning a `true` or `false` value, or at the
    very least if they do, there will probably be more that goes into calculating
    that `true` or `false` value. Another key part of the Letters Social app is showing
    and creating posts, and you need to migrate it to Redux. Like you might if you
    were migrating a real-life React app to use Redux, you should be able to preserve
    much of the existing logic that your app uses and translate it into a Redux-friendly
    form. You’ll create two reducers to handle the posts themselves and one for keeping
    track of the post IDs. In a larger app, you might combine these together under
    another key, but keeping them separate is fine for now. This also serves as an
    example of how multiple reducers can be set up to handle a single action. [Listing
    11.3](kindle_split_023_split_001.xhtml#ch11ex03) shows how to create the reducer
    for comments. You’ll be creating quite a few reducers here, but once that’s done,
    your app will not only have a comprehensive description of actions that can occur
    but also of ways that the state can change.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将创建另一个reducer来运用你的Redux技能。毕竟，许多reducer不会只是返回一个`true`或`false`值，或者至少如果它们这样做，计算那个`true`或`false`值的过程中可能还有更多。Letters
    Social应用的关键部分之一是显示和创建帖子，你需要将其迁移到Redux。就像你可能将一个真实的React应用迁移到使用Redux一样，你应该能够保留应用使用的现有逻辑的大部分，并将其转换为Redux友好的形式。你将创建两个reducer来处理帖子本身，以及一个用于跟踪帖子ID的reducer。在一个更大的应用中，你可能会将这些组合在另一个键下，但保持它们分开现在是可以的。这也作为了如何设置多个reducer来处理单个操作的示例。[列表11.3](kindle_split_023_split_001.xhtml#ch11ex03)显示了如何创建注释的reducer。你将在这里创建相当多的reducer，但一旦完成，你的应用不仅将有一个关于可能发生的操作的全面描述，还将有关于状态如何改变的方法。
- en: Listing 11.3\. Creating the comments reducer (src/reducers/comments)
  id: totrans-310
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表11.3\. 创建注释reducer（src/reducers/comments）
- en: '[PRE23]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '***1* Pull in initial state**'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 拉取初始状态**'
- en: '***2* Reducers are functions that take a state object and an action.**'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* Reducer是接受状态对象和操作的函数。**'
- en: '***3* Use a switch statement to determine how to respond to incoming action**'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 使用switch语句确定如何响应传入的操作**'
- en: '***4* For GET, make copy of state and add comments you don’t already have**'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 对于GET，复制状态并添加你尚未拥有的注释**'
- en: '***5* Return new state**'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 返回新状态**'
- en: '***6* Add new comment to state**'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 向状态添加新注释**'
- en: '***7* By default return same state**'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 默认返回相同状态**'
- en: '***8* You only want IDs here because you’ll store them separately from main
    objects.**'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8* 你只在这里想要ID，因为你会将它们与主要对象分开存储。**'
- en: '***9* Create copy of previous state**'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***9* 创建前一个状态副本**'
- en: '***10* Push new ID in**'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***10* 推入新ID**'
- en: Now when you dispatch actions related to comments, your store state will update
    appropriately. Did you notice how you were able to respond to actions that weren’t
    strictly of the same type? Reducers can respond to actions that are within their
    purview, even if they aren’t of an identical type. This has to be possible because
    even though the “posts” slice of state manages posts, there are other actions
    in the realm of the act that might affect it. The takeaway here is that a reducer
    is responsible for deciding how a particular aspect of state should change, regardless
    of which action or which type of action is coming through. Some reducers might
    need to know about many different types of actions that aren’t specifically related
    to the resource (posts) they’re modeling.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你分发与注释相关的操作时，你的存储状态将相应更新。你注意到你能够响应那些并非严格相同类型的操作吗？即使它们不是同一类型的，reducer也可以响应其范围内的操作。这是因为尽管“帖子”状态片段管理帖子，但还有其他可能影响它的操作。这里的要点是，reducer负责决定状态的一个特定方面应该如何改变，无论哪个操作或哪种类型的操作正在通过。一些reducer可能需要了解许多不同类型的操作，而这些操作并非特别与它们所模拟的资源（帖子）相关。
- en: Now that you’ve created the comments reducer, you can create the one that will
    handle posts. It will be very similar to the comments one because you’re employing
    the same strategy for storing them as IDs and objects separately. It will also
    need to know how to handle liking and unliking posts (you created the actions
    for this functionality in [chapter 10](kindle_split_022_split_000.xhtml#ch10)).
    The following listing shows how to create these reducers.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经创建了注释reducer，你可以创建处理帖子的reducer。因为它将使用相同的策略来存储它们，即分别存储ID和对象，所以它将与注释reducer非常相似。它还需要知道如何处理点赞和取消点赞帖子（你已经在第10章中创建了这些功能的操作）。下面的列表显示了如何创建这些reducer。
- en: Listing 11.4\. Creating the posts reducers (src/reducers/posts.js)
  id: totrans-324
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表11.4\. 创建帖子reducers（src/reducers/posts.js）
- en: '[PRE24]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '***1* Handle getting new posts**'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 处理获取新帖子**'
- en: '***2* Show or toggle comments for a post**'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 显示或切换帖子的评论**'
- en: '***3* Liking/unliking a post involves updating specific post in state with
    new data from API**'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 点赞/取消点赞帖子涉及使用API的新数据更新状态中的特定帖子**'
- en: '***4* Handle new IDs same way you did for comments**'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 以处理评论相同的方式处理新ID**'
- en: I included two reducers in these files because they were so closely related
    and both act on the same fundamental data (posts and comments), but you’ll probably
    find that most of the time you want to have one reducer per file to keep things
    simple. Most of the time your reducer setup will mirror or at least follow the
    structure of your store. You may have noticed the subtlety that how you design
    your store state shape (see the initial state you set up earlier in the chapter)
    will greatly influence how your reducers and, to a lesser degree, your actions
    are defined. One takeaway from this is that it’s generally better to spend too
    much time on designing state shape than to gloss over it. Too little time spent
    on design will probably result in lots of rework to improve the state shape, whereas
    solid design plus the patterns Redux gives you can make adding new functionality
    easier than not adding it.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这几个文件中包含了两个reducer，因为它们非常相关，并且都作用于相同的基本数据（帖子与评论），但你可能会发现，大多数情况下你希望每个文件有一个reducer以保持事情简单。大多数情况下，你的reducer设置将与你的store结构相似或至少遵循其结构。你可能已经注意到一个细微之处，即你如何设计你的store状态形状（参见本章前面设置的初始状态）将极大地影响你的reducers以及，在一定程度上，你的actions的定义。从这个角度来看，通常花更多的时间来设计状态形状比草率地处理它要好。设计时间过少可能会导致大量返工以改进状态形状，而稳健的设计加上Redux提供的模式可以使添加新功能比不添加它更容易。
- en: '|  |'
  id: totrans-331
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Migrating to Redux: worth it?**'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '**迁移到Redux：值得吗？**'
- en: I’ve mentioned a few times in this chapter that Redux can be a lot of work to
    initially set up (perhaps you’re feeling that right now!) but in the end it’s
    often worthwhile. Obviously, that can’t be true in every possible case, but I’ve
    found it to be true in the projects I’ve worked on and for other engineers I know
    who’ve done the same. One project I worked on involved a complete migration of
    the app from a Flux to Redux architecture. It took the entire team working for
    maybe a month or so, but we were able to launch the rewrite of the app with minimal
    instability and bug creation.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我提到过几次Redux的初始设置可能是一项大量工作（也许你现在就有这种感觉！）但最终通常是有价值的。显然，这并不适用于所有可能的情况，但我发现我在工作的项目中以及我所知道的那些做过同样事情的工程师那里都是这样。我参与的一个项目涉及将应用从Flux迁移到Redux架构的完整迁移。整个团队可能花了大约一个月的时间，但我们能够以最小的不稳定性和错误创建来发布应用的重新编写版本。
- en: The greater overall outcome, however, was the ability to more rapidly iterate
    on the product due to the patterns that Redux helped us put in place. Months after
    the Redux migration, we ended up doing a series of complete redesigns of the application.
    Even though we ended up rebuilding large portions of the React portion of the
    application, the Redux architecture meant that we had to make relatively few changes
    to any of the state management and business-logic portions of the application.
    What’s more, the patterns Redux provided for us made it trivial to add to the
    state of the application where necessary. Integrating Redux was worth the initial
    work to set it up and transition the app over to it and it continues to pay dividends
    long after.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，更大的整体成果是，由于Redux帮助我们建立的模式，我们可以更快地对产品进行迭代。在Redux迁移几个月后，我们最终进行了一系列应用的重设计。尽管我们最终重建了应用React部分的很大一部分，但Redux架构意味着我们只需要对应用的状态管理和业务逻辑部分进行相对较少的更改。更重要的是，Redux为我们提供的模式使得在必要时向应用状态中添加内容变得非常简单。集成Redux值得最初的工作来设置它并将应用迁移到它，而且它继续在长期内带来回报。
- en: '|  |'
  id: totrans-335
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: With some of the more complicated reducers taken care of, you can finish the
    reducers portion of our Redux work by creating reducers for errors, pagination,
    and the user. Start with the error reducer in the following listing.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理了一些更复杂的reducers之后，你可以通过创建错误、分页和用户的reducers来完成我们的Redux工作。以下列表以错误reducer开始。
- en: Listing 11.5\. Creating the error reducer (src/reducers/error.js)
  id: totrans-337
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表11.5\. 创建错误reducer（src/reducers/error.js）
- en: '[PRE25]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '***1* This slice of state isn’t complicated; sends through error on action**'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 这个状态片段并不复杂；在动作中传递错误**'
- en: Next, you need to ensure that your pagination state can get updated. Right now,
    the pagination is only related to posts, but in a larger application you might
    have to set up pagination for many different parts of your application (for example,
    when you have a post with too many comments to sensibly show at once). You only
    need to handle simple pagination for your sample application, so create the pagination
    reducer in the following listing.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要确保你的分页状态可以更新。目前，分页仅与帖子相关，但在更大的应用程序中，你可能需要为应用程序的许多不同部分设置分页（例如，当你有一个包含太多评论而无法一次性合理显示的帖子时）。对于你的示例应用程序，你只需要处理简单的分页，因此请创建以下列表中的分页reducer。
- en: Listing 11.6\. Creating the pagination reducer (src/reducers/pagination.js)
  id: totrans-341
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表11.6\. 创建分页reducer（src/reducers/pagination.js）
- en: '[PRE26]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '***1* Update those link URLs with new pagination info**'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 使用新的分页信息更新那些链接URL**'
- en: '***2* Create new copy of previous state and merge in URLs from action’s payload**'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 创建前一个状态的新副本，并将动作的有效负载中的URL合并进去**'
- en: '***3* Quirk due to how Letters Social terminates SSL when deployed to Zeit
    ([https://zeit.co/now](https://zeit.co/now))—ignore if you don’t deploy app yourself**'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 由于Letters Social在部署到Zeit ([https://zeit.co/now](https://zeit.co/now))时终止SSL的怪异行为——如果你没有自己部署应用程序，请忽略**'
- en: '***4* Update URL for each link type**'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 更新每种链接类型的URL**'
- en: Now you need to create a reducer that will let you respond to user-related events
    like logins and logouts. In this reducer you’ll also handle storing some cookies
    on the browser so you can use them later when you do server-side rendering in
    [chapter 12](kindle_split_024_split_000.xhtml#ch12). *Cookies* are small pieces
    of data that the server can send to a user’s web browser. You’re probably familiar
    with cookies from using computers every day (you get notified about them on some
    sites for legal reasons), but maybe you’ve never worked with them in a programmatic
    way before. That’s okay. You’ll use the `js-cookie` library to interact with cookies,
    and all you’ll do with them is set and unset one particular cookie when the user’s
    authentication state changes. The following listing shows creating the user reducer
    to do this.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你需要创建一个reducer，它将允许你响应用户相关的事件，如登录和登出。在这个reducer中，你还将处理在浏览器上存储一些cookie，以便你可以在第12章（[kindle_split_024_split_000.xhtml#ch12](https://kindle_split_024_split_000.xhtml#ch12)）中进行服务器端渲染时使用它们。*Cookies*
    是服务器可以发送到用户Web浏览器的小数据块。你可能因为每天使用计算机而熟悉cookie（由于法律原因，在某些网站上你会收到关于它们的通知），但也许你以前从未以编程方式处理过它们。没关系。你将使用`js-cookie`库与cookie交互，而你将做的所有事情就是在用户的身份验证状态改变时设置和取消设置一个特定的cookie。以下列表显示了创建用户reducer以执行此操作。
- en: Listing 11.7\. Creating the user reducer (src/reducers/user.js)
  id: totrans-348
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表11.7\. 创建用户reducer（src/reducers/user.js）
- en: '[PRE27]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '***1* Import js-cookie library for use**'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 导入js-cookie库以使用**'
- en: '***2* Pull user and token from action**'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 从动作中提取用户和令牌**'
- en: '***3* Store token as cookie on browser using js-cookie**'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 使用js-cookie在浏览器中存储令牌作为cookie**'
- en: '***4* Return copy of state with new user data, including token**'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 返回包含新用户数据和令牌的状态副本**'
- en: '***5* When logging out, set user back to initial state and wipe the cookie**'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 在登出时，将用户状态重置为初始状态并擦除cookie**'
- en: 11.1.3\. Combining reducers together in our store
  id: totrans-355
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.1.3\. 在我们的存储中组合reducers
- en: Lastly, you need to make sure that your reducers are integrated with your Redux
    store. Even though you’ve created them, they’re not connected in any way right
    now. Let’s revisit the root reducer you created in [chapter 10](kindle_split_022_split_000.xhtml#ch10)
    and see how to add new reducers to it. [Listing 11.8](kindle_split_023_split_001.xhtml#ch11ex08)
    shows how to add the reducers you created to the root reducer. It’s important
    to note here that the way that `combineReducers` will create keys on your store
    is based on the reducers you pass in. For the case in [listing 11.8](kindle_split_023_split_001.xhtml#ch11ex08),
    your store’s state will have `loading` and `posts` keys, each managed by their
    respective reducer. I’m using the ES2015 property shorthand here, but could have
    named the final keys differently if I wanted to. This is important to note so
    you don’t feel as though your function names must be directly tied to keys on
    your store.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你需要确保你的 reducer 已与你的 Redux 存储集成。尽管你已经创建了它们，但它们目前没有任何连接。让我们回顾一下你在[第 10 章](kindle_split_022_split_000.xhtml#ch10)中创建的根
    reducer，看看如何向其中添加新的 reducer。[列表 11.8](kindle_split_023_split_001.xhtml#ch11ex08)展示了如何将你创建的
    reducer 添加到根 reducer。这里需要注意的是，`combineReducers` 将根据你传入的 reducer 在你的存储中创建键的方式。对于[列表
    11.8](kindle_split_023_split_001.xhtml#ch11ex08)中的情况，你的存储状态将具有 `loading` 和 `posts`
    键，每个键分别由相应的 reducer 管理。我在这里使用的是 ES2015 属性简写，但如果我想的话，也可以将最终的键命名为不同的名称。这一点很重要，以免你觉得你的函数名必须直接与存储上的键相关联。
- en: Listing 11.8\. Adding new reducers to existing root reducer (src/reducers/root.js)
  id: totrans-357
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 11.8\. 向现有根 reducer 添加新 reducer（src/reducers/root.js）
- en: '[PRE28]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '***1* Import reducers so you can add them to root reducer**'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 导入 reducer 以将其添加到根 reducer**'
- en: '***2* combineReducers will mount each reducer at corresponding key, but you
    can change names if desired**'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* `combineReducers` 将在每个对应的键上挂载每个 reducer，但如果你希望的话，可以更改名称**'
- en: 11.1.4\. Testing reducers
  id: totrans-361
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.1.4\. 测试 reducer
- en: Testing Redux reducers is straightforward thanks to their pure, decoupled nature—they’re
    just functions, after all. To test your reducers, you’ll assert that given a certain
    input, they should produce a certain state. The next listing shows how to test
    the reducers you created for the posts and post ID slices of state. As with other
    parts of Redux, the fact that reducers are also functions makes them easy to isolate
    and test.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Redux reducer 的纯函数和松耦合特性，测试 Redux reducer 是直接的——毕竟，它们只是函数。为了测试你的 reducer，你需要断言给定一定的输入，它们应该产生一定的状态。下一个列表展示了如何测试你为状态切片的
    posts 和 post ID 创建的 reducer。与其他 Redux 部分一样，由于 reducer 也是函数，这使得它们易于隔离和测试。
- en: Listing 11.9\. Testing reducers (src/reducers/posts.test.js)
  id: totrans-363
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 11.9\. 测试 reducer（src/reducers/posts.test.js）
- en: '[PRE29]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '***1* Mock the js-cookie library**'
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 模拟 js-cookie 库**'
- en: '***2* Import reducer and types you’ll need for testing**'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 导入测试所需的 reducer 和类型**'
- en: '***3* Assert that initial state will be returned by default**'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 断言默认将返回初始状态**'
- en: '***4* Create mock user, token, and expected state to assert with**'
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 创建模拟用户、令牌和预期的状态以进行断言**'
- en: '***5* Given a login action, assert that state changed as expected**'
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 给定一个登录动作，断言状态按预期改变**'
- en: '***6* Assert that your cookies mock was called**'
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 断言你的 cookies 模拟被调用**'
- en: '***7* Perform similar assertion on LOGOUT_SUCCESS action**'
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 对 LOGOUT_SUCCESS 动作执行类似的断言**'
- en: 'With that, we’ve covered most of the basics of a Redux application: the store,
    reducers, actions, and middleware! The Redux ecosystem is robust, and there are
    many more areas you can explore yourself. We’ve omitted some parts of the API
    and/or Redux ecosystem like advanced middleware usage, selectors (optimized ways
    of interacting with store state), and more. We also specifically omitted extensively
    covering the store API (like, for example, working with `store.subscribe()` to
    interact with update events). That’s because the nuts and bolts of working with
    this part of Redux will be abstracted over with the `react-redux` library. (If
    you’re interested in going into more depth in these areas and learning more about
    Redux, see [https://redux.js.org](https://redux.js.org).) I’ve also put together
    a guide to the React ecosystem on my blog at [https://ifelse.io/react-ecosystem](https://ifelse.io/react-ecosystem)
    that covers Redux as well.'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些，我们已经涵盖了 Redux 应用程序的大部分基础知识：store、reducers、actions 和 middleware！Redux 生态系统强大，还有更多你可以自己探索的领域。我们省略了一些
    API 和/或 Redux 生态系统的一部分，比如高级 middleware 使用、selectors（与 store 状态交互的优化方式）等。我们还特别省略了广泛介绍
    store API（例如，使用 `store.subscribe()` 与更新事件交互）。这是因为与 Redux 这一部分工作的细节将通过 `react-redux`
    库进行抽象。如果你对这些领域有更深入的兴趣，并想了解更多关于 Redux 的信息，请参阅 [https://redux.js.org](https://redux.js.org)。我还在我的博客
    [https://ifelse.io/react-ecosystem](https://ifelse.io/react-ecosystem) 上整理了一份关于
    React 生态系统的指南，其中也包括了 Redux。
- en: '|  |'
  id: totrans-373
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**True or false**'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '**真或假**'
- en: 'Redux is a relatively small library for what it does, but it has a few “strong”
    opinions about how data flow works within the store, reducer, actions, and middleware.
    Take a second to check your understanding by evaluating the following statements:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: Redux 对于它所做的事情来说是一个相对较小的库，但它对 store、reducer、actions 和 middleware 中的数据流工作方式有一些“强烈”的观点。花点时间评估以下陈述，以检查你的理解：
- en: T | F Reducers should modify the existing state directly.
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: T | F Reducers 应该直接修改现有的状态。
- en: T | F Redux includes a way of doing asynchronous work (network requests, for
    example) by default.
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: T | F Redux 默认包含一种执行异步工作（例如网络请求）的方式。
- en: T | F It’s a good idea to include an initial state for every reducer by default.
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: T | F 默认为每个 reducer 包含一个初始状态是一个好主意。
- en: T | F Reducers can be combined, making it easier to separate out slices of state.
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: T | F Reducers 可以组合，这使得分离状态片段更容易。
- en: '|  |'
  id: totrans-380
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 11.2\. Bringing React and Redux together
  id: totrans-381
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2\. 将 React 和 Redux 结合起来
- en: You’ve made progress with Redux, but your React components don’t know anything
    about it at this point. You need to bring them together somehow. You can start
    to integrate your new architecture with React now that you’ve completed the Redux
    setup process by building out reducers, actions, and a store to use. You’ve probably
    noticed that you didn’t have to do much with React to get Redux up and running.
    That’s because Redux can be implemented without regard to a specific framework—or
    any framework at all. Granted, the way that Redux works fits particularly well
    with React applications, and this is at least in part why it has become one of
    the most popular choices for React application architecture. But remember even
    as you start to integrate React and Redux that you could integrate it with Angular,
    Vue, Preact, or Ember.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经在 Redux 上取得了进展，但你的 React 组件目前对此一无所知。你需要以某种方式将它们结合起来。现在你已经完成了 Redux 设置过程，通过构建出
    reducers、actions 和一个 store 来使用，你可以开始将你的新架构与 React 集成。你可能已经注意到，你不需要做太多 React 的工作就能让
    Redux 运行起来。这是因为 Redux 可以在不考虑特定框架——或者任何框架的情况下实现。当然，Redux 的工作方式与 React 应用程序特别契合，这也是它成为
    React 应用程序架构中最受欢迎的选择之一的原因。但请记住，即使你开始将 React 和 Redux 集成，你也可以将其与 Angular、Vue、Preact
    或 Ember 集成。
- en: 11.2.1\. Containers vs. presentational components
  id: totrans-383
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.2.1\. 容器组件与展示组件
- en: 'When integrating Redux into a React app, you’ll almost certainly be working
    with the `react-redux` library. This library serves as abstraction that covers
    the integration of the Redux store and actions into your React components. I’ll
    cover some of the ways you can use `react-redux`, including how to bring actions
    into your components, and discuss some new types of components: presentational
    and container components. You no longer need to distribute state among your many
    components because Redux is responsible for managing the application state via
    actions, reducers, and the store. Note again that there’s nothing inherently wrong
    with creating a React app that doesn’t use Redux; you still get all the other
    good things that come from using React. Redux’s predictability and added structure
    make designing and maintaining a large, complex React app easier, and that’s why
    many teams will choose to go with it over “vanilla” React.'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 当将Redux集成到React应用程序中时，你几乎肯定会使用`react-redux`库。这个库作为抽象层，涵盖了Redux存储和动作与React组件的集成。我将介绍一些你可以使用`react-redux`的方法，包括如何将动作引入你的组件，并讨论一些新的组件类型：表现性组件和容器组件。你不再需要在你的许多组件之间分配状态，因为Redux通过动作、reducer和存储负责管理应用程序状态。再次提醒，创建不使用Redux的React应用程序并没有什么固有的错误；你仍然会得到使用React带来的所有其他好处。Redux的可预测性和附加结构使得设计和维护大型、复杂的React应用程序更容易，这也是为什么许多团队会选择使用它而不是“纯”React。
- en: These two new categories of components (presentational and container) are really
    just two more-focused expressions of what your components are already doing. The
    difference between “any old” component and a presentation or container component
    is in what it does. Rather than allowing any component to handle styling, UI data,
    *and* application data, presentational components handle UI and UI-related data,
    and container components handle application data (à la Redux).
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种新的组件类别（表现性和容器）实际上只是对组件已经执行的功能的两种更专注的表达。普通组件与表现性或容器组件之间的区别在于它们的功能。而不是允许任何组件处理样式、UI数据和*以及*应用程序数据，表现性组件处理UI和UI相关数据，而容器组件处理应用程序数据（类似于Redux）。
- en: It’s important to understand the difference between containers and presentational
    components, but your application is still doing the same things it was doing with
    better separation of concerns. You haven’t introduced anything fundamentally new
    into the application with Redux; your React components will still receive props,
    maintain state, respond to events, and render with the same lifecycle as before.
    The key difference that `react-redux` provides is in integrating your store, reducers,
    and actions with your components. And the new divide between presentational and
    container components is just a pattern that can make your life easier.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 理解容器组件和表现性组件之间的区别很重要，但你的应用程序仍在做同样的事情，只是关注点分离得更好。你并没有在应用程序中引入任何根本性的新内容；你的React组件仍然会接收属性、维护状态、响应用件，并以与之前相同的生命周期渲染。`react-redux`提供的关键区别在于将你的存储、reducer和动作与组件集成。表现性组件和容器组件之间的新划分只是一个可以使你的生活更轻松的模式。
- en: Let’s look at these two general sorts of components used in a React app with
    a Redux architecture. As noted, presentational components are “UI-only” components.
    This means they should generally not have much to do with determining how application
    data is changed, updated, or emitted.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看在具有Redux架构的React应用程序中使用的这两种一般类型的组件。正如所提到的，表现性组件是“仅UI”组件。这意味着它们通常不会与确定应用程序数据如何更改、更新或发出的方式有很大关系。
- en: 'Here are some basics on presentational components:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些关于表现性组件的基本知识：
- en: They deal with how things look instead of how data flows or is determined.
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们处理的是事物的外观，而不是数据流或确定的方式。
- en: They only have their own state (they’re React classes with a backing instance)
    if necessary; most of the time they should be stateless, functional components
    that receive props from Redux via `react-redux` bindings.
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果有必要，它们只有自己的状态（它们是带有后端实例的React类）；大多数时候，它们应该是无状态的函数组件，通过`react-redux`绑定从Redux接收属性。
- en: 'When they *do* have their own state, it should be UI-related data, not application
    data. For example: an open/closed dropdown menu item and its state.'
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当它们*确实*有自己的状态时，它应该是UI相关数据，而不是应用程序数据。例如：一个打开/关闭的下拉菜单项及其状态。
- en: They don’t determine how data gets loaded or changed—that should happen primarily
    in containers.
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们不决定数据如何加载或更改——这应该在容器中主要发生。
- en: They’re usually created “by hand” instead of by the `react-redux` library.
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们通常是通过“手动”创建的，而不是通过`react-redux`库。
- en: They may contain style information, things like CSS classes, other style-related
    components, and any other UI-related data.
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们可能包含样式信息，例如CSS类、其他与样式相关的组件以及任何其他与UI相关的数据。
- en: 'If you’re exploring the React/Redux ecosystems, you may sometimes see references
    to *smart* (containers) and *dumb* (presentational) components. This way of referring
    to them has fallen out of favor, as it was found to be unhelpful and had a pejorative
    bent, but if do you see that terminology used you’ll be able to map it to the
    presentational/container dichotomy. With that in mind, container components do
    all of the following:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在探索React/Redux生态系统，你可能会偶尔看到对*智能*（容器）和*愚笨*（展示）组件的引用。这种称呼方式已经不再流行，因为它被发现是不有帮助的，并且带有贬义倾向，但如果你看到这种术语被使用，你将能够将其映射到展示/容器二分法。考虑到这一点，容器组件通常执行以下操作：
- en: Serve as a data source and can be stateful; the state will usually come from
    your Redux store.
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为数据源，可以是状态化的；状态通常来自你的Redux存储。
- en: Provide data and behavior information (like actions) to presentational components.
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向展示组件提供数据和行为信息（如动作）。
- en: Can contain other presentational *or* container components; it’s common for
    a container to be a parent with many presentational child components.
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以包含其他展示组件或容器组件；容器作为父组件拥有许多展示子组件是很常见的。
- en: Are usually created using `react-redux`’s *connect* method (more on that shortly)
    and are usually higher-order components (components that create new components
    from other components).
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常使用`react-redux`的`connect`方法（稍后将详细介绍）创建，通常是高阶组件（从其他组件创建新组件的组件）。
- en: Usually don’t have style information that doesn’t have to do with application
    data. For example, the user profile state slice on the Redux store might have
    “red” recorded for the user’s “favorite color”, but the container wouldn’t use
    that data for any styling—it would only ever pass it down to a presentational
    component.
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常不需要与应用数据无关的样式信息。例如，Redux存储中的用户配置文件状态切片可能会记录用户的“最喜欢的颜色”为“红色”，但容器不会使用这些数据来进行任何样式设计——它只会将其传递给一个展示组件。
- en: 'In this chapter, we’ll take a sort of middle approach to breaking down your
    components into presentational and connected or container components. For each
    component you want to connect to the Redux store, you’ll do the following:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将采取一种中间方法来将你的组件分解为展示组件和连接或容器组件。对于你想连接到Redux存储的每个组件，你将执行以下操作：
- en: Modify it by exporting a connected component in addition to the regular component.
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过导出一个连接组件以及常规组件来修改它。
- en: Move any props and state into special functions that `react-redux` can use (more
    on that shortly).
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将任何属性和状态移动到`react-redux`可以使用（稍后将详细介绍）的特殊函数中。
- en: Bring in any actions you need and bind those to an `actions` prop the component
    will have.
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引入你需要的任何动作，并将这些动作绑定到组件将拥有的`actions`属性。
- en: Replace local state where appropriate with props mapped to Redux store state.
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在适当的地方用映射到Redux存储状态的属性替换本地状态。
- en: '[Figure 11.3](kindle_split_023_split_002.xhtml#ch11fig03) should help you get
    a better sense of how a connected component typically works; the same Redux aspects
    exist, but are essentially “rearranged” around a React component so updates from
    the store are communicated to components.'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '[图11.3](kindle_split_023_split_002.xhtml#ch11fig03) 应该能帮助你更好地理解一个连接组件通常是如何工作的；相同的Redux方面存在，但基本上是围绕React组件“重新排列”的，以便将存储的更新传递给组件。'
- en: Figure 11.3\. Redux integrated with React. `react-redux` provides utilities
    that will help you generate components (higher-order components; components that
    generate other components).
  id: totrans-407
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图11.3\. 将Redux与React集成。`react-redux`提供了帮助你生成组件（高阶组件；生成其他组件的组件）的实用工具。
- en: '![](Images/11fig03_alt.jpg)'
  id: totrans-408
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/11fig03_alt.jpg)'
- en: This chapter doesn’t have the space to cover converting every component we’ve
    touched in this book, but the difference between containers and presentational
    components as well as the way you integrate Redux with React should give you some
    good starting practice to point you in the right direction.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 本章没有足够的空间涵盖将本书中接触到的每个组件都转换为容器组件，但容器组件和展示组件之间的区别以及你如何将Redux与React集成应该为你提供一些良好的起点实践，指引你走向正确的方向。
- en: 11.2.2\. Using <Provider /> to connect components to the Redux store
  id: totrans-410
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.2.2\. 使用<Provider />将组件连接到Redux存储
- en: The first step in integrating your Redux setup into your React app is to wrap
    the entire app with the Provider component provided by `react-redux`. This component
    accepts a Redux store as a prop and will make that store available to your “connected”
    components—another way to describe components that are hooked up to Redux. In
    almost every case, this is the central point of integration between your React
    components and Redux. A store will have to be available to your containers or
    your app won’t function properly (or probably at all). The following listing shows
    how to use the Provider component and update the authentication listener to handle
    your Redux actions.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 将你的 Redux 设置集成到你的 React 应用中的第一步是将整个应用包裹在 `react-redux` 提供的 Provider 组件中。该组件接受一个Redux
    store作为属性，并将该store提供给你的“连接”组件——这是连接到 Redux 的组件的另一种描述。在几乎所有情况下，这是你的 React 组件和 Redux
    之间的集成中心点。store必须可用于你的容器，否则你的应用可能无法正常工作（或者可能根本无法工作）。以下列表显示了如何使用Provider组件并更新身份验证监听器以处理你的
    Redux actions。
- en: Listing 11.10\. Wrapping your app with `react-redux`’s <Provider />
  id: totrans-412
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 11.10\. 使用 `react-redux` 的 <Provider />
- en: '[PRE30]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '***1* Import redux-related modules you’ll need here**'
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 导入你在这里需要的与redux相关的模块**'
- en: '***2* Create Redux store using initial state**'
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 使用初始状态创建 Redux store**'
- en: '***3* Wrap your router with Provider from react-redux and pass it the store**'
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 使用来自 react-redux 的 Provider 包装你的路由器，并传递它 store**'
- en: '***4* History listener stays the same**'
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 历史监听器保持不变**'
- en: '***5* Get user from Firebase and dispatch loading action**'
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 从 Firebase 获取用户并分发加载操作**'
- en: '***6* Create new user if you don’t have one already and dispatch user/token**'
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 如果还没有，创建新用户并分发用户/token**'
- en: '***7* Load existing user and dispatch**'
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 加载现有用户并分发**'
- en: Now that a store will be available to your components, you can connect them
    to your store. You’ll remember from [figure 11.3](kindle_split_023_split_002.xhtml#ch11fig03)
    that `react-redux` will inject store state into your components as props and change
    those props when the store gets updated. If you weren’t using `react-redux`, you’d
    need to manually subscribe to updates from the store on a component-by-component
    basis.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 现在store将可用于你的组件，你可以将它们连接到你的store。你会记得从[图 11.3](kindle_split_023_split_002.xhtml#ch11fig03)
    中，`react-redux` 将将store状态注入到你的组件作为props，并在store更新时更改这些props。如果你没有使用 `react-redux`，你需要手动在每个组件的基础上订阅store的更新。
- en: To make this happen, you need to use the `connect` utility from `react-redux`.
    It will generate a container component that’s connected (hence the name) to the
    Redux store and apply updates when the store changes. The `connect` method only
    has a few arguments, but there’s more to it than might first appear; you can read
    up on it more thoroughly at [https://github.com/reactjs/react-redux](https://github.com/reactjs/react-redux).
    For your purposes, you’ll use both the ability to subscribe to the store and to
    inject the store’s `dispatch` function so you can create actions for your components.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这一点，你需要使用来自 `react-redux` 的 `connect` 工具。它将生成一个连接到 Redux store 的容器组件（因此得名），并在store更改时应用更新。`connect`
    方法只有几个参数，但它的内容比最初看起来要多；你可以在[https://github.com/reactjs/react-redux](https://github.com/reactjs/react-redux)
    上了解更多。对于你的目的，你将使用订阅store的能力以及注入store的 `dispatch` 函数，以便为你的组件创建actions。
- en: To inject state, you’ll pass a function (`mapStateToProps`) that will receive
    `state` as a parameter and will return an object that will be merged into the
    props for the component; `react-redux` will re-invoke this function whenever the
    component receives new props. Once you’re using `connect` to wrap your component,
    you’ll need to adjust the way props are used in the component (I cover actions
    next); `state` shouldn’t be used unless it relates to UI-specific data. Remember
    that although this is considered a best practice, it doesn’t mean that there are
    no valid cases for blurring the lines between presentational and container components.
    They exist, even if they’re rare; make the best engineering decisions for your
    team and specific situation.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 要注入状态，你需要传递一个函数（`mapStateToProps`），该函数将接收 `state` 作为参数，并将返回一个将被合并到组件props中的对象；`react-redux`
    将在组件接收新props时重新调用此函数。一旦你使用 `connect` 来包裹你的组件，你将需要调整组件中props的使用方式（我将在下一部分介绍actions）；`state`
    不应使用，除非它与UI特定的数据相关。记住，尽管这被认为是最佳实践，但这并不意味着没有模糊表现性和容器组件之间界限的有效案例；它们确实存在，即使它们很罕见；为你的团队和特定情况做出最佳工程决策。
- en: '[Listing 11.11](kindle_split_023_split_002.xhtml#ch11ex11) shows how to use
    `connect` and how to adjust the way you’re accessing props in our Home component
    and convert it to a stateless function comp. You’ll use the first of the two parameters
    that you’ll end up passing to connect: `mapStateToProps`. This function will receive
    state (the store state) and can have an additional argument, `ownProps`, that
    will pass in any additional props passed to the container component. You won’t
    use that parameter right now, but the API provides it in case you need it.'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 11.11](kindle_split_023_split_002.xhtml#ch11ex11) 展示了如何使用 `connect` 以及如何调整你在我们的
    Home 组件中访问 props 的方式，并将其转换为无状态函数组件。你将使用传递给 connect 的两个参数中的第一个：`mapStateToProps`。这个函数将接收状态（存储状态）并可以有一个额外的参数，`ownProps`，它将传递给容器组件的任何额外的
    props。你现在不会使用这个参数，但 API 提供了它以防你需要它。'
- en: Listing 11.11\. `mapStateToProps` (src/pages/Home.js)
  id: totrans-425
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 11.11\. `mapStateToProps`（src/pages/Home.js）
- en: '[PRE31]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '***1* Use Lodash’s orderBy function for sorting posts**'
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 使用 Lodash 的 orderBy 函数对帖子进行排序**'
- en: '***2* Import components Home page displays**'
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 导入显示在主页上的组件**'
- en: '***3* Map over posts**'
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 遍历帖子**'
- en: '***4* Pass in post and post ID (mapStateToProps will further handle)**'
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 传递帖子及其 ID（`mapStateToProps` 将进一步处理）**'
- en: '***5* Map in posts and sort them using orderBy**'
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 使用 orderBy 对帖子进行映射和排序**'
- en: '***6* mapStateToProps function returns props for connected component**'
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* `mapStateToProps` 函数返回连接组件的 props**'
- en: '***7* Export connected component**'
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 导出连接组件**'
- en: When you run the app now (using `npm run dev`), you shouldn’t encounter any
    runtime errors, but you shouldn’t see any posts, either, because there are no
    actions doing anything. But if you open the React developer tools, you should
    be able to see `react-redux` at work creating your connected component. Notice
    how `connect` created another component that wraps the one you passed in and gave
    it a new set of props. Behind the scenes, it’s also going to subscribe to updates
    from the Redux store and pass them in as new props to your container. [Figure
    11.4](kindle_split_023_split_002.xhtml#ch11fig04) shows what you should see when
    you open the dev tools and your app side by side.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 当你现在运行应用时（使用 `npm run dev`），你不应该遇到任何运行时错误，但你也应该看不到任何帖子，因为没有任何操作在执行。但是，如果你打开
    React 开发者工具，你应该能够看到 `react-redux` 正在创建你的连接组件。注意 `connect` 是如何创建另一个组件来包裹你传递给它的组件，并给它一组新的
    props。在幕后，它还将订阅来自 Redux 存储的更新，并将它们作为新的 props 传递给你的容器。[图 11.4](kindle_split_023_split_002.xhtml#ch11fig04)
    展示了当你同时打开开发者工具和你的应用时你应该看到的内容。
- en: Figure 11.4\. If you open the React developer tools, you’ll be able to pick
    out the newly connected component and the props that it had passed into it by
    `connect`. Notice how the `connect` function created a new component that wrapped
    the component you passed to it.
  id: totrans-435
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 11.4\. 如果你打开 React 开发者工具，你将能够通过 `connect` 挑选出新连接的组件以及它通过 `connect` 传递给它的 props。注意
    `connect` 函数是如何创建一个新的组件来包裹你传递给它的组件的。
- en: '![](Images/11fig04_alt.jpg)'
  id: totrans-436
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/11fig04_alt.jpg)'
- en: 11.2.3\. Binding actions to component event handlers
  id: totrans-437
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.2.3\. 将操作绑定到组件事件处理器
- en: 'You need to get your app to respond to user actions again. You’ll use a second
    function to do that: `mapDispatchToProps`. This function does just what it sounds
    like—it has a `dispatch` argument that will be the store’s `dispatch` method,
    injected into your component. You might have noticed in [figure 10.3](kindle_split_022_split_001.xhtml#ch10fig03)
    from [chapter 10](kindle_split_022_split_000.xhtml#ch10) or in your React developer
    tools that the container has a `dispatch` method injected into its props already;
    you can use that function as is because it gets automatically injected if you
    don’t provide a `mapDispatchToProps` function. But using `mapDispatchToProps`
    has the advantage that you can use it to separate out the component-specific action
    logic from the component itself, and it makes testing easier.'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要让你的应用再次响应用户操作。你将使用第二个函数来完成这个任务：`mapDispatchToProps`。这个函数正是其名字所暗示的——它有一个 `dispatch`
    参数，这将作为存储的 `dispatch` 方法注入到你的组件中。你可能已经注意到，在 [第 10 章](kindle_split_022_split_000.xhtml#ch10)
    的 [图 10.3](kindle_split_022_split_001.xhtml#ch10fig03) 或者在你的 React 开发者工具中，容器已经有一个注入到其
    props 中的 `dispatch` 方法；你可以直接使用这个函数，因为它会自动注入，如果你没有提供 `mapDispatchToProps` 函数。但使用
    `mapDispatchToProps` 的优点是，你可以用它将组件特定的操作逻辑与组件本身分离出来，并且它使得测试变得更加容易。
- en: '|  |'
  id: totrans-439
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Source code assignment**'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: '**源代码作业**'
- en: The `react-redux` library provides some nice abstractions that have been battle-tested
    by many companies and individuals using Redux with React. But you don’t have to
    use this library to get React and Redux to work together. As an exercise, take
    some time to read through the source code for React-Redux at [https://github.com/reactjs/react-redux/tree/master/src](https://github.com/reactjs/react-redux/tree/master/src).
    It’s not recommended that you create your own way to connect React and Redux,
    but you should be able to see that it’s not “magic.”
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: '`react-redux` 库提供了一些经过许多公司和个人在 React 中使用 Redux 进行战斗测试的抽象。但您不必使用这个库来让 React
    和 Redux 一起工作。作为一个练习，花些时间阅读 React-Redux 的源代码，网址为 [https://github.com/reactjs/react-redux/tree/master/src](https://github.com/reactjs/react-redux/tree/master/src)。不建议您创建自己的方式来连接
    React 和 Redux，但您应该能够看到这并不是“魔法”。'
- en: '|  |'
  id: totrans-442
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The `mapDispatchToProps` function will be invoked by `react-redux` and the resulting
    object will be merged into your components’ props. You’ll use it to set up your
    action creators and make them available to your component. You’ll also take advantage
    of the `bindActionCreators` helper utility from Redux. The `bindActionCreators`
    utility transforms an object whose values are action creators into an object with
    identical keys—with the difference being that every action creator is wrapped
    in a dispatch call, so they may be invoked directly.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: '`mapDispatchToProps` 函数将由 `react-redux` 调用，并生成的对象将合并到您的组件属性中。您将使用它来设置您的动作创建器并使它们可用于您的组件。您还将利用
    Redux 的 `bindActionCreators` 辅助实用工具。`bindActionCreators` 实用工具将值是动作创建器的对象转换为一个具有相同键的对象——区别在于每个动作创建器都被包装在一个调度调用中，因此可以直接调用。'
- en: You probably noticed in [listing 11.11](kindle_split_023_split_002.xhtml#ch11ex11)
    that you used a React class instead of a stateless functional component. It’s
    common to create stateless functional components, but in this case you need a
    way to initially load posts, so you require lifecycle methods that can dispatch
    actions when the component has mounted. One way around this is to offload initiation
    events to the routing layer and coordinate loading data when certain routes are
    entered or exited. Your current router isn’t built with lifecycle hooks in mind,
    but other routers like React-router do have this as a feature. We’ll explore switching
    to React Router in the next chapter and you’ll take advantage of this feature.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到在 [列表 11.11](kindle_split_023_split_002.xhtml#ch11ex11) 中，您使用了一个 React
    类而不是无状态函数组件。创建无状态函数组件很常见，但在这个例子中，您需要一种方法来最初加载帖子，因此您需要可以在组件挂载时调度动作的生命周期方法。一种解决方案是将初始化事件卸载到路由层，并在进入或退出某些路由时协调加载数据。您当前的路由器没有考虑到生命周期钩子，但其他路由器，如
    React-router，确实具有这个功能。我们将在下一章中探讨切换到 React Router，您将利用这个功能。
- en: All that’s left, then, is to use `mapDispatchToProps` to pull in your actions
    and bind them in your components. You can also create an object with functions
    assigned to whatever key you like. This pattern can make it easier to directly
    reference your actions if the functions on the `mapDispatchToProps` object don’t
    have any additional logic between them and the dispatch invocation. The next listing
    shows how to use `mapDispatchToProps` to set up your actions.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，剩下的就是使用 `mapDispatchToProps` 来获取您的动作并将它们绑定到您的组件上。您还可以创建一个对象，将函数分配给您喜欢的任何键。这种模式可以使直接引用您的动作更容易，如果
    `mapDispatchToProps` 对象上的函数之间没有额外的逻辑，那么它们之间。
- en: Listing 11.12\. Using `mapDispatchToProps` (src/containers/Home.js)
  id: totrans-446
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 11.12\. 使用 `mapDispatchToProps` (src/containers/Home.js)
- en: '[PRE32]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '***1* Import actions you’ll need for this component**'
  id: totrans-448
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 导入您将需要为此组件使用的动作**'
- en: '***2* Load posts when component mounts**'
  id: totrans-449
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 组件挂载时加载帖子**'
- en: '***3* If error occurs in your component, use componentDidCatch to handle it,
    dispatch error to store**'
  id: totrans-450
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 如果组件中发生错误，请使用 componentDidCatch 来处理它，将错误调度到存储**'
- en: '***4* Pass post creation action to CreatePost component**'
  id: totrans-451
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 将创建帖子动作传递给 CreatePost 组件**'
- en: '***5* Pass showComments action via props**'
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 通过 props 传递 showComments 动作**'
- en: '***6* Pass load more posts action**'
  id: totrans-453
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 传递加载更多帖子的动作**'
- en: '***7* Use bindAction-Creators to bind wrap your actions in a dispatch call**'
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 使用 bindAction-Creators 将您的动作包装在调度调用中**'
- en: '***8* Use .bind() to ensure getPostsForPage action is called with ‘next’ argument
    every time**'
  id: totrans-455
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8* 使用 .bind() 确保每次调用 getPostsForPage 动作时都带有 ‘next’ 参数**'
- en: 'With that, you’ve connected your component to Redux! As I mentioned earlier,
    there isn’t sufficient space to cover converting every single one of the components
    in your application to use Redux. The good news is they all follow the same pattern
    (create `mapStateToProps` and `mapDispatchToProps`, export using `connect`), and
    you should be able to convert them to interact with Redux in the same way you
    did here for the home page. Here are the other components you’ve connected to
    the Redux store in the application source:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，你已经将你的组件连接到 Redux！正如我之前提到的，没有足够的空间来涵盖将你应用中的每个组件都转换为使用 Redux。好消息是它们都遵循相同的模式（创建
    `mapStateToProps` 和 `mapDispatchToProps`，使用 `connect` 导出），你应该能够将它们转换为以与这里对主页相同的方式与
    Redux 交互。以下是你在应用程序源中连接到 Redux 存储的其他组件：
- en: '*App*—src/app.js'
  id: totrans-457
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*应用*—src/app.js'
- en: '*Comments*—src/components/comment/Comments.js'
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*评论*—src/components/comment/Comments.js'
- en: '*Error*—src/components/error/Error.js'
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*错误*—src/components/error/Error.js'
- en: '*Navigation*—src/components/nav/navbar.js'
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*导航*—src/components/nav/navbar.js'
- en: '*PostActionSection*—src/components/post/PostActionSection.js'
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*帖子操作部分*—src/components/post/PostActionSection.js'
- en: '*Posts*—src/components/post/Posts.js'
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*帖子*—src/components/post/Posts.js'
- en: '*Login*—src/pages/login.js'
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*登录*—src/pages/login.js'
- en: '*SinglePost*—src/pages/post.js'
  id: totrans-464
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*单帖子*—src/pages/post.js'
- en: With all these components integrated, your application will be transitioned
    to using Redux! Now that you know how to add a Redux “loop” (action creator, reducer
    to handle action, and connecting any components), how would you go about adding
    a new feature like a user profile? What other features could you add to Letters
    Social? Fortunately, the Letters Social application has many areas for extension
    and ways in which you can try new things with Redux.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些组件集成后，你的应用程序将过渡到使用 Redux！现在你知道了如何添加 Redux “循环”（动作创建者、处理动作的减少器以及连接任何组件），那么你将如何添加新功能，比如用户资料？你还可以向
    Letters Social 添加哪些其他功能？幸运的是，Letters Social 应用程序有许多扩展区域和你可以尝试 Redux 的新方法。
- en: 11.2.4\. Updating your tests
  id: totrans-466
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.2.4\. 更新你的测试
- en: When you converted your Home component to React, you ended up breaking the tests
    that you had previously written for it. You’re going to fix that now. Fortunately,
    the bulk of the testing logic should now live elsewhere, so if anything, these
    tests should have gotten simpler than they were before. The following listing
    shows the updated test file for the Home component.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将你的主页组件转换为 React 时，你破坏了你之前为其编写的测试。你现在将修复它。幸运的是，大部分的测试逻辑现在应该存在于其他地方，所以如果有什么的话，这些测试应该比之前简单。以下列表显示了主页组件更新的测试文件。
- en: Listing 11.13\. Updating the Home component tests (src/containers/Home.test.js)
  id: totrans-468
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 11.13\. 更新主页组件测试（src/containers/Home.test.js）
- en: '[PRE33]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '***1* Mock Mapbox because CreateComment component will try to use it, bring
    in test renderer from react-test-renderer**'
  id: totrans-470
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 模拟 Mapbox，因为 CreateComment 组件将尝试使用它，引入测试渲染器从 react-test-renderer**'
- en: '***2* Create initial state with some posts**'
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 使用一些帖子创建初始状态**'
- en: '***3* Use initial state to create a store**'
  id: totrans-472
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 使用初始状态创建存储**'
- en: '***4* To test mapState-ToProps, assert a particular state will result in the
    right props**'
  id: totrans-473
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 为了测试 mapState-ToProps，断言特定的状态将导致正确的属性**'
- en: '***5* Assert mapDispatchToProps function has all the right properties**'
  id: totrans-474
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 断言 mapDispatchToProps 函数具有所有正确的属性**'
- en: '***6* Perform snapshot test to assert that component’s output hasn’t changed**'
  id: totrans-475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 执行快照测试以断言组件的输出没有改变**'
- en: '***7* Perform snapshot test to assert that component’s output hasn’t changed**'
  id: totrans-476
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 执行快照测试以断言组件的输出没有改变**'
- en: 11.3\. Summary
  id: totrans-477
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3\. 总结
- en: 'Here are the main things you learned in this chapter:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 本章你学到的主要内容：
- en: Reducers are functions used by Redux to compute changes to state based on a
    given action.
  id: totrans-479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少器是 Redux 用来根据给定的动作计算状态变化的函数。
- en: Redux is similar to Flux in many ways but introduces the idea of reducers, has
    a single store, and its action creators don’t directly dispatch actions.
  id: totrans-480
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Redux 在许多方面与 Flux 类似，但引入了减少器的概念，有一个单一存储，并且其动作创建者不会直接派发动作。
- en: Actions contain information about something that happened. They must have a
    type but can contain any other information that your store and reducers will need
    to determine how it should be updated. In Redux, there’s a single state tree for
    the entire application; state all lives in one area and can only be updated through
    specific APIs.
  id: totrans-481
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动作包含有关发生的事情的信息。它们必须有一个类型，但可以包含任何其他信息，你的存储和减少器将需要这些信息来确定如何更新。在 Redux 中，整个应用程序有一个单一的状态树；状态都生活在同一个区域，并且只能通过特定的
    API 进行更新。
- en: Action creators are functions that return actions that can be dispatched by
    the store. With certain middleware (see next bullet point) in place, you can create
    asynchronous action creators that are useful for doing things like calling remote
    APIs.
  id: totrans-482
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Action creators 是返回可以由 store 分发的 actions 的函数。在有某些中间件（见下一条项目符号）的情况下，你可以创建异步 action
    creators，这对于执行诸如调用远程 API 等操作非常有用。
- en: Redux allows you to write middleware, a place for injecting custom behavior
    into the Redux state management process. Middleware is executed before reducers
    are fired off and allow you to perform side effects or implement global solutions
    for your app.
  id: totrans-483
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Redux 允许你编写中间件，这是一个将自定义行为注入 Redux 状态管理过程的地方。中间件在触发 reducers 之前执行，并允许你执行副作用或为你的应用实现全局解决方案。
- en: '`react-redux` provides bindings for React components that enable you to connect
    your components to your store, handle the passing of new props, and check for
    updates from Redux (when the store changes).'
  id: totrans-484
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`react-redux` 为 React 组件提供了绑定，使你能够将你的组件连接到你的 store，处理新属性的传递，并检查 Redux 的更新（当
    store 发生变化时）。'
- en: Container components are components that only deal with data and nothing UI-related
    (think “application data only”).
  id: totrans-485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器组件是只处理数据而不涉及 UI 相关内容的组件（想想“仅应用数据”）。
- en: Presentational components are only concerned with what you can see or UI-specific
    data, such as whether a dropdown menu is open (think “what you see”).
  id: totrans-486
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 呈现组件只关注你可以看到的内容或 UI 特定的数据，例如下拉菜单是否打开（想想“你所看到的”）。
- en: Redux enforces a unidirectional data flow pattern where data changes are computed
    by reducers responding to actions and applied to the store.
  id: totrans-487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Redux 强制执行单向数据流模式，其中数据更改由响应 actions 的 reducers 计算并应用到 store 中。
- en: In the next chapter, you’ll explore the possibilities of server-side rendering
    in modern web applications and you’ll start using React on the server.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将探索现代网络应用中服务器端渲染的可能性，并开始使用 React 在服务器上。
- en: Chapter 12\. React on the server and integrating React Router
  id: totrans-489
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 12 章\. 服务器上的 React 和集成 React Router
- en: '*This chapter covers*'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Server-side rendering with React
  id: totrans-491
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 React 进行服务器端渲染
- en: When to and when *not* to add server-side rendering to your application
  id: totrans-492
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 何时以及何时不要将服务器端渲染添加到你的应用中
- en: Transitioning your routing setup to React Router
  id: totrans-493
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将你的路由设置过渡到 React Router
- en: Handling authenticated routes with React Router
  id: totrans-494
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 React Router 处理认证路由
- en: Fetching data during server-side rendering
  id: totrans-495
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在服务器端渲染期间获取数据
- en: Using Redux in the server-side rendering process
  id: totrans-496
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在服务器端渲染过程中使用 Redux
- en: Did you know you can use React outside the browser? That’s because some parts
    of the `react-dom` library don’t require a browser environment to work and can
    run on the node.js runtime (or almost any JavaScript runtime with sufficient language
    support). To be fair, most JavaScript that isn’t platform-specific can run on
    the browser or server; that would exclude IO-related features like reading files
    or cryptography for the node.js platform and user-related events or DOM-related
    aspects for browser platforms. But with the robustness and prevalence of the node.js
    platform, more and more frameworks are starting to be written with server and
    browser support in mind.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道你可以在浏览器外使用 React 吗？这是因为 `react-dom` 库的一些部分不需要浏览器环境即可工作，并且可以在 node.js 运行时（或几乎任何具有足够语言支持的
    JavaScript 运行时）上运行。公平地说，大多数非平台特定的 JavaScript 都可以在浏览器或服务器上运行；这会排除 node.js 平台相关的
    IO 功能，如读取文件或加密，以及浏览器平台相关的用户相关事件或 DOM 相关方面。但是，随着 node.js 平台的稳健性和普及，越来越多的框架开始考虑服务器和浏览器支持。
- en: This is true for React, too; it supports server-side rendering (SSR) via React
    DOM’s server APIs. What does that mean? SSR is generally the generation of static
    HTML markup that can be sent to the browser via HTTP or another protocol; it’s
    still “rendering,” but in a server context. Integrating SSR in your application
    can be useful in certain circumstances and unnecessary in others. In this chapter,
    we’ll explore some of the historical context of server-side rendering, look at
    when it might make sense to implement, integrate it into your Letters Social app,
    and replace the router you created in [chapters 7](kindle_split_018_split_000.xhtml#ch07)
    and [8](kindle_split_019_split_000.xhtml#ch08) to better support SSR and allow
    for future improvements. You’ll implement a simple version of server-side rendering
    using React to get familiar with the basic concepts.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 这对 React 也是如此；它通过 React DOM 的服务器 API 支持服务器端渲染（SSR）。这意味着什么？SSR 通常是指生成可以发送到浏览器通过
    HTTP 或其他协议的静态 HTML 标记；它仍然是“渲染”，但在服务器环境中。在某些情况下，在应用程序中集成 SSR 可能是有用的，而在其他情况下则是不必要的。在本章中，我们将探讨一些服务器端渲染的历史背景，看看何时可能需要实现它，将其集成到
    Letters Social 应用程序中，并替换你在 [第 7 章](kindle_split_018_split_000.xhtml#ch07) 和 [第
    8 章](kindle_split_019_split_000.xhtml#ch08) 中创建的路由，以更好地支持 SSR 并允许未来的改进。你将使用 React
    实现一个简单的服务器端渲染版本，以便熟悉基本概念。
- en: '|  |'
  id: totrans-499
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**How do I get the code for this chapter?**'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: '**我如何获取本章的代码？**'
- en: As with every chapter, you can check out the source code for this chapter by
    going to the GitHub repository at [https://github.com/react-in-action/letters-social](https://github.com/react-in-action/letters-social).
    If you want to start this chapter with a clean slate and follow along, you can
    use your existing code from [chapters 10](kindle_split_022_split_000.xhtml#ch10)
    and [11](kindle_split_023_split_000.xhtml#ch11) (if you followed along and built
    out the examples yourself) or check out the chapter-specific branch (chapter-12).
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 就像每一章一样，你可以通过访问 GitHub 仓库 [https://github.com/react-in-action/letters-social](https://github.com/react-in-action/letters-social)
    来查看本章的源代码。如果你想从这个章节开始一个全新的环境并跟随，你可以使用你从 [第 10 章](kindle_split_022_split_000.xhtml#ch10)
    和 [第 11 章](kindle_split_023_split_000.xhtml#ch11)（如果你跟随并自己构建了示例）中现有的代码，或者检出特定章节的分支（chapter-12）。
- en: Remember, each branch corresponds to the code at the end of the chapter (for
    example, the branch chapter-12 corresponds to the code as it will be at the end
    of this chapter). You can execute one of the following terminal commands in the
    directory of your choice to get the code for the current chapter.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，每个分支都对应于章节末尾的代码（例如，chapter-12 分支对应于本章末尾的代码）。你可以在你选择的目录中执行以下终端命令之一来获取当前章节的代码。
- en: 'If you don’t have the repository at all, type the following:'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你根本就没有仓库，请输入以下命令：
- en: '[PRE34]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'If you already have the repository cloned:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经克隆了仓库：
- en: '[PRE35]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'You may have come here from another chapter, so it’s always a good idea to
    ensure you have all the right dependencies installed:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能是从另一个章节来到这里的，所以始终确保你已经安装了所有正确的依赖项：
- en: '[PRE36]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '|  |'
  id: totrans-509
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 12.1\. What is server-side rendering?
  id: totrans-510
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.1. 服务器端渲染是什么？
- en: Let’s take a brief look at the historical context of rendering in web applications
    before we explore using React on the server. If you’re already familiar with how
    SSR works (maybe you’ve worked with frameworks like Ruby on Rails or Laravel before
    or already understand the mechanics), feel free to move ahead to section 12.1.4,
    where you start to implement SSR for your application.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们探索在服务器上使用 React 之前，让我们简要地回顾一下网络应用中渲染的历史背景。如果你已经熟悉了 SSR 的工作原理（也许你之前使用过像 Ruby
    on Rails 或 Laravel 这样的框架，或者已经理解了其机制），那么请随意跳到第 12.1.4 节，在那里你开始为你的应用程序实现 SSR。
- en: In the past (and still today for many applications), applications with only
    server-rendered views were the widespread norm. Generally, these apps would create
    HTML strings interspersed with user-related or other data and send that down to
    the browser over HTTP. Things would eventually improve, but at first even the
    server-side aspect was primitive. Simple server-side scripts were created that
    would manually concatenate parts of HTML strings together and then send that down
    as a response. This worked but made things more difficult than they had to be
    since manually creating concatenated views was time-consuming and could be hard
    to change. Over time, frameworks and even languages developed or were created
    to better enable developers to build user interfaces that were primarily rendered
    on the server.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去（并且至今对许多应用程序而言），只有服务器渲染视图的应用程序是普遍的标准。通常，这些应用程序会创建包含用户相关或其他数据的HTML字符串，并通过HTTP将其发送到浏览器。事情最终会得到改善，但最初即使是服务器端的功能也很原始。创建了简单的服务器端脚本，这些脚本会手动将HTML字符串的部分拼接在一起，然后将其作为响应发送下去。这虽然可行，但使得事情比必要的更加复杂，因为手动创建拼接视图既耗时又难以更改。随着时间的推移，框架甚至语言被开发或创建出来，以更好地帮助开发者构建主要在服务器上渲染的用户界面。
- en: '[Figure 12.1](kindle_split_024_split_001.xhtml#ch12fig01) shows a rough overview
    of this process. The basic idea is that servers respond to requests from the browser
    with dynamically generated HTML that, for example, contains information specific
    to the requesting user in some way. The example ERB template shows an example
    of what an engineer might work with as they create HTML markup. You might be familiar
    with the Pug (née Jade) templating language if you’ve worked in the node.js community
    before.'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: '[图12.1](kindle_split_024_split_001.xhtml#ch12fig01)展示了这个过程的粗略概述。基本思想是服务器对浏览器的请求做出响应，返回动态生成的HTML，例如，以某种方式包含请求用户的具体信息。示例ERB模板展示了工程师在创建HTML标记时可能工作的内容。如果你之前在node.js社区工作过，你可能熟悉Pug（原名Jade）模板语言。'
- en: Figure 12.1\. A simplified overview of server-side rendering
  id: totrans-514
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图12.1。服务器端渲染的简化概述
- en: '![](Images/12fig01_alt.jpg)'
  id: totrans-515
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/12fig01_alt.jpg)'
- en: Frameworks like Ruby on Rails, WordPress (a PHP-based content-management framework),
    and others developed and grew to fill the need of building applications in this
    manner. This server-centric approach has worked well and still does. But as client-side
    JavaScript became more robust and browsers became more powerful, developers eventually
    started using JavaScript for more than just adding basic interactivity to their
    apps. They started using it to generate and update interfaces with dynamic data.
    This meant the server was utilized less for templating and more as a source of
    data. Today you’ll find that many apps (like yours) use a robust client-side application
    to manage the UI and a remote (usually REST) API to provide dynamic data. This
    paradigm is the one you’ve been using in the book so far. But this chapter starts
    to change that slightly as you blend server-rendered and client-rendered patterns.
    The next section will show a more concrete example of some of what goes into server-side
    rendering. [Figure 12.2](kindle_split_024_split_001.xhtml#ch12fig02) shows an
    example of this setup as compared to the one in [figure 12.1](kindle_split_024_split_001.xhtml#ch12fig01).
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 像Ruby on Rails、WordPress（一个基于PHP的内容管理系统框架）等框架的开发和成长是为了满足以这种方式构建应用程序的需求。这种以服务器为中心的方法效果良好，并且至今仍然如此。但随着客户端JavaScript变得更加健壮，浏览器变得更加强大，开发者最终开始使用JavaScript来做的不仅仅是为他们的应用程序添加基本交互性。他们开始使用它来生成和更新带有动态数据的界面。这意味着服务器在模板化方面的使用减少，更多地作为数据源。今天你会发现许多应用程序（如你的）使用强大的客户端应用程序来管理UI，并使用远程（通常是REST）API来提供动态数据。这种范式是你迄今为止在书中一直在使用的。但本章开始稍微改变这一点，因为你开始混合服务器端渲染和客户端渲染的模式。下一节将展示一些关于服务器端渲染的具体示例。[图12.2](kindle_split_024_split_001.xhtml#ch12fig02)展示了这种设置与[图12.1](kindle_split_024_split_001.xhtml#ch12fig01)中的设置相比的例子。
- en: Figure 12.2\. As browsers and JavaScript evolved (sometimes slowly), client-side
    JavaScript took on more responsibilities. In both [figure 12.1](kindle_split_024_split_001.xhtml#ch12fig01)
    and this one, the same basic tasks are being accomplished (fetch or compute data;
    show it to the user), but client and server take on differing responsibilities.
  id: totrans-517
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图12.2。随着浏览器和JavaScript（有时进展缓慢）的演变，客户端JavaScript承担了更多的责任。在[图12.1](kindle_split_024_split_001.xhtml#ch12fig01)和这张图中，都在完成相同的基本任务（获取或计算数据；向用户展示），但客户端和服务器承担了不同的责任。
- en: '![](Images/12fig02_alt.jpg)'
  id: totrans-518
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/12fig02_alt.jpg)'
- en: 12.1.1\. Digging into server-side rendering
  id: totrans-519
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.1.1\. 深入研究服务器端渲染
- en: Before you start implementing SSR, we’ll look at a few more aspects of it in
    non-React contexts so that when you do start building it into your app, your task
    will make more sense. Let’s look at an example of SSR that uses ERB (Embedded
    Ruby). We saw ERB referenced in [figure 12.1](kindle_split_024_split_001.xhtml#ch12fig01).
    ERB is a feature of the Ruby programming language that can be used to create templates
    for HTML (or other types of text like XML for RSS feed generation). If you’re
    curious, you can learn more about ERB and Ruby on Rails at [http://guides.rubyonrails.org/layouts_and_rendering.html](http://guides.rubyonrails.org/layouts_and_rendering.html).
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始实现SSR之前，我们将从非React环境中探讨其更多方面，以便当你开始将其构建到你的应用中时，你的任务将更有意义。让我们看看一个使用ERB（嵌入式Ruby）的SSR示例。我们在[图12.1](kindle_split_024_split_001.xhtml#ch12fig01)中看到了ERB的引用。ERB是Ruby编程语言的一个特性，可以用来创建HTML（或其他类型的文本，如用于RSS订阅源生成的XML）模板。如果你感兴趣，可以在[http://guides.rubyonrails.org/layouts_and_rendering.html](http://guides.rubyonrails.org/layouts_and_rendering.html)了解更多关于ERB和Ruby
    on Rails的信息。
- en: Many Ruby on Rails apps will incorporate views generated using ERB templates.
    The framework will read the .erb template files created by developers and populate
    them using data from a server or elsewhere. Filled with data, the resulting text
    will be sent to the user’s browser. The ability to template HTML views is similar
    to JSX, albeit with a different syntax and semantics. React creates and manages
    the UI, whereas templating approaches like ERB only cover the “creation” half.
    [Listing 12.1](kindle_split_024_split_001.xhtml#ch12ex01) shows a simple example
    of an ERB file to demonstrate the sort of templating that’s often used in server-rendered
    applications. Aside from the syntax differences, it shouldn’t be too dissimilar
    from what you’re used to in other templating languages like Handlebars, Jade,
    EJS, or even in React. Many of these templating languages allow you to use many
    of the basic constructs available in programming languages like looping, variable
    access, and more; React’s JSX is no different.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 许多Ruby on Rails应用将包含使用ERB模板生成的视图。框架将读取开发者创建的.erb模板文件，并使用来自服务器或其他地方的数据填充它们。填充了数据后，生成的文本将被发送到用户的浏览器。模板化HTML视图的能力类似于JSX，尽管语法和语义不同。React创建并管理UI，而像ERB这样的模板化方法仅覆盖“创建”这一半。[列表12.1](kindle_split_024_split_001.xhtml#ch12ex01)展示了ERB文件的一个简单示例，以展示在服务器端渲染应用中经常使用的模板化类型。除了语法差异外，它与其他模板语言（如Handlebars、Jade、EJS，甚至在React中）所熟悉的内容不应有太大差异。许多这些模板语言允许你使用编程语言中许多基本结构，如循环、变量访问等；React的JSX也不例外。
- en: Listing 12.1\. ERB templating
  id: totrans-522
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表12.1\. ERB模板化
- en: '[PRE37]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: It might be helpful to take a quick look at what gets sent to the browser in
    the server-rendering process to get a feel for the mechanics of what you want
    to build. After the server processes a template like in [listing 12.1](kindle_split_024_split_001.xhtml#ch12ex01),
    it sends a text response to the browser. The result will look something like [listing
    12.2](kindle_split_024_split_001.xhtml#ch12ex02), which shows a text representation
    of an HTTP (version 1/1.1) response. This is similar to what you’ll be sending
    down to your browser when you’re rendering the Letters Social app on the server.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 快速查看服务器端渲染过程中发送到浏览器的内容，可能会有助于你对构建过程的机制有一个直观的了解。在服务器处理类似于[列表12.1](kindle_split_024_split_001.xhtml#ch12ex01)中的模板之后，它将发送一个文本响应到浏览器。结果将类似于[列表12.2](kindle_split_024_split_001.xhtml#ch12ex02)，它展示了HTTP（版本1/1.1）响应的文本表示。这类似于你在服务器上渲染Letters
    Social应用时发送到浏览器的内容。
- en: I used a common command-line tool, cURL, to fetch the web page at http://example.com
    so we could see a raw HTTP request. You probably already have cURL installed on
    your machine, but if you don’t, head over to [https://github.com/curl/](https://github.com/curl/)
    curl and follow the instructions there to install it. [Listing 12.2](kindle_split_024_split_001.xhtml#ch12ex02)
    shows the “raw” HTTP response sample output from running `curl -v https://example.com`.
    I omitted some content for brevity and left in the > and < symbols from cURL to
    indicate outgoing (>) and incoming (<) messages. If you don’t want to use cURL,
    you can always navigate to http://example.com in your browser and open the developer
    tools. Chrome, Firefox, and Edge all have network sections that let you inspect
    HTTP requests, too.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 我使用了一个常见的命令行工具cURL来获取http://example.com的网页，以便我们可以看到原始HTTP请求。您可能已经在您的机器上安装了cURL，但如果您没有，请访问[https://github.com/curl/](https://github.com/curl/)
    curl并按照那里的说明进行安装。[列表12.2](kindle_split_024_split_001.xhtml#ch12ex02)显示了运行`curl
    -v https://example.com`的“原始”HTTP响应样本输出。为了简洁起见，我省略了一些内容，并保留了cURL中的>和<符号来指示出站（>）和入站（<）消息。如果您不想使用cURL，您也可以在浏览器中导航到http://example.com并打开开发者工具。Chrome、Firefox和Edge都拥有网络部分，允许您检查HTTP请求。
- en: Listing 12.2\. Sample HTTP request
  id: totrans-526
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表12.2. 示例HTTP请求
- en: '[PRE38]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '***1* Request you sent to server using cURL**'
  id: totrans-528
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 您使用cURL发送到服务器的请求**'
- en: '***2* Response headers provide information like status of response and other
    helpful info (Cache-Control, Expires, and so on)**'
  id: totrans-529
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 响应头提供了诸如响应状态和其他有用信息（如Cache-Control、Expires等）**'
- en: '***3* Response headers provide information like status of response and other
    helpful info (Cache-Control, Expires, and so on)**'
  id: totrans-530
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 响应头提供了诸如响应状态和其他有用信息（如Cache-Control、Expires等）**'
- en: '***4* Response body—what you’ll use React to generate**'
  id: totrans-531
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 响应体——您将使用React生成的内容**'
- en: By the end of this chapter, you want the server portion of your application
    to be able to create the same sort of result as in [listing 12.2](kindle_split_024_split_001.xhtml#ch12ex02)
    (but specific to your app, of course). Hopefully by now the general idea of server
    rendering is making sense. In the next two sections, we’ll explore when it does
    and doesn’t make sense to build this functionality into your application.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您希望应用的服务器部分能够创建与[列表12.2](kindle_split_024_split_001.xhtml#ch12ex02)中相同类型的输出（但当然要针对您的app）。希望到现在为止，服务器渲染的一般概念已经变得有意义。在接下来的两个部分中，我们将探讨何时以及何时不应将此功能构建到您的应用中。
- en: 12.2\. Why render on the server?
  id: totrans-533
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.2. 为什么要在服务器上渲染？
- en: Why would you want to do SSR? There might be some very compelling reasons, depending
    on your use case. For example, there’s some anecdotal evidence that a server-rendered
    app fares better when it comes to being indexed and crawled by search engines.
    Although it seems that large search engines like Google can execute or at least
    emulate JavaScript and the DOM on the server, it also seems as if sites that render
    dynamic content without requiring the DOM tend to fair better. It’s difficult
    to ascertain the exact impact of SSR versus non-SSR apps on search engine optimization
    (SEO) because Google and other companies’ site-ranking algorithms are closely
    held, but there’s at least anecdotal evidence from people and teams in the industry
    that it can have a positive effect. If you have a highly public app that heavily
    depends on showing up in search engine results, you might consider SSR to increase
    crawler-friendliness in addition to all your other SEO optimizations.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么您想进行SSR？这取决于您的用例，可能会有一些非常有力的理由。例如，有一些轶事证据表明，当涉及到被搜索引擎索引和抓取时，服务器渲染的应用表现更好。尽管大型搜索引擎如Google似乎可以在服务器上执行或至少模拟JavaScript和DOM，但似乎渲染动态内容而不需要DOM的网站表现更好。由于Google和其他公司的网站排名算法是保密的，因此很难确定SSR与非SSR应用对搜索引擎优化（SEO）的确切影响，但至少有来自行业中的个人和团队的轶事证据表明它可能产生积极影响。如果您有一个高度公开的应用，并且高度依赖在搜索引擎结果中显示，您可能需要考虑SSR来增加爬虫友好性，以及您所有的其他SEO优化。
- en: In this book, you’ve been building an app that requires interactivity and allows
    users to dynamically create content, but not every app has those requirements.
    If you only want the static aspects of React, you could easily use React-DOM’s
    static rendering abilities to create a static page generator or templating library.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，您一直在构建一个需要交互性和允许用户动态创建内容的app，但并非每个app都有这些需求。如果您只想使用React的静态方面，您可以使用React-DOM的静态渲染能力轻松创建一个静态页面生成器或模板库。
- en: Another reason you might want to render on the server is to optimize your users’
    experience. If your app needs to show content to users as quickly as possible,
    rendering on the server might allow you to present that content to them more quickly
    than waiting on a client-side render might. This could be the case if your app
    is something that depends heavily on showing ads or other static paid content
    to people and if the size of the payload isn’t substantially large. In cases where
    you want to show content quickly without interaction, you tend to be more concerned
    about the *first paint*, which is when a user is first able to see something in
    their browser.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望在服务器上渲染的另一个原因是优化用户的体验。如果你的应用需要尽快向用户展示内容，那么在服务器上渲染可能允许你比等待客户端渲染更快地向他们展示内容。这可能适用于你的应用依赖于向人们展示广告或其他静态付费内容，并且负载大小不是特别大的情况。在你想快速展示内容而不需要交互的情况下，你通常更关心的是*首次绘制*，这是用户第一次能够在他们的浏览器中看到内容的时候。
- en: The first paint is one of many metrics you can use to determine how well an
    app is being rendered by the browser. Another one is the *perceptual speed index*
    (usually just *speed index* or *SpeedIndex*). This is calculated by recording
    how much of the page has finished rendering over time. Browsers will record a
    video of the page as it is loading and determine what percent of the page has
    loaded at a given interval. This metric can be useful for understanding at an
    aggregate level how quickly a given page appears to load for a user. SSR can potentially
    contribute to a faster speed index by allowing more of your site to be renderable
    by the browser earlier in the loading process. Learn more about speed index at
    [https://sites.google.com/a/webpagetest.org/docs/using-webpagetest/metrics/speed-index](https://sites.google.com/a/webpagetest.org/docs/using-webpagetest/metrics/speed-index).
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 首次绘制是你可以用来确定浏览器如何渲染应用的许多指标之一。另一个是*感知速度索引*（通常简称为*速度索引*或*SpeedIndex*）。这是通过记录页面随时间完成渲染的部分来计算的。浏览器会在页面加载时记录一个视频，并确定在给定的时间间隔内页面加载了多少百分比。这个指标可以用来理解在总体层面上，给定页面对于用户来说加载得多快。SSR可以通过允许在加载过程的早期阶段有更多的网站内容可以被浏览器渲染，从而潜在地贡献到一个更快的速度索引。更多关于速度索引的信息，请参阅[https://sites.google.com/a/webpagetest.org/docs/using-webpagetest/metrics/speed-index](https://sites.google.com/a/webpagetest.org/docs/using-webpagetest/metrics/speed-index)。
- en: Most apps will benefit from a faster speed index and quick first paint. But
    in other cases, you may not care as much about showing something to a user as
    quickly as possible because you care more about how quickly they can use your
    app. The time it takes until a user can interact with your application or page,
    called *time to interactive* (TTI), might be more important if your app is a highly
    interactive, feature-rich application like Basecamp or Asana. For these applications,
    SSR might not make sense because they aren’t public-facing and rely more heavily
    on interactivity than on showing their users something quickly.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数应用都将从更快的速度索引和快速首次绘制中受益。但在其他情况下，你可能不会像关心尽快向用户展示内容那样关心，因为你更关心他们使用你的应用的速度。用户能够与你的应用程序或页面交互所需的时间，称为*交互时间*（TTI），如果您的应用是一个高度交互、功能丰富的应用，如Basecamp或Asana，那么这个时间可能更为重要。对于这些应用，SSR可能没有意义，因为它们不是面向公众的，并且比快速向用户展示内容更依赖于交互性。
- en: 'Let’s look at a couple of applications and see how TTI could hypothetically
    factor in:'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看几个应用，并看看TTI如何可能影响：
- en: '***Basecamp (project management app)*—** Users want to be able to search for
    issues, update to-dos, and check project statuses. In this case, you would want
    to optimize your app to load JavaScript as quickly as possible instead of trying
    to show the user content as quickly as possible.'
  id: totrans-540
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***Basecamp（项目管理应用）***—**用户希望能够搜索问题、更新待办事项和检查项目状态。在这种情况下，你希望优化你的应用，尽可能快地加载JavaScript，而不是试图尽快向用户展示内容。'
- en: '***Medium (blog/writing app)*—** Users want to be able to read and browse articles
    as quickly as possible. Their ability to do so doesn’t depend on the interactivity
    of the app, so in this case you might want to optimize for the first paint.'
  id: totrans-541
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***Medium（博客/写作应用）***—**用户希望尽可能快地阅读和浏览文章。他们这样做的能力并不依赖于应用交互性，因此在这种情况下，你可能希望优化首次绘制。'
- en: When considering SSR you’ll also want to weigh the resource-usage tradeoffs
    between rendering on the server and on the client. If you’re rendering a huge
    amount of data (maybe thousands of rows in an online spreadsheet), doing that
    on the server will probably require you to send down a much larger initial payload
    to the browser. This, in turn, will probably mean a longer TTI that could be detrimental
    to your users and will probably use more server resources. Getting the same amount
    of data in JSON format after the app has loaded, for example, would probably result
    in a smaller payload size and potentially better user experience.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 当考虑SSR时，你还需要权衡在服务器和客户端渲染之间的资源使用权衡。如果你正在渲染大量数据（比如在线电子表格中的数千行），在服务器上执行这一操作可能需要你向浏览器发送更大的初始负载。这反过来可能意味着更长的TTI（首次内容绘制时间），这可能会对你的用户造成不利影响，并可能使用更多的服务器资源。例如，在应用加载后以JSON格式获取相同数量的数据，可能会产生更小的负载大小，并可能带来更好的用户体验。
- en: '|  |'
  id: totrans-543
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Server rendering with enterprise and consumer applications**'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: '**企业级和消费级应用的服务器渲染**'
- en: You may feel like our discussion of server rendering in this chapter is something
    theoretical that you’ll never have to deal with. But I believe you’ll find that
    server rendering is more common than you think and is an option many teams will
    actively consider. I’ve seen this to be true in my own experience and in the experiences
    of other engineers I’ve met. I’ve worked on public-facing consumer products and
    walled-off enterprise applications and had the chance to see server rendering
    considered in diverse business scenarios. In both sorts of cases, we wanted to
    do the best thing for our users and we considered server-side rendering as an
    option.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会觉得我们本章关于服务器渲染的讨论是某种理论性的内容，你永远不会需要处理。但我想告诉你，服务器渲染比你想象的要普遍得多，并且是许多团队会积极考虑的一个选项。我在自己的经历以及我所遇到的工程师的经历中看到了这一点。我参与过面向公众的消费产品以及封闭的企业应用的开发，有机会看到服务器渲染在多种商业场景中被考虑。在这两种情况下，我们都希望为用户提供最好的服务，并考虑了服务器端渲染作为一个选项。
- en: In the enterprise application, we were dealing with users who wanted the application
    to be interactive quickly, not just quickly rendered. We also had to serve pages
    that were potentially filled with hundreds or even thousands of rows of financial
    data (which could potentially obviate gains achieved by server rendering). The
    application was comprised of several smaller applications, and we served different
    JavaScript bundles depending on which of the apps were in use at a given time.
    To make matters even more complicated, data integrity and security were of the
    topmost concern for us, so server rendering would potentially introduce a new
    area to secure and evaluate from a security perspective.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 在企业应用中，我们面对的是希望应用能够快速交互的用户，而不仅仅是快速渲染。我们还必须提供可能包含数百行甚至数千行财务数据的页面（这可能会抵消服务器渲染带来的收益）。该应用由几个较小的应用组成，我们根据特定时间使用哪些应用来提供不同的JavaScript包。更复杂的是，数据完整性和安全性对我们来说是最重要的考虑因素，因此服务器渲染可能会引入一个新的安全领域，需要从安全角度进行评估和保障。
- en: These factors made server rendering a “nice to have” that would be saved for
    some future time when it could be reevaluated. We found that we could do other
    things to help our users, like improving our server performance, optimizing how
    we serve application assets, and defer data fetching on the client until necessary.
    Interestingly, people also tend to have different expectations about different
    sorts of applications. Consumer applications like Facebook, Twitter, and Amazon
    all compete for users that have a wide variety of choices they can make and so
    directly compete with others on many fronts. In my experience, enterprise users
    tend to have a slightly different set of expectations for an application they
    use for work. Speed is, of course, incredibly important, but so are stability,
    reliability, clarity, and other important aspects of a business application. It
    might make sense for an engineering team to optimize on these dimensions instead
    of spending the equivalent time optimizing on a less impactful metric. That’s
    not always the case, but it has been for some projects I’ve worked on.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 这些因素使得服务器渲染成为“锦上添花”的东西，可以在未来某个可以重新评估的时间保存。我们发现我们可以做其他事情来帮助我们的用户，比如提高我们的服务器性能，优化我们提供应用资源的方式，以及在必要时才在客户端延迟数据获取。有趣的是，人们对不同类型的应用也有不同的期望。像Facebook、Twitter和Amazon这样的消费应用都在争夺用户，他们有各种各样的选择，因此直接在其他许多方面与其他人竞争。在我的经验中，企业用户对他们用于工作的应用有一套不同的期望。速度当然非常重要，但稳定性、可靠性、清晰度以及商业应用的其他重要方面也同样重要。对于工程团队来说，在这些维度上优化可能比花同样时间在影响较小的指标上优化更有意义。这并不总是情况，但对我来说，我在一些项目上就是这样做的。
- en: Other projects I’ve worked on had very different demands. Another application
    was in the e-commerce space. Server rendering of pages made sense because time
    to first paint and SEO considerations were extremely important. We worked to minimize
    the size of bundled assets and show content to the user as quickly as possible.
    Any appearance of sluggishness would potentially dissuade a user from continuing
    in their shopping experience. The applications were also tightly integrated with
    marketing efforts, so working to guarantee stable SEO performance was a priority.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 我参与的其他项目有着非常不同的需求。另一个应用是在电子商务领域。页面服务器渲染是有意义的，因为首次绘制时间和SEO考虑因素非常重要。我们努力最小化捆绑资源的尺寸，并尽可能快地向用户展示内容。任何迟缓的表现都可能阻止用户继续他们的购物体验。这些应用也与营销活动紧密集成，因此保证稳定的SEO性能是一个优先事项。
- en: There are still other sorts of cases where server rendering can be applied,
    but I hope that these two simpler examples help shed a little light on some of
    the practicalities of what we’re discussing in this chapter.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然有其他类型的案例，其中服务器渲染可以应用，但我希望这两个更简单的例子能帮助稍微阐明我们在本章讨论的一些实际问题的细节。
- en: '|  |'
  id: totrans-550
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'You don’t necessarily have to go all-or-nothing in your SSR implementation.
    If you must render thousands of rows in a spreadsheet, it might make sense to
    let the client handle that aspect of rendering but render the signup and login
    pages on the server since those are smaller and rely more on first paint than
    on time to interactivity. You could also choose to render certain portions of
    pages on the web but allow the client to handle all further data fetching and
    rendering. If you’re interested in learning more about thinking through different
    aspects of web performance, a great place to start is Google’s Web Fundamentals
    guide: [https://developers.google.com/web/fundamentals/performance/](https://developers.google.com/web/fundamentals/performance/).'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的SSR实现中，不一定非得全有或全无。如果你必须在电子表格中渲染成千上万的行，可能让客户端处理渲染的这一方面是有意义的，但登录和注册页面可以在服务器上渲染，因为它们较小，并且更多地依赖于首次绘制而不是交互时间。你也可以选择在网页上渲染某些部分，但允许客户端处理所有进一步的数据获取和渲染。如果你对深入了解不同方面的Web性能有更多兴趣，一个好的起点是Google的Web基础指南：[https://developers.google.com/web/fundamentals/performance/](https://developers.google.com/web/fundamentals/performance/).
- en: 12.3\. You might not need SSR
  id: totrans-552
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.3. 你可能不需要SSR
- en: Even though there are some potential benefits to SSR, you should only build
    it into your app when the need really exists. That’s because it can, depending
    on how deeply integrated it is, introduce significant complexity. In this chapter,
    we’ll implement a basic, even simplistic, version of SSR (server-side rendering)
    to get familiar with the concepts, but building a robust, purpose-built implementation
    that handles all the different nuances of doing SSR can represent a significant
    technical involvement.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管SSR有一些潜在的好处，但你只有在真正需要时才应该将其构建到你的应用程序中。这是因为，根据其深度集成程度，它可能会引入显著复杂性。在本章中，我们将实现一个基本的、甚至可以说是简化的SSR（服务器端渲染）版本，以便熟悉这些概念，但构建一个强大、专门设计的实现，以处理所有不同的SSR细微差别，可能需要重大的技术投入。
- en: 'There are at least a few reasons why integrating server-side rendering can
    add complexity. Here are a few of them:'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 至少有几个原因说明为什么集成服务器端渲染会增加复杂性。以下是一些原因：
- en: You’ll need to synchronize the server and client in a way that your client can
    understand when it takes over. This can involve setting up markup, event handlers,
    and more that a client might need. Your authentication implementation will also
    need to account for requests coming from either the server or the client, which
    may require changes.
  id: totrans-555
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你需要以某种方式同步服务器和客户端，使得客户端能够理解何时接管。这可能包括设置标记、事件处理程序等客户端可能需要的更多内容。你的认证实现还需要考虑到来自服务器或客户端的请求，这可能需要做出改变。
- en: The client and server operate within different paradigms that don’t always easily
    map to one another (for example, no DOM, no filesystem, and so on). You must coordinate
    handoff and rendering and make sure you either don’t use, or else properly handle,
    components that depend on a browser environment.
  id: totrans-556
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端和服务器在不同的范式下运行，这些范式并不总是容易相互映射（例如，没有DOM，没有文件系统等）。你必须协调交接和渲染，并确保你不使用，或者正确处理依赖于浏览器环境的组件。
- en: Although there are a few exceptions, React (and any JavaScript) is most reliably
    run on Node.js runtime. This can tend to couple your client and the server that
    renders it because they now both need to support JavaScript. That can be a good
    thing, but it does mean you’re tying yourself to the JavaScript language/platform
    more than you would otherwise.
  id: totrans-557
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管有一些例外，但React（以及任何JavaScript）最可靠地运行在Node.js运行时。这可能会使你的客户端和渲染它的服务器耦合在一起，因为它们现在都需要支持JavaScript。这可能是一件好事，但也意味着你比以前更多地把自己绑定在JavaScript语言/平台上。
- en: Fine-tuning SSR can require special tuning of your client and server. Performance
    gains are usually realized in small, incremental wins that focus on specific functionality
    and almost always involve tradeoffs. This can sometimes mean less flexibility
    in making rapid changes and a more complex maintenance process. Server-side rendering
    adds one more aspect to this process.
  id: totrans-558
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微调SSR可能需要对客户端和服务器进行特殊的调整。性能提升通常是通过关注特定功能的小幅、增量胜利来实现的，这几乎总是涉及权衡。这有时可能意味着在快速做出改变时灵活性降低，以及更复杂的维护过程。服务器端渲染给这个过程增加了另一个方面。
- en: Overall, the main reason for caution here is the “use only what you need” idea.
    I don’t want you to come away with the idea that your React app isn’t complete
    or is somehow “not React-y enough” unless it’s using SSR. The best engineering
    decision-making processes involve a thorough consideration of the tradeoffs involved
    (not just what other people are using or what’s popular!), and that applies here,
    too. An example might be the case where you’re writing a simple blogging app as
    a personal side project. The reality is that you don’t need the infrastructure
    and orchestration technology of, say, Netflix, if you’re not Netflix. Even so,
    not all large companies are doing SSR. At the present time of writing, for instance,
    even Instagram doesn’t seem to be using React to do SSR, and that company is heavily
    invested in React. Use what you need.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，这里谨慎的主要原因是“只使用你需要的东西”这一理念。我不想让你产生这样的想法，即你的React应用程序不完整，或者以某种方式“不够React化”，除非它使用了SSR。最好的工程决策过程涉及对所涉及权衡的彻底考虑（而不仅仅是其他人使用什么或什么受欢迎！），这也适用于这里。一个例子可能是你正在编写一个简单的博客应用程序作为个人副项目。现实是，如果你不是Netflix，你不需要Netflix的基础设施和编排技术。即便如此，并非所有大型公司都在做SSR。例如，在撰写本文时，甚至Instagram似乎也没有使用React进行SSR，而该公司在React上投入了大量资金。使用你所需要的。
- en: 12.4\. Rendering components on the server
  id: totrans-560
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.4. 服务器上渲染组件
- en: 'Now that we’ve briefly looked at some of the tradeoffs of server-side rendering,
    we can start to dig in and see how it works with React. Let’s start with the React
    API that you’ll use. ReactDOMServer (accessed via `require(''react-dom/server'')`
    or `import ReactDOM from ''react-dom/server''`) exposes four important methods
    that you can use to generate the initial HTML for your components:'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们简要地探讨了服务器端渲染的一些权衡，我们可以开始深入了解它是如何与 React 一起工作的。让我们从您将使用的 React API 开始。ReactDOMServer（通过
    `require('react-dom/server')` 或 `import ReactDOM from 'react-dom/server'` 访问）公开了四个重要的方法，您可以使用这些方法为您组件生成初始
    HTML：
- en: '`renderToString`'
  id: totrans-562
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`renderToString`'
- en: '`renderToStaticMarkup`'
  id: totrans-563
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`renderToStaticMarkup`'
- en: '`renderToNodeStream`'
  id: totrans-564
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`renderToNodeStream`'
- en: '`renderToStaticNodeStream`'
  id: totrans-565
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`renderToStaticNodeStream`'
- en: Let’s look at each method in turn.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一查看每个方法。
- en: 'First, we have `ReactDOMServer.renderToString`. `renderToString` does what
    it sounds like: it takes a React element and generates the corresponding HTML
    markup from the component based on initial state and props (either default or
    passed) that exist when the method is called. React elements, as you’ll remember
    from earlier chapters, are the smallest building blocks of React apps. They’re
    created with `React.createElement` (or, more commonly, from JSX) and they’re created
    from either a string type or a React component class. The method looks like this:'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们有 `ReactDOMServer.renderToString`。`renderToString` 做的事情正如其名：它接受一个 React
    元素，并根据方法调用时存在的初始状态和属性（默认或传递的）从组件生成相应的 HTML 标记。如您在前面章节中记住的那样，React 元素是 React 应用程序的最小构建块。它们通过
    `React.createElement`（或更常见的是 JSX）创建，并且可以从字符串类型或 React 组件类创建。该方法看起来像这样：
- en: '[PRE39]'
  id: totrans-568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: When you’re rendering on the server, you’re using components and passing props
    as usual. The key difference between what you’re used to so far and using React
    on the server is the lack of a DOM and browser environment. This means React won’t
    run lifecycle methods like `componentWillMount` or persist state or utilize other
    DOM-specific features.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 当您在服务器上渲染时，您会像往常一样使用组件并传递属性。您迄今为止所习惯的与在服务器上使用 React 的主要区别是缺少 DOM 和浏览器环境。这意味着
    React 不会运行生命周期方法，如 `componentWillMount`，也不会持久化状态或利用其他 DOM 特定功能。
- en: '|  |'
  id: totrans-570
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Server rendering can involve a significant amount of complexity and shouldn’t
    be treated as a standard or “must-have” feature for all applications. Take some
    time to think through how you might approach implementing (or choosing not to
    implement) server-side rendering for the following types of apps:'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器端渲染可能涉及相当多的复杂性，不应被视为所有应用程序的标准或“必备”功能。花点时间思考一下您可能如何实现（或选择不实现）以下类型应用程序的服务器端渲染：
- en: Enterprise application with no public-facing portions
  id: totrans-572
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有面向公众部分的企业应用程序
- en: Social media site that depends heavily on advertising
  id: totrans-573
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 严重依赖广告的社交媒体网站
- en: E-commerce application
  id: totrans-574
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子商务应用程序
- en: Video-hosting platform
  id: totrans-575
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视频托管平台
- en: '|  |'
  id: totrans-576
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '`ReactDOM.renderToStaticMarkup` will do the same thing as `renderToString`,
    but without attaching any extra DOM attributes for React to use when “taking over”
    on the client side. This is useful for cases when you want to do basic templating
    or static site generation and don’t need any of the extra attributes. `renderToStaticMarkup`
    is almost identical to `renderToString`:'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReactDOM.renderToStaticMarkup` 将与 `renderToString` 做同样的事情，但不会附加任何额外的 DOM 属性供
    React 在客户端“接管”时使用。这在您只想进行基本的模板化或静态站点生成且不需要任何额外属性的情况下非常有用。`renderToStaticMarkup`
    几乎与 `renderToString` 相同：'
- en: '[PRE40]'
  id: totrans-578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: You won’t be using `renderToStaticMarkup` beyond this point, but once you’re
    done learning about how to implement SSR with React it should be simple to use
    it in future projects where appropriate.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 您将不会在此之后使用 `renderToStaticMarkup`，但一旦您学会了如何使用 React 实现服务器端渲染，在适当的项目中将其用于未来项目应该会很简单。
- en: You may have noticed that the first two methods have apparent complements in
    `renderToNodeStream` and `renderToStaticNodeStream`. If so, you’ve guessed correctly.
    These methods are identical to the others except they use node’s Streams API and
    were introduced in React 16 along with the fiber reconciler and many other changes.
    Streams are commonly used in node.js, and if you’ve done any work with node, you’ve
    probably heard of them. If you haven’t, that’s fine too, and you can learn more
    at [https://nodejs.org/api/stream.html](https://nodejs.org/api/stream.html). The
    takeaway for our purposes is that these stream-based methods are asynchronous.
    This gives them a significant advantage over their synchronous counterparts. For
    some time, one of the minor disadvantages of server rendering with React was that
    these methods were synchronous. That presented a challenge for applications that
    must render complex pages with many components. We’ll explore these methods later
    in the chapter when we look at data fetching on the server as part of server rendering.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到前两种方法在 `renderToNodeStream` 和 `renderToStaticNodeStream` 中有明显的补充。如果是这样，你猜对了。这些方法与其他方法相同，只是它们使用了
    Node 的 Streams API，并在 React 16 中随着 fiber reconciler 和许多其他变化一起引入。Streams 在 node.js
    中被广泛使用，如果你与 Node 有过任何工作，你可能已经听说过它们。如果你没有，那也无所谓，你可以在 [https://nodejs.org/api/stream.html](https://nodejs.org/api/stream.html)
    上了解更多信息。对我们来说，这些基于流的方法的要点是它们是异步的。这使它们在它们的同步对应物之上具有显著的优势。在一段时间内，使用 React 进行服务器渲染的一个小缺点是这些方法是同步的。这对必须渲染包含许多组件的复杂页面的应用程序提出了挑战。我们将在本章后面探讨这些方法，当我们查看服务器渲染中的数据获取时。
- en: We can focus on `renderToString` now that you know a little bit more about the
    API methods available to us. `renderToString` will generate code that React can
    work with and use on the client. React-DOM has another method, `hydrate`, that
    works almost exactly like the regular `render` method you’re so used to. The main
    difference is that `hydrate` specifically handles markup generated by server-side
    rendering.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你对可用的 API 方法了解得更多了，我们可以关注 `renderToString`。`renderToString` 将生成 React 可以在客户端使用和工作的代码。React-DOM
    另有一个方法 `hydrate`，它几乎与您非常熟悉的常规 `render` 方法完全一样。主要区别在于 `hydrate` 专门处理由服务器端渲染生成的标记。
- en: If you call `ReactDOM.hydrate()` on a node that already has the markup created
    by React-DOM on the server, React will preserve the existing HTML and do less
    work than it would otherwise. This should generally mean even less work for React
    to do on initial startup in addition to being a quicker initial load (depending
    on how much data you’re sending down and other factors like server load, network,
    weather, and so forth). I won’t note it again, but remember that SSR isn’t magic,
    and you can easily obviate any performance gains if you do things like load huge
    JavaScript files, don’t split your code, or go against other best practices.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在一个已经由 React-DOM 在服务器上创建了标记的节点上调用 `ReactDOM.hydrate()`，React 将保留现有的 HTML
    并比其他情况下做更少的工作。这通常意味着在初始启动时 React 需要做的工怍会更少（这取决于你发送的数据量以及服务器负载、网络、天气等因素）。我不会再次提及这一点，但请记住，SSR
    并非魔法，如果你像加载大型的 JavaScript 文件、不拆分代码或违反其他最佳实践这样的行为，你很容易就会抵消任何性能提升。
- en: 'Till now, you haven’t touched any server files. Aside from the limited scope
    of this chapter, server programming is generally outside the scope of this book,
    so we won’t cover much about the node.js runtime or web server programming paradigms.
    If you’re curious to learn more about node and server-side programming, check
    out *Node.js in Action*, 2nd Edition by Alex Young, et al. (Manning Publications,
    2017): [www.manning.com/books/node-js-in-action](http://www.manning.com/books/node-js-in-action).'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你还没有接触过任何服务器文件。除了本章的有限范围，服务器编程通常不在此书的范围之内，所以我们不会过多地介绍 node.js 运行时或网络服务器编程范式。如果你对
    Node 和服务器端编程感兴趣，可以查看 Alex Young 等人所著的 *Node.js in Action* 第二版（Manning Publications，2017）：[www.manning.com/books/node-js-in-action](http://www.manning.com/books/node-js-in-action)。
- en: You’re going to start building SSR by focusing on the server changes you need
    to make. [Listing 12.3](kindle_split_024_split_004.xhtml#ch12ex03) shows the state
    of the main app server code as it is before you do anything to get it to work
    with React. I’ve included all of it so you can get a sense of what it’s doing.
    Most of the code is boilerplate middleware that a simple Express application might
    use, but most of it isn’t directly related to SSR. [Figure 12.3](kindle_split_024_split_004.xhtml#ch12fig03)
    puts the code in [listing 12.3](kindle_split_024_split_004.xhtml#ch12ex03) into
    context of the rendering approaches we’ve discussed so far in this chapter.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 你将通过关注需要进行的服务器更改来开始构建SSR。[列表12.3](kindle_split_024_split_004.xhtml#ch12ex03)显示了在您对它进行任何操作以使其与React一起工作之前，主应用服务器代码的状态。我包括了所有内容，以便您可以了解它在做什么。大部分代码是简单的Express应用程序可能使用的样板中间件，但其中大部分与SSR没有直接关系。[图12.3](kindle_split_024_split_004.xhtml#ch12fig03)将[列表12.3](kindle_split_024_split_004.xhtml#ch12ex03)中的代码置于本章中我们讨论过的渲染方法背景中。
- en: Figure 12.3\. As of [listing 12.3](kindle_split_024_split_004.xhtml#ch12ex03),
    this is the basics of what the server code is doing. It sets up your server, adds
    some boilerplate middleware, and then serves a stripped-down HTML file that in
    turn downloads your app.
  id: totrans-585
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图12.3\. 截至[列表12.3](kindle_split_024_split_004.xhtml#ch12ex03)，这是服务器代码的基本功能。它设置了您的服务器，添加了一些样板中间件，然后提供了一个简化版的HTML文件，该文件反过来下载您的应用。
- en: '![](Images/12fig03_alt.jpg)'
  id: totrans-586
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/12fig03_alt.jpg)'
- en: '[Listing 12.3](kindle_split_024_split_004.xhtml#ch12ex03) shows the (basic)
    server setup for your app. When you put it into the context of the SSR approaches
    we’ve been looking at in this chapter, it matches with the client-focused paradigm.
    In this sort of approach, the server will usually only send down an HTML file
    that has no pre-rendered content in it. Your build tools are currently taking
    care of generating and serving the HTML file. That file contains references to
    scripts that will download and execute to do the work of rendering and managing
    the application, but no rendering is done on the server (yet!).'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表12.3](kindle_split_024_split_004.xhtml#ch12ex03)显示了您的应用（基本）服务器设置。当您将其置于本章中我们一直在查看的SSR方法背景中时，它与以客户端为中心的范例相匹配。在这种方法中，服务器通常会仅发送一个不包含预渲染内容的HTML文件。您的构建工具目前正在处理生成和提供HTML文件。该文件包含对将下载并执行以进行渲染和管理应用程序的脚本的引用，但在服务器上（尚未！）没有进行渲染。'
- en: Listing 12.3\. Starting out on the server (server/server.js)
  id: totrans-588
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表12.3\. 从服务器开始（server/server.js）
- en: '[PRE41]'
  id: totrans-589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '***1* Using ES modules syntax, available in node 8.5 and higher via ESM**'
  id: totrans-590
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 使用ES模块语法，在node 8.5及以上版本中可用通过ESM**'
- en: '***2* Setting up middleware that will apply to all incoming requests; handles
    logging, some basic security protections, parsing of incoming requests.**'
  id: totrans-591
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 设置将应用于所有传入请求的中间件；处理日志记录、一些基本的安全保护、解析传入请求。**'
- en: '***3* Respond to requests, where you’ll integrate with React DOM**'
  id: totrans-592
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 响应请求，您将集成React DOM**'
- en: '***4* Error-handling code that will catch forwarded errors from other routes
    and send to the client**'
  id: totrans-593
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 错误处理代码，用于捕获来自其他路由的转发错误并发送给客户端**'
- en: The first step you want to take is to bring in React-DOM and try rendering a
    simple component. You’ll render a simple `div` first with some text inside it
    before you move on to integrating your app. You’ll use `React.createElement` for
    this small example so you don’t have to deal with transpiling your server file,
    but you’ll be able to use JSX in other files later when you pull your components
    in to be used. That’s because you’ll use `babel-register`, a Babel library for
    development that transpiles your code on-the-fly. You can see us pulling in `babel-register`
    in index.js. In a production environment you wouldn’t do that. Instead, you’d
    be using something like Webpack and Babel to compile your code into a bundle.
    I can’t cover tooling in-depth here, but you can learn more at [https://webpack.js.org](https://webpack.js.org)
    and [https://babeljs.io](https://babeljs.io).
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 您想要采取的第一步是引入React-DOM并尝试渲染一个简单的组件。在您开始集成您的应用之前，您将首先渲染一个包含一些文本的简单`div`。您将使用`React.createElement`进行这个小示例，这样您就不必处理服务器文件的转译，但您可以在稍后拉入组件以供使用时在其他文件中使用JSX。这是因为您将使用`babel-register`，这是一个用于开发的Babel库，它即时转译您的代码。您可以在index.js中看到我们正在引入`babel-register`。在生产环境中，您不会这样做。相反，您将使用类似Webpack和Babel的工具将您的代码编译成一个包。在这里，我无法深入介绍工具，但您可以在[https://webpack.js.org](https://webpack.js.org)和[https://babeljs.io](https://babeljs.io)了解更多信息。
- en: For this first pass, all you’ll do is insert a simple message as the child content
    of a `div` and send it to the client. Once you have that in place, you’ll run
    the server and check to see what you get back. [Figure 12.4](kindle_split_024_split_004.xhtml#ch12fig04)
    shows what the code in [listing 12.4](kindle_split_024_split_004.xhtml#ch12ex04)
    does.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 在这次第一次遍历中，你只需插入一条简单的消息作为`div`的子内容，并将其发送到客户端。一旦你设置了这一切，你将运行服务器并检查你得到什么反馈。[图12.4](kindle_split_024_split_004.xhtml#ch12fig04)显示了[列表12.4](kindle_split_024_split_004.xhtml#ch12ex04)中的代码做了什么。
- en: Listing 12.4\. Trying out server-side rendering
  id: totrans-596
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表12.4\. 尝试服务器端渲染
- en: '[PRE42]'
  id: totrans-597
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '***1* Within request handler, create HTML string and send it down**'
  id: totrans-598
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 在请求处理器中，创建HTML字符串并发送下去**'
- en: '***2* Use renderToString and pass in bare-bones React element**'
  id: totrans-599
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 使用`renderToString`并传入裸骨React元素**'
- en: '***3* Create element with type of div and no props**'
  id: totrans-600
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 创建一个没有属性的div类型的元素**'
- en: '***4* Pass in simple string with timestamp as child content**'
  id: totrans-601
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 传入带有时间戳的简单字符串作为子内容**'
- en: '***5* Send response to client**'
  id: totrans-602
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 将响应发送到客户端**'
- en: Figure 12.4\. You’re now using React-DOM to render a simple HTML string and
    send it to the client. In some sense, this is all SSR is (create static markup,
    send it to the client). The complexity I’ve mentioned tends to come from, among
    other things, getting all the data you need to create the text, coordinating the
    process with the client, and then optimization.
  id: totrans-603
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图12.4\. 你现在正在使用React-DOM来渲染一个简单的HTML字符串并将其发送到客户端。从某种意义上说，这就是所有SSR（创建静态标记，发送到客户端）的全部。我提到的复杂性通常来自于，除了其他事情之外，获取创建文本所需的所有数据，与客户端协调过程，然后进行优化。
- en: '![](Images/12fig04_alt.jpg)'
  id: totrans-604
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/12fig04_alt.jpg)'
- en: If you make the change in [listing 12.4](kindle_split_024_split_004.xhtml#ch12ex04),
    run only the server with `node server/run.js` in a terminal, and use another session
    to send a request with cURL, then you should see a response coming back from the
    server. Before, you were sending down the same HTML string every time, and that
    document would load your application scripts after the fact. React would then
    run and render your application into the DOM (creating DOM nodes, assigning event
    listeners, and so on). With this new approach, you can delegate that first render
    to the server and let React take over. [Listing 12.5](kindle_split_024_split_004.xhtml#ch12ex05)
    shows how to run the server and use cURL to inspect responses coming back from
    the server.
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你修改了[列表12.4](kindle_split_024_split_004.xhtml#ch12ex04)，只需在终端中运行`node server/run.js`来仅运行服务器，并使用另一个会话通过cURL发送请求，然后你应该会看到服务器返回的响应。在此之前，你每次都发送相同的HTML字符串，然后该文档会在之后加载你的应用程序脚本。React随后会运行并将你的应用程序渲染到DOM中（创建DOM节点、分配事件监听器等）。使用这种新的方法，你可以将第一次渲染委托给服务器，并让React接管。[列表12.5](kindle_split_024_split_004.xhtml#ch12ex05)显示了如何运行服务器和使用cURL检查从服务器返回的响应。
- en: Listing 12.5\. Inspecting your first server-rendered response
  id: totrans-606
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表12.5\. 检查你的第一个服务器端渲染响应
- en: '[PRE43]'
  id: totrans-607
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '***1* Hit running server with request, inspect what you get back**'
  id: totrans-608
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 向运行中的服务器发送请求，检查你得到什么反馈**'
- en: '***2* You should get headers back in your request, but you care most about
    response body.**'
  id: totrans-609
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 你应该在请求中收到头部信息，但你最关心的是响应体。**'
- en: '***3* Special react-root and react-checksum properties on outermost HTML element**'
  id: totrans-610
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 最外层HTML元素上的特殊`react-root`和`react-checksum`属性**'
- en: With that, you’ve done your first server rendering. You used React to create
    a string representation of a React component and send it to the client. Right
    now, React isn’t being loaded so it can’t pick up from where the server left off,
    but once it’s included it will be able to take over. Try running the same commands
    but opt to use `renderToStaticMarkup` instead and see how the HTTP response from
    your server differs.
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，你已经完成了你的第一次服务器渲染。你使用了React来创建React组件的字符串表示形式并将其发送到客户端。目前，React还没有被加载，所以它不能从服务器停止的地方继续，但一旦它被包含进来，它将能够接管。尝试运行相同的命令，但选择使用`renderToStaticMarkup`而不是它，看看你的服务器HTTP响应如何不同。
- en: 12.5\. Switching to React Router
  id: totrans-612
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.5\. 切换到React Router
- en: The router you built in earlier chapters was optimized for handling routing
    in the browser, but it wasn’t designed with server-side rendering in mind. The
    chance to dig in and see what’s possible with React was a large part of building
    it yourself and not just installing a third-party library, and I hope that it
    gave you the chance to see how components can be used in different ways.
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 你在前面章节中构建的路由器是针对处理浏览器中的路由进行优化的，但它并没有考虑到服务器端渲染。有机会深入了解React的潜力是构建它自己的很大一部分，而不仅仅是安装第三方库，我希望这给了你看到组件可以以不同方式使用的机会。
- en: It may be useful enough for the relatively simple needs of the sample application,
    but your router is lacking in a few areas. It has a pretty bare-bones API, and
    it would be nice if it supported things like routing hooks (transitions between
    routes), middleware (logic that can be applied to multiple routes), and more.
    And as you dig into server-side rendering with React, you’re going to need more
    functionality, like the ability to generate a component tree to render based on
    a request URL. That’s why you’ll switch to using React Router V3.
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 对于相对简单的示例应用需求来说，它可能已经足够有用，但你的路由器在几个方面还不足。它有一个相当基础的 API，如果它能支持诸如路由钩子（路由之间的转换）、中间件（可以应用于多个路由的逻辑）等功能，那就更好了。随着你深入到
    React 的服务器端渲染，你将需要更多的功能，比如根据请求 URL 生成组件树进行渲染的能力。这就是为什么你会转向使用 React Router V3。
- en: React Router ([https://github.com/ReactTraining/react-router](https://github.com/ReactTraining/react-router))
    seems to be the single most-used and most-developed routing solution for React.
    It enjoys a robust following and community of contributors on GitHub and has gone
    through several major revisions.
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: React Router ([https://github.com/ReactTraining/react-router](https://github.com/ReactTraining/react-router))
    似乎是 React 单一最常用且最发达的路由解决方案。它在 GitHub 上拥有强大的追随者和贡献者社区，并且已经经历了多次重大修订。
- en: As of the time of writing, the most recent major version for React Router is
    4\. It’s currently in flux and may have been replaced by a new major version by
    the time you read this. You’ll use version 3 because its API is similar to the
    router that you created, and you should be able to use it with few changes. You’ll
    also use it because it’s a robust technology that has been developed by the React
    open source community. It can do more than your simpler router can and even exceeds
    the needs you have here.
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，React Router 的最新主要版本是 4。它目前处于变动中，在你阅读本文时可能已经被新的主要版本所取代。你会使用版本 3，因为它的
    API 与你创建的路由相似，你应该能够几乎不需要更改就能使用它。你还会使用它，因为它是由 React 开源社区开发的一个健壮的技术。它能够做比你更简单的路由更多的事情，甚至超过了你在这里的需求。
- en: '|  |'
  id: totrans-617
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Choosing third-party libraries vs. building in-house**'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: '**选择第三方库还是内部构建**'
- en: 'Another reason you’re switching over to React Router instead of sticking with
    your homegrown solution is that it’s a more likely candidate for any business
    situations you or your team will be in. You may often opt for an open source solution
    like React Router over writing your own. That’s because, depending on your needs,
    the time required to build and maintain a robust solution to a problem may or
    may not be worthwhile. Navigating the build-or-buy decision can be tricky when
    it comes to external dependencies, too. My two cents here are to keep two things
    in mind: 1) you don’t have to use something because everyone else does, and 2)
    there’s often much more work in building your own solution than just the initial
    work—maintenance is usually the biggest time sink. A large community of open source
    contributors will often catch many bugs before you encounter them yourself.'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 你选择转向 React Router 而不是坚持使用自家的解决方案的另一个原因是，它更可能是你或你的团队将面临任何商业情况下的候选者。你可能会更倾向于选择像
    React Router 这样的开源解决方案，而不是自己编写。这是因为，根据你的需求，构建和维护一个强大解决方案所需的时间可能或可能不值得。在处理外部依赖时，导航构建或购买决策也可能很棘手。我的观点是，记住两点：1)
    你不必因为别人都在使用而使用某物，2) 建立自己的解决方案通常比初始工作要付出更多努力——维护通常是最大的时间消耗。开源贡献者的大社区通常会在你遇到之前捕捉到许多错误。
- en: '|  |'
  id: totrans-620
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'It’s worth noting that React Router is a substantial technology, and we’ll
    only be dipping into its potential here. The project has come to include a wide
    variety of routing features for many situations. The latest major version (4 at
    time of writing) even has solutions for routing with the React Native platform.
    The number of developers using and working on React Router has helped make the
    project incredibly useful, but it also has the drawback of sometimes changing
    substantially between major versions. It’s for this reason, and the similarity
    to the router you built from scratch, that you won’t use the latest version of
    React Router. If you find yourself wanting to use the latest version of React
    Router, I have a post on my blog that covers using React Router v4 with React
    16: [https://ifelse.io/2017/09/07/server-rendering-with-react-router-and-react-16-fiber](https://ifelse.io/2017/09/07/server-rendering-with-react-router-and-react-16-fiber).
    I’ll also note that even though APIs have changed between versions of React Router,
    most of the same concepts apply—you’ll just need to do the work of remapping functionality
    to new APIs when transitioning.'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，React Router 是一项重要的技术，我们在这里只会浅尝辄止。该项目已经包含了针对多种情况的广泛路由功能。在撰写本文时，最新的主要版本（4）甚至为
    React Native 平台提供了路由解决方案。使用并参与 React Router 开发的开发者数量使得该项目极其有用，但这也带来了一个缺点，那就是在主要版本之间有时会有很大的变化。正因为如此，并且与您从头开始构建的路由相似，您不会使用
    React Router 的最新版本。如果您想使用 React Router 的最新版本，我在我的博客上有一篇关于使用 React Router v4 和
    React 16 的文章：[https://ifelse.io/2017/09/07/server-rendering-with-react-router-and-react-16-fiber](https://ifelse.io/2017/09/07/server-rendering-with-react-router-and-react-16-fiber)。我还会指出，尽管
    React Router 的版本之间 API 已经发生变化，但大多数相同的概念仍然适用——您只需在过渡时将功能重新映射到新的 API 上即可。
- en: 12.5.1\. Setting up React router
  id: totrans-622
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 12.5.1\. 设置 React Router
- en: We’ve decided on React Router as a production-ready replacement for your own
    router, so let’s see how to get it set up. The first step is to make sure you
    have React Router installed and swapped out with your current router. Even though
    the technologies are different, the APIs that you’ll use should be similar.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经决定使用 React Router 作为您自建路由的生产级替代品，因此让我们看看如何设置它。第一步是确保您已经安装了 React Router，并将其替换为当前的路由。尽管技术不同，但您将使用的
    API 应该是相似的。
- en: React Router should already be installed with the project dependencies. Now
    you need to start transitioning your project over to React Router and a setup
    that will allow you to do SSR. Start with your current src/index.js file. This
    is an entry-point file where you’ve been setting up the main parts of your app,
    including listening to browser history, rendering your router component, and activating
    your authentication events listener.
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: React Router 应该已经作为项目依赖项安装。现在您需要开始将项目过渡到 React Router 和一个允许您进行 SSR 的设置。从当前的
    src/index.js 文件开始。这是一个入口文件，您在这里设置了应用的主要部分，包括监听浏览器历史记录、渲染路由组件和激活您的身份验证事件监听器。
- en: This won’t work for your SSR setup because so much of the code there depends
    on a browser environment and because you won’t need all the functionality of React
    Router to get the app working. All you really need to keep is your authentication
    listener. Before you add anything in, create a helper tool for later. [Listing
    12.6](kindle_split_024_split_005.xhtml#ch12ex06) shows how to create a simple
    utility to check whether you’re in a browser environment. Some tooling technologies
    like Webpack can help you bundle code that’s environment aware, but for our purposes,
    stick to this simpler approach.
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于您的 SSR 设置是不适用的，因为那里的代码很大一部分依赖于浏览器环境，而且您不需要 React Router 的所有功能来使应用工作。您真正需要保留的是您的身份验证监听器。在添加任何内容之前，创建一个辅助工具以备后用。[列表
    12.6](kindle_split_024_split_005.xhtml#ch12ex06) 展示了如何创建一个简单的实用工具来检查您是否处于浏览器环境中。一些工具技术，如
    Webpack，可以帮助您捆绑出环境的代码，但就我们的目的而言，坚持使用这种方法。
- en: Listing 12.6\. Checking for browser environment (src/utils/environment.js)
  id: totrans-626
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.6\. 检查浏览器环境（src/utils/environment.js）
- en: '[PRE44]'
  id: totrans-627
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Now you can use this helper to determine what environment you’re in and execute
    code conditionally depending on your needs. It doesn’t do exhaustive checks to
    ensure you’re in a browser environment, but it should suffice for your needs.
    Having to account for the environment your code is running in is a pretty common
    aspect of building apps with SSR capabilities or apps that share code between
    client and server (sometimes referred to as *universal* or *isomorphic*). In my
    experience, this can also be a common source of bugs that can be hard to track
    down, especially if you install third-party dependencies that aren’t built with
    environment awareness in mind.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以使用这个助手来确定你处于什么环境，并根据你的需求有条件地执行代码。它不会进行详尽的检查以确保你处于浏览器环境，但应该足以满足你的需求。考虑到你的代码运行的环境是构建具有
    SSR 功能的应用程序或客户端和服务器之间共享代码的应用程序（有时称为 *通用* 或 *同构*）的一个相当常见的方面。在我的经验中，这也可能是难以追踪的常见错误来源，特别是如果你安装了没有考虑环境意识的第三方依赖项。
- en: By now, lots of the existing technology in the React community will usually
    either have support for SSR or indicate where it might cause problems. That wasn’t
    always the case. When using earlier versions of React several years ago, I ran
    into bugs in React itself that made some aspects of certain libraries fail unpredictably.
    Things are much better now, though, and SSR is a consideration not only of the
    React community but also the core team.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，React 社区中现有的许多技术通常要么支持 SSR，要么指出可能引起问题的位置。这并不总是如此。几年前使用 React 的早期版本时，我遇到了
    React 本身的一些错误，导致某些库的某些方面无法预测地失败。不过，现在情况要好得多，SSR 不仅受到 React 社区的关注，也受到核心团队的关注。
- en: Before moving on, you need to make a minor adjustment to one of your reducers
    to take the server environment into account. The user reducer will set a cookie
    on the browser using `js-cookie`. The server doesn’t normally allow you to store
    cookies (although there are libraries that can emulate this behavior, like `tough-cookie`
    ([https://github.com/salesforce/tough-cookie](https://github.com/salesforce/tough-cookie))),
    so you need to use your environment helper to adjust this code. The following
    listing shows the modifications you’ll need to make
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，你需要对你的一个还原器进行微调，以考虑服务器环境。用户还原器将使用 `js-cookie` 在浏览器上设置一个 cookie。服务器通常不允许你存储
    cookie（尽管有一些库可以模拟这种行为，如 `tough-cookie` ([https://github.com/salesforce/tough_cookie](https://github.com/salesforce/tough_cookie)))，因此你需要使用你的环境助手来调整这段代码。以下列表显示了你需要进行的修改
- en: Listing 12.7\. Modifying the user reducer
  id: totrans-631
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.7\. 修改用户还原器
- en: '[PRE45]'
  id: totrans-632
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '***1* Only attempt to use browser cookies if you’re in a browser environment.**'
  id: totrans-633
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 只有在你处于浏览器环境时才尝试使用浏览器 cookie。**'
- en: Back to the task at hand. You need to get React Router set up. Much like your
    router, React Router (version 3) allows you to use a nested hierarchy of <Route/>
    components to indicate which components should be mapped to which URLs. As I’ve
    noted, React Router is an incredibly widely used and battle-tested solution with
    many features that you didn’t add to your own router; you’ll stick to directly
    swapping it in for your own router instead of exploring all it can do.
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 回到手头的任务。你需要设置 React Router。与你的路由器类似，React Router（版本 3）允许你使用嵌套的 <Route/> 组件层次结构来指示哪些组件应该映射到哪些
    URL。正如我之前提到的，React Router 是一个极其广泛使用且经过实战检验的解决方案，它具有许多你没有添加到自己的路由器中的功能；你将坚持直接将其替换为你的路由器，而不是探索它所能做的一切。
- en: Create a new file, src/routes.js, for your routes. You’re breaking your routes
    into their own file because they’ll need to be accessed by your server and your
    client. This is convenient for apps where client code sits alongside server code,
    but you might need to find another way to bring in your routes to your server
    if they’re hosted elsewhere (via npm, a Git submodule, and so on). Your routes
    file should look like the router you created, with a few minor differences. You
    added the ability to specify an index component in the same <Route/> component,
    while React Router exposes a separate component for that purpose. [Figure 12.5](kindle_split_024_split_005.xhtml#ch12fig05)
    shows the high-level role of your routes configuration; it works in the same general
    manner as your router did and serves to map URLs to components or component trees
    (when nesting). [Listing 12.8](kindle_split_024_split_005.xhtml#ch12ex08) shows
    how to integrate React Router into your routing setup.
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的文件，src/routes.js，用于你的路由。你将路由拆分到自己的文件中，因为它们需要被你的服务器和客户端访问。这对于客户端代码与服务器代码并存的
    应用程序来说很方便，但如果你将它们托管在其他地方（通过 npm、Git 子模块等），你可能需要找到另一种方法将你的路由引入到你的服务器中。你的路由文件应该看起来像你创建的路由器，但有几点细微差别。你添加了在同一个
    <Route/> 组件中指定索引组件的能力，而 React Router 提供了一个单独的组件来达到这个目的。[图 12.5](kindle_split_024_split_005.xhtml#ch12fig05)
    展示了你的路由配置的高级角色；它以与你的路由器相同的一般方式工作，并用于将 URL 映射到组件或组件树（当嵌套时）。[列表 12.8](kindle_split_024_split_005.xhtml#ch12ex08)
    展示了如何将 React Router 集成到你的路由设置中。
- en: Figure 12.5\. In the same way as the router you built, the routes configuration
    for React Router maps URLs to components. You can nest components in order to
    share certain parts of the UI across pages or subsections (like a navbar or other
    shared component).
  id: totrans-636
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 12.5。与你自己构建的路由器一样，React Router 的路由配置将 URL 映射到组件。你可以嵌套组件，以便在页面或子部分（如导航栏或其他共享组件）之间共享某些
    UI 部分。
- en: '![](Images/12fig05_alt.jpg)'
  id: totrans-637
  prefs: []
  type: TYPE_IMG
  zh: '![图片 12.5](Images/12fig05_alt.jpg)'
- en: Listing 12.8\. Creating routes for React Router (src/routes.js)
  id: totrans-638
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.8。为 React Router 创建路由（src/routes.js）
- en: '[PRE46]'
  id: totrans-639
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '***1* Use App to wrap the entire app.**'
  id: totrans-640
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**1** 使用 App 来包裹整个应用。'
- en: '***2* Use React Router’s IndexRoute component to make sure you can show components
    at index (/) paths.**'
  id: totrans-641
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**2** 使用 React Router 的 IndexRoute 组件确保你可以在索引 (/) 路径上显示组件。'
- en: '***3* Match components with paths as you did with your own router.**'
  id: totrans-642
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**3** 按照你自己的路由器的方式匹配组件与路径。'
- en: Now that you have some routes set up, you can import them into your main app
    file for use with React Router. The same routes will get used on the client and
    server, which is where part of the *universal* or *isomorphic* aspect of SSR you
    may have heard about comes into play. Reusing code on the client and the server
    can be a big deal, but you probably won’t start to see the more significant benefits
    of it here in such a limited case. The advantage you do gain here is in easily
    exposing your client components to your server in the “normal” React way.
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经设置了一些路由，你可以将它们导入到你的主应用文件中，以便与 React Router 一起使用。相同的路由将在客户端和服务器上使用，这就是你可能听说过的
    SSR 的 *通用* 或 *同构* 方面发挥作用的地方。在客户端和服务器上重用代码可能是一个很大的优势，但你可能不会在这里看到它的更多显著好处，因为这是一个非常有限的案例。你在这里获得的优势是，可以轻松地将你的客户端组件以“正常”的
    React 方式暴露给服务器。
- en: Now import your routes into your server. [Listing 12.9](kindle_split_024_split_005.xhtml#ch12ex09)
    shows how to bring your routes into the server and use them in the rendering process.
    How is your server going to grab the right component(s) to render? Because routing
    is just mapping URLs to actions (HTTP responses, in this case), you need to be
    able to look up the right component that you’ve associated with a path. In your
    own router, you were using a basic URL-regex-matching library to determine whether
    a URL was mapped to a component in your router. It did the work of determining
    which component, if any, should be rendered based on a URL (refer to [figure 12.5](kindle_split_024_split_005.xhtml#ch12fig05)).
    React Router will allow you to do the same thing but on the server. That way,
    you can use the incoming URL from the HTTP request to the server to match the
    component(s) to render into static markup. That’s the key connection point between
    React Router and your goal of doing SSR. React Router uses a URL to render a component
    or component tree like it normally would, but on the server. The next listing
    shows how to set up the initial server portion of your SSR capabilities with React
    Router.
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将您的路由导入到您的服务器中。[列表 12.9](kindle_split_024_split_005.xhtml#ch12ex09) 展示了如何将您的路由引入服务器并在渲染过程中使用它们。您的服务器将如何获取正确的组件（s）进行渲染？因为路由只是将
    URL 映射到操作（在这种情况下是 HTTP 响应），您需要能够查找与路径关联的正确组件。在您自己的路由器中，您使用了一个基本的 URL-regex-matching
    库来确定 URL 是否映射到您的路由器中的组件。它完成了根据 URL 确定哪个组件（如果有的话）应该被渲染的工作（参考[图 12.5](kindle_split_024_split_005.xhtml#ch12fig05)）。React
    Router 将允许您在服务器上做同样的事情。这样，您可以使用来自服务器的 HTTP 请求的传入 URL 来匹配要渲染到静态标记中的组件（s）。这是 React
    Router 和您进行 SSR 目标之间的关键连接点。React Router 使用 URL 来渲染组件或组件树，就像它通常所做的那样，但在服务器上。下一个列表展示了如何使用
    React Router 设置您的 SSR 能力的初始服务器部分。
- en: Listing 12.9\. Using React Router on the server (server/server.js)
  id: totrans-645
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.9\. 在服务器上使用 React Router（server/server.js）
- en: '[PRE47]'
  id: totrans-646
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '***1* Import some utils from React Router, renderToString from React DOM, Redux
    Provider component, your store, and your routes**'
  id: totrans-647
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 从 React Router 导入一些实用工具，renderToString 从 React DOM，Redux Provider 组件，您的
    store 和您的路由**'
- en: '***2* Pass URL to match function as well as routes**'
  id: totrans-648
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将 URL 传递给匹配函数以及路由**'
- en: '***3* Match gives error, redirect (if any), and props; would be used to render
    custom error page or redirect**'
  id: totrans-649
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 匹配会出错，重定向（如果有），并传递 props；将用于渲染自定义错误页面或重定向**'
- en: '***4* Pass in RouterContext component you imported from React Router and wrap
    it in usual Redux Provider component**'
  id: totrans-650
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 将您从 React Router 导入的 RouterContext 组件传递进去，并用常规的 Redux Provider 组件包裹它**'
- en: '***5* Using string template literal to create HTML document with your app HTML
    inserted inside it**'
  id: totrans-651
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 使用字符串模板字面量创建包含您的应用程序 HTML 的 HTML 文档**'
- en: '***6* Set headers on response and send back to browser**'
  id: totrans-652
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 在响应中设置头部并发送回浏览器**'
- en: 12.6\. Handling authenticated routes with React router
  id: totrans-653
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.6\. 使用 React 路由处理受保护的路线
- en: 'Now that you have your server set up, you can clean up the client-side of your
    app a bit. You need to make sure you’re using your new routing setup. You also
    need to move around some of the logic you built related to authentication so you
    can better utilize React Router. To do that, you’ll use a set of features available
    from React Router: hooks. Similar to the way lifecycle methods work for mounting,
    updating, and unmounting components, React Router exposes certain hooks for transitions
    between routes. There are quite a few ways you can use these hooks, including
    the following:'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经设置了服务器，您可以稍微清理一下您的应用程序的客户端部分。您需要确保您正在使用您的新路由设置。您还需要移动一些与身份验证相关的逻辑，以便更好地利用
    React Router。为此，您将使用 React Router 提供的一系列功能：钩子。类似于生命周期方法在组件挂载、更新和卸载时工作的方式，React
    Router 提供了一些钩子用于路由之间的转换。您可以使用这些钩子的多种方式，包括以下内容：
- en: You can trigger data fetching for a page or check if a user is logged in before
    allowing them to finish the URL transition.
  id: totrans-655
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以在允许用户完成 URL 转换之前触发页面数据获取或检查用户是否已登录。
- en: You can handle any cleanup or maybe end an analytics session when a user leaves
    a page—you’re not restricted to entry-related events.
  id: totrans-656
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以在用户离开页面时处理任何清理操作或结束分析会话——您不仅限于与进入相关的事件。
- en: With React Router’s hooks you can even do synchronous *or* asynchronous work,
    so you’re not restricted to either one.
  id: totrans-657
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 React Router 的钩子，您甚至可以进行同步 *或* 异步工作，因此您不受限制于其中之一。
- en: Send pageview events to an analytics platform such as Google Analytics.
  id: totrans-658
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向分析平台（如 Google Analytics）发送页面浏览事件。
- en: '[Figure 12.6](kindle_split_024_split_006.xhtml#ch12fig06) shows the basic flow
    of the hooks you can use in React Router v3\. React Router interacts with the
    History API ([https://developer.mozilla.org/en-US/docs/Web/API/History_API](https://developer.mozilla.org/en-US/docs/Web/API/History_API))
    under the hood, but exposes these hooks to make routing easier in your applications.
    If you’d like to learn about more about the React Router V3 API and explore other
    helpful guides written by the community, check the docs out on GitHub at [https://github.com/ReactTraining/react-router/blob/v3/docs/API.md](https://github.com/ReactTraining/react-router/blob/v3/docs/API.md).'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 12.6](kindle_split_024_split_006.xhtml#ch12fig06) 展示了 React Router v3 中你可以使用的钩子基本流程。React
    Router 在底层与 History API ([https://developer.mozilla.org/en-US/docs/Web/API/History_API](https://developer.mozilla.org/en-US/docs/Web/API/History_API))
    交互，但将这些钩子暴露出来，以便在应用程序中更容易进行路由。如果你想了解更多关于 React Router V3 API 的信息，并探索社区编写的一些其他有用的指南，请查看
    GitHub 上的文档 [https://github.com/ReactTraining/react-router/blob/v3/docs/API.md](https://github.com/ReactTraining/react-router/blob/v3/docs/API.md)。'
- en: Figure 12.6\. React Router exposes a few event handlers on Route components.
    You can use these to hook into the route transitions that occur when a user or
    your code causes a transition. Note that the “redirect” is not an HTTP redirect
    with a 3XX status code.
  id: totrans-660
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 12.6\. React Router 在 Route 组件上暴露了一些事件处理器。你可以使用这些处理器来挂钩到用户或你的代码导致转换时发生的路由转换。请注意，“重定向”不是一个带有
    3XX 状态码的 HTTP 重定向。
- en: '![](Images/12fig06_alt.jpg)'
  id: totrans-661
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/12fig06_alt.jpg)'
- en: You’ll use the `onEnter` hook to check for a logged-in user for certain routes
    and redirect them to the login page if there is no authenticated user. In practice,
    you’d want to think through your application from a security perspective and put
    some serious time into how you prevent a user from transitioning to pages they
    shouldn’t be able to transition to. You’d also need to ensure your security strategy
    extends to your server as well. But for now, Firebase and route hooks should be
    sufficient to protect some of your routes. The next listing shows how you can
    set up the `onEnter` hook for protected pages. You might recognize the authentication
    logic from the last chapter, where you used it in the login action. [Figure 12.6](kindle_split_024_split_006.xhtml#ch12fig06)
    shows how this process works.
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 你将使用 `onEnter` 钩子来检查某些路由的登录用户，并在没有认证用户的情况下将他们重定向到登录页面。在实践中，你希望从安全的角度思考你的应用程序，并投入大量时间来防止用户转换到他们不应能够转换到的页面。你还需要确保你的安全策略也扩展到你的服务器。但就目前而言，Firebase
    和路由钩子应该足以保护一些你的路由。下一个列表显示了如何为受保护页面设置 `onEnter` 钩子。你可能从上一章中认出了认证逻辑，其中你在登录操作中使用它。[图
    12.6](kindle_split_024_split_006.xhtml#ch12fig06) 展示了此过程的工作方式。
- en: Listing 12.10\. Setting up an `onEnter` hook (src/routes.js)
  id: totrans-663
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.10\. 设置 `onEnter` 钩子（src/routes.js）
- en: '[PRE48]'
  id: totrans-664
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '***1* Import Firebase and isServer utilities.**'
  id: totrans-665
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 导入 Firebase 和 isServer 实用工具。**'
- en: '***2* React Router hooks take three arguments: nextState, a replace function,
    and a callback.**'
  id: totrans-666
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* React Router 钩子需要三个参数：nextState、一个替换函数和一个回调函数。**'
- en: '***3* If you’re on server, proceed**'
  id: totrans-667
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 如果你处于服务器，继续**'
- en: '***4* You need to know if you’re on login page so you don’t infinitely redirect**'
  id: totrans-668
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 你需要知道你是否在登录页面，这样你才不会无限重定向**'
- en: '***5* Use Firebase utility functions included in sample repository to get Firebase
    user and token**'
  id: totrans-669
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 使用样本仓库中包含的 Firebase 实用函数来获取 Firebase 用户和令牌**'
- en: '***6* If no token or user and you’re not on login page, redirect user**'
  id: totrans-670
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 如果没有令牌或用户且不在登录页面，重定向用户**'
- en: '***7* If no user but they’re on login page, allow them to proceed**'
  id: totrans-671
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 如果没有用户但他们在登录页面，允许他们继续**'
- en: '***8* If error, callback with it**'
  id: totrans-672
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8* 如果出错，则使用回调函数返回它**'
- en: '***9* Add hook to appropriate components using prop**'
  id: totrans-673
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***9* 使用属性将钩子添加到适当的组件中**'
- en: The final bit of setup you need to do before moving on is to clean up the main
    app file and replace your link components. The following listing shows the stripped-down
    version of the main client-side file.
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，你需要做的最后一点设置是清理主应用文件并替换你的链接组件。以下列表显示了简化后的主客户端文件版本。
- en: Listing 12.11\. Cleaning up your app index (src/index.js)
  id: totrans-675
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.11\. 清理你的应用索引（src/index.js）
- en: '[PRE49]'
  id: totrans-676
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '***1* Import and use hydrate method from React-DOM so it can work with server-rendered
    markup**'
  id: totrans-677
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 从 React-DOM 中导入和使用 hydrate 方法，以便它可以与服务器端渲染的标记一起工作**'
- en: '***2* Import router and browserHistory**'
  id: totrans-678
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 导入路由和browserHistory**'
- en: '***3* Import your routes.**'
  id: totrans-679
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 导入你的路由。**'
- en: '***4* Wrapping your app in Redux Provider**'
  id: totrans-680
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 将你的应用包裹在 Redux Provider 中**'
- en: '***5* Pass in your routes and browser-History to Router component**'
  id: totrans-681
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 将你的路由和browser-History传递给Router组件**'
- en: You’ve set up React Router using `browserHistory`, but you could have also set
    it up using either a hash-based or in-memory history. These are slightly different
    from your browser history in that they don’t use the same browser History API.
    The hash-based history works by changing a hashed fragment in the URL but not
    changing the user’s browser history. The in-memory history API doesn’t manipulate
    the URL at all and is more suited for things like local development or React Native
    (covered in the next chapter). For more information on the different history implementations
    available, see [https://github.com/ReactTraining/react-router/blob/v3/docs/guides/Histories.md](https://github.com/ReactTraining/react-router/blob/v3/docs/guides/Histories.md).
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经使用`browserHistory`设置了React Router，但你也可以使用基于哈希或内存的历史记录来设置它。这些与你的浏览器历史记录略有不同，因为它们不使用相同的浏览器历史API。基于哈希的历史记录通过改变URL中的哈希片段来实现，但不会改变用户的浏览器历史记录。内存历史记录API完全不操作URL，更适合像本地开发或React
    Native（下一章将介绍）这样的应用。有关不同历史实现的信息，请参阅[https://github.com/ReactTraining/react-router/blob/v3/docs/guides/Histories.md](https://github.com/ReactTraining/react-router/blob/v3/docs/guides/Histories.md)。
- en: 'If you run the app locally, you should be able to see everything getting rendered
    on the server and sent down to the client. React should take over, and things
    should be interactive as you’d expect. You may notice one thing, though: routing
    with links seems to be broken. That’s because you built your own link components
    that integrate with your old router. Fortunately, all you’ll need to do to remedy
    this problem is swap out the history module you’ve been using for the one React
    Router uses. The change-over here should be easy, but it’s also worth pointing
    out that when you choose or build a router it can affect large portions of your
    application. Links, changing between pages, how props are accessed—they can all
    be affected by routing and you should take that into consideration.'
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在本地上运行应用程序，你应该能看到所有内容在服务器上渲染并发送到客户端。React应该接管，一切应该像你预期的那样交互式。不过，你可能注意到一个问题：使用链接的路由似乎出了问题。这是因为你构建了自己的链接组件，这些组件与你的旧路由器集成。幸运的是，要解决这个问题，你只需要将你一直在使用的history模块替换为React
    Router使用的模块。这里的转换应该很简单，但值得注意的是，当你选择或构建一个路由器时，它可能会影响应用程序的很大一部分。链接、页面间的切换、如何访问props——所有这些都可能受到路由的影响，你应该考虑这一点。
- en: The main change you need to make is swapping out the history your links use.
    React Router still uses the browser History API, but you can sync things up with
    your router by using the one React Router provides instead of what you were using
    before. Since you centralized your navigation wrapper, any actions that need to
    route users around should work fine within your new setup. The next listing shows
    the lines you’ll need to change. Aside from that, you shouldn’t have to change
    anything else.
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要做的主要更改是替换链接使用的history。React Router仍然使用浏览器历史API，但你可以通过使用React Router提供的而不是之前使用的来与你的路由器同步。由于你集中了导航包装器，任何需要将用户路由到其他位置的操作都应该在新设置中正常工作。下一个列表显示了你需要更改的行。除此之外，你不需要更改其他任何内容。
- en: Listing 12.12\. Swapping histories out (src/history/history.js)
  id: totrans-685
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表12.12\. 替换历史记录（src/history/history.js）
- en: '[PRE50]'
  id: totrans-686
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '***1* Only lines you’ll need to change; let React Router know about your transitions**'
  id: totrans-687
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 只需更改的行；让React Router知道你的转换**'
- en: 'With those changes in place, you should be rendering on the server using React
    Router! Let’s recap as we wrap up:'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些更改到位后，你应该在服务器上使用React Router进行渲染！让我们在结束前回顾一下：
- en: When a request comes in, you pass the URL of the request to React Router’s `match`
    utility to get the component(s) you want to render.
  id: totrans-689
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当请求到来时，你将请求的URL传递给React Router的`match`实用工具，以获取你想要渲染的组件。
- en: Using the results from `match`, you use React DOM’s `renderToString` method
    to build an HTML response and send it back down to the client.
  id: totrans-690
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`match`的结果，你可以使用React DOM的`renderToString`方法构建一个HTML响应并将其发送回客户端。
- en: If you use cURL or the developer tools to inspect your dev server (running with
    `npm run server:dev)`, you should see the HTML for your components in the response
    (see [figure 12.7](kindle_split_024_split_006.xhtml#ch12fig07)).
  id: totrans-691
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你使用cURL或开发者工具检查你的开发服务器（使用`npm run server:dev`运行），你应该能在响应中看到你的组件的HTML（见[图12.7](kindle_split_024_split_006.xhtml#ch12fig07)）。
- en: Figure 12.7\. Inspecting your server-rendered app. With React-DOM you can create
    the HTML of your app that you can then send down to the client. Notice that because
    you haven’t done any server-side data fetching, you won’t expect to see any dynamic
    data populating your app (like posts).
  id: totrans-692
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图12.7. 检查你的服务器端渲染应用。使用React-DOM，你可以创建你的应用HTML，然后将其发送到客户端。注意，因为你没有进行任何服务器端的数据获取，所以你不会期望看到任何动态数据填充你的应用（如帖子）。
- en: '![](Images/12fig07_alt.jpg)'
  id: totrans-693
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/12fig07_alt.jpg)'
- en: 12.7\. Server rendering with data-fetching
  id: totrans-694
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.7. 使用数据获取的服务器端渲染
- en: You’ve integrated server rendering into your application. This can potentially
    have benefits with regard to app engagement and performance. There’s still room
    to improve, however. You’re not currently doing anything to render the app in
    its full state before sending it down. The payload that you’re sending down is
    the same whether a user is logged in or not. It’s currently up to the browser
    to then do things like start the authentication flow and loading posts. Your server
    rendering is also synchronous because you’re not yet using `renderToNodeStream`.
    In this section, you’ll improve your server rendering to take advantage of this
    API and integrate Firebase on your server so you can do rendering that’s aware
    of authentication state. [Figure 12.8](kindle_split_024_split_007.xhtml#ch12fig08)
    shows an overview of server-rendering with data-fetching integrated.
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经将服务器端渲染集成到你的应用中。这可能在应用参与度和性能方面带来潜在的好处。然而，仍有改进的空间。你目前没有做任何事情来在发送之前渲染应用的全状态。你发送的负载在用户是否登录的情况下都是相同的。目前这取决于浏览器去做诸如启动认证流程和加载帖子之类的事情。你的服务器端渲染也是同步的，因为你还没有使用`renderToNodeStream`。在本节中，你将改进你的服务器端渲染以利用这个API，并在服务器上集成Firebase，这样你就可以进行了解认证状态的渲染。[图12.8](kindle_split_024_split_007.xhtml#ch12fig08)展示了集成数据获取的服务器端渲染的概述。
- en: Figure 12.8\. Server rendering with data fetching. This is similar overall to
    how you’ve been doing rendering, with the main difference being that you’ll need
    to do some data fetching as part of the rendering process. The rendering output
    will change based on whether or not a user is logged in, what that user’s data
    looks like, and when they log in.
  id: totrans-696
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图12.8. 使用数据获取的服务器端渲染。总体上与你的渲染方式相似，主要区别在于你需要在渲染过程中进行一些数据获取。渲染输出将根据用户是否登录、用户的数据看起来如何以及他们何时登录而变化。
- en: '![](Images/12fig08_alt.jpg)'
  id: totrans-697
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/12fig08_alt.jpg)'
- en: Firebase provides a way to interact with their APIs from the server in a similar
    way to how you have from the browser. This will enable you to continue to treat
    Firebase as your database even on the server. In other situations, you might do
    something like make an HTTP call to a microservice or database that would allow
    you to determine if a user exists and if they’re in a currently authenticated
    state. You’ll stick with Firebase because you’re focusing on React, but note that
    this is one place where you might swap in one of these systems under different
    circumstances.
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: Firebase提供了一种从服务器以类似浏览器的方式与他们的API进行交互的方法。这将使你即使在服务器上也能继续将Firebase视为你的数据库。在其他情况下，你可能需要做一些类似的事情，比如向一个微服务或数据库发起HTTP调用，以确定用户是否存在以及他们是否处于当前认证状态。由于你专注于React，你将坚持使用Firebase，但请注意，这是你可能在不同情况下替换这些系统的一个地方。
- en: If you haven’t already created a Firebase account, this is a great time to do
    so. I’ve distributed the application source with the public token for the account,
    but to use the Firebase user admin APIs you need to have a real account (you can
    use it to access user information, something I don’t want people doing). To get
    set up with a Firebase account, head to [https://firebase.google.com](https://firebase.google.com)
    and sign up for an account (you should be able to use an existing Google account).
    From there, create a project named whatever you like.
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有创建Firebase账户，这是一个很好的时机。我已经将应用程序源代码与账户的公共令牌一起分发，但为了使用Firebase用户管理API，你需要有一个真实账户（你可以用它来访问用户信息，这是我不希望人们做的事情）。要设置Firebase账户，请访问[https://firebase.google.com](https://firebase.google.com)并注册一个账户（你应该能够使用现有的Google账户）。从那里，创建一个你喜欢的项目名称。
- en: After that, you’ll need to walk through the Firebase admin SDK setup. This process
    might change over time, so I won’t specify it exactly here. The setup and installation
    instructions can be found at [https://firebase.google.com/docs/admin/setup](https://firebase.google.com/docs/admin/setup)
    and should be relatively straightforward to follow. We’re most interested in the
    User Management API. You shouldn’t need to install anything else in the project
    because the node.js Firebase SDK is already included in your project dependencies.
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，您需要完成Firebase管理SDK的设置。这个过程可能会随时间而变化，所以在这里我不会具体说明。设置和安装说明可以在[https://firebase.google.com/docs/admin/setup](https://firebase.google.com/docs/admin/setup)找到，应该相对容易遵循。我们最感兴趣的是用户管理API。您不需要在项目中安装任何其他东西，因为node.js
    Firebase SDK已经包含在您的项目依赖中。
- en: As a final bit of setup, you’ll need to replace the included Firebase keys in
    the application, since they’re related to the Letters Social project and will
    likely conflict with your own. You can find them in the source code by looking
    in the config directory. Two files, development.json and production.json, contain
    the configuration variables for the development and production environments, respectively.
    Feel free to edit those or other variables as you see fit (maybe you want to customize
    the application yourself and deploy it on a site!). [Figure 12.9](kindle_split_024_split_007.xhtml#ch12fig09)
    shows the Firebase console and the service account page. Generate a new private
    key and move the downloaded file into the main app repository—you’ll use it shortly.
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后的设置步骤，您需要替换应用程序中包含的Firebase密钥，因为它们与Letters Social项目相关，并且可能会与您自己的冲突。您可以在源代码中通过查看config目录找到它们。两个文件，development.json和production.json，分别包含开发和生产环境下的配置变量。请随意编辑这些或其他变量（也许您想自定义应用程序并在网站上部署它！）![图12.9](kindle_split_024_split_007.xhtml#ch12fig09)显示了Firebase控制台和服务账户页面。生成一个新的私有密钥，并将下载的文件移动到主应用程序仓库中——您很快就会用到它。
- en: Figure 12.9\. Create a new Firebase project and generate a new private key.
    This will allow you to authenticate to the Firebase platform and use the SDK to
    manage users on the server.
  id: totrans-702
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图12.9\. 创建一个新的Firebase项目并生成一个新的私有密钥。这将允许您验证到Firebase平台并使用SDK在服务器上管理用户。
- en: '![](Images/12fig09_alt.jpg)'
  id: totrans-703
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/12fig09_alt.jpg)'
- en: You can get back to coding now that you have those logistical bits out of the
    way. You want to authenticate your server application with the Firebase platform
    so you can verify and fetch Firebase users for the purposes of rendering the complete
    application state. You may have already seen the example snippet showing how to
    do this on the Firebase page, but [listing 12.13](kindle_split_024_split_007.xhtml#ch12ex13)
    shows how to configure the Firebase Admin SDK in your server.
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经处理完这些后勤问题，可以回到编码了。您想要通过Firebase平台验证您的服务器应用程序，以便您可以验证和检索用于渲染完整应用程序状态的Firebase用户。您可能已经在Firebase页面上看到了如何做到这一点的示例片段，但[列表12.13](kindle_split_024_split_007.xhtml#ch12ex13)展示了如何在您的服务器上配置Firebase
    Admin SDK。
- en: Listing 12.13\. Integrating Firebase on the server (server/server.js
  id: totrans-705
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表12.13\. 在服务器上集成Firebase (server/server.js)
- en: '[PRE51]'
  id: totrans-706
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '***1* Import Firebase admin SDK**'
  id: totrans-707
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 导入Firebase管理SDK**'
- en: '***2* Set stringified version of JSON file as environment variable; parse it
    so Firebase can work**'
  id: totrans-708
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将JSON文件的字符串化版本设置为环境变量；解析它以便Firebase可以工作**'
- en: '***3* Another way to authenticate with Firebase**'
  id: totrans-709
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 使用Firebase进行验证的另一种方式**'
- en: Now when the server runs it will automatically connect to Firebase and enable
    you to use the Admin SDK to interact with users. That way you can do data fetching
    on the server in a way that knows about the user making the request. Why does
    that matter? You might remember from earlier in the chapter that I said server-side
    routing can be complicated because it can involve synchronizing your client and
    server. You’re not going to do anything terribly complicated, but this is what
    I was referring to. Server-side rendering can quickly become extremely complicated.
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当服务器运行时，它将自动连接到Firebase并允许您使用Admin SDK与用户交互。这样，您就可以在服务器上以了解请求用户的方式执行数据检索。这有什么意义？您可能还记得，在本章早期我说过服务器端路由可能很复杂，因为它可能涉及同步您的客户端和服务器。您不会做任何特别复杂的事情，但这就是我所指的。服务器端渲染可能会迅速变得极其复杂。
- en: 'Fortunately, you won’t be doing anything so daunting. What you’re going to
    do is use Redux in a way you may not have used it before. Because there’s nothing
    about Redux that constrains it to running in the browser, you can use it for state
    management on the server too. Here’s a brief outline of what you’ll do to accomplish
    rendering that allows for data fetching:'
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，你不会做任何如此令人畏惧的事情。你将要做的就是以一种你可能之前没有使用过的方式使用 Redux。因为 Redux 没有任何限制它只能在浏览器中运行的特性，所以你也可以在服务器上用它进行状态管理。以下是你将要做的事情的简要概述，以实现允许数据获取的渲染：
- en: Get the user’s token from a cookie you stored in earlier chapters.
  id: totrans-712
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从之前章节中存储的 cookie 中获取用户的令牌。
- en: Verify the token with Firebase and fetch the user if they exist.
  id: totrans-713
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Firebase 验证令牌，如果存在则获取用户。
- en: If they don’t have a valid token (maybe it expired), clear the cookie and send
    them to the login page.
  id: totrans-714
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果他们没有有效的令牌（可能已过期），清除 cookie 并将他们发送到登录页面。
- en: If they’re a valid user, fetch their information from your server and dispatch
    actions to the store.
  id: totrans-715
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果他们是有效用户，从你的服务器获取他们的信息并向存储库发送动作。
- en: Render the appropriate route component based on the state of the store.
  id: totrans-716
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据存储的状态渲染适当的路由组件。
- en: '`JSON.stringify` the current store state and embed it in the HTML that you
    need to send down to the browser.'
  id: totrans-717
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `JSON.stringify` 将当前存储状态序列化，并将其嵌入你需要发送到浏览器的 HTML 中。
- en: If that sounds complicated, don’t fret. You’re adding a minor step to the same
    flow of server rendering you were doing before. Instead of rendering the same
    content every time, you’re fetching data from Firebase and using that information
    to do rendering. Remember, the benefit here is that you can “fully” render the
    application so the user can immediately see content.
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这听起来很复杂，不要担心。你只是在之前做的服务器渲染流程中添加了一个小步骤。你不再每次都渲染相同的内容，而是从 Firebase 获取数据，并使用这些信息进行渲染。记住，这里的优势是你可以“完全”渲染应用程序，这样用户就可以立即看到内容。
- en: Your use of Redux on the server is a great example of “universal” JavaScript
    in action. If Redux depended heavily on browser APIs, it might be difficult or
    impossible to integrate it on the server, and you’d have to take a different approach
    altogether. As it is, though, you can re-create a store on demand, update it based
    on responses from your APIs and Firebase, and then use the store to render your
    application just as you would in the browser. [Figure 12.10](kindle_split_024_split_007.xhtml#ch12fig10)
    shows this process in the context of server rendering that we’ve been looking
    at for this chapter.
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 你在服务器上使用 Redux 是“通用”JavaScript 付诸实践的绝佳例子。如果 Redux 严重依赖于浏览器 API，那么在服务器上集成它可能很困难或不可能，你可能需要采取完全不同的方法。然而，现在，你可以按需重新创建一个存储库，根据你的
    API 和 Firebase 的响应来更新它，然后就像在浏览器中一样使用存储库来渲染你的应用程序。[图 12.10](kindle_split_024_split_007.xhtml#ch12fig10)
    展示了在本章中我们一直在研究的服务器渲染的上下文中的此过程。
- en: Figure 12.10\. Server rendering with data fetching as part of the render process
  id: totrans-720
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 12.10\. 作为渲染过程一部分的数据获取的服务器渲染
- en: '![](Images/12fig10_alt.jpg)'
  id: totrans-721
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/12fig10_alt.jpg)'
- en: In this flow, you use a cookie coming from the browser to verify that the user’s
    token is valid. Then you get the user from Firebase and dispatch actions to a
    Redux store created server-side. You still render to static HTML, but this time
    you render using updated state so the app can be rendered with new data. You also
    embed the state in the HTML response so the browser can pick up where the server
    left off. One thing to watch out for when doing this is your Redux store not being
    recreated or persisting in memory on the server. I’ve worked on projects where
    this was briefly happening during local development, and it was hard to track
    down. Aside from being annoying, it meant that the server would render the same
    user data for everyone making requests because the store’s state hadn’t been wiped.
    That would’ve been an unacceptable security breach in a production environment.
    I mention this to help drive home the reality that coordinating browser and client
    can be complex and must be done carefully to avoid tricky bugs or security holes.
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个流程中，您使用来自浏览器的 cookie 来验证用户的令牌是否有效。然后您从 Firebase 获取用户，并将动作分发到在服务器端创建的 Redux
    存储。您仍然渲染为静态 HTML，但这次您使用更新的状态进行渲染，以便应用程序可以使用新数据渲染。您还将状态嵌入到 HTML 响应中，以便浏览器可以从服务器停止的地方继续。在执行此操作时，需要注意的一个问题是您的
    Redux 存储在服务器上没有被重新创建或持久保存在内存中。我在一些项目中遇到过这种情况，在本地开发期间会短暂发生，很难追踪。除了令人烦恼之外，这意味着服务器将为所有请求的用户渲染相同的数据，因为存储的状态没有被清除。在生产环境中，这将是一个不可接受的严重安全漏洞。我提到这一点是为了强调协调浏览器和客户端可能很复杂，并且必须谨慎操作，以避免棘手的错误或安全漏洞。
- en: Let’s take a look at the code you’ll need to do this data fetching and rendering
    process. [Listing 12.14](kindle_split_024_split_007.xhtml#ch12ex14) shows the
    initial steps of fetching data and handling some basic errors that might arise
    from an expired or invalid token. In the next step, you’ll integrate asynchronous
    server rendering with React-DOM’s `renderToNodeStream` and even further improve
    your server rendering.
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看您需要执行数据获取和渲染过程的代码。[列表 12.14](kindle_split_024_split_007.xhtml#ch12ex14)
    展示了获取数据的初始步骤以及可能由过期或无效令牌引起的一些基本错误处理。在下一步中，您将集成异步服务器渲染与 React-DOM 的 `renderToNodeStream`，并进一步提高您的服务器渲染性能。
- en: Listing 12.14\. Fetching data for server rendering (server/server.js)
  id: totrans-724
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.14\. 为服务器渲染获取数据（server/server.js）
- en: '[PRE52]'
  id: totrans-725
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '***1* Create instance of your Redux store**'
  id: totrans-726
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 创建 Redux 存储实例**'
- en: '***2* Get user token off requests’ cookies**'
  id: totrans-727
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 从请求的 cookie 中获取用户令牌**'
- en: '***3* Verify token with Firebase and use response to fetch user from your JSON
    API**'
  id: totrans-728
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 使用 Firebase 验证令牌，并使用响应从您的 JSON API 获取用户**'
- en: '***4* If user exists, unwrap JSON response from API (you’re using isomorphic-fetch
    library and async/await syntax here)**'
  id: totrans-729
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 如果用户存在，从 API 解包 JSON 响应（这里您使用 isomorphic-fetch 库和 async/await 语法）**'
- en: '***5* Thanks to Redux-thunk, you can dispatch your asynchronous action creators
    that you use in login and wait for them to finish before moving on.**'
  id: totrans-730
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 感谢 Redux-thunk，您可以在登录时分发异步动作创建器，并在它们完成之前继续操作。**'
- en: '***6* If there’s an error like token being expired, dispatch error to store**'
  id: totrans-731
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 如果出现错误，例如令牌过期，将错误分发到存储**'
- en: That’s most of the work you’ll need to do fully render the application with
    user context! One downside to this approach is that if you had many pages with
    different data-fetching requirements, it would be difficult to fit those in. You
    don’t have a way of saying, “Ah, we’re requesting page X, page X needs Y data.”
    There are ways to do that, though, and I cover them briefly on my blog at [https://ifelse.io/2017/09/07/server-rendering-with-react-router-and-react-16-fiber](https://ifelse.io/2017/09/07/server-rendering-with-react-router-and-react-16-fiber)
    (if you’re interested in learning more about this and some of the newer React
    Router versions).
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是您需要完成的大部分工作，以使用用户上下文完全渲染应用程序！这种方法的缺点是，如果您有多个页面，每个页面都有不同的数据获取需求，那么将它们整合起来会变得困难。您没有一种方法可以说，“啊，我们正在请求页面
    X，页面 X 需要 Y 数据。”尽管如此，还是有方法可以做到这一点，我在我的博客上简要介绍了这些方法，请访问 [https://ifelse.io/2017/09/07/server-rendering-with-react-router-and-react-16-fiber](https://ifelse.io/2017/09/07/server-rendering-with-react-router-and-react-16-fiber)（如果您想了解更多关于这一点以及一些较新的
    React Router 版本的信息）。
- en: To finish your rendering improvements, you’ll need to do a few more things.
    First, you’ll need to find a way to inject the HTML string that React-DOM will
    give back to us. Because it works with streams, your string template approach
    from before will need to change. Instead of directly injecting the resulting HTML,
    you’ll use two functions to write down HTML for your app. One will contain the
    header information that your app will need (metadata about the app, Open Graph
    data, CSS links, and so on). The other will embed the Redux store state in the
    HTML response. You want to embed the state so that when the browser takes over
    it doesn’t redo any of the work the server already did. You want to do less rendering,
    not more! The next listing shows the HTML wrapper component that you’ll pass your
    component and Redux store state into.
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成您的渲染改进，您还需要做几件事。首先，您需要找到一种方法来注入 React-DOM 将返回给我们的 HTML 字符串。因为它与流一起工作，所以您之前使用的字符串模板方法需要改变。您不会直接注入生成的
    HTML，而是使用两个函数来为您的应用程序编写 HTML。一个将包含您的应用程序需要的标题信息（关于应用程序的元数据、Open Graph 数据、CSS 链接等）。另一个将
    Redux 商店状态嵌入到 HTML 响应中。您希望嵌入状态，这样当浏览器接管时，它不会重做服务器已经完成的工作。您希望减少渲染，而不是增加！下一个列表显示了您将传递组件和
    Redux 商店状态的 HTML 包装组件。
- en: Listing 12.15\. Embedding Redux state
  id: totrans-734
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.15\. 嵌入 Redux 状态
- en: '[PRE53]'
  id: totrans-735
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '***1* Basic metadata about the app—some boilerplate code is omitted as not
    relevant to current discussion**'
  id: totrans-736
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 关于应用程序的基本元数据——一些与当前讨论不相关的样板代码被省略**'
- en: '***2* Inject your app into main div so when React-DOM takes over on browser,
    it won’t have to redo work server did**'
  id: totrans-737
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将您的应用程序注入到主 div 中，这样当 React-DOM 在浏览器中接管时，它就不需要重做服务器已经完成的工作**'
- en: '***3* Redux store in browser should be able to take over where server left
    off, so embed store in JSON-stringified format;**'
  id: totrans-738
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 浏览器中的 Redux 商店应该能够从服务器停止的地方接管，因此以 JSON-stringified 格式嵌入商店；**'
- en: 'With that, you need to modify the Redux store so it can take over. In this
    listing, you’ll do two main things: make sure the Redux store is created from
    scratch every time on the server (to prevent the potential bugs mentioned earlier)
    and teach it to read the initial state from the DOM. The following listing shows
    these minor modifications that you’ll make to your production store (the development
    version isn’t being rendered by the server, so there’s no initial state to pick
    up).'
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，您需要修改 Redux 商店，以便它能够接管。在这个列表中，您将做两件事：确保每次在服务器上创建 Redux 商店都是从头开始的（以防止前面提到的潜在错误），并教会它从
    DOM 中读取初始状态。以下列表显示了您将对您的生产商店（开发版本不会被服务器渲染，因此没有初始状态可拾取）进行的这些小修改。
- en: Listing 12.16\. Modifying the Redux store for SSR (src/store/configureStore.prod.js)
  id: totrans-740
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 12.16\. 修改用于 SSR 的 Redux 商店（src/store/configureStore.prod.js）
- en: '[PRE54]'
  id: totrans-741
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '***1* If you’re on server, you want to return new store every time**'
  id: totrans-742
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 如果您在服务器上，您希望每次都返回新的商店**'
- en: '***2* If you’re not on server and app is in production mode, check DOM for
    state and use if possible**'
  id: totrans-743
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 如果您不在服务器上且应用程序处于生产模式，检查 DOM 以获取状态并尽可能使用**'
- en: Now your store will be able to read initial state from data embedded by your
    server and won’t have to do double work. What’s left? You may remember from the
    beginning of the chapter that you had asynchronous options available to use when
    rendering on the server. You’re currently using the `renderToString` method from
    React-DOM, but it’s synchronous, and that could be a bottleneck for your server
    if many users visit the app at once. In React 16, an asynchronous option for server
    rendering was introduced, and you’ll use it here. The usage is identical except
    node.js streams can be used instead of the synchronous method.
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您的商店将能够从您的服务器嵌入的数据中读取初始状态，而无需做重复工作。接下来是什么？您可能还记得章节开头提到的，当在服务器上渲染时，您有异步选项可供使用。您目前使用的是
    React-DOM 的 `renderToString` 方法，但它是同步的，如果许多用户同时访问应用程序，这可能会成为您服务器的瓶颈。在 React 16
    中，引入了服务器渲染的异步选项，您将在这里使用它。使用方式相同，只是可以使用 node.js 流代替同步方法。
- en: '|  |'
  id: totrans-745
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Open source libraries**'
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: '**开源库**'
- en: 'You’ve done some work to integrate server-side rendering into the Letters Social
    application. You got it working with Redux, but scaling to a very large application
    or introducing new data-fetching requirements (data for other pages, for example)
    might require some refactoring and reconsidering how you approach server rendering.
    There are open source libraries for doing server rendering with React that help
    address issues of uniformly allowing components to be rendered on the server.
    As an exercise in improving your understanding of what’s possible with server
    rendering with React, take some time to look at them and their source code. You’ll
    probably be pleasantly surprised at what you can accomplish with server rendering
    (optimized rendering, in the case of react-server [https://github.com/redfin/react-server](https://github.com/redfin/react-server))
    and how much easier an abstraction can make implementing server rendering (in
    the case of Next.js: [https://github.com/zeit/next.js/](https://github.com/zeit/next.js/)).'
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经将服务器端渲染集成到Letters Social应用中。你使用Redux使其工作，但要将应用扩展到非常大的规模或引入新的数据获取需求（例如其他页面的数据）可能需要一些重构和重新考虑你的服务器端渲染方法。有一些开源库可以帮助使用React进行服务器端渲染，这些库有助于统一允许组件在服务器上渲染。作为一个提高你对React服务器端渲染可能性的理解的练习，花些时间查看它们及其源代码。你可能会对服务器端渲染（在react-server
    [https://github.com/redfin/react-server](https://github.com/redfin/react-server)的情况下是优化渲染）所能实现的事情感到惊喜，以及抽象化如何使实现服务器端渲染变得更加容易（在Next.js的情况下：[https://github.com/zeit/next.js/](https://github.com/zeit/next.js/)）。
- en: '|  |'
  id: totrans-748
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: You may be familiar with streams if you’ve worked with node.js before. If not,
    that’s fine. Streams in node.js are an abstract interface for working with streaming
    data. That can include things like reading or writing a file, transforming and
    compressing images, or working with HTTP requests and responses. You can learn
    more about streams in node.js at [https://nodejs.org/api/stream.html](https://nodejs.org/api/stream.html).
    The next listing illustrates taking advantage of the new `renderToNodeStream`
    API in React-DOM.
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前使用过node.js，你可能熟悉流。如果不熟悉，那也无所谓。node.js中的流是一个用于处理流数据的抽象接口。这可能包括读取或写入文件、转换和压缩图像，或处理HTTP请求和响应等。你可以在[https://nodejs.org/api/stream.html](https://nodejs.org/api/stream.html)了解更多关于node.js中流的信息。下面的列表展示了如何利用React-DOM中的新`renderToNodeStream`
    API。
- en: Listing 12.17\. Async server rendering (server/server.js)
  id: totrans-750
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表12.17. 异步服务器端渲染（server/server.js）
- en: '[PRE55]'
  id: totrans-751
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '***1* Write Content-type header so browser knows what type of content to expect**'
  id: totrans-752
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 写入Content-type头，以便浏览器知道期望的内容类型**'
- en: '***2* Browser should start loading page as quickly as possible, so send first
    part of app down**'
  id: totrans-753
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 浏览器应该尽可能快地开始加载页面，因此发送应用程序的第一部分**'
- en: '***3* Create stream for your app to render**'
  id: totrans-754
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 为你的应用程序创建一个渲染流**'
- en: '***4* Pipe rendered app down to browser but don’t end stream yet**'
  id: totrans-755
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 将渲染的应用程序管道发送到浏览器，但不要结束流**'
- en: '***5* When stream emits end event and rendering is done, send down rest of
    HTML and end response**'
  id: totrans-756
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 当流发出结束事件并且渲染完成后，发送剩余的HTML并结束响应**'
- en: With that, Letters Social is now being fully rendered to users. You can directly
    observe this if you use the developer tools to inspect the document loading process
    and look at what the server sends down ([figure 12.11](kindle_split_024_split_007.xhtml#ch12fig11)
    shows something similar to what you should see). You may be able to see the difference
    in speed if you run the application in production mode, but looking at the development
    tools in Chrome or Firefox will allow you to inspect the app loading on a frame-by-frame
    basis. You’ll be able to see that a full web page is being sent down by the server
    and not just rendered after the application has loaded.
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，Letters Social现在正被完全渲染给用户。如果你使用开发者工具检查文档加载过程并查看服务器发送下来的内容，可以直接观察到这一点（[图12.11](kindle_split_024_split_007.xhtml#ch12fig11)显示了你应该看到的内容）。如果你在生产模式下运行应用程序，可能会看到速度上的差异，但查看Chrome或Firefox的开发者工具将允许你逐帧检查应用程序的加载。你会发现服务器正在发送完整的网页，而不仅仅是应用程序加载后进行渲染。
- en: Figure 12.11\. If we inspect the performance tab for social.react.sh using the
    Chrome developer tools, you’ll see that the server is sending down fully rendered
    HTML and not waiting till the application bundle has loaded to render the application.
  id: totrans-758
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图12.11. 如果我们使用Chrome开发者工具检查social.react.sh的性能标签，你会看到服务器正在发送完全渲染的HTML，而不是等待应用程序包加载完成后再渲染应用程序。
- en: '![](Images/12fig11_alt.jpg)'
  id: totrans-759
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/12fig11_alt.jpg)'
- en: 12.8\. Summary
  id: totrans-760
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 12.8. 摘要
- en: 'In this chapter, we looked at how you might approach building server-side rendering
    functionality into your app. As we saw, it can involve quite a few aspects of
    your application, including routing, data fetching, and state management (Redux):'
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了如何将服务器端渲染功能构建到你的应用程序中。正如我们所看到的，它可能涉及到你应用程序的许多方面，包括路由、数据获取和状态管理（Redux）：
- en: Server-side rendering (SSR) is generating the static markup for a UI on a server
    that is sent to a client. SSR with React involves using React-DOM to either render
    an HTML string that React can reuse when running on the client-side or static
    markup (`ReactDOM.renderToString()`) that’s meant to remain static on the browser
    (`ReactDOM.renderToStaticMarkUp()`).
  id: totrans-762
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器端渲染（SSR）是在服务器上为 UI 生成静态标记，并将其发送到客户端。使用 React 进行 SSR 涉及使用 React-DOM 来渲染一个
    React 可以在客户端运行时重用的 HTML 字符串，或者静态标记（`ReactDOM.renderToString()`），它旨在在浏览器上保持静态（`ReactDOM.renderToStaticMarkUp()`）。
- en: Not all JS frameworks or libraries are built to handle SSR; React is and can
    “take over” markup that was generated on the server without having to initially
    re-render existing elements on the browser.
  id: totrans-763
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并非所有 JS 框架或库都是为处理 SSR 而构建的；React 是，并且可以“接管”在服务器上生成的标记，而无需最初在浏览器上重新渲染现有元素。
- en: Using a routing solution like React Router can allow you to share routes between
    the client and server, allowing you to share some code across platforms.
  id: totrans-764
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用像 React Router 这样的路由解决方案可以允许你在客户端和服务器之间共享路由，从而让你能够在平台上共享一些代码。
- en: SSR can be complex to implement and only makes sense in certain cases. Some
    situations where it might make sense include when you’re especially concerned
    about SEO, when you have an app whose critical path needs to involve a quick first
    paint, or if you’re using React as a static markup generator.
  id: totrans-765
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SSR 的实现可能很复杂，并且仅在特定情况下才有意义。一些可能合理的情况包括当你特别关注 SEO 时，当你有一个关键路径需要快速首次绘制的应用程序时，或者如果你使用
    React 作为静态标记生成器。
- en: The performance gains SSR can offer are often only realized if the page payload
    sent down by a server is not overly large (so as to not take even longer to load
    than before). A longer response time and more data may obviate the quick first
    paint you would otherwise get.
  id: totrans-766
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SSR 可以提供的性能提升通常只有在服务器发送的页面负载不是过大（这样就不会比之前加载得更慢）的情况下才能实现。更长的响应时间和更多数据可能会抵消你原本期望的快速首次绘制。
- en: SSR requires you to consider which parts of your app will work on the server
    and which won’t. Those features that require a browser environment need to be
    patched to work or should be handled so as not to run on the server.
  id: totrans-767
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SSR 要求你考虑你的应用程序的哪些部分可以在服务器上运行，哪些不行。那些需要浏览器环境的特性需要修补才能工作，或者应该以不运行在服务器上的方式处理。
- en: You can accomplish a “complete” render on the server by doing work to synchronize
    authentication state between client and server and doing any necessary fetching
    of data on the server.
  id: totrans-768
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以通过在服务器上同步客户端和服务器之间的身份验证状态以及执行任何必要的服务器端数据获取来实现服务器上的“完整”渲染。
- en: Although other JS platform implementations exist, SSR practically requires you
    to run a node.js server or at least call out to one to generate your HTML for
    sending to the client.
  id: totrans-769
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管存在其他 JS 平台实现，但 SSR 实际上要求你运行一个 node.js 服务器或至少调用一个服务器来生成发送给客户端的 HTML。
- en: In the next chapter, we’ll take a brief look at React Native and complete your
    journey toward learning the basics of React.
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将简要介绍 React Native 并完成你对 React 基础知识的学习之旅。
- en: Chapter 13\. An introduction to React Native
  id: totrans-771
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 13 章。React Native 简介
- en: '*This chapter covers*'
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: An overview of React Native
  id: totrans-773
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React Native 概述
- en: Differences between React and React Native
  id: totrans-774
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React 和 React Native 之间的区别
- en: Ways to learn more about React Native
  id: totrans-775
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解更多关于 React Native 的方法
- en: At this point, you’ve been over the basics of using React, implemented a router,
    explored Redux, looked at server-side rendering, and even transitioned to using
    React Router. What’s left? There’s still plenty to learn and explore in the React
    ecosystem and community. This chapter takes a high-level look at React Native,
    another project in the React ecosystem developed by Facebook. With React Native,
    you can write React applications that run on mobile platforms like iOS and Android.
    This means you can write applications that run on smartphones and any other platforms
    that React Native targets now or in the future. React Native provides an excellent
    developer experience when building these mobile applications in a React-like way,
    and this is a large part of why it’s becoming increasingly important and popular
    in the React community.
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经掌握了使用React的基础知识，实现了路由器，探索了Redux，研究了服务器端渲染，甚至过渡到了使用React Router。接下来是什么？React生态系统和社区中仍有大量内容可以学习和探索。本章从高层次的角度审视React
    Native，这是Facebook在React生态系统内开发的另一个项目。使用React Native，你可以编写在iOS和Android等移动平台上运行的React应用程序。这意味着你可以编写在智能手机和其他React
    Native现在或未来目标平台上的应用程序。React Native以类似React的方式构建这些移动应用程序时提供了卓越的开发者体验，这也是它为什么在React社区中越来越重要和受欢迎的原因之一。
- en: Because React Native and getting started with mobile development encompass a
    substantially large domain, I’ll keep our discussion of React Native concise and
    focused mainly on higher-level concepts. By the end of the chapter, you should
    have an idea of what React Native is and why you might want to use it, and you’ll
    know how to get started on learning more about it.
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 由于React Native和移动开发入门涵盖了相当大的领域，因此我将保持我们对React Native的讨论简明扼要，主要关注高级概念。到本章结束时，你应该对React
    Native是什么以及为什么你可能想使用它有一个概念，并且你会知道如何开始学习更多关于它的内容。
- en: 13.1\. Introducing React Native
  id: totrans-778
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.1. 介绍React Native
- en: Before React Native came on the scene, you had a few options when it came to
    creating mobile applications. You could either use the iOS and Android platforms
    and languages available to you or you could opt for one of the hybrid approaches
    available. These vary in how they’re implemented, but they would often utilize
    a web view (think “mobile browser”) and expose some interfaces to the native SDKs.
    One downside to this approach is that although you can write native applications
    that allow you to use many familiar web APIs and idioms, the app wasn’t “really
    native,” and there would sometimes be a noticeable difference in performance and
    overall feel. The benefit was that teams or developers without expertise in mobile
    development could transfer their web-related skills and be able to create a mobile
    app.
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: 在React Native出现之前，在创建移动应用程序方面你有几种选择。你可以使用可用的iOS和Android平台和语言，或者你可以选择可用的混合方法之一。这些方法在实现方式上有所不同，但它们通常会使用一个网页视图（想想“移动浏览器”）并向原生SDK公开一些接口。这种方法的缺点是，尽管你可以编写允许你使用许多熟悉的Web
    API和惯用方法的原生应用程序，但应用程序并不是“真正的原生”，有时在性能和整体感觉上会有明显的差异。好处是，没有移动开发专业知识的团队或开发者可以转移他们的Web相关技能，并能够创建一个移动应用程序。
- en: The subject of mobile development and how platforms, languages, and hardware
    in this world all play their different roles is beyond the scope of this book.
    But the choice between hybrid and all-native approaches is relevant to our discussion
    of React Native because React Native offers a new alternative. With React Native,
    you can build apps that are “really native” but you can use a combination of JavaScript
    and platform-specific code (like Swift or Java).
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: 移动开发的主题以及在这个世界中平台、语言和硬件如何扮演各自的不同角色超出了本书的范围。但混合和全原生方法之间的选择与我们对React Native的讨论相关，因为React
    Native提供了一个新的替代方案。使用React Native，你可以构建“真正的原生”应用程序，同时可以使用JavaScript和平台特定代码（如Swift或Java）的组合。
- en: React Native aims to bring the idioms and concepts of building user interfaces
    with React to mobile application development and blend the best aspects of mobile
    and browser development. It encourages code-sharing across platforms (there are
    components that target both iOS and Android devices), allows you to write native
    code where appropriate, and compiles to a native application—all while using many
    of the same idioms familiar to React.
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: React Native旨在将构建用户界面的React惯用和概念带到移动应用程序开发中，并将移动和浏览器开发的最佳方面结合起来。它鼓励跨平台代码共享（存在针对iOS和Android设备的组件），允许你在适当的地方编写原生代码，并编译成原生应用程序——所有这些都在使用许多React熟悉的惯用方法的同时完成。
- en: 'Let’s glance at a few top-level features of React Native:'
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速浏览一下 React Native 的几个顶级特性：
- en: With React Native, you can write JavaScript applications that can also use native
    code (Swift or Java) and compile to native applications that run on iOS or Android.
  id: totrans-783
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 React Native，你可以编写可以同时使用原生代码（Swift 或 Java）并编译为在 iOS 或 Android 上运行的本地应用程序的
    JavaScript 应用程序。
- en: React Native can handle creating the same UI elements on Android and iOS, potentially
    simplifying the development of mobile applications.
  id: totrans-784
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React Native 可以在 Android 和 iOS 上处理创建相同的 UI 元素，这可能会简化移动应用程序的开发。
- en: You can add your own native code when you need to, so you aren’t constrained
    to using only JavaScript.
  id: totrans-785
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你需要时，你可以添加自己的原生代码，这样你就不受限于仅使用 JavaScript。
- en: React Native apps share idioms with React and provide the same component-driven,
    declarative concepts, and even APIs in some cases, to work with when designing
    your UI.
  id: totrans-786
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React Native 应用程序与 React 共享语法，提供相同的以组件驱动、声明式概念，在某些情况下甚至提供相同的 API，以便在设计你的 UI
    时使用。
- en: The developer tooling for building React Native applications allows you to reload
    your application with changes without having to wait for a long compile cycle.
    This often saves developers time and can make for a more pleasant experience.
  id: totrans-787
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建 React Native 应用程序的开发者工具允许你在不需要等待漫长的编译周期的情况下重新加载你的应用程序。这通常可以节省开发者的时间，并使体验更加愉快。
- en: The ability to share code and target multiple platforms can sometimes reduce
    the number of engineers dedicated to building a particular app or project. It
    can lead to fewer codebases to maintain, and engineers can more easily move between
    web and native platforms.
  id: totrans-788
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够共享代码并针对多个平台可以有时减少专门用于构建特定应用程序或项目的工程师数量。它可以导致维护的代码库减少，工程师可以更容易地在 Web 和原生平台之间移动。
- en: You can share logic and other aspects of React web apps with React Native apps,
    such as business logic and even styles in some cases.
  id: totrans-789
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以将 React 网页应用程序的逻辑和其他方面（如业务逻辑和某些情况下的样式）与 React Native 应用程序共享。
- en: How does React Native work? It may seem like a mysterious, black-box process
    for something to take your JavaScript and output a compiled, native application.
    You don’t need to know how every part of React Native works in order to work with
    it, just like you don’t need to know the ins and outs of React-DOM to write great
    React applications. But it’s often helpful to have at least a working understanding
    of the technology you’re using.
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: React Native 是如何工作的？它可能看起来是一个神秘的、黑盒的过程，将你的 JavaScript 转换为编译后的、本地应用程序。你不需要了解
    React Native 的每个部分是如何工作的，才能与之合作，就像你不需要了解 React-DOM 的内部和外部才能编写出色的 React 应用程序一样。但至少对所使用的技术有一个工作理解通常是很有帮助的。
- en: With React Native, you can create applications that are a blend of JavaScript
    and native code. React Native makes this possible by creating a bridge of sorts
    between your application and the underlying mobile platform. Most mobile devices
    can execute JavaScript, and React Native takes advantage of that to run your JavaScript.
    When your JavaScript is executed alongside any native code, React Native’s bridging
    system uses the `React` core library, among others, to translate the component
    hierarchy (with event handlers, state, props, and styles) into a view on the mobile
    device.
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 React Native，你可以创建混合了 JavaScript 和原生代码的应用程序。React Native 通过在应用程序和底层移动平台之间创建某种桥梁来实现这一点。大多数移动设备都可以执行
    JavaScript，React Native 就利用这一点来运行你的 JavaScript。当你的 JavaScript 与任何原生代码一起执行时，React
    Native 的桥接系统使用 `React` 核心库等工具，将组件层次结构（包括事件处理程序、状态、属性和样式）转换为移动设备上的视图。
- en: When updates occur (for example, a user presses a button), React Native translates
    the native event (a press, a shake, a geolocation event, or whatever it is) into
    an event your JavaScript or native code can handle. It also renders the proper
    UI based on changes to state or props. React Native will also bundle all your
    code and do any necessary compilation so you can release your app to the Apple
    App Store or Google Play Store.
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: 当发生更新时（例如，用户按下按钮），React Native 将原生事件（一个点击、一个摇晃、一个地理位置事件，或任何其他事件）转换为你的 JavaScript
    或原生代码可以处理的事件。它还会根据状态或属性的变化渲染适当的 UI。React Native 还会捆绑所有你的代码并执行任何必要的编译，以便你可以将你的应用程序发布到
    Apple App Store 或 Google Play Store。
- en: There’s much more to these processes and to how React Native works, but the
    basic process of translating between the JavaScript running on the device and
    the native platform APIs and events is where the “magic” of React Native happens.
    The result is a platform that you can work with but that also doesn’t compromise
    when it comes to performance. It’s a happy medium between the problems of previous
    hybrid approaches to mobile apps, and it also avoids some of the pain points of
    traditional mobile development. [Figure 13.1](kindle_split_025_split_001.xhtml#ch13fig01)
    illustrates an overall view of how it works.
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: 这些过程以及React Native的工作方式还有很多，但将设备上运行的JavaScript与原生平台API和事件之间进行转换的基本过程是React Native“魔法”发生的地方。结果是您可以与之工作的平台，但在性能方面也不会妥协。它是在之前混合移动应用方法的问题和传统移动开发的一些痛点之间的一个折中方案。[图13.1](kindle_split_025_split_001.xhtml#ch13fig01)展示了它的工作的整体视图。
- en: Figure 13.1\. React Native works by creating a bridge between your JavaScript
    and the underlying native platform. Most native platforms implement a JavaScript
    virtual machine or other way of running JavaScript natively. The bridge enables
    execution of your application’s JavaScript. The React Native bridging system will
    relay messages between the underlying platform and your JavaScript so that native
    events can be translated into ones your React components can understand and respond
    to.
  id: totrans-794
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图13.1\. React Native通过在您的JavaScript和底层原生平台之间创建桥梁来工作。大多数原生平台都实现了JavaScript虚拟机或其他运行JavaScript的本地方式。该桥梁使您的应用程序的JavaScript能够执行。React
    Native桥接系统将在底层平台和您的JavaScript之间传递消息，以便将原生事件转换为React组件可以理解和响应的事件。
- en: '![](Images/13fig01_alt.jpg)'
  id: totrans-795
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/13fig01_alt.jpg)'
- en: If that sounds like a departure from the React you’ve been learning in this
    book, well, it is in many ways. But more important than the differences are the
    similarities. I’ll cover those more in the next section, but you can look at the
    code in [listing 13.1](kindle_split_025_split_001.xhtml#ch13ex01) to see how similar
    a React Native component is to the components you’ve worked with so far.
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这听起来与您在这本书中学到的React有所不同，那么在许多方面确实是这样的。但更重要的是相似之处。我将在下一节中更详细地介绍这些相似之处，但您可以通过查看[列表13.1](kindle_split_025_split_001.xhtml#ch13ex01)中的代码来了解React
    Native组件与您迄今为止所使用的组件是多么相似。
- en: You can still see what the code in [listing 13.1](kindle_split_025_split_001.xhtml#ch13ex01)
    does even though I’m not covering how to set up a React Native project in this
    chapter. Visit [https://repl.it/KOAE/3](https://repl.it/KOAE/3) if you want to
    see what the code is doing and play around with React Native. Repl.it is an online
    platform for running and sharing code in an interactive way, and it has support
    for React Native. You’ll be able to scan a QR code with your phone to view your
    React Native playground app. It’s a great way to experiment with React Native
    without having to do any setup or configuration.
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: 即使我在本章中不介绍如何设置React Native项目，您仍然可以看到[列表13.1](kindle_split_025_split_001.xhtml#ch13ex01)中的代码做了什么。如果您想查看代码执行情况并尝试使用React
    Native，请访问[https://repl.it/KOAE/3](https://repl.it/KOAE/3)。Repl.it是一个在线平台，可以以交互式方式运行和共享代码，并且支持React
    Native。您可以使用手机扫描QR码来查看您的React Native playground应用程序。这是一种无需进行任何设置或配置即可实验React Native的绝佳方式。
- en: One important thing you might notice is that the elements of the component (View,
    Text) are analogous to the `div` and `span` elements in your components from earlier
    chapters. This is an example of the broad React concepts persisting across platforms.
    It doesn’t matter so much what the individual elements of a component are as much
    as that you can reuse and compose them, as shown in this listing.
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会注意到的一个重要事情是，组件的元素（View，Text）与您之前章节中的组件中的`div`和`span`元素类似。这是一个React概念在各个平台之间持续存在的例子。组件的各个元素是什么并不那么重要，重要的是您可以重用和组合它们，如本列表所示。
- en: Listing 13.1\. React Native example component
  id: totrans-799
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表13.1\. React Native示例组件
- en: '[PRE56]'
  id: totrans-800
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '***1* You can still use regular React.Component, even in native app**'
  id: totrans-801
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 您仍然可以使用常规的React.Component，即使在原生应用中**'
- en: '***2* React Native comes with basic ingredients to build mobile applications.**'
  id: totrans-802
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* React Native提供了构建移动应用程序的基本元素。**'
- en: '***3* You can compose components with React Native; view component here is
    like a div in browser (common layout component)**'
  id: totrans-803
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 您可以使用React Native组合组件；这里的视图组件就像浏览器中的div元素（常见布局组件）**'
- en: '***4* Text is more like span in browser**'
  id: totrans-804
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 文本在浏览器中更像是span元素**'
- en: There are other projects like React VR where the focus is even more divergent
    from the web UIs you’ve been working with but that use the same patterns and concepts.
    This is one of the most powerful aspects of the React platform and is especially
    apparent when you see it across platforms. Learn more about React VR at [https://facebook.github.io/react-vr](https://facebook.github.io/react-vr).
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他一些项目，如React VR，其重点甚至更偏离您一直在工作的Web UI，但它们使用相同的模式和概念。这是React平台最强大的方面之一，当您跨平台看到它时尤为明显。更多关于React
    VR的信息请访问[https://facebook.github.io/react-vr](https://facebook.github.io/react-vr)。
- en: 13.2\. React and React Native
  id: totrans-806
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.2\. React和React Native
- en: 'How similar are React and React Native? Beyond sharing a name, they both use
    the `React` core library but target different platforms (browsers and mobile devices).
    This section will briefly look at some of their differences and similarities.
    Let’s compare some of the important aspects of React and React Native:'
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: React和React Native有多相似？除了共享一个名字，它们都使用`React`核心库，但针对不同的平台（浏览器和移动设备）。本节将简要探讨它们的一些差异和相似之处。让我们比较一下React和React
    Native的一些重要方面：
- en: '***Runtime*—** React and React Native target different platforms. React targets
    browsers and thus heavily uses the browser-specific APIs. You can see some of
    the results of this in each API. For example, properties like class, ID, and others
    are commonly seen in web-based React components. Native platforms use different
    layout and styling semantics, so you won’t see many of these properties on React
    Native components. Browser-based and mobile applications also run on different
    types of devices, so things like threading, CPU utilization, and other differences
    in the underlying technology shouldn’t be ignored when thinking about React and
    React Native.'
  id: totrans-808
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***运行时*—** React和React Native针对不同的平台。React针对浏览器，因此大量使用浏览器特定的API。您可以在每个API中看到一些结果。例如，class、ID等属性在基于Web的React组件中很常见。原生平台使用不同的布局和样式语义，因此在React
    Native组件上您不会看到很多这些属性。基于浏览器和移动应用程序也运行在不同的设备上，因此在考虑React和React Native时，不应忽视底层技术（如线程、CPU利用率等）的差异。'
- en: '***Core APIs*—** Many of the React-specific APIs (like those used in component
    lifecycles, state, props, and so on) are similar across React and React Native.
    But each platform implements different APIs for networking, layout, geolocation,
    resource management, persistence, events, and other important areas. React Native
    aims to import some familiar APIs from the browser-oriented world, like the Fetch
    API for networking ([https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API))
    and the Flexbox API for layout ([https://developer.mozilla.org/en-US/docs/Web/CSS/flex](https://developer.mozilla.org/en-US/docs/Web/CSS/flex)).
    React Native also exposes events, but they’re more specific to mobile platforms
    (`onPress,` for instance). These differences can be a minor hurdle, but fortunately
    there are libraries that help to eliminate differences between web and native
    APIs, like `react-primitives` ([https://github.com/lelandrichardson/react-primitives](https://github.com/lelandrichardson/react-primitives)).'
  id: totrans-809
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***核心APIs*—** 许多React特定的API（如用于组件生命周期、状态、属性等）在React和React Native中是相似的。但每个平台在联网、布局、地理位置、资源管理、持久化、事件和其他重要领域实现了不同的API。React
    Native旨在从面向浏览器的世界中导入一些熟悉的API，例如用于联网的Fetch API ([https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API))
    和用于布局的Flexbox API ([https://developer.mozilla.org/en-US/docs/Web/CSS/flex](https://developer.mozilla.org/en-US/docs/Web/CSS/flex))。React
    Native也暴露了事件，但它们更适用于移动平台（例如`onPress`）。这些差异可能是一个小障碍，但幸运的是，有一些库可以帮助消除Web和本地API之间的差异，如`react-primitives`
    ([https://github.com/lelandrichardson/react-primitives](https://github.com/lelandrichardson/react-primitives))。'
- en: '***Components*—** The web-based React project doesn’t have “built-in” components
    (for example, for images, text layout, or other UI elements). You create these
    yourself. React Native, on the other hand, does include components for things
    like text, views, images, and more. These are primitives you need to create UIs
    for mobile applications and are similar to what DOM elements are for browser environments.'
  id: totrans-810
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***组件*—** 基于Web的React项目没有“内置”组件（例如，用于图像、文本布局或其他UI元素）。您需要自己创建这些组件。另一方面，React
    Native确实包括文本、视图、图像等组件。这些是您需要为移动应用程序创建UI的原生元素，类似于浏览器环境中的DOM元素。'
- en: '***Use of `React` core library*—** Both React and React Native use the `React`
    core library for component definition. Each project utilizes a different rendering
    system to wire everything together and interact with the device (browser or mobile).
    React for web uses the `react-dom` library, whereas React Native implements its
    own system. This approach enables you to write components in similar ways across
    platforms.'
  id: totrans-811
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`React`核心库的使用**—**React和React Native都使用`React`核心库进行组件定义。每个项目都利用不同的渲染系统将一切连接起来并与设备（浏览器或移动设备）交互。React
    Web使用`react-dom`库，而React Native实现了自己的系统。这种方法使你能够在不同平台上以类似的方式编写组件。'
- en: '***Lifecycle methods*—** React Native components also have lifecycle methods
    since they inherit from the same `React` base class, and those methods are also
    handled by the platform-specific system (React-DOM or React Native).'
  id: totrans-812
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生命周期方法**—**React Native组件也有生命周期方法，因为它们继承自相同的`React`基类，并且这些方法也由特定于平台的系统（React-DOM或React
    Native）处理。'
- en: '***Event types*—** Whereas React-DOM implements a synthetic event system that
    allows your components to work with browser events in a standard way, mobile applications
    expose other events. One example is gestures. You can pan, zoom, drag, and more
    on touch devices. Components written in React Native components allow you to respond
    to these events.'
  id: totrans-813
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件类型**—**与React-DOM实现了一个合成事件系统，允许你的组件以标准方式与浏览器事件一起工作不同，移动应用程序公开其他事件。一个例子是手势。你可以在触摸设备上平移、缩放、拖动等。用React
    Native组件编写的组件允许你响应这些事件。'
- en: '***Styling*—** Because React Native doesn’t target browsers, you’ll need to
    style your components in slightly different ways. There is no CSS API in regular
    mobile development, but you can use most CSS properties with React Native. React
    Native provides a specific API where 1:1 correspondence between properties isn’t
    possible. Take CSS animations, for example. The CSS specification and the ways
    browsers implement it are different than how iOS and Android enable and implement
    animations, so you’ll need to animate differently and use the right API for each
    platform. Learning new APIs for styling can take time and can prevent directly
    sharing CSS styling across web and native projects. Thankfully, though, there
    are libraries that work with React and React Native, like `styled-components`
    ([www.styled-components.com](http://www.styled-components.com)). With the increasing
    popularity of React Native, you should expect to see more of these cross-platform
    libraries being developed.'
  id: totrans-814
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**样式**—**由于React Native不针对浏览器，你需要以略微不同的方式对组件进行样式设计。常规移动开发中没有CSS API，但你几乎可以使用所有CSS属性与React
    Native一起使用。React Native提供了一个特定的API，其中属性之间没有1:1的对应关系。以CSS动画为例。CSS规范以及浏览器实现它的方式与iOS和Android启用和实现动画的方式不同，因此你需要以不同的方式动画化并使用每个平台正确的API。学习新的样式API可能需要时间，并可能阻止直接在Web和原生项目中共享CSS样式。幸运的是，尽管如此，还有一些与React和React
    Native一起工作的库，如`styled-components`([www.styled-components.com](http://www.styled-components.com))。随着React
    Native的日益流行，你应该期待看到更多这些跨平台库的开发。'
- en: '***Third-party dependencies*—** As with React, you can still use third-party
    component libraries for React Native. Many popular libraries, like `React Router`
    and `styled-components`, even include variants that target React Native (as noted
    earlier). One of the most appealing aspects of React Native is that it can still
    take advantage of the JavaScript module ecosystem.'
  id: totrans-815
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第三方依赖**—**与React一样，你仍然可以使用第三方组件库为React Native开发。许多流行的库，如`React Router`和`styled-components`，甚至包括针对React
    Native的变体（如前所述）。React Native最吸引人的方面之一是它仍然可以利用JavaScript模块生态系统。'
- en: '***Distribution*—** Although you can deploy React applications to almost any
    modern browser, React Native applications require platform-specific distribution
    tooling for both development and final release (Xcode, for example). You’ll usually
    need to use the React Native build process to compile your application for final
    upload. The “walled garden” nature of the iOS and Android tooling is a well-known
    tradeoff to developing mobile applications.'
  id: totrans-816
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分发**—**虽然你可以将React应用程序部署到几乎任何现代浏览器，但React Native应用程序需要特定于平台的分发工具，用于开发和最终发布（例如Xcode）。你通常需要使用React
    Native构建过程来编译你的应用程序以供最终上传。iOS和Android工具的“围栏花园”性质是开发移动应用程序的一个众所周知的权衡。'
- en: '***Development tooling*—** React for web runs in browsers, so you have the
    benefit of any browser-specific tools to help with debugging and development.
    For React Native, you aren’t required to have the platform-specific tooling available,
    but it can still be useful. One key difference between the projects is that React
    Native has a focus on hot reloading that isn’t part of React by default. *Hot
    reloading* can speed up mobile development because you don’t have to wait for
    your app to compile. [Figure 13.2](kindle_split_025_split_002.xhtml#ch13fig02)
    shows an example of some of the developer tools you get access to when working
    with React Native.'
  id: totrans-817
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***开发工具*—** React 用于网页在浏览器中运行，因此你可以利用任何特定浏览器的工具来帮助调试和开发。对于 React Native，你不需要拥有特定平台的工具，但它仍然可能很有用。项目之间的一个关键区别是
    React Native 专注于热重载，而这是 React 默认不包含的。*热重载*可以加快移动开发速度，因为你不需要等待你的应用程序编译。[图 13.2](kindle_split_025_split_002.xhtml#ch13fig02)
    展示了当你与 React Native 一起工作时可以访问的一些开发者工具。'
- en: Figure 13.2\. React Native comes with a number of additional developer tools
    that help with performance, debugging, and other functionality. These tools also
    mean you have less of a strict reliance on tools like Xcode for development, although
    you can certainly still use your platform-specific tools for development. Although
    there are many reasons, the excellent developer experience provided by React Native
    seems to be one reason why it’s been received especially well as a technology.
  id: totrans-818
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 13.2\. React Native 随带一些额外的开发者工具，这些工具有助于性能、调试和其他功能。这些工具还意味着你不太严格依赖于 Xcode
    等工具进行开发，尽管你当然可以使用你平台特定的工具进行开发。尽管有许多原因，但 React Native 提供的优秀开发者体验似乎是其特别受欢迎的技术之一原因。
- en: '![](Images/13fig02.jpg)'
  id: totrans-819
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/13fig02.jpg)'
- en: 13.3\. When to use React Native
  id: totrans-820
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.3\. 何时使用 React Native
- en: 'Not every developer and not every team has a need for React Native. Let’s imagine
    a few scenarios you could find yourself in and see how React Native might or might
    not be something you should consider:'
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: 并非每个开发者和每个团队都需要 React Native。让我们设想一些你可能遇到的场景，看看 React Native 是否是你应该考虑的：
- en: '***Solo developer*—** If you’re learning React for the first time or just using
    it for side projects, you’ll probably learn React Native for fun or if you work
    on any mobile projects. React Native is also something to consider if you aren’t
    deeply experienced with native development but want to ease into it or have a
    more straightforward app. If you already know React, it can make sense to dive
    into using React Native for mobile development with some familiar concepts at
    your disposal.'
  id: totrans-822
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***独立开发者*—** 如果你第一次学习 React 或只是将其用于副项目，你可能会为了乐趣或如果你在处理任何移动项目时学习 React Native。如果你不熟悉原生开发但想逐步进入或拥有更简单的应用程序，React
    Native 也是可以考虑的。如果你已经了解 React，那么利用一些熟悉的概念来使用 React Native 进行移动开发是有意义的。'
- en: '***Small cross-functional team*—** Small startups are often in a position where
    engineers will work on a broad slice of the stack, ranging from server to client
    applications (web, mobile, or otherwise). In situations like this, React Native
    can sometimes present a way for engineers who wear many hats for the organization
    to work on a mobile app without deep mobile experience and have their React momentum
    carry over. This could also apply to large organizations that want to easily move
    engineers between apps or projects.'
  id: totrans-823
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***小型跨职能团队*—** 小型初创公司通常处于工程师将在整个堆栈上工作的位置，从服务器到客户端应用程序（网页、移动或其他）。在这种情况下，React
    Native 有时可以为那些在组织内扮演多个角色的工程师提供一种方式，让他们在没有深入移动经验的情况下开发移动应用程序，并且可以将他们的 React 动力延续到移动应用中。这也适用于希望轻松在不同应用程序或项目之间移动工程师的大型组织。'
- en: '***Team with little to moderate native expertise*—** If you or your team have
    little to moderate expertise with mobile development but are familiar with React
    and JavaScript, React Native may make it easier for you to get your product together
    quickly. There’s no substitute for experience, but not having to go all-in on
    Swift (iOS) or Java (Android) could potentially save you time.'
  id: totrans-824
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***对原生开发经验有限到适中的团队*—** 如果你或你的团队对移动开发只有有限到适中的经验，但熟悉 React 和 JavaScript，React
    Native 可能会更容易让你快速组装产品。经验是无法替代的，但不必完全投入 Swift（iOS）或 Java（Android）可能潜在地节省你时间。'
- en: '***Deep native expertise*—** Some teams will choose React Native not because
    it lowers the barrier to mobile development in some ways, but because it helps
    standardize idioms and patterns across the various implementations of an app for
    a business (mobile and desktop). But if that’s not a problem and you already have
    significant expertise and time invested in mobile development, React Native may
    need closer evaluation to see whether your team would benefit from the available
    abstractions and patterns.'
  id: totrans-825
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***深入原生专业知识*—** 有些团队选择React Native并不是因为它在某些方面降低了移动开发的门槛，而是因为它有助于标准化业务（移动和桌面）应用程序的各种实现中的惯用和模式。但如果这不是问题，并且你已经对移动开发投入了大量的专业知识和时间，React
    Native可能需要更仔细的评估，看看你的团队能否从可用的抽象和模式中受益。'
- en: 'Aside from the team and expertise considerations you might make when thinking
    about React Native, you should also be aware of some of the limitations that are
    inherent to the technology as it exists today:'
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: 除了你在考虑React Native时可能做出的团队和专业知识方面的考虑之外，你还应该意识到一些今天存在的技术的固有局限性：
- en: '***Use of JavaScript*—** If your team or organization doesn’t have any JavaScript-focused
    developers or is already highly experienced with mobile development, it may not
    make sense to transition engineers to a JavaScript and JavaScript-focused ecosystem,
    and that’s okay. Like React for web, React Native is not a silver bullet and should
    be evaluated based on tradeoffs, not the hype around it.'
  id: totrans-827
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***使用JavaScript*—** 如果你的团队或组织没有专注于JavaScript的开发者，或者已经在移动开发方面经验丰富，那么将工程师过渡到JavaScript和以JavaScript为中心的生态系统可能没有意义，这是完全可以接受的。就像Web上的React一样，React
    Native并非万能的银弹，而应该基于权衡来评估，而不是围绕它的炒作。'
- en: '***Specific performance needs*—** React Native is performant, but as an abstraction
    it can present another barrier to achieving specific performance goals that you
    or your team might have. For example, if rendering 3D scenes is the primary goal
    of an application, React Native will probably not be the best fit. Other frameworks
    (like Unity) are probably better suited. This is in keeping with the “React is
    not a silver bullet” idea I just mentioned and that I’ve tried to maintain in
    earlier chapters.'
  id: totrans-828
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***特定的性能需求*—** React Native性能良好，但作为一个抽象层，它可能会成为实现你或你的团队可能有的特定性能目标的另一个障碍。例如，如果渲染3D场景是应用程序的主要目标，React
    Native可能不是最佳选择。其他框架（如Unity）可能更适合。这与我刚才提到的“React不是万能的银弹”的观点一致，并且我在前面的章节中一直试图保持这一观点。'
- en: '***Highly specialized app*—** Some application types aren’t a good fit for
    the React model. Augmented reality (AR), graphics-intensive, or other highly specialized
    applications often require special libraries and skills that most web engineers
    aren’t equipped with. This isn’t to say that it can’t be done, but as of now React
    Native doesn’t focus on addressing these needs.'
  id: totrans-829
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***高度专业化的应用程序*—** 有些应用程序类型不适合React模型。增强现实（AR）、图形密集型或其他高度专业化的应用程序通常需要特殊的库和技能，而大多数Web工程师并不具备这些技能。这并不是说不能做到，但截至目前，React
    Native并没有专注于解决这些需求。'
- en: '***Internal application*—** Sometimes larger companies develop apps for internal
    use that help employees do their job better in a variety of ways. React Native
    can be well suited for these sorts of apps because such apps usually involve a
    relatively simple UI and can be iterated on quickly by engineers who don’t specialize
    in mobile development.'
  id: totrans-830
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***内部应用程序*—** 有时大公司会开发用于内部使用的应用程序，以帮助员工以各种方式更好地完成工作。React Native非常适合这类应用程序，因为这类应用程序通常涉及相对简单的用户界面，并且可以由不专注于移动开发的工程师快速迭代。'
- en: Of course, it’s ultimately up to you and your team to evaluate whether a technology
    makes sense for your use case, but hopefully you now have a better sense of when
    it might or might not make sense to use React Native.
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，最终是否使用这项技术取决于你和你的团队来评估，但希望你现在对何时使用React Native可能或可能不合适有了更好的认识。
- en: 13.4\. The simplest “Hello World”
  id: totrans-832
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.4\. 最简单的“Hello World”
- en: Even though I won’t cover how to integrate React Native with Letters Social,
    this section spends a little time walking through a basic “Hello World” example
    so you can see it in action. You’ll work outside the Letters Social repository,
    so feel free to place the app code wherever you like to keep track of code on
    your computer. Run the commands in the following listing to get started.
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我不会介绍如何将React Native与Letters Social集成，但本节将花一些时间通过一个基本的“Hello World”示例来演示其功能。你将在Letters
    Social存储库之外工作，所以请随意将应用程序代码放在你喜欢的位置以跟踪计算机上的代码。运行以下列表中的命令以开始。
- en: Listing 13.2\. Installing `create-react-native-app`
  id: totrans-834
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 13.2\. 安装 `create-react-native-app`
- en: '[PRE57]'
  id: totrans-835
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: After you’ve run these commands, you should be able to see a number of files
    created in your desired directory and some instructions. These commands are similar
    to those available in Create React App, a similar project focused just on React.js
    for the web platform. You can learn more about Create React App at [https://github.com/facebookincubator/create-react-app](https://github.com/facebookincubator/create-react-app).
    [Figure 13.3](kindle_split_025_split_004.xhtml#ch13fig03) shows what you should
    see when getting started with the Create React Native App library.
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这些命令后，你应该能在你想要的目录中看到创建的多个文件和一些说明。这些命令与 Create React App 中可用的命令类似，这是一个仅关注 Web
    平台的 React.js 的类似项目。你可以在 [https://github.com/facebookincubator/create-react-app](https://github.com/facebookincubator/create-react-app)
    上了解更多关于 Create React App 的信息。[图 13.3](kindle_split_025_split_004.xhtml#ch13fig03)
    展示了当你开始使用 Create React Native App 库时应该看到的内容。
- en: Figure 13.3\. When you start the application in development mode, you should
    see the React Native packager start and see a message like the one shown here.
    Follow the instructions to make sure you have the Expo XDE set up on your local
    machine. Depending on what environment you’d like to target, open either the Android
    or iOS simulator.
  id: totrans-837
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 13.3\. 当你在开发模式下启动应用程序时，你应该会看到 React Native 打包器启动，并看到这里所示的消息。按照说明确保你在本地机器上设置了
    Expo XDE。根据你想要针对的环境，打开 Android 或 iOS 模拟器。
- en: '![](Images/13fig03_alt.jpg)'
  id: totrans-838
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/13fig03_alt.jpg)'
- en: The Create React Native App tool installed dependencies, created some boilerplate
    files, set up a build process, and integrated the Expo React Native toolkit into
    the project. The Expo SDK extends React Native’s functionality and makes working
    with the hardware technologies easier, among other things. The Expo XDE development
    environment makes it easy to manage multiple React Native projects as well as
    build and deploy them.
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: Create React Native App 工具安装了依赖项，创建了一些样板文件，设置了构建过程，并将 Expo React Native 工具包集成到项目中。Expo
    SDK 扩展了 React Native 的功能，使得与硬件技术的工作更加容易，以及其他方面。Expo XDE 开发环境使得管理多个 React Native
    项目以及构建和部署它们变得容易。
- en: You won’t build anything substantial, but you can tinker around and get a sense
    for how easy it might be to start building applications with React Native. Once
    you have the React Native packager running with `yarn start`, open one of the
    emulators (Android or iOS) so you can see the running app. Swap out some of the
    boilerplate code and see the hot reloading happening. [Listing 13.3](kindle_split_025_split_004.xhtml#ch13ex03)
    shows a simple component that fetches some data from the Star Wars API when it’s
    mounted. Notice that React Native is already using modern web APIs like Flexbox
    and Fetch (which you used a polyfill for in earlier chapters).
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: 你不会构建出任何实质性的东西，但你可以尝试修改并感受使用 React Native 开始构建应用程序的容易程度。一旦你使用 `yarn start` 启动了
    React Native 打包器，打开一个模拟器（Android 或 iOS），这样你就可以看到正在运行的应用程序。替换一些样板代码，看看热重载是如何发生的。[列表
    13.3](kindle_split_025_split_004.xhtml#ch13ex03) 展示了一个简单的组件，当它挂载时会从《星球大战》API 获取一些数据。注意，React
    Native 已经使用了现代的 Web API，如 Flexbox 和 Fetch（你之前章节中使用 polyfill 实现）。
- en: Listing 13.3\. Simple React Native example (App.js)
  id: totrans-841
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 13.3\. 简单的 React Native 示例（App.js）
- en: '[PRE58]'
  id: totrans-842
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '***1* Unlike React, React Native comes with primitive components for your UI.**'
  id: totrans-843
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 与 React 不同，React Native 为你的 UI 提供了原始组件。**'
- en: '***2* Constructor, state initialization, and lifecycle methods are the same
    in React and React Native**'
  id: totrans-844
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 构造函数、状态初始化和生命周期方法在 React 和 React Native 中是相同的**'
- en: '***3* You can use modern JavaScript features like async/await in React Native
    apps too.**'
  id: totrans-845
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 你也可以在 React Native 应用中使用现代 JavaScript 特性，如 async/await。**'
- en: '***4* Even though styles appear similar in React Native, you’re not using CSS.**'
  id: totrans-846
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 即使在 React Native 中样式看起来相似，你并没有使用 CSS。**'
- en: '***5* JSX expressions are the same in React Native and React**'
  id: totrans-847
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* JSX 表达式在 React Native 和 React 中是相同的**'
- en: '***6* Creating a stylesheet in React Native requires use of its Stylesheet
    API to style your components.**'
  id: totrans-848
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 在 React Native 中创建样式表需要使用其 Stylesheet API 来样式化你的组件。**'
- en: If you make changes to the app, you should see the packager respond and update
    your running app in real time, as shown in [figure 13.4](kindle_split_025_split_004.xhtml#ch13fig04).
    I hope this gives you a sense of how easy it can be to build applications in React
    Native. You may be used to hot reloading on the web, but for mobile development
    the compile-inspect-recompile cycle can take up a significant amount of time.
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你修改了应用程序，你应该看到打包器实时响应并更新你的运行中的应用程序，如图 13.4 所示 [figure 13.4](kindle_split_025_split_004.xhtml#ch13fig04)。我希望这能让你感受到在
    React Native 中构建应用程序是多么容易。你可能已经习惯了网页上的热重载，但对于移动开发来说，编译-检查-重新编译的周期可能会占用相当多的时间。
- en: Figure 13.4\. You should be able to see changes being instantly reflected in
    the simulator running your application code.
  id: totrans-850
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 13.4\. 你应该能够看到在运行你的应用程序代码的模拟器中即时反映出的变化。
- en: '![](Images/13fig04.jpg)'
  id: totrans-851
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/13fig04.jpg)'
- en: With that, you’ve created your first React Native component and code, which
    should give you a brief glimpse into how the technology works and how easy it
    can be to work with.
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，你已经创建了你的第一个 React Native 组件和代码，这应该让你对这项技术的工作原理以及与之合作的便捷性有一个初步的了解。
- en: 13.5\. Where to go next
  id: totrans-853
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.5\. 接下来去哪里
- en: One of the phrases you’ll see in the React docs, library ecosystem, and community
    is *learn once, write anywhere*. This is an homage of sorts to the *write once,
    run anywhere* phrase that’s popular within the Java community and that is one
    of the hallmarks of the React paradigm. As we’ve seen in this chapter, you can
    learn React concepts and apply them to a variety of platforms, ranging from web
    to mobile to VR. There will be platform-specific differences and nuances whenever
    you learn how to use React on a new platform, but much of your React knowledge
    will easily transfer. That’s one of the reasons why working with React can be
    such a pleasure.
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
  zh: 你在 React 文档、库生态系统和社区中会看到的一个短语是 *一次学习，到处编写*。这某种程度上是对 Java 社区中流行的 *一次编写，到处运行*
    短语的致敬，这也是 React 范式的一个标志。正如我们在本章中看到的，你可以学习 React 概念并将它们应用到从网页到移动到 VR 的各种平台上。无论何时你学习如何在新的平台上使用
    React，都会有一些平台特定的差异和细微差别，但你的大部分 React 知识将很容易迁移。这就是为什么与 React 合作可以如此愉快的原因之一。
- en: There are many resources you can look into if you’d like to keep learning about
    React Native. One is *React Native in Action* by Nader Dabit (Manning Publications,
    2018), shown in [figure 13.5](kindle_split_025_split_005.xhtml#ch13fig05), which
    pairs nicely with this book because it allows you to pick up right where you leave
    off in learning React and is an excellent introduction to React Native. You’ll
    apply your knowledge from your work in this book so far and use the momentum to
    dive into building mobile applications with React Native. It’s also a good resource
    to look into next if your team is considering React Native for an upcoming project.
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要继续学习 React Native，有许多资源你可以查阅。一个是 Nader Dabit 编著的《React Native in Action》（Manning
    Publications，2018），如图 13.5 所示 [figure 13.5](kindle_split_025_split_005.xhtml#ch13fig05)，它与这本书配合得很好，因为它允许你在学习
    React 的过程中无缝继续学习，并且是 React Native 的一个优秀入门。你将应用这本书到目前为止的工作中的知识，并利用这种势头深入构建使用 React
    Native 的移动应用程序。如果你的团队正在考虑为即将到来的项目使用 React Native，这也是一个值得查阅的好资源。
- en: Figure 13.5\. *React Native in Action* by Nader Dabit gives iOS, Android, and
    web developers the skills they need to build robust, complex React Native applications.
    If you’re still curious about React, it’s the perfect book to transition to next.
    Learn more at [www.manning.com/books/react-native-in-action](http://www.manning.com/books/react-native-in-action).
  id: totrans-856
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 13.5\. 《React Native in Action》由 Nader Dabit 编著，为 iOS、Android 和网页开发者提供了构建健壮、复杂
    React Native 应用程序所需的技能。如果你对 React 仍然好奇，这是一本过渡到下一阶段的完美书籍。更多信息请访问 [www.manning.com/books/react-native-in-action](http://www.manning.com/books/react-native-in-action)。
- en: '![](Images/13fig05.jpg)'
  id: totrans-857
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/13fig05.jpg)'
- en: 'Another great resource to get you started with React Native is the Create React
    Native App project. Create React Native App provides an excellent starting place
    for a new React Native project or an excellent sample application for those just
    starting out with it. It includes a few preset libraries and tools for building
    React Native apps, but allows you to “eject” and reset to the default. If you’re
    curious about Create React App or Create React Native App, check them out online:'
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个帮助你开始使用 React Native 的绝佳资源是 Create React Native App 项目。Create React Native
    App 为新的 React Native 项目提供了一个出色的起点，对于那些刚开始使用它的开发者来说，也是一个出色的示例应用程序。它包含了一些预设的库和工具，用于构建
    React Native 应用程序，但允许你“退出”并重置到默认设置。如果你对 Create React App 或 Create React Native
    App 感兴趣，可以在网上查看：
- en: '*Create React Native App*—[https://github.com/react-community/create-react-native-app](https://github.com/react-community/create-react-native-app)'
  id: totrans-859
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建 React Native 应用*—[https://github.com/react-community/create-react-native-app](https://github.com/react-community/create-react-native-app)'
- en: '*Create React App*—[https://github.com/facebook/create-react-app](https://github.com/facebook/create-react-app)'
  id: totrans-860
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建 React App*—[https://github.com/facebook/create-react-app](https://github.com/facebook/create-react-app)'
- en: '*React Native documentation*—[https://facebook.github.io/react-native](https://facebook.github.io/react-native)'
  id: totrans-861
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*React Native 文档*—[https://facebook.github.io/react-native](https://facebook.github.io/react-native)'
- en: 13.6\. Summary
  id: totrans-862
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 13.6. 概述
- en: 'Here’s a recap of what you learned in this chapter:'
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是本章所学内容的总结：
- en: React Native is a technology in the React ecosystem that developers can use
    to write React applications that run on mobile iOS and Android devices.
  id: totrans-864
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React Native 是 React 生态系统中的技术，开发者可以使用它来编写在移动 iOS 和 Android 设备上运行的 React 应用程序。
- en: React Native uses the `React` core library for component creation but uses a
    different set of libraries to handle rendering your application on the native
    platform and to handle interactions with the underlying platform (touch events,
    geolocation, cameras access, and so on).
  id: totrans-865
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React Native 使用 `React` 核心库进行组件创建，但使用不同的库来处理在本地平台上渲染应用程序以及与底层平台（触摸事件、地理位置、相机访问等）的交互。
- en: React Native handles bridging between your JavaScript and the underlying mobile
    platform.
  id: totrans-866
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React Native 处理 JavaScript 和底层移动平台之间的桥接。
- en: React Native uses many APIs that are identical or similar to web APIs. It uses
    Flexbox for layout, Fetch for network requests, and other familiar APIs.
  id: totrans-867
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React Native 使用许多与 Web API 相同或相似的 API。它使用 Flexbox 进行布局，使用 Fetch 进行网络请求，以及其他熟悉的
    API。
- en: You can mix JavaScript and native code when building React Native applications.
  id: totrans-868
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在构建 React Native 应用程序时，你可以混合使用 JavaScript 和原生代码。
- en: React Native provides a robust set of tools for developing and compiling your
    applications.
  id: totrans-869
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React Native 为开发和编译你的应用程序提供了一套强大的工具。
- en: React Native’s hot-reload developer tools save you time by not making you wait
    for your application to recompile every time.
  id: totrans-870
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React Native 的热重载开发者工具通过每次不需要等待应用程序重新编译来节省你的时间。
- en: Using React Native can help lower the barrier to mobile development for you
    or your team.
  id: totrans-871
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 React Native 可以帮助你或你的团队降低移动开发的门槛。
- en: You won’t want to use React Native for absolutely every type of mobile application,
    but it should be sufficient for most typical mobile applications.
  id: totrans-872
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可能不会希望为所有类型的移动应用程序都使用 React Native，但它应该足够用于大多数典型移动应用程序。
- en: '*React Native in Action* by Nader Dabit (Manning, 2018) is a great next resource
    to consider in your React journey—check it out at [www.manning.com/books/react-native-in-action](http://www.manning.com/books/react-native-in-action).'
  id: totrans-873
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Nader Dabit 著的 *React Native in Action*（Manning，2018）是你在 React 之旅中可以考虑的绝佳资源——请访问
    [www.manning.com/books/react-native-in-action](http://www.manning.com/books/react-native-in-action)
    了解详情。
