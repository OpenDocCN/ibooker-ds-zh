- en: 22 Using someone else’s script
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 22 使用他人的脚本
- en: Much as we hope you’ll be able to construct your own PowerShell commands and
    scripts from scratch, we also realize that you’ll rely heavily on the internet
    for examples. Whether you’re repurposing examples from someone’s blog, or tweaking
    a script you’ve found in an online script repository, being able to reuse someone
    else’s PowerShell script is an important core skill. In this chapter, we’ll walk
    you through the process we use to understand someone else’s script and make it
    our own.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们希望你能从头开始构建自己的 PowerShell 命令和脚本，但我们也意识到你将严重依赖互联网上的示例。无论你是从某人的博客中重新利用示例，还是调整你在在线脚本存储库中找到的脚本，能够重用他人的
    PowerShell 脚本是一项重要的核心技能。在本章中，我们将带你了解我们理解他人脚本并将其变为己用的过程。
- en: Thanks Credit goes to Brett Miller, who provided us with the script we use in
    this chapter. We deliberately asked him for a less-than-perfect script that doesn’t
    necessarily reflect all of the best practices we normally like to see. And in
    some instances, we *worsened* this script to make this chapter better reflect
    the real world. We truly appreciate his contribution to this learning exercise!
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 感谢感谢归功于 Brett Miller，他为我们提供了本章中使用的脚本。我们故意要求他提供一个不太完美的脚本，这个脚本不一定反映我们通常喜欢看到的最佳实践。在某些情况下，我们甚至
    *恶化* 了此脚本，以便使本章更好地反映现实世界。我们真正感谢他对这个学习练习的贡献！
- en: 'Note that we’ve also selected these scripts specifically because they use advanced
    PowerShell features that we haven’t taught you. Again, we think that’s realistic:
    you’re going to run across stuff that looks unfamiliar, and part of this exercise
    is about how to quickly figure out what the script is doing, even if you aren’t
    fully trained on every technique the script uses.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们之所以特别选择这些脚本，是因为它们使用了我们尚未教授你的高级 PowerShell 功能。再次强调，我们认为这是现实的：你可能会遇到看起来不熟悉的东西，而这个练习的一部分就是如何快速弄清楚脚本在做什么，即使你对脚本使用的每个技术并不完全训练有素。
- en: 22.1 The script
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 22.1 脚本
- en: This is a true real-world scenario that most of our students have been through.
    They have a problem, go the internet, find a script that does what they need to
    do. It’s important that you understand what is happening. The following listing
    shows the complete script, which is entitled Get-AdExistence.ps1\. This script
    is designed to work with Microsoft’s AD cmdlets. This will only work on a Windows-based
    computer. If you do not have access to a Windows machine with Active Directory
    installed, you can still follow along with us, as we will be going through this
    script piece by piece.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个真实的世界场景，我们的大多数学生都经历过。他们遇到问题，上网，找到一个能完成他们所需工作的脚本。理解正在发生的事情非常重要。以下列表显示了完整的脚本，其标题为
    Get-AdExistence.ps1。此脚本旨在与 Microsoft 的 AD cmdlets 一起工作。这只能在基于 Windows 的计算机上工作。如果你没有访问安装了
    Active Directory 的 Windows 机器，你仍然可以跟随我们，因为我们将逐个分析这个脚本。
- en: Listing 22.1 Get-AdExistence.Ps1
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 22.1 Get-AdExistence.Ps1
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 22.1.1 Parameter block
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 22.1.1 参数块
- en: 'First up is a parameter block, which you learned to create in chapter 19:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 首先是参数块，你已经在第 19 章中学到了如何创建它：
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This parameter block looks a bit different, but it appears to be defining a
    `-Computers` parameter that can accept an array, and it’s mandatory. Fair enough.
    When you run this, you’ll need to provide this information. The next couple of
    lines are more mysterious:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这个参数块看起来有些不同，但它似乎是在定义一个可以接受数组并强制性的 `-Computers` 参数。这是合理的。当你运行它时，你需要提供这些信息。接下来的几行更加神秘：
- en: '[PRE2]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We haven’t gone into process blocks yet, but for now just know this is where
    the meat of the script belongs. We go over this more in detail in the *Learn Scripting
    in a Month of* *Lunches* (Manning, 2017).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有介绍过程块，但现在只需知道这是脚本的主要内容所在。我们将在 *Learn Scripting in a Month of* *Lunches*（Manning，2017）中更详细地介绍这一点。
- en: 22.1.2 Process block
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 22.1.2 过程块
- en: We haven’t covered `Try Catch` yet, but it is coming, don’t worry. For now,
    just know that you will `Try` to do the thing, and if that doesn’t work you will
    `CATCH` the error it throws. Next we see two variables, `$comp` and `$properties`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有介绍 `Try Catch`，但很快就会介绍，不用担心。现在，只需知道你会尝试做某事，如果那不起作用，你将 `CATCH` 到它抛出的错误。接下来我们看到两个变量，`$comp`
    和 `$properties`。
- en: '[PRE3]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`$Comp` is running an Active Directory command to see if the computer exists,
    and if it does, it will store the AD information in the `$comp` variable. `$Properties`
    is a hash table that we have created that stores some information that we need
    that includes the `ComputerName`, `Enabled`, and if it’s in `AD` or not.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`$Comp`正在运行一个Active Directory命令来查看计算机是否存在，如果存在，它将AD信息存储在`$comp`变量中。`$Properties`是我们创建的一个哈希表，它存储了一些我们需要的信息，包括`ComputerName`、`Enabled`以及它是否在`AD`中。'
- en: The remainder of our script takes our hash table that we created and turns that
    into a PS custom object, then writes it to the screen with `Write-Output`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们脚本的其余部分将我们创建的哈希表转换成PS自定义对象，然后使用`Write-Output`将其写入屏幕。
- en: '[PRE4]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Above and beyond
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外
- en: What would we need to change to write this to a text file or a CSV file?
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要更改什么才能将此写入文本文件或CSV文件？
- en: 22.2 It’s a line-by-line examination
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 22.2 这是对每一行的检查
- en: 'The process in the previous section is a line-by-line analysis of the script,
    and that’s the process we suggest you follow. As you progress through each line,
    do the following:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 上一节的过程是对脚本的逐行分析，这是我们建议你遵循的过程。随着你逐行前进，请执行以下操作：
- en: Identify variables, try to figure out what they’ll contain, and write that down
    on a piece of paper. Because variables are often passed to command parameters,
    having a handy reference of what you think each variable contains will help you
    predict what each command will do.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别变量，尝试弄清楚它们将包含什么内容，并将这些内容写在一张纸上。因为变量通常会被传递给命令参数，所以拥有一个关于你认为每个变量包含什么的便捷参考可以帮助你预测每个命令将做什么。
- en: When you run across new commands, read their help and try to understand what
    they’re doing. For `Get-` commands, try running them—plugging in any values that
    the script passes in variables to parameters—to see what output is produced.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你遇到新的命令时，阅读它们的帮助并尝试理解它们在做什么。对于`Get-`命令，尝试运行它们——将脚本传递给变量的任何值插入参数中——以查看产生的输出。
- en: When you run across unfamiliar elements, such as `if` or `[environment]`, consider
    running short code snippets inside a virtual machine to see what those snippets
    do (using a VM helps protect your production environment). Search for those keywords
    in help (using wildcards) to learn more.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你遇到不熟悉的内容，如`if`或`[environment]`时，考虑在虚拟机中运行简短的代码片段以查看这些片段做什么（使用虚拟机有助于保护你的生产环境）。在帮助中搜索这些关键字（使用通配符）以了解更多信息。
- en: Above all, don’t skip a single line. Don’t think, “Well, I don’t know what that
    does, so I’ll just keep going.” Stop and find out what each line does, or what
    you think it does. That helps you figure out where you need to tweak the script
    to meet your specific needs.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是，不要跳过任何一行。不要想，“嗯，我不知道那是什么，所以我继续。”停下来弄清楚每一行做什么，或者你认为它做什么。这有助于你确定你需要调整脚本以适应你的特定需求。
- en: 22.3 Lab
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 22.3 实验
- en: Listing 22.2 shows a complete script. See if you can figure out what it does
    and how to use it. Can you predict any errors that this might cause? What might
    you need to do in order to use this in your environment?
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 列表22.2显示了一个完整的脚本。看看你是否能弄清楚它做什么以及如何使用它。你能预测出任何可能导致的错误吗？为了在你的环境中使用它，你可能需要做什么？
- en: Note that this script should run as is (you may have to run it as administrator
    to access the security log), but if it doesn’t run on your system, can you track
    down the cause of the problem? Keep in mind that you’ve seen most of these commands,
    and for the ones you haven’t, there are the PowerShell help files. Those files’
    examples include every technique shown in this script.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个脚本应该直接运行（你可能需要以管理员身份运行以访问安全日志），但如果它在你的系统上无法运行，你能追踪到问题的原因吗？记住，你已经看到了大多数这些命令，而对于你没有看到的命令，有PowerShell的帮助文件。这些文件中的示例包括脚本中展示的每个技术。
- en: Listing 22.2 Get-LastOn.ps1
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 列表22.2 Get-LastOn.ps1
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 22.4 Lab answer
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 22.4 实验答案
- en: 'The script file seems to define two functions that won’t do anything until
    called. At the end of the script is a command, `Get-LastOn`, which is the same
    name as one of the functions, so we can assume that’s what is executed. Looking
    at that function, you can see that it has numerous parameter defaults, which explains
    why nothing else needs to be called. The comment-based help also explains what
    the function does. The first part of this function is using `Get-WinEvent`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本文件似乎定义了两个函数，这些函数在调用之前不会做任何事情。在脚本末尾有一个命令`Get-LastOn`，它与其中一个函数的名称相同，所以我们可以假设这就是执行的内容。查看该函数，你可以看到它有多个参数默认值，这解释了为什么不需要调用其他内容。基于注释的帮助也解释了该函数的功能。这个函数的第一部分使用`Get-WinEvent`：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: If this were a new cmdlet, we’d look at help and examples. The expression seems
    to be returning a user-defined maximum of events. After looking at the help for
    `Get-WinEvent`, we see that the parameter `-MaxEvents` will return the maximum
    number of events sorted from newest to oldest. Therefore, our variable of `$MaxEvents`
    comes from a parameter and has a default value of `5000`. These event logs are
    then filtered by `Where-Object`, looking for two event log values (event IDs of
    `4627` and `4647`), also from the parameter.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是一个新的cmdlet，我们会查看帮助和示例。表达式似乎返回一个用户定义的事件最大值。在查看`Get-WinEvent`的帮助后，我们看到参数`-MaxEvents`将返回从最新到最旧的排序的最大事件数。因此，我们的变量`$MaxEvents`来自一个参数，默认值为`5000`。这些事件日志随后通过`Where-Object`进行过滤，寻找两个事件日志值（事件ID为`4627`和`4647`），也来自参数。
- en: 'Next it looks like something is done with each event log in the `foreach` loop.
    Here’s a potential pitfall: In the `foreach` loop, it looks like other variables
    are getting set. The first one is taking the event object and piping it to something
    called `parseEventmessage`. This doesn’t look like a cmdlet name, but we did see
    it as one of the functions. Jumping to it, we can see that it takes a message
    as a parameter and splits each one into an array. We might need to research the
    `–Split` operator.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，看起来在`foreach`循环中对每个事件日志都进行了某种处理。这里有一个潜在的陷阱：在`foreach`循环中，看起来其他变量正在被设置。第一个是将事件对象传递到名为`parseEventmessage`的某个东西。这看起来不像是一个cmdlet名称，但我们确实看到它被用作一个函数。跳转到它，我们可以看到它接受一个消息作为参数，并将每个消息分割成一个数组。我们可能需要研究`-Split`运算符。
- en: Each line in the array is processed by another `foreach` loop. It looks like
    lines are split again, and there is a `try/catch` block to handle errors. Again,
    we might need to read up on that to see how it works. Finally, there is an `if`
    statement, where it appears that if the split-up strings are not empty, then a
    variable called `$props` is created as a hash table or associative array. This
    function would be much easier to decipher if the author had included some comments.
    Anyway, the parsing function ends by calling `New-Object`, another cmdlet to read
    up on.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 数组中的每一行都通过另一个`foreach`循环进行处理。看起来行再次被分割，并且有一个`try/catch`块来处理错误。同样，我们可能需要阅读有关它的内容以了解它是如何工作的。最后，有一个`if`语句，看起来如果分割后的字符串不为空，则创建一个名为`$props`的变量作为散列表或关联数组。如果作者包含一些注释，这个函数将更容易理解。无论如何，解析函数通过调用`New-Object`（另一个需要了解的cmdlet）结束。
- en: This function’s output is then passed to the calling function. It looks like
    the same process is repeated to get `$domain`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的输出随后传递给调用函数。看起来重复了同样的过程以获取`$domain`。
- en: Oh, look, another hash table and `New-Object`, but by now we should understand
    what the function is doing. This is the final output from the function and hence
    the script.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 哦，看，另一个散列表和`New-Object`，但到现在我们应该理解这个函数在做什么。这是函数的最终输出，因此是脚本。
