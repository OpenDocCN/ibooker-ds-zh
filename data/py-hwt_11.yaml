- en: 8 Defining user-friendly classes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8 定义用户友好的类
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了
- en: Defining the initialization method
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义初始化方法
- en: Creating instance, static, and class methods
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建实例、静态和类方法
- en: Applying encapsulation to a class
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将封装应用于类
- en: Creating proper string representations
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建适当的字符串表示
- en: Defining a superclass and subclasses
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义超类和子类
- en: The core of any application is data. Although built-in data types are useful
    for managing data, you’ll find them to be limited because they only have attributes
    and methods that are designed to address the most generic functionalities, including
    named tuples (section 3.3). You may have noticed that you don’t have useful methods
    to manipulate tasks with named tuples. But the task management app (like all applications
    in general) addresses specific business needs, which require data models that
    can handle those needs. Thus, custom classes are irreplaceable elements in your
    application. By defining proper attributes for the class, you can better capture
    the data needed in your application. By defining proper methods, you can better
    process the data in your application.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 任何应用程序的核心是数据。尽管内置数据类型对于管理数据很有用，但你可能会发现它们有限，因为它们只具有设计用来处理最通用功能（包括命名元组（第3.3节））的属性和方法。你可能已经注意到，你没有有用的方法来操作带有命名元组的任务。但是，任务管理应用程序（就像所有通用应用程序一样）解决特定的业务需求，这需要能够处理这些需求的数据模型。因此，自定义类是你应用程序中不可或缺的元素。通过为类定义适当的属性，你可以更好地捕捉到应用程序中所需的数据。通过定义适当的方法，你可以更好地处理应用程序中的数据。
- en: In this chapter, I focus on how to define attributes and different kinds of
    methods for your class, mostly using the Task class as part of the task management
    app to discuss the pertinent topics. The goal of defining a good custom class
    is to make it user-friendly—not only robust in terms of its attributes and methods
    (what should be available), but also maintainable in terms of implementing its
    functionalities in a clear organization (how they are structured).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我专注于如何为你的类定义属性和不同种类的的方法，主要使用任务管理应用程序中的Task类作为讨论相关主题的一部分。定义一个好的自定义类的目标是使其用户友好——不仅在其属性和方法方面（应该提供什么）方面健壮，而且在实现其功能时的可维护性方面（如何组织）。
- en: 8.1 How do I define the initialization method for a class?
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.1 我该如何定义一个类的初始化方法？
- en: When we use built-in classes, such as list and dict, we can use their constructors
    to create instance objects (or instances) of these classes. The process of creating
    an instance is known as *instantiation**:* you create the instance object. Under
    the hood, creating an instance object involves calling the __init__ method, as
    shown in the next listing.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用内置类，如list和dict时，我们可以使用它们的构造函数来创建这些类的实例对象（或实例）。创建实例的过程被称为*实例化**：你创建了实例对象。在底层，创建实例对象涉及调用__init__方法，如下一列表所示。
- en: Listing 8.1 Creating a Task class with no meaningful initialization
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.1 创建一个没有有意义初始化的Task类
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As you can see, we call the constructor Task() to create an instance, which
    triggers calling the __init__ method. If you’re wondering what the name of this
    method (init) means, it stands for *initialization**,* setting the initial states
    for the instance object. Thus, this method is the most essential method that you
    almost always define in a custom class. In this section, you’ll learn the best
    practice for defining the initialization method: __init__.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们调用构造函数Task()来创建一个实例，这会触发调用__init__方法。如果你想知道这个方法（init）的名字意味着什么，它代表的是*初始化**，*为实例对象设置初始状态。因此，这个方法是在自定义类中几乎总是定义的最基本的方法。在本节中，你将学习定义初始化方法：__init__的最佳实践。
- en: '8.1.1 Demystifying self: The first parameter in __init__'
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1.1 揭秘self：__init__中的第一个参数
- en: 'In listing 8.1, although we don’t have any implementation for the __init__
    method, the method still has one parameter: self. More broadly, if you’ve ever
    read someone else’s code, you should see that their __init__ method also uses
    self as its first parameter. If you’ve wondered what self is, this section demystifies
    it by addressing four questions:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表8.1中，尽管我们没有为__init__方法提供任何实现，但该方法仍然有一个参数：self。更广泛地说，如果你曾经阅读过别人的代码，你应该看到他们的__init__方法也使用self作为其第一个参数。如果你想知道self是什么，本节通过回答四个问题来揭开它的神秘面纱：
- en: What does self stand for?
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: self代表什么？
- en: Why don’t we need to send an argument for self?
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么我们不需要为self传递参数？
- en: Is self a keyword?
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Self是一个关键字吗？
- en: Do we have to use self as the parameter name?
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们是否必须使用self作为参数名？
- en: 'Self: The instance object'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Self：实例对象
- en: 'The first question is what self stands for. When you define methods in a class,
    most of the time, the methods are intended to manipulate instance objects, such
    as __init__, which sets the initial attributes for the new instance object. Thus,
    we need a convenient way to refer to the instance object. If you happen to know
    other object-oriented programming (OOP) languages, you know that these languages
    may use this, that, self, or it to refer to the instance object. Python uses self
    to refer to the instance objects in the method definitions. To prove the claim
    that self refers to the newly created instance object, we can use the built-in
    id function, which uniquely identifies an object in the memory, as follows:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个问题是什么self代表。当你在一个类中定义方法时，大多数情况下，这些方法是为了操作实例对象，例如`__init__`，它为新实例对象设置初始属性。因此，我们需要一种方便的方式来引用实例对象。如果你恰好了解其他面向对象编程（OOP）语言，你知道这些语言可能使用this、that、self或it来引用实例对象。Python在方法定义中使用self来引用实例对象。为了证明self指向新创建的实例对象，我们可以使用内置的id函数，它唯一地标识内存中的对象，如下所示：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ Expect a different value on your computer, and each run can have a new value.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在您的计算机上可能会得到不同的值，并且每次运行都可能得到新的值。
- en: The printout reveals that the self’s and task’s memory addresses are the same,
    meaning that they’re the same object—the newly created instance object of the
    Task class.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 打印输出显示自我和任务的内存地址是相同的，这意味着它们是同一个对象——新创建的Task类实例对象。
- en: Reminder The id function checks an object’s memory address. Because each object
    has a unique memory address, when objects have the same memory address, they’re
    the same object.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：id函数检查对象的内存地址。因为每个对象都有一个唯一的内存地址，当对象具有相同的内存地址时，它们就是同一个对象。
- en: Setting self implicitly
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 隐式设置self
- en: 'When we create an instance object by calling the constructor Task(), we don’t
    use any arguments. But the underlying __init__ method does require one argument:
    self. How can you explain this apparent conflict? The reason is that the self
    argument is set, however implicitly, by Python. As you’ll see, Python creates
    the instance object by calling __new__ and sends it to __init__ as the self argument.
    To understand the implicit setting of the self argument, observe the following
    code snippet:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们通过调用构造函数`Task()`创建实例对象时，我们不使用任何参数。但是底层的`__init__`方法确实需要一个参数：self。你如何解释这种明显的冲突？原因是self参数被Python隐式设置。正如你将看到的，Python通过调用`__new__`创建实例对象，并将其作为self参数传递给`__init__`。为了理解self参数的隐式设置，观察以下代码片段：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In this code, we call the constructor Task(). Note that the construction involves
    the sequential automatic invocation of two special methods under the hood: __new__
    and __init__. The __new__ method creates and returns (boldfaced) the new instance
    object, and the __init__ method doesn’t return anything. The reason for this difference
    in returning a value is that after you call __new__, you need to refer to the
    instance object that you just created. Thus, if the __new__ method doesn’t return
    that new instance object, you can’t access and use it. By contrast, the __init__
    method takes self as an argument; it refers to the new instance and manipulates
    the instance in-place.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们调用构造函数`Task()`。请注意，构造过程涉及底层连续自动调用两个特殊方法：`__new__`和`__init__`。`__new__`方法创建并返回（粗体）新的实例对象，而`__init__`方法不返回任何内容。这种返回值差异的原因是在调用`__new__`之后，你需要引用你刚刚创建的实例对象。因此，如果`__new__`方法不返回那个新实例对象，你就无法访问和使用它。相比之下，`__init__`方法接受self作为参数；它指向新的实例并在原地操作实例。
- en: 'To simulate the fact that the instance construction is a two-step process that
    calls __new__ and __init__, we can call these two methods manually. Please note
    that this simulation is meant to demonstrate the underlying machinery and is rarely
    used in a codebase:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 为了模拟实例构造是一个两步过程，它调用`__new__`和`__init__`，我们可以手动调用这两个方法。请注意，这种模拟是为了演示底层机制，在代码库中很少使用：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'First, we use __new__ method to create an instance object: task. Then we can
    set task as the self argument in the __init__ method. As you can tell from the
    memory address, we’re manipulating the same instance object. Figure 8.1 summarizes
    the process.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用`__new__`方法创建实例对象：task。然后我们可以在`__init__`方法中将task设置为self参数。正如你可以从内存地址中看出的，我们正在操作同一个实例对象。图8.1总结了这个过程。
- en: '![CH08_F01_Cui](../Images/CH08_F01_Cui.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![CH08_F01_Cui](../Images/CH08_F01_Cui.png)'
- en: Figure 8.1 The detailed instantiation process behind the scenes. When you create
    an instance object by calling the constructor, the instance object is created
    first by the __new__ method. When it’s created, it’s sent to the __init__ method
    to complete the initialization, where the instance’s attributes are set.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.1 后台详细的实例化过程。当你通过调用构造函数创建实例对象时，实例对象首先通过 `__new__` 方法创建。当它被创建时，它被发送到 `__init__`
    方法以完成初始化，在那里设置实例的属性。
- en: Because of the equivalence between the call to the constructor and two-step
    instantiation, you can think of using the constructor directly as being syntactic
    sugar for the two-step process. Moreover, using the constructor for instantiation
    is more concise and readable.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 由于构造函数调用与两步实例化的等价性，你可以认为直接使用构造函数是两步过程的语法糖。此外，使用构造函数进行实例化更简洁、更易读。
- en: Self is not a keyword
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`self` 不是一个关键字'
- en: 'In Python, we use def to signify that we’re creating a function, and we use
    for to signify that we’re running a for loop. def and for are examples of keywords
    in Python, meaning that they’re reserved by the language for special operations.
    Because we use self to refer to the instance in Python, which appears to be a
    special operation, this may lead some people to think that self is a keyword.
    As you’ll see, however, self is *not* a keyword. One rule of keywords is that
    you can’t use keywords as a variable name, as shown in this example:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，我们使用 `def` 来表示我们正在创建一个函数，使用 `for` 来表示我们正在运行一个循环。`def` 和 `for` 是 Python
    中的关键字，意味着它们被语言保留用于特殊操作。由于我们在 Python 中使用 `self` 来引用实例，这看起来像是一个特殊操作，这可能会让一些人认为 `self`
    是一个关键字。然而，正如你将看到的，`self` 并不是一个关键字。关键字的一个规则是，你不能将关键字用作变量名，如下面的例子所示：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can’t assign any value to def or class, but we can assign a value to self,
    clearly indicating that self is qualitatively different from other keywords. In
    fact, a more formal way to check whether a word is a reserved keyword is to take
    advantage of the keyword module, which provides the convenient iskeyword function:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能给 `def` 或 `class` 赋值，但我们可以给 `self` 赋值，这清楚地表明 `self` 与其他关键字有本质的不同。实际上，检查一个词是否是保留关键字的一个更正式的方法是利用关键字模块，它提供了一个方便的
    `iskeyword` 函数：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As shown in the preceding code snippet, def, class, and lambda are identified
    as keywords by the iskeyword function. By contrast, self isn’t a keyword.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码片段所示，`def`、`class` 和 `lambda` 被识别为关键字，而 `self` 则不是关键字。
- en: Trivia You can get the entire list of keywords by calling the kwlist function
    in the keyword module.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 知识点 你可以通过在关键字模块中调用 `kwlist` 函数来获取整个关键字列表。
- en: Preferring using self as the parameter name
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 倾向于使用 `self` 作为参数名
- en: 'We know that self refers to the instance object in __init__ and that it’s not
    a keyword. We may have seen that the first argument in __init__ is always self;
    thus, we may assume that it must be named self. We’re not required to use self
    as the parameter name, however. We can use any legitimate variable name (but it
    can’t be a keyword). The following code snippet shows the use of this instead
    of self in __init__:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道 `self` 在 `__init__` 中指的是实例对象，并且它不是一个关键字。我们可能已经看到 `__init__` 中的第一个参数总是 `self`；因此，我们可能认为它必须命名为
    `self`。然而，我们没有义务将 `self` 作为参数名。我们可以使用任何合法的变量名（但不能是关键字）。下面的代码片段显示了在 `__init__`
    中使用此变量名而不是 `self` 的用法：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see, we can still create an instance object of the Task class without
    any problems when we use this. From the syntax perspective, we’re not obligated
    to use self in __init__. But we should use self anyway; using self in __init__
    is a convention, and every Python programmer should respect this convention.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，当我们使用这种方式时，我们仍然可以无任何问题地创建 Task 类的实例对象。从语法角度来看，我们没有义务在 `__init__` 中使用 `self`。但我们应该使用
    `self`；在 `__init__` 中使用 `self` 是一种约定，每个 Python 程序员都应该遵守这个约定。
- en: Readability Follow the common conventions, such as using self in __init__. When
    you follow the convention, it’s easier for others to read your code because they
    know exactly what you mean.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 可读性 遵循常见的约定，例如在 `__init__` 中使用 `self`。当你遵循约定时，其他人阅读你的代码会更容易，因为他们确切地知道你的意思。
- en: 8.1.2 Setting proper arguments in __init__
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1.2 在 `__init__` 中设置合适的参数
- en: In the examples I’ve shown, I don’t include arguments other than self in the
    __init__ method. This section shows what considerations we should give to the
    arguments we use in the __init__ method.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在我展示的例子中，我没有在 `__init__` 方法中包含除 `self` 之外的任何参数。本节展示了我们应该考虑在 `__init__` 方法中使用哪些参数。
- en: 'The __init__ method is intended to complete the initialization process for
    the new instance object, particularly setting the essential attributes to the
    instance. The discussion of named tuples in section 3.3 mentions that the Task
    class should handle three attributes for each task: title, description, and urgency
    level. The following code snippet shows the data model created with named tuples:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: __init__ 方法旨在完成新实例对象的初始化过程，特别是将基本属性设置到实例中。第 3.3 节中关于命名元组的讨论提到，Task 类应该为每个任务处理三个属性：标题、描述和紧急程度。以下代码片段显示了使用命名元组创建的数据模型：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As you can see, using the named tuples-based data model, we create the instance
    object by specifying all three attributes. Thus, when we’re creating a custom
    class other than named tuples, we should have the same mechanism that allows the
    users to set these attributes, adding the necessary arguments to the __init__
    method:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，使用基于命名元组的模型，我们通过指定所有三个属性来创建实例对象。因此，当我们创建一个除了命名元组之外的定制类时，我们应该有相同的机制，允许用户设置这些属性，将必要的参数添加到
    __init__ 方法中：
- en: '[PRE8]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'By taking arguments, __init__ can perform an additional initialization procedure:
    setting the initial attributes from the arguments for the instance. It’s important
    to note that the arguments should be related to the attributes of the instance
    object. In the body of the __init__ method, we’re setting the instance’s attributes
    with the arguments. With this updated __init__ method, we can create an instance
    object by supplying the arguments:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 通过接受参数，__init__ 可以执行额外的初始化过程：从参数中为实例设置初始属性。需要注意的是，这些参数应该与实例对象的属性相关。在 __init__
    方法的主体中，我们使用参数设置实例的属性。使用这个更新的 __init__ 方法，我们可以通过提供参数来创建实例对象：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'When the instance is created, it has all the needed attributes set up. To inspect
    the new instance’s attributes, you can check the instance’s special attribute
    __dict__. As you can see, the new instance task has these attributes stored as
    a dict object:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当实例被创建时，它已经设置了所有需要的属性。要检查新实例的属性，你可以检查实例的特殊属性 __dict__。正如你所看到的，新实例 task 具有这些属性，它们被存储为一个字典对象：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'For the Task class, this specific example applies to the task management application,
    but your project uses different custom classes that address your data modeling
    needs. Thus, the question is what considerations you should use for the arguments
    in the __init__ method when you build your own custom class. In general, I recommend
    the following rules of thumb:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Task 类，这个特定的例子适用于任务管理应用程序，但你的项目使用不同的定制类来满足你的数据建模需求。因此，问题是当你构建自己的定制类时，在 __init__
    方法中构建参数时你应该考虑哪些因素。一般来说，我建议以下经验法则：
- en: '*Identify the required arguments.* When you construct an instance, you want
    the new instance to have all the attributes set up and ready for use. Thus, you
    need to identify the arguments that are required to set the instance’s attributes.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*识别所需的参数.* 当你创建一个实例时，你希望新的实例具有所有已设置并准备使用的属性。因此，你需要识别出设置实例属性所需的参数。'
- en: '*Prioritize key arguments.* Your custom class may require ten initial attributes
    that need to be set for a new instance object. Some attributes are always more
    important than others, however. You want to list the more important ones before
    the less important ones.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*优先考虑关键字参数.* 你的自定义类可能需要十个初始属性，这些属性需要为新实例对象设置。然而，有些属性比其他属性更重要。你希望在较不重要的属性之前列出更重要的属性。'
- en: '*Use key arguments as positional.* This requirement is more of a style convention
    than a rule. You want users to be able to set important arguments as positional
    arguments, because calling a constructor without specifying keyword arguments
    is cleaner than using keyword arguments.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用关键字作为位置参数.* 这个要求更多的是一种风格约定，而不是规则。你希望用户能够将重要的参数设置为位置参数，因为在不指定关键字参数的情况下调用构造函数比使用关键字参数更简洁。'
- en: '*Limit the number of positional arguments.* This point is related to the preceding
    one. Although we prefer using positional arguments for the __init__ method, when
    there are too many positional arguments, readers may not know which is which.
    Thus, as a rule of thumb, I recommend using no more than four positional arguments.
    You can make additional arguments keyword-only (section 6.4.1).'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*限制位置参数的数量.* 这个点与前面的点相关。虽然我们更喜欢在 __init__ 方法中使用位置参数，但当位置参数太多时，读者可能不知道哪个是哪个。因此，作为一个经验法则，我建议不要使用超过四个位置参数。你可以将额外的参数设置为关键字参数（第
    6.4.1 节）。'
- en: '*Set applicable default values.* At its core, __init__ is a function. Thus,
    to make calling this function easier, you want to set default values for the arguments
    that most users don’t bother changing. Of the ten initial attributes, it’s likely
    that seven are the same in most use cases; thus, you can set default values for
    these seven attributes.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*设置适用的默认值。* 在本质上，__init__ 是一个函数。因此，为了使调用此函数更容易，你希望为大多数用户不费心更改的参数设置默认值。在十个初始属性中，大多数情况下可能七个是相同的；因此，你可以为这七个属性设置默认值。'
- en: 8.1.3 Specifying all attributes in __init__
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1.3 在 __init__ 中指定所有属性
- en: In section 8.1.2, we discussed setting arguments in the __init__ method. With
    these arguments, we set the corresponding attributes for an instance object in
    the body of the __init__ method. An instance object can have more attributes than
    those created from __init__’s arguments. Although you can set an instance’s attributes
    anywhere in the class’s body, the best practice is to specify all attributes of
    an instance object in the body of the __init__ method. This section discusses
    this practice.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 8.1.2 节中，我们讨论了在 __init__ 方法中设置参数。通过这些参数，我们在 __init__ 方法的主体中为实例对象设置相应的属性。实例对象可以拥有的属性比从
    __init__ 的参数创建的属性更多。尽管你可以在类的任何地方设置实例的属性，但最佳实践是在 __init__ 方法的主体中指定实例对象的全部属性。本节讨论了这种实践。
- en: First, consider the next listing, in which the instance’s attributes are initialized
    in multiple places. Please note that I don’t recommend this pattern, as it’s unclear
    about what attributes an instance can have.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，考虑下一个列表，其中实例的属性在多个地方初始化。请注意，我不推荐这种模式，因为它不清楚实例可以有哪些属性。
- en: Listing 8.2 Setting attributes elsewhere other than __init__
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.2 在 __init__ 之外设置属性
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Peek The methods whose first parameter is self are known as *instance methods,*
    which are intended to be called by the instance objects of the class. We’ll discuss
    them in section 8.2.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以 self 为第一个参数的方法被称为 *实例方法*，这些方法旨在由类的实例对象调用。我们将在第 8.2 节中讨论它们。
- en: 'In listing 8.2, besides the title, desc, and urgency attributes, we set the
    attributes status and tags in the complete and add_tag methods, respectively.
    You don’t want to adopt the pattern of initializing instance attributes everywhere
    (other than inside the __init__ method) for two reasons:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表 8.2 中，除了标题、描述和紧急程度属性外，我们在 complete 和 add_tag 方法中分别设置了状态和标签属性。你不希望在整个类中（除了在
    __init__ 方法内部）初始化实例属性的模式，原因有两个：
- en: 'When you try to access these attributes, you encounter an AttributeError unless
    you’ve called these two methods, which set these attributes accordingly. In other
    words, if you access these attributes accidentally without calling the related
    methods, your application will crash:'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你尝试访问这些属性时，除非你已经调用了这些两个方法来相应地设置这些属性，否则你会遇到 AttributeError。换句话说，如果你在未调用相关方法的情况下意外地访问这些属性，你的应用程序将会崩溃：
- en: '[PRE12]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: It’s hard for users to know what attributes an instance object of the class
    can have. Particularly when your application is complicated, it’s likely that
    your class has many functionalities. If you set attributes in these methods, users
    have a nightmare of a time trying to figure out the attributes of an instance
    object.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户很难知道类的一个实例对象可以有哪些属性。尤其是当你的应用程序很复杂时，你的类可能有很多功能。如果你在这些方法中设置属性，用户在试图找出实例对象的属性时会有一个噩梦。
- en: For these two reasons, we should specify all the attributes in __init__, even
    though some attributes are to be updated through a specific method call. In these
    cases, these attributes should have a reasonable initial value. The next listing
    shows the desired pattern.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这两个原因，我们应该在 __init__ 中指定所有属性，即使某些属性将通过特定的方法调用进行更新。在这些情况下，这些属性应该有一个合理的初始值。下一个列表显示了期望的模式。
- en: Listing 8.3 Setting all attributes in __init__
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.3 在 __init__ 中设置所有属性
- en: '[PRE13]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'With the updated pattern, after you create an instance object, it has all the
    attributes assigned properly, and we can inspect them by accessing the __dict__
    special attribute:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 使用更新的模式，在你创建一个实例对象之后，它已经正确分配了所有属性，我们可以通过访问 __dict__ 特殊属性来检查它们：
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Maintainability By placing all the attributes in __init__, you make it clear
    to your teammates what attributes an instance object of the class can have. When
    you access any attribute, it always has a value, so no AttributeError will be
    raised.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 可维护性 通过将所有属性放在 __init__ 中，你让你的队友清楚地知道类的一个实例对象可以有哪些属性。当你访问任何属性时，它总是有一个值，所以不会引发
    AttributeError。
- en: Now you can access the status and tags attributes without calling the complete
    and add_tag methods first. More importantly, readers can scan the __init__ method
    to know an instance’s available attributes instead of looking for attributes buried
    in various methods (listing 8.2). Figure 8.2 shows the contrast between the two
    patterns.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以直接访问状态和标签属性，而无需首先调用 complete 和 add_tag 方法。更重要的是，读者可以扫描 __init__ 方法来了解实例的可用属性，而不是在各种方法中寻找隐藏的属性（列表8.2）。图8.2展示了两种模式的对比。
- en: '![CH08_F02_Cui](../Images/CH08_F02_Cui.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![CH08_F02_Cui](../Images/CH08_F02_Cui.png)'
- en: Figure 8.2 The contrast between two patterns that differ in where they specify
    the attributes for the instance object. In the unrecommended pattern, you initialize
    the attributes in various places. In the recommended pattern, you initialize the
    attributes only in the __init__ method, making it clear to readers what attributes
    an instance object has.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2展示了两个模式之间的对比，这两个模式在指定实例对象属性的位置上有所不同。在不推荐的模式中，你在各种地方初始化属性。在推荐的模式中，你只在 __init__
    方法中初始化属性，这样读者就可以清楚地知道实例对象有哪些属性。
- en: 8.1.4 Defining class attributes outside the __init__ method
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1.4 在 __init__ 方法外定义类属性
- en: The initialization method should provide initialization for an instance object
    by defining its attributes on a per-instance basis. Notably, there can be shared
    attributes for all instance objects. In this case, you should not include them
    as instance attributes and should consider class attributes instead. This section
    discusses this feature.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化方法应该通过在实例级别上定义其属性来为实例对象提供初始化。值得注意的是，所有实例对象可以共享属性。在这种情况下，你不应该将它们包括为实例属性，而应该考虑类属性。本节讨论了这一特性。
- en: Concept *Class attributes* are those attributes that belong to the class (as
    an object), and all the instance objects of the class share the attributes through
    the class.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 概念 *类属性* 是那些属于类的（作为一个对象）属性，并且类的所有实例对象通过类共享这些属性。
- en: 'For simplicity, suppose that each task has an attribute user who creates the
    task. Theoretically, you can make user an instance attribute by using the following
    __init__ method:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化，假设每个任务都有一个创建任务的属性用户。理论上，你可以通过以下 __init__ 方法将用户作为一个实例属性：
- en: '[PRE15]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Because user is an instance attribute, you expect your application to need
    more memory, as you need to save user data for every instance. But it’s important
    to know that in the application, after the user login, there will be only one
    user who will create all the tasks. Thus, all the instances should share the attribute
    user. To help reduce the memory cost of saving user for each instance, you should
    create a class attribute in this case:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 因为用户是一个实例属性，你预期你的应用程序需要更多的内存，因为你需要为每个实例保存用户数据。但重要的是要知道，在应用程序中，用户登录后，将只有一个用户会创建所有任务。因此，所有实例都应该共享属性用户。为了帮助减少为每个实例保存用户数据的内存成本，你应该在这种情况下创建一个类属性：
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Depending on the data model, you may need to define additional class attributes
    for your class. Defining class attributes is an important technique for saving
    memory, as the instances share the same attributes by referencing the same underlying
    object in memory. From a readability perspective, it’s essential to know that
    you place the class attributes below the class definition head and above the __init__
    method.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 根据数据模型，你可能需要为你的类定义额外的类属性。定义类属性是节省内存的重要技术，因为实例通过引用内存中相同的底层对象来共享相同的属性。从可读性的角度来看，了解你将类属性放在类定义头部下方和
    __init__ 方法上方是至关重要的。
- en: Readability All the class attributes should be explicit and clear. Place them
    right below the class definition head.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 可读性 所有类属性都应该是明确和清晰的。将它们放在类定义头部下方。
- en: 8.1.5 Discussion
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1.5 讨论
- en: You almost always implement the __init__ method in your custom class. The __init__
    method should include all the attributes for an instance object so that readers
    don’t have to guess what attribute the instances have. Also, place the __init__
    method before any other methods in the body of the class. Why? From a readability
    perspective, we want to know what data a class can hold; the instance’s attributes
    represent the data that the class holds. Defining a proper __init__ method is
    the first thing you want to work on in a custom class.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 您几乎总是在自定义类中实现 `__init__` 方法。`__init__` 方法应包含实例对象的全部属性，这样读者就不必猜测实例具有哪些属性。此外，将
    `__init__` 方法放在类体中的其他方法之前。为什么？从可读性的角度来看，我们想知道一个类可以持有什么数据；实例的属性代表类持有的数据。定义一个合适的
    `__init__` 方法是在自定义类中首先想要做的工作。
- en: 8.1.6 Challenge
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1.6 挑战
- en: Leah is working on the task management app to learn coding in Python. She suggested
    allowing users to specify tags during instantiation. So, she needed to add tags
    as an argument in the __init__ method (listing 8.3). In most cases, she expected
    users to set an empty list to the tags argument. What default value should she
    set for tags in this case?
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 莉亚正在开发任务管理应用以学习Python编程。她建议在实例化时允许用户指定标签。因此，她需要在 `__init__` 方法中添加标签作为参数（见列表8.3）。在大多数情况下，她期望用户将空列表设置给标签参数。在这种情况下，她应该为标签设置什么默认值？
- en: Hint At its core, __init__ is a function. You may recall from section 6.1 that
    we should set a default value for a mutable argument in a function.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 提示 在其核心，`__init__` 是一个函数。你可能还记得从第6.1节中，我们应该在函数中为可变参数设置一个默认值。
- en: 8.2 When do I define instance, static, and class methods?
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.2 我何时定义实例、静态和类方法？
- en: 'After we set proper attributes for the instance objects, it’s time to provide
    functionalities to the class. In listing 8.3, the class has two functions: complete
    and add_tag. These functions are known as *instance methods.* Besides instance
    methods, you can define static and class methods. These methods are intended for
    different use cases. This section explores situations in which you need to define
    instance, static, or class methods.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们为实例对象设置了适当的属性之后，是时候为类提供功能了。在列表8.3中，该类有两个函数：complete 和 add_tag。这些函数被称为 *实例方法*。除了实例方法之外，您还可以定义静态和类方法。这些方法适用于不同的用例。本节探讨了需要定义实例、静态或类方法的场景。
- en: 8.2.1 Defining instance methods for manipulating individual instances
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2.1 为操作单个实例定义实例方法
- en: An instance method is intended to be called on an instance object of the class.
    Thus, when you want to change the data of an individual instance object or run
    operations that rely on an individual instance object’s data, such as attributes
    or other instance methods, you need to define instance methods.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 实例方法旨在在类的实例对象上调用。因此，当您想更改单个实例对象的数据或运行依赖于单个实例对象数据的操作时，例如属性或其他实例方法，您需要定义实例方法。
- en: Reminder Syntactically, you’re allowed to use a different parameter name for
    the self argument, but it’s a convention to use self as the name.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 提醒 从语法上讲，您可以为 `self` 参数使用不同的参数名，但使用 `self` 作为名称是一种约定。
- en: The hallmark of an instance method is that you set self as its first parameter.
    As discussed extensively in section 8.1.1, self refers to the instance object
    in the __init__ method, which is true for all instance methods. In listing 8.4,
    we verify that the self argument in instance methods also refers to the instance
    object with a simple modification of the Task class’s complete method from listing
    8.3\. Please note that to save space, I don’t include other implementation details
    of the Task class, such as __init__.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 实例方法的标志是您将其第一个参数设置为 `self`。如第8.1.1节中广泛讨论的那样，`self` 指的是 `__init__` 方法中的实例对象，这对于所有实例方法都是正确的。在列表8.4中，我们通过简单修改列表8.3中的
    Task 类的 complete 方法来验证实例方法中的 `self` 参数也指向实例对象。请注意，为了节省空间，我没有包括 Task 类的其他实现细节，例如
    `__init__`。
- en: Listing 8.4 Creating and using an instance method
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.4 创建和使用实例方法
- en: '[PRE17]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As you can see, self in the complete method has the same memory address as the
    task instance, which indicates that self is indeed the instance object on which
    we call the method. Under the hood, an instance method is invoked by the class
    calling the method with the instance as an argument, as illustrated in figure
    8.3.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，在完整方法中，`self` 与任务实例具有相同的内存地址，这表明 `self` 确实是我们调用方法的实例对象。在底层，实例方法是通过类调用方法并以实例作为参数来调用的，如图8.3所示。
- en: '![CH08_F03_Cui](../Images/CH08_F03_Cui.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![CH08_F03_Cui](../Images/CH08_F03_Cui.png)'
- en: Figure 8.3 The underlying action for calling an instance method. When you use
    an instance object to call an instance method, it’s processed as using the class
    to call the method with the instance object as an argument. At the end, the function’s
    operations are applied to the instance object that calls the instance method.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3 调用实例方法的基本操作。当你使用实例对象来调用实例方法时，它被处理为使用类来调用方法，其中实例对象作为参数。最后，函数的操作应用于调用实例方法的实例对象。
- en: 'The single purpose of an instance method is to manipulate a specific instance
    object. That is, you always take the following calling pattern to use an instance
    method: instance.instance_method(arg0, arg1, arg2).'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 实例方法的单一目的是操作特定的实例对象。也就是说，你总是采用以下调用模式来使用实例方法：instance.instance_method(arg0, arg1,
    arg2)。
- en: In the body of the instance method, the operations should be about manipulating
    the instance object that we call the method on. Therefore, if you find out that
    the method doesn’t manipulate the instance or doesn’t rely on the instance-related
    data, it’s likely that the method shouldn’t be implemented as an instance method
    to begin with. Instead, you may need to implement the method as a static method.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在实例方法的主体中，操作应该是关于操作我们调用的实例对象。因此，如果你发现该方法不操作实例或不依赖于实例相关数据，那么很可能该方法一开始就不应该作为实例方法实现。相反，你可能需要将其实现为静态方法。
- en: 8.2.2 Defining static methods for utility functionalities
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2.2 定义用于实用功能的静态方法
- en: When you implement utility-related functions that are not specific to any instance,
    you need to define a static method. This section discusses how to define a static
    method.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当你实现不针对任何特定实例的实用相关函数时，你需要定义一个静态方法。本节讨论了如何定义静态方法。
- en: Unlike an instance method, which uses self as its first parameter, a static
    method doesn’t use self, as it’s intended to be independent of any instance object,
    and there is no need to refer to a specific instance. To define a static method,
    we use the staticmethod decorator for the function within the body of the class.
    Consider the example in listing 8.5.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用 self 作为其第一个参数的实例方法不同，静态方法不使用 self，因为它旨在独立于任何实例对象，并且没有必要引用特定的实例。为了定义静态方法，我们在类的主体中使用
    staticmethod 装饰器为函数。考虑列表8.5中的示例。
- en: Reminder Decorators add additional functionalities to the decorated function
    without changing its original functionality.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 提醒装饰器在不改变其原始功能的情况下为装饰的函数添加额外的功能。
- en: Listing 8.5 Creating a static method
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.5 创建静态方法
- en: '[PRE18]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In listing 8.5, get_timestamp is a static method defined with the @staticmethod
    decorator. In this static method, we create a formatted timestamp string, which
    we can use whenever we need to show users the exact time. To call this method,
    we use the following pattern: CustomClass.static_method(arg0, arg1, arg2). We
    can try this pattern with the get_timestamp static method:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表8.5中，get_timestamp 是使用 @staticmethod 装饰器定义的静态方法。在这个静态方法中，我们创建了一个格式化的时间戳字符串，我们可以在需要向用户显示确切时间时使用它。要调用此方法，我们使用以下模式：CustomClass.static_method(arg0,
    arg1, arg2)。我们可以尝试使用 get_timestamp 静态方法来尝试这个模式：
- en: '[PRE19]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As you can see, we use the static method by calling Task.get_timestamp(), which
    retrieves the current timestamp in the desired format. This operation represents
    a general utility need; as you can imagine, there are multiple scenarios in which
    a timestamp should be displayed. Providing utility functionalities is the main
    purpose of static methods. That is, when you need to define utility-related methods
    that are independent of any instance object, you should use the @staticmethod
    decorator to create static methods. When you read someone else’s custom class
    and notice any use of @staticmethod, you know that it’s a static method, as the
    staticmethod decorator is a hallmark of a static method.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们通过调用 Task.get_timestamp() 使用静态方法，它以所需格式检索当前时间戳。这种操作代表了一种通用实用需求；正如你可以想象的那样，有多个场景需要显示时间戳。提供实用功能是静态方法的主要目的。也就是说，当你需要定义与任何实例对象无关的实用相关方法时，你应该使用
    @staticmethod 装饰器来创建静态方法。当你阅读他人的自定义类并注意到任何使用 @staticmethod 的情况时，你知道它是一个静态方法，因为
    staticmethod 装饰器是静态方法的标志。
- en: 8.2.3 Defining class methods for accessing class-level attributes
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2.3 定义用于访问类级属性的类方法
- en: In section 8.2.2, you learned about defining static methods that are utility
    methods without the need to access individual instance objects. It’s possible
    that some methods may need to access the attributes of the class. In this case,
    you need to define a class method.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在 8.2.2 节中，你学习了如何定义不需要访问单个实例对象的实用方法静态方法。可能有些方法需要访问类的属性。在这种情况下，你需要定义一个类方法。
- en: The first hallmark of a class method is that you use cls as its first parameter.
    Like self in an instance method, cls is not a keyword, and you can give this argument
    other applicable names, but it’s a convention to name it cls, and every Python
    programmer should respect this convention.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 类方法的第一个显著特征是，你使用 cls 作为它的第一个参数。就像实例方法中的 self 一样，cls 不是一个关键字，你可以给这个参数其他适用的名称，但按照惯例，我们将其命名为
    cls，并且每个 Python 程序员都应该遵守这个惯例。
- en: Readability You name the first parameter as cls in a class method. When other
    programmers see cls, they know that it’s referring to the class.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 可读性 你在类方法中将第一个参数命名为 cls。当其他程序员看到 cls 时，他们会知道它指的是类。
- en: 'The implementation of static methods requires the staticmethod decorator. A
    class method also uses the classmethod decorator—the second hallmark of a class
    method. The method is called a *class method* because it needs to access the attributes
    or methods of the class. Consider an example. Suppose that in our task management
    application, we obtain data in the form of a dict object, which stores the data
    for a task:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 静态方法的实现需要使用 @staticmethod 装饰器。类方法也使用 @classmethod 装饰器——这是类方法的第二个显著特征。这个方法被称为
    *类方法*，因为它需要访问类的属性或方法。考虑一个例子。假设在我们的任务管理应用程序中，我们以字典对象的形式获取数据，该对象存储了任务的详细信息：
- en: '[PRE20]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To construct an instance object of the Task class from this dict object, we
    may have to do the following:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个字典对象构建 Task 类的实例对象，我们可能需要执行以下操作：
- en: '[PRE21]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: But because we may often obtain this kind of dict data and create a corresponding
    Task instance, we should provide a more convenient way to address this need. Fortunately,
    a class method is a good solution, as the following listing shows.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 但因为我们可能经常获取这种字典数据并创建相应的 Task 实例，我们应该提供一个更方便的方式来满足这种需求。幸运的是，类方法是一个很好的解决方案，如下面的列表所示。
- en: Listing 8.6 Creating a class method
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.6 创建类方法
- en: '[PRE22]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'As you can see in listing 8.6, we define a class method called task_from_dict
    with @classmethod. In the body of this method, because cls stands for the class
    that we’re working with (Task), we can use the class’s constructor directly—cls(title,
    desc, urgency)—to create an instance object. With this class method, we can conveniently
    create a Task instance object from a dict object:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如列表 8.6 所示，我们使用 @classmethod 定义了一个名为 task_from_dict 的类方法。在这个方法的主体中，因为 cls 代表我们正在工作的类（Task），我们可以直接使用类的构造函数——cls(title,
    desc, urgency)—来创建实例对象。通过这个类方法，我们可以方便地从字典对象创建 Task 实例对象：
- en: '[PRE23]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: From a general perspective, a class method is used mostly as a *factory method**,*
    meaning that this kind of method is used to create an instance object from a particular
    form of data. Section 4.5 mentions that DataFrame is a spreadsheet-like data model
    in the pandas library. It has a couple of class methods—from_dict and from_records—that
    you can use to construct instance objects of the DataFrame class.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 从一般的角度来看，类方法主要用作 *工厂方法**，这意味着这类方法用于从特定形式的数据创建实例对象。第 4.5 节提到，DataFrame 是 pandas
    库中类似于电子表格的数据模型。它有几个类方法——from_dict 和 from_records，你可以使用这些方法来构建 DataFrame 类的实例对象。
- en: 8.2.4 Discussion
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2.4 讨论部分
- en: Of the three kinds of methods, instance and class methods are the most straightforward.
    Static methods are a little trickier. Because they’re intended to provide utility
    functionalities, it’s generally acceptable to define them outside a class; after
    all, they don’t need to manipulate any instance or the class. In general, I recommend
    that you place a static method outside a class if it addresses a more general
    utility functionality than a class should handle. Taking the data processing library
    pandas as an example, the core data models are Series and DataFrame classes. One
    utility function, to_datetime, converts data to a date object. This function addresses
    a more general need; thus, it’s not implemented as a static method within Series
    or DataFrame.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在三种方法中，实例方法和类方法是最直接的。静态方法稍微复杂一些。因为它们旨在提供实用功能，所以通常可以在类外部定义它们；毕竟，它们不需要操作任何实例或类。一般来说，我建议如果你定义的静态方法比类应该处理的功能更通用，就将静态方法放在类外部。以数据处理库pandas为例，核心数据模型是Series和DataFrame类。一个实用函数to_datetime将数据转换为日期对象。这个函数解决了一个更普遍的需求；因此，它不是在Series或DataFrame中作为静态方法实现的。
- en: 8.2.5 Challenge
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2.5 挑战
- en: 'While Leah continues to work on the task management app, she realizes that
    she needs to create an instance of the Task class from a tuple object: ("Laundry",
    "Wash clothes", 3). What kind of method should she implement to address this need
    in the class?'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当利亚继续在任务管理应用上工作时，她意识到她需要从一个元组对象中创建一个Task类的实例：("Laundry", "Wash clothes", 3)。她应该在类中实现哪种方法来满足这个需求？
- en: Hint We implement a method that creates an instance object from a dict object
    in listing 8.6.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：我们在列表8.6中实现了一个从字典对象创建实例对象的方法。
- en: 8.3 How do I apply finer access control to a class?
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.3 我该如何对类应用更细粒度的访问控制？
- en: 'In a custom class, you may define tens of methods. Some methods are for internal
    use by you (the developers of the class), whereas other methods are for other
    developers that use your class. Consider the following scenario. In the Task class,
    another method formats the note for the complete method:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个自定义类中，你可能定义了数十个方法。其中一些方法是供你（类的开发者）内部使用的，而其他方法则是供其他使用你的类的开发者使用的。考虑以下场景。在Task类中，另一个方法为complete方法格式化笔记：
- en: '[PRE24]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'When the user calls the complete method, this method sets a formatted note
    to the note attribute by calling the format_note method. Notably, the user can
    also call format_ note directly. This behavior isn’t the desired behavior, as
    one key principle of OOP is encapsulation: you expose only attributes and methods
    that users need to access and nothing more. The implication of encapsulation is
    that you apply finer access control to the class. In this section, we’ll talk
    about some key access control techniques.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户调用complete方法时，这个方法通过调用format_note方法将一个格式化的笔记设置到note属性中。值得注意的是，用户也可以直接调用format_note。这种行为并不是期望的行为，因为面向对象编程的一个基本原则是封装：你只暴露用户需要访问的属性和方法，而不暴露更多。封装的隐含意义是，你为类应用更细粒度的访问控制。在本节中，我们将讨论一些关键的访问控制技术。
- en: Concept *Encapsulation* refers to a coding principle that is widely adopted
    in OOP languages, in which you bundle data and methods into a class and allow
    access to only the part of the data relevant to users.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 概念*封装*指的是在面向对象编程语言中广泛采用的一种编码原则，其中你将数据和方法捆绑到一个类中，并只允许访问对用户相关的数据部分。
- en: Public, protected, and private
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 公共的、受保护的和私有的
- en: In a typical OOP language, to restrict access to a specific attribute or method,
    many languages use protected or private as a keyword. The opposite of protected
    and private is public, meaning that the attributes and methods are available to
    all users both outside and inside a class. *Protected* means that the attributes
    and methods are available to the class and its subclasses but not outside the
    class. *Private* means that the attributes and methods are only available to the
    class itself, not to its subclasses or outside the class. Because of their restrictive
    access to the inside, *private* and *protected* are also referred to as *nonpublic*.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型的面向对象编程语言中，为了限制对特定属性或方法的访问，许多语言使用protected或private作为关键字。protected和private的反义词是public，意味着属性和方法对类内外所有用户都是可用的。*受保护的*意味着属性和方法对类及其子类可用，但不在类外部。*私有的*意味着属性和方法仅对类本身可用，对它的子类或类外部不可用。由于它们对内部访问的限制，*私有的*和*受保护的*也被称为*非公共的*。
- en: 8.3.1 Creating protected methods by using an underscore as the prefix
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3.1 通过使用下划线作为前缀创建受保护的方法
- en: At its core, Python is an OOP language. Unlike other OOP languages that use
    private and/or protected for access control, however, Python has no formal mechanism
    that restricts access to any attribute or method. In other words, everything in
    a class is public, and Python doesn’t have protected or private as a keyword.
    The convention in creating an access-control mechanism is to use underscores as
    the prefix for the attribute or method. A one-underscore prefix means protected,
    and a double-underscore prefix means private (as discussed in section 8.3.2).
    In this section, you’ll learn about defining protected methods. Notably, the same
    mechanism applies to creating protected and private attributes.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在其核心，Python是一种面向对象编程（OOP）语言。然而，与其他使用私有和/或受保护进行访问控制的OOP语言不同，Python没有正式的机制来限制对任何属性或方法的访问。换句话说，类中的所有内容都是公开的，Python没有受保护或私有的关键字。创建访问控制机制的惯例是使用下划线作为属性或方法的前缀。单下划线前缀表示受保护，双下划线前缀表示私有（如第8.3.2节所述）。在本节中，你将学习如何定义受保护方法。值得注意的是，相同的机制也适用于创建受保护和私有属性。
- en: When I talked about named tuples in section 3.3, I mentioned that creating a
    named tuple data model allows us to take advantage of an integrated development
    environment’s (IDE’s) autocompletion hints by populating the available attributes
    after you enter the dot following the object. This approach can be inconvenient,
    however, if the populated list includes the methods you’re not going to use. As
    a user, you’re not going to call the format_note method yourself; thus, it’s ideal
    for the autocompletion suggestion not to show format_note (figure 8.4).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 当我在第3.3节中谈到命名元组时，我提到创建命名元组数据模型允许我们利用集成开发环境（IDE）的自动完成提示，在输入对象后的点号后填充可用的属性。然而，如果填充的列表包括你不会使用的函数，这种方法可能不方便。作为用户，你不会自己调用format_note方法；因此，自动完成建议不显示format_note（如图8.4所示）。
- en: '![CH08_F04_Cui](../Images/CH08_F04_Cui.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![CH08_F04_Cui](../Images/CH08_F04_Cui.png)'
- en: Figure 8.4 Different autocompletion hints provided for the instance object.
    It’s less desirable if the autocompletion hints include functions that users don’t
    need to use—in this case, the format_note method.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4 为实例对象提供的不同自动完成提示。如果自动完成提示包括用户不需要使用的函数，则不太理想——在这种情况下，是format_note方法。
- en: 'Apparently, by hiding the functions you don’t need in the autocompletion hint
    list, you can have higher coding efficiency. But how does the IDE know what functions
    to hide? The magic is in using an underscore as a prefix for the method’s name,
    which indicates that it’s a protected method. Instead of format_note, we can name
    the method _format_note. The significance of the underscore prefix is twofold:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，通过在自动完成提示列表中隐藏你不需要的函数，你可以提高编码效率。但是，IDE如何知道要隐藏哪些函数呢？秘诀在于使用下划线作为方法名称的前缀，这表示它是一个受保护的方法。我们可以将方法命名为_format_note。下划线前缀的意义有两重：
- en: This method is not intended to be used outside the class, so it’s not prompted
    in the autocompletion hints when you work outside the class, as shown in the right
    panel of figure 8.4.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此方法不打算在课堂外使用，因此在你在课堂外工作时，自动完成提示中不会显示，如图8.4的右侧面板所示。
- en: This method is still available as part of the autocompletion hints when you
    work inside the class, as shown in figure 8.5.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你在类内工作时，此方法作为自动完成提示的一部分仍然可用，如图8.5所示。
- en: '![CH08_F05_Cui](../Images/CH08_F05_Cui.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![CH08_F05_Cui](../Images/CH08_F05_Cui.png)'
- en: Figure 8.5 The availability of a protected method within the class. After you
    enter the dot, the available attributes and methods for the instance object appear
    in the list, and the list includes the protected method.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5 类中受保护方法的可用性。在你输入点号后，实例对象可用的属性和方法会显示在列表中，并且列表中包括受保护方法。
- en: These two implications are in line with the encapsulation principle. You restrict
    outside users’ access to the functions they don’t need and keep the same functions
    available to users who do need them.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个含义与封装原则一致。你限制外部用户访问他们不需要的功能，同时保持对需要这些功能的用户可用相同的功能。
- en: 8.3.2 Creating private methods by using double underscores as the prefix
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3.2 使用双下划线作为前缀创建私有方法
- en: In section 8.3.1, you learned how to define protected methods to restrict public
    access to the methods you don’t want users to see. Besides using protected methods,
    you can define private methods, which achieve the same encapsulation effect. In
    this section, you’ll learn to define a private method. More importantly, you’ll
    see why it’s sometimes a good idea to define a private method instead of a protected
    method.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在8.3.1节中，你学习了如何定义受保护的方法来限制用户对不想让他们看到的方法的公共访问。除了使用受保护的方法外，你还可以定义私有方法，这可以达到相同的封装效果。在本节中，你将学习如何定义私有方法。更重要的是，你将了解为什么有时定义私有方法而不是受保护的方法是一个好主意。
- en: You’ve learned that defining a private method requires two underscores as the
    prefix. Let’s continue using the format_note method as an example. To make the
    method private, change the name to __format_note. With this name change, the method’s
    access is consistently restricted to the internal of the class (figure 8.6).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经了解到定义私有方法需要使用两个下划线作为前缀。让我们继续以`format_note`方法为例。为了使方法私有，将名称更改为`__format_note`。通过这个名称更改，方法的访问权限将始终限制在类的内部（如图8.6所示）。
- en: '![CH08_F06_Cui](../Images/CH08_F06_Cui.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![CH08_F06_Cui](../Images/CH08_F06_Cui.png)'
- en: Figure 8.6 Internal but no external access to private methods. The __format_note
    method starts with double underscores, meaning that it’s private. A private method
    is available only within the class.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.6 内部访问但外部无法访问私有方法。`__format_note` 方法以两个下划线开头，这意味着它是私有的。私有方法仅可在类内部使用。
- en: Protected and private methods are similar in terms of their availabilities inside
    the class. As mentioned at the beginning of section 8.3.1, however, there are
    no strict nonpublic methods in Python. If you want to access protected methods,
    you can, although many IDEs display a warning, as shown in figure 8.7.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 受保护方法和私有方法在类内部的可访问性方面相似。然而，如8.3.1节开头所述，Python中并没有严格意义上的非公共方法。如果你想访问受保护的方法，你可以，尽管许多IDE会显示警告，如图8.7所示。
- en: '![CH08_F07_Cui](../Images/CH08_F07_Cui.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![CH08_F07_Cui](../Images/CH08_F07_Cui.png)'
- en: Figure 8.7 Calling a protected method outside a class is technically allowed,
    but a warning appears in response to this unintended behavior, as protected methods
    are not intended for outside use.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.7 在类外部调用受保护的方法在技术上是被允许的，但出于这种意外行为，会出现警告，因为受保护的方法并不打算用于外部使用。
- en: 'What happens when someone is trying to access a private method outside a class?
    A seemingly strange thing happens. As shown in the following code snippet, no
    such method or attribute exists:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当有人试图在类外部访问私有方法时会发生什么？会发生一件看似奇怪的事情。如下面的代码片段所示，不存在这样的方法或属性：
- en: '[PRE25]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This “inaccessibility” of __format_note outside the class marks a major difference
    between private and protected methods, as it seems to be more private than a protected
    method such as _format_note. Thus, if you want to have more restrictive access
    to nonpublic methods, you should use double underscores as the prefix to create
    private methods instead of using one underscore to create protected methods.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这种在类外部对`__format_note`的“不可访问性”标志着私有方法和受保护方法之间的一项重大区别，因为它似乎比像`_format_note`这样的受保护方法更私密。因此，如果你想对非公共方法有更严格的访问限制，你应该使用双下划线作为前缀来创建私有方法，而不是使用单下划线来创建受保护的方法。
- en: Maintainability Because of the differential public access rule between protected
    and private methods, use private methods if you want to have restrictive access.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 可维护性 由于受保护方法和私有方法之间的公共访问规则不同，如果你想有更严格的访问限制，应使用私有方法。
- en: 'I said that Python has no real nonpublic methods, which is why I put quotation
    marks around inaccessibility earlier in this section. But the question is how
    to access a private method if you need to. You may want to manipulate some code
    within a package developed by others, for example. As shown in the following code
    snippet, you can access the private method by calling _Task__format_note("a note"):'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我说过Python没有真正的非公共方法，这就是为什么我在本节前面将“不可访问性”用引号括起来的原因。但是，问题是如果你需要如何访问私有方法。你可能想操作其他人开发的包内的某些代码，例如。如下面的代码片段所示，你可以通过调用`_Task__format_note("a
    note")`来访问私有方法。
- en: '[PRE26]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This technique is called *name mangling**,* which converts a private method
    to a differently named method, allowing a private method to be called outside
    the class. Specifically, the name mangling follows the rule __private_method ->
    _ClassName__private_method. Thus, __format_note becomes _Task__format_note, and
    we can call this private method outside the Task class.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术称为*名称混淆**，它将私有方法转换为具有不同名称的方法，允许在类外调用私有方法。具体来说，名称混淆遵循以下规则：__private_method
    -> _ClassName__private_method。因此，__format_note 变为 _Task__format_note，我们可以在 Task
    类外调用这个私有方法。
- en: Concept *Name mangling* is the process of converting a private method name to
    a different name by using _ClassName as a prefix. Then the private method can
    be accessed outside the class.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 概念 *名称混淆* 是通过使用 _ClassName 作为前缀将私有方法名称转换为不同名称的过程。然后，私有方法可以在类外访问。
- en: In addition to having different public access rules, protected and private methods
    have different rules for accessing them within the subclass where these methods
    are defined. I’ll review this topic in section 8.5.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 除了具有不同的公共访问规则外，受保护和私有方法在定义它们的子类中访问它们时也有不同的规则。我将在第 8.5 节中回顾这个主题。
- en: 8.3.3 Creating read-only attributes with the property decorator
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3.3 使用属性装饰器创建只读属性
- en: 'One major reason for implementing a custom class is that you can define as
    many attributes as you need so that the custom class, as a cohesive entity, can
    bundle all related data through well-defined attributes and methods. Notably,
    a custom class is *mutable,* meaning that you can change the attributes of the
    instance objects. But you may not want users to change some attributes. In that
    case, you should consider another access control technique: *read-only attributes.*
    Users can read these attributes but can’t change them. In this section, you’ll
    learn how to define read-only attributes.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 实现自定义类的一个主要原因是你可以定义你需要的尽可能多的属性，这样自定义类作为一个统一的实体，可以通过定义良好的属性和方法捆绑所有相关数据。值得注意的是，自定义类是*可变的*，这意味着你可以更改实例对象的属性。但是你可能不希望用户更改某些属性。在这种情况下，你应该考虑另一种访问控制技术：*只读属性*。用户可以读取这些属性，但不能更改它们。在本节中，你将学习如何定义只读属性。
- en: 'For the Task class, consider the status attribute. For now, users can freely
    change the status attribute for an instance:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Task 类，考虑 status 属性。目前，用户可以自由更改实例的 status 属性：
- en: '[PRE27]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: For encapsulation purposes, we don’t allow users to set the status attribute
    freely. To update a task’s status to completed, for example, they should call
    the complete method. So the question is how to prevent users from setting status
    manually. The solution is to take advantage of the property decorator. The next
    listing shows the technique.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 为了封装的目的，我们不允许用户自由设置状态属性。例如，要将任务的状态更新为完成，他们应该调用完整方法。所以问题是如何防止用户手动设置状态。解决方案是利用属性装饰器。下一个列表显示了技术。
- en: Listing 8.7 Using the property decorator
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.7 使用属性装饰器
- en: '[PRE28]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In listing 8.7, we keep only the code that is relevant to defining a read-only
    attribute technique. In the code, we should note three significant things:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表 8.7 中，我们只保留与定义只读属性技术相关的代码。在代码中，我们应该注意三个重要的事情：
- en: The instance has a protected attribute _status.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实例有一个受保护的属性 _status。
- en: We define an instance method status, which is decorated by the property decorator.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们定义了一个实例方法 status，它被属性装饰器装饰。
- en: In the complete method, we update the _status attribute.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在完整方法中，我们更新 _status 属性。
- en: 'We know that when we call a method on an object, we use the call operator—the
    parentheses following the method name. But the property decorator makes a method
    accessible as though it’s an attribute. For simplicity, you can refer to a method
    with the property decorator as a property, and you don’t need to use the call
    operator to access a property:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道当我们对一个对象调用方法时，我们使用调用操作符——方法名称后面的括号。但是属性装饰器使得方法可以像属性一样访问。为了简单起见，你可以将带有属性装饰器的方法称为属性，并且不需要使用调用操作符来访问属性：
- en: '[PRE29]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Notably, a property represents a read-only attribute. You can read it as shown
    in the preceding code snippet. You can’t set it, however, which is exactly what
    you want: to prevent users from setting status directly, as shown in the following
    listing.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，属性代表一个只读属性。你可以像前面的代码片段中那样读取它。然而，你不能设置它，这正是你想要的：防止用户直接设置状态，如下面的列表所示。
- en: Listing 8.8 Read-only property
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.8 只读属性
- en: '[PRE30]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Maintainability Creating read-only properties can prevent users from changing
    a specific attribute, maintaining data stability.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 可维护性 创建只读属性可以防止用户更改特定的属性，从而保持数据稳定性。
- en: In a more general scenario, when you define a read-only property, it’s common
    to create a protected attribute designed to handle the corresponding data internally.
    status, for example, is a read-only property, and we use _status to handle status-related
    data inside the class.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在更一般的情况下，当你定义一个只读属性时，通常需要创建一个受保护的属性来内部处理相应的数据。例如，`status` 就是一个只读属性，我们使用 `_status`
    来在类内部处理与状态相关的数据。
- en: QUESTION Why do we want to use a protected attribute instead of a private attribute?
    Think about the difference between them in terms of access from a subclass.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 问题 为什么我们想要使用受保护的属性而不是私有属性？从子类访问的角度考虑它们之间的区别。
- en: 8.3.4 Verifying data integrity with a property setter
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3.4 使用属性设置器验证数据完整性
- en: In section 8.3.3, we introduced the property decorator, which we used to create
    the read-only property status for the Task class. The implication of the read-only
    property is that we can’t set a value for it. That behavior isn’t always the desired
    behavior, however. Sometimes, we want to have a mechanism to set a value for a
    property. One useful scenario for setting a property is verifying data integrity,
    as discussed in this section.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在 8.3.3 节中，我们介绍了属性装饰器，我们使用它为 Task 类创建了只读属性 `status`。只读属性的含义是我们不能为其设置值。然而，这种行为并不总是我们想要的。有时，我们希望有一种机制来为属性设置值。本节讨论的设置属性的有用场景之一是验证数据完整性。
- en: 'Concept In a conventional OOP language such as Java, two concepts are related
    to a property: getter and setter. The *getter* is the method that allows you to
    retrieve the property’s value, and the *setter* is the method through which you
    set the value for the property. The property decorator creates a getter, and in
    the following paragraphs, we’re creating a setter.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 概念 在像 Java 这样的传统面向对象语言中，有两个概念与属性相关：获取器和设置器。*获取器* 是允许你检索属性值的函数，而 *设置器* 是通过它设置属性值的函数。属性装饰器创建了一个获取器，在接下来的段落中，我们将创建一个设置器。
- en: Suppose that we allow users to set the status property directly. The value must
    be a valid one, however. Consider that a task’s status can be created, started,
    completed, or suspended. How can we ensure that the set value is one of them?
    This kind of data verification of property can be best addressed with the property
    setter technique, as shown in the next listing.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们允许用户直接设置 `status` 属性。然而，值必须是有效的。考虑一个任务的状态可以是创建、开始、完成或暂停。我们如何确保设置的值是其中之一？这种属性的数据验证可以通过属性设置器技术来最好地解决，如下一列表所示。
- en: Listing 8.9 Creating a setter for a property
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.9 为属性创建设置器
- en: '[PRE31]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: ❶ The best practice is to raise an exception (see section 12.4).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 最佳实践是抛出异常（见第 12.4 节）。
- en: 'In listing 8.9, after creating the status property, we create a setter for
    this property by using @status.setter, which adopts the general form @property_name.setter.
    This setter is an instance method, which takes a value argument that stands for
    the value we want to assign to the property. In the body of the setter, we verify
    that the value is one of the four possibilities. With this setter, we’re able
    to set the status property:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表 8.9 中，在创建 `status` 属性之后，我们通过使用 `@status.setter` 创建了这个属性的设置器，它采用了通用的形式 `@property_name.setter`。这个设置器是一个实例方法，它接受一个值参数，代表我们想要分配给属性的值。在设置器的主体中，我们验证该值是否是四种可能性之一。有了这个设置器，我们就能设置
    `status` 属性：
- en: '[PRE32]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: As you can see, we can directly set the status to completed. More important,
    when we’re trying to set an invalid value, we’re notified of this error. Although
    we can create getters and setters to convert attributes to properties, we don’t
    want to, because they complicate the class. Unless you implement properties for
    reasons such as read-only or data verification, you should access and set the
    attributes directly instead of going through properties. This pattern of direct
    access and manipulation separates Python from other OOP languages, making Python
    code more concise in general.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们可以直接将状态设置为“完成”。更重要的是，当我们尝试设置一个无效值时，我们会收到这个错误的提示。尽管我们可以创建获取器和设置器来将属性转换为属性，但我们不想这样做，因为这会使类变得复杂。除非你出于只读或数据验证等理由实现属性，否则你应该直接访问和设置属性，而不是通过属性。这种直接访问和操作的模式使
    Python 与其他面向对象的语言区分开来，通常使 Python 代码更加简洁。
- en: 8.3.5 Discussion
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3.5 讨论
- en: Defining private and protected methods is an essential technique for implementing
    encapsulation for the class; it helps minimize the public attributes of a class.
    When users work with the classes, they’ll be given the autocompletion hints for
    these public attributes, making their work more efficient. Don’t try to encapsulate
    everything by creating setters and getters as some other OOP languages do; that
    practice isn’t Pythonic. In most cases, you should use direct accessing and setting
    of attributes instead of properties, because the former technique is more straightforward
    and requires less implementation code.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 定义私有和受保护的方是实现类封装的基本技术；它有助于最小化类的公共属性。当用户与类一起工作时，他们会收到这些公共属性的自动完成提示，使他们的工作更加高效。不要试图通过创建setter和getter来封装一切，就像其他一些面向对象语言所做的那样；这种做法不符合Python风格。在大多数情况下，你应该使用直接访问和设置属性，而不是使用属性，因为前者更直接，且需要更少的实现代码。
- en: 8.3.6 Challenge
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3.6 挑战
- en: Suppose that the urgency attribute should have an integer value between 1 and
    5\. Can you convert it to a property with a setter? The setter allows you to check
    the value.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 假设紧急属性应该有一个介于1和5之间的整数值。你能将其转换为具有setter的属性吗？setter允许你检查值。
- en: Hint You can use a protected attribute, such as _urgency, as the internal representation
    of the urgency data, and create a property called urgency.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：您可以使用一个受保护的属性，例如`_urgency`，作为紧急数据的内部表示，并创建一个名为`urgency`的属性。
- en: 8.4 How do I customize string representation for a class?
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.4 如何自定义类的字符串表示？
- en: In section 8.1, we studied the initialization method __init__. This kind of
    method, the name of which is surrounded by two sets of double underscores, is
    known as a *special method**.* Special methods carry special operations, such
    as __init__, which is invoked when we create an instance object using the constructor.
    Notably, when we implement a special method in a class, we can say that we’re
    overriding this method, as all Python classes are subclasses of the object class,
    which implements these special methods.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在第8.1节中，我们学习了初始化方法`__init__`。这种方法的名字被两对双下划线包围，被称为*特殊方法**。特殊方法执行特殊操作，例如`__init__`，当使用构造函数创建实例对象时会被调用。值得注意的是，当我们在一个类中实现特殊方法时，可以说我们正在重写这个方法，因为所有Python类都是对象类的子类，而对象类实现了这些特殊方法。
- en: Concept In an OOP language, overriding means that a subclass provides different
    implementations for a method that is defined in its parent class.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 概念：在面向对象编程语言中，重写意味着子类为其父类中定义的方法提供了不同的实现。
- en: 'In this section, I’ll show you two other special methods: __str__ and __repr__,
    which provide customized string representations for a class.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将向你展示另外两个特殊方法：`__str__`和`__repr__`，它们为类提供了定制的字符串表示。
- en: 8.4.1 Overriding __str__ to show meaningful information for an instance
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.4.1 重写`__str__`以显示实例的有意义信息
- en: 'In many places, we need to inspect the instance objects that we’re working
    with. One common method is the print function, which shows the string representation
    of the object. Using this method, we can see what an instance of the Task class
    looks like:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多地方，我们需要检查我们正在处理的实例对象。一个常见的方法是`print`函数，它显示了对象的字符串表示。使用这种方法，我们可以看到`Task`类的实例看起来像什么：
- en: '[PRE33]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The information includes the instance’s class and its memory address, but nothing
    else. In other words, we don’t see anything more meaningful about the instance,
    such as its attributes. In this section, we’ll see how we can show more meaningful
    information of an instance with the print function.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这些信息包括实例的类及其内存地址，但没有其他信息。换句话说，我们看不到关于实例的任何更有意义的信息，例如其属性。在本节中，我们将看到如何使用`print`函数显示实例的更多有意义信息。
- en: When you use print with a custom class instance, the special method that is
    invoked is __str__, which defines the string representation of the instance. To
    provide customized string representation other than the default one shown in the
    preceding code snippet, we can override __str__ in our Task class, as the next
    listing shows.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用`print`与自定义类实例一起使用时，被调用的特殊方法是`__str__`，它定义了实例的字符串表示。为了提供除了前面代码片段中显示的默认字符串表示之外的定制字符串表示，我们可以在我们的`Task`类中重写`__str__`，如下一个列表所示。
- en: Listing 8.10 Overriding __str__ in a class
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.10 在类中重写`__str__`
- en: '[PRE34]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'When you override __str__ in a class, you should note three things:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在类中重写`__str__`时，你应该注意三件事：
- en: It’s an instance method, as it’s intended to provide a string representation
    for an instance object.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是一个实例方法，因为它旨在为实例对象提供一个字符串表示。
- en: It should return a str object as its return value.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它应该返回一个 `str` 对象作为其返回值。
- en: The returned string should provide descriptive information for the instance.
    In our case, we want to show the key attributes of the instance, including title,
    desc, and urgency.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回的字符串应该为实例提供描述性信息。在我们的例子中，我们希望显示实例的关键属性，包括标题、描述和紧急程度。
- en: 'After overriding the __str__ method, we can see what we observe with the print
    function:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在重写 `__str__` 方法之后，我们可以通过 `print` 函数看到我们观察到的结果：
- en: '[PRE35]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Besides print, we also often use an f-string to prepare string output for data
    display. When you include an instance object in curly braces, the interpolation
    of the instance calls the __str__ method under the hood. Observe this behavior:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `print` 之外，我们还经常使用 f-string 准备字符串输出以供数据显示。当你将实例对象包含在大括号中时，实例的插值会调用底层的 `__str__`
    方法。观察以下行为：
- en: '[PRE36]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'If you want to invoke the __str__ method on an instance explicitly, the preferred
    approach is str(instance), although we can call Class.__str__(instance)directly:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要显式调用实例上的 `__str__` 方法，首选的方法是 `str(instance)`，尽管我们也可以直接调用 `Class.__str__(instance)`：
- en: '[PRE37]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 8.4.2 Overriding __repr__ to provide instantiation information
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.4.2 重写 `__repr__` 以提供实例化信息
- en: 'Many people like to use Python in an interactive Python console, particularly
    when they’re learning Python, as the console provides real-time output of the
    code. In the console, if you enter a str variable, you see its string value:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 许多人喜欢在交互式 Python 控制台中使用 Python，尤其是在学习 Python 时，因为控制台提供了代码的实时输出。在控制台中，如果你输入一个
    `str` 变量，你会看到它的字符串值：
- en: '[PRE38]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'If you try to do that with the task instance, you’ll see something like this:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试对任务实例这样做，你会看到类似以下的内容：
- en: '[PRE39]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We’ve already implemented the __str__ method, which doesn’t change the displayed
    information for the instance in an interactive console. In this section, we’ll
    see how to change the string representation displayed in a console.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经实现了 `__str__` 方法，它不会改变在交互式控制台中显示的实例信息。在本节中，我们将看到如何更改控制台显示的字符串表示。
- en: 'When the interactive console shows the string representation for the instance,
    the special method that is invoked is __repr__. First, I’ll show you how to implement
    __repr__ in a class (see listing 8.11) and explain key things to note:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 当交互式控制台显示实例的字符串表示时，调用的特殊方法是 `__repr__`。首先，我将向你展示如何在类中实现 `__repr__`（参见列表 8.11），并解释需要注意的关键事项：
- en: It’s an instance method, as it provides string representation information on
    an instance-specific basis.
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是一个实例方法，因为它基于特定实例提供字符串表示信息。
- en: It returns a string value.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它返回一个字符串值。
- en: The string should provide information about the instantiation. Specifically,
    if other users type the string as code, it should create an instance object that
    has the same attributes as the current instance object.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串应该提供有关实例化的信息。具体来说，如果其他用户将字符串作为代码输入，它应该创建一个具有与当前实例对象相同属性的实例对象。
- en: Listing 8.11 Overriding __repr__ in a class
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 8.11 在类中重写 `__repr__`
- en: '[PRE40]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: ❶ !r requests the __repr__ method to be used for string interpolation.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ `!r` 请求使用 `__repr__` 方法进行字符串插值。
- en: 'After implementing __repr__, we can inspect the instance of the Task class
    in an interactive Python console:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现 `__repr__` 之后，我们可以在交互式 Python 控制台中检查 `Task` 类的实例：
- en: '[PRE41]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'To call __repr__ on an instance, you should use repr(instance) instead of Class.__repr__(instance):'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 要在实例上调用 `__repr__`，你应该使用 `repr(instance)` 而不是 `Class.__repr__(instance)`：
- en: '[PRE42]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 8.4.3 Understanding the differences between __str__ and __repr__
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.4.3 理解 `__str__` 和 `__repr__` 之间的区别
- en: In sections 8.4.1 and 8.4.2, you learned about __str__ and __repr__, both of
    which are designed to provide string representation for instances of a custom
    class. This section addresses their differences.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在 8.4.1 和 8.4.2 节中，你学习了 `__str__` 和 `__repr__`，这两个方法都是为了为自定义类的实例提供字符串表示。本节将讨论它们之间的区别。
- en: Different purposes
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的目的
- en: 'The first difference, which is also the biggest, is that the methods serve
    different purposes. The string provided by __repr__ is intended for debugging
    and development, so it’s for developers. Specifically, developers should be able
    to construct an instance literally from the string. As mentioned in section 2.2,
    we can use the built-in function eval to evaluate a string literal to derive the
    underlying object. We can do the same thing here:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个区别，也是最大的区别，是这两个方法服务于不同的目的。`__repr__` 提供的字符串旨在用于调试和开发，因此它是为开发者准备的。具体来说，开发者应该能够从字符串中直接构造实例。如
    2.2 节中提到的，我们可以使用内置函数 `eval` 来评估字符串字面量以推导出底层对象。我们在这里也可以做同样的事情：
- en: '[PRE43]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: By contrast, the string provided by __str__ is intended to show descriptive
    information and is for regular users of the code. Thus, the string is less formal
    than that provided by __repr__, which shows the instantiation information.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，`__str__` 提供的字符串旨在显示描述性信息，并且是为代码的常规用户设计的。因此，这个字符串比 `__repr__` 提供的字符串不那么正式，后者显示了实例化信息。
- en: Different usages
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 不同用法
- en: Although both methods provide string representation for a class, __str__ is
    the method that underlies both the print function and the interpolation in an
    f-string. By contrast, __repr__ is the method to use when you try to inspect an
    instance in an interactive console.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这两种方法都为类提供了字符串表示形式，但 `__str__` 是既支持 `print` 函数又支持 f-string 中插值的底层方法。相比之下，`__repr__`
    是当你尝试在交互式控制台中检查实例时应该使用的方法。
- en: 'In listing 8.11, you may notice that we append !r to the interpolation of self.title.
    !r is known as a *conversion flag**,* which requests that the interpolated string
    of the object call __repr__ instead of __str__ to create the string representation.
    By default, interpolating an instance of a custom class uses the string created
    from __str__. To override this default behavior, you use the conversion flag following
    the instance: f"{instance!r}". Relatedly, the default conversion flag for an instance
    is !s, which uses the string created from __str__. In other words, the expressions
    f"{instance}" and f"{instance!s}" are equivalent.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表 8.11 中，你可能注意到我们在 `self.title` 的插值中添加了 `!r`。`!r` 被称为 *转换标志**，它要求对象被插值的字符串调用
    `__repr__` 而不是 `__str__` 来创建字符串表示形式。默认情况下，插值自定义类的实例使用由 `__str__` 创建的字符串。为了覆盖此默认行为，你使用实例后的转换标志：`f"{instance!r}"`。相关地，实例的默认转换标志是
    `!s`，它使用由 `__str__` 创建的字符串。换句话说，表达式 `f"{instance}"` 和 `f"{instance!s}"` 是等效的。
- en: 'You may wonder why we need to use the !r flag for title and desc but not for
    urgency. The reason is that both title and desc are str objects. Their string
    representations from __str__ have no quotation marks. Thus, if we use their default
    interpolation, the string from __repr__ can’t be used to construct an instance
    object, as follows:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道为什么我们需要为标题和描述使用 `!r` 标志，而不是紧急情况。原因是标题和描述都是 `str` 对象。它们从 `__str__` 生成的字符串没有引号。因此，如果我们使用它们的默认插值，`__repr__`
    的字符串不能用来构造实例对象，如下所示：
- en: '[PRE44]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'In the revised class, we omit the !r conversion flag for title and desc. From
    the printout, we can see that there are no more quotation marks for Laundry and
    Wash clothes. As you can expect, we can’t construct a Task instance from this
    string:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在修订后的类中，我们省略了标题和描述的 `!r` 转换标志。从打印输出中，我们可以看到洗衣和洗衣服不再有引号。正如你所预期的，我们不能从这个字符串构造一个任务实例：
- en: '[PRE45]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: By contrast, the string representation from __repr__ does have quotation marks,
    as quotation marks are required for string literals, such as "Laundry" as opposed
    to Laundry. The former is a valid str object, but the latter is not. (It will
    be treated as a variable named Laundry, but it can’t be used because we never
    define a variable called Laundry.)
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，`__repr__` 的字符串表示形式确实有引号，因为字符串字面量需要引号，例如 "Laundry" 与 Laundry。前者是一个有效的 `str`
    对象，但后者不是。（它将被视为名为 Laundry 的变量，但不能使用，因为我们从未定义名为 Laundry 的变量。）
- en: 8.4.4 Discussion
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.4.4 讨论
- en: The essential purpose of the __repr__ method is to explain what the object is
    in an unambiguous way. Because the string generated from the repr method (note
    that calling repr invokes the __repr__ method in the class) should represent a
    text that we can use to reconstruct a similar object, any strings generated by
    repr should have quotes to make them valid Python string literals. Don’t forget
    to use the !r conversion flag if you use an f-string. I recommend that you implement
    both the __str__ and __repr__ methods for custom classes. If you prefer to implement
    only one method, override __repr__, because Python uses __repr__ when __str__
    isn’t implemented.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '`__repr__` 方法的根本目的是以明确的方式解释对象是什么。因为从 `repr` 方法生成的字符串（注意调用 `repr` 会调用类中的 `__repr__`
    方法）应该代表我们可以用来重建类似对象的文本，所以由 `repr` 生成的任何字符串都应该有引号以使其成为有效的 Python 字符串字面量。如果你使用 f-string，不要忘记使用
    `!r` 转换标志。我建议你为自定义类实现 `__str__` 和 `__repr__` 方法。如果你只想实现一个方法，则覆盖 `__repr__`，因为当
    `__str__` 没有实现时，Python 会使用 `__repr__`。'
- en: 8.4.5 Challenge
  id: totrans-261
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.4.5 挑战
- en: For the Task class, we return f"Task({self.title!r}, {self.desc!r}, {self .urgency})"
    for the __repr__ method, in which we hardcode the class name Task in the f-string.
    A general programming principle is that we minimize hardcoded data. Do you know
    how we can retrieve the class name programmatically?
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Task 类，我们在 __repr__ 方法中返回 f"Task({self.title!r}, {self.desc!r}, {self.urgency})"，在
    f-string 中硬编码了类名 Task。一个通用的编程原则是我们尽量减少硬编码的数据。你知道我们如何以编程方式检索类名吗？
- en: Hint An instance has a special attribute __class__ to identify its class, and
    a class has a special attribute __name__ to retrieve the class’s name.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 提示 一个实例有一个特殊的属性 __class__ 来标识其类，一个类有一个特殊的属性 __name__ 来检索类的名称。
- en: 8.5 Why and how do I create a superclass and subclasses?
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 8.5 为什么以及如何创建超类和子类？
- en: An essential concept in OOP *is inheritance,* which generally refers to the
    process of creating a child class that can reuse the implementations, or part
    of them, of a parent class. In the meantime, you can apply customized implementations
    to the child class, which becomes better at addressing specific questions than
    the parent class. The child class is also known as a *subclass,* and the parent
    class is also known as a *superclass.*
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象编程（OOP）中，*继承*是一个基本概念，它通常指的是创建一个子类，该子类可以重用父类的实现，或其部分实现。同时，你可以对子类应用定制的实现，这使得子类在解决特定问题方面比父类做得更好。子类也被称为*子类*，父类也被称为*超类*。
- en: Trivia Subclasses and superclasses are relative. A subclass is its own subclass’s
    superclass.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 知识点 子类和超类是相对的。一个子类是其自身子类的超类。
- en: Creating a subclass is a more advanced topic than many others that we have discussed
    so far. As you’ll find out in this section, it’s less straightforward to manage
    a superclass with multiple subclasses than distinct unrelated classes. Thus, a
    rule of thumb is that you justify the use of subclasses before you commit to implementing
    subclasses. In this section, we’ll review what constitutes good justification
    and examine the technical details of implementing a subclass.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 创建子类是一个比我们之前讨论的许多其他主题更高级的话题。正如你将在本节中发现的那样，管理具有多个子类的超类比管理不同且无关的类要复杂得多。因此，一个经验法则是，在决定实现子类之前，你需要证明使用子类的合理性。在本节中，我们将回顾构成良好理由的内容，并检查实现子类的技术细节。
- en: 8.5.1 Identifying the use scenario of subclasses
  id: totrans-268
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.5.1 确定子类的使用场景
- en: When your project’s scope grows, you’ll define more classes to deal with increased
    data. At this stage, all classes have no inheritance relationships. You notice,
    however, that some classes are similar in their functionalities; a level of code
    repetition exists. If you recall the DRY (Don’t Repeat Yourself) principle, you
    may realize that it’s time to refactor these classes. One essential approach is
    creating subclasses to reduce the overlapped implementations between classes.
    In this section, we’ll see when to use subclasses.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的项目范围扩大时，你需要定义更多的类来处理增加的数据。在这个阶段，所有类之间没有继承关系。然而，你注意到一些类在功能上相似；存在一定程度的代码重复。如果你回想起DRY（不要重复自己）原则，你可能会意识到是时候重构这些类了。一个基本的方法是创建子类以减少类之间的重叠实现。在本节中，我们将了解何时使用子类。
- en: Top-down (superclass to subclasses) or bottom-up (subclasses to superclass)?
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 自顶向下（超类到子类）还是自底向上（子类到超类）？
- en: When you try to implement subclasses in a project, two common scenarios can
    happen. In the first scenario, you start with one class as a data model, and you
    realize that you need to create subclasses from this class to form more specific
    data models. In the second scenario, you start with multiple classes as separate
    data models, and you realize that a considerable number of functionalities are
    similar between these classes. In this case, you can create a superclass from
    which the current class can inherit.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在项目中尝试实现子类时，可能会出现两种常见的场景。在第一种场景中，你从一个类作为数据模型开始，然后意识到你需要从这个类创建子类以形成更具体的数据模型。在第二种场景中，你从多个类作为独立的数据模型开始，然后意识到这些类之间有相当多的功能相似。在这种情况下，你可以创建一个超类，当前类可以从该超类继承。
- en: 'Both scenarios can happen in a project. In this section, we’ll focus on the
    second scenario: the bottom-up one. Based on my experience, a project typically
    starts with a flat data model structure—multiple classes for each model. When
    you implement these classes, you recognize similarities between them, making it
    necessary to create a superclass.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种情况都可能出现在项目中。在本节中，我们将重点关注第二种情况：自下而上的情况。根据我的经验，一个项目通常从一个扁平的数据模型结构开始——每个模型有多个类。当你实现这些类时，你会认识到它们之间的相似性，这使得创建一个超类成为必要。
- en: 'Suppose that our task management application supports user registration. There
    are two kinds of users: supervisors and subordinates. When we start to develop
    our application, we’ve created two separate classes, Supervisor and Subordinate,
    to manage the data for supervisors and subordinates, respectively. Figure 8.8
    provides a visual overview of the attributes and methods of these two classes.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的任务管理应用程序支持用户注册。存在两种类型的用户：主管和下属。当我们开始开发我们的应用程序时，我们创建了两个独立的类，分别是Supervisor和Subordinate，分别用于管理主管和下属的数据。图8.8提供了这两个类的属性和方法的可视概述。
- en: '![CH08_F08_Cui](../Images/CH08_F08_Cui.png)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![CH08_F08_Cui](../Images/CH08_F08_Cui.png)'
- en: Figure 8.8 Similarities and differences between the Supervisor and Subordinate
    classes. Some attributes and methods are the same in these two classes; other
    attributes and methods are different.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.8 Supervisor和Subordinate类的相似性和差异。这两个类中有一些属性和方法是相同的；其他属性和方法是不同的。
- en: As you can see, these two classes are similar, sharing most attributes and methods.
    In this case, you should consider creating a superclass that handles the shared
    functionalities. To handle the distinct functionalities for each type, you can
    inherit the superclass to create two subclasses. Figure 8.9 provides a visual
    overview of the inheritance structure.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这两个类很相似，共享大多数属性和方法。在这种情况下，你应该考虑创建一个处理共享功能性的超类。为了处理每种类型的独特功能，你可以从超类继承以创建两个子类。图8.9提供了继承结构的可视概述。
- en: '![CH08_F09_Cui](../Images/CH08_F09_Cui.png)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![CH08_F09_Cui](../Images/CH08_F09_Cui.png)'
- en: Figure 8.9 Creating a superclass that handles the shared attributes and methods.
    In the subclasses, you implement specific attributes and methods. You should also
    note that by default, the subclasses inherit all nonprivate attributes and methods
    from the superclass.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.9 创建处理共享属性和方法的超类。在子类中，你实现特定的属性和方法。你还应该注意，默认情况下，子类从超类继承所有非私有属性和方法。
- en: As shown in figure 8.9, when we create a superclass, we move all the shared
    attributes and methods from the subclasses to the superclass. In the subclasses,
    you implement specific attributes and methods. These instructions may sound too
    abstract. Let’s see more implementation code in the next section.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 如图8.9所示，当我们创建一个超类时，我们将所有共享的属性和方法从子类移动到超类。在子类中，你实现特定的属性和方法。这些说明可能听起来过于抽象。让我们在下一节中看看更多的实现代码。
- en: 8.5.2 Inheriting the superclass's attributes and methods automatically
  id: totrans-280
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.5.2 自动继承超类的属性和方法
- en: Earlier, I mentioned that overlapping of functionalities between classes is
    the basis of creating a superclass, which helps reduce code repetition. In this
    section, you’ll learn why we need less code with the inheritance.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我提到类之间的功能重叠是创建超类的基础，这有助于减少代码重复。在本节中，你将了解为什么我们需要更少的代码来实现继承。
- en: To see how superclass and subclass work together, let’s continue with the Employee-Supervisor
    example. Please read the code in the next listing first. We don’t implement the
    customized __init__ in the Supervisor class; I leave that task for section 8.5.6
    instead.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解超类和子类是如何一起工作的，让我们继续使用员工-主管的例子。请首先阅读下一列表中的代码。我们在Supervisor类中没有实现自定义的__init__；我将其任务留给了8.5.6节。
- en: Listing 8.12 Basic structure of a superclass and subclasses
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 列表8.12 超类和子类的基本结构
- en: '[PRE46]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'When you define a subclass, you specify the superclass in parentheses following
    the class’s name. Here, the superclass is Employee, so we place it after Supervisor.
    Notably, the subclass Supervisor automatically inherits everything from its superclass
    Employee, including its initialization and other methods. We can observe this
    feature in the following code snippet:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 当你定义一个子类时，你指定超类在类名后面的括号中。在这里，超类是Employee，所以我们将其放在Supervisor之后。值得注意的是，子类Supervisor自动从其超类Employee继承一切，包括其初始化和其他方法。我们可以在以下代码片段中观察到这一特性：
- en: '[PRE47]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: As you can see, we create an instance by calling Supervisor("John", "1001").
    The body of the Supervisor class uses only the pass statement. Supervisor supports
    instantiation, but the created instance object has attributes and methods because
    the Supervisor class inherits from the Employee class.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们通过调用Supervisor("John", "1001")创建了一个实例。Supervisor类的主体只使用了pass语句。Supervisor支持实例化，但创建的实例对象具有属性和方法，因为Supervisor类从Employee类继承而来。
- en: From a general perspective, when your subclasses have the same attributes and
    methods as the superclass, you don’t need to provide any implementation in the
    subclass, as the subclass automatically gains all the attributes and methods from
    the superclass.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 从一般的角度来看，当你的子类与超类具有相同的属性和方法时，你不需要在子类中提供任何实现，因为子类会自动从超类获得所有属性和方法。
- en: 8.5.3 Overriding the superclass's methods to provide customized behaviors
  id: totrans-289
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.5.3 覆盖超类的方法以提供定制行为
- en: In section 8.5.2, you learned that subclasses automatically inherit all attributes
    and methods from the superclass. Sometimes, however, you want to provide customized
    behaviors to a subclass. In this section, you’ll learn how to override a superclass’s
    method to provide specific implementations to a subclass.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在8.5.2节中，你了解到子类会自动从超类继承所有属性和方法。然而，有时你可能想要为子类提供定制的功能。在本节中，你将学习如何覆盖超类的方法，为子类提供特定的实现。
- en: Overriding a method completely
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 完全覆盖方法
- en: 'You can override a superclass’s method completely. Unlike some OOP languages,
    in which you may have to use the override keyword, Python allows you to define
    the same method with a distinct implementation from the superclass. Let’s use
    the login method as an example:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以完全覆盖超类的方法。与一些需要使用覆盖关键字的重写某些面向对象语言不同，Python 允许你使用与超类不同的实现来定义相同的方法。让我们以登录方法为例：
- en: '[PRE48]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'With this updated login method in the subclass, we can see that the instance
    of the Supervisor class will call the login method of the subclass instead of
    that of the superclass:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在子类中更新了登录方法后，我们可以看到Supervisor类的实例将调用子类的登录方法，而不是超类的登录方法：
- en: '[PRE49]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We don’t have a customized implementation for the logout method. As you can
    expect, if we call logout on the instance, the Employee class’s logout implementation
    will be triggered. How does Python determine which implementation it should use?
    The answer pertains to an important concept: *method resolution order* (MRO),
    which dictates the order of using a specific implementation of a method in a hierarchical
    class structure.'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有为注销方法提供定制实现。正如您所预料的，如果我们对实例调用注销，将触发Employee类的注销实现。Python是如何确定应该使用哪个实现的呢？答案涉及一个重要的概念：*方法解析顺序*（MRO），它决定了在层次类结构中特定方法实现的顺序。
- en: Concept MRO determines how a method or an attribute of an instance is evaluated
    in an inherited class structure.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 概念：MRO决定了在继承类结构中实例的方法或属性是如何被评估的。
- en: 'Because Python supports multiple inheritance—a class inherits from multiple
    classes—the MRO in multiple inheritance is more complicated. Here, let’s focus
    on the most common scenario: a subclass with only one superclass. Figure 8.10
    illustrates how the MRO works. Please note that when you define a class that has
    no explicit superclass, Python uses the object class as its superclass—in the
    case of Employee, a subclass of object.'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Python支持多重继承——一个类可以继承多个类——多重继承中的MRO更为复杂。在这里，让我们关注最常见的情况：只有一个超类的子类。图8.10说明了MRO是如何工作的。请注意，当你定义一个没有显式超类的类时，Python使用object类作为其超类——在Employee的情况下，object的一个子类。
- en: '![CH08_F10_Cui](../Images/CH08_F10_Cui.png)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
  zh: '![CH08_F10_Cui](../Images/CH08_F10_Cui.png)'
- en: Figure 8.10 MRO in a hierarchical class structure. When you call a method on
    an instance, Python checks the method with its class first. If the method is resolved,
    apply the implementation. If not, move up to its superclass. If it’s still not,
    move up to the object superclass, trying to resolve the method. If the method
    is still not resolved, raise the AttributeError exception. If there are more levels
    for the class inheritance structure, every level is checked.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.10 层次类结构中的MRO。当你对一个实例调用方法时，Python首先检查其类中的方法。如果方法被解析，则应用该实现。如果没有解析，则向上移动到其超类。如果仍然没有，则向上移动到对象超类，尝试解析该方法。如果方法仍然没有解析，则引发AttributeError异常。如果类继承结构有更多层级，则每个层级都会被检查。
- en: 'When you call a method on an instance, the instance object has an established
    MRO through its class, which you can inspect with the mro method:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在实例上调用一个方法时，实例对象通过其类有一个已建立的 MRO（方法解析顺序），你可以使用 mro 方法来检查：
- en: '[PRE50]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: As you can see, the resolution order is Supervisor -> Employee -> object. That
    is, following this order, if the method is found to be implemented in any class,
    it’s resolved and evaluated. If all the classes are examined without resolving
    the method, the AttributeError exception is raised.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，解析顺序是 Supervisor -> Employee -> object。也就是说，按照这个顺序，如果在任何类中找到了方法的实现，它就会被解析和评估。如果检查了所有类而没有解析到方法，则会引发
    AttributeError 异常。
- en: Overriding a method partially
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 部分重写方法
- en: You don’t always want a different implementation for a method from the superclass.
    Instead, you want to keep the implementation of the superclass, on top of which
    you apply additional customization. In this case, we’re saying that we’re overriding
    a method partially.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 你并不总是希望对超类中的方法有不同的实现。相反，你希望保留超类的实现，并在其基础上应用额外的定制。在这种情况下，我们是在部分重写一个方法。
- en: 'This time, consider the logout method. Besides the superclass’s implementation,
    we want to apply a customized behavior that is specific to a supervisor—for simplicity,
    showing the message Additional logout actions for a supervisor. The following
    code snippet shows how we should implement this behavior:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，考虑注销方法。除了超类的实现之外，我们希望应用一个特定于管理员的定制行为——为了简单起见，显示“Additional logout actions
    for a supervisor”的消息。以下代码片段展示了我们应该如何实现这个行为：
- en: '[PRE51]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The most significant thing to note is that we use super() as a reference to
    the superclass to create a proxy object of the superclass. From a conceptual perspective,
    you can think of super() as being a temporary instance object of the superclass,
    allowing us to call the superclass’s logout method on this object. With this partially
    overridden logout method, what output do you expect? The following is the result:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是要注意，我们使用 super() 作为对超类的引用来创建一个超类的代理对象。从概念上讲，你可以将 super() 视为一个超类的临时实例对象，允许我们在该对象上调用超类的
    logout 方法。有了这个部分重写的 logout 方法，你期望什么输出？以下就是结果：
- en: '[PRE52]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: From the output, we can see that calling logout on the supervisor instance invokes
    not only the Employee class’s logout method through super().logout(), but also
    the additional customized implementation in the Supervisor’s logout method.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中，我们可以看到，在管理员实例上调用 logout 不仅通过 super().logout() 调用了 Employee 类的 logout 方法，还调用了
    Supervisor 的 logout 方法中的额外定制实现。
- en: 8.5.4 Creating non-public methods of the superclass
  id: totrans-311
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.5.4 创建超类的非公共方法
- en: 'In section 8.3, we introduced two nonpublic attributes/methods: protected and
    private. Besides their naming difference (prefix with one underscore versus two
    underscores), we also mentioned that they differ in their accessibility in a subclass.
    In this section, we’ll observe this difference and see when to create a protected
    or a private method from the class inheritance perspective.'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在 8.3 节中，我们介绍了两个非公共属性/方法：受保护的和私有的。除了它们的命名差异（一个下划线前缀与两个下划线前缀）之外，我们还提到它们在子类中的可访问性不同。在本节中，我们将观察这种差异，并从类继承的角度看何时创建受保护的或私有方法。
- en: 'To begin, assume that our superclass Employee has the following implementation.
    Besides the initialization method, we define one protected method, _request_ vacation,
    and one private method, __transfer_group:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，假设我们的超类 Employee 有以下实现。除了初始化方法外，我们定义了一个受保护的成员方法 _request_vacation 和一个私有方法
    __transfer_group：
- en: '[PRE53]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We are ready to create a subclass Supervisor that inherits from Employee. To
    illustrate the difference between protected and private in terms of accessibility
    within a subclass, let’s try accessing these nonpublic methods within Supervisor:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 我们准备好创建一个继承自 Employee 的子类 Supervisor。为了说明在子类中受保护和私有在可访问性方面的差异，让我们尝试在 Supervisor
    中访问这些非公共方法：
- en: '[PRE54]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'In this subclass, we define an instance method do_something, within which we
    call _request_vacation and __transfer_group. What do you expect will happen if
    you call do_something? Give yourself a few moments to think. Remember that subclasses
    inherit protected methods. If you’re ready, here’s the answer:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个子类中，我们定义了一个实例方法 do_something，在其中我们调用了 _request_vacation 和 __transfer_group。当你调用
    do_something 时，你期望会发生什么？给自己一些时间思考。记住，子类继承了受保护的成员方法。如果你准备好了，这里就是答案：
- en: '[PRE55]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: As you can see, _request_vacation is successfully invoked, which is expected.
    But __transfer_group can’t be invoked because using the double underscores as
    the prefix triggers name mangling. Instead of trying to call __transfer_group,
    Python tries to call _Supervisor__transfer_group, a method that is not defined
    in Supervisor!
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，_request_vacation被成功调用，这是预期的。但是__transfer_group无法被调用，因为使用双下划线作为前缀触发了名称改写。因此，不要尝试调用__transfer_group，Python会尝试调用_Supervisor__transfer_group，这是一个在Supervisor中未定义的方法！
- en: 'Given their different accessibility within subclasses, you should define nonpublic
    methods based on this principle: if you expect that the subclasses should have
    access to the nonpublic methods, you should define protected methods, which the
    subclasses can inherit. If you expect that the subclasses should have no access
    to the nonpublic methods, you should define private methods.'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到子类中不同的可访问性，你应该根据以下原则定义非公开方法：如果你期望子类应该能够访问非公开方法，你应该定义受保护的方法，子类可以继承这些方法。如果你期望子类不应该访问非公开方法，你应该定义私有方法。
- en: 8.5.5 Discussion
  id: totrans-321
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.5.5 讨论
- en: 'Creating a hierarchical class structure is an essential technique in the OOP
    world, and it’s a critical skill for building a clean, maintainable codebase.
    The superclass is responsible for handling attributes and methods that are shared
    among its subclasses. Instead of handling methods in multiple locations if you
    define the same methods in similar classes, you need to maintain these methods
    in only one place: the superclass.'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象的世界中，创建分层类结构是一种基本技术，并且对于构建干净、可维护的代码库来说是一项关键技能。超类负责处理在其子类之间共享的属性和方法。如果你在类似类中定义相同的方法，而不是在多个位置处理方法，你需要只在超类中维护这些方法。
- en: You should realize that creating a hierarchical class structure has a price.
    Because subclasses depend on the behaviors of the superclass, this interrelationship
    or tight coupling can make it tricky or hard to update your codebase. When you
    want to add something to a subclass, you may also need to update its superclass.
    Thus, in your project, it’s better to use flatter data models. If you notice overlapping
    functionalities between classes, however, don’t hesitate to implement superclasses
    and subclasses.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该意识到创建分层类结构是有代价的。因为子类依赖于超类的行为，这种相互关系或紧密耦合可能会使代码库的更新变得棘手或困难。当你想要向子类添加内容时，你可能还需要更新其超类。因此，在你的项目中，最好使用更扁平的数据模型。然而，如果你注意到类之间存在重叠的功能，则不妨实现超类和子类。
- en: 8.5.6 Challenge
  id: totrans-324
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.5.6 挑战
- en: In section 8.1, we studied how to implement the __init__ method in a custom
    class. If the subclass has the same implementation as the superclass, you don’t
    need to override __init__ at all. But if you need customized initialization, as
    in the case of Supervisor, you want to override __init__. How can you override
    __init__ in the Supervisor class?
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在8.1节中，我们学习了如何在自定义类中实现__init__方法。如果子类与超类有相同的实现，你根本不需要重写__init__。但是，如果你需要定制的初始化，就像Supervisor的情况一样，你想要重写__init__。你如何在Supervisor类中重写__init__？
- en: Hint Overriding __init__ isn’t different from overriding other methods. You
    use super() to create a proxy object to use the constructor of the superclass.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 提示重写__init__与其他方法的重写没有区别。你使用super()创建一个代理对象来使用超类的构造函数。
- en: Summary
  id: totrans-327
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概述
- en: Your class should have __init__ as the first method, and it should initialize
    all attributes of an instance, even if some attributes have a value of None.
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的类应该将__init__作为第一个方法，并初始化实例的所有属性，即使某些属性的值为None。
- en: The initialization method __init__ is an instance method, which uses self as
    its first parameter. You should know how things work behind the scenes—how an
    instance is created from calling the constructor.
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化方法__init__是一个实例方法，它使用self作为其第一个参数。你应该了解幕后的事情——如何通过调用构造函数来创建实例。
- en: When all the instances share the same attribute values, you should define them
    as class attributes, which helps save memory.
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当所有实例共享相同的属性值时，你应该将它们定义为类属性，这有助于节省内存。
- en: 'In general, you can define three kinds of methods in a class: instance (note
    that the first parameter is self), static (using the @staticmethod decorator),
    and class (using the @classmethod decorator). You should know how these methods
    differ and when to use which.'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常情况下，你可以在类中定义三种方法：实例方法（注意第一个参数是self），静态方法（使用@staticmethod装饰器），以及类方法（使用@classmethod装饰器）。你应该了解这些方法之间的区别以及何时使用哪种方法。
- en: When you define a class, consider minimizing the attributes and methods that
    the users need access to. By “hiding” them, such as by defining protected and
    private methods, you help users increase their coding efficiency because they
    don’t need to bother with these nonpublic methods in the autocompletion hint list.
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你定义一个类时，考虑最小化用户需要访问的属性和方法。通过“隐藏”它们，例如通过定义受保护的和私有方法，你帮助用户提高他们的编码效率，因为他们不需要在自动完成提示列表中烦恼这些非公开方法。
- en: The property decorator allows you to create a read-only property, which helps
    you create data integrity by disallowing data change. If you want to allow users
    to change the property, you can create a setter for the property, which is also
    an opportunity for you to verify data integrity in the setter.
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性装饰器允许你创建一个只读属性，这有助于你通过不允许数据更改来创建数据完整性。如果你想允许用户更改属性，你可以为属性创建一个设置器，这也是你验证数据完整性的机会。
- en: When you define a class, you want to override both __str__ and __repr__ so that
    you can provide proper string representations for users and developers.
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你定义一个类时，你希望重写`__str__`和`__repr__`，以便为用户和开发者提供适当的字符串表示。
- en: Creating a hierarchical class structure helps you manage your data when there
    are similarities between data models. The shared data can go to the superclass,
    making it easier to develop and maintain your codebase.
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个分层类结构有助于你在数据模型之间存在相似性时管理你的数据。共享的数据可以放入超类中，这使得开发和维护代码库变得更加容易。
- en: Think twice before you create a hierarchical class structure because you may
    overcomplicate your data models by dealing with superclasses and subclasses.
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在创建分层类结构之前三思而后行，因为你可能通过处理超类和子类而使你的数据模型过于复杂。
