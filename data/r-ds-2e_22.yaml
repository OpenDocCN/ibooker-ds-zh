- en: Chapter 19\. Joins
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第19章. 连接
- en: Introduction
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: 'It’s rare that a data analysis involves only a single data frame. Typically
    you have many data frames, and you must *join* them together to answer the questions
    that you’re interested in. This chapter will introduce you to two important types
    of joins:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 数据分析很少仅涉及单个数据框。通常情况下，您会有多个数据框，并且必须将它们连接在一起以回答您感兴趣的问题。本章将向您介绍两种重要的连接类型：
- en: Mutating joins, which add new variables to one data frame from matching observations
    in another.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变异连接是一种操作，它会从另一个数据框中匹配的观测中向一个数据框中添加新变量。
- en: Filtering joins, which filter observations from one data frame based on whether
    they match an observation in another.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过滤连接是一种操作，它根据是否与另一个数据框中的观测相匹配来过滤观测。
- en: We’ll begin by discussing keys, the variables used to connect a pair of data
    frames in a join. We cement the theory with an examination of the keys in the
    datasets from the nycflights13 package and then use that knowledge to start joining
    data frames together. Next we’ll discuss how joins work, focusing on their action
    on the rows. We’ll finish up with a discussion of non-equi joins, a family of
    joins that provide a more flexible way of matching keys than the default equality
    relationship.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从讨论键开始，这些变量用于在连接操作中连接一对数据框。我们将通过检查来自 nycflights13 包中数据集中的键来巩固理论，并利用这些知识开始将数据框连接在一起。接下来，我们将讨论连接操作的工作原理，重点放在它们对行的影响上。最后，我们将讨论非等连接，这是一组提供更灵活的键匹配方式的连接操作，不同于默认的等式关系。
- en: Prerequisites
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 先决条件
- en: In this chapter, we’ll explore the five related datasets from nycflights13 using
    the join functions from dplyr.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用 dplyr 中的连接函数来探索来自 nycflights13 的五个相关数据集。
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Keys
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 键
- en: To understand joins, you need to first understand how two tables can be connected
    through a pair of keys, within each table. In this section, you’ll learn about
    the two types of key and see examples of both in the datasets of the nycflights13
    package. You’ll also learn how to check that your keys are valid and what to do
    if your table lacks a key.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解连接操作，首先需要了解如何通过两个表中的一对键连接它们。在本节中，您将学习关于两种类型的键的知识，并在 nycflights13 数据集中看到具体示例。您还将学习如何验证您的键是否有效，以及在表中缺少键时该如何处理。
- en: Primary and Foreign Keys
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主键和外键
- en: 'Every join involves a pair of keys: a primary key and a foreign key. A *primary
    key* is a variable or set of variables that uniquely identifies each observation.
    When more than one variable is needed, the key is called a *compound key*. For
    example, in nycflights13:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 每个连接都涉及一对键：一个主键和一个外键。*主键* 是一个变量或一组变量，可以唯一标识每个观测。当需要多个变量时，这个键被称为*复合键*。例如，在 nycflights13
    中：
- en: '`airlines` records two pieces of data about each airline: its carrier code
    and its full name. You can identify an airline with its two-letter carrier code,
    making `carrier` the primary key.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`airlines` 记录了每家航空公司的两个数据：其运营代码和全称。您可以通过两字母运营代码来识别每家航空公司，使 `carrier` 成为主键。'
- en: '[PRE1]'
  id: totrans-14
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`airports` records data about each airport. You can identify each airport by
    its three-letter airport code, making `faa` the primary key.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`airports` 记录了每个机场的数据。您可以通过三字母机场代码来识别每个机场，使 `faa` 成为主键。'
- en: '[PRE2]'
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`planes` records data about each plane. You can identify a plane by its tail
    number, making `tailnum` the primary key.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`planes` 记录了每架飞机的数据。您可以通过其尾号来识别一架飞机，从而使 `tailnum` 成为主键。'
- en: '[PRE3]'
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`weather` records data about the weather at the origin airports. You can identify
    each observation by the combination of location and time, making `origin` and
    `time_hour` the compound primary key.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`weather` 记录了起飞机场的天气数据。您可以通过位置和时间的组合来识别每个观测，从而使 `origin` 和 `time_hour` 成为复合主键。'
- en: '[PRE4]'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'A *foreign key* is a variable (or set of variables) that corresponds to a primary
    key in another table. For example:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*外键* 是一个变量（或一组变量），对应于另一张表中的主键。例如：'
- en: '`flights$tailnum` is a foreign key that corresponds to the primary key `planes$tailnum`.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flights$tailnum` 是一个外键，对应于主键 `planes$tailnum`。'
- en: '`flights$carrier` is a foreign key that corresponds to the primary key `airlines$carrier`.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flights$carrier` 是一个外键，对应于主键 `airlines$carrier`。'
- en: '`flights$origin` is a foreign key that corresponds to the primary key `airports$faa`.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flights$origin` 是一个外键，对应于主键 `airports$faa`。'
- en: '`flights$dest` is a foreign key that corresponds to the primary key `airports$faa`.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flights$dest` 是一个外键，对应于主键 `airports$faa`。'
- en: '`flights$origin`-`flights$time_hour` is a compound foreign key that corresponds
    to the compound primary key `weather$origin`-`weather$time_hour`.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flights$origin`-`flights$time_hour` 是对应于 `weather$origin`-`weather$time_hour`
    复合主键的复合外键。'
- en: These relationships are summarized visually in [Figure 19-1](#fig-flights-relationships).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这些关系在[图19-1](#fig-flights-relationships)中以视觉方式总结。
- en: '![The relationships between airports, planes, flights, weather, and airlines
    datasets from the nycflights13 package. airports$faa connected to the flights$origin
    and flights$dest. planes$tailnum is connected to the flights$tailnum. weather$time_hour
    and weather$origin are jointly connected to flights$time_hour and flights$origin.
    airlines$carrier is connected to flights$carrier. There are no direct connections
    between airports, planes, airlines, and weather data frames.](assets/rds2_1901.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![nycflights13 包中 airports、planes、flights、weather 和 airlines 数据集之间的关系。airports$faa
    连接到 flights$origin 和 flights$dest。planes$tailnum 连接到 flights$tailnum。weather$time_hour
    和 weather$origin 共同连接到 flights$time_hour 和 flights$origin。airlines$carrier 连接到
    flights$carrier。airports、planes、airlines 和 weather 数据框之间没有直接连接。](assets/rds2_1901.png)'
- en: Figure 19-1\. Connections between all five data frames in the nycflights13 package.
    Variables making up a primary key are gray and are connected to their corresponding
    foreign keys with arrows.
  id: totrans-29
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图19-1\. nycflights13 包中所有五个数据框之间的连接。构成主键的变量为灰色，并用箭头连接到其对应的外键。
- en: 'You’ll notice a nice feature in the design of these keys: the primary and foreign
    keys almost always have the same names, which, as you’ll see shortly, will make
    your joining life much easier. It’s also worth noting the opposite relationship:
    almost every variable name used in multiple tables has the same meaning in each
    place. There’s only one exception: `year` means year of departure in `flights`
    and year of manufacturer in `planes`. This will become important when we start
    actually joining tables together.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到这些键设计中的一个好特点：主键和外键几乎总是具有相同的名称，这将在稍后使得连接更加容易。还值得注意的是相反的关系：几乎每个在多个表中使用的变量名称在每个地方的含义都相同。只有一个例外：`year`在`flights`中表示起飞年份，在`planes`中表示制造年份。这在我们开始实际连接表格时将变得重要。
- en: Checking Primary Keys
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查主键
- en: 'Now that that we’ve identified the primary keys in each table, it’s good practice
    to verify that they do indeed uniquely identify each observation. One way to do
    that is to [`count()`](https://dplyr.tidyverse.org/reference/count.xhtml) the
    primary keys and look for entries where `n` is greater than one. This reveals
    that `planes` and `weather` both look good:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经确定了每个表中的主键，验证它们确实可以唯一标识每个观察值是一个好习惯。一种方法是使用[`count()`](https://dplyr.tidyverse.org/reference/count.xhtml)计算主键，并查找`n`大于一的条目。这显示`planes`和`weather`看起来都不错：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You should also check for missing values in your primary keys—if a value is
    missing, then it can’t identify an observation!
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 您还应该检查主键中是否有缺失值——如果值丢失，那么它无法标识一个观察值！
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Surrogate Keys
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代理键
- en: So far we haven’t talked about the primary key for `flights`. It’s not super
    important here, because there are no data frames that use it as a foreign key,
    but it’s still useful to consider because it’s easier to work with observations
    if we have some way to describe them to others.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们还没有讨论`flights`的主键。在这里它并不是特别重要，因为没有数据框将其用作外键，但仍然有必要考虑，因为如果我们有一些方法可以向其他人描述观察值，那么工作起来会更容易。
- en: 'After a little thinking and experimentation, we determined that there are three
    variables that together uniquely identify each flight:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 经过一点思考和实验，我们确定有三个变量联合唯一标识每次航班：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Does the absence of duplicates automatically make `time_hour`-`carrier`-`flight`
    a primary key? It’s certainly a good start, but it doesn’t guarantee it. For example,
    are altitude and latitude a good primary key for `airports`?
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 缺少重复项是否自动使`time_hour`-`carrier`-`flight`成为主键？这当然是个好开始，但不能保证。例如，海拔和纬度是否适合作为`airports`的主键？
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Identifying an airport by its altitude and latitude is clearly a bad idea, and
    in general it’s not possible to know from the data alone whether a combination
    of variables makes a good primary key. But for flights, the combination of `time_hour`,
    `carrier`, and `flight` seems reasonable because it would be really confusing
    for an airline and its customers if there were multiple flights with the same
    flight number in the air at the same time.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 通过海拔和纬度来识别机场显然是个坏主意，总体而言，仅凭数据无法知道组合变量是否构成一个良好的主键。但对于航班来说，`time_hour`、`carrier`和`flight`的组合似乎是合理的，因为如果有多个相同航班号的航班同时在空中，对航空公司及其乘客来说会非常混乱。
- en: 'That said, we might be better off introducing a simple numeric surrogate key
    using the row number:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，引入一个简单的数值代理键，使用行号：
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Surrogate keys can be particularly useful when communicating to other humans:
    it’s much easier to tell someone to take a look at flight 2001 than to say look
    at UA430, which departed at 9 a.m. on January 3, 2013.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当与其他人沟通时，代理键特别有用：告诉别人查看2001航班要比说查看2013年1月3日上午9点起飞的UA430航班容易得多。
- en: Exercises
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: We forgot to draw the relationship between `weather` and `airports` in [Figure 19-1](#fig-flights-relationships).
    What is the relationship, and how should it appear in the diagram?
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们忘记在[图19-1](#fig-flights-relationships)中绘制`weather`和`airports`之间的关系。这种关系是什么，图示应该如何呈现？
- en: '`weather` contains information for only the three origin airports in NYC. If
    it contained weather records for all airports in the US, what additional connection
    would it make to `flights`?'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`weather`仅包含纽约市三个起飞机场的信息。如果它包含了美国所有机场的天气记录，它将对`flights`有什么额外的连接？'
- en: The `year`, `month`, `day`, `hour`, and `origin` variables almost form a compound
    key for `weather`, but there’s one hour that has duplicate observations. Can you
    figure out what’s special about that hour?
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`year`、`month`、`day`、`hour`和`origin`变量几乎形成了`weather`的复合键，但有一个小时有重复的观测值。你能找出这个小时有什么特别之处吗？'
- en: We know that some days of the year are special and fewer people than usual fly
    on them (e.g., Christmas Eve and Christmas Day). How might you represent that
    data as a data frame? What would be the primary key? How would it connect to the
    existing data frames?
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们知道一年中有些特别的日子，人们会比平常少乘坐飞机（例如，圣诞节前夕和圣诞节）。你会如何将这些数据表示为一个数据框？主键将是什么？它将如何连接到现有的数据框？
- en: Draw a diagram illustrating the connections between the `Batting`, `People`,
    and `Salaries` data frames in the Lahman package. Draw another diagram that shows
    the relationship between `People`, `Managers`, and `AwardsManagers`. How would
    you characterize the relationship between the `Batting`, `Pitching`, and `Fielding`
    data frames?
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绘制一个图示，展示`Batting`、`People`和`Salaries`数据框之间的连接。再画一个图示，展示`People`、`Managers`和`AwardsManagers`之间的关系。你如何描述`Batting`、`Pitching`和`Fielding`数据框之间的关系？
- en: Basic Joins
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本连接
- en: 'Now that you understand how data frames are connected via keys, we can start
    using joins to better understand the `flights` dataset. dplyr provides six join
    functions:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你了解了如何通过键连接数据框，我们可以开始使用连接操作更好地理解`flights`数据集。dplyr提供了六个连接函数：
- en: '[`left_join()`](https://dplyr.tidyverse.org/reference/mutate-joins.xhtml)'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`left_join()`](https://dplyr.tidyverse.org/reference/mutate-joins.xhtml)'
- en: '[`inner_join()`](https://dplyr.tidyverse.org/reference/mutate-joins.xhtml)'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`inner_join()`](https://dplyr.tidyverse.org/reference/mutate-joins.xhtml)'
- en: '[`right_join()`](https://dplyr.tidyverse.org/reference/mutate-joins.xhtml)'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`right_join()`](https://dplyr.tidyverse.org/reference/mutate-joins.xhtml)'
- en: '[`full_join()`](https://dplyr.tidyverse.org/reference/mutate-joins.xhtml)'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`full_join()`](https://dplyr.tidyverse.org/reference/mutate-joins.xhtml)'
- en: '[`semi_join()`](https://dplyr.tidyverse.org/reference/filter-joins.xhtml)'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`semi_join()`](https://dplyr.tidyverse.org/reference/filter-joins.xhtml)'
- en: '[`anti_join()`](https://dplyr.tidyverse.org/reference/filter-joins.xhtml)'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`anti_join()`](https://dplyr.tidyverse.org/reference/filter-joins.xhtml)'
- en: 'They all have the same interface: they take a pair of data frames (`x` and
    `y`) and return a data frame. The order of the rows and columns in the output
    is primarily determined by `x`.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 它们都有相同的接口：它们接受一对数据框（`x`和`y`），并返回一个数据框。输出中的行和列的顺序主要由`x`决定。
- en: In this section, you’ll learn how to use one mutating join, [`left_join()`](https://dplyr.tidyverse.org/reference/mutate-joins.xhtml),
    and two filtering joins, [`semi_join()`](https://dplyr.tidyverse.org/reference/filter-joins.xhtml)
    and [`anti_join()`](https://dplyr.tidyverse.org/reference/filter-joins.xhtml).
    In the next section, you’ll learn exactly how these functions work and about the
    remaining [`inner_join()`](https://dplyr.tidyverse.org/reference/mutate-joins.xhtml),
    [`right_join()`](https://dplyr.tidyverse.org/reference/mutate-joins.xhtml), and
    [`full_join()`](https://dplyr.tidyverse.org/reference/mutate-joins.xhtml).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将学习如何使用一个变异连接[`left_join()`](https://dplyr.tidyverse.org/reference/mutate-joins.xhtml)，以及两个过滤连接[`semi_join()`](https://dplyr.tidyverse.org/reference/filter-joins.xhtml)和[`anti_join()`](https://dplyr.tidyverse.org/reference/filter-joins.xhtml)。在下一节中，您将了解这些函数的确切工作方式，以及关于剩余的[`inner_join()`](https://dplyr.tidyverse.org/reference/mutate-joins.xhtml)、[`right_join()`](https://dplyr.tidyverse.org/reference/mutate-joins.xhtml)和[`full_join()`](https://dplyr.tidyverse.org/reference/mutate-joins.xhtml)。
- en: Mutating Joins
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变异连接
- en: 'A *mutating join* allows you to combine variables from two data frames: it
    first matches observations by their keys and then copies across variables from
    one data frame to the other. Like [`mutate()`](https://dplyr.tidyverse.org/reference/mutate.xhtml),
    the join functions add variables to the right, so if your dataset has many variables,
    you won’t see the new ones. For these examples, we’ll make it easier to see what’s
    going on by creating a narrower dataset with just six variables:^([1](ch19.xhtml#idm44771284613936))'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*变异连接*允许您从两个数据框中合并变量：它首先通过它们的键匹配观测值，然后从一个数据框复制变量到另一个数据框。与[`mutate()`](https://dplyr.tidyverse.org/reference/mutate.xhtml)类似，连接函数将变量添加到右侧，因此如果您的数据集有很多变量，您将看不到新变量。为了这些示例，我们将创建一个只有六个变量的更窄的数据集，以便更容易看到发生了什么：^([1](ch19.xhtml#idm44771284613936))'
- en: '[PRE10]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'There are four types of mutating join, but there’s one that you’ll use almost
    all of the time: [`left_join()`](https://dplyr.tidyverse.org/reference/mutate-joins.xhtml).
    It’s special because the output will always have the same rows as `x`.^([2](ch19.xhtml#idm44771284529504))
    The primary use of [`left_join()`](https://dplyr.tidyverse.org/reference/mutate-joins.xhtml)
    is to add additional metadata. For example, we can use [`left_join()`](https://dplyr.tidyverse.org/reference/mutate-joins.xhtml)
    to add the full airline name to the `flights2` data:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 有四种类型的变异连接，但几乎所有时间您都会使用一种：[`left_join()`](https://dplyr.tidyverse.org/reference/mutate-joins.xhtml)。它很特别，因为输出将始终与`x`具有相同的行。^([2](ch19.xhtml#idm44771284529504))
    [`left_join()`](https://dplyr.tidyverse.org/reference/mutate-joins.xhtml)的主要用途是添加额外的元数据。例如，我们可以使用[`left_join()`](https://dplyr.tidyverse.org/reference/mutate-joins.xhtml)将完整的航空公司名称添加到`flights2`数据中：
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Or we could find out the temperature and wind speed when each plane departed:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 或者我们可以找出每架飞机起飞时的温度和风速：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Or what size of plane was flying:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 或者飞机的尺寸是多少：
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'When [`left_join()`](https://dplyr.tidyverse.org/reference/mutate-joins.xhtml)
    fails to find a match for a row in `x`, it fills in the new variables with missing
    values. For example, there’s no information about the plane with tail number `N3ALAA`
    so the `type`, `engines`, and `seats` will be missing:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 当[`left_join()`](https://dplyr.tidyverse.org/reference/mutate-joins.xhtml)无法在`x`中找到某一行的匹配时，它会用缺失值填充新变量。例如，关于机尾号为`N3ALAA`的飞机没有信息，因此`type`、`engines`和`seats`将会缺失：
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We’ll come back to this problem a few times in the rest of the chapter.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章的其余部分多次回到这个问题。
- en: Specifying Join Keys
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指定连接键
- en: By default, [`left_join()`](https://dplyr.tidyverse.org/reference/mutate-joins.xhtml)
    will use all variables that appear in both data frames as the join key, the so-called
    *natural* join. This is a useful heuristic, but it doesn’t always work. For example,
    what happens if we try to join `flights2` with the complete `planes` dataset?
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，[`left_join()`](https://dplyr.tidyverse.org/reference/mutate-joins.xhtml)将使用两个数据框中出现的所有变量作为连接键，即所谓的*自然*连接。这是一种有用的启发式方法，但并不总是有效。例如，如果我们尝试使用完整的`planes`数据集来连接`flights2`会发生什么？
- en: '[PRE15]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We get a lot of missing matches because our join is trying to use `tailnum`
    and `year` as a compound key. Both `flights` and `planes` have a `year` column,
    but they mean different things: `flights$year` is the year the flight occurred,
    and `planes$year` is the year the plane was built. We only want to join on `tailnum`,
    so we need to provide an explicit specification with [`join_by()`](https://dplyr.tidyverse.org/reference/join_by.xhtml):'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到很多缺失的匹配，因为我们的连接尝试使用 `tailnum` 和 `year` 作为复合键。`flights` 和 `planes` 都有一个 `year`
    列，但它们的含义不同：`flights$year` 是飞行发生的年份，而 `planes$year` 是飞机建造的年份。我们只想在 `tailnum` 上进行连接，因此我们需要使用
    [`join_by()`](https://dplyr.tidyverse.org/reference/join_by.xhtml) 提供显式规范：
- en: '[PRE16]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note that the `year` variables are disambiguated in the output with a suffix
    (`year.x` and `year.y`), which tells you whether the variable came from the `x`
    or `y` argument. You can override the default suffixes with the `suffix` argument.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 注意输出中的 `year` 变量使用后缀（`year.x` 和 `year.y`）进行消歧义，告诉您变量是来自 `x` 还是 `y` 参数。您可以使用
    `suffix` 参数覆盖默认后缀。
- en: '`join_by(tailnum)` is short for `join_by(tailnum == tailnum)`. It’s important
    to know about this fuller form for two reasons. First, it describes the relationship
    between the two tables: the keys must be equal. That’s why this type of join is
    often called an *equi join*. You’ll learn about non-equi joins in [“Filtering
    Joins”](#sec-non-equi-joins).'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`join_by(tailnum)` 是 `join_by(tailnum == tailnum)` 的简写。了解这种更完整的形式有两个原因很重要。首先，它描述了两个表之间的关系：键必须相等。这就是为什么这种连接通常被称为*等连接*。您将在[“过滤连接”](#sec-non-equi-joins)中了解非等连接。'
- en: 'Second, it’s how you specify different join keys in each table. For example,
    there are two ways to join the `flight2` and `airports` table: either by `dest`
    or by `origin`:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，这是您如何在每个表中指定不同的连接键。例如，有两种方法可以将 `flight2` 表和 `airports` 表连接起来：要么通过 `dest`，要么通过
    `origin`：
- en: '[PRE17]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In older code you might see a different way of specifying the join keys, using
    a character vector:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在旧代码中，您可能会看到使用字符向量指定连接键的不同方法：
- en: '`by = "x"` corresponds to `join_by(x)`.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`by = "x"` 对应于 `join_by(x)`。'
- en: '`by = c("a" = "x")` corresponds to `join_by(a == x)`.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`by = c("a" = "x")` 对应于 `join_by(a == x)`。'
- en: Now that it exists, we prefer [`join_by()`](https://dplyr.tidyverse.org/reference/join_by.xhtml)
    since it provides a clearer and more flexible specification.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在有了 [`join_by()`](https://dplyr.tidyverse.org/reference/join_by.xhtml)，我们更喜欢它，因为它提供了更清晰和更灵活的规范。
- en: '[`inner_join()`](https://dplyr.tidyverse.org/reference/mutate-joins.xhtml),
    [`right_join()`](https://dplyr.tidyverse.org/reference/mutate-joins.xhtml), and
    [`full_join()`](https://dplyr.tidyverse.org/reference/mutate-joins.xhtml) have
    the same interface as [`left_join()`](https://dplyr.tidyverse.org/reference/mutate-joins.xhtml).
    The difference is which rows they keep: left join keeps all the rows in `x`, the
    right join keeps all rows in `y`, the full join keeps all rows in either `x` or
    `y`, and the inner join keeps only those rows that occur in both `x` and `y`.
    We’ll come back to these in more detail later.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '[`inner_join()`](https://dplyr.tidyverse.org/reference/mutate-joins.xhtml)，[`right_join()`](https://dplyr.tidyverse.org/reference/mutate-joins.xhtml)
    和 [`full_join()`](https://dplyr.tidyverse.org/reference/mutate-joins.xhtml) 与
    [`left_join()`](https://dplyr.tidyverse.org/reference/mutate-joins.xhtml) 拥有相同的接口。它们之间的区别在于它们保留的行数：左连接保留
    `x` 中的所有行，右连接保留 `y` 中的所有行，全连接保留 `x` 或 `y` 中的所有行，而内连接仅保留同时出现在 `x` 和 `y` 中的行。我们稍后会更详细地回到这些。'
- en: Filtering Joins
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 过滤连接
- en: 'As you might guess, the primary action of a *filtering join* is to filter the
    rows. There are two types: semi-joins and anti-joins. *Semi-joins* keep all rows
    in `x` that have a match in `y`. For example, we could use a semi-join to filter
    the `airports` dataset to show just the origin airports:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能猜到的那样，*过滤连接*的主要操作是过滤行。有两种类型：半连接和反连接。*半连接*保留 `x` 中与 `y` 中匹配的所有行。例如，我们可以使用半连接来过滤
    `airports` 数据集，只显示起始机场：
- en: '[PRE18]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Or just the destinations:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 或者只需目的地：
- en: '[PRE19]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*Anti-joins* are the opposite: they return all rows in `x` that don’t have
    a match in `y`. They’re useful for finding missing values that are *implicit*
    in the data, the topic of [“Implicit Missing Values”](ch18.xhtml#sec-missing-implicit).
    Implicitly missing values don’t show up as `NA`s but instead exist only as an
    absence. For example, we can find rows that are missing from `airports` by looking
    for flights that don’t have a matching destination airport:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '*反连接*则相反：它们返回 `x` 中没有在 `y` 中找到匹配的所有行。它们对于查找数据中*隐式*缺失值很有用，这是[“隐式缺失值”](ch18.xhtml#sec-missing-implicit)的主题。隐式缺失值不显示为
    `NA`，而是仅存在于缺失。例如，我们可以通过查找没有与目的地机场匹配的航班来找到缺少的行：'
- en: '[PRE20]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Or we can find which `tailnum`s are missing from `planes`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 或者我们可以找出哪些`tailnum`在`planes`中不存在：
- en: '[PRE21]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Exercises
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: Find the 48 hours (over the course of the whole year) that have the worst delays.
    Cross-reference it with the `weather` data. Can you see any patterns?
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找出全年中**最严重延误**的48小时（以全年为单位）。与`weather`数据进行交叉参考。你能看到任何规律吗？
- en: 'Imagine you’ve found the top 10 most popular destinations using this code:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 想象一下，你已经使用了这段代码找到了前10个最受欢迎的目的地：
- en: '[PRE22]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: How can you find all flights to those destinations?
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你如何找到所有飞往那些目的地的航班？
- en: Does every departing flight have corresponding weather data for that hour?
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每一个出发的航班都有对应的那一小时的天气数据吗？
- en: 'What do the tail numbers that don’t have a matching record in `planes` have
    in common? (Hint: One variable explains about 90% of the problems.)'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 那些在`planes`中没有匹配记录的尾号有什么共同点？（提示：一个变量解释了大约90%的问题。）
- en: Add a column to `planes` that lists every `carrier` that has flown that plane.
    You might expect that there’s an implicit relationship between plane and airline,
    because each plane is flown by a single airline. Confirm or reject this hypothesis
    using the tools you’ve learned in previous chapters.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`planes`中添加一列，列出每个飞机已经飞过的每个`carrier`。你可能会预期每架飞机与航空公司之间有一个隐含的关系，因为每架飞机只由一家航空公司飞行。使用你在前几章学到的工具来确认或者拒绝这个假设。
- en: Add the latitude and the longitude of the origin *and* destination airport to
    `flights`. Is it easier to rename the columns before or after the join?
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`flights`添加起飞和目的地机场的纬度和经度。在连接之前还是之后更容易重命名列名？
- en: 'Compute the average delay by destination and then join on the `airports` data
    frame so you can show the spatial distribution of delays. Here’s an easy way to
    draw a map of the United States:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算每个目的地的平均延误时间，然后在`airports`数据框上进行连接，以便展示延误的空间分布。这里有一个绘制美国地图的简单方法：
- en: '[PRE23]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: You might want to use the `size` or `color` of the points to display the average
    delay for each airport.
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可能想要使用点的`size`或`color`来显示每个机场的平均延误时间。
- en: What happened on June 13, 2013? Draw a map of the delays, and then use Google
    to cross-reference with the weather.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 2013年6月13日发生了什么？绘制延误地图，然后使用Google进行与天气的交叉参考。
- en: How Do Joins Work?
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接是如何工作的？
- en: Now that you’ve used joins a few times, it’s time to learn more about how they
    work, focusing on how each row in `x` matches rows in `y`. We’ll begin by introducing
    a visual representation of joins, using the simple tibbles defined next and shown
    in [Figure 19-2](#fig-join-setup). In these examples we’ll use a single key called
    `key` and a single value column (`val_x` and `val_y`), but the ideas all generalize
    to multiple keys and multiple values.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经多次使用了连接，是时候学习更多关于它们如何工作的知识了，重点是`x`中的每一行如何与`y`中的行匹配。我们将首先介绍连接的视觉表示，使用接下来定义并在[图 19-2](#fig-join-setup)中显示的简单数据框。
- en: '[PRE24]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '![x and y are two data frames with 2 columns and 3 rows, with contents as described
    in the text. The values of the keys are colored: 1 is green, 2 is purple, 3 is
    orange, and 4 is yellow.](assets/rds2_1902.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![x 和 y 是两个包含2列和3行的数据框，内容如文本所述。关键值的颜色为：1 是绿色，2 是紫色，3 是橙色，4 是黄色。](assets/rds2_1902.png)'
- en: Figure 19-2\. Graphical representation of two simple tables. The colored `key`
    columns map background color to key value. The gray columns represent the “value”
    columns that are carried along for the ride.
  id: totrans-114
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 19-2\. 两个简单表格的图形表示。有颜色的`key`列将背景颜色映射到关键值。灰色列表示伴随旅行的“value”列。
- en: '[Figure 19-3](#fig-join-setup2) introduces the foundation for our visual representation.
    It shows all potential matches between `x` and `y` as the intersection between
    lines drawn from each row of `x` and each row of `y`. The rows and columns in
    the output are primarily determined by `x`, so the `x` table is horizontal and
    lines up with the output.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 19-3](#fig-join-setup2) 介绍了我们视觉表示的基础。它展示了`x`和`y`之间所有潜在的匹配，即从`x`的每一行到`y`的每一行的交集。输出中的行和列主要由`x`决定，因此`x`表是水平的，并与输出对齐。'
- en: '![x and y are placed at right-angles, with horizontal lines extending from
    x and vertical lines extending from y. There are 3 rows in x and 3 rows in y,
    which leads to nine intersections representing nine potential matches.](assets/rds2_1903.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![x 和 y 形成直角，x 上有水平线，y 上有垂直线。x 有3行，y 有3行，共有9个交点表示九个潜在匹配点。](assets/rds2_1903.png)'
- en: Figure 19-3\. To understand how joins work, it’s useful to think of every possible
    match. Here we show that with a grid of connecting lines.
  id: totrans-117
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 19-3\. 要理解连接操作的工作原理，考虑每种可能的匹配是很有用的。这里我们展示了一个连接线网格。
- en: To describe a specific type of join, we indicate matches with dots. The matches
    determine the rows in the output, a new data frame that contains the key, the
    x values, and the y values. For example, [Figure 19-4](#fig-join-inner) shows
    an inner join, where rows are retained if and only if the keys are equal.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 要描述特定类型的连接，我们用点表示匹配。这些匹配确定了输出中的行，即一个包含键、x 值和 y 值的新数据框。例如，[图 19-4](#fig-join-inner)显示了一个内连接，仅当键相等时保留行。
- en: '![x and y are placed at right-angles with lines forming a grid of potential
    matches. Keys 1 and 2 appear in both x and y, so we get a match, indicated by
    a dot. Each dot corresponds to a row in the output, so the resulting joined data
    frame has two rows.](assets/rds2_1904.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![x 和 y 形成直角放置，并通过连接线形成一个潜在匹配的网格。键 1 和 2 在 x 和 y 中都出现，因此我们得到一个匹配，用点表示。每个点对应输出中的一行，因此结果的连接数据帧有两行。](assets/rds2_1904.png)'
- en: Figure 19-4\. An inner join matches each row in `x` to the row in `y` that has
    the same value of `key`. Each match becomes a row in the output.
  id: totrans-120
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 19-4\. 内连接将`x`中的每一行与具有相同`key`值的`y`中的行匹配。每个匹配项成为输出中的一行。
- en: 'We can apply the same principles to explain the *outer joins*, which keep observations
    that appear in at least one of the data frames. These joins work by adding an
    additional “virtual” observation to each data frame. This observation has a key
    that matches if no other key matches, as well as values filled with `NA`. There
    are three types of outer joins:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以应用相同的原则来解释*外连接*，它保留出现在至少一个数据框中的观测值。这些连接通过向每个数据框添加一个额外的“虚拟”观测值来工作。如果没有其他键匹配，则此观测值具有与之匹配的键，以及填充了`NA`的值。外连接有三种类型：
- en: A *left join* keeps all observations in `x`, as shown in [Figure 19-5](#fig-join-left).
    Every row of `x` is preserved in the output because it can fall back to matching
    a row of `NA`s in `y`.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*左连接*保留`x`中的所有观测值，如[图 19-5](#fig-join-left)所示。输出中保留了`x`的每一行，因为它可以回退到在`y`中匹配到一行`NA`的情况。'
- en: '![Compared to the previous diagram showing an inner join, the y table gets
    a new virtual row contain in NA that will match any row in x that didn''t otherwise
    match. This means that the output now has three rows. For key = 3, which matches
    this virtual row, val_y takes value NA.](assets/rds2_1905.png)'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![与之前显示内连接的图表相比，y 表现现在增加了一个新的虚拟行，其中包含 NA，它将匹配任何未匹配到的 x 中的行。这意味着输出现在有三行。对于 key
    = 3，与此虚拟行匹配，val_y 取值 NA。](assets/rds2_1905.png)'
- en: Figure 19-5\. A visual representation of the left join where every row in `x`
    appears in the output.
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 19-5\. 左连接的可视化表示，`x`中的每一行都出现在输出中。
- en: A *right join* keeps all observations in `y`, as shown in [Figure 19-6](#fig-join-right).
    Every row of `y` is preserved in the output because it can fall back to matching
    a row of `NA`s in `x`. The output still matches `x` as much as possible; any extra
    rows from `y` are added to the end.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*右连接*保留`y`中的所有观测值，如[图 19-6](#fig-join-right)所示。输出中保留了`y`的每一行，因为它可以回退到在`x`中匹配到一行`NA`的情况。输出仍然尽可能与`x`匹配；任何额外来自`y`的行都添加到最后。'
- en: '![Compared to the previous diagram showing an left join, the x table now gains
    a virtual row so that every row in y gets a match in x. val_x contains NA for
    the row in y that didn''t match x.](assets/rds2_1906.png)'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![与之前显示左连接的图表相比，x 表现现在增加了一个虚拟行，以便每个 y 中的行在 x 中都获得匹配。对于未匹配到 x 的 y 行，val_x 包含
    NA。](assets/rds2_1906.png)'
- en: Figure 19-6\. A visual representation of the right join where every row of `y`
    appears in the output.
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 19-6\. 右连接的可视化表示，`y`的每一行都出现在输出中。
- en: A *full join* keeps all observations that appear in `x` or `y`, as shown in
    [Figure 19-7](#fig-join-full). Every row of `x` and `y` is included in the output
    because both `x` and `y` have a fallback row of `NA`s. Again, the output starts
    with all rows from `x`, followed by the remaining unmatched `y` rows.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*完全连接*保留出现在`x`或`y`中的所有观测值，如[图 19-7](#fig-join-full)所示。输出中包含了`x`和`y`的每一行，因为`x`和`y`都有一行`NA`的备用。同样，输出从`x`的所有行开始，然后是剩余未匹配的`y`行。'
- en: '![Now both x and y have a virtual row that always matches. The result has 4
    rows: keys 1, 2, 3, and 4 with all values from val_x and val_y, however key 2,
    val_y and key 4, val_x are NAs since those keys don''t have a match in the other
    data frames.](assets/rds2_1907.png)'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![现在，无论是 x 还是 y，都有一个始终匹配的虚拟行。结果包含 4 行：键 1、2、3 和 4，其值全部来自于 val_x 和 val_y，但键
    2 的 val_y 和键 4 的 val_x 因为这些键在另一个数据框中没有匹配而为 NA。](assets/rds2_1907.png)'
- en: Figure 19-7\. A visual representation of the full join where every row in `x`
    and `y` appears in the output.
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 19-7\. 全连接的视觉表示，其中 `x` 和 `y` 中的每一行都出现在输出中。
- en: Another way to show how the types of outer join differ is with a Venn diagram,
    as in [Figure 19-8](#fig-join-venn). However, this is not a great representation
    because while it might jog your memory about which rows are preserved, it fails
    to illustrate what’s happening with the columns.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种显示外连接类型不同的方式是使用维恩图，如[图 19-8](#fig-join-venn)。然而，这并不是一个很好的表示，因为虽然它可能会唤起你对保留哪些行的记忆，但它未能说明列中发生了什么。
- en: '![Venn diagrams for inner, full, left, and right joins. Each join represented
    with two intersecting circles representing data frames x and y, with x on the
    right and y on the left. Shading indicates the result of the join.](assets/rds2_1908.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![维恩图表示内连接、全连接、左连接和右连接。每个连接用两个相交的圆表示数据框 x 和 y，x 在右侧，y 在左侧。阴影表示连接的结果。](assets/rds2_1908.png)'
- en: Figure 19-8\. Venn diagrams showing the difference between inner, left, right,
    and full joins.
  id: totrans-133
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 19-8\. 维恩图显示内连接、左连接、右连接和全连接的区别。
- en: The joins shown here are the so-called *equi joins*, where rows match if the
    keys are equal. Equi joins are the most common type of join, so we’ll typically
    omit the equi prefix and just say “inner join” rather than “equi inner join.”
    We’ll come back to non-equi joins in [“Filtering Joins”](#sec-non-equi-joins).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这里显示的是所谓的*等连接*，其中如果键相等，则行匹配。等连接是最常见的连接类型，因此我们通常会省略等前缀，只说“内连接”而不是“等内连接”。我们将在[“过滤连接”](#sec-non-equi-joins)中回到非等连接。
- en: Row Matching
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 行匹配
- en: So far we’ve explored what happens if a row in `x` matches zero or one rows
    in `y`. What happens if it matches more than one row? To understand what’s going
    on, let’s first narrow our focus to [`inner_join()`](https://dplyr.tidyverse.org/reference/mutate-joins.xhtml)
    and then draw a picture, as shown in [Figure 19-9](#fig-join-match-types).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经探讨了如果行在 `y` 中匹配零或一行会发生什么。如果它匹配多于一行会发生什么？要理解正在发生的情况，让我们首先将焦点缩小到[`inner_join()`](https://dplyr.tidyverse.org/reference/mutate-joins.xhtml)，然后绘制一幅图，如[图
    19-9](#fig-join-match-types)所示。
- en: '![A join diagram where x has key values 1, 2, and 3, and y has key values 1,
    2, 2\. The output has three rows because key 1 matches one row, key 2 matches
    two rows, and key 3 matches zero rows.](assets/rds2_1909.png)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![一个联接图，其中 x 具有键值 1、2 和 3，y 具有键值 1、2、2。输出有三行，因为键 1 匹配一行，键 2 匹配两行，键 3 没有匹配行。](assets/rds2_1909.png)'
- en: Figure 19-9\. The three ways a row in `x` can match. `x1` matches one row in
    `y`, `x2` matches two rows in `y`, and `x3` matches zero rows in y. Note that
    while there are three rows in `x` and three rows in the output, there isn’t a
    direct correspondence between the rows.
  id: totrans-138
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 19-9\. 行 `x` 匹配的三种方式。`x1` 匹配 `y` 中的一行，`x2` 匹配 `y` 中的两行，`x3` 不匹配 `y` 中的任何行。请注意，虽然
    `x` 中有三行且输出中也有三行，但行之间没有直接的对应关系。
- en: 'There are three possible outcomes for a row in `x`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 一行在 `x` 中有三种可能的结果：
- en: If it doesn’t match anything, it’s dropped.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果它没有匹配项，它将被丢弃。
- en: If it matches one row in `y`, it’s preserved.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果它在 `y` 中匹配一行，它将被保留。
- en: If it matches more than one row in `y`, it’s duplicated once for each match.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果它在 `y` 中匹配多于一行，它将被复制，每个匹配一次。
- en: 'In principle, this means there’s no guaranteed correspondence between the rows
    in the output and the rows in `x`, but in practice, this rarely causes problems.
    There is, however, one particularly dangerous case that can cause a combinatorial
    explosion of rows. Imagine joining the following two tables:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 原则上，这意味着输出中的行与 `x` 中的行之间没有保证的对应关系，但实际上，这很少会引起问题。然而，有一种特别危险的情况可能会导致行的组合爆炸。想象一下，联接以下两个表：
- en: '[PRE25]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'While the first row in `df1` matches only one row in `df2`, the second and
    third rows both match two rows. This is sometimes called a *many-to-many* join
    and will cause dplyr to emit a warning:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 `df1` 中的第一行仅与 `df2` 中的一行匹配，但第二行和第三行都与两行匹配。这有时被称为*多对多*连接，并将导致 dplyr 发出警告：
- en: '[PRE26]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: If you are doing this deliberately, you can set `relationship = "many-to-many"`,
    as the warning suggests.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是故意这样做的，你可以设置 `relationship = "many-to-many"`，就像警告建议的那样。
- en: Filtering Joins
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 过滤连接
- en: The number of matches also determines the behavior of the filtering joins. The
    semi-join keeps rows in `x` that have one or more matches in `y`, as in [Figure 19-10](#fig-join-semi).
    The anti-join keeps rows in `x` that match zero rows in `y`, as in [Figure 19-11](#fig-join-anti).
    In both cases, only the existence of a match is important; it doesn’t matter how
    many times it matches. This means that filtering joins never duplicate rows like
    mutating joins do.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配的数量还决定了过滤连接的行为。半连接保留在y中具有一个或多个匹配项的x中的行，如[图 19-10](#fig-join-semi)。反连接保留在y中没有匹配项的x中的行，如[图 19-11](#fig-join-anti)。在这两种情况下，只有匹配的存在性是重要的；它不关心匹配了多少次。这意味着过滤连接不会像变异连接那样重复行。
- en: '![A join diagram with old friends x and y. In a semi join, only the presence
    of a match matters so the output contains the same columns as x.](assets/rds2_1910.png)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![一个显示了老朋友x和y的连接图。在半连接中，只有匹配的存在性是重要的，因此输出包含与x相同的列。](assets/rds2_1910.png)'
- en: Figure 19-10\. In a semi-join it only matters that there is a match; otherwise,
    values in `y` don’t affect the output.
  id: totrans-151
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 19-10\. 在半连接中，只有匹配的存在性是重要的；否则，y中的值不会影响输出。
- en: '![An anti-join is the inverse of a semi-join so matches are drawn with red
    lines indicating that they will be dropped from the output.](assets/rds2_1911.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![反向关联是半关联的反面，因此匹配通过红线指示，表明它们将从输出中删除。](assets/rds2_1911.png)'
- en: Figure 19-11\. An anti-join is the inverse of a semi-join, dropping rows from
    `x` that have a match in `y`.
  id: totrans-153
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 19-11\. 反连接是半连接的反向操作，从x中删除在y中具有匹配项的行。
- en: Non-Equi Joins
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 非等值连接
- en: So far you’ve seen only equi joins, joins where the rows match if the `x` key
    equals the `y` key. Now we’re going to relax that restriction and discuss other
    ways of determining if a pair of rows match.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您只看到了等值连接，即只有在x的键等于y的键时才匹配的连接。现在我们将放宽这个限制，讨论确定一对行是否匹配的其他方法。
- en: But before we can do that, we need to revisit a simplification we made previously.
    In equi joins the `x` keys and `y` are always equal, so we need to show only one
    in the output. We can request that dplyr keep both keys with `keep = TRUE`, leading
    to the following code and the redrawn [`inner_join()`](https://dplyr.tidyverse.org/reference/mutate-joins.xhtml)
    in [Figure 19-12](#fig-inner-both).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 但在此之前，我们需要重新审视先前所做的简化。在等值关联中，x的键和y总是相等的，因此我们只需要在输出中显示一个。我们可以请求dplyr保留两个键，使用`keep
    = TRUE`，导致以下代码和重新绘制的[`inner_join()`](https://dplyr.tidyverse.org/reference/mutate-joins.xhtml)在[图 19-12](#fig-inner-both)中。
- en: '[PRE27]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '![A join diagram showing an inner join between x and y. The result now includes
    four columns: key.x, val_x, key.y, and val_y. The values of key.x and key.y are
    identical, which is why we usually only show one. ](assets/rds2_1912.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![显示了x和y之间内连接的连接图。结果现在包括四列：key.x、val_x、key.y和val_y。key.x和key.y的值相同，这就是为什么我们通常只显示一个的原因。](assets/rds2_1912.png)'
- en: Figure 19-12\. An inner join showing both `x` and `y` keys in the output.
  id: totrans-159
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 19-12\. 一个内连接显示了输出中的x和y两个键。
- en: When we move away from equi joins, we’ll always show the keys, because the key
    values will often be different. For example, instead of matching only when the
    `x$key` and `y$key` are equal, we could match whenever the `x$key` is greater
    than or equal to the `y$key`, leading to [Figure 19-13](#fig-join-gte). dplyr’s
    join functions understand this distinction between equi and non-equi joins so
    will always show both keys when you perform a non-equi join.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们移开从等值连接时，我们总是显示键，因为键值通常会有所不同。例如，不再只匹配x$key和y$key相等时，而是当x$key大于或等于y$key时匹配，这会导致[图 19-13](#fig-join-gte)。dplyr的连接函数理解等值连接和非等值连接之间的区别，因此在执行非等值连接时始终会显示两个键。
- en: '![A join diagram illustrating join_by(key >= key). The first row of x matches
    one row of y and the second and thirds rows each match two rows. This means the
    output has five rows containing each of the following (key.x, key.y) pairs: (1,
    1), (2, 1), (2, 2), (3, 1), (3, 2).](assets/rds2_1913.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![一个关联图示说明了按照(key >= key)进行关联的方法。x的第一行与y的一行匹配，第二行和第三行各自与两行匹配。这意味着输出包含五行，每行都包含以下(key.x,
    key.y)对：(1, 1), (2, 1), (2, 2), (3, 1), (3, 2)。](assets/rds2_1913.png)'
- en: Figure 19-13\. A non-equi join where the `x` key must be greater than or equal
    to the `y` key. Many rows generate multiple matches.
  id: totrans-162
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 19-13\. 非等值连接，其中x键必须大于或等于y键。许多行会生成多个匹配项。
- en: 'Non-equi join isn’t a particularly useful term because it only tells you what
    the join is not, not what it is. dplyr helps by identifying four particularly
    useful types of non-equi join:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 非等连接并不是一个特别有用的术语，因为它只告诉你这个连接不是什么，而不是什么。
- en: Cross joins
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 交叉连接
- en: Match every pair of rows.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配每一对行。
- en: Inequality joins
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 不等连接
- en: Use `<`, `<=`, `>`, and `>=` instead of `==`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `<`、`<=`、`>` 和 `>=` 而不是 `==`。
- en: Rolling joins
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 滚动连接
- en: Similar to inequality joins but only find the closest match.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于不等连接，但只找到最接近的匹配。
- en: Overlap joins
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 重叠连接
- en: A special type of inequality join designed to work with ranges.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 一种特殊类型的不等连接，设计用于处理范围。
- en: Each of these is described in more detail in the following sections.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的各个连接类型将在接下来的章节中详细描述。
- en: Cross Joins
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 交叉连接
- en: A cross join matches everything, as in [Figure 19-14](#fig-join-cross), generating
    the Cartesian product of rows. This means the output will have `nrow(x) * nrow(y)`
    rows.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 交叉连接匹配所有内容，如 [图 19-14](#fig-join-cross) 所示，生成行的笛卡尔积。这意味着输出将有 `nrow(x) * nrow(y)`
    行。
- en: '![A join diagram showing a dot for every combination of x and y.](assets/rds2_1914.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![一个连接图示，显示每个 `x` 和 `y` 的组合点。](assets/rds2_1914.png)'
- en: Figure 19-14\. A cross join matches each row in `x` with every row in `y`.
  id: totrans-176
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 19-14\. 交叉连接将`x`中的每一行与`y`中的每一行匹配。
- en: Cross joins are useful when generating permutations. For example, the following
    code generates every possible pair of names. Since we’re joining `df` to itself,
    this is sometimes called a *self-join*. Cross joins use a different join function
    because there’s no distinction between inner/left/right/full when you’re matching
    every row.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 交叉连接在生成排列时非常有用。例如，以下代码生成了每对名称的所有可能组合。由于我们将 `df` 与自身连接，这有时被称为*自连接*。交叉连接使用不同的连接函数，因为在匹配每一行时不存在内部/左侧/右侧/完整的区别。
- en: '[PRE28]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Inequality Joins
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不等连接
- en: Inequality joins use `<`, `<=`, `>=`, or `>` to restrict the set of possible
    matches, as in [Figure 19-13](#fig-join-gte) and [Figure 19-15](#fig-join-lt).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 不等连接使用 `<`、`<=`、`>=` 或 `>` 来限制可能匹配的集合，如 [图 19-13](#fig-join-gte) 和 [图 19-15](#fig-join-lt)
    中所示。
- en: '![A diagram depicting an inequality join where a data frame x is joined by
    a data frame y where the key of x is less than the key of y, resulting in a triangular
    shape in the top-left corner.](assets/rds2_1915.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![一个图示，描绘了一个不等连接的图，其中数据框 `x` 与数据框 `y` 连接，其中 `x` 的键小于 `y` 的键，结果在左上角呈三角形状。](assets/rds2_1915.png)'
- en: Figure 19-15\. An inequality join where `x` is joined to `y` on rows where the
    key of `x` is less than the key of `y`. This makes a triangular shape in the top-left
    corner.
  id: totrans-182
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 19-15\. 不等连接，其中 `x` 与 `y` 在 `x` 的键小于 `y` 的键的行上连接。这在左上角形成一个三角形。
- en: 'Inequality joins are extremely general, so general that it’s hard to come up
    with meaningful specific use cases. One small useful technique is to use them
    to restrict the cross join so that instead of generating all permutations, we
    generate all combinations:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 不等连接非常普遍，以至于很难想出有意义的具体用例。一个小而有用的技巧是使用它们来限制交叉连接，以便不生成所有排列，而是生成所有组合：
- en: '[PRE29]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Rolling Joins
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 滚动连接
- en: Rolling joins are a special type of inequality join where instead of getting
    *every* row that satisfies the inequality, you get just the closest row, as in
    [Figure 19-16](#fig-join-closest). You can turn any inequality join into a rolling
    join by adding `closest()`. For example, `join_by(closest(x <= y))` matches the
    smallest `y` that’s greater than or equal to x, and `join_by(closest(x > y))`
    matches the biggest `y` that’s less than `x`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 滚动连接是一种特殊类型的不等连接，不是获取满足不等式的每一行，而是获取最接近的行，如 [图 19-16](#fig-join-closest) 所示。你可以通过添加
    `closest()` 将任何不等连接转换为滚动连接。例如，`join_by(closest(x <= y))` 匹配大于或等于 `x` 的最小 `y`，而
    `join_by(closest(x > y))` 匹配小于 `x` 的最大 `y`。
- en: '![A rolling join is a subset of an inequality join so some matches are grayed
    out indicating that they''re not used because they''re not the "closest".](assets/rds2_1916.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![滚动连接是不等连接的子集，因此一些匹配被灰色表示，表示它们未被使用，因为它们不是“最接近的”。](assets/rds2_1916.png)'
- en: Figure 19-16\. A rolling join is similar to a greater-than-or-equal inequality
    join but matches only the first value.
  id: totrans-188
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 19-16\. 滚动连接类似于大于或等于的不等连接，但只匹配第一个值。
- en: Rolling joins are particularly useful when you have two tables of dates that
    don’t perfectly line up and you want to find, for example, the closest date in
    table 1 that comes before (or after) some date in table 2.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 滚动连接在你有两个日期表格并且它们不完全对齐时特别有用，你想要找到例如第一个表格中在第二个表格某个日期之前（或之后）的最接近的日期。
- en: 'For example, imagine that you’re in charge of the party planning commission
    for your office. Your company is rather cheap so instead of having individual
    parties, you have a party only once each quarter. The rules for determining when
    a party will be held are a little complex: parties are always on a Monday, you
    skip the first week of January since a lot of people are on holiday, and the first
    Monday of Q3 2022 is July 4, so that has to be pushed back a week. That leads
    to the following party days:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，想象一下，您负责办公室派对策划委员会。您的公司相当吝啬，所以没有单独的派对，每季度只举办一次派对。确定何时举行派对的规则有点复杂：派对总是在星期一举行，您跳过一月份的第一周，因为很多人在度假，2022年第三季度的第一个星期一是7月4日，所以必须推迟一周。这导致以下派对日期：
- en: '[PRE30]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now imagine that you have a table of employee birthdays:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在想象一下，您有一个员工生日表：
- en: '[PRE31]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'And for each employee we want to find the first party date that comes after
    (or on) their birthday. We can express that with a rolling join:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每位员工，我们希望找到在他们生日之后（或者当天）的第一个派对日期。我们可以通过滚动连接来表达这一点：
- en: '[PRE32]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'There is, however, one problem with this approach: the folks with birthdays
    before January 10 don’t get a party:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种方法有一个问题：在1月10日之前过生日的人就不能参加派对：
- en: '[PRE33]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: To resolve that issue we’ll need to tackle the problem a different way, with
    overlap joins.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 要解决这个问题，我们需要以不同的方式处理它，采用重叠连接的方法。
- en: Overlap Joins
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重叠连接
- en: 'Overlap joins provide three helpers that use inequality joins to make it easier
    to work with intervals:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 重叠连接提供了三个助手函数，使用不等连接使得处理间隔更加容易：
- en: '`between(x, y_lower, y_upper)` is short for `x >= y_lower, x <= y_upper`.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`between(x, y_lower, y_upper)` 的意思是 `x >= y_lower, x <= y_upper`。'
- en: '`within(x_lower, x_upper, y_lower, y_upper)` is short for `x_lower >= y_lower,
    x_upper <= y_upper`.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`within(x_lower, x_upper, y_lower, y_upper)` 的意思是 `x_lower >= y_lower, x_upper
    <= y_upper`。'
- en: '`overlaps(x_lower, x_upper, y_lower, y_upper)` is short for `x_lower <= y_upper,
    x_upper >= y_lower`.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`overlaps(x_lower, x_upper, y_lower, y_upper)` 的意思是 `x_lower <= y_upper, x_upper
    >= y_lower`。'
- en: 'Let’s continue the birthday example to see how you might use them. There’s
    one problem with the strategy we used earlier: there’s no party preceding the
    birthdays from January 1 to 9\. So it might be better to to be explicit about
    the date ranges that each party span, and make a special case for those early
    birthdays:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续使用生日的例子来看看您可能如何使用它们。我们之前使用的策略有一个问题：没有派对在1月1日到9日的生日之前。因此，最好明确每个派对跨越的日期范围，并为这些早期生日制定一个特殊情况：
- en: '[PRE34]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Hadley is hopelessly bad at data entry, so he also wanted to check that the
    party periods don’t overlap. One way to do this is by using a self-join to check
    whether any start-end interval overlaps with another:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 哈德利在数据输入方面非常糟糕，因此他还想检查派对期间是否重叠。一种方法是使用自连接来检查任何开始-结束间隔是否与另一个重叠：
- en: '[PRE35]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Oops, there is an overlap, so let’s fix that problem and continue:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 糟糕，有重叠，让我们修复这个问题并继续：
- en: '[PRE36]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now we can match each employee to their party. This is a good place to use
    `unmatched = "error"` because we want to quickly find out if any employees didn’t
    get assigned a party:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以将每位员工与他们的派对匹配。这是一个使用 `unmatched = "error"` 的好地方，因为我们想要快速找出是否有任何员工没有被分配到派对：
- en: '[PRE37]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Exercises
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习
- en: Can you explain what’s happening with the keys in this equi join? Why are they
    different?
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您能解释这个等连接中键发生了什么吗？它们为什么不同？
- en: '[PRE38]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: When finding if any party period overlapped with another party period, we used
    `q < q` in the [`join_by()`](https://dplyr.tidyverse.org/reference/join_by.xhtml)?
    Why? What happens if you remove this inequality?
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在查找是否有任何派对期间重叠时，我们在[`join_by()`](https://dplyr.tidyverse.org/reference/join_by.xhtml)中使用了`q
    < q`，为什么？如果删除这个不等式会发生什么？
- en: Summary
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to use mutating and filtering joins to combine
    data from a pair of data frames. Along the way you learned how to identify keys,
    and you learned the difference between primary and foreign keys. You also understand
    how joins work and how to figure out how many rows the output will have. Finally,
    you gained a glimpse into the power of non-equi joins and saw a few interesting
    use cases.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学会了如何使用变异和过滤连接来合并来自一对数据框的数据。在此过程中，您学会了如何识别键，以及主键和外键之间的区别。您还了解了连接的工作原理以及如何确定输出将有多少行。最后，您深入了解了非等连接的强大功能，并看到了一些有趣的用例。
- en: This chapter concludes the “Transform” part of the book where the focus was
    on the tools you could use with individual columns and tibbles. You learned about
    dplyr and base functions for working with logical vectors, numbers, and complete
    tables; stringr functions for working strings; lubridate functions for working
    with date-times; and forcats functions for working with factors.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 本章结束了本书“转换”部分的内容，重点是你可以使用的工具，包括处理单独列和tibble的dplyr和基础函数；处理逻辑向量、数字和完整表格的base函数；处理字符串的stringr函数；处理日期时间的lubridate函数；以及处理因子的forcats函数。
- en: In the next part of the book, you’ll learn more about getting various types
    of data into R in a tidy form.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的下一部分将进一步学习如何以整洁的形式将各种类型的数据导入到R中。
- en: ^([1](ch19.xhtml#idm44771284613936-marker)) Remember that in RStudio you can
    also use [`View()`](https://rdrr.io/r/utils/View.xhtml) to avoid this problem.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch19.xhtml#idm44771284613936-marker)) 请记住，在RStudio中，你也可以使用[`View()`](https://rdrr.io/r/utils/View.xhtml)来避免这个问题。
- en: ^([2](ch19.xhtml#idm44771284529504-marker)) That’s not 100% true, but you’ll
    get a warning whenever it isn’t.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch19.xhtml#idm44771284529504-marker)) 这并非百分之百正确，但如果不是的话，你会收到警告。
