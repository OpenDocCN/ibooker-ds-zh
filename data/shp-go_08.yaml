- en: 6 Testing frameworks, mocking, and dependencies
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6 测试框架、模拟和依赖
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Isolating code from external dependencies by using interfaces
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用接口将代码从外部依赖中隔离
- en: Injecting dependencies into services to create composable portions of code
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将依赖注入到服务中以创建可组合的代码部分
- en: Constructing suites of tests to reduce boilerplate setup and teardown for tests
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建测试套件以减少测试的样板设置和拆卸
- en: Stubbing and mocking dependencies to create isolated tests that are reliable
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟和模拟依赖以创建可靠且隔离的测试
- en: Simulating calls to an external service to test the logic of a client service
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟对外部服务的调用以测试客户端服务的逻辑
- en: “So you want to sit with me and tell me what to code? Won’t that be a waste
    of your time?” You’ve just given the intern permission to access the repository
    and sat down next to her at her desk. You explain that she should download the
    repository and follow the directions on the README, and you will sit there to
    answer any questions. After making some minor notes on where to expand the documentation,
    you move on to coding. The intern will add some new functionality to the system
    and write the code while you explain what to write.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: “所以你想坐在我旁边告诉我该写什么代码？那不会浪费你的时间吗？”你刚刚给了实习生访问仓库的权限，并坐在她的桌子旁边。你解释说她应该下载仓库并遵循README中的说明，你将坐在那里回答任何问题。在记下一些关于如何扩展文档的笔记后，你继续编码。实习生将向系统中添加一些新功能，并编写代码，而你将解释应该写什么。
- en: This process of “pair programming” is a great technique to bring people on board
    and explain the code base. It also is a great team-building activity. One person
    can write the tests while the other implements the solution. In this case, you
    will write the test and explain what it does, and it will then be the intern’s
    job to implement it with you there to guide her and provide pointers and input.
    Before you can do this, though, you need to define what you’re going to build,
    so you pull up an editor and write the code in the following listing in your `translate.go`
    handler.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这种“结对编程”的过程是一种很好的技术，可以让人加入并解释代码库。它也是一种很好的团队建设活动。一个人可以编写测试，另一个人实现解决方案。在这种情况下，你将编写测试并解释它做什么，然后实习生将负责在你在场的情况下实现它，你将指导她并提供指导和反馈。不过，在这样做之前，你需要定义你将要构建的内容，所以你打开一个编辑器，并在你的`translate.go`处理器中编写以下列表中的代码。
- en: Listing 6.1 `translate.go`
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.1 `translate.go`
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ Extracting our method into an interface allows us flexibility in the implementation.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将我们的方法提取到接口中使我们能够在实现上具有灵活性。
- en: “You want me to implement this interface in a new service? Why? Everything seems
    to work fine now. What will an interface do to help?” You smile; it’s always fun
    to teach.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: “你想要我在新服务中实现这个接口？为什么？现在一切似乎都运行得很好。接口能做什么来帮助？”你微笑着；教人总是很有趣。
- en: 6.1 Dependency inversion principle
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.1 依赖反转原则
- en: “Depend on abstractions, not concretions.” This is the *dependency inversion
    principle*. This is a design principle that is found in software development.
    It is a fairly simple concept that helps developers create clean and focused code.
    Instead of using an implemented class or function directly, we depend on the abstraction.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: “依赖抽象，而非具体。”这是**依赖反转原则**。这是一个在软件开发中发现的原理。这是一个相当简单的概念，有助于开发者创建干净和专注的代码。我们不是直接使用实现过的类或函数，而是依赖于抽象。
- en: The best way that I can explain this concept is to imagine a scenario where
    electrical plugs didn’t exist. How hard would it be if you had to directly wire
    your lamp or TV to your home’s electrical system? I’m sure you would think twice
    before you rearranged your furniture. Instead, we created plugs and outlets. We
    don’t care about the wiring in our house, the circuit breaker (unless one is flipped),
    the line to the house, the transformer, or where the electricity comes from. It
    just simply works for us. If your lamp breaks tomorrow, it can be replaced, and
    you don’t need to worry about putting in a new outlet. The plug should just fit.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我能解释这个概念的最佳方式是想象一个没有电源插头的场景。如果你必须直接将你的灯或电视连接到家里的电力系统，那会多么困难？我相信在你重新布置家具之前，你一定会三思。相反，我们创造了插头和插座。我们不在乎家里的电线、断路器（除非有人拉闸）、通往房子的线路、变压器，或者电是从哪里来的。它对我们来说只是简单地工作。如果你的灯明天坏了，它可以被更换，你不需要担心安装一个新的插座。插头应该刚好合适。
- en: This is what is known as an *interface*, an abstraction that allows someone
    to easily use something more complex behind the scenes. We talked about abstractions
    in chapter 4 and how they can be helpful in software development. It’s no surprise
    that developers want to help abstract some of their code for others to use. Similarly,
    they want to be able to improve and change things without causing major refactors
    or problems. This is where interfaces come in. In software development, an interface
    defines the functions of a given struct or class. Once a struct has all of the
    request functions, it satisfies the interface and can be used in the place of
    another service that also satisfies the interface. Just like the lamps, we can
    change out pieces of code that help us grow and improve.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是所谓的 *接口*，一种抽象，它允许某人轻松地使用背后更复杂的东西。我们在第4章讨论了抽象，以及它们如何在软件开发中有所帮助。开发者想要帮助抽象他们的一些代码供他人使用，这并不奇怪。同样，他们希望能够在不引起重大重构或问题的前提下改进和更改事物。这就是接口发挥作用的地方。在软件开发中，接口定义了给定结构体或类的函数。一旦结构体拥有了所有请求的函数，它就满足了接口，可以在满足接口的另一个服务的地方使用。就像灯具一样，我们可以更换帮助我们成长和改进的代码片段。
- en: Some developers will forgo the creation of interfaces and instead create portions
    of code that are tightly coupled and intertwined. This makes it hard for us to
    test effectively and enhance our code in the future. We need to modularize our
    code so we can do a better job of testing it, which can be done through the use
    of interfaces.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 一些开发者会放弃创建接口，而是创建紧密耦合和交织的代码片段。这使得我们难以有效地测试，并在未来增强我们的代码。我们需要模块化我们的代码，以便我们可以更好地测试它，这可以通过使用接口来实现。
- en: 6.2 Defining an interface
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.2 定义接口
- en: Interfaces are also called *protocols*, which help define boundaries between
    systems and provide a way to communicate between those boundaries. Protocols and
    interfaces create a definition of how to communicate through established structures
    or patterns. Just like different outlet faces on an electrical socket can tell
    us what sort of electricity is on the other side, an interface will tell our user
    how to use a service by defining method definitions (as seen in figure 6.1).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 接口也被称为 *协议*，它有助于定义系统之间的边界，并提供在这些边界之间通信的方式。协议和接口创建了一个定义，说明如何通过既定的结构或模式进行通信。就像电源插座上不同的插孔面可以告诉我们另一侧是什么类型的电力一样，接口将通过定义方法定义（如图6.1所示）告诉我们的用户如何使用服务。
- en: '![](../../OEBPS/Images/CH06_F01_Holmes4.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH06_F01_Holmes4.png)'
- en: Figure 6.1 Various interfaces are designed to abstract the delivery of electricity.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1 设计了各种接口来抽象电力的输送。
- en: This allows our developers to write their code toward an interface definition
    rather than a concrete implementation, allowing us to make changes that don’t
    affect the entire system. This is important as we develop because we may find
    that we need to slowly replace portions of our code while still supporting backward
    compatibility or testing features that are not ready for wide consumption. Later
    in this chapter, we will do this, but let’s start with the simple example in the
    following listing.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许我们的开发者面向接口定义编写代码，而不是具体的实现，这样我们就可以做出不会影响整个系统的更改。在我们开发过程中，这一点很重要，因为我们可能会发现我们需要缓慢地替换代码的一部分，同时仍然支持向后兼容性或测试尚未准备好广泛消费的功能。在本章的后面部分，我们将这样做，但让我们先从以下列表中的简单示例开始。
- en: Listing 6.2 `example.go`
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.2 `example.go`
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ The interface defines a method that a struct needs to have to satisfy the
    interface.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 接口定义了一个结构体需要拥有的方法以满足接口。
- en: ❷ The spanishGreeter struct adds the method and therefore satisfies the interface.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ `spanishGreeter` 结构体添加了该方法，因此满足了接口。
- en: ❸ In the same way, the englishGreeter also satisfies the interface.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 同样，`englishGreeter` 也满足了接口。
- en: ❹ A generic method can then be written that uses the interface as input.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 然后，可以编写一个泛型方法，该方法使用接口作为输入。
- en: We created two structures that satisfy the same interface. This allows us to
    abstract the parameters of the function to take the interface and swap between
    the two structures. This can be seen in figure 6.2 where we have a service using
    an interface to hide the underlying implementation. Though this is a trivial example,
    we will see it be more powerful in the future as we customize our application.
    What we can see now is that we can implement any number of structs to satisfy
    this interface without changing the caller. Though I have never encoun-tered this
    scenario, imagine using an interface for a backend datastore. With an interface,
    you could satisfy the interface using Postgres, RedisDB, MongoDB, or any number
    of technologies and not have to change your code. This rarely happens but prevents
    you from locking into a given implementation.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了两个满足相同接口的结构体。这允许我们将函数的参数抽象化，以接受接口并在两个结构体之间进行切换。这可以在图 6.2 中看到，我们有一个使用接口来隐藏底层实现的服务。虽然这是一个简单的例子，但我们将看到它在未来定制我们的应用程序时将变得更加强大。我们现在可以看到，我们可以实现任何数量的结构体来满足这个接口，而无需更改调用者。尽管我从未遇到过这种情况，但想象一下使用接口作为后端数据存储。有了接口，你可以使用
    Postgres、RedisDB、MongoDB 或任何数量的技术来满足接口，而无需更改你的代码。这种情况很少发生，但可以防止你锁定到特定的实现。
- en: '![](../../OEBPS/Images/CH06_F02_Holmes4.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH06_F02_Holmes4.png)'
- en: Figure 6.2 Interfaces allow us to swap between different services that satisfy
    the interface without changing our logic in the consuming service.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.2 接口允许我们在不改变消费服务逻辑的情况下，在满足接口的不同服务之间进行切换。
- en: Why does this matter? By making use of interfaces, we can also simplify how
    we test our code. Let’s look at our handler function as an example. Right now,
    it is dependent on the service struct for translations. If we were to change the
    underlying implementation of services, we would hope that this wouldn’t affect
    our handler. But when we think about it, our handler should work independently
    of the underlying service. All the handler cares about is the output translation
    and nothing else, so we want to add an abstraction within the handler to make
    it easier to test (see the following code listing).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这有什么关系呢？通过使用接口，我们还可以简化我们测试代码的方式。让我们以我们的处理器函数为例。目前，它依赖于服务结构体进行翻译。如果我们改变服务的底层实现，我们希望这不会影响我们的处理器。但当我们思考这个问题时，我们的处理器应该独立于底层服务工作。处理器所关心的只是输出翻译，没有其他，因此我们希望在处理器内添加一个抽象层，使其更容易测试（见以下代码列表）。
- en: Listing 6.3 `translate.go`
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.3 `translate.go`
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ Extracting our method into an interface allows us flexibility in the implementation.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将我们的方法提取到接口中使我们能够在实现上具有灵活性。
- en: 'You may wonder why we are defining this interface here and not somewhere else.
    The handler is the consumer of the interface and therefore defines the functionality
    it needs following the dependency inversion principle we discussed earlier. We
    define the interface we want and then create the implementation that satisfies
    this interface type. Go uses something called *duck typing* to help map an interface
    to its implementation. The term *duck typing* is a type system wherein the object
    needs to satisfy certain behaviors. It comes from a *duck test*: “If it walks
    like a duck and quacks like a duck, then it must be a duck.” The handler can define
    what it expects from a structure through the use of an interface and ignore the
    underlying implementation. This means our implementation can come from anywhere,
    and a single implementation can satisfy many interfaces. As developers, we want
    to split our interfaces into small chunks known as *interface segregation* to
    help them be more composable and reusable. Go’s standard library has a wonderful
    example of this (see the following listing).'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道为什么我们要在这里定义这个接口而不是其他地方。处理器是这个接口的消费者，因此根据我们之前讨论的依赖倒置原则，它定义了它需要的功能。我们定义我们想要的接口，然后创建满足这个接口类型的实现。Go
    使用一种称为 *鸭子类型* 的方法来帮助将接口映射到其实现。*鸭子类型* 是一种类型系统，其中对象需要满足某些行为。它来自一个 *鸭子测试*：“如果它像鸭子走路，像鸭子嘎嘎叫，那么它一定是一只鸭子。”处理器可以通过使用接口来定义它对结构的期望，并忽略底层实现。这意味着我们的实现可以来自任何地方，一个单一的实现可以满足许多接口。作为开发者，我们希望将我们的接口分成小块，称为
    *接口隔离*，以帮助它们更易于组合和重用。Go 的标准库有一个很好的例子（见以下列表）。
- en: Listing 6.4 `io.go`
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.4 `io.go`
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ The reader interface only has one method to satisfy . . .
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 读取接口只有一个方法需要满足 . . .
- en: ❷ . . . and so does the writer interface.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ . . . 以及写接口。
- en: ❸ A composite interface can then be created from each of these interfaces.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 从这些接口中创建一个复合接口。
- en: A service may only want to implement `Reader` or `Writer` or both. You can treat
    interfaces like Legos that you assemble so that you can use what you need and
    nothing more. This is all well and good, but how do we use this composability?
    We create a structure that fulfills the interface and injects it into a consuming
    struct. This is known as *dependency injection*.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 一个服务可能只想实现 `Reader` 或 `Writer` 或两者兼具。你可以将接口视为乐高积木，这样你可以组装你需要的东西，而无需更多。这很好，但我们如何使用这种可组合性呢？我们创建一个满足接口的结构体，并将其注入到一个消费结构体中。这被称为
    *依赖注入*。
- en: 6.3 Dependency injection
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.3 依赖注入
- en: I’ve always imagined dependency injection as putting a different engine in a
    different car. Many car bodies share the same engine, and many car bodies support
    different engines. For example, the 2022 Toyota Camry allows you the option to
    have a four-cylinder, six-cylinder, or four-cylinder hybrid engine all in the
    same type of car, in the same way that hybrid engines can also be used on other
    vehicles. This is a streamlined way for companies to reuse designs while giving
    their users the variety that they need.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我一直想象依赖注入就像在不同的车上安装不同的引擎。许多车身使用相同的引擎，许多车身支持不同的引擎。例如，2022 款丰田凯美瑞允许你选择安装四缸、六缸或四缸混合动力引擎，所有这些都在同一类型的汽车上，就像混合动力引擎也可以用于其他车辆一样。这是公司以简化设计的同时，为用户提供他们所需多样性的流线型方式。
- en: NOTE We are going to wire these dependencies by hand, but there are tools out
    there that will do it for you. These include Wire, Fx, and Kit.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 备注：我们将手动连接这些依赖项，但有一些工具可以为你完成这项工作。这些包括 Wire、Fx 和 Kit。
- en: In the same way, we can build our code to use different services and elements
    while not affecting our current implementation. Code changes. Ideas change. Features
    get added. What is important is that these changes should not require an entire
    rearchitecting or rebuilding of our system. Instead, we should be able to define
    how the service should work in abstract terms and then satisfy them with concrete
    implemen-tations so they are not *tightly coupled*, wherein a change in one service
    requires a change in another service. Instead, a change in a given service shouldn’t
    affect the underlying functionality of another service. In the previous section,
    we talked about the merits of writing an interface. You can view your interface
    as a way of standardizing how a service will work. With this standard in place,
    you can then make changes as you need. You can attach the larger engine, the smaller
    engine, or the hybrid without doing a major overhaul. Let’s see how this works.
    We’ve already written our interface for translation, and now we need to make the
    handler use it and the service satisfy it. Open your `translate.go` file, and
    add the code in the following listing.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以构建我们的代码以使用不同的服务和元素，同时不影响我们的当前实现。代码会变化，想法会变化，功能会添加。重要的是，这些变化不应该需要整个系统的重新架构或重建。相反，我们应该能够以抽象术语定义服务应该如何工作，然后通过具体的实现来满足它们，这样它们就不是
    *紧密耦合* 的，即一个服务的更改需要另一个服务的更改。相反，一个给定服务的更改不应该影响另一个服务的底层功能。在前一节中，我们讨论了编写接口的优点。你可以将你的接口视为一种标准化服务如何工作的方式。有了这个标准，你就可以根据需要做出更改。你可以添加更大的引擎、较小的引擎或混合引擎，而无需进行大规模的改造。让我们看看这是如何工作的。我们已经为翻译编写了接口，现在我们需要让处理器使用它，并让服务满足它。打开你的
    `translate.go` 文件，并添加以下列表中的代码。
- en: Listing 6.5 `translate.go`
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.5 `translate.go`
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ Our handler now becomes a struct that depends on an interface to satisfy the
    translations.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 我们的处理程序现在成为一个依赖于接口以满足翻译的 struct。
- en: ❷ We create a convenience method to create the instance so that you don’t miss
    out on any dependencies.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 我们创建了一个便利方法来创建实例，这样你就不会错过任何依赖项。
- en: ❸ Changes the method to be attached to our struct
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将方法更改为附加到我们的结构体
- en: ❹ Replaces our translation method with the interface
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 用接口替换我们的翻译方法
- en: We’ve created a struct that holds our interface and allows us to call it in
    our handler function. Let’s now update our service to satisfy the interface so
    we can still use it and get our system building again. Open `translator.go`, and
    add the code in the following listing.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个包含我们的接口并允许我们在处理器函数中调用它的结构体。现在让我们更新我们的服务以满足接口，这样我们仍然可以使用它，并让我们的系统重新构建。打开
    `translator.go` 文件，并添加以下列表中的代码。
- en: Listing 6.6 `translate.go`
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.6 `translate.go`
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ Creates a new struct to attach our existing function to
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个新的 struct 来附加我们现有的函数
- en: ❷ Creates a method to instantiate this struct
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 创建一个实例化此结构体的方法
- en: ❸ Attaches the function to the struct and satisfies the interface needed by
    the handler
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将函数附加到结构体并满足处理程序所需的接口
- en: Now comes the dependency injection. As the name implies, we will inject the
    dependent services into the handler struct. Open `main.go`, and add the code in
    the following listing.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是依赖注入。正如其名所示，我们将依赖的服务注入到处理程序结构体中。打开`main.go`，并添加以下列表中的代码。
- en: Listing 6.7 `main.go`
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.7 `main.go`
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ Creates the new static service
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建新的静态服务
- en: ❷ Creates a new handler with the service as a dependency
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 创建一个新的处理程序，将服务作为依赖项
- en: ❸ Registers the function with the mux
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 在路由器上注册函数
- en: As you can see, we create the service we need and pass it to our handler, which
    registers the translation function call. We now have control over what service
    the handler can use. We will take advantage of this later as we expand our services.
    Our FaaS will also fail now that we’ve made the change to the handler. See if
    you can fix it yourself.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们创建了所需的服务并将其传递给处理程序，处理程序注册了翻译函数调用。我们现在可以控制处理程序可以使用哪种服务。我们将利用这一点，随着我们扩展服务。我们的FaaS现在也会因为我们对处理程序的更改而失败。看看你是否能自己修复它。
- en: What is interesting is that during this exercise you can witness how difficult
    it is to make small changes when your services become *tightly coupled*. We can
    see here that making our changes to our handler and service has broken several
    pieces of our code, including our tests. Right now, our code base isn’t that big,
    so imagine what would have happened on a larger project!
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，在这次练习中，你可以看到当你的服务变得紧密耦合时，进行小改动是多么困难。我们可以看到，我们对处理程序和服务的更改破坏了我们的代码的几个部分，包括我们的测试。目前，我们的代码库并不大，想象一下在一个更大的项目中会发生什么！
- en: Now we need to fix our tests. Let’s do the minimum to fix this, and then we’ll
    improve our tests to take advantage of the changes we’ve made. Open `translate
    _test.go`, and add the code in the following listing.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要修复我们的测试。让我们先做最少的修复，然后我们将改进我们的测试以利用我们所做的更改。打开`translate _test.go`，并添加以下列表中的代码。
- en: Listing 6.8 `translate_test.go`
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.8 `translate_test.go`
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ Updates the tests to create the new handler
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 更新测试以创建新的处理程序
- en: ❷ Registers the handler for the test
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 为测试注册处理程序
- en: Implement the changes to `translator_test.go` (see the following listing).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在`translator_test.go`文件中实现更改（见以下列表）。
- en: Listing 6.9 `translate_test.go`
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.9 `translate_test.go`
- en: '[PRE8]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ Creates a new static service to test against
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个新的静态服务进行测试
- en: ❷ Uses this for getting the results for the different test cases
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用此方法获取不同测试用例的结果
- en: You’ll notice that I used a variable called `underTest` in both of these files.
    This is a nice pattern to follow because it allows you to explicitly see what
    you are testing. Now we should be able to see all of our tests run without a problem.
    Commit your changes and push your branch.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到我在这两个文件中都使用了一个名为`underTest`的变量。这是一个很好的模式，因为它允许你明确地看到你在测试什么。现在我们应该能够看到所有测试都能无问题地运行。提交你的更改并推送你的分支。
- en: Why did we go through all of the trouble of refactoring to not have anything
    change functionally?
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们要费这么大的力气重构，却不想在功能上有所改变？
- en: The first reason is to underline the importance of creating interfaces early
    in development instead of doing it later. You can see the difficulty and pain
    of making these changes after the fact instead of planning them out before. I
    did this as a lesson. I remember as a junior developer being assigned the task
    of creating interfaces for all of the services in our system. It was tedious.
    It was painful. Worst of all, the interfaces were sloppy.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个原因是强调在开发早期创建接口的重要性，而不是在之后。你可以看到，在事后而不是在规划之前进行这些更改的困难和痛苦。我这样做是为了一个教训。我记得作为一个初级开发者，我被分配了一个为系统中所有服务创建接口的任务。这是乏味的。这是痛苦的。最糟糕的是，接口是草率的。
- en: Sloppy interfaces are the ones that do too much and have too many parameters.
    They are too broad and difficult to reason about. They have *low cohesion* or
    *coincidental cohesion* because they are grouped arbitrarily and with little thought
    given to their function. Alternatively, if we were to think about our service
    at the onset, we could build something with *high cohesion* or *functional cohesion*
    and group them in a well-defined set of tasks. Functional programmers often tout
    the superiority of their languages because most functions will eventually fall
    into small, highly cohesive functions. But the same can be true of any language
    if you give it enough time and thought. See table 6.1.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 滥用接口是那些做得太多并且有太多参数的接口。它们太宽泛，难以推理。它们具有*低内聚*或*偶然内聚*，因为它们是任意分组，并且很少考虑其功能。或者，如果我们一开始就考虑我们的服务，我们可以构建具有*高内聚*或*功能内聚*的东西，并将它们分组在定义良好的任务集中。功能程序员经常吹嘘他们语言的优越性，因为大多数函数最终都会落入小型、高度内聚的函数中。但任何语言如果给予足够的时间和思考，也可以做到这一点。参见表6.1。
- en: Table 6.1 Cohesion is used to define how well a structure or class is defined.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 表6.1 使用内聚性来定义结构或类定义得有多好。
- en: '| High cohesion | Clearly defined purpose and method definitions |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| 高内聚 | 明确的目的和方法定义 |'
- en: '| Low cohesion | Broad responsibilities that are often all in one class or
    struct |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| 低内聚 | 广泛的责任，通常都在一个类或结构体中 |'
- en: An easy example of this is a class named `Validation` versus a class named `UserRegistrationValidation`.
    In the first case, you have a class that houses too many functions for all types
    of validation within your system, whereas the second provides a more focused validation
    of a specific step in a business process. The second reason for putting you through
    all of this is so we can decouple our tests and make them more atomic, or independent,
    which in the long run, will give us stability and speed up our development. Let’s
    take a look at what that will look like.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子中一个简单的例子就是名为 `Validation` 的类与名为 `UserRegistrationValidation` 的类之间的对比。在前一种情况下，你有一个包含系统中所有类型验证功能的类的集合，而后者则提供了一个针对业务流程中特定步骤的更专注的验证。让我们经历这一切的第二个原因是，我们可以解耦我们的测试，使它们更加原子化，或者说是独立的，这从长远来看，将给我们带来稳定性和加快我们的开发速度。让我们看看这将是什么样子。
- en: 6.4 Testing stubs
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.4 测试存根
- en: 'With dependency injection, we give ourselves some control over a service that
    we didn’t have before. In chapter 3, we introduced the concept of black box testing:
    we can’t see inside the method or structure we are testing and must test it externally.
    As our applications become more complex, the service we are writing tests for
    may become more difficult to reason about. Dependency injection allows us to constrain
    and isolate various parts of the underlying code we are trying to test. This is
    known as *scientific control* within experiments to help minimize the effects
    of the *independent variable* or the thing you are trying to test. In our current
    implementation of the handler, we cannot control how the underlying translation
    service will work, so we cannot control our tests.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 通过依赖注入，我们对自己之前没有控制权的服务有了更多的控制。在第3章中，我们介绍了黑盒测试的概念：我们看不到我们正在测试的方法或结构内部，必须从外部进行测试。随着我们的应用程序变得更加复杂，我们正在为其编写测试的服务可能变得更加难以推理。依赖注入允许我们约束和隔离我们试图测试的底层代码的各个部分。这在实验中被称为*科学控制*，以帮助最小化*独立变量*或你试图测试的东西的影响。在我们当前的处理程序实现中，我们无法控制底层翻译服务的工作方式，因此我们无法控制我们的测试。
- en: Here is an example. Currently, in our handler tests, we expect `/translate/hello?language=dutch`
    to return a 404 message. If we implement the Dutch translation in our underlying
    service, our test will break! This means that our handler tests are coupled with
    the underlying service, which is not what we want to test. Instead, we want to
    understand what will trigger the responses expected from the handler itself. If
    a result comes back as valid, we want to return a 200, which is the HTTP code
    for success, along with the corresponding value. If it is not found, a 404 error
    code will be returned.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子。目前，在我们的处理程序测试中，我们期望 `/translate/hello?language=dutch` 返回一个404消息。如果我们在我们底层服务中实现荷兰语翻译，我们的测试将会失败！这意味着我们的处理程序测试与底层服务耦合在一起，而这并不是我们想要测试的。相反，我们想要了解什么会触发处理程序本身预期的响应。如果结果返回为有效，我们想要返回一个200，这是成功的HTTP代码，以及相应的值。如果未找到，将返回404错误代码。
- en: But now that we can inject our own dependency, we can create our own service
    specifically for testing. This is known as a stub. Stubs are very simple implementations
    of any structure (service, repository, utility) that can be used in testing as
    well as in systems under development. A stub mostly lacks complicated logic and
    returns hardcoded values. This allows us to test the service with known expectations
    of the underlying stubbed service.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 但现在我们能够注入自己的依赖，我们可以创建专门用于测试的自定义服务。这被称为存根。存根是任何结构（服务、仓库、实用工具）的非常简单的实现，可以在测试以及开发中的系统中使用。存根通常缺乏复杂的逻辑，并返回硬编码的值。这使我们能够根据底层存根服务的已知期望来测试服务。
- en: NOTE Stubs can be great placeholders while code is under development. In chapter
    2, we talked about splitting up work among team members to get the smallest delivered
    code possible. This can be accomplished by looking at your code as layers and
    stubbing the underlying dependencies as you move forward. In this example, you
    would stub the service that feeds the code to the handler and solely focus on
    the handler. Once the handler is delivered, consuming applications can start the
    often painful integration process earlier while you continue to build out the
    business logic.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：存根在代码开发期间可以作为很好的占位符。在第2章中，我们讨论了将工作分配给团队成员以获取尽可能小的交付代码。这可以通过将你的代码视为层，并在前进过程中存根底层依赖来实现。在这个例子中，你会存根将代码传递给处理程序的服务，并仅关注处理程序。一旦处理程序交付，消费应用程序可以更早地开始通常痛苦的集成过程，同时你继续构建业务逻辑。
- en: To see this in action, let’s update our test code as in the following listing.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看这个功能是如何工作的，让我们更新我们的测试代码，如下所示。
- en: Listing 6.10 `translate_test.go`
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.10 `translate_test.go`
- en: '[PRE9]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ❶ Creates an empty struct to satisfy your interface
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个空的struct来满足你的接口
- en: ❷ Satisfies the interface expected by the handler
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 满足处理程序期望的接口
- en: ❸ Creates a simple method within the interface to test against
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 在接口内创建一个简单的方法来测试
- en: ❹ Injects the stubbed service for testing
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 注入存根服务进行测试
- en: 'You’ll notice that some things are different here. Mostly, we changed the test
    to focus on the results that come back from our service instead of trying to push
    the logic through to the service. What we want to test is this:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到这里有一些不同。主要的是，我们将测试更改为关注从我们的服务返回的结果，而不是试图将逻辑推送到服务中。我们想要测试的是：
- en: That the default language is English if no language is passed
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有传递语言，则默认语言为英语
- en: That if a language is passed, the language is returned
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果传递了语言，则返回该语言
- en: That if a word that is not translated, we expect a 404 and empty values
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果传递了未翻译的单词，我们期望返回404和空值
- en: I personally like to make clear to the developer that they are test values,
    thus the use of `foo`, `bar`, and `baz`. This helps people realize that we are
    working with fake data instead of real data and focuses their attention on the
    actual logic. This will run well, but it lacks some fidelity. Specifically, we
    are missing the actual values passed to the service itself. Right now, we have
    a bug in our code that was left there intentionally. In our testing chapter, we
    talked about building services that are robust and that handle the standardization
    of input. While we built utilities to support this on the service, we failed to
    pay attention to this on the handler. We can make a call like in the following
    listing.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我个人喜欢清楚地让开发者知道这些是测试值，因此使用了`foo`、`bar`和`baz`。这有助于人们意识到我们正在处理的是假数据而不是真实数据，并使他们的注意力集中在实际逻辑上。这将运行良好，但它缺乏一些精确度。具体来说，我们缺少传递给服务本身的实际值。目前，我们的代码中有一个故意留下的错误。在我们的测试章节中，我们讨论了构建健壮的服务，这些服务可以处理输入的标准化。虽然我们在服务上构建了支持这一点的工具，但我们没有在处理程序上注意到这一点。我们可以像以下列表中那样进行调用。
- en: Listing 6.11 `translate_test.go`
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 列表6.11 `translate_test.go`
- en: '[PRE10]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ❶ Input here shows inconsistent capitalization from what we are expecting on
    the service.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 此处的输入显示与我们在服务上期望的不一致的字母大小写。
- en: ❷ The expectation is that the results should be lowercase.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 预期结果是应该小写的。
- en: Our test would fail. We want to make sure that the language is lowercase when
    we return the value. This way, the results are always standard and our consumers
    can develop against it properly. We want to not only verify that the returned
    value is lowercase but also make sure we are passing the lowercase version to
    our service. How do we do that?
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试将会失败。我们希望确保返回的值时小写的。这样，结果总是标准的，我们的消费者可以正确地针对它进行开发。我们不仅想要验证返回的值是小写的，还要确保我们传递给服务的是小写版本。我们该如何做到这一点？
- en: We could add the logic to our stub to do the verification, but this becomes
    complicated. Instead, we can focus on using something that gives us more control
    around the testing logic by using a mock.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在我们的存根中添加逻辑来进行验证，但这会变得复杂。相反，我们可以通过使用模拟来专注于使用给我们更多测试逻辑控制的东西。
- en: Before we get to mocking, let’s circle back to what we are trying to achieve.
    We are not testing dependencies within our application; instead, we are testing
    how part of our application works *with* the dependencies. This distinction has
    to be clear because we want each piece to be independently testable and verifiable.
    Therefore, when you find that a portion of your code depends on an external library
    or service, you should consider how it will be incorporated into your testing
    strategy.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进行模拟之前，让我们回顾一下我们试图实现的目标。我们不是在测试我们应用程序中的依赖项；相反，我们是在测试我们应用程序的某个部分是如何与依赖项一起工作的。这种区别必须清楚，因为我们希望每个部分都是可以独立测试和验证的。因此，当你发现你的代码的一部分依赖于外部库或服务时，你应该考虑它将如何融入你的测试策略。
- en: 6.5 Mocking
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.5 模拟
- en: In baseball, batters typically warm up with a pitching machine. This machine
    stands in for a person to help the batter practice their swing. In practice, the
    batter may face a live player who throws them the ball. This person isn’t a pitcher
    but is someone who can give the batter just enough variation that makes it *higher
    fidelity* by making it more realistic. Finally, during the game, the hitter will
    encounter a real pitcher, and hopefully they are ready.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在棒球中，击球手通常用投球机进行热身。这个机器代替人，帮助击球手练习挥棒。在实践中，击球手可能会面对一个真人投球手，这个人不是投球手，但可以给击球手提供足够的变数，使其更加逼真，从而提高逼真度。最后，在比赛中，击球手将遇到真正的投球手，希望他们已经准备好了。
- en: In testing we want to exercise our code in the same way. In the previous section
    we talked about stubs, which act as a placeholder for a service but with expected
    results. These stubs don’t do very much, and you may find that you are adding
    strange logic code in your stub to make your tests work as expected. Before you
    go down that path you should consider mocking.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试中，我们希望以相同的方式锻炼我们的代码。在前一节中，我们讨论了存根，它充当服务的一个占位符，但具有预期的结果。这些存根做得不多，你可能会发现你正在你的存根中添加奇怪的逻辑代码，以便你的测试按预期工作。在你走那条路之前，你应该考虑模拟。
- en: '*Mocking* is like a stub but with more detail. With mocks you create a similar
    object, but you can attach methods that allow you to assert if certain methods
    were called and with what values. It can change functionality per test so that
    you can test error handling and strange values. Overall, it provides you with
    a deeper insight into how your function works and how you can test every edge
    case.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '*模拟*就像一个存根，但更详细。使用模拟，你可以创建一个类似的对象，但你可以附加方法，这样你就可以断言某些方法是否被调用以及调用时使用了什么值。它可以按测试更改功能，这样你就可以测试错误处理和奇怪值。总的来说，它为你提供了更深入的了解，了解你的函数是如何工作的，以及你如何测试每个边缘情况。'
- en: 'To help demonstrate this we will first add a feature to our system and then
    test it with a mock. If we cannot find the result in our database, we will call
    an external service using a client to fetch the result from the old system. To
    do this, we will first create an interface so that we can interchange them when
    we are ready to release the feature. Let’s see what this service looks like:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助演示这一点，我们首先将在我们的系统中添加一个功能，然后用模拟来测试它。如果我们无法在我们的数据库中找到结果，我们将使用客户端调用外部服务以从旧系统中获取结果。为此，我们首先创建一个接口，这样我们就可以在准备发布功能时进行交换。让我们看看这个服务是什么样子：
- en: '[PRE11]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Next, add the code in the following listing.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，添加以下列表中的代码。
- en: Listing 6.12 `remote_translator.go`
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.12 `remote_translator.go`
- en: '[PRE12]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ❶ Verifies that the struct we are building satisfies the interface. This will
    cause a compile-time error if not satisfied.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 验证我们正在构建的struct是否满足接口。如果不满足，这将导致编译时错误。
- en: ❷ Uses a new interface for making calls to external API
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用新的接口调用外部API
- en: ❸ Creates an interface for the client that calls and translates
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 为调用和翻译的客户端创建一个接口
- en: ❹ Uses the client to make external calls
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 使用客户端进行外部调用
- en: Notice that we’ve added a new interface called `HelloClient`. Right now, all
    we have the service do is call the client and return the results. This will be
    the basis for our test. With mocking, you will find out that a lot of boilerplate
    occurs, so it is easier to organize our tests in `test suites` or groupings of
    tests that have a similar setup and tear down functionality. This means that we
    can establish our mock and test against it in various ways without conflicting
    setups or strange side effects.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们添加了一个名为 `HelloClient` 的新接口。目前，我们让服务只调用客户端并返回结果。这将是我们的测试基础。通过模拟，你会发现有很多样板代码，因此更容易将我们的测试组织在
    `test suites` 或具有相似设置和拆卸功能的测试分组中。这意味着我们可以以各种方式建立模拟并对其进行测试，而不会出现冲突设置或奇怪的外部效应。
- en: 6.5.1 Setting up our test suite
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.5.1 设置我们的测试套件
- en: 'Luckily, there is a great testing tool kit called `testify` that will handle
    both suites and mocking. This library provides suites, assertion helpers, and
    mocks to help us with our testing. To use this, we will import our first external
    library:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有一个名为 `testify` 的优秀测试工具包，它可以处理套件和模拟。这个库提供了套件、断言辅助工具和模拟，帮助我们进行测试。为了使用它，我们将导入我们的第一个外部库：
- en: '[PRE13]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: NOTE GoMock is a popular alternative to Testify’s mock tool. It has a mechanism
    for generating specific mocks for your interfaces.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：GoMock 是 Testify 模拟工具的一个流行替代品。它有一个为你的接口生成特定模拟的机制。
- en: 'Now let’s create our test file and set up our suite:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建我们的测试文件并设置我们的套件：
- en: '[PRE14]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Next, add the code in the following listing.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，添加以下列表中的代码。
- en: Listing 6.13 `remote_translator_test.go`
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.13 `remote_translator_test.go`
- en: '[PRE15]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: ❶ Go’s testing framework expects tests to start with the word Test and have
    the (t *testing.T) method. This will be used to trigger our suite.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ Go 的测试框架期望测试以单词 Test 开头，并具有 (t *testing.T) 方法。这将用于触发我们的套件。
- en: ❷ Builds a suite that houses whatever dependencies we need to run our tests
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 构建一个包含我们运行测试所需的任何依赖项的套件
- en: ❸ Extends the Suite struct to use default methods
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 扩展 Suite 结构体以使用默认方法
- en: ❹ SetupTest will run before each test. Here, we initialize the mocked client
    and the service to test.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ SetupTest 在每个测试之前运行。在这里，我们初始化模拟客户端和要测试的服务。
- en: ❺ Creates a Mock struct to satisfy the interface
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 创建一个 Mock 结构体以满足接口
- en: ❻ Extends Mock to use methods to track calls
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 扩展 Mock 以使用方法来跟踪调用
- en: ❼ Satisfies the interface for the Mock
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 满足 Mock 接口
- en: ❽ Asserts that the values were called with the expected values
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 断言值以期望的值被调用
- en: ❾ Returns the values from the mock
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: ❾ 从模拟返回值
- en: We have wrapped our traditional testing mechanism from the testing library in
    a struct that extends a `Suite` struct. With this structure, `testify` can use
    the `SetupTest` function to run before we run any tests. We then use the `Mock`
    structure to extend the functionality we will need to verify and manipulate the
    test so that we can try various edge cases. Testify allows you to use various
    setup and teardown commands to help reduce duplication of code, and in the case
    of mocks, reset their values.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将测试库的传统测试机制包装在一个扩展 `Suite` 结构体的结构体中。使用这种结构，`testify` 可以使用 `SetupTest` 函数在我们运行任何测试之前运行。然后我们使用
    `Mock` 结构体来扩展我们将需要验证和操作测试的功能，以便我们可以尝试各种边缘情况。Testify 允许你使用各种设置和拆卸命令来帮助减少代码重复，在模拟的情况下，重置它们的值。
- en: We will explore some additional setup and teardowns in the next section, but
    for now, you can see how we are organizing our suite so that we can focus on the
    actual tests.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节中探索一些额外的设置和拆卸，但到目前为止，你可以看到我们如何组织套件，以便我们可以专注于实际的测试。
- en: 6.5.2 Using our mocks in test
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.5.2 在测试中使用我们的模拟
- en: We have written a service that calls a remote endpoint for a value and returns
    it to the user. This obviously isn’t what we want long term, but we’ll let the
    tests drive the writing of this service. First, let’s get our tests written (see
    the following listing), and then we will work on enhancing our service.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写了一个服务，它调用远程端点获取值并将其返回给用户。这显然不是我们长期想要的，但我们将让测试驱动这个服务的编写。首先，让我们编写我们的测试（见以下列表），然后我们将着手改进我们的服务。
- en: Listing 6.14 `remote_translator_test.go`
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.14 `remote_translator_test.go`
- en: '[PRE16]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: ❶ Tells the mock what to expect as input and what to return
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 告诉模拟期望的输入和返回值
- en: ❷ Suites have assertion libraries that act as convenience methods in testing.
    Here, we check if the values are equal.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 套件具有断言库，这些库在测试中充当便利方法。在这里，我们检查值是否相等。
- en: ❸ Asserts the calls were made on the mock
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 断言在模拟上进行了调用
- en: Now run your tests, and see if they pass. This gives us more control over the
    dependency to verify that the service was called along with asserting the values
    by which the service was called. This is powerful because all too often, bugs
    can happen because a service may expect values to come in a certain format that
    the calling service may have forgotten or missed. Mocks provide a way for us to
    verify the values as part of the setup (see the following listing).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行您的测试，看看它们是否通过。这使我们能够更好地控制依赖关系，以验证服务是否被调用，并通过断言服务调用的值。这是强大的，因为过于频繁地，错误可能发生，因为一个服务可能期望以某种格式接收值，而调用服务可能已经忘记或遗漏了。模拟提供了一种方法，使我们能够在设置过程中验证值（见以下列表）。
- en: Listing 6.15 `remote_translator_test.go`
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.15 `remote_translator_test.go`
- en: '[PRE17]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: ❶ This is the same expectation we had before from our mock. We will try to see
    if our method passes the expected input to the service it’s calling.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 这是我们之前从模拟中得到的相同期望。我们将尝试查看我们的方法是否将预期的输入传递给了它所调用的服务。
- en: ❷ Here, we change the input so that the test will fail.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在这里，我们更改输入，以便测试将失败。
- en: Run this, and you should see a failure. It says it expected the input to be
    `foo`, not `Foo`. Here, the mock verifies the expectations we set earlier. Now
    we need to change our function to reflect this requirement (see the following
    listing).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 运行这个，你应该看到失败。它表示它期望输入为 `foo`，而不是 `Foo`。在这里，模拟验证了我们之前设定的期望。现在我们需要更改我们的函数以反映这一要求（见以下列表）。
- en: Listing 6.16 `remote_translator.go`
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.16 `remote_translator.go`
- en: '[PRE18]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: ❶ Lowercases the input so that your tests pass
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将输入转换为小写，以便您的测试通过
- en: Now your tests should pass. Not only can we use a mock to verify the input,
    but it allows us to control the output. Here, we can add a simple test with minimal
    changes to see what happens if we get an error (see the following listing)
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您的测试应该通过。我们不仅可以使用模拟来验证输入，而且它还允许我们控制输出。在这里，我们可以添加一个简单的测试，只需进行最小更改，以查看如果发生错误会发生什么（见以下列表）。
- en: Listing 6.17 `remote_translator_test.go`
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.17 `remote_translator_test.go`
- en: '[PRE19]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: ❶ Now we return an error to see how we handle it.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 现在我们返回一个错误以查看我们如何处理它。
- en: ❷ We should not get an answer back.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 我们不应该得到任何回答。
- en: Ah, we aren’t handling the error in our service! Let’s fix that using the code
    in the following listing.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 哎，我们没有在我们的服务中处理错误！让我们使用以下列表中的代码来修复它。
- en: Listing 6.18 `remote_translator.go`
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.18 `remote_translator.go`
- en: '[PRE20]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: ❶ Handles the error
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 处理错误
- en: Now we can verify how we handle this error. See how we could easily extend the
    test without changing how our mock is created? Stubs don’t provide this level
    of control by default and need to have special programming to handle these types
    of cases. Instead, our mock provides us with the ability to inject errors and
    verify inputs without needing to change the underlying implementation.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以验证我们如何处理这个错误。看看我们如何能够轻松地扩展测试而不改变我们创建模拟的方式？存根默认不提供这种级别的控制，并且需要特殊的编程来处理这些类型的案例。相反，我们的模拟为我们提供了注入错误和验证输入的能力，而无需更改底层实现。
- en: NOTE Why even test the error? It may seem pointless in this example, but it
    can be helpful in most cases. Errors happen constantly in code, and business rules
    need to be associated with each type of error. Here, we just log the error and
    return an empty string. Our test verifies that no matter what, we should return
    an empty string in the case of a failed translation.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 备注：为什么还要测试错误？在这个例子中，它可能看起来毫无意义，但在大多数情况下它可能是有帮助的。错误在代码中不断发生，业务规则需要与每种类型的错误相关联。在这里，我们只是记录错误并返回一个空字符串。我们的测试验证了无论发生什么，在翻译失败的情况下，我们都应该返回一个空字符串。
- en: The final feature we want to add to our service is a cache. Most times, when
    calling an external or remote service, it is important to save the values to reduce
    the number of calls. This makes your service faster because it doesn’t require
    waiting on a response from a server; it also makes it dependable, and in some
    cases, it saves you money. We want to verify that if we make the call with the
    same value, it only happens once. Our mock can keep track of this for us (see
    the following listing).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要添加到我们服务中的最后一个功能是一个缓存。大多数时候，在调用外部或远程服务时，保存值以减少调用次数是很重要的。这使得你的服务更快，因为它不需要等待服务器的响应；它也使服务更可靠，在某些情况下，它还能为你省钱。我们希望验证，如果我们用相同的值进行调用，它只会发生一次。我们的模拟可以为我们跟踪这一点（见以下列表）。
- en: Listing 6.19 `remote_translator_test.go`
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.19 `remote_translator_test.go`
- en: '[PRE21]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: ❶ Asserts that this command was only run once
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 断言此命令只运行了一次
- en: ❷ Makes the call twice to test the cache. Notice that we are using capitalization
    so we know that our business logic should lowercase the value before looking in
    the cache.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 对缓存进行两次调用以测试缓存。注意，我们使用大写字母，这样我们知道我们的业务逻辑在查找缓存之前应该将值转换为小写。
- en: You should see a failure when you run your test. Let’s fix this by using an
    in-memory map in the next listing.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行测试时，你应该看到失败。让我们通过在下一个列表中使用内存映射来修复这个问题。
- en: Listing 6.20 `remote_translator.go`
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.20 `remote_translator.go`
- en: '[PRE22]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: ❶ Uses an in-memory map for a cache
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用内存映射作为缓存
- en: ❷ Creates the map as part of initialization
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在初始化过程中创建映射
- en: ❸ Creates a key for your map to store the translation
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 为你的映射创建一个键来存储翻译
- en: ❹ Checks the cache for the key
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 检查缓存中的键
- en: ❺ If the value was found, returns it
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 如果找到了值，则返回它
- en: ❻ Makes the translation call
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 进行翻译调用
- en: ❼ Stores the value in the cache
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 将值存储在缓存中
- en: Perfect! Now run your tests and see that they all pass. Mocks can be a powerful
    tool for testing, but be warned that they can become complicated and your tests
    can become hard to follow. This is where as a team you will need to focus on the
    *compatibility* or easy assembly of services and functions and the relationship
    between them. If a test becomes burdened with a bunch of mocks, the service may
    need to be broken up. If a mock needs to be changed constantly because of a changing
    interface, you may need to rethink your abstraction. Mocks aren’t the silver bullet
    for testing; they’re just one tool to help you test your code in isolation and
    enhance your unit testing.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 完美！现在运行你的测试，看看它们是否都通过了。模拟可以是一个强大的测试工具，但警告，它们可能会变得复杂，你的测试可能会变得难以跟踪。这就是作为一个团队，你需要专注于服务的*兼容性*或易于组装以及它们之间关系的地方。如果一个测试因为一堆模拟而变得负担过重，服务可能需要被拆分。如果一个模拟因为接口的变化而需要不断更改，你可能需要重新思考你的抽象。模拟不是测试的万能药；它们只是帮助你测试代码的一个工具，以便在隔离的环境中测试你的代码并增强你的单元测试。
- en: 6.6 Fake
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.6 模拟
- en: Finally, we will add one more set of unit tests for a client that calls an external
    API. Here, we come up against a different type of interface testing, this time
    with an API that we don’t control. Like our other interfaces tests, we can establish
    a *contract* or definition of what this API should look like and use a fake to
    simulate it.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将为调用外部API的客户端添加一组单元测试。在这里，我们遇到了不同类型的接口测试，这次是与我们不控制的API。像我们的其他接口测试一样，我们可以建立一个*契约*或定义这个API应该是什么样子，并使用模拟来模拟它。
- en: WARNING We don’t have control over the other API, just our own, and if something
    were to change on the other API, we could end up with failures. This fake is simulating
    an *external dependency*, or a system outside our control, and therefore should
    be monitored and heavily logged in case failures such as outages occur. Advanced
    system patterns such as Circuit Breakers should be used, but they are outside
    the context of this book. I suggest *Cloud Native Patterns* (Manning, 2019) by
    Cornelia Davis.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 警告 我们无法控制其他API，只是我们自己的，如果其他API发生变化，我们可能会遇到失败。这个模拟正在模拟一个*外部依赖*，或者是我们无法控制的外部系统，因此应该对其进行监控并大量记录，以防出现故障。应该使用高级系统模式，如断路器，但它们超出了本书的范围。我建议阅读Cornelia
    Davis的《Cloud Native Patterns》（Manning，2019）。
- en: A *fake* is an object, struct, or service with limited capabilities. So far,
    we have described stubs and mocks in the context of testing. We will use the term
    *fake* as a definition of an object that stands in for an external service. Fakes
    provide this last category of tools to help us verify the base units of our code
    before we start moving toward integrating with external integration.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 一个*模拟*是一个具有有限功能的对象、结构或服务。到目前为止，我们已经在测试的上下文中描述了存根和模拟。我们将使用*模拟*这个术语来定义代表外部服务的对象。模拟提供了这一类工具，帮助我们验证代码的基本单元，在我们开始与外部集成之前。
- en: Go provides the ability to create a test server to call against, which makes
    our testing easier. We will use a fake HTTP server to build our fake to test a
    client we create. Let’s set up our suite before we get into the details of the
    implementation. First, create the files using
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Go提供了创建测试服务器的功能，这使得我们的测试更容易。我们将使用一个模拟HTTP服务器来构建我们的模拟以测试我们创建的客户端。在我们深入了解实现细节之前，让我们设置我们的套件。首先，使用以下命令创建文件：
- en: '[PRE23]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: and then add the code in the following listing.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在下面的列表中添加代码。
- en: Listing 6.21 `client_test.go`
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.21 `client_test.go`
- en: '[PRE24]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: ❶ Use a test server to run against
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用测试服务器进行测试
- en: ❷ We are going to be testing the interface defined here.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 我们将测试这里定义的接口。
- en: ❸ Similar mock to the ones we’ve seen before to help us inject values into the
    handler
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 与我们之前看到的类似的模拟，帮助我们向处理器注入值
- en: To set up our client test, we will need to create a handler that captures the
    message to test what the client passes (see the following listing).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设置我们的客户端测试，我们需要创建一个处理器来捕获消息以测试客户端传递的内容（见以下列表）。
- en: Listing 6.22 `client_test.go`
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.22 `client_test.go`
- en: '[PRE25]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: ❶ SetupSuite is used because we don’t want to create a new server for each test,
    just this group of tests.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用SetupSuite是因为我们不希望为每个测试创建一个新的服务器，只需为这个测试组创建即可。
- en: ❷ Use the mock to get information and then handle the response using the correct
    error codes.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 使用模拟来获取信息，然后使用正确的错误代码处理响应
- en: ❸ Start the test server.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 启动测试服务器。
- en: ❹ Shut down the server at the end of the suite.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 在套件结束时关闭服务器。
- en: NOTE We are setting up a database within the context of our test. Alternatively,
    you can use tools such as WireMock, which is language agnostic.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：我们在测试的上下文中设置了一个数据库。或者，您可以使用如WireMock之类的工具，它是语言无关的。
- en: We are setting up a fake server with an HTTP handler that uses a mock so that
    we can test how the client handles various message types. Specifically, we want
    to see what happens when an error occurs, the result cannot be found, or a good
    result is found. The actual test cases will need to be written out once we’ve
    built the client, but you can see here how the setup of our suite will drive that
    design from the start. Let’s use the code in the following listing to write our
    client and then write our tests.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在设置一个带有HTTP处理器的假服务器，该处理器使用模拟，以便我们可以测试客户端如何处理各种消息类型。具体来说，我们想看看当发生错误、结果无法找到或找到良好结果时会发生什么。实际的测试用例将在我们构建客户端后编写出来，但您可以看到我们的套件设置如何从一开始就驱动该设计。让我们使用以下列表中的代码来编写我们的客户端，然后编写我们的测试。
- en: Listing 6.23 `client.go`
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.23 `client.go`
- en: '[PRE26]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: ❶ Types check to make sure it fulfills the interface
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 类型检查以确保它满足接口
- en: ❷ Stores the passed-in endpoint to call
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 存储传入的端点以进行调用
- en: ❸ Makes the external call to the server
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 向服务器发起外部调用
- en: ❹ Checks the status codes to properly handle the response
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 检查状态码以正确处理响应
- en: ❺ Uses a generic struct to get values from the JSON
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 使用通用结构体从JSON中获取值
- en: Now the client will make the call to a server based on the provided endpoint
    and handle the results, giving the calling service the translated text. As you
    can see, we have plenty of paths to go down for tests, and most of them are failure
    cases. We will go through a few cases, but I’ll let you finish up the others.
    Since we have almost everything already set up, the last thing we need to do before
    writing our tests is add our new client to the test suite (see the following listing).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在客户端将根据提供的端点调用服务器并处理结果，给调用服务提供翻译后的文本。如您所见，我们有大量的路径可以用于测试，其中大多数是失败案例。我们将通过几个案例，但我会让您完成其他案例。由于我们几乎已经设置了一切，我们在编写测试之前需要做的最后一件事是将我们的新客户端添加到测试套件中（见以下列表）。
- en: Listing 6.24 `client_test.go`
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.24 `client_test.go`
- en: '[PRE27]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: ❶ Creates the client in the suite and passes the unique server URL to it
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在套件中创建客户端并将其唯一的服务器URL传递给它
- en: Now we can start writing some tests. We can use the mock the same way we did
    in our other tests to manipulate the output of our fake server. First, we will
    take the happy path rather than two failure cases (see the following listing).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以开始编写一些测试了。我们可以像在其他测试中一样使用模拟来操纵假服务器的输出。首先，我们将采取快乐路径而不是两个失败案例（见以下列表）。
- en: Listing 6.25 `client_test.go`
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 6.25 `client_test.go`
- en: '[PRE28]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: ❶ Makes the system return valid JSON
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使系统返回有效的JSON
- en: ❷ Checks to see that there wasn’t an error
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 检查是否没有错误
- en: ❸ Returns an error to test the error status
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 返回错误以测试错误状态
- en: ❹ Checks the returned error value to make sure the right error was passed
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 检查返回的错误值以确保传递了正确的错误
- en: ❺ Makes the system fail by sending the wrong content
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 通过发送错误内容使系统失败
- en: Can you add tests for bad input and not found responses?
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以为不良输入和未找到响应添加测试用例吗？
- en: 6.7 Just the base of the pyramid
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.7 金字塔的基础
- en: In chapter 3, we talked about how unit tests provide us with the base we need
    for the rest of our tests. In that chapter, our tests were fairly simple, but
    as you can see, once other functions and systems get involved, they become more
    complicated. This dependency can be avoided by creating abstractions, but those
    abstractions need to be tested in a realistic way. It is up to you to find this
    out and explore ways of keeping your services as simple as possible. If your test
    code becomes complicated, it might cause you to pause and look at your code to
    see if it can be simplified and refactored. See table 6.2.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在第3章中，我们讨论了单元测试如何为我们提供其余测试所需的基础。在那个章节中，我们的测试相当简单，但正如你所看到的，一旦其他函数和系统介入，它们就会变得更加复杂。可以通过创建抽象来避免这种依赖，但这些抽象需要以现实的方式进行测试。这取决于你发现这一点并探索保持你的服务尽可能简单的方法。如果你的测试代码变得复杂，它可能会让你停下来，看看你的代码是否可以简化并重构。参见表6.2。
- en: Table 6.2 Comparing stubs, mocks, and fakes
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 表6.2 比较存根、模拟和伪造
- en: '| Type | Pros | Cons |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 优点 | 缺点 |'
- en: '| Stub | Easy to create and manipulate | Verification can become complicated.
    |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| 存根 | 创建和操作简单 | 验证可能变得复杂。 |'
- en: '| Mock | Records interactions for later verification | More complex setup and
    teardown. |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| 模拟 | 记录交互以供后续验证 | 设置和拆除更复杂。 |'
- en: '| Fake | Higher-fidelity interactions with a simulated system | Complicated
    to write and maintain. |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| 伪造 | 与模拟系统的交互更高保真 | 编写和维护复杂。 |'
- en: Our introduction to stubs, mocks, and fakes gives you tools to help you write
    better tests. Be aware that these tools should not preempt good design. When writing
    code, you will sometimes find that you have a ton of mocks floating around or
    that your fake becomes too complicated. These are canaries in your coal mine,
    and these should raise some flags about your implementation. Maybe your code needs
    to be broken up. Maybe you need to rethink your design. In any case, you need
    to watch and think about how you are testing and writing your code. Tests provide
    an excellent mirror to what you are doing. Complicated structs are hard to write
    tests for and therefore are more prone to errors. Cracks in the foundation of
    your testing pyramid, as seen in figure 6.3, will lead to a decrease in confidence
    about your code, so take your time to think about what you are writing and how
    you are structuring your tests and your code.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对存根、模拟和伪造的介绍为你提供了编写更好测试的工具。请注意，这些工具不应取代良好的设计。在编写代码时，你有时会发现你周围有大量的模拟，或者你的伪造变得过于复杂。这些都是你的煤矿中的金丝雀，它们应该会引发一些关于你实现的问题。也许你的代码需要被拆分。也许你需要重新思考你的设计。无论如何，你需要关注并思考你如何测试和编写代码。测试为你提供了一个极好的反映你正在做的事情的镜子。复杂的结构很难编写测试，因此更容易出错。如图6.3所示，测试金字塔的基础上的裂缝将导致你对代码的信心下降，所以请花时间思考你正在写什么，以及你如何构建你的测试和代码结构。
- en: '![](../../OEBPS/Images/CH06_F03_Holmes4.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH06_F03_Holmes4.png)'
- en: Figure 6.3 We have now covered the base of our pyramid using these techniques.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3 我们现在已经使用这些技术覆盖了金字塔的底部。
- en: We find ourselves slowly crawling up the pyramid and still have the middle and
    top layers to add to our system to help us establish some confidence in what we
    are building. But these tests are going to become even more complicated to manage
    and less dependable, and therefore will require a different part of our pipeline.
    The theme I’m trying to establish in this book is this notion of starting from
    a place of simplicity and moving toward the complex. Complexity should be avoided
    if at all possible but is sometimes unavoidable as a trade-off. You alone will
    be able to determine when it is time to move toward complexity based either on
    features or the size of your team. Working together, you and your team will figure
    out the best way to build, test, and run your application.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们发现自己正缓缓地向上爬金字塔，仍然需要添加中间和顶层到我们的系统中，以帮助我们对我们正在构建的东西建立一些信心。但这些测试将变得更加复杂，难以管理，因此将需要我们管道的不同部分。我在这本书中试图确立的主题是从简单的地方开始，向复杂发展。如果可能的话，应尽量避免复杂性，但有时作为权衡，它不可避免。你将能够独自决定何时根据功能或你团队的大小转向复杂性。你们一起，你和你的团队将找出构建、测试和运行应用程序的最佳方式。
- en: “Wow, that was neat. I didn’t realize I would be contributing something so important
    on my first day.” You smile. It is really nice to see someone learn something
    new and help them understand how your system works. A few more pair programming
    sessions like this and the intern will be ready to teach the next person who comes
    on board. So far, she’s been able to contribute both test code and feature code.
    Now it’s time to teach her the infrastructure.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: “哇，这真不错。我没想到第一天就能贡献这么重要的事情。”你微笑着说。看到有人学到新东西并帮助他们理解你的系统是如何工作的，真的很好。再进行几轮这样的结对编程，实习生就能准备好教下一位加入的人了。到目前为止，她已经能够贡献测试代码和功能代码。现在是时候教她基础设施了。
- en: Summary
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Interfaces can be used to define the communication between services and act
    as an abstraction to isolate your code.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口可以用来定义服务之间的通信，并作为抽象来隔离你的代码。
- en: Services that satisfy an interface can then be passed into a service as a dependency
    allowing you to inject the code you want to support the service.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 满足接口的服务可以被作为依赖项传递给服务，这样你就可以注入你想要支持服务的代码。
- en: Suites allow you to set up and tear down tests and groups of tests in a uniform
    way.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Suites 允许你以统一的方式设置和拆除测试以及测试组。
- en: Stubs are lightweight structures that can help you test a service without external
    dependencies in a simple way.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Stubs 是轻量级结构，可以帮助你以简单的方式测试服务，而无需外部依赖。
- en: Mocks add more dimensions to your tests by allowing you to verify calls and
    their content.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mocks 通过允许你验证调用及其内容，为你的测试增加了更多维度。
- en: Fakes can be used in conjunction with mocks and stubs to stand in completely
    for another service.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Fakes 可以与 Mocks 和 Stubs 结合使用，完全替代另一个服务。
