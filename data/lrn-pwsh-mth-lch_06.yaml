- en: '6 The pipeline: Connecting commands'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 6 管道：连接命令
- en: 'In chapter 4, you learned that running commands in PowerShell is the same as
    running commands in any other shell: you type a cmdlet name, give it parameters,
    and press Enter. What makes PowerShell special isn’t the way it runs commands
    but the way it allows multiple commands to be connected to each other in powerful,
    one-line sequences.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在第4章中，你了解到在PowerShell中运行命令与在任何其他shell中运行命令相同：你输入一个cmdlet名称，给它参数，然后按Enter。使PowerShell特殊的地方不在于它运行命令的方式，而在于它允许将多个命令以强大的单行序列连接在一起的方式。
- en: '6.1 Connecting one command to another: Less work for you'
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.1 将一个命令连接到另一个命令：为你减少工作量
- en: PowerShell connects commands to each other by using a *pipeline*. The pipeline
    provides a way for one command to pass, or *pipe*, its output to another command,
    allowing that second command to have something to work with. This can be seen
    with the vertical bar `|` between two cmdlets (figure 6.1).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell通过使用*管道*将命令连接在一起。管道提供了一种方式，允许一个命令将其输出传递或*管道*到另一个命令，使第二个命令有东西可以处理。这可以通过两个cmdlet之间的垂直线`|`（图6.1）看到。
- en: '![](Images/CH06_F01_Plunk.png)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH06_F01_Plunk.png)'
- en: Figure 6.1 Showing the pipe `|` in a command
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1 展示了命令中的管道`|`
- en: You’ve already seen this in action in commands such as `Dir` `|` `more`. You’re
    piping the output of the `Dir` command into the `more` command; the `more` command
    takes that directory listing and displays it one page at a time. PowerShell takes
    that same piping concept and extends it to greater effect.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经在`Dir` `|` `more`等命令中看到了这个功能。你正在将`Dir`命令的输出管道传输到`more`命令；`more`命令接收那个目录列表并逐页显示。PowerShell采用相同的管道概念并将其扩展到更有效果。
- en: PowerShell’s use of a pipeline may seem similar at first to the way UNIX and
    Linux shells work. Don’t be fooled, though. As you’ll come to realize over the
    next few chapters, PowerShell’s pipeline implementation is much richer and more
    modern.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell对管道的使用可能一开始看起来与UNIX和Linux shell的工作方式相似。但不要被误导。正如你将在接下来的几章中意识到的那样，PowerShell的管道实现要丰富得多，也更现代。
- en: 6.2 Exporting to a file
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.2 导出到文件
- en: PowerShell provides several powerful ways to export data to useful formats,
    such as TXT, CSV, JSON, and XML (Extensible Markup Language). In your workflow,
    you may need to export data from Azure Active Directory or from cloud storage.
    In this chapter, we will go through the process of piping data. We will start
    by getting the data from some simple built-in commands to simplify the process,
    but the concept is the same.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell提供了几种强大的方式将数据导出为有用的格式，例如TXT、CSV、JSON和XML（可扩展标记语言）。在你的工作流程中，你可能需要从Azure
    Active Directory或从云存储中导出数据。在本章中，我们将介绍管道数据的过程。我们将从获取一些简单的内置命令的数据开始，以简化过程，但概念是相同的。
- en: 'Let’s start by running a few simple commands. Then we’ll learn how to join
    them together. Here are a few commands that we can use:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从运行几个简单的命令开始。然后我们将学习如何将它们连接起来。以下是我们可以使用的一些命令：
- en: '`Get-Process` (or `gps`)'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Get-Process`（或`gps`）'
- en: '`Get-Command` (or `gcm`)'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Get-Command`（或`gcm`)'
- en: '`Get-History -count 10` (or `h`)'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Get-History -count 10`（或`h`）'
- en: We picked these commands because they’re easy and straightforward. We gave you
    the aliases for `Get-Process` and `Get-Command` in parentheses. For `Get-History`,
    we specified the `-count` parameter with a value of `10` so that we only get the
    last 10 history entries.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择这些命令是因为它们简单直接。我们在括号中给出了`Get-Process`和`Get-Command`的别名。对于`Get-History`，我们指定了`-count`参数的值为`10`，这样我们只获取最后10个历史条目。
- en: Try it Now Go ahead and choose the commands you want to work with. We use `Get-Process`
    for the following examples; you can stick with one of the three we’ve listed,
    or switch between them to see the differences in the results.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试看 选择你想要使用的命令。我们使用`Get-Process`作为以下示例；你可以坚持我们列出的其中之一，或者在这三者之间切换以查看结果的不同。
- en: What do you see? When we run `Get-Process`, a table with several columns of
    information appears on the screen (figure 6.2).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到了什么？当我们运行`Get-Process`时，一个包含多个信息列的表格出现在屏幕上（图6.2）。
- en: '![](Images/CH06_F02_Plunk.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH06_F02_Plunk.png)'
- en: Figure 6.2 The output of `Get-Process` is a table with several columns of information.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2 `Get-Process`的输出是一个包含多个信息列的表格。
- en: It’s great to have that information on the screen, but you might want to do
    more with the information. For example, if you want to make charts and graphs
    of memory and CPU utilization, you might want to export the information into a
    CSV file that could be read into an application for further data manipulation.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在屏幕上显示这些信息是很好的，但你可能还想做更多的事情。例如，如果你想制作内存和CPU利用率的图表和图形，你可能想将信息导出到一个CSV文件中，该文件可以被导入到应用程序中进行进一步的数据处理。
- en: 6.2.1 Exporting to CSV
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2.1 导出到CSV
- en: 'Exporting to a file is where the pipeline and a second command come in handy:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 将信息导出到文件时，管道和第二个命令很有用：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Similar to piping `Dir` to `more`, we’ve piped our processes to `Export-CSV`.
    That second cmdlet has a mandatory positional parameter (discussed in chapter
    3) that we’ve used to specify the output filename. Because `Export-CSV` is a native
    PowerShell cmdlet, it knows how to translate the output generated by `Get-Process`
    into a standard CSV file.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 与将`Dir`通过管道传递到`more`类似，我们已经将我们的进程通过管道传递到`Export-CSV`。第二个cmdlet有一个必须的位置参数（在第3章中讨论），我们已使用它来指定输出文件名。因为`Export-CSV`是一个本机PowerShell
    cmdlet，它知道如何将`Get-Process`生成的输出转换为标准CSV文件。
- en: Go ahead and open the file in Visual Studio Code to see the results, as shown
    in figure 6.3.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 继续在Visual Studio Code中打开文件，查看结果，如图6.3所示。
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '![](Images/CH06_F03_Plunk.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH06_F03_Plunk.png)'
- en: Figure 6.3 Viewing the exported CSV file in Windows Notepad
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3 在Windows记事本中查看导出的CSV文件
- en: The first line of the file contains column headings, and the subsequent lines
    list the information for the various processes running on the computer. You can
    pipe the output of almost any `Get-` cmdlet to `Export-CSV` and get excellent
    results. You may also notice that the CSV file contains a great deal more information
    than what’s typically shown on the screen. That’s intentional. The shell knows
    it can’t possibly fit all of that information on the screen, so it uses a configuration,
    supplied by Microsoft, to select the most important information for onscreen display.
    In later chapters, we’ll show you how to override that configuration to display
    whatever you want.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 文件的第一行包含列标题，随后的行列出计算机上运行的各个进程的信息。你可以将几乎任何`Get-` cmdlet的输出通过管道传递到`Export-CSV`，以获得出色的结果。你可能还会注意到，CSV文件包含的信息比通常在屏幕上显示的要多得多。这是故意的。Shell知道它不可能在屏幕上显示所有这些信息，因此它使用由Microsoft提供的配置来选择屏幕显示的最重要信息。在后面的章节中，我们将向您展示如何覆盖该配置以显示您想要的内容。
- en: 'Once the information is saved into a CSV file, you can easily email it to colleagues
    and ask them to view it from within PowerShell. To do this, they’d import the
    file:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦信息被保存到CSV文件中，你可以轻松地通过电子邮件发送给同事，并要求他们在PowerShell中查看它。为此，他们需要导入该文件：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The shell would read in the CSV file and display the process information. It
    wouldn’t be based on live information, but it would be a snapshot from the exact
    point in time that you created the CSV file.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Shell会读取CSV文件并显示进程信息。它不会基于实时信息，但会是从你创建CSV文件的精确时间点的快照。
- en: 6.2.2 Exporting to JSON
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2.2 导出到JSON
- en: Let’s say you want to export the process information and include the thread
    information. The thread information is what is called a *nested property* on the
    `process` object. Let’s take a look (figure 6.4). Note that `Select-Object Threads`
    tells PowerShell to display only the `Threads` property. We will cover `Select-Object`
    in more depth in chapter 8.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想导出进程信息并包含线程信息。线程信息是在`process`对象上称为*嵌套属性*的内容。让我们看一下（图6.4）。请注意，`Select-Object
    Threads`告诉PowerShell只显示`Threads`属性。我们将在第8章更深入地介绍`Select-Object`。
- en: '![](Images/CH06_F04_Plunk.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH06_F04_Plunk.png)'
- en: Figure 6.4 We are showing two different ways to display the `Threads` property.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4 我们展示了两种不同的显示`Threads`属性的方法。
- en: If you try to export processes using `ConvertTo-CSV`, the `Threads` property
    will have the value `System.Diagnostics.ProcessThreadCollection`. So, we need
    another way to export data if we want the nested properties under the `Threads`
    property.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试使用`ConvertTo-CSV`导出进程，`Threads`属性将具有值`System.Diagnostics.ProcessThreadCollection`。因此，如果我们想导出`Threads`属性下的嵌套属性，我们需要另一种导出数据的方法。
- en: 'PowerShell also has a `ConvertTo-Json` cmdlet, which creates a JSON file that
    allows storage of these nested properties. Most languages have libraries to understand
    JSON. You’ll also have a matching `ConvertFrom-Json` cmdlet. Both the `ConvertFrom`
    and `ConvertTo` cmdlets (such as `ConvertFrom-CSV` and `ConvertTo-CSV`) either
    produce or consume a string on the pipeline. This is the command to convert processes
    into JSON, using `Out-File` to save the results to a file:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell还有一个`ConvertTo-Json`命令，它创建一个JSON文件，允许存储这些嵌套属性。大多数语言都有理解JSON的库。你还将有一个匹配的`ConvertFrom-Json`命令。`ConvertFrom`和`ConvertTo`命令（如`ConvertFrom-CSV`和`ConvertTo-CSV`）要么在管道上生成字符串，要么消耗字符串。这是将进程转换为JSON的命令，使用`Out-File`将结果保存到文件中：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You can get the data back by running the following command:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过运行以下命令来获取数据：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If you run this command, you will notice that the data is in a very different
    format than when you run the `Get-Process` command. We will show you how to deal
    with that in the next section. Figure 6.5 shows an excerpt of what the `Threads`
    property looks like in the exported JSON.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行此命令，你会注意到数据格式与运行`Get-Process`命令时的格式非常不同。我们将在下一节中向你展示如何处理这种情况。图6.5展示了导出JSON中`Threads`属性的一个摘录。
- en: '![](Images/CH06_F05_Plunk.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH06_F05_Plunk.png)'
- en: Figure 6.5 Showing what the `Threads` property looks like in JSON format
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.5 展示`Threads`属性在JSON格式下的样子
- en: 6.2.3 Exporting to XML
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2.3 导出为XML
- en: In the previous section, you noticed that the data returned by `ConvertFrom-Json`
    is displayed very differently than if you get it from the original command. This
    is because the objects are not of the same type (we will cover objects in chapter
    8). There is a command to export data and get back the original objects.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，你注意到`ConvertFrom-Json`返回的数据与从原始命令获取的数据显示方式大不相同。这是因为对象类型不同（我们将在第8章中介绍对象）。有一个命令可以导出数据并获取原始对象。
- en: PowerShell has an `Export-Clixml` cmdlet, which creates a generic CLI XML file
    that allows PowerShell to reconstruct the original objects (or something very
    close). `Clixml` is unique to PowerShell, and although any program is technically
    capable of understanding the XML it produces, it is best for when the results
    are being used by PowerShell. You’ll also have a matching `Import-Clixml` cmdlet.
    Both the import and export cmdlets (such as `Import-CSV` and `Export-CSV`) expect
    a filename as a mandatory parameter.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell有一个`Export-Clixml`命令，它创建一个通用的CLI XML文件，允许PowerShell重建原始对象（或非常接近）。`Clixml`是PowerShell特有的，尽管任何程序在技术上都可以理解它产生的XML，但最好是在结果被PowerShell使用时使用。你还将有一个匹配的`Import-Clixml`命令。导入和导出命令（如`Import-CSV`和`Export-CSV`）都期望一个文件名作为必选参数。
- en: When to use Export-Clixml
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 何时使用Export-Clixml
- en: 'If getting the original objects is better, why not use it all the time? There
    are several disadvantages:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果获取原始对象更好，为什么不总是使用它呢？有几个缺点：
- en: The format is often much larger.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 格式通常要大得多。
- en: The format is specific to PowerShell and can be complicated to read in other
    languages.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 格式是PowerShell特有的，可能在其他语言中难以阅读。
- en: On Windows, PowerShell will encrypt security-related portions of the file, which
    means that the file can only be decrypted by the user or machine that created
    the file.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Windows上，PowerShell将加密文件的安全相关部分，这意味着只有创建文件的用户或机器才能解密该文件。
- en: Try it Now Try exporting such things as processes, or commands, to a CLIXML
    file. Make sure you can reimport the file, and try opening the resulting file
    in Visual Studio Code or another text editor on your system to see how each application
    displays the information.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下 尝试将进程、命令等导出到CLIXML文件。确保你可以重新导入文件，并尝试在你的系统上的Visual Studio Code或其他文本编辑器中打开生成的文件，以查看每个应用程序如何显示信息。
- en: Does PowerShell include any other import or export commands? You could find
    out by using the `Get-Command` cmdlet and specifying a `-Verb` parameter with
    either `Import` or `Export`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell是否包含其他导入或导出命令？你可以通过使用`Get-Command`命令并指定带有`Import`或`Export`的`-Verb`参数来找出答案。
- en: Try it Now See if PowerShell comes with any other import or export cmdlets.
    You may want to repeat this check after you load new commands into the shell—something
    you’ll do in the next chapter.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下 看看PowerShell是否包含其他导入或导出命令。你可能想在将新命令加载到shell中之后重复此检查——你将在下一章中这样做。
- en: 6.2.4 Out-File
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2.4 Out-File
- en: 'We have talked about CSV, JSON, and XML files, but what if you simply want
    a flat file to store your data in? Let’s look at the `Out-File` command. It takes
    the data that is in the pipeline and directs it out to a flat file—below a text
    file in our example:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了 CSV、JSON 和 XML 文件，但如果你只是想用一个扁平文件来存储你的数据怎么办？让我们看看 `Out-File` 命令。它将管道中的数据导出到一个扁平文件中——在我们的例子中是在一个文本文件下面：
- en: '[PRE5]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 6.2.5 Comparing files
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 6.2.5 比较文件
- en: Both CSV and CLIXML files can be useful for persisting snapshots of information,
    sharing those snapshots with others, and reviewing those snapshots at a later
    time. In fact, `Compare-Object` has a great way of using them.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: CSV 和 CLIXML 文件都可以用于持久化信息快照，与他人共享这些快照，并在以后的时间审查这些快照。实际上，`Compare-Object` 有一种很好的使用它们的方法。
- en: 'First, run `help Compare-Object` and read the help for this cmdlet. We want
    you to pay attention to three parameters in particular: `-ReferenceObject`, `-DifferenceObject`,
    and `-Property`.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，运行 `help Compare-Object` 并阅读这个 cmdlet 的帮助信息。我们希望你特别注意三个参数：`-ReferenceObject`、`-DifferenceObject`
    和 `-Property`。
- en: '`Compare-Object` is designed to take two sets of information and compare them
    to each other. For example, imagine that you run `Get-Process` on two computers
    that are sitting side by side. The computer that’s configured exactly the way
    you want is on the left and is the *reference computer*. The computer on the right
    might be the same, or it might be somewhat different; this one is the *difference
    computer*. After running the command on each, you’re staring at two tables of
    information, and your job is to figure out whether any differences exist between
    the two.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`Compare-Object` 是设计用来接受两组信息并将它们相互比较的。例如，想象一下你在并排放置的两个计算机上运行 `Get-Process`。配置得正好符合你要求的计算机在左边，是**参考计算机**。右边的计算机可能相同，也可能有些不同；这个是**差异计算机**。在每台计算机上运行命令后，你会看到两张信息表，你的任务是确定这两者之间是否存在任何差异。'
- en: 'Because these are processes that you’re looking at, you’re always going to
    see differences in things like CPU and memory utilization numbers, so we’ll ignore
    those columns. In fact, focus on the Name column, because we want to see whether
    the difference computer contains any additional, or any fewer, processes than
    the reference computer. It might take you a while to compare all of the process
    names from both tables, but you don’t have to—that’s exactly what `Compare-Object`
    will do for you. Let’s say you sit down at the reference computer and run this:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这些是你正在查看的进程，所以你总是会看到 CPU 和内存利用率等数据上的差异，所以我们将忽略这些列。实际上，关注名称列，因为我们想看看差异计算机是否包含比参考计算机更多的或更少的进程。你可能需要花一些时间来比较两张表中的所有进程名称，但你不一定需要——这正是
    `Compare-Object` 会为你做的。假设你坐在参考计算机前并运行以下命令：
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We prefer using CLIXML rather than CSV for comparisons like this, because CLIXML
    can hold more information than a flat CSV file. You then transport that XML file
    to the difference computer and run this command:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们更倾向于使用 CLIXML 而不是 CSV 进行此类比较，因为 CLIXML 可以比扁平的 CSV 文件存储更多信息。然后，您将那个 XML 文件传输到差异计算机上并运行以下命令：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Because the previous step is a bit tricky, we’ll explain what’s happening:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 因为前面的步骤有点棘手，我们将解释正在发生的事情：
- en: As in math, parentheses in PowerShell control the order of execution. In the
    previous example, they force `Import-Clixml` and `Get-Process` to run before `Compare-Object`
    runs. The output from `Import-Clixml` is fed to the `-Reference` parameter, and
    the output from `Get-Process` is fed to the `-Difference` parameter.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 就像数学一样，PowerShell 中的括号控制着执行顺序。在上一个例子中，它们强制 `Import-Clixml` 和 `Get-Process` 在
    `Compare-Object` 运行之前执行。`Import-Clixml` 的输出被馈送到 `-Reference` 参数，而 `Get-Process`
    的输出被馈送到 `-Difference` 参数。
- en: The parameter names are `-ReferenceObject` and `-DifferenceObject`. Keep in
    mind that you can abbreviate parameter names by typing enough of their names for
    the shell to be able to figure out which one you want. In this case, `-Reference`
    and `-Difference` are more than enough to uniquely identify these parameters.
    We probably could have shortened them even further to something like `-ref` and
    `-diff`, and the command would still have worked.
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 参数名称是 `-ReferenceObject` 和 `-DifferenceObject`。请记住，你可以通过输入足够多的参数名称来缩写参数名称，以便
    shell 能够确定你想要哪一个。在这种情况下，`-Reference` 和 `-Difference` 已经足够独特地识别这些参数了。我们可能还可以进一步缩短它们，例如缩短为
    `-ref` 和 `-diff`，而命令仍然可以正常工作。
- en: Rather than comparing the two complete tables, `Compare-Object` focuses on the
    `Name`, because we gave it the `-Property` parameter. If we hadn’t, it would think
    that every process is different because the values of columns such as `VM`, `CPU`,
    and `PM` are always going to be different.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与比较两个完整的表格不同，`Compare-Object`专注于`Name`，因为我们给了它`-Property`参数。如果我们没有这样做，它就会认为每个进程都不同，因为像`VM`、`CPU`和`PM`这样的列的值总是会有所不同。
- en: The result is a table telling you what’s different. Every process that’s in
    the reference set but not in the difference set will have a `<=` indicator (which
    indicates that the process is present only on the left side). If a process is
    on the difference computer but not the reference computer, it’ll have a `=>` indicator
    instead. Processes that match across both sets aren’t included in the `Compare-Object`
    output.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结果是一个表格，告诉你有什么不同。在参考集中但不在差异集中的每个进程都将有一个`<=`指示符（表示该进程仅在左侧存在）。如果一个进程在差异计算机上但不在参考计算机上，它将有一个`=>`指示符。在两个集合中都匹配的进程不包括在`Compare-Object`输出中。
- en: Try it Now Go ahead and try this. If you don’t have two computers, start by
    exporting your current processes to a CLIXML file, as shown in the previous example.
    Then start some additional processes, another `pwsh`, such as Visual Studio Code,
    nano (a command-line editor), the browser, or a game. Your computer will become
    the difference computer (on the right), whereas the CLIXML file will still be
    the reference computer (on the left).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试看。如果你没有两台计算机，可以从导出你的当前进程到一个CLIXML文件开始，就像上一个例子中展示的那样。然后启动一些额外的进程，比如另一个`pwsh`，例如Visual
    Studio Code、nano（一个命令行编辑器）、浏览器或一个游戏。你的计算机将成为差异计算机（在右侧），而CLIXML文件仍然是参考计算机（在左侧）。
- en: 'Here’s the output from our test:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们测试的输出结果：
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This is a useful management trick. If you think of those reference CLIXML files
    as configuration baselines, you can compare any current computer to that baseline
    and get a difference report. Throughout this book, you’ll discover more cmdlets
    that can retrieve management information, all of which can be piped into a CLIXML
    file to become a baseline. You can quickly build a collection of baseline files
    for services, processes, operating system configuration, users and groups, and
    much more, and then use those at any time to compare the current state of a system
    to that baseline.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个有用的管理技巧。如果你把那些参考CLIXML文件视为配置基线，你就可以将任何当前计算机与该基线进行比较，并获取差异报告。在这本书中，你将发现更多可以检索管理信息的cmdlets，所有这些都可以被管道输入到CLIXML文件中，成为基线。你可以快速构建一组基线文件，用于服务、进程、操作系统配置、用户和组等，然后随时使用这些文件将系统的当前状态与基线进行比较。
- en: Try it Now For fun, try running the `Compare-Object` command again, but leave
    off the `-Property` parameter entirely. See the results? Every single process
    is listed, because values such as `PM`, `VM`, and so forth, have all changed,
    even though they’re the same processes. The output also isn’t as useful, because
    it displays each process’s type name and process name.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试看。为了好玩，再次运行`Compare-Object`命令，但完全省略`-Property`参数。看到了吗？每个进程都被列出，因为像`PM`、`VM`等值都发生了变化，尽管它们是相同的进程。输出也不太有用，因为它显示了每个进程的类型名称和进程名称。
- en: By the way, you should know that `Compare-Object` generally doesn’t do well
    at comparing text files. Although other operating systems and shells have a `Compare-Object`
    command that’s explicitly intended for comparing text files, PowerShell’s `Compare-Object`
    command works differently. You’ll see how differently in this chapter’s lab.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，你应该知道`Compare-Object`在比较文本文件方面通常表现不佳。尽管其他操作系统和shell有一个明确用于比较文本文件的`Compare-Object`命令，但PowerShell的`Compare-Object`命令的工作方式不同。你将在本章的实验中看到它有多么不同。
- en: Note If it seems as though you’re using `Get-Process` and `Get-Command` often,
    well, that’s on purpose. We guarantee you have access to those cmdlets because
    they’re native to PowerShell and don’t require an add-in such as Azure PowerShell
    or AWS Tools for PowerShell. That said, the skills you’re learning apply to every
    cmdlet you’ll ever need to run, including those that ship with Azure compute,
    Azure Storage, Azure Virtual Network, and Azure PowerShell module.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：如果你经常使用`Get-Process`和`Get-Command`，那是有意为之的。我们保证你可以访问这些cmdlets，因为它们是PowerShell的本地命令，不需要像Azure
    PowerShell或AWS Tools for PowerShell这样的插件。话虽如此，你正在学习的技能适用于你将需要运行的每个cmdlet，包括那些与Azure计算、Azure存储、Azure虚拟网络和Azure
    PowerShell模块一起提供的cmdlet。
- en: 6.3 Piping to a file
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.3 将输出重定向到文件
- en: 'Whenever you have nicely formatted output—for example, the tables generated
    by `Get-Command` or `Get-Process`—you may want to preserve that in a file or even
    on paper. Normally, cmdlet output is directed to the screen, which PowerShell
    refers to as the *host*, but you can change where that output goes. We’ve already
    shown you one way to do so:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你有格式良好的输出时——例如，由 `Get-Command` 或 `Get-Process` 生成的表格——你可能希望将其保存在文件中，甚至打印在纸上。通常，cmdlet
    输出会被定向到屏幕，PowerShell 将其称为 *host*，但你也可以改变输出去向。我们已经向你展示了其中一种方法：
- en: '[PRE9]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `>` character is a shortcut added to PowerShell to provide syntactic compatibility
    with the Bash shell. In reality, when you run that command, PowerShell does the
    following under the hood:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`>` 字符是 PowerShell 添加的一个快捷方式，以提供与 Bash shell 的语法兼容性。实际上，当你运行那个命令时，PowerShell
    在幕后会做以下操作：'
- en: '[PRE10]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You can run that same command on your own, instead of using the `>` syntax.
    Why would you do so? Because `Out-File` also provides additional parameters that
    let you specify alternative character encodings (such as UTF-8 or Unicode), append
    content to an existing file, and so forth. By default, the files created by `Out-File`
    are 80 columns wide, which means sometimes PowerShell might alter command output
    to fit within 80 characters. That alteration might make the file’s contents appear
    different than when you run the same command on the screen. Read the help file
    for `Out-File` to see if you can spot a parameter that would let you change the
    output file width to something other than 80 characters.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在自己的机器上运行相同的命令，而不是使用 `>` 语法。你为什么这么做呢？因为 `Out-File` 还提供了额外的参数，让你可以指定替代字符编码（如
    UTF-8 或 Unicode），将内容追加到现有文件，等等。默认情况下，`Out-File` 创建的文件宽度为 80 列，这意味着有时 PowerShell
    可能会调整命令输出以适应 80 个字符。这种调整可能会使文件内容看起来与你在屏幕上运行相同命令时不同。阅读 `Out-File` 的帮助文件，看看你是否能找到一个参数，可以让你将输出文件宽度更改为
    80 个字符以外的值。
- en: Try it Now Don’t look here for the answer—open up that help file and see what
    you can find. We guarantee you’ll spot the right parameter in a few moments.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下——不要在这里寻找答案——打开那个帮助文件，看看你能找到什么。我们保证你会在几分钟内找到正确的参数。
- en: PowerShell has a variety of `Out-` cmdlets. One is called `Out-Default`, and
    it’s the one the shell uses when you don’t specify a different `Out-` cmdlet.
    If you run
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell 有许多 `Out-` 命令。其中一个叫做 `Out-Default`，当你不指定不同的 `Out-` 命令时，shell 会使用它。如果你运行
- en: '[PRE11]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: you’re technically running
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 你实际上正在运行
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: even if you don’t realize it. `Out-Default` does nothing more than direct content
    to `Out-Host`, which means you’re running
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你没有意识到。`Out-Default` 除了将内容直接定向到 `Out-Host` 外，没有做更多的事情，这意味着你正在运行
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: without realizing it. `Out-Host` displays information on the screen. What other
    `Out-` cmdlets can you find?
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有意识到的情况下。`Out-Host` 在屏幕上显示信息。你能找到其他哪些 `Out-` 命令？
- en: Try it Now Time to investigate other `Out-` cmdlets. To get started, try using
    the `Help` command and wildcards such as `Help` `Out*`. Another option is to use
    the `Get-Command` in the same way, such as `Get-Command` `Out*`. Or you could
    specify the `-Verb` parameter `Get-Command -Verb Out`. What did you come up with?
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下——现在是调查其他 `Out-` 命令的时候了。为了开始，尝试使用 `Help` 命令和通配符，例如 `Help` `Out*`。另一个选项是使用
    `Get-Command` 的相同方式，例如 `Get-Command` `Out*`。或者，你可以指定 `-Verb` 参数 `Get-Command -Verb
    Out`。你得到了什么？
- en: '`Out-Null` and `Out-String` have specific uses that we won’t get into right
    now, but you’re welcome to read their help files and look at the examples included
    in those files.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`Out-Null` 和 `Out-String` 有其特定的用途，我们现在不会深入探讨，但您随时可以阅读它们的相关帮助文件，并查看那些文件中包含的示例。'
- en: 6.4 Converting to HTML
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.4 转换为 HTML
- en: 'Want to produce HTML reports? Pipe your command to `ConvertTo-Html`. This command
    produces well-formed, generic HTML that displays in any web browser. It’s plain-looking,
    but you can reference a Cascading Style Sheets (CSS) file to specify more-attractive
    formatting if desired. Notice that this command doesn’t require a filename:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 想要生成 HTML 报告？将你的命令通过管道传递给 `ConvertTo-Html`。这个命令生成格式良好的通用 HTML，可以在任何网页浏览器中显示。它看起来很朴素，但如果你需要的话，可以引用一个级联样式表（CSS）文件来指定更吸引人的格式。请注意，这个命令不需要指定文件名：
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Try it Now Make sure that you run that command yourself—we want you to see what
    it does before you proceed.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试一下——确保你自己运行那个命令——我们希望你在继续之前看到它做了什么。
- en: 'In the PowerShell world, the verb `Export` implies that you’re taking data,
    converting it to some other format, and saving that other format in some kind
    of storage, such as a file. The verb `ConvertTo` implies only a portion of that
    process: the conversion to a different format but not saving it into a file. When
    you ran the preceding command, you got a screen full of HTML, which probably wasn’t
    what you wanted. Stop for a second; can you think of how you’d get that HTML into
    a text file on disk?'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PowerShell 世界中，动词 `Export` 暗示你正在获取数据，将其转换为其他格式，并将该格式保存到某种存储中，例如文件。动词 `ConvertTo`
    仅暗示该过程的一部分：将数据转换为不同格式，但不将其保存到文件中。当你运行前面的命令时，你得到了一屏幕的 HTML，这可能不是你想要的。停一下；你能想到如何将那个
    HTML 保存到磁盘上的文本文件中吗？
- en: Try it Now If you can think of a way, go ahead and try it before you read on.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在试试看。如果你能想到一种方法，请在继续阅读之前尝试一下。
- en: 'This command does the trick:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令可以解决问题：
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: See how connecting more and more commands allows you to have increasingly powerful
    command lines? Each command handles a single step in the process, and the entire
    command line as a whole accomplishes a useful task.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 看看连接越来越多的命令如何让你拥有越来越强大的命令行？每个命令处理过程的一个步骤，整个命令行作为一个整体完成一个有用的任务。
- en: PowerShell ships with other `ConvertTo-` cmdlets, including `ConvertTo-CSV`
    and `ConvertTo-Xml`. As with `ConvertTo-Html`, these don’t create a file on disk;
    they translate command output into CSV or XML, respectively. You could pipe that
    converted output to `Out-File` to then save it to disk, although it would be shorter
    to use `Export-CSV` or `Export-Clixml`, because those do both the conversion and
    the saving.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: PowerShell 随带其他 `ConvertTo-` 命令，包括 `ConvertTo-CSV` 和 `ConvertTo-Xml`。与 `ConvertTo-Html`
    类似，这些命令不会在磁盘上创建文件；它们分别将命令输出转换为 CSV 或 XML。你可以将转换后的输出通过管道传递给 `Out-File` 命令，然后将其保存到磁盘上，尽管使用
    `Export-CSV` 或 `Export-Clixml` 会更简洁，因为这两个命令同时完成转换和保存。
- en: Above and beyond
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外
- en: 'Time for a bit more useless background information, although in this case it’s
    the answer to a question that many students often ask us: why would Microsoft
    provide both `Export-CSV` and `ConvertTo-CSV`, as well as two nearly identical
    cmdlets for XML?'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候提供更多无用的背景信息了，尽管在这种情况下，这是许多学生经常向我们提出的问题的答案：为什么微软会同时提供 `Export-CSV` 和 `ConvertTo-CSV`，以及两个几乎相同的
    XML 命令？
- en: In certain advanced scenarios, you might not want to save the data to a file
    on disk. For example, you might want to convert data to XML and then transmit
    it to a web service or some other destination. By having distinct `ConvertTo-`
    cmdlets that don’t save to a file, you have the flexibility to do whatever you
    want.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些高级场景中，你可能不希望将数据保存到磁盘上的文件中。例如，你可能想要将数据转换为 XML，然后将其传输到 Web 服务或其他目的地。通过拥有不保存到文件的独立
    `ConvertTo-` 命令，你就有灵活性去做你想做的事情。
- en: '6.5 Using cmdlets that modify the system: Killing processes'
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.5 使用修改系统的命令：终止进程
- en: 'Exporting and converting aren’t the only reasons you might want to connect
    two commands together. For example, consider—*but* *please don’t run*—this command:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 导出和转换并不是连接两个命令的唯一原因。例如，考虑一下——*但请别运行*——这个命令：
- en: '[PRE16]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Can you imagine what that command would do? We’ll tell you: you could kill
    critical processes. It would retrieve every process and then start trying to end
    each one of them. It would get to a critical process, such as the `/usr/sbin/coreaudiod`
    on macOS, and your computer would no longer be able to play sound. If you’re running
    PowerShell inside a virtual machine and want to have a little fun, go ahead and
    try running that command.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你能想象这个命令会做什么吗？我们将告诉你：你可以终止关键进程。它会检索每个进程，然后尝试终止每个进程。它会到达一个关键进程，例如 macOS 上的 `/usr/sbin/coreaudiod`，然后你的电脑将无法再播放声音。如果你在虚拟机中运行
    PowerShell 并想找点乐子，请尝试运行该命令。
- en: 'The point is that cmdlets with the same noun (in this case, `Process`) can
    often pass information among themselves. Typically, you’d specify the name of
    a specific process rather than trying to stop them all:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 重点是具有相同名词（在这种情况下，`Process`）的 cmdlet 可以经常在彼此之间传递信息。通常，你会指定特定进程的名称，而不是尝试停止所有进程：
- en: '[PRE17]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Jobs offer something similar: the output from `Get-Job` can be piped to cmdlets
    such as `Stop-Job`, `Receive-Job`, `Wait-Job`, and so forth. We will cover jobs
    in detail in chapter 14.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 作业提供类似的功能：`Get-Job` 的输出可以被传递到 `Stop-Job`、`Receive-Job`、`Wait-Job` 等命令。我们将在第
    14 章详细介绍作业。
- en: As you might expect, specific rules limit which commands can connect to each
    other. For example, if you look at a command sequence such as `Get-Process` `|`
    `New-Alias`, you probably wouldn’t expect it to do anything sensible (although
    it might well do something nonsensical). In chapter 7, we’ll dive into the rules
    that govern how commands can connect to each other.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所期望的，特定的规则限制了哪些命令可以相互连接。例如，如果你查看一个如`Get-Process` `|` `New-Alias`的命令序列，你可能不会期望它做任何有意义的事情（尽管它可能确实做了某些无意义的事情）。在第7章中，我们将深入探讨控制命令如何相互连接的规则。
- en: 'We’d like you to know one more thing about cmdlets such as `Stop-Job` and `Stop-Process`.
    These cmdlets modify the system in some fashion, and all cmdlets that modify the
    system have an internally defined *impact level*. The cmdlet’s creator sets this
    impact level, and it can’t be changed. The shell has a corresponding `$Confirm-Preference`
    setting, which is set to `High` by default. Type the following setting name to
    see your shell’s setting:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望你了解关于`Stop-Job`和`Stop-Process`等cmdlet的另一个信息。这些cmdlet以某种方式修改系统，所有修改系统的cmdlet都有一个内部定义的*影响级别*。cmdlet的创建者设置这个影响级别，并且不能更改。shell有一个相应的`$Confirm-Preference`设置，默认设置为`High`。输入以下设置名称以查看你的shell设置：
- en: '[PRE18]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here’s how it works: when a cmdlet’s internal impact level is equal to or higher
    than the shell’s `$ConfirmPreference` setting, the shell will automatically ask,
    “Are you sure?” when the cmdlet does whatever it’s trying to do. If you used a
    virtual machine to try the crash-your-computer command we mentioned earlier, you
    probably were asked, “Are you sure?” for each process. When a cmdlet’s internal
    impact level is less than the shell’s `$ConfirmPreference` setting, you don’t
    automatically get the “Are you sure?” prompt. But you can force the shell to ask
    you whether you’re sure:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是这样工作的：当cmdlet的内部影响级别等于或高于shell的`$ConfirmPreference`设置时，shell会自动询问，“你确定吗？”当cmdlet执行它试图做的事情时。如果你使用虚拟机尝试我们之前提到的会导致电脑崩溃的命令，你可能对每个进程都被问到了“你确定吗？”当cmdlet的内部影响级别低于shell的`$ConfirmPreference`设置时，你不会自动得到“你确定吗？”提示。但你可以强制shell询问你是否确定：
- en: '[PRE19]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You just add the `-Confirm` parameter to the cmdlet. This should be supported
    by any cmdlet that makes some kind of change to the system, and it’ll show up
    in the help file for the cmdlet if it’s supported.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 你只需将`-Confirm`参数添加到cmdlet中。任何对系统进行某种更改的cmdlet都应该支持它，如果它支持，它将在cmdlet的帮助文件中显示。
- en: 'A similar parameter is `-WhatIf`. This is supported by any cmdlet that supports
    `-Confirm`. The `-WhatIf` parameter isn’t triggered by default, but you can specify
    it whenever you want to:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 类似的参数是`-WhatIf`。任何支持`-Confirm`的cmdlet都支持`-WhatIf`参数。默认情况下，`-WhatIf`参数不会被触发，但你可以随时指定它：
- en: '[PRE20]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This tells you what the cmdlet would have done, without letting the cmdlet do
    it. It’s a useful way to preview what a potentially dangerous cmdlet would have
    done to your computer, to make certain that you want to do that.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这会告诉你cmdlet会做什么，而不让cmdlet实际执行。这是一种有用的方式来预览一个可能危险的cmdlet会对你的电脑造成什么影响，以确保你确实想要这样做。
- en: 6.6 Common points of confusion
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.6 常见混淆点
- en: One common point of confusion in PowerShell revolves around the `Export-CSV`
    and `Export-Clixml` commands. Both commands, technically speaking, create text
    files. The output of either command can be viewed in Visual Studio Code, as shown
    in figure 6.3\. But you have to admit that the text is definitely in a special
    kind of format—either in CSV or XML.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在PowerShell中，一个常见的混淆点围绕着`Export-CSV`和`Export-Clixml`命令。从技术上讲，这两个命令都创建文本文件。这两个命令的输出可以在Visual
    Studio Code中查看，如图6.3所示。但你必须承认，文本肯定是一种特殊的格式——要么是CSV，要么是XML。
- en: 'The confusion tends to set in when someone is asked to read these files back
    into the shell. Do you use `Get-Content` (or its alias `type`)? For example, suppose
    you do this:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当有人被要求将这些文件读回到shell时，混淆往往会出现。你是使用`Get-Content`（或其别名`type`）吗？例如，假设你这样做：
- en: '[PRE21]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Notice the `-IncludeTypeInformation` switch; we will come back to it later.
    Now, try reading that back in by using `Get-Content`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到`-IncludeTypeInformation`开关；我们稍后会回到它。现在，尝试使用`Get-Content`读取它：
- en: '[PRE22]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We truncated the preceding output, but there’s a lot more of the same. Looks
    like garbage, right? You’re looking at the raw CSV data. The command didn’t try
    to interpret, or *parse*, the data at all. Contrast that with the results of `Import-CSV`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们截断了前面的输出，但还有很多类似的输出。看起来像是垃圾，对吧？你正在查看原始CSV数据。命令根本就没有尝试解释，或*解析*数据。与`Import-CSV`的结果进行对比：
- en: '[PRE23]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Much nicer, right? The `Import-` cmdlets pay attention to what’s in the file,
    attempt to interpret it, and create a display that looks more like the output
    of the original command (`Get-Process`, in this case). To do this with `Export-CSV`,
    you must use the `-IncludeTypeInformation` switch. Typically, then, if you create
    a file with `Export-CSV`, you read it by using `Import-CSV`. If you create it
    by using `Export-Clixml`, you generally read it by using `Import-Clixml`. By using
    these commands in pairs, you get better results. Use `Get-Content` only when you’re
    reading in a text file and don’t want PowerShell attempting to parse the data—that
    is, when you want to work with the raw text.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 更好一些，对吧？`Import-` cmdlets 会注意文件中的内容，尝试进行解释，并创建一个看起来更像原始命令（在这种情况下是 `Get-Process`）输出的显示。为了使用
    `Export-CSV` 来做到这一点，你必须使用 `-IncludeTypeInformation` 开关。通常，如果你使用 `Export-CSV` 创建文件，你会通过使用
    `Import-CSV` 来读取它。如果你使用 `Export-Clixml` 创建它，你通常通过使用 `Import-Clixml` 来读取它。通过使用这些命令成对使用，你可以获得更好的结果。仅当你在读取文本文件且不希望
    PowerShell 尝试解析数据时（即当你想处理原始文本时），才使用 `Get-Content`。
- en: 6.7 Lab
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.7 实验室
- en: 'We’ve kept this chapter’s text slightly shorter because some of the examples
    probably took you a bit longer to complete and because we want you to spend more
    time completing the following hands-on exercises. If you haven’t already completed
    all of the “Try it now” tasks in this chapter, we strongly recommend that you
    do so before tackling these tasks:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将本章的文本略微缩短，因为一些示例可能花费了你更多的时间来完成，并且我们希望你能花更多的时间来完成以下动手实验。如果你还没有完成本章中所有的“现在试试”任务，我们强烈建议你在尝试这些任务之前完成它们：
- en: 'Create two similar, but different, text files. Try comparing them by using
    `Compare-Object`. Run something like this: `Compare-Object -Reference` `(Get-Content`
    `File1.txt)` `-Difference` `(Get-Content File2.txt)`. If the files have only one
    line of text that’s different, the command should work.'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建两个相似但不同的文本文件。尝试使用 `Compare-Object` 来比较它们。运行类似以下命令：`Compare-Object -Reference
    `(Get-Content` `File1.txt)` `-Difference `(Get-Content File2.txt)`。如果文件只有一行文本不同，该命令应该可以工作。
- en: What happens if you run `Get-Command` `|` `Export-CSV` `commands.CSV` `|` `Out-File`
    from the console? Why does that happen?
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你从控制台运行 `Get-Command` `|` `Export-CSV` `commands.CSV` `|` `Out-File`，会发生什么？为什么会发生这种情况？
- en: Apart from getting one or more jobs and piping them to `Stop-Job`, what other
    means does `Stop-Job` provide for you to specify the job or jobs you want to stop?
    Is it possible to stop a job without using `Get-Job` at all?
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除了获取一个或多个作业并将它们通过管道传递给 `Stop-Job` 以外，`Stop-Job` 还提供了哪些方法让你指定要停止的作业或作业？是否可以在不使用
    `Get-Job` 的情况下停止作业？
- en: What if you want to create a pipe-delimited file instead of a CSV file? You’d
    still use the `Export-CSV` command, but what parameters would you specify?
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你想要创建一个以管道分隔符分隔的文件而不是 CSV 文件，你仍然会使用 `Export-CSV` 命令，但你需要指定哪些参数？
- en: How do you include the type information in the `#` comment line at the top of
    an exported CSV file?
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何在导出的 CSV 文件的顶部注释行 `#` 中包含类型信息？
- en: '`Export-Clixml` and `Export-CSV` both modify the system because they can create
    and overwrite files. What parameter would prevent them from overwriting an existing
    file? What parameter would ask whether you were sure before proceeding to write
    the output file?'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Export-Clixml` 和 `Export-CSV` 都会修改系统，因为它们可以创建和覆盖文件。哪个参数可以防止它们覆盖现有文件？哪个参数会在写入输出文件之前询问你是否确定？'
- en: The operating system maintains several regional settings, which include a default
    list separator. On US systems, that separator is a comma. How can you tell `Export-CSV`
    to use the system’s default separator rather than a comma?
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 操作系统维护了几个区域设置，其中包括默认的分隔符列表。在美国系统上，该分隔符是逗号。你如何告诉 `Export-CSV` 使用系统的默认分隔符而不是逗号？
- en: 6.8 Lab answers
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 6.8 实验室答案
- en: '`PS C:\Scripts > "I am the walrus" | Out-File file1.txt`'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`PS C:\Scripts > "I am the walrus" | Out-File file1.txt`'
- en: '`PS C:\Scripts > "I''m a believer" | Out-File file2.txt`'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`PS C:\Scripts > "I''m a believer" | Out-File file2.txt`'
- en: '`PS C:\Scripts > $f1 = Get-Content .\file1.txt`'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`PS C:\Scripts > $f1 = Get-Content .\file1.txt`'
- en: '`PS C:\Scripts > $f2 = Get-Content .\file2.txt`'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`PS C:\Scripts > $f2 = Get-Content .\file2.txt`'
- en: '`PS C:\Scripts > Compare-Object $f1 $f2`'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`PS C:\Scripts > Compare-Object $f1 $f2`'
- en: '`InputObject                             SideIndicator`'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`InputObject                             SideIndicator`'
- en: '`-----------                             -------------`'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`-----------                             -------------`'
- en: '`I''m a believer                          =>`'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`I''m a believer                          =>`'
- en: '`I am the walrus                         <=`'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`I am the walrus                         <=`'
- en: If you don’t specify a filename with `Out-File`, you’ll get an error. But even
    if you do, `Out-File` won’t do anything because the file is created by `Export-CSV`.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您没有使用 `Out-File` 指定文件名，您将收到错误。但即使指定了，`Out-File` 也不会执行任何操作，因为文件是由 `Export-CSV`
    创建的。
- en: '`Stop-Job` can accept one or more job names as parameter values for the `–Name`
    parameter. For example, you could run this:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Stop-Job` 可以接受一个或多个作业名称作为 `–Name` 参数的参数值。例如，您可以运行以下命令：'
- en: '`Stop-job jobName`'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Stop-job jobName`'
- en: '`get-Command | Export-CSV commands.CSV -Delimiter "|"`'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`get-Command | Export-CSV commands.CSV -Delimiter "|"`'
- en: Use the `–IncludeTypeInformation` parameter with `Export-CSV`.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Export-CSV` 中使用 `–IncludeTypeInformation` 参数。
- en: '`Get-Command | Export-CSV services.CSV –NoClobber`'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Get-Command | Export-CSV services.CSV –NoClobber`'
- en: '`Get-Command | Export-CSV services.CSV -Confirm`'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Get-Command | Export-CSV services.CSV -Confirm`'
- en: '`Get-Command | Export-CSV services.CSV -UseCulture`'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Get-Command | Export-CSV services.CSV -UseCulture`'
