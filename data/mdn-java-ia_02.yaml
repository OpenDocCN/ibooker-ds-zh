- en: Part 3\. Effective programming with streams and lambdas
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第3部分. 使用流和lambda进行有效编程
- en: The third part of this book explores various Java 8 and Java 9 topics that will
    make you more effective at using Java and enhance your codebase with modern idioms.
    Because it’s oriented toward more advanced programming ideas, nothing later in
    the book depends on the techniques described here.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本书第三部分探讨了各种Java 8和Java 9主题，这些主题将使你更有效地使用Java，并使用现代惯用模式增强你的代码库。因为它面向更高级的编程思想，所以本书后面的内容不依赖于这里描述的技术。
- en: '[Chapter 8](kindle_split_020.xhtml#ch08) is a new chapter for the second edition
    and explores the Collection API enhancements of Java 8 and Java 9 and covers using
    collection factories and learning new idiomatic patterns to work with List and
    Set collections along with idiomatic patterns involving Map.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '[第8章](kindle_split_020.xhtml#ch08)是第二版的新章节，探讨了Java 8和Java 9的集合API增强，涵盖了使用集合工厂以及学习与List和Set集合一起使用的新惯用模式，以及涉及Map的惯用模式。'
- en: '[Chapter 9](kindle_split_021.xhtml#ch09) explores how you can improve your
    existing code using new Java 8 features and a few recipes. In addition, it explores
    vital software development techniques such as design patterns, refactoring, testing,
    and debugging.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[第9章](kindle_split_021.xhtml#ch09)探讨了如何使用新的Java 8特性和一些食谱来改进现有的代码。此外，它还探讨了重要的软件开发技术，如设计模式、重构、测试和调试。'
- en: '[Chapter 10](kindle_split_022.xhtml#ch10) is again new for the second edition.
    It explores the idea of basing an API on a domain-specific language (DSL). This
    is not only a powerful way of designing APIs but also one that is both becoming
    increasingly popular and already visible in Java, such as in the `Comparator`,
    `Stream`, and `Collector` interfaces.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '[第10章](kindle_split_022.xhtml#ch10)在第二版中也是新的。它探讨了基于领域特定语言（DSL）的API的想法。这不仅是一种强大的API设计方式，而且这种方式越来越受欢迎，并且在Java中已经很明显，例如在`Comparator`、`Stream`和`Collector`接口中。'
- en: Chapter 8\. Collection API enhancements
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第8章. 集合API增强
- en: '*This chapter covers*'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Using collection factories
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用集合工厂
- en: Learning new idiomatic patterns to use with `List` and `Set`
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习使用`List`和`Set`的新惯用模式
- en: Learning idiomatic patterns to work with `Map`
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习与`Map`一起工作的惯用模式
- en: Your life as a Java developer would be rather lonely without the Collection
    API. Collections are used in every Java applications. In previous chapters, you
    saw how useful the combination of Collections with the Streams API is for expressing
    data processing queries. Nonetheless, the Collection API had various deficiencies,
    which made it verbose and error-prone to use at times.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 没有集合API，你的Java开发者生活将会相当孤独。集合被用于每个Java应用程序中。在前面的章节中，你看到了集合与Streams API结合使用是多么有用，这对于表达数据处理查询非常有用。尽管如此，集合API存在各种缺陷，有时使其使用起来既冗长又容易出错。
- en: In this chapter, you will learn about new additions to the Collection API in
    Java 8 and Java 9 that will make your life easier. First, you learn about the
    collections factories in Java 9—new additions that simplify the process of creating
    small lists, sets, and maps. Next, you learn how to apply idiomatic removal and
    replacement patterns in lists and sets thanks to Java 8 enhancements. Finally,
    you learn about new convenience operations that are available to work with maps.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将了解Java 8和Java 9中集合API的新增功能，这将使你的生活变得更轻松。首先，你将了解Java 9中的集合工厂——简化创建小列表、集合和映射过程的添加。接下来，你将学习如何利用Java
    8的增强功能在列表和集合中应用惯用移除和替换模式。最后，你将了解可用于处理映射的新便利操作。
- en: '[Chapter 9](kindle_split_021.xhtml#ch09) explores a wider range of techniques
    for refactoring old-style Java code.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[第9章](kindle_split_021.xhtml#ch09)探讨了重构旧式Java代码的更广泛的技术。'
- en: 8.1\. Collection factories
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1. 集合工厂
- en: Java 9 introduced a few convenient ways to create small collection objects.
    First, we’ll review why programmers needed a better way to do things; then we’ll
    show you how to use the new factory methods.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Java 9引入了一些方便的方式来创建小的集合对象。首先，我们将回顾为什么程序员需要一个更好的方式来做事情；然后我们将向您展示如何使用新的工厂方法。
- en: 'How would you create a small list of elements in Java? You might want to group
    the names of your friends who are going on a holiday, for example. Here’s one
    way:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何在Java中创建一个小的元素列表？你可能想将要去度假的朋友的名字分组，例如。这里有一种方法：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'But that’s quite a few lines to write for storing three strings! A more convenient
    way to write this code is to use the `Arrays.asList()` factory method:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 但要存储三个字符串，却要写这么多行代码！一个更方便的方式来编写这段代码是使用`Arrays.asList()`工厂方法：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You get a fixed-sized list that you can update, but not add elements to or
    remove elements from. Attempting to add elements, for example, results in an `Unsupported-ModificationException`,
    but updating by using the method `set` is allowed:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你得到一个固定大小的列表，你可以更新它，但不能添加或删除元素。尝试添加元素，例如，会导致 `Unsupported-ModificationException`，但使用
    `set` 方法更新是允许的：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '***1* throws an UnsupportedOperationException**'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 抛出 `UnsupportedOperationException` 异常**'
- en: This behavior seems slightly surprising because the underlying list is backed
    by a mutable array of fixed size.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为似乎有些令人惊讶，因为底层列表是由一个固定大小的可变数组支持的。
- en: 'How about a `Set`? Unfortunately, there’s no `Arrays.asSet()` factory method,
    so you need another trick. You can use the `HashSet` constructor, which accepts
    a `List`:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如何看待一个 `Set`？不幸的是，没有 `Arrays.asSet()` 工厂方法，所以你需要另一个技巧。你可以使用 `HashSet` 构造函数，它接受一个
    `List`：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Alternatively you could use the Streams API:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你也可以使用 Streams API：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Both solutions, however, are far from elegant and involve unnecessary object
    allocations behind the scenes. Also note that you get a mutable `Set` as a result.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这两种解决方案都远非优雅，并且在幕后涉及不必要的对象分配。此外，请注意，你得到的是一个可变的 `Set`。
- en: How about `Map`? There’s no elegant way of creating small maps, but don’t worry;
    Java 9 added factory methods to make your life simpler when you need to create
    small lists, sets, and maps.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如何看待 `Map`？创建小地图没有优雅的方法，但别担心；Java 9 添加了工厂方法，使你在需要创建小列表、集合和地图时生活变得更简单。
- en: '|  |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Collection literals**'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**集合字面量**'
- en: Some languages, including Python and Groovy, support collection literals, which
    let you create collections by using special syntax, such as [42, 1, 5] to create
    a list of three numbers. Java doesn’t provide syntactic support because language
    changes come with a high maintenance cost and restrict future use of a possible
    syntax. Instead, Java 9 adds support by enhancing the Collection API.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 一些语言，包括 Python 和 Groovy，支持集合字面量，允许你使用特殊语法创建集合，例如使用 [42, 1, 5] 创建一个包含三个数字的列表。Java
    没有提供语法支持，因为语言的变化伴随着高昂的维护成本，并限制了未来可能语法的使用。相反，Java 9 通过增强 Collection API 来添加支持。
- en: '|  |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: We begin the tour of new ways of creating collections in Java by showing you
    what’s new with `List`s.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过向你展示 `List` 的新特性来开始对 Java 中创建集合的新方法的探索。
- en: 8.1.1\. List factory
  id: totrans-34
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.1.1\. 列表工厂
- en: 'You can create a list simply by calling the factory method `List.of`:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过调用工厂方法 `List.of` 来创建一个列表：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '***1* [Raphael, Olivia, Thibaut]**'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* [Raphael, Olivia, Thibaut]**'
- en: 'You’ll notice something strange, however. Try to add an element to your list
    of friends:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你会注意到一些奇怪的事情。尝试向你的朋友列表中添加一个元素：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Running this code results in a `java.lang.UnsupportedOperationException`. In
    fact, the list that’s produced is immutable. Replacing an item with the `set()`
    method throws a similar exception. You won’t be able to modify it by using the
    `set` method either. This restriction is a good thing, however, as it protects
    you from unwanted mutations of the collections. Nothing is stopping you from having
    elements that are mutable themselves. If you need a mutable list, you can still
    instantiate one manually. Finally, note that to prevent unexpected bugs and enable
    a more-compact internal representation, null elements are disallowed.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码会导致 `java.lang.UnsupportedOperationException`。事实上，生成的列表是不可变的。使用 `set()`
    方法替换项会抛出类似的异常。你也不能使用 `set` 方法来修改它。然而，这种限制是好事，因为它保护你免受集合的不希望变化的侵害。没有任何东西阻止你拥有本身可变的元素。如果你需要一个可变列表，你仍然可以手动实例化一个。最后，请注意，为了防止意外的错误并允许更紧凑的内部表示，不允许使用
    null 元素。
- en: '|  |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Overloading vs. varargs**'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**重载与可变参数**'
- en: 'If you further inspect the `List` interface, you notice several overloaded
    variants of `List.of`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你进一步检查 `List` 接口，你会注意到 `List.of` 有几个重载变体：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You may wonder why the Java API didn’t have one method that uses varargs to
    accept an arbitrary number of elements in the following style:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道为什么 Java API 没有一个使用可变参数接受任意数量元素的方法，如下所示：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Under the hood, the varargs version allocates an extra array, which is wrapped
    up inside a list. You pay the cost for allocating an array, initializing it, and
    having it garbage-collected later. By providing a fixed number of elements (up
    to ten) through an API, you don’t pay this cost. Note that you can still create
    `List.of` using more than ten elements, but in that case the varargs signature
    is invoked. You also see this pattern appearing with `Set.of` and `Map.of`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在底层，可变参数版本分配了一个额外的数组，该数组被包装在一个列表中。你为分配数组、初始化它以及稍后进行垃圾回收付出了代价。通过API提供固定数量的元素（最多十个），你不必承担这个代价。请注意，你仍然可以使用超过十个元素创建`List.of`，但在此情况下将调用可变参数签名。你还在`Set.of`和`Map.of`中看到了这种模式。
- en: '|  |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: You may wonder whether you should use the Streams API instead of the new collection
    factory methods to create such lists. After all, you saw in previous chapters
    that you can use the `Collectors.toList()` collector to transform a stream into
    a list. Unless you need to set up some form of data processing and transformation
    of the data, we recommend that you use the factory methods; they’re simpler to
    use, and the implementation of the factory methods is simpler and more adequate.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道是否应该使用Streams API而不是新的集合工厂方法来创建这样的列表。毕竟，你之前章节中看到可以使用`Collectors.toList()`收集器将流转换为列表。除非你需要设置某种形式的数据处理和转换，我们建议使用工厂方法；它们更易于使用，并且工厂方法的实现更简单、更合适。
- en: Now that you’ve learned about a new factory method for `List`, in the next section,
    you will work with `Set`s.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了`List`的新工厂方法，在下一节中，你将学习如何使用`Set`。
- en: 8.1.2\. Set factory
  id: totrans-51
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.1.2\. 集合工厂
- en: 'As with `List.of`, you can create an immutable `Set` out of a list of elements:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 与`List.of`类似，你可以从元素列表中创建一个不可变的`Set`：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '***1* [Raphael, Olivia, Thibaut]**'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* [拉斐尔，奥利维亚，蒂博]**'
- en: 'If you try to create a `Set` by providing a duplicated element, you receive
    an `Illegal-ArgumentException`. This exception reflects the contract that sets
    enforce uniqueness of the elements they contain:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试通过提供重复的元素来创建`Set`，你会收到一个`Illegal-ArgumentException`。这个异常反映了集合强制其包含的元素唯一性的契约：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '***1* java.lang.IllegalArgumentException: duplicate element: Olivia**'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* java.lang.IllegalArgumentException: duplicate element: 奥利维亚**'
- en: Another popular data structure in Java is `Map`. In the next section, you learn
    about new ways of creating `Map`s.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Java中另一个流行的数据结构是`Map`。在下一节中，你将了解创建`Map`的新方法。
- en: 8.1.3\. Map factories
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.1.3\. 映射工厂
- en: 'Creating a map is a bit more complicated than creating lists and sets because
    you have to include both the key and the value. You have two ways to initialize
    an immutable map in Java 9\. You can use the factory method `Map.of`, which alternates
    between keys and values:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 创建映射比创建列表和集合要复杂一些，因为你必须包含键和值。在Java 9中，你有两种初始化不可变映射的方法。你可以使用工厂方法`Map.of`，它交替使用键和值：
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '***1* {Olivia=25, Raphael=30, Thibaut=26}**'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* {奥利维亚=25, 拉斐尔=30, 蒂博=26}**'
- en: 'This method is convenient if you want to create a small map of up to ten keys
    and values. To go beyond this, use the alternative factory method called `Map.ofEntries`,
    which takes `Map.Entry<K, V>` objects but is implemented with varargs. This method
    requires additional object allocations to wrap up a key and a value:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想创建一个包含最多十个键和值的较小映射，这个方法很方便。要超出这个范围，请使用名为`Map.ofEntries`的替代工厂方法，它接受`Map.Entry<K,
    V>`对象，但使用可变参数实现。此方法需要额外的对象分配来包装键和值：
- en: '[PRE12]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '***1* {Olivia=25, Raphael=30, Thibaut=26}**'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* {奥利维亚=25, 拉斐尔=30, 蒂博=26}**'
- en: '`Map.entry` is a new factory method to create `Map.Entry` objects.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`Map.entry`是一个新的工厂方法，用于创建`Map.Entry`对象。'
- en: '|  |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quiz 8.1**'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 8.1**'
- en: What do you think is the output of the following snippet?
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 你认为以下代码片段的输出是什么？
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '**Answer:**'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案：**'
- en: An `UnsupportedOperationException` is thrown. The collection produced by `List.of`
    is immutable.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 抛出`UnsupportedOperationException`。由`List.of`产生的集合是不可变的。
- en: '|  |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: So far, you’ve seen that the new Java 9 factory methods allow you to create
    collections more simply. But in practice, you have to process the collections.
    In the next section, you learn about a few new enhancements to `List` and `Set`
    that implement common processing patterns out of the box.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经看到新的Java 9工厂方法允许你更简单地创建集合。但在实践中，你必须处理这些集合。在下一节中，你将学习关于`List`和`Set`的一些新增强功能，它们实现了开箱即用的常见处理模式。
- en: 8.2\. Working with List and Set
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2\. 使用列表和集合
- en: 'Java 8 introduced a couple of methods into the `List` and `Set` interfaces:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Java 8将一些方法引入了`List`和`Set`接口：
- en: '`removeIf` removes element matching a predicate. It’s available on all classes
    that implement `List` or `Set` (and is inherited from the Collection interface).'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`removeIf` 移除与谓词匹配的元素。它适用于所有实现 `List` 或 `Set` 的类（并且从 `Collection` 接口继承而来）。'
- en: '`replaceAll` is available on `List` and replaces elements using a (`UnaryOperator`)
    function.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`replaceAll` 在 `List` 上可用，并使用一个 (`UnaryOperator`) 函数替换元素。'
- en: '`sort` is also available on the `List` interface and sorts the list itself.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sort` 也在 `List` 接口上可用，并排序列表本身。'
- en: All these methods mutate the collections on which they’re invoked. In other
    words, they change the collection itself, unlike stream operations, which produce
    a new (copied) result. Why would such methods be added? Modifying collections
    can be error-prone and verbose. So Java 8 added `removeIf` and `replaceAll` to
    help.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些方法都会对其调用的集合进行修改。换句话说，它们会改变集合本身，这与流操作不同，流操作会产生一个新的（复制的）结果。为什么会有这样的方法？修改集合可能会出错且冗长。因此，Java
    8 添加了 `removeIf` 和 `replaceAll` 来帮助。
- en: 8.2.1\. removeIf
  id: totrans-81
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.2.1\. removeIf
- en: 'Consider the following code, which tries to remove transactions that have a
    reference code starting with a digit:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码，它试图移除以数字开头的参考代码的交易：
- en: '[PRE14]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Can you see the problem? Unfortunately, this code may result in a `Concurrent-ModificationException`.
    Why? Under the hood, the `for-each` loop uses an `Iterator` object, so the code
    executed is as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你能看出问题吗？不幸的是，这段代码可能会导致 `Concurrent-ModificationException`。为什么？在底层，`for-each`
    循环使用了一个 `Iterator` 对象，所以执行的代码如下：
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '***1* Problem we are iterating and modifying the collection through two separate
    objects**'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 问题是我们通过两个不同的对象迭代和修改集合**'
- en: 'Notice that two separate objects manage the collection:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，有两个单独的对象管理着这个集合：
- en: The `Iterator` object, which is querying the source by using `next()` and `hasNext()`
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用 `next()` 和 `hasNext()` 查询源的 `Iterator` 对象。
- en: The `Collection` object itself, which is removing the element by calling `remove()`
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过调用 `remove()` 方法移除元素的 `Collection` 对象本身。
- en: 'As a result, the state of the iterator is no longer synced with the state of
    the collection, and vice versa. To solve this problem, you have to use the `Iterator`
    object explicitly and call its `remove()` method:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，迭代器的状态不再与集合的状态同步，反之亦然。为了解决这个问题，你必须显式使用 `Iterator` 对象并调用它的 `remove()` 方法：
- en: '[PRE16]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This code has become fairly verbose to write. This code pattern is now directly
    expressible with the Java 8 `removeIf` method, which is not only simpler but also
    protects you from these bugs. It takes a predicate indicating which elements to
    remove:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码编写起来变得相当冗长。现在，这个代码模式可以直接使用 Java 8 的 `removeIf` 方法来直接表达，这不仅更简单，还能保护你免受这些错误的影响。它需要一个表示要移除哪些元素的谓词：
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Sometimes, though, instead of removing an element, you want to replace it. For
    this purpose, Java 8 added `replaceAll`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你不想移除一个元素，而是想替换它。为此，Java 8 添加了 `replaceAll`。
- en: 8.2.2\. replaceAll
  id: totrans-95
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.2.2\. replaceAll
- en: 'The `replaceAll` method on the `List` interface lets you replace each element
    in a list with a new one. Using the Streams API, you could solve this problem
    as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`List` 接口上的 `replaceAll` 方法允许你将列表中的每个元素替换为一个新的元素。使用 Streams API，你可以这样解决这个问题：'
- en: '[PRE18]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '***1* [a12, C14, b13]**'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* [a12, C14, b13]**'
- en: '***2* outputs A12, C14, B13**'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 输出 A12, C14, B13**'
- en: 'This code results in a new collection of strings, however. You want a way to
    update the existing collection. You can use a `ListIterator` object as follows
    (supporting a `set()` method to replace an element):'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码会生成一个新的字符串集合，然而，你想要一种方法来更新现有的集合。你可以使用一个 `ListIterator` 对象，如下所示（支持 `set()`
    方法来替换元素）：
- en: '[PRE19]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As you can see, this code is fairly verbose. In addition, as we explained earlier,
    using `Iterator` objects in conjunction with collection objects can be error-prone
    by mixing iteration and modification of the collection. In Java 8, you can simply
    write
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这段代码相当冗长。此外，正如我们之前解释的，使用 `Iterator` 对象与集合对象结合可能会因为混合迭代和修改集合而出现错误。在 Java
    8 中，你可以简单地写
- en: '[PRE20]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You’ve learned what’s new with `List` and `Set`, but don’t forget about `Map`.
    New additions to the `Map` interface are covered in the next section.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经学到了 `List` 和 `Set` 的新特性，但不要忘记 `Map`。`Map` 接口的新增内容将在下一节中介绍。
- en: 8.3\. Working with Map
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3\. 使用 Map
- en: Java 8 introduced several default methods supported by the `Map` interface.
    (Default methods are covered in detail in [chapter 13](kindle_split_026.xhtml#ch13),
    but here you can think of them as being preimplemented methods in an interface.)
    The purpose of these new operations is to help you write more concise code by
    using a readily available idiomatic pattern instead of implementing it yourself.
    We look at these operations in the following sections, starting with the shiny
    new `forEach`.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Java 8 引入了几种由 `Map` 接口支持的默认方法。（默认方法在[第13章](kindle_split_026.xhtml#ch13)中有详细说明，但在这里你可以把它们看作是接口中预实现的方法。）这些新操作的目的在于通过使用现成的惯用模式来帮助你编写更简洁的代码，而不是自己实现它。我们将在以下章节中查看这些操作，从全新的
    `forEach` 开始。
- en: 8.3.1\. forEach
  id: totrans-107
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.3.1\. forEach
- en: 'Iterating over the keys and values of a `Map` has traditionally been awkward.
    In fact, you needed to use an iterator of a `Map.Entry<K, V>` over the entry set
    of a `Map`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的迭代 `Map` 的键和值是尴尬的。实际上，你需要使用 `Map` 的 `entrySet` 中的 `Map.Entry<K, V>` 迭代器：
- en: '[PRE21]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Since Java 8, the `Map` interface has supported the `forEach` method, which
    accepts a `BiConsumer`, taking the key and value as arguments. Using `forEach`
    makes your code more concise:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 自从 Java 8 以来，`Map` 接口支持了 `forEach` 方法，该方法接受一个 `BiConsumer`，它接受键和值作为参数。使用 `forEach`
    可以使你的代码更简洁：
- en: '[PRE22]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: A concern related to iterating over date is sorting it. Java 8 introduced a
    couple of convenient ways to compare entries in a `Map`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 与迭代日期相关的一个问题是排序。Java 8 引入了几种方便的方式来比较 `Map` 中的条目。
- en: 8.3.2\. Sorting
  id: totrans-113
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.3.2\. 排序
- en: 'Two new utilities let you sort the entries of a map by values or keys:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 两个新的实用工具让你可以按值或键对映射的条目进行排序：
- en: '`Entry.comparingByValue`'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Entry.comparingByValue`'
- en: '`Entry.comparingByKey`'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Entry.comparingByKey`'
- en: The code
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 代码
- en: '[PRE23]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '***1* Processes the elements of the stream in alphabetic order based on the
    person’s name**'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 根据人员的姓名按字母顺序处理流中的元素**'
- en: 'outputs, in order:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 输出顺序如下：
- en: '[PRE24]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '|  |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**HashMap and Performance**'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '**HashMap 和性能**'
- en: The internal structure of a `HashMap` was updated in Java 8 to improve performance.
    Entries of a map typically are stored in buckets accessed by the generated hashcode
    of the key. But if many keys return the same hashcode, performance deteriorates
    because buckets are implemented as `LinkedList`s with `O(n)` retrieval. Nowadays,
    when the buckets become too big, they’re replaced dynamically with sorted trees,
    which have `O(log(n))` retrieval and improve the lookup of colliding elements.
    Note that this use of sorted trees is possible only when the keys are `Comparable`
    (such as `String` or `Number` classes).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Java 8 对 `HashMap` 的内部结构进行了更新，以提高性能。映射的条目通常存储在通过键生成的哈希码访问的桶中。但如果许多键返回相同的哈希码，性能会下降，因为桶被实现为
    `LinkedList`，其检索复杂度为 `O(n)`。如今，当桶变得太大时，它们会动态地被排序树替换，这些树具有 `O(log(n))` 的检索复杂度，并提高了冲突元素的查找。请注意，这种使用排序树的方法仅在键是
    `Comparable`（如 `String` 或 `Number` 类）时才可行。
- en: '|  |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Another common pattern is how to act when the key you’re looking up in the `Map`
    isn’t present. The new `getOrDefault` method can help.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的模式是当你在 `Map` 中查找的键不存在时该如何处理。新的 `getOrDefault` 方法可以帮助。
- en: 8.3.3\. getOrDefault
  id: totrans-127
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.3.3\. getOrDefault
- en: 'When the key you’re looking up isn’t present, you receive a null reference
    that you have to check against to prevent a `NullPointerException`. A common design
    style is to provide a default value instead. Now you can encode this idea more
    simply by using the `getOrDefault` method. This method takes the key as the first
    argument and a default value (to be used when the key is absent from the `Map`)
    as the second argument:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当你查找的键不存在时，你会收到一个 null 引用，你必须检查它以防止 `NullPointerException`。一种常见的设计风格是提供默认值。现在你可以通过使用
    `getOrDefault` 方法更简单地编码这个想法。此方法将键作为第一个参数，将默认值（在键不存在于 `Map` 中时使用）作为第二个参数：
- en: '[PRE25]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '***1* Outputs James Bond**'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 输出詹姆斯·邦德**'
- en: '***2* Outputs Matrix**'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 输出矩阵**'
- en: Note that if the key existed in the `Map` but was accidentally associated with
    a null value, `getOrDefault` can still return null. Also note that the expression
    you pass as a fallback is always evaluated, whether the key exists or not.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果键存在于 `Map` 中，但意外地关联了 null 值，`getOrDefault` 仍然可以返回 null。另外，请注意，你传递的回退表达式始终会被评估，无论键是否存在。
- en: Java 8 also included a few more advanced patterns to deal with the presence
    and absence of values for a given key. You will learn about these new methods
    in the next section.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Java 8 还包含了一些处理给定键值存在和不存在的高级模式。你将在下一节中了解这些新方法。
- en: 8.3.4\. Compute patterns
  id: totrans-134
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.3.4\. 计算模式
- en: 'Sometimes, you want to perform an operation conditionally and store its result,
    depending on whether a key is present or absent in a `Map`. You may want to cache
    the result of an expensive operation given a key, for example. If the key is present,
    there’s no need to recalculate the result. Three new operations can help:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能需要根据一个`Map`中是否存在某个键来有条件地执行一个操作并存储其结果，例如，根据键来缓存一个昂贵操作的输出。如果键存在，就没有必要重新计算结果。以下三种新操作可以帮助你：
- en: '`computeIfAbsent`—If there’s no specified value for the given key (it’s absent
    or its value is null), calculate a new value by using the key and add it to the
    `Map`.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`computeIfAbsent`——如果给定的键没有指定值（它不存在或其值为null），则使用键计算一个新的值并将其添加到`Map`中。'
- en: '`computeIfPresent`—If the specified key is present, calculate a new value for
    it and add it to the `Map`.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`computeIfPresent`——如果指定的键存在，计算一个新的值并添加到`Map`中。'
- en: '`compute`—This operation calculates a new value for a given key and stores
    it in the `Map`.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`compute`——这个操作为给定的键计算一个新的值并将其存储在`Map`中。'
- en: One use of `computeIfAbsent` is for caching information. Suppose that you parse
    each line of a set of files and calculate their SHA-256 representation. If you’ve
    processed the data previously, there’s no need to recalculate it.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`computeIfAbsent`的一个用途是缓存信息。假设你解析一组文件中的每一行并计算它们的SHA-256表示。如果你之前已经处理过这些数据，就没有必要重新计算。'
- en: 'Now suppose that you implement a cache by using a `Map`, and you use an instance
    of `MessageDigest` to calculate SHA-256 hashes:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设你通过使用`Map`来实现缓存，并使用`MessageDigest`实例来计算SHA-256散列：
- en: '[PRE26]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Then you can iterate through the data and cache the results:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以遍历数据并缓存结果：
- en: '[PRE27]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '***1* line is the key to look up in the map.**'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**1** 行是映射中要查找的键。'
- en: '***2* The operation to execute if the key is absent**'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**2** 如果键不存在时执行的操作'
- en: '***3* The helper that will calculate a hash for the given key**'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**3** 将为给定键计算散列的帮助程序'
- en: 'This pattern is also useful for conveniently dealing with maps that store multiple
    values. If you need to add an element to a `Map<K, List<V>>`, you need to ensure
    that the entry has been initialized. This pattern is a verbose one to put in place.
    Suppose that you want to build up a list of movies for your friend Raphael:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式对于方便地处理存储多个值的映射也非常有用。如果你需要向`Map<K, List<V>>`添加一个元素，你需要确保条目已经被初始化。这种模式是一种冗长的实现方式。假设你想要为你的朋友Raphael构建一个电影列表：
- en: '[PRE28]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '***1* Check that the list was initialized.**'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**1** 检查列表是否已初始化。'
- en: '***2* Add the movie.**'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**2** 添加电影。'
- en: '***3* {Raphael: [Star Wars]}**'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**3** `{Raphael: [Star Wars]}`'
- en: 'How can you use `computeIfAbsent` instead? It returns the calculated value
    after adding it to the `Map` if the key wasn’t found; otherwise, it returns the
    existing value. You can use it as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何使用`computeIfAbsent`呢？如果键未找到，它会在将计算值添加到`Map`后返回计算值；否则，它返回现有值。你可以如下使用它：
- en: '[PRE29]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '***1* {Raphael: [Star Wars]}**'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**1** `{Raphael: [Star Wars]}`'
- en: 'The `computeIfPresent` method calculates a new value if the current value associated
    with the key is present in the `Map` and non-null. Note a subtlety: if the function
    that produces the value returns null, the current mapping is removed from the
    `Map`. If you need to remove a mapping, however, an overloaded version of the
    `remove` method is better suited to the task. You learn about this method in the
    next section.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`computeIfPresent`方法在`Map`中与键关联的当前值存在且非空时计算一个新的值。注意一个细微之处：如果产生值的函数返回null，则当前映射将从`Map`中移除。然而，如果你需要移除映射，则重载的`remove`方法更适合这项任务。你将在下一节中了解这个方法。'
- en: 8.3.5\. Remove patterns
  id: totrans-156
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.3.5\. 移除模式
- en: 'You already know about the `remove` method that lets you remove a `Map` entry
    for a given key. Since Java 8, an overloaded version removes an entry only if
    the key is associated with a specific value. Previously, this code is how you’d
    implement this behavior (we have nothing against Tom Cruise, but *Jack Reacher
    2* received poor reviews):'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经了解`remove`方法，它允许你根据给定的键移除`Map`条目。自从Java 8以来，一个重载的版本只有在键与特定值关联时才会移除条目。之前，这段代码是这样实现这个行为的（我们并不反对汤姆·克鲁斯，但*杰克·雷acher
    2*收到了差评）：
- en: '[PRE30]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Here is how you can do the same thing now, which you have to admit is much
    more to the point:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以这样做到同样的事情，你不得不承认这更加切中要害：
- en: '[PRE31]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In the next section, you learn about ways of replacing elements in and removing
    elements from a `Map`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将了解如何在`Map`中替换元素和移除元素的方法。
- en: 8.3.6\. Replacement patterns
  id: totrans-162
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.3.6\. 替换模式
- en: '`Map` has two new methods that let you replace the entries inside a `Map`:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`Map` 有两个新方法，允许你替换 `Map` 内部的条目：'
- en: '`replaceAll`—Replaces each entry’s value with the result of applying a `BiFunction`.
    This method works similarly to `replaceAll` on a `List`, which you saw earlier.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`replaceAll`—将每个条目的值替换为应用 `BiFunction` 的结果。这种方法与前面看到的 `List` 上的 `replaceAll`
    方法类似。'
- en: '`Replace`—Lets you replace a value in the `Map` if a key is present. An additional
    overload replaces the value only if it the key is mapped to a certain value.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Replace`—允许你在 `Map` 中替换一个值，如果键存在。一个额外的重载只替换键映射到特定值的值。'
- en: 'You could format all the values in a `Map` as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将 `Map` 中的所有值格式化如下：
- en: '[PRE32]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '***1* We have to use a mutable map since we will be using replaceAll**'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 我们必须使用可变映射，因为我们将会使用replaceAll**'
- en: '***2* {Olivia=JAMES BOND, Raphael=STAR WARS}**'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* {奥利维亚=詹姆斯·邦德, 拉斐尔=星球大战}**'
- en: The replace patterns you’ve learned work with a single `Map`. But what if you
    have to combine and replace values from two `Map`s? You can use a new `merge`
    method for that task.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 你所学的替换模式与单个 `Map` 一起工作。但如果你必须从两个 `Map` 中组合和替换值怎么办？你可以使用一个新的 `merge` 方法来完成这个任务。
- en: 8.3.7\. Merge
  id: totrans-171
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.3.7\. 合并
- en: 'Suppose that you’d like to merge two intermediate `Map`s, perhaps two separate
    `Map`s for two groups of contacts. You can use `putAll` as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想要合并两个中间 `Map`，可能是两组联系人各自的两个单独的 `Map`。你可以使用 `putAll` 如下：
- en: '[PRE33]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '***1* Copies all the entries from friends into everyone**'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将朋友映射中的所有条目复制到每个人映射中**'
- en: '***2* {Cristina=James Bond, Raphael=Star Wars, Teo=Star Wars}**'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* {克里斯蒂娜=詹姆斯·邦德, 拉斐尔=星球大战, 特奥=星球大战}**'
- en: 'This code works as expected as long as you don’t have duplicate keys. If you
    require more flexibility in how values are combined, you can use the new `merge`
    method. This method takes a `BiFunction` to merge values that have a duplicate
    key. Suppose that Cristina is in both the family and friends maps but with different
    associated movies:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码在没有重复键的情况下按预期工作。如果你需要更多灵活性来组合值，可以使用新的 `merge` 方法。这个方法接受一个 `BiFunction` 来合并具有重复键的值。假设克里斯蒂娜同时在家庭和朋友映射中，但关联的电影不同：
- en: '[PRE34]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Then you could use the `merge` method in combination with `forEach` to provide
    a way to deal with the conflict. The following code concatenates the string names
    of the two movies:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以结合使用 `merge` 方法与 `forEach` 来提供一个处理冲突的方法。以下代码连接了两个电影的字符串名称：
- en: '[PRE35]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '***1* Given a duplicate key, concatenates the two values**'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 给定一个重复键，连接两个值**'
- en: '***2* Outputs {Raphael=Star Wars, Cristina=James Bond & Matrix, Teo=Star Wars}**'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 输出 {拉斐尔=星球大战, 克里斯蒂娜=詹姆斯·邦德 & 矩阵, 特奥=星球大战}**'
- en: 'Note that the `merge` method has a fairly complex way to deal with nulls, as
    specified in the Javadoc:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`merge` 方法处理空值的方式相当复杂，如 Javadoc 所述：
- en: '*If the specified key is not already associated with a value or is associated
    with null, [*`merge`*] associates it with the given non-null value. Otherwise,
    [*`merge`*] replaces the associated value with the [result] of the given remapping
    function, or removes [it] if the result is null.*'
  id: totrans-183
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*如果指定的键尚未与值关联或与 null 关联，[*`merge`*] 将它与给定的非空值关联。否则，[*`merge`*] 将关联的值替换为给定的重映射函数的结果，或者如果结果是
    null，则删除 [它]。*'
- en: 'You can also use `merge` to implement initialization checks. Suppose that you
    have a `Map` for recording how many times a movie is watched. You need to check
    that the key representing the movie is in the map before you can increment its
    value:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用 `merge` 来实现初始化检查。假设你有一个 `Map` 来记录一部电影被观看的次数。在你增加其值之前，你需要检查代表电影的键是否在映射中：
- en: '[PRE36]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This code can be rewritten as
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码可以重写为
- en: '[PRE37]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The second argument to merge in this case is `1L`. The Javadoc specifies that
    this argument is “the non-null value to be merged with the existing value associated
    with the key or, if no existing value or a null value is associated with the key,
    to be associated with the key.” Because the value returned for that key is `null`,
    the value 1 is provided the first time around. The next time around, because the
    value for the key was initialized to the value of 1, the `BiFunction` is applied
    to increment the count.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`merge` 的第二个参数是 `1L`。Javadoc 指出，此参数是“要与非现有值或与键关联的 null 值合并的非空值；或者，如果没有现有值或与键关联的
    null 值，则与键关联。”因为对该键返回的值是 `null`，所以第一次提供值 1。下一次，因为该键的值被初始化为 1，所以 `BiFunction` 被应用于增加计数。
- en: '|  |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Quiz 8.2**'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习 8.2**'
- en: 'Figure out what the following code does, and think of what idiomatic operation
    you could use to simplify what it’s doing:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 确定以下代码的作用，并考虑你可以使用什么惯用操作来简化它：
- en: '[PRE38]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '***1* {Matrix=15, JamesBond=20}**'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* {Matrix=15, JamesBond=20}**'
- en: '**Answer:**'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案：**'
- en: 'You can use the `removeIf` method on the map’s entry set, which takes a predicate
    and removes the elements:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在映射的集合上使用`removeIf`方法，它接受一个谓词并删除元素：
- en: '[PRE39]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '|  |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'You’ve learned about the additions to the `Map` interface. New enhancements
    were added to a cousin: `ConcurrentHashMap` which you will learn about next.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经学习了`Map`接口的扩展。一些新的增强功能被添加到了它的一个堂兄弟：`ConcurrentHashMap`，你将在下一节学习到。
- en: 8.4\. Improved ConcurrentHashMap
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.4\. 改进的`ConcurrentHashMap`
- en: The `ConcurrentHashMap` class was introduced to provide a more modern `HashMap`,
    which is also concurrency friendly. `ConcurrentHashMap` allows concurrent `add`
    and `update` operations that lock only certain parts of the internal data structure.
    Thus, read and write operations have improved performance compared with the synchronized
    `Hashtable` alternative. (Note that the standard `HashMap` is unsynchronized.`)`
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConcurrentHashMap`类被引入以提供一种更现代的`HashMap`，它也是并发友好的。`ConcurrentHashMap`允许并发`add`和`update`操作，这些操作只锁定内部数据结构的一部分。因此，与同步的`Hashtable`替代品相比，读写操作的性能得到了提升。（注意，标准的`HashMap`是不同步的。`））'
- en: 8.4.1\. Reduce and Search
  id: totrans-201
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.4.1\. 归约和搜索
- en: '`ConcurrentHashMap` supports three new kinds of operations, reminiscent of
    what you saw with streams:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConcurrentHashMap`支持三种新的操作类型，这与你在流中看到的情况相似：'
- en: '`forEach`—Performs a given action for each (key, value)'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`forEach`—对每个（键，值）执行给定的操作'
- en: '`reduce`—Combines all (key, value) given a reduction function into a result'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`reduce`—将所有给定的（键，值）通过一个归约函数组合成一个结果'
- en: s`earch`—Applies a function on each (key, value) until the function produces
    a non-null result
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`search`—对每个（键，值）应用一个函数，直到函数产生一个非空结果'
- en: 'Each kind of operation supports four forms, accepting functions with keys,
    values, `Map.Entry`, and (key, value) arguments:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 每种操作类型支持四种形式，接受带有键、值、`Map.Entry`和（键，值）参数的函数：
- en: Operates with keys and values (`forEach, reduce, search`)
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用键和值（`forEach, reduce, search`）
- en: Operates with keys (`forEachKey, reduceKeys, searchKeys`)
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用键（`forEachKey, reduceKeys, searchKeys`）
- en: Operates with values (`forEachValue, reduceValues, searchValues`)
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用值（`forEachValue, reduceValues, searchValues`）
- en: Operates with `Map.Entry` objects (`forEachEntry, reduceEntries, search-Entries`)
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Map.Entry`对象（`forEachEntry, reduceEntries, search-Entries`）操作
- en: Note that these operations don’t lock the state of the `ConcurrentHashMap`;
    they operate on the elements as they go along. The functions supplied to these
    operations shouldn’t depend on any ordering or on any other objects or values
    that may change while computation is in progress.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这些操作不会锁定`ConcurrentHashMap`的状态；它们在操作过程中对元素进行操作。提供给这些操作的功能不应该依赖于任何顺序或任何可能在计算过程中改变的其他对象或值。
- en: In addition, you need to specify a parallelism threshold for all these operations.
    The operations execute sequentially if the current size of the map is less than
    the given threshold. A value of `1` enables maximal parallelism using the common
    thread pool. A threshold value of `Long.MAX_VALUE` runs the operation on a single
    thread. You generally should stick to these values unless your software architecture
    has advanced resource-use optimization.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你还需要为所有这些操作指定一个并行度阈值。如果映射的当前大小小于给定的阈值，则操作将按顺序执行。`1`的值启用最大并行性，使用公共线程池。`Long.MAX_VALUE`的阈值值在单个线程上运行操作。除非你的软件架构具有高级资源使用优化，否则你通常应该坚持这些值。
- en: 'In this example, you use the `reduceValues` method to find the maximum value
    in the map:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你使用`reduceValues`方法在映射中找到最大值：
- en: '[PRE40]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '***1* A ConcurrentHashMap, presumed to be updated to contain several keys and
    values**'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 假设`ConcurrentHashMap`被更新以包含多个键和值**'
- en: Note the primitive specializations for int, long, and double for each `reduce`
    operation (`reduceValuesToInt`, `reduceKeysToLong`, and so on), which are more
    efficient, as they prevent boxing.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，对于每个`reduce`操作（如`reduceValuesToInt`、`reduceKeysToLong`等），都有原始特殊化，这更有效，因为它们防止了装箱。
- en: 8.4.2\. Counting
  id: totrans-217
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.4.2\. 计数
- en: The `ConcurrentHashMap` class provides a new method called `mappingCount`, which
    returns the number of mappings in the map as a long. You should use it for new
    code in preference to the `size` method, which returns an int. Doing so future
    proofs your code for use when the number of mappings no longer fits in an int.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConcurrentHashMap`类提供了一个名为`mappingCount`的新方法，它以长整型返回映射中的映射数量。你应该在返回int类型的方法`size`之前使用它，因为这样做可以为当映射数量不再适合int时使用的情况提供未来保障。'
- en: 8.4.3\. Set views
  id: totrans-219
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.4.3. 集合视图
- en: The `ConcurrentHashMap` class provides a new method called `keySet` that returns
    a view of the `ConcurrentHashMap` as a `Set`. (Changes in the map are reflected
    in the `Set`, and vice versa.) You can also create a `Set` backed by a `ConcurrentHashMap`
    by using the new static method `newKeySet`.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConcurrentHashMap`类提供了一个名为`keySet`的新方法，它返回一个将`ConcurrentHashMap`视为`Set`的视图。（映射中的更改反映在`Set`中，反之亦然。）你也可以通过使用新的静态方法`newKeySet`来创建由`ConcurrentHashMap`支持的`Set`。'
- en: Summary
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: Java 9 supports collection factories, which let you create small immutable lists,
    sets, and maps by using `List.of`, `Set.of`, `Map.of,` and `Map.ofEntries`.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java 9支持集合工厂，允许你使用`List.of`、`Set.of`、`Map.of`和`Map.ofEntries`创建小的不可变列表、集合和映射。
- en: The objects returned by these collection factories are immutable, which means
    that you can’t change their state after creation.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些集合工厂返回的对象是不可变的，这意味着你无法在创建后改变它们的状态。
- en: The `List` interface supports the default methods `removeIf`, `replaceAll`,
    and `sor`t.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`List`接口支持默认方法`removeIf`、`replaceAll`和`sor`t。'
- en: The `Set` interface supports the default method `removeIf.`
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Set`接口支持默认方法`removeIf`。'
- en: The `Map` interface includes several new default methods for common patterns
    and reduces the scope for bugs.
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Map`接口包括几个新的默认方法，用于常见模式，并减少了错误范围。'
- en: '`ConcurrentHashMap` supports the new default methods inherited from `Map` but
    provides thread-safe implementations for them.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConcurrentHashMap`支持从`Map`继承的新默认方法，但提供了线程安全的实现。'
- en: Chapter 9\. Refactoring, testing, and debugging
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第9章. 重构、测试和调试
- en: '*This chapter covers*'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Refactoring code to use lambda expressions
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重构代码以使用lambda表达式
- en: Appreciating the impact of lambda expressions on object-oriented design patterns
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 体会lambda表达式对面向对象设计模式的影响
- en: Testing lambda expressions
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试lambda表达式
- en: Debugging code that uses lambda expressions and the Streams API
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试使用lambda表达式和Streams API的代码
- en: In the first eight chapters of this book, you saw the expressive power of lambdas
    and the Streams API. You were mainly creating new code that used these features.
    If you have to start a new Java project, you can use lambdas and streams immediately.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的前八章中，你看到了lambda和Streams API的表达能力。你主要是在创建使用这些特性的新代码。如果你必须从头开始一个新的Java项目，你可以立即使用lambda和流。
- en: Unfortunately, you don’t always get to start a new project from scratch. Most
    of the time you have to deal with an existing code base written in an older version
    of Java.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，你并不总是可以从零开始一个新的项目。大多数时候，你必须处理一个使用较旧版本的Java编写的现有代码库。
- en: This chapter presents several recipes that show you how to refactor existing
    code to use lambda expressions to gain readability and flexibility. In addition,
    we discuss how several object-oriented design patterns (including strategy, template
    method, observer, chain of responsibility, and factory) can be made more concise
    thanks to lambda expressions. Finally, we explore how you can test and debug code
    that uses lambda expressions and the Streams API.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了几个示例，展示了如何重构现有代码以使用lambda表达式来提高可读性和灵活性。此外，我们还讨论了由于lambda表达式，几个面向对象的设计模式（包括策略、模板方法、观察者、责任链和工厂）可以变得更加简洁。最后，我们探讨了如何测试和调试使用lambda表达式和Streams
    API的代码。
- en: 'In [chapter 10](kindle_split_022.xhtml#ch10), we explore a more wide-ranging
    way of refactoring code to make the application logic more readable: creating
    a domain-specific language.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第10章](kindle_split_022.xhtml#ch10)中，我们探讨了重构代码的更广泛方式，以使应用程序逻辑更易于阅读：创建领域特定语言。
- en: 9.1\. Refactoring for improved readability and flexibility
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1. 优化可读性和灵活性
- en: From the start of this book, we’ve argued that lambda expressions let you write
    more concise and flexible code. The code is more concise because lambda expressions
    let you represent a piece of behavior in a more compact form compared with using
    anonymous classes. We also showed you in [chapter 3](kindle_split_013.xhtml#ch03)
    that method references let you write even more concise code when all you want
    to do is pass an existing method as an argument to another method.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 从本书的开头，我们就主张lambda表达式可以让您编写更简洁、更灵活的代码。代码更加简洁，因为lambda表达式允许您以更紧凑的形式表示一段行为，与使用匿名类相比。我们还在[第3章](kindle_split_013.xhtml#ch03)中展示了方法引用如何让您在只想将现有方法作为参数传递给另一个方法时，编写更加简洁的代码。
- en: Your code is more flexible because lambda expressions encourage the style of
    behavior parameterization that we introduced in [chapter 2](kindle_split_012.xhtml#ch02).
    Your code can use and execute multiple behaviors passed as arguments to cope with
    requirement changes.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 您的代码更加灵活，因为lambda表达式鼓励我们[第2章](kindle_split_012.xhtml#ch02)中引入的行为参数化风格。您的代码可以使用和执行作为参数传递的多个行为来应对需求变化。
- en: 'In this section, we bring everything together and show you simple steps for
    refactoring code to gain readability and flexibility, using the features you learned
    in previous chapters: lambdas, method references, and streams.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将所有内容整合在一起，向您展示如何使用之前章节中学到的特性（lambda表达式、方法引用和流）来重构代码，以提升代码的可读性和灵活性。
- en: 9.1.1\. Improving code readability
  id: totrans-242
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.1.1\. 提高代码可读性
- en: What does it mean to improve the readability of code? Defining good readability
    can be subjective. The general view is that the term means “how easily this code
    can be understood by another human.” Improving code readability ensures that your
    code is understandable and maintainable by people other than you. You can take
    a few steps to make sure that your code is understandable to other people, such
    as making sure that your code is well documented and follows coding standards.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 提高代码的可读性意味着什么？定义良好的可读性可能具有主观性。普遍的观点是，这个术语意味着“其他人理解这段代码的难易程度。”提高代码的可读性确保了除了您之外的其他人也能理解并维护您的代码。您可以通过以下步骤确保您的代码对其他人来说是可理解的，例如确保您的代码有良好的文档并遵循编码标准。
- en: Using features introduced in Java 8 can also improve code readability compared
    with previous versions. You can reduce the verbosity of your code, making it easier
    to understand. Also, you can better show the intent of your code by using method
    references and the Streams API.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Java 8引入的特性也可以与之前的版本相比提高代码的可读性。您可以通过减少代码的冗长性来使代码更容易理解。此外，您还可以通过使用方法引用和Streams
    API更好地展示代码的意图。
- en: 'In this chapter, we describe three simple refactorings that use lambdas, method
    references, and streams, which you can apply to your code to improve its readability:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们描述了三种使用lambda表达式、方法引用和流的简单重构方法，您可以将这些方法应用到您的代码中以提高其可读性：
- en: Refactoring anonymous classes to lambda expressions
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将匿名类重构为lambda表达式
- en: Refactoring lambda expressions to method references
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将lambda表达式重构为方法引用
- en: Refactoring imperative-style data processing to streams
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将命令式风格的数据处理重构为流
- en: 9.1.2\. From anonymous classes to lambda expressions
  id: totrans-249
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.1.2\. 从匿名类到lambda表达式
- en: 'The first simple refactoring you should consider is converting uses of anonymous
    classes implementing one single abstract method to lambda expressions. Why? We
    hope that in earlier chapters, we convinced you that anonymous classes are verbose
    and error-prone. By adopting lambda expressions, you produce code that’s more
    succinct and readable. As shown in [chapter 3](kindle_split_013.xhtml#ch03), here’s
    an anonymous class for creating a `Runnable` object and its lambda-expression
    counterpart:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该考虑的第一个简单重构是将实现单个抽象方法的匿名类使用转换为lambda表达式。为什么？我们希望在之前的章节中已经说服您，匿名类是冗长且容易出错的。通过采用lambda表达式，您将产生更简洁、更易读的代码。正如[第3章](kindle_split_013.xhtml#ch03)中所示，以下是一个创建`Runnable`对象的匿名类及其lambda表达式对应物：
- en: '[PRE41]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '***1* Before, using an anonymous class**'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 之前，使用匿名类**'
- en: '***2* After, using a lambda expression**'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 之后，使用lambda表达式**'
- en: 'But converting anonymous classes to lambda expressions can be a difficult process
    in certain situations.^([[1](#ch09fn01)]) First, the meanings of `this` and `super`
    are different for anonymous classes and lambda expressions. Inside an anonymous
    class, `this` refers to the anonymous class itself, but inside a lambda, it refers
    to the enclosing class. Second, anonymous classes are allowed to shadow variables
    from the enclosing class. Lambda expressions can’t (they’ll cause a compile error),
    as shown in the following code:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 但在某些情况下，将匿名类转换为lambda表达式可能是一个困难的过程.^([[1](#ch09fn01)]) 首先，匿名类和lambda表达式中的`this`和`super`的含义不同。在匿名类内部，`this`指的是匿名类本身，但在lambda内部，它指的是封装类。其次，匿名类允许遮蔽封装类的变量。Lambda表达式不能（这将导致编译错误），如下面的代码所示：
- en: ¹
  id: totrans-255
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-256
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'This excellent paper describes the process in more detail: [http://dig.cs.illinois.edu/papers/lambdaRefactoring.pdf](http://dig.cs.illinois.edu/papers/lambdaRefactoring.pdf).'
  id: totrans-257
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这篇优秀的论文详细描述了该过程：[http://dig.cs.illinois.edu/papers/lambdaRefactoring.pdf](http://dig.cs.illinois.edu/papers/lambdaRefactoring.pdf)。
- en: '[PRE42]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '***1* Compile error**'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 编译错误**'
- en: '***2* Everything is fine!**'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 一切正常！**'
- en: 'Finally, converting an anonymous class to a lambda expression can make the
    resulting code ambiguous in the context of overloading. Indeed, the type of anonymous
    class is explicit at instantiation, but the type of the lambda depends on its
    context. Here’s an example of how this situation can be problematic. Suppose that
    you’ve declared a functional interface with the same signature as `Runnable`,
    here called `Task` (as might occur when you need more-meaningful interface names
    in your domain model):'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将匿名类转换为lambda表达式可能会使代码在重载的上下文中变得模糊。确实，匿名类的类型在实例化时是明确的，但lambda的类型取决于其上下文。以下是一个说明这种情况下可能存在问题的例子。假设您已声明了一个与`Runnable`具有相同签名的函数式接口，这里称为`Task`（当您在领域模型中需要更有意义的接口名称时可能会发生这种情况）：
- en: '[PRE43]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Now you can pass an anonymous class implementing `Task` without a problem:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以无问题地传递一个实现`Task`的匿名类：
- en: '[PRE44]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'But converting this anonymous class to a lambda expression results in an ambiguous
    method call, because both `Runnable` and `Task` are valid target types:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 但将这个匿名类转换为lambda表达式会导致一个模糊的方法调用，因为`Runnable`和`Task`都是有效的目标类型：
- en: '[PRE45]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '***1* Problem; both doSomething(Runnable) and doSomething(Task) match.**'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 问题；doSomething(Runnable)和doSomething(Task)都匹配。**'
- en: 'You can solve the ambiguity by providing an explicit cast `(Task)`:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过提供显式的转换`(Task)`来解决歧义：
- en: '[PRE46]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Don’t be turned off by these issues, though; there’s good news! Most integrated
    development environments (IDEs)—such as NetBeans, Eclipse, and IntelliJ—support
    this refactoring and automatically ensure that these gotchas don’t arise.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管存在这些问题，但请保持乐观；有好消息！大多数集成开发环境（IDE）——如NetBeans、Eclipse和IntelliJ——支持这种重构，并自动确保这些陷阱不会出现。
- en: 9.1.3\. From lambda expressions to method references
  id: totrans-271
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.1.3\. 从lambda表达式到方法引用
- en: 'Lambda expressions are great for short code that needs to be passed around.
    But consider using method references whenever possible to improve code readability.
    A method name states the intent of your code more clearly. In [chapter 6](kindle_split_017.xhtml#ch06),
    for example, we showed you the following code to group dishes by caloric levels:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda表达式非常适合需要传递的简短代码。但尽可能使用方法引用来提高代码的可读性。方法名称可以更清楚地表达代码的意图。例如，在[第6章](kindle_split_017.xhtml#ch06)中，我们向您展示了以下代码来按卡路里水平对菜肴进行分组：
- en: '[PRE47]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'You can extract the lambda expression into a separate method and pass it as
    an argument to `groupingBy`. The code becomes more concise, and its intent is
    more explicit:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将lambda表达式提取到单独的方法中，并将其作为参数传递给`groupingBy`。代码变得更加简洁，其意图也更加明确：
- en: '[PRE48]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '***1* The lambda expression is extracted into a method.**'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* Lambda表达式被提取到方法中。**'
- en: 'You need to add the method `getCaloricLevel` inside the `Dish` class itself
    for this code to work:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要将`getCaloricLevel`方法添加到`Dish`类本身中，这样代码才能正常工作：
- en: '[PRE49]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'In addition, consider using helper static methods such as `comparing` and `maxBy`
    whenever possible. These methods were designed for use with method references!
    Indeed, this code states much more clearly its intent than its counterpart using
    a lambda expression, as we showed you in [chapter 3](kindle_split_013.xhtml#ch03):'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，尽可能考虑使用辅助静态方法，如`comparing`和`maxBy`。这些方法是为与方法引用一起使用而设计的！确实，与我们在第3章中展示的lambda表达式相比，这段代码更清楚地表达了其意图，如下所示：
- en: '[PRE50]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '***1* You need to think about the implementation of comparison.**'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 您需要考虑比较的实现。**'
- en: '***2* Reads like the problem statement**'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 读起来像问题陈述**'
- en: Moreover, for many common reduction operations such as *sum*, *maximum*, there
    are built-in helper methods that can be combined with method references. We showed
    you, for example, that by using the `Collectors` API, you can find the maximum
    or sum in a clearer way than by using a combination of a lambda expression and
    a lower-level `reduce` operation. Instead of writing
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，对于许多常见的缩减操作，如 *sum*、*maximum*，有一些内置的辅助方法可以与方法引用结合使用。例如，我们展示了如何使用 `Collectors`
    API，你可以比使用 lambda 表达式和低级别的 `reduce` 操作组合更清晰地找到最大值或总和。而不是编写
- en: '[PRE51]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'try using alternative built-in collectors, which state the problem statement
    more clearly. Here, we use the collector `summingInt` (names go a long way in
    documenting your code):'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用替代的内置收集器，这些收集器更清晰地陈述了问题。在这里，我们使用收集器 `summingInt`（名称在文档化代码方面大有裨益）：
- en: '[PRE52]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 9.1.4\. From imperative data processing to Streams
  id: totrans-287
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.1.4\. 从命令式数据处理到 Streams
- en: Ideally, you should try to convert all code that processes a collection with
    typical data processing patterns with an iterator to use the Streams API instead.
    Why? The Streams API expresses more clearly the intent of a data processing pipeline.
    In addition, streams can be optimized behind the scenes, making use of short-circuiting
    and laziness as well as leveraging your multicore architecture, as we explained
    in [chapter 7](kindle_split_018.xhtml#ch07).
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，你应该尝试将所有使用迭代器处理典型数据处理模式的代码转换为使用 Streams API。为什么？Streams API 更清晰地表达了数据处理管道的意图。此外，流可以在幕后进行优化，利用短路和惰性以及利用你的多核架构，正如我们在[第7章](kindle_split_018.xhtml#ch07)中解释的那样。
- en: 'The following imperative code expresses two patterns (filtering and extracting)
    that are mangled together, forcing the programmer to carefully figure out the
    whole implementation before figuring out what the code does. In addition, an implementation
    that executes in parallel would be a lot more difficult to write. See [chapter
    7](kindle_split_018.xhtml#ch07) (particularly [section 7.2](kindle_split_018.xhtml#ch07lev1sec2))
    to get an idea of the work involved:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令式代码表达了两种模式（过滤和提取），它们被混合在一起，迫使程序员在弄清楚代码做什么之前仔细考虑整个实现。此外，一个并行执行的实现将更加困难。参见[第7章](kindle_split_018.xhtml#ch07)（特别是[7.2节](kindle_split_018.xhtml#ch07lev1sec2)）以了解涉及的工作：
- en: '[PRE53]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The alternative, which uses the Streams API, reads more like the problem statement,
    and it can be easily parallelized:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种使用 Streams API 的替代方案，读起来更像问题陈述，并且可以轻松并行化：
- en: '[PRE54]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Unfortunately, converting imperative code to the Streams API can be a difficult
    task, because you need to think about control-flow statements such as `break`,
    `continue`, and `return` and then infer the right stream operations to use. The
    good news is that some tools can help you with this task as well. The good news
    is that some tools (e.g., Lambda-Ficator, [https://ieeexplore.ieee.org/document/6606699](https://ieeexplore.ieee.org/document/6606699))
    can help you with this task as well.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，将命令式代码转换为 Streams API 可能是一项艰巨的任务，因为你需要考虑控制流语句，如 `break`、`continue` 和 `return`，然后推断出正确的流操作来使用。好消息是，一些工具也可以帮助你完成这项任务。好消息是，一些工具（例如
    Lambda-Ficator，[https://ieeexplore.ieee.org/document/6606699](https://ieeexplore.ieee.org/document/6606699)）也可以帮助你完成这项任务。
- en: 9.1.5\. Improving code flexibility
  id: totrans-294
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.1.5\. 提高代码灵活性
- en: We argued in [chapters 2](kindle_split_012.xhtml#ch02) and [3](kindle_split_013.xhtml#ch03)
    that lambda expressions encourage the style of behavior parameterization. You
    can represent multiple behaviors with different lambdas that you can then pass
    around to execute. This style lets you cope with requirement changes (creating
    multiple ways of filtering with a `Predicate` or comparing with a `Comparator`,
    for example). In the next section, we look at a couple of patterns that you can
    apply to your code base to benefit immediately from lambda expressions.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第2章](kindle_split_012.xhtml#ch02)和[第3章](kindle_split_013.xhtml#ch03)中论证，lambda
    表达式鼓励行为参数化的风格。你可以用不同的 lambda 来表示多种行为，然后可以将它们传递出去执行。这种风格让你能够应对需求变化（例如，使用 `Predicate`
    创建多个过滤方式或使用 `Comparator` 进行比较）。在下一节中，我们将探讨一些你可以应用到代码库中的模式，以立即从 lambda 表达式中受益。
- en: Adopting functional interfaces
  id: totrans-296
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 采用函数式接口
- en: 'First, you can’t use lambda expressions without functional interfaces; therefore,
    you should start introducing them in your code base. But in which situations should
    you introduce them? In this chapter, we discuss two common code patterns that
    can be refactored to leverage lambda expressions: conditional deferred execution
    and execute around. Also, in the next section, we show you how various object-oriented
    design patterns—such as the strategy and template-method design patterns—can be
    rewritten more concisely with lambda expressions.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，没有功能接口，你无法使用lambda表达式；因此，你应该开始在代码库中引入它们。但在哪种情况下应该引入它们？在本章中，我们讨论了两种常见的代码模式，可以将它们重构为利用lambda表达式：条件延迟执行和执行周围。在下一节中，我们将向你展示如何使用lambda表达式更简洁地重写各种面向对象设计模式——例如策略和模板方法设计模式。
- en: Conditional deferred execution
  id: totrans-298
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 条件延迟执行
- en: 'It’s common to see control-flow statements mangled inside business-logic code.
    Typical scenarios include security checks and logging. Consider the following
    code, which uses the built-in Java `Logger` class:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在业务逻辑代码中看到控制流语句被破坏是很常见的。典型场景包括安全检查和记录。考虑以下使用内置Java `Logger`类的代码：
- en: '[PRE55]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'What’s wrong with it? A couple of things:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 这有什么问题？几点：
- en: The state of the logger (what level it supports) is exposed in the client code
    through the method `isLoggable`.
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录器的状态（它支持哪些级别）通过`isLoggable`方法在客户端代码中暴露。
- en: Why should you have to query the state of the logger object every time before
    you log a message? It clutters your code.
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么你每次记录消息之前都必须查询记录器对象的状态？这会使你的代码变得杂乱。
- en: 'A better alternative is to use the `log` method, which checks internally to
    see whether the logger object is set to the right level before logging the message:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更好的替代方案是使用`log`方法，该方法在记录消息之前，内部检查记录器对象是否设置为正确的级别：
- en: '[PRE56]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'This approach is better because your code isn’t cluttered with `if` checks,
    and the state of the logger is no longer exposed. Unfortunately, this code still
    has an issue: the logging message is always evaluated, even if the logger isn’t
    enabled for the message level passed as an argument.'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法更好，因为你的代码中没有`if`检查，记录器的状态也不再暴露。不幸的是，这段代码仍然有一个问题：即使记录器没有启用传递的消息级别，日志消息总是会被评估。
- en: 'Lambda expressions can help. What you need is a way to defer the construction
    of the message so that it can be generated only under a given condition (here,
    when the logger level is set to `FINER`). It turns out that the Java 8 API designers
    knew about this problem and introduced an overloaded alternative to `log` that
    takes a `Supplier` as an argument. This alternative `log` method has the following
    signature:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda表达式可以帮助。你需要一种方式来延迟消息的构建，以便它只能在给定条件下生成（在这里，当记录器级别设置为`FINER`时）。结果证明，Java
    8 API设计者知道这个问题，并引入了一个重载的`log`方法，该方法接受一个`Supplier`作为参数。这个替代`log`方法具有以下签名：
- en: '[PRE57]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Now you can call it as follows:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以这样调用它：
- en: '[PRE58]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The `log` method internally executes the lambda passed as an argument only
    if the logger is of the right level. The internal implementation of the `log`
    method is along these lines:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '`log`方法仅在记录器处于正确的级别时，内部执行作为参数传递的lambda表达式。`log`方法的内部实现大致如下：'
- en: '[PRE59]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '***1* Executing the lambda**'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 执行lambda表达式**'
- en: What’s the takeaway from the story? If you see yourself querying the state of
    an object (such as the state of the logger) many times in client code, only to
    call some method on this object with arguments (such as to log a message), consider
    introducing a new method that calls that method, passed as a lambda or method
    reference, only after internally checking the state of the object. Your code will
    be more readable (less cluttered) and better encapsulated, without exposing the
    state of the object in client code.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个故事中我们能学到什么？如果你在客户端代码中多次查询对象的状态（例如记录器的状态），只是为了调用这个对象上的某个方法（例如记录一条消息），考虑引入一个新的方法，该方法在内部检查对象的状态后，仅通过lambda表达式或方法引用调用该方法。你的代码将更易于阅读（更简洁），并且封装性更好，而不会在客户端代码中暴露对象的状态。
- en: Execute around
  id: totrans-315
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 执行周围
- en: 'In [chapter 3](kindle_split_013.xhtml#ch03), we discussed another pattern that
    you can adopt: execute around. If you find yourself surrounding different code
    with the same preparation and cleanup phases, you can often pull that code into
    a lambda. The benefit is that you can reuse the logic dealing with the preparation
    and cleanup phases, thus reducing code duplication.'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 3 章](kindle_split_013.xhtml#ch03)中，我们讨论了你可以采用的另一种模式：执行周围。如果你发现自己用相同的准备和清理阶段包围不同的代码，你通常可以将这些代码拉入
    lambda。好处是你可以重用处理准备和清理阶段的逻辑，从而减少代码重复。
- en: 'Here’s the code that you saw in [chapter 3](kindle_split_013.xhtml#ch03). It
    reuses the same logic to open and close a file but can be parameterized with different
    lambdas to process the file:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你在[第 3 章](kindle_split_013.xhtml#ch03)中看到的代码。它重用了相同的逻辑来打开和关闭文件，但可以用不同的 lambda
    参数化来处理文件：
- en: '[PRE60]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '***1* Pass a lambda.**'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 传递一个 lambda。**'
- en: '***2* Pass a different lambda.**'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 传递不同的 lambda。**'
- en: '***3* Execute the Buffered-ReaderProcessor passed as an argument.**'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 执行作为参数传递的 Buffered-ReaderProcessor。**'
- en: '***4* A functional interface for a lambda, which can throw an IOException**'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 一个用于 lambda 的功能接口，可以抛出 IOException**'
- en: This code was made possible by introducing the functional interface `BufferedReader-Processor`,
    which lets you pass different lambdas to work with a `BufferedReader` object.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码是通过引入功能接口 `BufferedReader-Processor` 实现的，它允许你传递不同的 lambda 来处理 `BufferedReader`
    对象。
- en: In this section, you’ve seen how to apply various recipes to improve the readability
    and flexibility of your code. In the next section, you see how lambda expressions
    can remove boilerplate code associated with common object-oriented design patterns.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你看到了如何应用各种配方来提高你代码的可读性和灵活性。在下一节中，你将看到 lambda 表达式如何移除与常见面向对象设计模式相关的样板代码。
- en: 9.2\. Refactoring object-oriented design patterns with lambdas
  id: totrans-325
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2\. 使用 lambda 重构面向对象设计模式
- en: New language features often make existing code patterns or idioms less popular.
    The introduction of the `for-each` loop in Java 5, for example, has replaced many
    uses of explicit iterators because it’s less error-prone and more concise. The
    introduction of the diamond operator `<>` in Java 7 reduced the use of explicit
    generics at instance creation (and slowly pushed Java programmers to embrace type
    inference).
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 新的语言特性往往使现有的代码模式或习惯用法不那么受欢迎。例如，Java 5 中 `for-each` 循环的引入取代了许多显式迭代器的使用，因为它更不容易出错，更简洁。Java
    7 中菱形运算符 `<>` 的引入减少了实例创建时显式泛型的使用（并逐渐推动 Java 程序员接受类型推断）。
- en: A specific class of patterns is called design patterns.^([[2](#ch09fn02)]) *Design
    patterns* are reusable blueprints, if you will, for common problems in designing
    software. They are rather like how construction engineers have a set of reusable
    solutions to construct bridges for specific scenarios (suspension bridge, arch
    bridge, and so on). The *visitor design pattern,* for example, is a common solution
    for separating an algorithm from a structure on which it needs to operate. The
    *singleton pattern* is a common solution to restrict the instantiation of a class
    to one object.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 一类特定的模式被称为设计模式.^([[2](#ch09fn02)]) *设计模式*可以视为解决软件设计中常见问题的可重用蓝图。它们类似于建筑工程师拥有一套可重用的解决方案来构建特定场景下的桥梁（如悬索桥、拱桥等）。例如，*访问者设计模式*是一种常见的解决方案，用于将算法与其需要操作的特定结构分离。*单例模式*是一种常见的解决方案，用于限制类的实例化只能有一个对象。
- en: ²
  id: totrans-328
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ²
- en: ''
  id: totrans-329
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'See *Design Patterns: Elements of Reusable Object-Oriented Software*, by Erich
    Gamma, Richard Helm, Ralph Johnson, and John Vlissides; ISBN 978-0201633610, ISBN
    0-201-63361-2'
  id: totrans-330
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '见 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 所著的 *Design Patterns:
    Elements of Reusable Object-Oriented Software*；ISBN 978-0201633610，ISBN 0-201-63361-2'
- en: Lambda expressions provide yet another new tool in the programmer’s toolbox.
    They can provide alternative solutions to the problems that the design patterns
    are tackling, but often with less work and in a simpler way. Many existing object-oriented
    design patterns can be made redundant or written in a more concise way with lambda
    expressions.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda 表达式为程序员提供了另一个新的工具。它们可以提供替代设计模式解决问题的方案，但通常工作量更少，方式更简单。许多现有的面向对象设计模式可以通过
    lambda 表达式变得冗余或以更简洁的方式编写。
- en: 'In this section, we explore five design patterns:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了五种设计模式：
- en: Strategy
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 策略
- en: Template method
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板方法
- en: Observer
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 观察者
- en: Chain of responsibility
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 责任链
- en: Factory
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工厂
- en: We show you how lambda expressions can provide an alternative way to solve the
    problem that each design pattern is intended to solve.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向你展示 lambda 表达式如何提供一种替代方法来解决每个设计模式旨在解决的问题。
- en: 9.2.1\. Strategy
  id: totrans-339
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.2.1\. 策略
- en: The strategy pattern is a common solution for representing a family of algorithms
    and letting you choose among them at runtime. You saw this pattern briefly in
    [chapter 2](kindle_split_012.xhtml#ch02) when we showed you how to filter an inventory
    with different predicates (such as heavy apples or green apples). You can apply
    this pattern to a multitude of scenarios, such as validating an input with different
    criteria, using different ways of parsing, or formatting an input.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 策略模式是表示一系列算法并允许你在运行时从中选择的一种常见解决方案。你曾在[第 2 章](kindle_split_012.xhtml#ch02)中简要地看到过这个模式，当时我们向你展示了如何使用不同的谓词（如重苹果或绿苹果）来过滤库存。你可以将此模式应用于多种场景，例如使用不同的标准验证输入，使用不同的解析方式或格式化输入。
- en: 'The strategy pattern consists of three parts, as illustrated in [figure 9.1](#ch09fig01):'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 策略模式由三个部分组成，如图 9.1 所示：
- en: An interface to represent some algorithm (the interface `Strategy`)
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表示某种算法的接口（接口 `Strategy`）
- en: One or more concrete implementations of that interface to represent multiple
    algorithms (the concrete classes `ConcreteStrategyA`, `ConcreteStrategyB`)
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个或多个具体实现该接口以表示多个算法（具体类 `ConcreteStrategyA`，`ConcreteStrategyB`）
- en: One or more clients that use the strategy objects
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个或多个使用策略对象的客户端
- en: Figure 9.1\. The strategy design pattern
  id: totrans-345
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 9.1\. 策略设计模式
- en: '![](Images/09fig01_alt.jpg)'
  id: totrans-346
  prefs: []
  type: TYPE_IMG
  zh: '![图片 9.1](Images/09fig01_alt.jpg)'
- en: 'Suppose that you’d like to validate whether a text input is properly formatted
    for different criteria (consists of only lowercase letters or is numeric, for
    example). You start by defining an interface to validate the text (represented
    as a `String`):'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想要验证一个文本输入是否按照不同的标准（例如仅由小写字母组成或为数字）正确格式化。你首先定义一个接口来验证文本（表示为 `String`）：
- en: '[PRE61]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Second, you define one or more implementation(s) of that interface:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，你定义该接口的一个或多个实现：
- en: '[PRE62]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Then you can use these different validation strategies in your program:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以在你的程序中使用这些不同的验证策略：
- en: '[PRE63]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '***1* Returns false**'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 返回 false**'
- en: '***2* Returns true**'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 返回 true**'
- en: Using lambda expressions
  id: totrans-355
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用 lambda 表达式
- en: 'By now, you should recognize that `ValidationStrategy` is a functional interface.
    In addition, it has the same function descriptor as `Predicate<String>`. As a
    result, instead of declaring new classes to implement different strategies, you
    can pass more concise lambda expressions directly:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你应该已经认识到 `ValidationStrategy` 是一个函数式接口。此外，它具有与 `Predicate<String>` 相同的功能描述符。因此，你不需要声明新的类来实现不同的策略，可以直接传递更简洁的
    lambda 表达式：
- en: '[PRE64]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '***1* Passing a lambda directly**'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 直接传递 lambda 表达式**'
- en: As you can see, lambda expressions remove the boilerplate code that’s inherent
    to the strategy design pattern. If you think about it, lambda expressions encapsulate
    a piece of code (or strategy), which is what the strategy design pattern was created
    for, so we recommend that you use lambda expressions instead for similar problems.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，lambda 表达式消除了策略设计模式固有的样板代码。如果你这么想，lambda 表达式封装了一块代码（或策略），这正是策略设计模式被创建的原因，所以我们建议你在类似的问题上使用
    lambda 表达式。
- en: 9.2.2\. Template method
  id: totrans-360
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.2.2\. 模板方法
- en: The template method design pattern is a common solution when you need to represent
    the outline of an algorithm and have the additional flexibility to change certain
    parts of it. Okay, this pattern sounds a bit abstract. In other words, the template
    method pattern is useful when you find yourself saying “I’d love to use this algorithm,
    but I need to change a few lines so it does what I want.”
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 模板方法设计模式是在你需要表示算法的轮廓并具有更改其某些部分的额外灵活性时的一种常见解决方案。好吧，这个模式听起来有点抽象。换句话说，当你说“我很想使用这个算法，但我需要更改几行使其按我的要求工作”时，模板方法模式很有用。
- en: 'Here’s an example of how this pattern works. Suppose that you need to write
    a simple online banking application. Users typically enter a customer ID; the
    application fetches the customer’s details from the bank’s database and does something
    to make the customer happy. Different online banking applications for different
    banking branches may have different ways of making a customer happy (such as adding
    a bonus to his account or sending him less paperwork). You can write the following
    abstract class to represent the online banking application:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个这个模式如何工作的例子。假设您需要编写一个简单的在线银行应用程序。用户通常输入客户ID；应用程序从银行的数据库中获取客户的详细信息，并做一些使客户满意的事情。不同分支的在线银行应用程序可能有不同的使客户满意的方式（例如向他的账户添加奖金或减少他的文件工作）。您可以编写以下抽象类来表示在线银行应用程序：
- en: '[PRE65]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'The `processCustomer` method provides a sketch for the online banking algorithm:
    Fetch the customer given its ID and make the customer happy. Now different branches
    can provide different implementations of the `makeCustomerHappy` method by subclassing
    the `OnlineBanking` class.'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '`processCustomer`方法为在线银行算法提供了一个草图：根据其ID获取客户并使客户满意。现在，不同的分支可以通过继承`OnlineBanking`类来提供`makeCustomerHappy`方法的不同的实现。'
- en: Using lambda expressions
  id: totrans-365
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用lambda表达式
- en: You can tackle the same problem (creating an outline of an algorithm and letting
    implementers plug in some parts) by using your favorite lambdas. The components
    of the algorithms you want to plug in can be represented by lambda expressions
    or method references.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用您喜欢的lambda表达式来解决相同的问题（创建算法的轮廓并让实施者插入一些部分）。您想要插入的算法组件可以用lambda表达式或方法引用表示。
- en: 'Here, we introduce a second argument to the `processCustomer` method of type
    `Consumer<Customer>` because it matches the signature of the method `makeCustomer-Happy`
    defined earlier:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将一个类型为`Consumer<Customer>`的第二个参数引入到`processCustomer`方法中，因为它与之前定义的`makeCustomerHappy`方法的签名相匹配：
- en: '[PRE66]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Now you can plug in different behaviors directly without subclassing the `Online-Banking`
    class by passing lambda expressions:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以通过传递lambda表达式直接插入不同的行为，而无需对`Online-Banking`类进行子类化：
- en: '[PRE67]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: This example shows how lambda expressions can help you remove the boilerplate
    inherent to design patterns.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示了lambda表达式如何帮助您移除设计模式中固有的样板代码。
- en: 9.2.3\. Observer
  id: totrans-372
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.2.3\. 观察者
- en: The observer design pattern is a common solution when an object (called the
    *subject*) needs to automatically notify a list of other objects (called *observers*)
    when some event happens (such as a state change). You typically come across this
    pattern when working with GUI applications. You register a set of observers on
    a GUI component such as a button. If the button is clicked, the observers are
    notified and can execute a specific action. But the observer pattern isn’t limited
    to GUIs. The observer design pattern is also suitable in a situation in which
    several traders (observers) want to react to the change of price of a stock (subject).
    [Figure 9.2](#ch09fig02) illustrates the UML diagram of the observer pattern.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者设计模式是在一个对象（称为*主题*）需要自动通知其他对象列表（称为*观察者*）在某个事件发生时（例如状态变化）时的常见解决方案。您通常在处理GUI应用程序时遇到这种模式。您在按钮等GUI组件上注册一组观察者。如果按钮被点击，观察者将被通知并可以执行特定操作。但观察者模式不仅限于GUI。观察者设计模式也适用于多个交易者（观察者）希望对股票（主题）价格的变化做出反应的情况。[图9.2](#ch09fig02)展示了观察者模式的UML图。
- en: Figure 9.2\. The observer design pattern
  id: totrans-374
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.2\. 观察者设计模式
- en: '![](Images/09fig02_alt.jpg)'
  id: totrans-375
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/09fig02_alt.jpg)'
- en: 'Now write some code to see how useful the observer pattern is in practice.
    You’ll design and implement a customized notification system for an application
    such as Twitter. The concept is simple: several newspaper agencies (*The New York
    Times*, *The Guardian*, and *Le Monde*) are subscribed to a feed of news tweets
    and may want to receive a notification if a tweet contains a particular keyword.'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 现在编写一些代码来查看观察者模式在实际中的实用性。您将为类似Twitter这样的应用程序设计并实现一个定制的通知系统。概念很简单：几家新闻机构（*《纽约时报》*，*《卫报》*和*《世界报》*）订阅了新闻推文的源，如果推文包含特定的关键词，它们可能希望收到通知。
- en: 'First, you need an `Observer` interface that groups the observers. It has one
    method, called `notify`, that will be called by the subject (`Feed`) when a new
    tweet is available:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要一个`Observer`接口来分组观察者。它有一个名为`notify`的方法，当有新的推文可用时，将由主题（`Feed`）调用：
- en: '[PRE68]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Now you can declare different observers (here, the three newspapers) that produce
    a different action for each different keyword contained in a tweet:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以声明不同的观察者（这里，是三家报纸），它们会对推文中包含的不同关键词执行不同的操作：
- en: '[PRE69]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'You’re still missing the crucial part: the subject. Define an interface for
    the subject:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 你仍然缺少关键部分：主题。为主题定义一个接口：
- en: '[PRE70]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The subject can register a new observer using the `registerObserver` method
    and notify his observers of a tweet with the `notifyObservers` method. Now implement
    the `Feed` class:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 主题可以使用`registerObserver`方法注册新的观察者，并使用`notifyObservers`方法通知观察者关于推文的信息。现在实现`Feed`类：
- en: '[PRE71]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'This implementation is straightforward: the feed keeps an internal list of
    observers that it can notify when a tweet arrives. You can create a demo application
    to wire up the subject and observers:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实现很简单：该feed维护一个内部观察者列表，当收到一条推文时可以通知这些观察者。你可以创建一个演示应用程序来连接主题和观察者：
- en: '[PRE72]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Unsurprisingly, *The Guardian* picks up this tweet.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 毫不奇怪，*《卫报》* 收到了这条推文。
- en: Using lambda expressions
  id: totrans-388
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用lambda表达式
- en: 'You may be wondering how to use lambda expressions with the observer design
    pattern. Notice that the various classes that implement the `Observer` interface
    all provide implementation for a single method: `notify`. They’re wrapping a piece
    of behavior to execute when a tweet arrives. Lambda expressions are designed specifically
    to remove that boilerplate. Instead of instantiating three observer objects explicitly,
    you can pass a lambda expression directly to represent the behavior to execute:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道如何使用lambda表达式与观察者设计模式结合。注意，实现`Observer`接口的各个类都为单个方法提供了实现：`notify`。它们封装了当收到推文时要执行的行为。Lambda表达式专门设计用来移除这些样板代码。你不需要显式实例化三个观察者对象，可以直接传递一个lambda表达式来表示要执行的行为：
- en: '[PRE73]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Should you use lambda expressions all the time? The answer is no. In the example
    we described, lambda expressions work great because the behavior to execute is
    simple, so they’re helpful for removing boilerplate code. But the observers may
    be more complex; they could have state, define several methods, and the like.
    In those situations, you should stick with classes.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否应该始终使用lambda表达式？答案是：不。在我们描述的例子中，lambda表达式工作得很好，因为要执行的行为很简单，因此它们有助于移除样板代码。但是观察者可能更复杂；它们可能有状态，定义多个方法等。在这些情况下，你应该坚持使用类。
- en: 9.2.4\. Chain of responsibility
  id: totrans-392
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.2.4. 职责链
- en: The chain of responsibility pattern is a common solution to create a chain of
    processing objects (such as a chain of operations). One processing object may
    do some work and pass the result to another object, which also does some work
    and passes it on to yet another processing object, and so on.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 职责链模式是创建处理对象链（如操作链）的常见解决方案。一个处理对象可能做一些工作并将结果传递给另一个对象，该对象也做一些工作并将结果传递给另一个处理对象，依此类推。
- en: 'Generally, this pattern is implemented by defining an abstract class representing
    a processing object that defines a field to keep track of a successor. When it
    finishes its work, the processing object hands over its work to its successor.
    The code looks like this:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，此模式通过定义一个表示处理对象的抽象类来实现，该类定义了一个字段来跟踪后继者。当它完成其工作后，处理对象将工作转交给其后继者。代码看起来像这样：
- en: '[PRE74]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[Figure 9.3](#ch09fig03) illustrates the chain of responsibility pattern in
    UML.'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '[图9.3](#ch09fig03) 使用UML说明了职责链模式。'
- en: Figure 9.3\. The chain of responsibility design pattern
  id: totrans-397
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.3. 职责链设计模式
- en: '![](Images/09fig03.jpg)'
  id: totrans-398
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/09fig03.jpg)'
- en: Here, you may recognize the template method design pattern, which we discussed
    in [section 9.2.2](#ch09lev2sec7). The `handle` method provides an outline for
    dealing with a piece of work. You can create different kinds of processing objects
    by subclassing the `Processing-Object` class and by providing an implementation
    for the `handleWork` method.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，你可能认出了我们在[9.2.2节](#ch09lev2sec7)中讨论的模板方法设计模式。`handle`方法提供了一个处理工作的框架。你可以通过子类化`Processing-Object`类并提供`handleWork`方法的实现来创建不同类型的处理对象。
- en: 'Here’s an example of how to use this pattern. You can create two processing
    objects doing some text processing:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个如何使用此模式的例子。你可以创建两个执行一些文本处理的处理对象：
- en: '[PRE75]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '***1* Oops—we forgot the ‘m’ in “lambda”!**'
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 哦，我们忘记在“lambda”中写‘m’了！**'
- en: 'Now you can connect two processing objects to construct a chain of operations:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以连接两个处理对象来构建操作链：
- en: '[PRE76]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '***1* Chaining two processing objects**'
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 连接两个处理对象**'
- en: '***2* Prints “From Raoul, Mario and Alan: Aren’t lambdas really sexy?!!”**'
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 打印出“来自 Raoul, Mario 和 Alan：lambda 真的很有魅力吗？!!”**'
- en: Using lambda expressions
  id: totrans-407
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用 lambda 表达式
- en: 'Wait a minute—this pattern looks like chaining (that is, composing) functions.
    We discussed composing lambda expressions in [chapter 3](kindle_split_013.xhtml#ch03).
    You can represent the processing objects as an instance of `Function<String, String>`,
    or (more precisely) a `UnaryOperator<String>`. To chain them, compose these functions
    by using the `andThen` method:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 等一下——这个模式看起来像是函数链（即组合）。我们在[第 3 章](kindle_split_013.xhtml#ch03)中讨论了组合 lambda
    表达式。你可以将处理对象表示为 `Function<String, String>` 的一个实例，或者（更精确地）一个 `UnaryOperator<String>`。要链式调用它们，请使用
    `andThen` 方法组合这些函数：
- en: '[PRE77]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '***1* The first processing object**'
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 第一个处理对象**'
- en: '***2* The second processing object**'
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 第二个处理对象**'
- en: '***3* Compose the two functions, resulting in a chain of operations.**'
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 组合两个函数，形成一个操作链。**'
- en: 9.2.5\. Factory
  id: totrans-413
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.2.5\. 工厂
- en: 'The factory design pattern lets you create objects without exposing the instantiation
    logic to the client. Suppose that you’re working for a bank that needs a way of
    creating different financial products: loans, bonds, stocks, and so on.'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂设计模式允许你创建对象，同时不向客户端暴露实例化逻辑。假设你为一家银行工作，该银行需要一种创建不同金融产品的方法：贷款、债券、股票等等。
- en: 'Typically, you’d create a `Factory` class with a method that’s responsible
    for the creation of different objects, as shown here:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你会创建一个 `Factory` 类，其中包含一个负责创建不同对象的方法，如下所示：
- en: '[PRE78]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Here, `Loan`, `Stock`, and `Bond` are subtypes of `Product`. The `createProduct`
    method could have additional logic to configure each created product. But the
    benefit is that you can create these objects without exposing the constructor
    and the configuration to the client, which makes the creation of products simpler
    for the client, as follows:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`Loan`、`Stock` 和 `Bond` 是 `Product` 的子类型。`createProduct` 方法可以包含额外的逻辑来配置每个创建的产品。但好处是你可以创建这些对象，同时不向客户端暴露构造函数和配置，这使得客户端创建产品更加简单，如下所示：
- en: '[PRE79]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Using lambda expressions
  id: totrans-419
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用 lambda 表达式
- en: 'You saw in [chapter 3](kindle_split_013.xhtml#ch03) that you can refer to constructors
    the way that you refer to methods: by using method references. Here’s how to refer
    to the `Loan` constructor:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 你在[第 3 章](kindle_split_013.xhtml#ch03)中看到，你可以像引用方法一样引用构造函数：使用方法引用。以下是如何引用 `Loan`
    构造函数的示例：
- en: '[PRE80]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Using this technique, you could rewrite the preceding code by creating a `Map`
    that maps a product name to its constructor:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种技术，你可以通过创建一个将产品名称映射到其构造函数的 `Map` 来重写前面的代码：
- en: '[PRE81]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'You can use this `Map` to instantiate different products, as you did with the
    factory design pattern:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这个 `Map` 来实例化不同的产品，就像使用工厂设计模式一样：
- en: '[PRE82]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: This technique is a neat way to use this Java 8 feature to achieve the same
    intent as the factory pattern. But this technique doesn’t scale well if the factory
    method `create-Product` needs to take multiple arguments to pass to the product
    constructors. You’d have to provide a functional interface other than a simple
    `Supplier`.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术是一种巧妙的方法，使用 Java 8 的这个特性来实现与工厂模式相同的目的。但如果工厂方法 `create-Product` 需要传递多个参数给产品构造函数，这种技术就不太适用了。你将不得不提供除简单的
    `Supplier` 之外的函数式接口。
- en: 'Suppose that you want to refer to constructors for products that take three
    arguments (two `Integer`s and a `String`); you need to create a special functional
    interface `TriFunction` to support such constructors. As a result, the signature
    of the `Map` becomes more complex:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想引用需要三个参数（两个 `Integer` 和一个 `String`）的产品构造函数；你需要创建一个特殊的函数式接口 `TriFunction`
    来支持这样的构造函数。因此，`Map` 的签名变得更加复杂：
- en: '[PRE83]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: You’ve seen how to write and refactor code by using lambda expressions. In the
    next section, you see how to ensure that your new code is correct.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了如何使用 lambda 表达式编写和重构代码。在下一节中，你将看到如何确保你的新代码是正确的。
- en: 9.3\. Testing lambdas
  id: totrans-430
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3\. 测试 lambda
- en: You’ve sprinkled your code with lambda expressions, and it looks nice and concise.
    But in most developer jobs, you’re paid not for writing nice code, but for writing
    code that’s correct.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经在代码中使用了 lambda 表达式，代码看起来既美观又简洁。但在大多数开发者的工作中，你得到的报酬不是写漂亮的代码，而是写正确的代码。
- en: 'Generally, good software engineering practice involves using unit testing to
    ensure that your program behaves as intended. You write test cases, which assert
    that small individual parts of your source code are producing the expected results.
    Consider a simple `Point` class for a graphical application:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，良好的软件工程实践涉及使用单元测试来确保你的程序按预期行为。你编写测试用例，断言你的源代码的小部分产生预期的结果。考虑一个简单的用于图形应用的`Point`类：
- en: '[PRE84]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'The following unit test checks whether the method `moveRightBy` behaves as
    expected:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 以下单元测试检查`moveRightBy`方法是否按预期行为：
- en: '[PRE85]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 9.3.1\. Testing the behavior of a visible lambda
  id: totrans-436
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.3.1\. 测试可见lambda的行为
- en: This code works nicely because the `moveRightBy` method is public and, therefore,
    can be tested inside the test case. But lambdas don’t have names (they’re anonymous
    functions, after all), and testing them in your code is tricky because you can’t
    refer to them by name.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码运行良好，因为`moveRightBy`方法是公开的，因此可以在测试用例中测试。但lambda没有名字（毕竟它们是无名函数），在你的代码中测试它们是棘手的，因为你不能通过名字引用它们。
- en: 'Sometimes, you have access to a lambda via a field so that you can reuse it,
    and you’d like to test the logic encapsulated in that lambda. What can you do?
    You could test the lambda as you do when calling methods. Suppose that you add
    a static field `compareByXAndThenY` in the `Point` class that gives you access
    to a `Comparator` object generated from method references:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可以通过一个字段访问到一个lambda，这样你可以重用它，并且你想要测试那个lambda中封装的逻辑。你能做什么？你可以像调用方法一样测试lambda。假设你在`Point`类中添加一个静态字段`compareByXAndThenY`，它让你可以访问由方法引用生成的`Comparator`对象：
- en: '[PRE86]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Remember that lambda expressions generate an instance of a functional interface.
    As a result, you can test the behavior of that instance. Here, you can call the
    `compare` method on the `Comparator` object `compareByXAndThenY` with different
    arguments to test whether its behavior is as intended:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，lambda表达式生成一个函数式接口的实例。因此，你可以测试那个实例的行为。在这里，你可以通过不同的参数调用`Comparator`对象`compareByXAndThenY`上的`compare`方法来测试其行为是否符合预期：
- en: '[PRE87]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 9.3.2\. Focusing on the behavior of the method using a lambda
  id: totrans-442
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.3.2\. 专注于使用lambda的方法的行为
- en: 'But the purpose of lambdas is to encapsulate a one-off piece of behavior to
    be used by another method. In that case, you shouldn’t make lambda expressions
    available publicly; they’re only implementation details. Instead, we argue that
    you should test the behavior of the method that uses a lambda expression. Consider
    the `moveAllPoints-RightBy` method shown here:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 但lambda的目的在于封装一个一次性行为，以便其他方法使用。在这种情况下，你不应该公开lambda表达式；它们只是实现细节。相反，我们认为你应该测试使用lambda表达式的那个方法的行为。考虑这里显示的`moveAllPoints-RightBy`方法：
- en: '[PRE88]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'There’s no point (pun intended) in testing the lambda `p -> new Point(p.getX()
    + x, p.getY())`; it’s only an implementation detail for the `moveAllPointsRightBy`
    method. Instead, you should focus on testing the behavior of the `moveAllPointsRightBy`
    method:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 测试lambda `p -> new Point(p.getX() + x, p.getY())`没有意义（有意为之）；它只是`moveAllPointsRightBy`方法的实现细节。相反，你应该专注于测试`moveAllPointsRightBy`方法的行为：
- en: '[PRE89]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Note that in the unit test, it’s important for the `Point` class to implement
    the `equals` method appropriately; otherwise, it relies on the default implementation
    from `Object`.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在单元测试中，`Point`类适当地实现`equals`方法是重要的；否则，它依赖于`Object`的默认实现。
- en: 9.3.3\. Pulling complex lambdas into separate methods
  id: totrans-448
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.3.3\. 将复杂的lambda提取到单独的方法中
- en: Perhaps you come across a really complicated lambda expression that contains
    a lot of logic (such as a technical pricing algorithm with corner cases). What
    do you do, because you can’t refer to the lambda expression inside your test?
    One strategy is to convert the lambda expression to a method reference (which
    involves declaring a new regular method), as we explained in [section 9.1.3](#ch09lev2sec3).
    Then you can test the behavior of the new method as you would that of any regular
    method.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 也许你会遇到一个非常复杂的lambda表达式，其中包含很多逻辑（例如具有边缘情况的复杂技术定价算法）。你该怎么办，因为你不能在测试中引用lambda表达式？一种策略是将lambda表达式转换为方法引用（这涉及到声明一个新的常规方法），正如我们在[第9.1.3节](#ch09lev2sec3)中解释的那样。然后你可以像测试任何常规方法一样测试新方法的行为。
- en: 9.3.4\. Testing high-order functions
  id: totrans-450
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.3.4\. 测试高阶函数
- en: 'Methods that take a function as an argument or return another function (so-called
    higher-order functions, explained in [chapter 19](kindle_split_034.xhtml#ch19))
    are a little harder to deal with. One thing you can do if a method takes a lambda
    as an argument is test its behavior with different lambdas. You can test the `filter`
    method that you created in [chapter 2](kindle_split_012.xhtml#ch02) with different
    predicates:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 接受函数作为参数或返回另一个函数的方法（所谓的高阶函数，在第19章中解释）处理起来稍微有些困难。如果方法接受lambda作为参数，你可以用不同的lambda来测试其行为。你可以用你在第2章中创建的`filter`方法来测试不同的谓词：
- en: '[PRE90]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: What if the method that needs to be tested returns another function? You can
    test the behavior of that function by treating it as an instance of a functional
    interface, as we showed you earlier with a `Comparator`.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要测试的方法返回另一个函数呢？你可以通过将其视为功能接口的实例来测试该函数的行为，就像我们之前用`Comparator`展示的那样。
- en: Unfortunately, not everything works the first time, and your tests may report
    some errors related to your use of lambda expressions. So, in the next section
    we turn to debugging.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，并非所有事情都能一帆风顺，你的测试可能会报告一些与lambda表达式使用相关的错误。因此，在下一节中，我们将转向调试。
- en: 9.4\. Debugging
  id: totrans-455
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.4. 调试
- en: 'A developer’s arsenal has two main old-school weapons for debugging problematic
    code:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者的工具箱中有两种主要的旧式武器用于调试有问题的代码：
- en: Examining the stack trace
  id: totrans-457
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查堆栈跟踪
- en: Logging
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录
- en: Lambda expressions and streams can bring new challenges to your typical debugging
    routine. We explore both in this section.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda表达式和流可以为你的典型调试流程带来新的挑战。我们将在本节中探讨这两个方面。
- en: 9.4.1\. Examining the stack trace
  id: totrans-460
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.4.1. 检查堆栈跟踪
- en: When your program has stopped (because an exception was thrown, for example),
    the first thing you need to know is where the program stopped and how it got there.
    Stack frames are useful for this purpose. Each time your program performs a method
    call, information about the call is generated, including the location of the call
    in your program, the arguments of the call, and the local variables of the method
    being called. This information is stored on a stack frame.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的程序停止（例如，抛出异常）时，你需要知道的第一件事是程序停止的位置以及它是如何到达那里的。堆栈帧对此很有用。每次你的程序执行方法调用时，都会生成有关调用的信息，包括调用在程序中的位置、调用的参数以及被调用方法的局部变量。这些信息存储在堆栈帧中。
- en: When your program fails, you get a *stack trace*, which is a summary of how
    your program got to that failure, stack frame by stack frame. In other words,
    you get a valuable list of method calls up to when the failure appeared. This
    list helps you understand how the problem occurred.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的程序失败时，你会得到一个*堆栈跟踪*，这是你的程序如何到达失败状态的总结，从堆栈帧到堆栈帧。换句话说，你得到了一个直到失败出现时的方法调用宝贵列表。这个列表有助于你理解问题是如何发生的。
- en: Using lambda expressions
  id: totrans-463
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 使用lambda表达式
- en: 'Unfortunately, due to the fact that lambda expressions don’t have names, stack
    traces can be slightly puzzling. Consider the following simple code, which is
    made to fail on purpose:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，由于lambda表达式没有名字，堆栈跟踪可能会有些令人困惑。考虑以下故意编写来失败的简单代码：
- en: '[PRE91]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Running this code produces a stack trace along the lines of the following (depending
    on your javac version; you may not have the same stack trace):'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码会产生类似于以下堆栈跟踪（取决于你的javac版本；你可能不会得到相同的堆栈跟踪）：
- en: '[PRE92]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '***1* What does $0 in this line mean?**'
  id: totrans-468
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 这行代码中的$0代表什么？**'
- en: 'Yuck! What’s going on? The program fails, of course, because the second element
    of the list of points is `null`. You try to process a `null` reference. Because
    the error occurs in a stream pipeline, the whole sequence of method calls that
    make a stream pipeline work is exposed to you. But notice that the stack trace
    produces the following cryptic lines:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀！发生了什么事？程序当然失败了，因为点的列表中的第二个元素是`null`。你试图处理一个`null`引用。由于错误发生在流管道中，使流管道工作的整个方法调用序列都暴露给你。但请注意，堆栈跟踪产生了以下神秘的行：
- en: '[PRE93]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: These lines mean that the error occurred inside a lambda expression. Unfortunately,
    because lambda expressions don’t have names, the compiler has to make up a name
    to refer to them. In this case, the name is `lambda$main$0`, which isn’t intuitive
    and can be problematic if you have large classes containing several lambda expressions.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 这些行意味着错误发生在lambda表达式内部。不幸的是，由于lambda表达式没有名字，编译器必须编造一个名字来引用它们。在这种情况下，名字是`lambda$main$0`，这并不直观，如果你有包含多个lambda表达式的长类，可能会出现问题。
- en: 'Even if you use method references, it’s still possible that the stack won’t
    show you the name of the method you used. Changing the preceding lambda `p ->
    p.getX()` to the method reference `Point::getX` also results in a problematic
    stack trace:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你使用了方法引用，仍然有可能堆栈不会显示你使用的方法名称。将前面的 lambda `p -> p.getX()` 改为方法引用 `Point::getX`
    也会导致问题堆栈跟踪：
- en: '[PRE94]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '***1* What does this line mean?**'
  id: totrans-474
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 这行代码是什么意思？**'
- en: 'Note that if a method reference refers to a method declared in the same class
    where it’s used, it appears in the stack trace. In the following example:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果方法引用引用的是在同一类中声明的同一方法，它将出现在堆栈跟踪中。在以下示例中：
- en: '[PRE95]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'The `divideByZero` method is reported correctly in the stack trace:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: '`divideByZero` 方法在堆栈跟踪中报告正确：'
- en: '[PRE96]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '***1* divideByZero appears in the stack trace.**'
  id: totrans-479
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* divideByZero 出现在堆栈跟踪中。**'
- en: In general, keep in mind that stack traces involving lambda expressions may
    be more difficult to understand. This area is one in which the compiler can be
    improved in a future version of Java.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，请记住，涉及 lambda 表达式的堆栈跟踪可能更难以理解。这是编译器在未来版本的 Java 中可以改进的一个领域。
- en: 9.4.2\. Logging information
  id: totrans-481
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.4.2\. 记录信息
- en: 'Suppose that you’re trying to debug a pipeline of operations in a stream. What
    can you do? You could use `forEach` to print or log the result of a stream as
    follows:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在尝试调试流操作管道。你能做什么？你可以使用 `forEach` 来打印或记录流的结果，如下所示：
- en: '[PRE97]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'This code produces the following output:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码产生以下输出：
- en: '[PRE98]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Unfortunately, after you call `forEach`, the whole stream is consumed. It would
    be useful to understand what each operation (`map`, `filter`, `limit`) produces
    in the pipeline of a stream.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，在调用 `forEach` 之后，整个流都被消费了。了解流管道中每个操作（`map`、`filter`、`limit`）产生的结果将是有用的。
- en: The stream operation `peek` can help. The purpose of `peek` is to execute an
    action on each element of a stream as it’s consumed. It doesn’t consume the whole
    stream the way `forEach` does, however; it forwards the element on which it performed
    an action to the next operation in the pipeline. [Figure 9.4](#ch09fig04) illustrates
    the `peek` operation.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 流操作 `peek` 可以帮助。`peek` 的目的是在流被消费时对每个元素执行一个动作。然而，它不会像 `forEach` 那样消费整个流；它将执行了动作的元素传递给管道中的下一个操作。[图
    9.4](#ch09fig04) 展示了 `peek` 操作。
- en: Figure 9.4\. Examining values flowing in a stream pipeline with `peek`
  id: totrans-488
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 9.4\. 使用 `peek` 检查流管道中流动的值
- en: '![](Images/09fig04_alt.jpg)'
  id: totrans-489
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/09fig04_alt.jpg)'
- en: 'In the following code, you use `peek` to print the intermediate values before
    and after each operation in the stream pipeline:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，你使用 `peek` 来打印流管道中每个操作前后的中间值：
- en: '[PRE99]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '***1* Print the current element consumed from the source**'
  id: totrans-492
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打印从源中消耗的当前元素**'
- en: '***2* Print the result of the map operation.**'
  id: totrans-493
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 打印映射操作的结果。**'
- en: '***3* Print the number selected after the filter operation.**'
  id: totrans-494
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 打印过滤操作后选定的数字。**'
- en: '***4* Print the number selected after the limit operation.**'
  id: totrans-495
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 打印限制操作后选定的数字。**'
- en: 'This code produces useful output at each step of the pipeline:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码在管道的每个步骤都产生有用的输出：
- en: '[PRE100]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: Summary
  id: totrans-498
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: Lambda expressions can make your code more readable and flexible.
  id: totrans-499
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lambda 表达式可以使你的代码更易读和灵活。
- en: Consider converting anonymous classes to lambda expressions, but be wary of
    subtle semantic differences such as the meaning of the keyword `this` and shadowing
    of variables.
  id: totrans-500
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑将匿名类转换为 lambda 表达式，但要注意关键字 `this` 的含义和变量遮蔽等细微的语义差异。
- en: Method references can make your code more readable compared with lambda expressions.
  id: totrans-501
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 lambda 表达式相比，方法引用可以使你的代码更易读。
- en: Consider converting iterative collection processing to use the Streams API.
  id: totrans-502
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑将迭代集合处理转换为使用 Streams API。
- en: Lambda expressions can remove boilerplate code associated with several object-oriented
    design patterns, such as strategy, template method, observer, chain of responsibility,
    and factory.
  id: totrans-503
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lambda 表达式可以移除与多个面向对象设计模式（如策略、模板方法、观察者、责任链、工厂）相关的样板代码。
- en: Lambda expressions can be unit-tested, but in general, you should focus on testing
    the behavior of the methods in which the lambda expressions appear.
  id: totrans-504
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lambda 表达式可以进行单元测试，但通常你应该关注测试 lambda 表达式出现的那些方法的行为了。
- en: Consider extracting complex lambda expressions into regular methods.
  id: totrans-505
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑将复杂的 lambda 表达式提取到常规方法中。
- en: Lambda expressions can make stack traces less readable.
  id: totrans-506
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Lambda 表达式可以使堆栈跟踪更难以阅读。
- en: The `peek` method of a stream is useful for logging intermediate values as they
    flow past certain points of a stream pipeline.
  id: totrans-507
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流的`peek`方法在将中间值作为它们流经流管道的某些点时进行日志记录很有用。
- en: Chapter 10\. Domain-specific languages using lambdas
  id: totrans-508
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第10章\. 使用lambda的领域特定语言
- en: '*This chapter covers*'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: What domain-specific languages (DSLs) and their forms are
  id: totrans-510
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哪些领域特定语言（DSLs）及其形式
- en: The pros and cons of adding a DSL to your API
  id: totrans-511
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在API中添加DSL的优缺点
- en: The alternatives available on the JVM to a plain Java-based DSL
  id: totrans-512
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在JVM上可用于普通Java DSL的替代方案
- en: Learning from the DSLs present in modern Java interfaces and classes
  id: totrans-513
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从现代Java接口和类中现有的DSL中学习
- en: Patterns and techniques to implement effective Java-based DSLs
  id: totrans-514
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现有效的基于Java的领域特定语言（DSL）的模式和技术
- en: How commonly used Java libraries and tools use these patterns
  id: totrans-515
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在常用的Java库和工具中使用这些模式
- en: Developers often forget that a programming language is first of all a language.
    The main purpose of any language is to convey a message in the clearest, most
    understandable way. Perhaps the most important characteristic of well-written
    software is clear communication of its intentions—or, as famous computer scientist
    Harold Abelson stated, “Programs must be written for people to read and only incidentally
    for machines to execute.”
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者常常忘记，编程语言首先是一种语言。任何语言的主要目的都是以最清晰、最易懂的方式传达信息。也许编写得好的软件最重要的特征就是清晰地传达其意图——正如著名计算机科学家Harold
    Abelson所说：“程序必须是为了让人阅读而编写的，而只是偶然地为了机器执行。”
- en: Readability and understandability are even more important in the parts of the
    software that are intended to model the core business of your application. Writing
    code that can be shared and understood by both the development team and the domain
    experts is helpful for productivity. Domain experts can be involved in the software
    development process and verify the correctness of the software from a business
    point of view. As a result, bugs and misunderstandings can be caught early on.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 可读性和可理解性在旨在模拟应用程序核心业务的软件部分中尤为重要。编写可以被开发团队和领域专家共享和理解代码有助于提高生产力。领域专家可以参与到软件开发过程中，并从业务角度验证软件的正确性。因此，可以尽早发现错误和误解。
- en: To achieve this result, it’s common to express the application’s business logic
    through a domain-specific language (DSL). A *DSL* is a small, usually non-general-purpose
    programming language explicitly tailored for a specific domain. The DSL uses the
    terminology characteristic of that domain. You may be familiar with Maven and
    Ant, for example. You can see them as DSLs for expressing build processes. You’re
    also familiar with HTML, which is a language tailored to define the structure
    of a web page. Historically, due to its rigidity and excessive verbosity, Java
    has never been popular for implementing a compact DSL that’s also suitable to
    be read by non-technical people. Now that Java supports lambda expressions, however,
    you have new tools in your toolbox! In fact, you learned in [chapter 3](kindle_split_013.xhtml#ch03)
    that lambda expressions help reduce code verbosity and improve the signal/noise
    ratio of your programs.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 为了达到这个结果，通常通过领域特定语言（DSL）来表述应用程序的业务逻辑。*DSL* 是一种小型的、通常非通用目的的编程语言，它专门针对特定领域进行定制。该DSL使用该领域的术语。例如，你可能熟悉Maven和Ant，你可以把它们看作是表述构建过程的DSL。你也熟悉HTML，这是一种专门用于定义网页结构的语言。从历史上看，由于它的僵化和过多的冗余，Java从未流行于实现一个既紧凑又适合非技术人士阅读的DSL。然而，现在Java支持lambda表达式，你就有新的工具在你的工具箱中！实际上，你在[第3章](kindle_split_013.xhtml#ch03)中了解到lambda表达式有助于减少代码冗余并提高程序的信噪比。
- en: 'Think about a database implemented in Java. Deep down in the database, there’s
    likely to be lots of elaborate code determining where on disk to store a given
    record, constructing indexes for tables, and dealing with concurrent transactions.
    This database is likely to be programmed by relatively expert programmers. Suppose
    that now you want to program a query similar to those we explored in [chapters
    4](kindle_split_015.xhtml#ch04) and [5](kindle_split_016.xhtml#ch05): “Find all
    menu entries on a given menu that have fewer than 400 calories.”'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个用Java实现的数据库。在数据库的底层，可能有很多复杂的代码来确定给定记录在磁盘上的存储位置，为表构建索引，以及处理并发事务。这个数据库可能是由相对有经验的程序员编写的。假设现在你想编写一个类似于我们在[第4章](kindle_split_015.xhtml#ch04)和[第5章](kindle_split_016.xhtml#ch05)中探索的查询：“找到给定菜单上所有少于400卡路里的菜单项。”
- en: 'Historically, such expert programmers might have quickly written low-level
    code in this style and thought that the task was easy:'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 从历史上看，这样的专家程序员可能会以这种方式快速编写低级代码，并认为任务很简单：
- en: '[PRE101]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'This solution has two main problems: it’s hard for a less-experienced programmer
    to create (it may need subtle details of locking, I/O, or disc allocation), and
    more important, it deals in system-level concepts, not application-level concepts.'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案有两个主要问题：一个是不太有经验的程序员很难创建（可能需要锁定、I/O或磁盘分配的微妙细节），更重要的是，它处理的是系统级概念，而不是应用级概念。
- en: A new-joining user-facing programmer might say, “Why can’t you provide me an
    SQL interface so I can write `SELECT name FROM menu WHERE calorie < 400`, where
    `menu` holds the restaurant menu expressed as an SQL table? Now I can program
    far more effectively than all this system-level nonsense!” It’s hard to argue
    with this statement! In essence the programmer has asked for a DSL to interact
    with the database instead of writing pure Java code. Technically, this type of
    DSL is called *external* because it expects the database to have an API that can
    parse and evaluate SQL expressions written in text. You learn more about the distinction
    between external and internal DSL later in this chapter.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 一个新加入的用户界面程序员可能会说：“为什么你们不能提供一个SQL接口，让我可以编写`SELECT name FROM menu WHERE calorie
    < 400`，其中`menu`包含以SQL表形式表达的餐厅菜单？现在我可以比所有这些系统级垃圾更有效地编程！” 这句话很难反驳！本质上，程序员要求使用DSL与数据库交互，而不是编写纯Java代码。从技术上讲，这种类型的DSL被称为*外部*，因为它期望数据库有一个API，可以解析和评估以文本形式编写的SQL表达式。你将在本章后面了解更多关于外部和内部DSL之间的区别。
- en: 'But if you think back to [chapters 4](kindle_split_015.xhtml#ch04) and [5](kindle_split_016.xhtml#ch05),
    you notice that this code could also be written more concisely in Java using the
    `Stream` API, such as the following:'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你回顾第[4章](kindle_split_015.xhtml#ch04)和第[5章](kindle_split_016.xhtml#ch05)，你会注意到这段代码也可以使用`Stream`
    API更简洁地编写，如下所示：
- en: '[PRE102]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: This use of chaining methods, which is so characteristic of the `Stream` API,
    is often called *fluent style* in that it’s easy to understand quickly, in contrast
    to complex control flow in Java loops.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 这种使用链式方法，这是`Stream` API的一个典型特征，通常被称为*流畅风格*，因为它易于快速理解，与Java循环中的复杂控制流形成对比。
- en: This style effectively captures a DSL. In this case, this DSL isn’t external,
    but internal. In an *internal* DSL, the application-level primitives are exposed
    as Java methods to use on one or more class types that represent the database,
    in contrast to the non-Java syntax for primitives in an external DSL, such as
    SELECT FROM in the SQL discussion above.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 这种风格有效地捕捉了DSL。在这种情况下，这个DSL不是外部的，而是内部的。在*内部* DSL中，应用级原语被暴露为Java方法，可以在表示数据库的一个或多个类类型上使用，这与外部DSL中原语的非Java语法形成对比，例如上面SQL讨论中的SELECT
    FROM。
- en: In essence, designing a DSL consists of deciding what operations the application-level
    programmer needs to manipulate (carefully avoiding any unnecessary pollution caused
    by system-level concepts) and providing these operations to the programmer.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，设计一个DSL包括决定应用级程序员需要执行哪些操作（仔细避免由系统级概念引起的任何不必要的污染），并向程序员提供这些操作。
- en: For an internal DSL, this process means exposing appropriate classes and methods
    so that code can be written fluently. An external DSL takes more effort; you must
    not only design the DSL syntax, but also implement a parser and evaluator for
    the DSL. If you get the design right, however, perhaps lower-skilled programmers
    can write code quickly and effectively (thus making the money that keeps your
    company in business) without having to program directly within your beautiful
    (but hard for non-experts to understand) system-level code!
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 对于内部领域特定语言（DSL），这个过程意味着暴露适当的类和方法，以便代码可以流畅地编写。外部DSL需要更多的努力；你不仅必须设计DSL的语法，还要为DSL实现一个解析器和评估器。然而，如果你设计得当，也许低技能的程序员可以快速有效地编写代码（从而为公司赚取维持运营的资金），而无需直接在您美丽（但非专家难以理解）的系统级代码中进行编程！
- en: In this chapter, you learn what a DSL is through several examples and use cases;
    you learn when you should consider implementing one and what the benefits are.
    Then you explore some of the small DSLs that were introduced in the Java 8 API.
    You also learn how you could employ the same patterns to create your own DSLs.
    Finally, you investigate how some widely used Java libraries and frameworks have
    adopted these techniques to offer their functionalities through a set of DSLs,
    making their APIs more accessible and easy to use.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将通过几个示例和用例了解什么是DSL；你将了解何时应该考虑实现一个，以及它的好处是什么。然后你将探索一些在Java 8 API中引入的小型DSL。你还了解如何使用相同的模式创建自己的DSL。最后，你将研究一些广泛使用的Java库和框架如何采用这些技术，通过一系列DSL提供其功能，使它们的API更易于访问和使用。
- en: 10.1\. A specific language for your domain
  id: totrans-531
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1. 为你的领域设计一种特定语言
- en: A DSL is a custom-built language designed to solve a problem for a specific
    business domain. You may be developing a software application for accounting,
    for example. Your business domain includes concepts such as bank statements and
    operations such as reconciling. You could create a custom DSL to express problems
    in that domain. In Java, you need to come up with a set of classes and methods
    to represent that domain. In a way, you can see the DSL as an API created to interface
    with a specific business domain.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: DSL（领域特定语言）是一种为解决特定商业领域问题而设计的定制语言。例如，你可能正在开发一个用于会计的软件应用程序。你的业务领域包括诸如银行对账单和诸如对账等操作。你可以创建一个定制的DSL来表示该领域的问题。在Java中，你需要想出一组类和方法来表示该领域。从某种意义上说，你可以将DSL视为创建用于与特定商业领域接口的API。
- en: A DSL isn’t a general-purpose programming language; it restricts the operations
    and vocabulary available to a specific domain, which means that you have less
    to worry about and can invest more attention in solving the business problem at
    hand. Your DSL should allow its users to deal only with the complexities of that
    domain. Other lower-level implementation details should be hidden – just like
    making lower-level implementation-detail methods of a class private. This results
    in a user-friendly DSL.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: DSL不是一种通用编程语言；它限制了特定领域可用的操作和词汇，这意味着你考虑的事情更少，可以更多地关注解决手头的业务问题。你的DSL应该允许其用户仅处理该领域的复杂性。其他更底层的实现细节应该被隐藏——就像将类的底层实现细节方法设为私有一样。这导致了一个用户友好的DSL。
- en: 'What isn’t a DSL? A DSL isn’t plain English. It’s also not a language that
    lets domain experts implement low-level business logic. Two reasons should drive
    you toward the development of a DSL:'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 什么不是DSL？DSL不是普通的英语。它也不是一种让领域专家实现低级业务逻辑的语言。有两个原因应该推动你朝着开发DSL的方向发展：
- en: '***Communication is king.*** Your code should clearly communicate its intentions
    and be understandable even by a non-programmer. This way, this person can contribute
    to validating whether the code matches the business requirements.'
  id: totrans-535
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**沟通是王道。**你的代码应该清楚地传达其意图，即使是非程序员也能理解。这样，这个人就可以贡献于验证代码是否符合业务需求。'
- en: '***Code is written once but read many times.*** Readability is vital for maintainability.
    In other words, you should always code in a way that your colleagues thank you
    for rather than hate you for!'
  id: totrans-536
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码一旦编写，就要多次阅读。**可读性对于可维护性至关重要。换句话说，你应该始终以你的同事会感谢你而不是恨你的方式编写代码！'
- en: A well-designed DSL offers many benefits. Nonetheless, developing and using
    a bespoke DSL has pros and cons. In [section 10.1.1](#ch10lev2sec1), we explore
    the pros and cons in more detail so that you can decide when a DSL is appropriate
    (or not) for a particular scenario.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 一个设计良好的DSL提供了许多好处。尽管如此，开发和使用定制的DSL既有优点也有缺点。在[第10.1.1节](#ch10lev2sec1)中，我们更详细地探讨了优缺点，以便你可以决定在特定场景下何时（或不）使用DSL。
- en: 10.1.1\. Pros and cons of DSLs
  id: totrans-538
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.1.1. DSL的优缺点
- en: DSLs, like other technologies and solutions in software development, aren’t
    silver bullets. Using a DSL to work with your domain can be both an asset and
    a liability. A DSL can be an asset because it raises the level of abstraction
    with which you can clarify the business intention of the code and makes the code
    more readable. But it can also be a liability because the implementation of the
    DSL is code in its own right that needs to be tested and maintained. For this
    reason, it’s useful to investigate the benefits and costs of DSLs so that you
    can evaluate whether adding one to your project will result in a positive return
    of investment.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: DSLs，就像软件开发中的其他技术和解决方案一样，并不是万能的。使用 DSL 与您的领域进行交互可以是资产也可以是负债。DSL 可以成为资产，因为它提高了您澄清代码业务意图的抽象级别，并使代码更易于阅读。但这也可能成为负债，因为
    DSL 的实现本身就是需要测试和维护的代码。因此，调查 DSL 的优势和成本是有用的，这样您就可以评估将 DSL 添加到您的项目中是否会带来积极的投资回报。
- en: 'DSLs offer the following benefits:'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: DSLs 提供以下优势：
- en: '***Conciseness*—** An API that conveniently encapsulates the business logic
    allows you to avoid repetition, resulting in code that’s less verbose.'
  id: totrans-541
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***简洁性***—**一个方便封装业务逻辑的 API 允许您避免重复，从而生成更简洁的代码。'
- en: '***Readability*—** Using words that belong to the vocabulary of the domain
    makes the code understandable even by domain non-experts. Consequently, code and
    domain knowledge can be shared across a wider range of members of the organization.'
  id: totrans-542
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***可读性***—**使用属于领域词汇表中的词汇可以使代码即使对领域非专家来说也是可理解的。因此，代码和领域知识可以在组织更广泛的成员之间共享。'
- en: '***Maintainability*—** Code written against a well-designed DSL is easier to
    maintain and modify. Maintainability is especially important for business-related
    code, which is the part of the application that may change most frequently.'
  id: totrans-543
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***可维护性***—**针对良好设计的 DSL 编写的代码更容易维护和修改。对于业务相关的代码，可维护性尤为重要，因为这部分应用程序可能变化最为频繁。'
- en: '***Higher level of abstraction*—** The operations available in a DSL work at
    the same level of abstraction as the domain, thus hiding the details that aren’t
    strictly related to the domain’s problems.'
  id: totrans-544
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***更高的抽象级别***—**DSL 中可用的操作与领域处于相同的抽象级别，从而隐藏了与领域问题严格无关的细节。'
- en: '***Focus*—** Having a language designed for the sole purpose of expressing
    the rules of the business domain helps programmers stay focused on that specific
    part of the code. The result is increased productivity.'
  id: totrans-545
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***专注度***—**为表达业务领域规则而设计的语言有助于程序员专注于代码的特定部分。结果是生产力的提高。'
- en: '***Separation of concerns*—** Expressing the business logic in a dedicated
    language makes it easier to keep the business-related code isolated from the infrastructural
    part of the application. The result is code that’s easier to maintain.'
  id: totrans-546
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***关注点分离***—**在专用语言中表达业务逻辑使将业务相关的代码与应用程序的基础设施部分隔离开来变得更容易。结果是代码更容易维护。'
- en: 'Conversely, introducing a DSL into your code base can have a few disadvantages:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，将 DSL 引入您的代码库可能会带来一些不利因素：
- en: '***Difficulty of DSL design*—** It’s hard to capture domain knowledge in a
    concise limited language.'
  id: totrans-548
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***DSL 设计的难度***—**在简洁有限的语境内捕捉领域知识是有难度的。'
- en: '***Development cost*—** Adding a DSL to your code base is a long-term investment
    with a high up-front cost, which could delay your project in its early stages.
    In addition, the maintenance of the DSL and its evolution add further engineering
    overhead.'
  id: totrans-549
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***开发成本***—**将 DSL 添加到您的代码库是一项长期投资，前期成本较高，可能会在项目早期阶段延迟您的项目。此外，DSL 的维护及其演变还会增加额外的工程开销。'
- en: '***Additional indirection layer*—** A DSL wraps your domain model in an additional
    layer that has to be as thin as possible to avoid incurring performance problems-.'
  id: totrans-550
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***额外的间接层***—**DSL 在尽可能薄的一层中封装了您的领域模型，以避免引入性能问题。'
- en: '***Another language to learn*—** Nowadays, developers are used to employing
    multiple languages. Adding a DSL to your project, however, implicitly implies
    that you and your team have one more language to learn. Worse, if you decide to
    have multiple DSLs covering different areas of your business domain, combining
    them in a seamless way could be hard, because DSLs tend to evolve independently.'
  id: totrans-551
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***另一种需要学习的技术***—**如今，开发者习惯于使用多种语言。然而，将 DSL 添加到您的项目中，却隐含着您和您的团队需要学习一门新的语言。更糟糕的是，如果您决定拥有多个覆盖您业务领域不同领域的
    DSL，将它们无缝结合可能会很困难，因为 DSL 倾向于独立演变。'
- en: '***Hosting-language limitations*—** Some general-purpose programming languages
    (Java is one of them) are known for being verbose and having rigid syntax. These
    languages make it difficult to design a user-friendly DSL. In fact, DSLs developed
    on top of a verbose programming language are constrained by the cumbersome syntax
    and may not be nice to read. The introduction of lambda expression in Java 8 offers
    a powerful new tool to mitigate this problem.'
  id: totrans-552
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**宿主语言限制**—**一些通用编程语言（Java就是其中之一）因其冗长和语法严格而闻名。这些语言使得设计用户友好的DSL变得困难。事实上，在冗长编程语言之上开发的DSL受到繁琐语法的限制，可能不易阅读。Java
    8中lambda表达式的引入为缓解这个问题提供了一个强大的新工具。'
- en: Given these lists of positive and negative arguments, deciding whether to develop
    a DSL for your project isn’t easy. Moreover, you have alternatives to Java for
    implementing your own DSL. Before investigating which patterns and strategies
    you could employ to develop a readable easy-to-use DSL in Java 8 and beyond, we
    quickly explore these alternatives and describe the circumstances under which
    they could be appropriate solutions.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这些正负参数列表，决定是否为你的项目开发领域特定语言（DSL）并不容易。此外，你还有Java以外的其他选择来实现自己的DSL。在调查你可以采用哪些模式和策略来在Java
    8及更高版本中开发易于阅读和使用的DSL之前，我们快速探索这些替代方案，并描述它们可能成为适当解决方案的情况。
- en: 10.1.2\. Different DSL solutions available on the JVM
  id: totrans-554
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.1.2\. JVM上可用的不同DSL解决方案
- en: In this section, you learn the categories of DSLs. You also learn that you have
    many choices besides Java for implementing DSLs. In later sections, we focus on
    how to implement DSLs by using Java features.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习DSL的分类。你还将了解到，除了Java之外，你还有许多选择来实现DSL。在后面的章节中，我们将重点介绍如何使用Java特性来实现DSL。
- en: The most common way to categorize DSLs, introduced by Martin Fowler, is to distinguish
    between internal and external DSLs. Internal DSLs (also known as embedded DSLs)
    are implemented on top of the existing hosting language (which could be plain
    Java code), whereas external DSLs are called stand-alone because they’re developed
    from scratch with a syntax that’s independent of the hosting language.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的DSL分类方法是由Martin Fowler提出的，即区分内部和外部DSL。内部DSL（也称为嵌入式DSL）是在现有宿主语言（可能是纯Java代码）之上实现的，而外部DSL被称为独立型，因为它们是从零开始开发的，语法独立于宿主语言。
- en: 'Moreover, the JVM gives you a third possibility that falls between an internal
    and an external DSL: another general-purpose programming language that also runs
    on the JVM but is more flexible and expressive than Java, such as Scala or Groovy.
    We refer to this third alternative as a polyglot DSL.'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，JVM为你提供了一个介于内部和外部DSL之间的第三种可能性：另一种在JVM上运行但比Java更灵活、更丰富的通用编程语言，例如Scala或Groovy。我们将这种第三种替代方案称为多语言DSL。
- en: In the following sections, we look at these three types of DSLs in order.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将按顺序查看这三种类型的DSL。
- en: Internal DSL
  id: totrans-559
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 内部领域特定语言（Internal DSL）
- en: 'Because this book is about Java, when we speak about an internal DSL, we clearly
    mean a DSL written in Java. Historically, Java hasn’t been considered to be a
    DSL-friendly language because its cumbersome, inflexible syntax makes it difficult
    to produce an easy-to-read, concise, expressive DSL. This issue has been largely
    mitigated by the introduction of lambda expressions. As you saw in [chapter 3](kindle_split_013.xhtml#ch03),
    lambdas are useful for using behavior parameterization in a concise manner. In
    fact, using lambdas extensively results in a DSL with a more acceptable signal/noise
    ratio by reducing the verbosity that you get with anonymous inner classes. To
    demonstrate the signal/noise ratio, try to print a list of `String`s with Java
    7 syntax, but use Java 8’s new `forEach` method:'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这本书是关于Java的，当我们提到内部DSL时，我们明确指的是用Java编写的DSL。从历史上看，Java并不被认为是一种适合DSL的语言，因为其繁琐、不灵活的语法使得编写易于阅读、简洁、表达丰富的DSL变得困难。lambda表达式的引入在很大程度上缓解了这个问题。正如你在[第3章](kindle_split_013.xhtml#ch03)中看到的，lambda表达式以简洁的方式用于行为参数化。实际上，广泛使用lambda表达式会导致具有更可接受的信号/噪声比的DSL，因为它减少了与匿名内部类相关的冗长性。为了演示信号/噪声比，尝试使用Java
    7语法打印一个`String`列表，但使用Java 8的新`forEach`方法：
- en: '[PRE103]'
  id: totrans-561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: In this snippet, the part that is bold is carrying the signal of the code. All
    the remaining code is syntactic noise that provides no additional benefit and
    (even better) is no longer necessary in Java 8\. The anonymous inner class can
    be replaced by the lambda expression
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个片段中，粗体的部分承载着代码的信号。所有剩余的代码都是语法噪声，它不会提供额外的益处，而且在 Java 8 中，这些代码甚至不再是必要的。匿名内部类可以被
    lambda 表达式替换。
- en: '[PRE104]'
  id: totrans-563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'or even more concisely by a method reference:'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，可以通过方法引用来更加简洁地实现：
- en: '[PRE105]'
  id: totrans-565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'You may be happy to build your DSL with Java when you expect users to be somewhat
    technically minded. If the Java syntax isn’t an issue, choosing to develop your
    DSL in plain Java has many advantages:'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 当你预期用户具有一定的技术背景时，你可能会很高兴用 Java 来构建你的 DSL。如果 Java 语法不是问题，选择在纯 Java 中开发你的 DSL
    有许多优点：
- en: The effort of learning the patterns and techniques necessary to implement a
    good Java DSL is modest compared with the effort required to learn a new programming
    language and the tools normally used to develop an external DSL.
  id: totrans-567
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与学习新的编程语言及其通常用于开发外部 DSL 的工具相比，学习实现良好的 Java DSL 所需的模式和技术所付出的努力是微不足道的。
- en: Your DSL is written in plain Java, so it’s compiled with the rest of your code.
    There’s no additional building cost caused by the integration of a second language
    compiler or of the tool employed to generate the external DSL.
  id: totrans-568
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的 DSL 是用纯 Java 编写的，所以它与你的其他代码一起编译。由于集成了第二语言编译器或用于生成外部 DSL 的工具，不会产生额外的构建成本。
- en: Your development team won’t need to get familiar with a different language or
    with a potentially unfamiliar and complex external tool.
  id: totrans-569
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的开发团队不需要熟悉不同的语言或可能不熟悉且复杂的第三方工具。
- en: The users of your DSL will have all the features normally provided by your favorite
    Java IDE, such as autocompletion and refactoring facilities. Modern IDEs are improving
    their support for other popular JVM languages, but still don’t have support comparable
    to what they offer Java developers.
  id: totrans-570
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的 DSL 用户将拥有你最喜欢的 Java 集成开发环境（IDE）通常提供的所有功能，例如自动完成和重构功能。现代 IDE 正在提高对其他流行 JVM
    语言的兼容性，但仍然没有提供与为 Java 开发者提供的服务相当的支持。
- en: If you need to implement more than one DSL to cover various parts of your domain
    or multiple domains, you won’t have any problem composing them if they’re written
    in plain Java.
  id: totrans-571
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你需要实现多个 DSL 来覆盖你的领域或多个领域，只要它们是用纯 Java 编写的，你就不必担心它们之间的组合问题。
- en: Another possibility is combining DSLs that use the same Java bytecode by combining
    JVM-based programming languages. We call these DSLs polyglot and describe them
    in the next section.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种可能性是通过结合基于 JVM 的编程语言来组合使用相同 Java 字节码的 DSL。我们称这些 DSL 为多语言 DSL，并在下一节中对其进行描述。
- en: Polyglot DSL
  id: totrans-573
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 多语言 DSL
- en: Nowadays, probably more than 100 languages run on the JVM. Some of these languages,
    such as Scala and Groovy, are quite popular, and it isn’t difficult to find developers
    who are skilled in them. Other languages, including JRuby and Jython, are ports
    of other well-known programming languages to the JVM. Finally, other emerging
    languages, such as Kotlin and Ceylon, are gaining traction mostly because they
    claim to have features comparable with those of Scala, but with lower intrinsic
    complexity and a gentle learning curve. All these languages are younger than Java
    and have been designed with less-constrained, less-verbose syntax. This characteristic
    is important because it helps implement a DSL that has less inherent verbosity
    due to the programming language in which it’s embedded.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，可能超过 100 种语言在 JVM 上运行。其中一些语言，如 Scala 和 Groovy，相当流行，而且并不难找到精通它们的开发者。其他语言，包括
    JRuby 和 Jython，是将其他知名编程语言移植到 JVM 上的。最后，其他新兴语言，如 Kotlin 和 Ceylon，正在获得越来越多的关注，主要是因为它们声称具有与
    Scala 相当的特性，但具有更低的内在复杂性和更平缓的学习曲线。所有这些语言都比 Java 年轻，并且设计时采用了更宽松、更简洁的语法。这一特性很重要，因为它有助于实现一个由于嵌入的编程语言而具有较少固有冗余的
    DSL。
- en: Scala in particular has several features, such as currying and implicit conversion,
    that are convenient in developing a DSL. You get an overview of Scala and how
    it compares to Java in [chapter 20](kindle_split_035.xhtml#ch20). For now, we
    want to give you a feeling for what you can do with these features by giving you
    a small example.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 特别地，Scala 几乎有几个特性，如柯里化和隐式转换，这些特性在开发领域特定语言（DSL）时非常方便。你可以在第 20 章 [chapter 20](kindle_split_035.xhtml#ch20)
    中了解 Scala 的概述以及它与 Java 的比较。目前，我们希望通过一个小的示例让你对使用这些特性能做什么有一个感觉。
- en: Suppose that you want to build a utility function that repeats the execution
    of another function, `f`, a given number of times. As a first attempt, you could
    end up with the following recursive implementation in Scala. (Don’t worry about
    the syntax; the overall idea is what’s important.)
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想要构建一个重复执行另一个函数`f`的给定次数的实用函数。作为一个初步尝试，你可能会在Scala中得到以下递归实现。（不要担心语法；整体思路才是重要的。）
- en: '[PRE106]'
  id: totrans-577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '***1* Execute the f function.**'
  id: totrans-578
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**1** 执行`f`函数。'
- en: '***2* If the counter i is positive, decrement it and recursively invoke the
    times function.**'
  id: totrans-579
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**2** 如果计数器`i`是正数，则递减它并递归调用`times`函数。'
- en: 'Note that in Scala, invoking this function with large values of `i` won’t cause
    a stack overflow, as would happen in Java, because Scala has the tail call optimization,
    which means that the recursive invocation to the `times` function won’t be added
    to the stack. You learn more about this topic in [chapters 18](kindle_split_033.xhtml#ch18)
    and [19](kindle_split_034.xhtml#ch19). You can use this function to execute another
    function repeatedly (one that prints `"Hello World"` three times) as follows:'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在Scala中，使用大的`i`值调用此函数不会导致栈溢出，这就像在Java中发生的那样，因为Scala有尾调用优化，这意味着对`times`函数的递归调用不会被添加到栈中。你可以在第[18章](kindle_split_033.xhtml#ch18)和第[19章](kindle_split_034.xhtml#ch19)中了解更多关于这个主题的内容。你可以使用这个函数重复执行另一个函数（例如打印
    `"Hello World"` 三次），如下所示：
- en: '[PRE107]'
  id: totrans-581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: If you curry the `times` function, or put its arguments in two groups (we cover
    currying in detail in [chapter 19](kindle_split_034.xhtml#ch19)),
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将`times`函数进行柯里化，或者将其参数分成两组（我们将在第[19章](kindle_split_034.xhtml#ch19)中详细讨论柯里化），
- en: '[PRE108]'
  id: totrans-583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'you can achieve the same result by passing the function to be executed multiple
    times in curly braces:'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在花括号中多次传递要执行的函数来达到相同的结果：
- en: '[PRE109]'
  id: totrans-585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: Finally, in Scala you can define an implicit conversion from an `Int` to an
    anonymous class by having only one function that in turn has as argument the function
    to be repeated. Again, don’t worry about the syntax and details. The objective
    of this example is to give you an idea of what’s possible beyond Java.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在Scala中，你可以通过只有一个函数将`Int`转换为匿名类，该函数将重复执行的函数作为参数。再次提醒，不要担心语法和细节。这个示例的目的是给你一个关于超越Java可能性的想法。
- en: '[PRE110]'
  id: totrans-587
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '***1* Defines an implicit conversion from an Int to an anonymous class**'
  id: totrans-588
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**1** 定义了一个从Int到匿名类的隐式转换。'
- en: '***2* The class has only a times function accepting another function f as argument.**'
  id: totrans-589
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**2** 该类只有一个接受另一个函数`f`作为参数的`times`函数。'
- en: '***3* A second times function takes two arguments and is defined in the scope
    of the first one.**'
  id: totrans-590
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**3** 一个接受两个参数的二次函数在第一个函数的作用域内定义。'
- en: '***4* Invokes the inner times function**'
  id: totrans-591
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**4** 调用内部`times`函数。'
- en: 'In this way the user of your small Scala-embedded DSL can execute a function
    that prints `"Hello World"` three times as follows:'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式，你的小型Scala嵌入式DSL的用户可以执行一个打印 `"Hello World"` 三次的函数，如下所示：
- en: '[PRE111]'
  id: totrans-593
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: As you can see, the result has no syntactic noise, and it’s easily understandable
    even by a non-developer. Here, the number `3` is automatically converted by the
    compiler in an instance of a class that stores the number in its `i` field. Then
    the `times` function is invoked with dotless notation, taking as an argument the
    function to be repeated.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，结果没有语法噪音，即使是非开发者也能轻松理解。在这里，数字`3`被编译器自动转换为存储在`i`字段中的类的实例。然后使用无点表示法调用`times`函数，将重复的函数作为参数。
- en: 'Obtaining a similar result in Java is impossible, so the advantages of using
    a more DSL-friendly language are obvious. This choice also has some clear inconveniences,
    however:'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中无法获得类似的结果，因此使用更适合DSL的语言的优势是显而易见的。然而，这个选择也有一些明显的不便：
- en: You have to learn a new programming language or have somebody on your team who’s
    already skilled in it. Because developing a nice DSL in these languages generally
    requires the use of relatively advanced features, superficial knowledge of the
    new language normally isn’t enough.
  id: totrans-596
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你必须学习一门新的编程语言，或者你的团队中必须有已经掌握这门语言的人。因为这些语言中构建良好的DSL通常需要使用相对高级的功能，对新语言的肤浅了解通常是不够的。
- en: You need to complicate your build process a bit by integrating multiple compilers
    to build the source written with two or more languages.
  id: totrans-597
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你需要通过集成多个编译器来复杂化你的构建过程，以构建用两种或更多语言编写的源代码。
- en: Finally, although the majority of languages running on the JVM claim to be 100
    percent Java-compatible, making them interoperate with Java often requires awkward
    tricks and compromises. Also, this interoperation sometimes causes a performance
    loss. Scala and Java collections aren’t compatible, for example, so when a Scala
    collection has to be passed to a Java function or vice versa, the original collection
    has to be converted to one that belongs to the native API of the target language.
  id: totrans-598
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，尽管在JVM上运行的多数语言都声称与100%的Java兼容，但与Java进行互操作通常需要尴尬的技巧和妥协。此外，这种互操作有时会导致性能损失。例如，Scala和Java集合不兼容，所以当一个Scala集合需要传递给Java函数或反之亦然时，原始集合必须转换为目标语言原生API中的一个集合。
- en: External DSL
  id: totrans-599
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 外部DSL
- en: The third option for adding a DSL to your project is implementing an external
    one. In this case, you have to design a new language from the ground up, with
    its own syntax and semantics. You also need to set up a separate infrastructure
    to parse the new language, analyze the output of the parser, and generate the
    code to execute your external DSL. This is a lot of work! The skills required
    to perform these tasks are neither common nor easy to acquire. If you do want
    to go down this road, ANTLR is a parser generator that’s commonly used to help
    and that goes hand in hand with Java.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 将DSL添加到你的项目的第三种选择是实现一个外部DSL。在这种情况下，你必须从头开始设计一种新的语言，包括其自己的语法和语义。你还需要设置一个单独的基础设施来解析新语言，分析解析器的输出，并生成执行外部DSL的代码。这是一项大量工作！执行这些任务所需的技能既不常见也不容易获得。如果你确实想走这条路，ANTLR是一个常用的解析器生成器，它可以帮助你，并且与Java紧密配合。
- en: Moreover, even designing a coherent programming language from scratch isn’t
    a trivial task. Another common problem is that it’s easy for an external DSL to
    grow out of control and to cover areas and purposes for which it wasn’t designed.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，即使从头开始设计一个连贯的编程语言也不是一个简单任务。另一个常见问题是外部DSL很容易失控，并覆盖它未设计用于的领域和目的。
- en: The biggest advantage in developing an external DSL is the practically unlimited
    degree of flexibility that it provides. It’s possible for you to design a language
    that perfectly fits the needs and peculiarities of your domain. If you do a good
    job, the result is an extremely readable language specifically tailored to describe
    and solve the problems of your business. The other positive outcome is the clear
    separation between the infrastructural code developed in Java and the business
    code written with the external DSL. This separation is a double-edged sword, however,
    because it also creates an artificial layer between the DSL and the host language.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发外部领域特定语言（DSL）中最大的优势是它提供的几乎无限的灵活性。你可以设计一种语言，使其完美地满足你领域的需求和特殊性。如果你做得好，结果将是一种极其易读的语言，专门用于描述和解决你业务中的问题。另一个积极的结果是，在Java中开发的底层代码与使用外部DSL编写的业务代码之间的清晰分离。然而，这种分离是一把双刃剑，因为它也在DSL和宿主语言之间创建了一个人工层。
- en: In the remainder of this chapter, you learn about patterns and techniques that
    can help you develop effective modern-Java-based internal DSLs. You start by exploring
    how these ideas have been used in the design of the native Java API, especially
    the API additions in Java 8 and beyond.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的剩余部分，你将了解可以帮助你开发有效的基于现代Java的内部DSL的模式和技术。你首先将探索这些想法是如何被用于原生Java API的设计中的，特别是Java
    8及其以后的API新增功能。
- en: 10.2\. Small DSLs in modern Java APIs
  id: totrans-604
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2. 现代Java API中的小型DSL
- en: The first APIs to take advantage of the new functional capabilities of Java
    are the native Java APIs themselves. Before Java 8, the native Java API already
    had a few interfaces with a single abstract method, but as you saw in [section
    10.1](#ch10lev1sec1), their use required the implementation of an anonymous inner
    class with a bulky syntax. The addition of lambdas and (maybe even more important
    from a DSL point of view) method references changed the rules of the game, making
    functional interfaces a cornerstone of Java API design.
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 首先利用Java新功能特性的API是原生Java API本身。在Java 8之前，原生Java API已经有一些只有一个抽象方法的接口，但正如你在[第10.1节](#ch10lev1sec1)中看到的，它们的使用需要实现一个具有庞大语法的匿名内部类。lambda表达式和（也许从DSL的角度来看甚至更重要）方法引用的添加改变了游戏规则，使功能接口成为Java
    API设计的基础。
- en: The `Comparator` interface in Java 8 has been updated with new methods. You
    learn in [chapter 13](kindle_split_026.xhtml#ch13) that an interface can include
    both static method and default methods. For now, the `Comparator` interface serves
    as a good example of how lambdas improve the reusability and composability of
    methods in native Java API.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: Java 8 中的 `Comparator` 接口已经添加了新的方法。你在[第 13 章](kindle_split_026.xhtml#ch13)中了解到，一个接口可以包含静态方法和默认方法。目前，`Comparator`
    接口是一个很好的例子，展示了 lambda 如何提高原生 Java API 中方法的复用性和可组合性。
- en: 'Suppose that you have a list of objects representing people (`Person`s), and
    you want to sort these objects based on the people’s ages. Before lambdas, you
    had to implement the `Comparator` interface by using an inner class:'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个代表人员的对象列表（`Person` 对象），并且你想根据人员的年龄对这些对象进行排序。在 lambda 之前，你必须通过内部类实现 `Comparator`
    接口：
- en: '[PRE112]'
  id: totrans-608
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'As you’ve seen in many other examples in this book, now you can replace the
    inner class with a more compact lambda expression:'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在本书的许多其他示例中看到的，现在你可以用更紧凑的 lambda 表达式替换内部类：
- en: '[PRE113]'
  id: totrans-610
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'This technique greatly increases the signal/noise ratio of your code. Java,
    however, also has a set of static utility methods that let you create `Comparator`
    objects in a more readable manner. These static methods are included in the `Comparator`
    interface. By statically importing the `Comparator.comparing` method, you can
    rewrite the preceding sorting example as follows:'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术大大提高了代码的信号/噪声比。然而，Java 也有一系列静态实用方法，允许你以更可读的方式创建 `Comparator` 对象。这些静态方法包含在
    `Comparator` 接口中。通过静态导入 `Comparator.comparing` 方法，你可以将前面的排序示例重写如下：
- en: '[PRE114]'
  id: totrans-612
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Even better, you can replace the lambda with a method reference:'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的是，你可以用方法引用替换 lambda：
- en: '[PRE115]'
  id: totrans-614
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'The benefit of this approach can be pushed even further. If you want to sort
    the people by age, but in reverse order, you can exploit the instance method `reverse`
    (also added in Java 8):'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的优点可以进一步发挥。如果你想按年龄对人员进行排序，但顺序相反，你可以利用添加在 Java 8 中的实例方法 `reverse`：
- en: '[PRE116]'
  id: totrans-616
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Moreover, if you want the people of the same age to be sorted alphabetically,
    you can compose that `Comparator` with one that performs the comparison on the
    names:'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果你想按字母顺序对同龄人进行排序，你可以将这个 `Comparator` 与一个基于名称进行比对的 `Comparator` 组合起来：
- en: '[PRE117]'
  id: totrans-618
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'Finally, you could use the new `sort` method added on the `List` interface
    to tidy things further:'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以使用在 `List` 接口中添加的新 `sort` 方法来进一步整理：
- en: '[PRE118]'
  id: totrans-620
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: This small API is a minimal DSL for the domain of collection sorting. Despite
    its limited scope, this DSL already shows you how a well-designed use of lambdas
    and method reference can improve the readability, reusability, and composability
    of your code.
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 这个小的 API 是集合排序领域的最小 DSL。尽管其范围有限，但这个 DSL 已经展示了如何通过精心设计的 lambda 和方法引用来提高代码的可读性、复用性和可组合性。
- en: 'In the next section, we explore a richer and more widely used Java 8 class
    in which the readability improvement is even more evident: the `Stream` API.'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨一个更丰富、更广泛使用的 Java 8 类，其中可读性的提升更为明显：`Stream` API。
- en: 10.2.1\. The Stream API seen as a DSL to manipulate collections
  id: totrans-623
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.2.1\. 将 Stream API 视为操作集合的 DSL
- en: The `Stream` interface is a great example of a small internal DSL introduced
    into the native Java API. In fact, a `Stream` can be seen as a compact but powerful
    DSL that filters, sorts, transforms, groups, and manipulates the items of a collection.
    Suppose that you’re required to read a log file and collect the first 40 lines,
    starting with the word `"ERROR"` in a `List<String>`. You could perform this task
    in an imperative style, as shown in the following listing.
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: '`Stream` 接口是原生 Java API 中引入的小型内部 DSL 的一个很好的例子。实际上，`Stream` 可以被视为一个紧凑但强大的 DSL，它可以过滤、排序、转换、分组和操作集合中的项。假设你需要读取一个日志文件并收集以
    `"ERROR"` 开头的前 40 行，你可以按照以下列表所示以命令式方式执行此任务。'
- en: Listing 10.1\. Reading the error lines in a log file in imperative style
  id: totrans-625
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.1\. 以命令式方式读取日志文件中的错误行
- en: '[PRE119]'
  id: totrans-626
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'Here, we omitted the error-handling part of the code for brevity. Despite this
    fact, the code is excessively verbose, and its intention isn’t immediately evident.
    The other aspect that harms both readability and maintainability is the lack of
    a clear separation of concerns. In fact, the code with the same responsibility
    is scattered across multiple statements. The code used to read the file line by
    line, for example, is located in three places:'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，为了简洁，我们省略了错误处理部分的代码。尽管如此，代码过于冗长，其意图并不立即明显。损害可读性和可维护性的另一个方面是缺乏清晰的关注点分离。实际上，具有相同职责的代码散布在多个语句中。例如，用于逐行读取文件的代码位于三个地方：
- en: Where the `FileReader` is created
  id: totrans-628
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FileReader`创建的位置'
- en: The second condition of the `while` loop, which checks whether the file has
    terminated
  id: totrans-629
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`while`循环的第二个条件，用于检查文件是否已终止'
- en: The end of the `while` loop itself that reads the next line in the file
  id: totrans-630
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`while`循环的末尾本身读取文件中的下一行'
- en: 'Similarly, the code that limits the number of lines collected in the list to
    the first 40 results is scattered across three statements:'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，将收集到的行数限制在列表中的前40行的代码也散布在三个语句中：
- en: The one initializing the variable `errorCount`
  id: totrans-632
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化变量`errorCount`的操作
- en: The first condition of the `while` loop
  id: totrans-633
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`while`循环的第一个条件'
- en: The statement incrementing the counter when a line starting with `"ERROR"` is
    found in the log
  id: totrans-634
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当在日志中找到以`"ERROR"`开头的行时增加计数器的语句
- en: Achieving the same result in a more functional style through the `Stream` interface
    is much easier and results in far more compact code, as shown in [listing 10.2](#ch10ex02).
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`Stream`接口以更函数式的方式实现相同的结果要容易得多，并且代码更加紧凑，如[列表10.2](#ch10ex02)所示。
- en: Listing 10.2\. Reading the error lines in a log file in functional style
  id: totrans-636
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.2\. 以函数式风格读取日志文件中的错误行
- en: '[PRE120]'
  id: totrans-637
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '***1* Opens the file and creates a Stream of Strings where each String corresponds
    to a line in the file.**'
  id: totrans-638
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 打开文件并创建一个字符串流，其中每个字符串对应文件中的一行。**'
- en: '***2* Filters the line starting with “ERROR”.**'
  id: totrans-639
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 过滤以“ERROR”开头的行。**'
- en: '***3* Limits the result to the first 40 lines.**'
  id: totrans-640
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 限制结果只显示前40行。**'
- en: '***4* Collects the resulting Strings in a List.**'
  id: totrans-641
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 将结果字符串收集到列表中。**'
- en: '`Files.lines` is a static utility method that returns a `Stream<String>` where
    each `String` represents a line in the file to be parsed. That part of the code
    is the only part that has to read the file line by line. In the same way, the
    statement `limit(40)` is enough to limit the number of collected error lines to
    the first 40\. Can you imagine something more obviously readable?'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: '`Files.lines`是一个静态实用方法，它返回一个`Stream<String>`，其中每个`String`代表要解析的文件中的一行。这部分代码是唯一需要逐行读取文件的代码。同样，`limit(40)`语句就足以将收集的错误行数限制在前40行。你能想象出更易于阅读的吗？'
- en: The fluent style of the `Stream` API is another interesting aspect that’s typical
    of a well-designed DSL. All intermediate operations are lazy and return another
    `Stream` allowing a sequence of operations to be pipelined. The terminal operation
    is eager and triggers the computation of the result of the whole pipeline.
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: '`Stream` API流畅的风格是另一个有趣的特点，这是良好设计的领域特定语言（DSL）的典型特征。所有中间操作都是懒加载的，并返回另一个`Stream`，允许一系列操作被管道化。终端操作是急切的，并触发整个管道的计算结果。'
- en: 'It’s time to investigate the APIs of another small DSL designed to be used
    in conjunction with the `collect` method of the `Stream` interface: the `Collectors`
    API.'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候调查另一个小型DSL的API了，该DSL旨在与`Stream`接口的`collect`方法一起使用：`Collectors` API。
- en: 10.2.2\. Collectors as a DSL to aggregate data
  id: totrans-645
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.2.2\. 将收集器作为聚合数据的DSL
- en: 'You saw that the `Stream` interface can be viewed as a DSL that manipulates
    lists of data. Similarly, the `Collector` interface can be viewed as a DSL that
    performs aggregation on data. In [chapter 6](kindle_split_017.xhtml#ch06), we
    explored the `Collector` interface and explained how to use it to collect, to
    group, and to partition the items in a `Stream`. We also investigated the static
    factory methods provided by the `Collectors` class to conveniently create different
    flavors of `Collector` objects and combine them. It’s time to review how these
    methods are designed from a DSL point of view. In particular, as the methods in
    the `Comparator` interface can be combined to support multifield sorting, `Collector`s
    can be combined to achieve multilevel grouping. You can group a list of cars,
    for example, first by their brand and then by their color as follows:'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经看到`Stream`接口可以被视为一个操作数据列表的DSL。同样，`Collector`接口可以被视为一个对数据进行聚合操作的DSL。在第6章中，我们探讨了`Collector`接口，并解释了如何使用它来收集、分组和分区`Stream`中的项目。我们还研究了`Collectors`类提供的静态工厂方法，以方便地创建不同类型的`Collector`对象并将它们组合起来。现在是时候回顾这些方法是如何从DSL的角度来设计的了。特别是，由于`Comparator`接口中的方法可以组合起来以支持多字段排序，`Collector`也可以组合起来实现多级分组。例如，您可以首先按品牌然后按颜色对汽车列表进行分组，如下所示：
- en: '[PRE121]'
  id: totrans-647
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: What do you notice here compared with what you did to concatenate two `Comparator`s?
    You defined the multifield `Comparator` by composing two `Comparator`s in a fluent
    way,
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 与您连接两个`Comparator`所做的工作相比，您在这里注意到了什么？您通过以流畅的方式组合两个`Comparator`来定义了多字段`Comparator`，
- en: '[PRE122]'
  id: totrans-649
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'whereas the `Collectors` API allows you to create a multilevel `Collector`
    by nesting the `Collector`s:'
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 而`Collectors` API允许你通过嵌套`Collector`来创建多级`Collector`：
- en: '[PRE123]'
  id: totrans-651
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: Normally, the fluent style is considered to be more readable than the nesting
    style, especially when the composition involves three or more components. Is this
    difference in style a curiosity? In fact, it reflects a deliberate design choice
    caused by the fact that the innermost `Collector` has to be evaluated first, but
    logically, it’s the last grouping to be performed. In this case, nesting the `Collector`
    creations with several static methods instead of fluently concatenating them allows
    the innermost grouping to be evaluated first but makes it appear to be the last
    one in the code.
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，流畅风格被认为比嵌套风格更易读，尤其是在涉及三个或更多组件的组合时。这种风格上的差异是一种好奇心吗？事实上，它反映了由于最内层的`Collector`必须首先评估，但从逻辑上讲，它是最后一个分组操作，因此这是一种故意的、有意识的设计选择。在这种情况下，使用几个静态方法而不是流畅地连接它们来创建`Collector`创建，允许首先评估最内层的分组，但看起来像是在代码中的最后一个。
- en: It would be easier (except for the use of generics in the definitions) to implement
    a `GroupingBuilder` that delegates to the `groupingBy` factory method but allows
    multiple grouping operations to be composed fluently. This next listing shows
    how.
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 实现一个`GroupingBuilder`，它委托给`groupingBy`工厂方法，但允许流畅地组合多个分组操作会更简单（除了在定义中使用泛型之外）。接下来的列表展示了如何实现。
- en: Listing 10.3\. A fluent grouping collectors builder
  id: totrans-654
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.3\. 一个流畅分组收集器构建器
- en: '[PRE124]'
  id: totrans-655
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'What’s the problem with this fluent builder? Trying to use it makes the problem
    evident:'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 这个流畅构建器有什么问题？尝试使用它会使问题变得明显：
- en: '[PRE125]'
  id: totrans-657
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: As you can see, the use of this utility class is counterintuitive because the
    grouping functions have to be written in reverse order relative to the corresponding
    nested grouping level. If you try to refactor this fluent builder to fix the ordering
    issue, you realize that unfortunately, the Java type system won’t allow you to
    do this.
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，使用这个实用程序类是不直观的，因为分组函数必须相对于相应的嵌套分组级别以相反的顺序编写。如果您尝试重构这个流畅构建器以修复排序问题，您会发现不幸的是，Java类型系统不允许您这样做。
- en: By looking more closely at the native Java API and the reasons behind its design
    decisions, you’ve started to learn a few patterns and useful tricks for implementing
    readable DSLs. In the next section, you continue to investigate techniques for
    developing effective DSLs.
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 通过更仔细地查看原生Java API及其设计决策背后的原因，您已经开始学习一些用于实现可读性DSL的模式和有用的技巧。在下一节中，您将继续研究开发有效DSL的技术。
- en: 10.3\. Patterns and techniques to create DSLs in Java
  id: totrans-660
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3\. 在Java中创建DSL的模式和技术
- en: A DSL provides a friendly, readable API to work with a particular domain model.
    For that reason, we start this section by defining a simple domain model; then
    we discuss the patterns that can be used to create a DSL on top of it.
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: DSL提供了一个友好、易读的API来处理特定的领域模型。因此，我们从这个部分开始定义一个简单的领域模型；然后我们讨论可以用来在它之上创建DSL的模式。
- en: 'The sample domain model is made of three things. The first thing is plain Java
    beans modeling a stock quoted on a given market:'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 样例领域模型由三部分组成。第一部分是建模在特定市场上交易的股票的普通Java Bean：
- en: '[PRE126]'
  id: totrans-663
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'The second thing is a trade to buy or sell a given quantity of a stock at a
    given price:'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 第二件事是在给定价格下买卖一定数量的股票的交易：
- en: '[PRE127]'
  id: totrans-665
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'The final thing is an order placed by a customer to settle one or more trades:'
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一件事情是客户为结算一个或多个交易而下达的订单：
- en: '[PRE128]'
  id: totrans-667
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: This domain model is straightforward. It’s cumbersome to create objects representing
    orders, for example. Try to define a simple order that contains two trades for
    your customer BigBank, as shown in [listing 10.4](#ch10ex04).
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 这个领域模型很简单。创建表示订单的对象很繁琐，例如。尝试为你的客户BigBank定义一个简单的订单，它包含两个交易，如[列表10.4](#ch10ex04)所示。
- en: Listing 10.4\. Creating a stock trading order by using the domain object’s API
    directly
  id: totrans-669
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.4\. 直接使用领域对象的API创建股票交易订单
- en: '[PRE129]'
  id: totrans-670
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: The verbosity of this code is hardly acceptable; you can’t expect a non-developer
    domain expert to understand and validate it at first glance. What you need is
    a DSL that reflects the domain model and allows it to be manipulated in a more
    immediate, intuitive way. You can employ various approaches to achieve this result.
    In the rest of this section, you learn the pros and cons of these approaches.
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的冗长性几乎无法接受；你不能期望非开发领域的专家一眼就能理解和验证它。你需要的是一个反映领域模型的领域特定语言（DSL），并允许以更直接、直观的方式对其进行操作。你可以采用各种方法来实现这一结果。在本节的其余部分，你将了解这些方法的优缺点。
- en: 10.3.1\. Method chaining
  id: totrans-672
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.3.1\. 方法链
- en: The first style of DSL to explore is one of the most common. It allows you to
    define a trading order with a single chain of method invocations. The following
    listing shows an example of this type of DSL.
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: 要探索的第一种DSL风格是最常见的之一。它允许你通过单一的方法调用链定义一个交易订单。以下列表展示了这种类型DSL的一个示例。
- en: Listing 10.5\. Creating a stock trading order with method chaining
  id: totrans-674
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.5\. 使用方法链创建股票交易订单
- en: '[PRE130]'
  id: totrans-675
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: This code looks like a big improvement, doesn’t it? It’s very likely that your
    domain expert will understand this code effortlessly. But how can you implement
    a DSL to achieve this result? You need a few builders that create the objects
    of this domain through a fluent API. The top-level builder creates and wraps an
    order, making it possible to add one or more trades to it, as shown in the next
    listing.
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码看起来是一个很大的改进，不是吗？你的领域专家很可能能够轻松理解这段代码。但你是如何实现一个DSL来达到这个结果的？你需要一些构建器，通过流畅的API创建这个领域的对象。顶级构建器创建并包装一个订单，使其能够添加一个或多个交易，如下一列表所示。
- en: Listing 10.6\. An order builder providing a method-chaining DSL
  id: totrans-677
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.6\. 提供方法链DSL的订单构建器
- en: '[PRE131]'
  id: totrans-678
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '***1* The order wrapped by this builder**'
  id: totrans-679
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 由这个构建器包装的订单**'
- en: '***2* A static factory method to create a builder of an order placed by a given
    customer**'
  id: totrans-680
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 一个静态工厂方法用于创建由给定客户放置的订单构建器**'
- en: '***3* Creates a TradeBuilder to build a trade to buy a stock**'
  id: totrans-681
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 创建一个TradeBuilder来构建一个购买股票的交易**'
- en: '***4* Creates a TradeBuilder to build a trade to sell a stock**'
  id: totrans-682
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 创建一个TradeBuilder来构建一个出售股票的交易**'
- en: '***5* Adds a trade to the order**'
  id: totrans-683
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 将交易添加到订单中**'
- en: '***6* Returns the order builder itself, allowing you to fluently create and
    add further trades**'
  id: totrans-684
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 返回订单构建器本身，允许你流畅地创建和添加更多交易**'
- en: '***7* Terminates the building of the order and returns it**'
  id: totrans-685
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 终止订单的构建并返回它**'
- en: 'The `buy()` and `sell()` methods of the order builder create and return another
    builder that builds a trade and adds it to the order itself:'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 订单构建器的`buy()`和`sell()`方法创建并返回另一个构建器，该构建器构建一个交易并将其添加到订单本身：
- en: '[PRE132]'
  id: totrans-687
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'The only public method of the `TradeBuilder` is used to create a further builder,
    which then builds an instance of the `Stock` class:'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: '`TradeBuilder`的唯一公共方法用于创建另一个构建器，然后构建`Stock`类的实例：'
- en: '[PRE133]'
  id: totrans-689
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'The `StockBuilder` has a single method, `on()`, that specifies the market for
    the stock, adds the stock to the trade, and returns one last builder:'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: '`StockBuilder`有一个单一的方法`on()`，它指定了股票的市场，将股票添加到交易中，并返回最后一个构建器：'
- en: '[PRE134]'
  id: totrans-691
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: This one public method of `TradeBuilderWithStock` sets the unit price of the
    traded stock and returns the original order builder. As you’ve seen, this method
    allows you to fluently add other trades to the order until the end method of the
    `MethodChaining-OrderBuilder` is called. The choice of having multiple builder
    classes—and in particular, two different trade builders—is made to force the user
    of this DSL to call the methods of its fluent API in a predetermined sequence,
    ensuring that a trade has been configured correctly before the user starts creating
    the next one. The other advantage of this approach is that the parameters used
    to set an order up are scoped inside the builder. This approach minimizes the
    use of static methods and allows the names of the methods to act as named arguments,
    thus further improving the readability of this style of DSL. Finally, the fluent
    DSL resulting from this technique has the least syntactic noise possible.
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: '`TradeBuilderWithStock` 的这个公共方法设置了交易股票的单位价格，并返回原始订单构建器。正如你所看到的，这个方法允许你流畅地添加其他交易到订单中，直到调用
    `MethodChaining-OrderBuilder` 的结束方法。选择多个构建器类——特别是两个不同的交易构建器——是为了迫使 DSL 的用户以预定的顺序调用其流畅
    API 的方法，确保在用户开始创建下一个交易之前，交易已被正确配置。这种方法的其他优点是，用于设置订单的参数都在构建器的作用域内。这种方法最小化了静态方法的使用，并允许方法名称作为命名参数，从而进一步提高了这种
    DSL 风格的可读性。最后，这种技术产生的流畅 DSL 具有尽可能少的语法噪声。'
- en: Unfortunately, the main issue in method chaining is the verbosity required to
    implement the builders. A lot of glue code is necessary to mix the top-level builders
    with the lower-level ones. Another evident disadvantage is the fact that you have
    no way to enforce the indentation convention that you used to underline the nesting
    hierarchy of the objects in your domain.
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，方法链的主要问题是实现构建器所需的冗长性。需要大量的粘合代码来混合顶层构建器和底层构建器。另一个明显的缺点是，你无法强制执行你用来强调领域对象嵌套层次结构的缩进约定。
- en: In the next section, you investigate a second DSL pattern that has quite different
    characteristics.
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将研究第二种具有不同特性的 DSL 模式。
- en: 10.3.2\. Using nested functions
  id: totrans-695
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.3.2\. 使用嵌套函数
- en: The *nested function* DSL pattern takes its name from the fact that it populates
    the domain model by using functions that are nested within other functions. The
    following listing illustrates the DSL style resulting from this approach.
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: '*嵌套函数* DSL 模式的名称来源于它通过使用嵌套在其他函数中的函数来填充领域模型。下面的列表展示了这种方法的 DSL 风格。'
- en: Listing 10.7\. Creating a stock-trading order with nested functions
  id: totrans-697
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.7\. 使用嵌套函数创建股票交易订单
- en: '[PRE135]'
  id: totrans-698
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: The code required to implement this DSL style is far more compact than what
    you learned in [section 10.3.1](#ch10lev2sec5).
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这种 DSL 风格所需的代码比你在[第 10.3.1 节](#ch10lev2sec5)中学到的要紧凑得多。
- en: The `NestedFunctionOrderBuilder` in the following listing shows that it’s possible
    to provide an API with this DSL style to your users. (In this listing, we implicitly
    assume that all its static methods are imported.)
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表中的 `NestedFunctionOrderBuilder` 展示了向用户提供具有这种 DSL 风格的 API 是可能的。（在这个列表中，我们隐含地假设所有静态方法都已导入。）
- en: Listing 10.8\. An order builder providing a nested-function DSL
  id: totrans-701
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.8\. 提供嵌套函数 DSL 的订单构建器
- en: '[PRE136]'
  id: totrans-702
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '***1* Creates an order for a given customer**'
  id: totrans-703
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 为指定客户创建订单**'
- en: '***2* Adds all trades to the order**'
  id: totrans-704
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将所有交易添加到订单中**'
- en: '***3* Creates a trade to buy a stock**'
  id: totrans-705
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 创建一个购买股票的交易**'
- en: '***4* Creates a trade to sell a stock**'
  id: totrans-706
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 创建一个出售股票的交易**'
- en: '***5* A dummy method to define the unit price of the traded stock**'
  id: totrans-707
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 一个用于定义交易股票单位价格的虚拟方法**'
- en: '***6* Creates the traded stock**'
  id: totrans-708
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 创建交易股票**'
- en: '***7* A dummy method to define the market where the stock is traded**'
  id: totrans-709
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 一个用于定义股票交易市场的虚拟方法**'
- en: The other advantage of this technique compared with method chaining is that
    the hierarchy structure of your domain objects (an order contains one or more
    trades, and each trade refers to a single stock in the example) is visible by
    the way in which the different functions are nested.
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 与方法链相比，这种技术的另一个优点是，通过不同函数的嵌套方式，可以直观地看到领域对象的层次结构（例如，在示例中，一个订单包含一个或多个交易，每个交易引用单个股票）。
- en: Unfortunately, this pattern also has some issues. You may have noticed that
    the resulting DSL requires a lot of parentheses. Moreover, the list of arguments
    that have to be passed to the static methods is rigidly predetermined. If the
    objects of your domain have some optional fields, you need to implement different
    overloaded versions of those methods, which allows you to omit the missing parameters.
    Finally, the meanings of the different arguments are defined by their positions
    rather than their names. You can mitigate this last problem by introducing a few
    dummy methods, as you did with the `at()` and `on()` methods in your `NestedFunctionOrderBuilder`,
    the only purpose of which is to clarify the role of an argument.
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这个模式也存在一些问题。您可能已经注意到，生成的DSL需要很多括号。此外，必须传递给静态方法的参数列表是严格预定的。如果您的领域对象有一些可选字段，您需要实现那些方法的多个重载版本，这样您就可以省略缺失的参数。最后，不同参数的含义是由它们的顺序而不是它们的名称定义的。您可以通过引入一些占位方法来减轻最后一个问题，就像您在`NestedFunctionOrderBuilder`中的`at()`和`on()`方法所做的那样，这些方法的唯一目的是阐明参数的作用。
- en: The two DSL patterns we’ve shown you so far don’t require the use of lambda
    expressions. In the next section, we illustrate a third technique that leverages
    the functional capabilities introduced by Java 8.
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前向您展示的两个DSL模式不需要使用lambda表达式。在下一节中，我们将展示第三种技术，该技术利用了Java 8引入的功能特性。
- en: 10.3.3\. Function sequencing with lambda expressions
  id: totrans-713
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.3.3\. 使用lambda表达式进行函数序列
- en: The next DSL pattern employs a sequence of functions defined with lambda expressions.
    Implementing a DSL in this style on top of your usual stock-trading domain model
    allows you to define an order, as shown in [listing 10.9](#ch10ex09).
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个DSL模式使用lambda表达式定义的函数序列。在您的常规股票交易领域模型之上以这种方式实现DSL允许您定义一个订单，如[列表10.9](#ch10ex09)所示。
- en: Listing 10.9\. Creating a stock-trading order with function sequencing
  id: totrans-715
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.9\. 使用函数序列创建股票交易订单
- en: '[PRE137]'
  id: totrans-716
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: To implement this approach, you need to develop several builders that accept
    lambda expressions and to populate the domain model by executing them. These builders
    keep the intermediate state of the objects to be created the way you did in the
    DSL implementation by using method chaining. As you did in the method-chaining
    pattern, you have a top-level builder to create the order, but this time, the
    builder takes `Consumer` objects as parameters so that the user of the DSL can
    use lambda expressions to implement them. The next listing shows the code required
    to implement this approach.
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这种方法，您需要开发几个接受lambda表达式的构建器，并通过执行它们来填充领域模型。这些构建器以与在DSL实现中使用方法链相同的方式保留要创建的对象的中间状态。如您在方法链模式中所做的那样，您有一个顶级构建器来创建订单，但这次，构建器接受`Consumer`对象作为参数，以便DSL的用户可以使用lambda表达式来实现它们。下一个列表显示了实现此方法所需的代码。
- en: Listing 10.10\. An order builder providing a function-sequencing DSL
  id: totrans-718
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.10\. 提供函数序列DSL的订单构建器
- en: '[PRE138]'
  id: totrans-719
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '***1* The order wrapped by this builder**'
  id: totrans-720
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 由该构建器包装的订单**'
- en: '***2* Executes the lambda expression passed to the order builder**'
  id: totrans-721
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 执行传递给订单构建器的lambda表达式**'
- en: '***3* Returns the order populated by executing the Consumer of the OrderBuilder**'
  id: totrans-722
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 通过执行OrderBuilder的Consumer返回填充的订单**'
- en: '***4* Sets the customer who placed the order**'
  id: totrans-723
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 设置下订单的客户**'
- en: '***5* Consumes a TradeBuilder to create a trade to buy a stock**'
  id: totrans-724
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 消费TradeBuilder以创建购买股票的交易**'
- en: '***6* Consumes a TradeBuilder to create a trade to sell a stock**'
  id: totrans-725
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 消费TradeBuilder以创建销售股票的交易**'
- en: '***7* Executes the lambda expression passed to the TradeBuilder**'
  id: totrans-726
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 执行传递给TradeBuilder的lambda表达式**'
- en: '***8* Adds to the order the trade populated by executing the Consumer of the
    TradeBuilder**'
  id: totrans-727
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8* 通过执行TradeBuilder的Consumer将交易添加到订单中**'
- en: 'The `buy()` and `sell()` methods of the order builder accept two lambda expressions
    that are `Consumer<TradeBuilder>`. When executed, these methods populate a buying
    or selling trade, as follows:'
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: 订单构建器的`buy()`和`sell()`方法接受两个`Consumer<TradeBuilder>`类型的lambda表达式。当执行时，这些方法将填充一个购买或销售交易，如下所示：
- en: '[PRE139]'
  id: totrans-729
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'Finally, the `TradeBuilder` accepts the `Consumer` of a third builder that’s
    intended to define the traded stock:'
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`TradeBuilder`接受一个第三构建器的`Consumer`，该构建器旨在定义交易股票：
- en: '[PRE140]'
  id: totrans-731
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: This pattern has the merit of combining two positive characteristics of the
    two previous DSL styles. Like the method-chaining pattern it allows to define
    the trading order in a fluent way. In addition, similarly to the nested-function
    style, it preserves the hierarchy structure of our domain objects in the nesting
    level of the different lambda expressions.
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式结合了两种先前 DSL 风格的两个积极特点。像方法链模式一样，它允许以流畅的方式定义交易顺序。此外，类似于嵌套函数风格，它在不同 lambda
    表达式的嵌套级别中保留了我们的领域对象的层次结构。
- en: Unfortunately, this approach requires a lot of setup code, and using the DSL
    itself is affected by the noise of the Java 8 lambda-expression syntax.
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这种方法需要大量的设置代码，并且使用 DSL 本身也受到 Java 8 lambda 表达式语法的噪声影响。
- en: Choosing among these three DSL styles is mainly a matter of taste. It also requires
    some experience to find the best fit for the domain model for which you want to
    create a domain language. Moreover, it’s possible to combine two or more of these
    styles in a single DSL, as you see in the next section.
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: 在这三种 DSL 风格之间进行选择主要是一个口味问题。这也需要一些经验来找到最适合你想要创建领域语言的领域模型。此外，你可以在单个 DSL 中结合两种或更多这些风格，正如你在下一节中看到的那样。
- en: 10.3.4\. Putting it all together
  id: totrans-735
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.3.4\. 将所有内容组合在一起
- en: As you’ve seen so far, all three DSL patterns have pros and cons, but nothing
    prevents you from using them together within a single DSL. You could end up developing
    a DSL through which you could define your stock-trading order as shown in the
    following listing.
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，所有三种 DSL 模式都有优点和缺点，但没有什么阻止你在单个 DSL 中一起使用它们。你最终可能会开发出一个 DSL，通过它可以定义你的股票交易订单，如下面的列表所示。
- en: Listing 10.11\. Creating a stock-trading order by using multiple DSL patterns
  id: totrans-737
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.11\. 通过使用多个 DSL 模式创建股票交易订单
- en: '[PRE141]'
  id: totrans-738
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '***1* Nested function to specify attributes of the top-level order**'
  id: totrans-739
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 嵌套函数用于指定顶级订单的属性**'
- en: '***2* Lambda expression to create a single trade**'
  id: totrans-740
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 使用单个 lambda 表达式创建单个交易**'
- en: '***3* Method chaining in the body of the lambda expression that populates the
    trade object**'
  id: totrans-741
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 在填充交易对象的 lambda 表达式主体中进行方法链**'
- en: In this example, the nested-function pattern is combined with the lambda approach.
    Each trade is created by a `Consumer` of a `TradeBuilder` that’s implemented by
    a lambda expression, as shown in the next listing.
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，嵌套函数模式与 lambda 方法相结合。每个交易都是由 `TradeBuilder` 的 `Consumer` 创建的，该 `TradeBuilder`
    由 lambda 表达式实现，如下面的列表所示。
- en: Listing 10.12\. An order builder providing a DSL that mixes multiple styles
  id: totrans-743
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.12\. 提供混合多种风格的 DSL 的订单构建器
- en: '[PRE142]'
  id: totrans-744
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'Finally, the helper class `TradeBuilder` and the `StockBuilder` that it uses
    internally (implementation shown immediately after this paragraph) provide a fluent
    API implementing the method-chaining pattern. After you make this choice, you
    can write the body of the lambda expression through which the trade will be populated
    in the most compact way possible:'
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，辅助类 `TradeBuilder` 和它内部使用的 `StockBuilder`（实现如下所示）提供了一个实现方法链模式的流畅 API。在你做出这个选择之后，你可以通过
    lambda 表达式的主体以最紧凑的方式编写填充交易的代码：
- en: '[PRE143]'
  id: totrans-746
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '[Listing 10.12](#ch10ex12) is an example of how the three DSL patterns discussed
    in this chapter can be combined to achieve a readable DSL. Doing so allows you
    to take advantage of the pros of the various DSL styles, but this technique has
    a minor drawback: the resulting DSL appears to be less uniform than one that uses
    a single technique, so users of this DSL probably will need more time to learn
    it.'
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 10.12](#ch10ex12) 是一个例子，说明了本章讨论的三个 DSL 模式如何结合以实现可读的 DSL。这样做可以让你利用各种 DSL
    风格的优点，但这种技术有一个小缺点：结果 DSL 看起来不如使用单一技术的 DSL 统一，因此这个 DSL 的用户可能需要更多时间来学习它。'
- en: So far, you’ve used lambda expressions, but, as the `Comparator` and `Stream`
    APIs show, using method references can further improve the readability of many
    DSLs. We demonstrate this fact in the next section through a practical example
    of using method references in the stock-trading domain model.
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经使用了 lambda 表达式，但正如 `Comparator` 和 `Stream` API 所示，使用方法引用可以进一步提高许多 DSL
    的可读性。我们将在下一节通过一个使用方法引用在股票交易领域模型中的实际例子来证明这一点。
- en: 10.3.5\. Using method references in a DSL
  id: totrans-749
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.3.5\. 在 DSL 中使用方法引用
- en: In this section, you try to add another simple feature to your stock-trading
    domain model. This feature calculates the final value of an order after adding
    zero or more of the following taxes to the order’s net value, as shown in the
    next listing.
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你尝试向你的股票交易领域模型添加另一个简单的功能。这个功能在订单的净价值中添加零个或多个以下税费后，计算订单的最终价值，如以下列表所示。
- en: Listing 10.13\. The taxes that can be applied to the order’s net value
  id: totrans-751
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.13\. 可以应用于订单净价值的税费
- en: '[PRE144]'
  id: totrans-752
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: The simplest way to implement such a tax calculator is to use a static method
    that accepts the order plus one Boolean flag for each tax that could be applied
    ([listing 10.14](#ch10ex14)).
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这样的税费计算器最简单的方法是使用一个静态方法，该方法接受订单以及每个可能应用的税费的一个布尔标志（[列表10.14](#ch10ex14)）。
- en: Listing 10.14\. Applying taxes to the order’s net value with a set of Boolean
    flags
  id: totrans-754
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.14\. 使用一组布尔标志应用订单净价值的税费
- en: '[PRE145]'
  id: totrans-755
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'This way, it’s possible to calculate the final value of an order after applying
    the regional tax and the surcharge, but not the general tax, as follows:'
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，就可以在应用地区税和附加费后，但未应用一般税的情况下，计算出订单的最终价值，如下所示：
- en: '[PRE146]'
  id: totrans-757
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'The readability problem of this implementation is evident: it’s difficult to
    remember the right sequence of Boolean variables and to understand which taxes
    have been applied and which haven’t. The canonical way to fix this issue is to
    implement a `TaxCalculator` that provides a minimal DSL to fluently set the Boolean
    flags one by one, as shown the next listing.'
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实现的可读性问题很明显：很难记住正确的布尔变量的顺序，也很难理解哪些税费已经应用，哪些没有。解决这个问题的规范方法是实现一个`TaxCalculator`，它提供一个最小的领域特定语言（DSL），可以流畅地逐个设置布尔标志，如以下列表所示。
- en: Listing 10.15\. A tax calculator that fluently defines the taxes to be applied
  id: totrans-759
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.15\. 一个流畅定义要应用的税费的税费计算器
- en: '[PRE147]'
  id: totrans-760
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'Using this `TaxCalculator` makes clear that you want to apply the regional
    tax and the surcharge to the net value of the order:'
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个`TaxCalculator`可以清楚地表明你想要将地区税和附加费应用于订单的净价值：
- en: '[PRE148]'
  id: totrans-762
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: The main issue with this solution is its verbosity. It doesn’t scale because
    you need a Boolean field and a method for each tax in your domain. By using the
    functional capabilities of Java, you can achieve the same result in terms of readability
    in a far more compact and flexible way. To see how, refactor your `TaxCalculator`
    as shown in this next listing.
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案的主要问题是其冗长性。它无法扩展，因为你需要在你的领域中的每个税费都有一个布尔字段和方法。通过使用Java的功能特性，你可以以更紧凑、更灵活的方式实现相同的结果，在可读性方面。要了解如何实现，请参考以下列表中的重构`TaxCalculator`。
- en: Listing 10.16\. A tax calculator that fluently combines the tax functions to
    be applied
  id: totrans-764
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.16\. 一个流畅组合要应用的税费函数的税费计算器
- en: '[PRE149]'
  id: totrans-765
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '***1* The function calculating all the taxes to be applied to the order’s value**'
  id: totrans-766
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 计算要应用于订单价值的所有税费的函数**'
- en: '***2* Obtains the new tax-calculating function, composing the current one with
    the one passed as argument**'
  id: totrans-767
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 获取新的税费计算函数，将当前函数与作为参数传递的函数组合**'
- en: '***3* Returns this, allowing further tax functions to be concatenated fluently**'
  id: totrans-768
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 返回这个，允许流畅地连接更多的税费函数**'
- en: '***4* Calculates the final order’s value by applying the tax-calculating function
    to the order’s net value**'
  id: totrans-769
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 通过将税费计算函数应用于订单的净价值来计算最终订单价值**'
- en: 'With this solution, you need only one field: the function that, when applied
    to the order’s net value, adds in one shot all the taxes configured through the
    `TaxCalculator` class. The starting value of this function is the identity function.
    At this point, no tax has been added yet, so the order’s final value is the same
    as the net value. When a new tax is added through the `with()` method, this tax
    is composed with the current tax-calculating function, thus encompassing all the
    added taxes in a single function. Finally, when an order is passed to the `calculate()`
    method, the tax-calculating function resulting from the composition of the various
    configured taxes is applied to the order’s net value. This refactored `TaxCalculator`
    can be used as follows:'
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个解决方案，你只需要一个字段：一个函数，当应用于订单的净价值时，一次性添加通过`TaxCalculator`类配置的所有税费。这个函数的起始值是恒等函数。在这个点上，还没有添加任何税费，因此订单的最终价值与净价值相同。当通过`with()`方法添加新的税费时，这个税费与当前的税费计算函数组合，从而在单个函数中包含所有添加的税费。最后，当订单传递给`calculate()`方法时，将应用由各种配置的税费组合而成的税费计算函数到订单的净价值上。这个重构后的`TaxCalculator`可以使用如下方式：
- en: '[PRE150]'
  id: totrans-771
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: This solution uses method references, is easy to read, and gives succinct code.
    It’s also flexible in that if and when a new tax function is added to the `Tax`
    class, you can use it immediately with your functional `TaxCalculator` without
    modification.
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案使用方法引用，易于阅读，并给出简洁的代码。它也很灵活，如果在`Tax`类中添加了新的税函数，你可以立即使用你的功能`TaxCalculator`而无需修改。
- en: Now that we’ve discussed the various techniques that can be used to implement
    a DSL in Java 8 and beyond, it’s interesting to investigate how these strategies
    have been used in widely adopted Java tools and frameworks.
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了在Java 8及更高版本中实现DSL的各种技术，有趣的是研究这些策略是如何被广泛采用的Java工具和框架所使用的。
- en: 10.4\. Real World Java 8 DSL
  id: totrans-774
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.4. 实际应用中的Java 8 DSL
- en: In [section 10.3](#ch10lev1sec3), you learned three useful patterns for developing
    DSLs in Java, together with their pros and cons. [Table 10.1](#ch10table01) summarizes
    what we’ve discussed so far.
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第10.3节](#ch10lev1sec3)中，你学习了三个用于在Java中开发DSL的有用模式，以及它们的优缺点。[表10.1](#ch10table01)总结了我们迄今为止所讨论的内容。
- en: Table 10.1\. DSLs patterns with their pros and cons
  id: totrans-776
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表10.1. DSL模式及其优缺点
- en: '| Pattern name | Pros | Cons |'
  id: totrans-777
  prefs: []
  type: TYPE_TB
  zh: '| 模式名称 | 优点 | 缺点 |'
- en: '| --- | --- | --- |'
  id: totrans-778
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Method chaining |'
  id: totrans-779
  prefs: []
  type: TYPE_TB
  zh: '| 方法链 |'
- en: Method names that act as keyword arguments
  id: totrans-780
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为关键字参数的方法名
- en: Works well with optional parameters
  id: totrans-781
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与可选参数配合良好
- en: Possible to enforce the DSL user to call methods in a pre-determined order
  id: totrans-782
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以强制DSL用户以预定的顺序调用方法
- en: Minimal or no use of static methods
  id: totrans-783
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小或无静态方法的使用
- en: Lowest possible syntactic noise
  id: totrans-784
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最低可能的语法噪声
- en: '|'
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Verbose implementation
  id: totrans-786
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现冗长
- en: Glue code to bind the builders
  id: totrans-787
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将构建器粘合在一起的粘合代码
- en: Hierarchy of domain objects defined only by indentation convention
  id: totrans-788
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅通过缩进约定定义的领域对象层次结构
- en: '|'
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Nested functions |'
  id: totrans-790
  prefs: []
  type: TYPE_TB
  zh: '| 嵌套函数 |'
- en: Lower implementation verbosity
  id: totrans-791
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现冗长度较低
- en: Domain objects hierarchy echoed by function nesting
  id: totrans-792
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过函数嵌套回显的领域对象层次结构
- en: '|'
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Heavy use of static methods
  id: totrans-794
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 严重使用静态方法
- en: Arguments defined by position rather than name
  id: totrans-795
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数由位置而不是名称定义
- en: Method overloading required for optional parameters
  id: totrans-796
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于可选参数需要方法重载
- en: '|'
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Function sequencing with lambdas |'
  id: totrans-798
  prefs: []
  type: TYPE_TB
  zh: '| 使用lambda表达式进行函数序列 |'
- en: Works well with optional parameters
  id: totrans-799
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与可选参数配合良好
- en: Minimal or no use of static methods
  id: totrans-800
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小或无静态方法的使用
- en: Hierarchy of domain objects echoed by lambdas nesting
  id: totrans-801
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过嵌套的lambda表达式回显的领域对象层次结构
- en: No glue code for builders
  id: totrans-802
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有构建器的粘合代码
- en: '|'
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Verbose implementation
  id: totrans-804
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现冗长
- en: More syntactic noise from lambda expressions in the DSL
  id: totrans-805
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DSL中的lambda表达式产生的更多语法噪声
- en: '|'
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'It’s time to consolidate what you’ve learned so far by analyzing how these
    patterns are employed in three well-known Java libraries: an SQL mapping tool,
    a behavior-driven development framework, and a tool that implements Enterprise
    Integration Patterns.'
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候通过分析这些模式在三个著名的Java库中的应用来巩固你迄今为止所学的知识了：一个SQL映射工具、一个行为驱动开发框架以及一个实现企业集成模式的工具。
- en: 10.4.1\. jOOQ
  id: totrans-808
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.4.1. jOOQ
- en: SQL is one of the most common and widely used DSLs. For this reason, it shouldn’t
    be surprising that there’s a Java library providing a nice DSL to write and execute
    SQL queries. jOOQ is an internal DSL that implements SQL as a type-safe embedded
    language directly in Java. A source-code generator reverse-engineers the database
    schema, which allows the Java compiler to type-check complex SQL statements. The
    product of this reverse-engineering process generates information with which you
    can navigate your database schema. As a simple example, the following SQL query
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: SQL是最常见和广泛使用的DSL之一。因此，有一个Java库提供了一个很好的DSL来编写和执行SQL查询并不令人惊讶。jOOQ是一个内部DSL，它直接在Java中实现了类型安全的SQL嵌入语言。源代码生成器会逆向工程数据库模式，这允许Java编译器检查复杂的SQL语句。这个逆向工程过程产生的信息可以用来导航你的数据库模式。作为一个简单的例子，以下SQL查询
- en: '[PRE151]'
  id: totrans-810
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'can be written using the jOOQ DSL like this:'
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用jOOQ DSL像这样编写：
- en: '[PRE152]'
  id: totrans-812
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: Another nice feature of the jOOQ DSL is the possibility of using it in combination
    with the `Stream` API. This feature allows you to manipulate in memory, with a
    single fluent statement, the data resulting from the execution of the SQL query,
    as shown in the next listing.
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: jOOQ DSL的另一个优点是它可以与`Stream` API结合使用。这个特性允许你通过单个流畅的语句在内存中操作SQL查询执行的结果，如下面的列表所示。
- en: Listing 10.17\. Selecting books from a database by using the jOOQ DSL
  id: totrans-814
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.17. 使用jOOQ DSL从数据库中选择书籍
- en: '[PRE153]'
  id: totrans-815
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: '***1* Creates the connection to the SQL database**'
  id: totrans-816
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 创建到SQL数据库的连接**'
- en: '***2* Starts the jOOQ SQL statement, using the just-created database connection**'
  id: totrans-817
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 使用刚刚创建的数据库连接开始 jOOQ SQL 语句**'
- en: '***3* Defines the SQL statement through the jOOQ DSL**'
  id: totrans-818
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 通过 jOOQ DSL 定义 SQL 语句**'
- en: '***4* Fetches the data from the database; jOOQ statement ends here**'
  id: totrans-819
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 从数据库中获取数据；jOOQ 语句在此结束**'
- en: '***5* Starts manipulating data fetched from database with Stream API**'
  id: totrans-820
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 使用 Stream API 开始操作从数据库获取的数据**'
- en: '***6* Groups the books by author**'
  id: totrans-821
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 按作者分组书籍**'
- en: '***7* Prints the authors’ names together with the books they wrote**'
  id: totrans-822
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 打印作者的名字以及他们所写的书籍**'
- en: It’s evident that the main DSL pattern chosen to implement the jOOQ DSL is method-chaining.
    In fact, various characteristics of this pattern (allowing optional parameters
    and requiring certain methods to be called only in a predetermined sequence) are
    essential to mimic the syntax of a well-formed SQL query. These features, together
    with its lower syntactic noise, make the method-chaining pattern a good fit for
    jOOQ’s needs.
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，实现 jOOQ DSL 所选择的主要 DSL 模式是方法链。实际上，这种模式的各种特性（允许可选参数和需要以预定的顺序调用某些方法）对于模仿良好形成的
    SQL 查询的语法至关重要。这些特性，加上其较低的语法噪声，使得方法链模式非常适合 jOOQ 的需求。
- en: 10.4.2\. Cucumber
  id: totrans-824
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.4.2\. Cucumber
- en: Behavior-driven development (BDD) is an extension of test-driven development
    that uses a simple domain-specific scripting language made of structured statements
    that describe various business scenarios. Cucumber, like other BDD frameworks,
    translates these statements into executable test cases. As a result, the scripts
    resulting from the application of this development technique can be used both
    as runnable tests and as acceptance criteria for a given business feature. BDD
    also focuses the development effort on the delivery of prioritized, verifiable
    business value and bridges the gap between domain experts and programmers by making
    them share a business vocabulary.
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: 行为驱动开发（BDD）是测试驱动开发的扩展，它使用一种简单的领域特定脚本语言，由结构化语句组成，描述各种业务场景。Cucumber，像其他 BDD 框架一样，将这些语句转换为可执行的测试用例。因此，应用这种开发技术产生的脚本既可以作为可运行的测试，也可以作为给定业务功能的验收标准。BDD
    还将开发努力集中在交付优先级高、可验证的业务价值上，并通过使领域专家和程序员共享业务词汇来弥合他们之间的差距。
- en: 'These abstract concepts can be clarified by a practical example that uses Cucumber,
    a BDD tool that enables developers to write business scenarios in plain English.
    Use Cucumber’s scripting language as follows to define a simple business scenario:'
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: 这些抽象概念可以通过一个使用 Cucumber 的实际例子来澄清，Cucumber 是一个 BDD 工具，它允许开发者用纯英语编写业务场景。以下是如何使用
    Cucumber 的脚本语言定义一个简单的业务场景：
- en: '[PRE154]'
  id: totrans-827
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: 'Cucumber uses notation that’s divided into three parts: the definition of prerequisites
    (`Given`), the actual calls to the domain objects under test, and (`When`) the
    assertions checking the outcome of the test case (`Then`).'
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: Cucumber 使用分为三部分的符号：前提条件的定义（`Given`）、对测试中的域对象的实际调用（`When`），以及检查测试用例结果的断言（`Then`）。
- en: The script that defines the test scenario is written with an external DSL that
    has a limited number of keywords and lets you write sentences in a free format.
    These sentences are matched through regular expressions that capture the variables
    of the test case and pass them as arguments to the methods that implement the
    test itself. Using the stock-trading domain model from the beginning of [section
    10.3](#ch10lev1sec3), it’s possible to develop a Cucumber test case that checks
    whether the value of a stock-trading order is calculated correctly, as shown in
    the next listing.
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: 定义测试场景的脚本是用一个具有有限关键词的外部 DSL 编写的，它允许你以自由格式编写句子。这些句子通过正则表达式进行匹配，捕获测试用例的变量，并将它们作为参数传递给实现测试本身的方法。从
    [第 10.3 节](#ch10lev1sec3) 开头的股票交易域模型开始，可以开发一个 Cucumber 测试用例，以检查股票交易订单的价值是否正确计算，如下一列表所示。
- en: Listing 10.18\. Implementing a test scenario by using Cucumber annotations
  id: totrans-830
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.18\. 使用 Cucumber 注解实现测试场景
- en: '[PRE155]'
  id: totrans-831
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '***1* Defines the unit price of a stock as a prerequisite of this scenario**'
  id: totrans-832
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 定义股票单价为此场景的前提条件**'
- en: '***2* Stores the stock unit price**'
  id: totrans-833
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 存储库存单价**'
- en: '***3* Defines the actions to be taken on the domain model under test**'
  id: totrans-834
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 定义对测试中的域模型要采取的操作**'
- en: '***4* Populates the domain model accordingly**'
  id: totrans-835
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 根据域模型进行填充**'
- en: '***5* Defines the expected scenario outcome**'
  id: totrans-836
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 定义预期的场景结果**'
- en: '***6* Checks the test assertions**'
  id: totrans-837
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 检查测试断言**'
- en: 'The introduction of lambda expressions in Java 8 allowed Cucumber to develop
    an alternative syntax that eliminated annotations by using two-argument methods:
    the regular expression previously contained in the annotation value and the lambda
    implementing the test method. When you use this second type of notation, you can
    rewrite the test scenario like this:'
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: Java 8中lambda表达式的引入使得Cucumber能够开发一种替代语法，通过使用两个参数的方法来消除注解：注解值中之前包含的正则表达式和实现测试方法的lambda表达式。当你使用这种第二种类型的表示法时，你可以像这样重写测试场景：
- en: '[PRE156]'
  id: totrans-839
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: This alternative syntax has the obvious advantage of being compact. In particular,
    replacing the test methods with anonymous lambdas eliminates the burden of finding
    meaningful method names (which rarely adds anything to readability in a test scenario).
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: 这种替代语法具有明显的优势，即简洁。特别是，用匿名lambda表达式替换测试方法，消除了寻找有意义的名称（在测试场景中很少增加可读性）的负担。
- en: Cucumber’s DSL is extremely simple, but it demonstrates how to effectively combine
    an external DSL with an internal one and (once again) shows that lambdas allow
    you to write more compact, readable code.
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: Cucumber的DSL非常简单，但它展示了如何有效地结合外部DSL和内部DSL，并且（再次）表明lambda表达式允许你编写更紧凑、更易读的代码。
- en: 10.4.3\. Spring Integration
  id: totrans-842
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.4.3\. Spring Integration
- en: '*Spring Integration* extends the dependency-injection-based Spring programming
    model to support the well-known Enterprise Integration Patterns.^([[1](#ch10fn01)])
    Spring Integration’s primary goals are to provide a simple model to implement
    complex enterprise integration solutions and to promote the adoption of an asynchronous,
    message-driven architecture.'
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: '*Spring Integration* 扩展了基于依赖注入的Spring编程模型，以支持众所周知的企业集成模式。[1](#ch10fn01) Spring
    Integration的主要目标是提供一个简单的模型来实现复杂的集成解决方案，并促进异步、消息驱动架构的采用。'
- en: ¹
  id: totrans-844
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ¹
- en: ''
  id: totrans-845
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'For more details see the book: “Enterprise Integration Patterns: Designing,
    Building, and Deploying Messaging Solutions” (Addison-Wesley) Gregor Hohpe and
    Bobby Woolf, 2004.'
  id: totrans-846
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 更多详情请参阅书籍：“企业集成模式：设计、构建和部署消息解决方案”（Addison-Wesley），作者Gregor Hohpe和Bobby Woolf，2004年。
- en: Spring Integration enables lightweight remoting, messaging, and scheduling within
    Spring-based applications. These features are also available through a rich, fluent
    DSL that’s more than syntactic sugar built on top of traditional Spring XML configuration
    files.
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Integration在基于Spring的应用程序中实现了轻量级远程通信、消息传递和调度。这些功能也通过一个丰富、流畅的DSL提供，该DSL不仅仅是建立在传统Spring
    XML配置文件之上的语法糖。
- en: Spring Integration implements all the most common patterns necessary for message-based
    applications, such as channels, endpoints, pollers, and channel interceptors.
    Endpoints are expressed as verbs in the DSL to improve readability, and integration
    processes are constructed by composing these endpoints into one or more message
    flows. The next listing shows how Spring Integration works with a simple but complete
    example.
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: Spring Integration实现了基于消息的应用程序所需的所有最常见模式，例如通道、端点、轮询器和通道拦截器。端点在DSL中以动词的形式表达，以提高可读性，并且通过将这些端点组合成一个或多个消息流来构建集成过程。下面的列表显示了Spring
    Integration如何通过一个简单但完整的示例来工作。
- en: Listing 10.19\. Configuring a Spring Integration flow by using the Spring Integration
    DSL
  id: totrans-849
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.19\. 使用Spring Integration DSL配置Spring Integration流程
- en: '[PRE157]'
  id: totrans-850
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '***1* Creates a new Message-Source that at each invocation increments an AtomicInteger**'
  id: totrans-851
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 创建一个新的Message-Source，每次调用时增加一个AtomicInteger**'
- en: '***2* The channel conveying the data arriving from the MessageSource**'
  id: totrans-852
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 传递来自MessageSource的数据的通道**'
- en: '***3* Starts creating the IntegrationFlow through a builder following the method-chaining
    pattern**'
  id: totrans-853
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 通过遵循方法链模式使用builder开始创建IntegrationFlow**'
- en: '***4* Uses the formerly defined MessageSource as the source for this IntegrationFlow**'
  id: totrans-854
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 使用之前定义的MessageSource作为此IntegrationFlow的源**'
- en: '***5* Polls the MessageSource to dequeue the data it conveys**'
  id: totrans-855
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 查询MessageSource以出队它所传递的数据**'
- en: '***6* Filters only the even numbers**'
  id: totrans-856
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 只过滤偶数**'
- en: '***7* Converts the Integers retrieved from the MessageSource into Strings**'
  id: totrans-857
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 将从MessageSource检索到的整数转换为字符串**'
- en: '***8* Sets channel queueChannel as output for this IntegrationFlow**'
  id: totrans-858
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8* 将channel queueChannel设置为IntegrationFlow的输出**'
- en: '***9* Terminates the building of the IntegrationFlow and returns it**'
  id: totrans-859
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***9* 终止IntegrationFlow的构建并返回它**'
- en: 'Here, the method `myFlow()` builds an `IntegrationFlow` by using the Spring
    Integration DSL. It uses the fluent builder provided by the `IntegrationFlows`
    class, which implements the method-chaining pattern. In this case, the resulting
    flow polls a `MessageSource` at a fixed rate, providing a sequence of `Integer`s;
    filters the even ones and converts them to `String`s, and finally sends the result
    to an output channel in a style that’s similar to the native Java 8 `Stream` API.
    This API allows a message to be sent to any component within the flow if you know
    its `inputChannel` name. If the flow starts with a direct channel, not a `MessageSource`,
    it’s possible to define the `Integration-Flow` with a lambda expression as follows:'
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`myFlow()`方法通过使用Spring Integration DSL构建`IntegrationFlow`。它使用`IntegrationFlows`类提供的流畅构建器，该类实现了方法链模式。在这种情况下，结果流程以固定速率轮询`MessageSource`，提供一系列`Integer`；过滤出偶数并将它们转换为`String`，最后以类似于原生Java
    8 `Stream` API的风格将结果发送到输出通道。此API允许将消息发送到流中的任何组件，如果你知道其`inputChannel`名称。如果流程从直接通道开始，而不是`MessageSource`，则可以使用以下lambda表达式定义`Integration-Flow`：
- en: '[PRE158]'
  id: totrans-861
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'As you see, the most widely used pattern in Spring Integration DSL is method
    chaining. This pattern fits well with the main purpose of the `IntegrationFlow`
    builder: creating a flow of message-passing and data transformations. As shown
    in this last example, however, it also uses function sequencing with lambda expressions
    for the top-level object to be built (and in some cases also for inner, more-complex
    method arguments).'
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，在Spring Integration DSL中最广泛使用的模式是方法链。这种模式与`IntegrationFlow`构建器的主要目的非常契合：创建消息传递和数据转换的流程。然而，正如这个最后的例子所示，它还使用了lambda表达式进行函数序列，用于构建顶级对象（在某些情况下也用于内部更复杂的方法参数）。
- en: Summary
  id: totrans-863
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: The main purpose of a DSL is to fill the gap between developers and domain experts.
    It’s rare for the person who writes the code that implements the business logic
    of an application to also have deep knowledge in the business field in which the
    program will be used. Writing this business logic in a language that non-developers
    can understand doesn’t turn domain experts into programmers, but it does allow
    them to read and validate the logic.
  id: totrans-864
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DSL的主要目的是填补开发者和领域专家之间的差距。编写实现应用程序业务逻辑的代码的人通常对程序将要使用的业务领域没有深入的了解。用非开发者可以理解的语言编写这种业务逻辑并不会使领域专家成为程序员，但它确实使他们能够阅读和验证逻辑。
- en: The two main categories of DSLs are *internal* (implemented in the same language
    used to develop the application in which the DSL will be used) and *external*
    (using a different language designed ad hoc). Internal DSLs require less development
    effort but have a syntax constrained by the hosting language. External DSLs offer
    a higher degree of flexibility but are harder to implement.
  id: totrans-865
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DSL（领域特定语言）的两大主要类别是*内部*（在用于开发将使用DSL的应用程序的同一种语言中实现）和*外部*（使用专门设计的不同语言）。内部DSL需要较少的开发工作量，但语法受到宿主语言的限制。外部DSL提供了更高的灵活性，但实现起来更困难。
- en: It’s possible to develop a polyglot DSL by using another programming language
    already available on the JVM, such as Scala or Groovy. These languages are often
    more flexible and concise than Java. Integrating them with Java requires a more-complex
    building process, however, and their interoperability with Java can be far from
    seamless.
  id: totrans-866
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以通过使用JVM上已经可用的另一种编程语言来开发多语言DSL，例如Scala或Groovy。这些语言通常比Java更灵活、更简洁。然而，将它们与Java集成需要更复杂的构建过程，并且它们与Java的互操作性可能远非无缝。
- en: Due to its verbosity and rigid syntax, Java isn’t the ideal programming language
    to use to develop internal DSLs, but the introduction of lambda expressions and
    method references in Java 8 hugely improved this situation.
  id: totrans-867
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于其冗长和严格的语法，Java并不是开发内部DSL的理想编程语言，但Java 8中lambda表达式和方法引用的引入极大地改善了这种情况。
- en: Modern Java already provides small DSLs in its native API. These DSLs, like
    the ones in the `Stream` and `Collectors` classes, are useful and convenient,
    particularly for sorting, filtering, transforming, and grouping collections of
    data.
  id: totrans-868
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现代Java已经在其原生API中提供了小的DSL。这些DSL，如`Stream`和`Collectors`类中的那些，对于排序、过滤、转换和分组数据集合非常有用和方便。
- en: The three main patterns used to implement DSLs in Java are method chaining,
    nested functions, and function sequencing. Each pattern has pros and cons, but
    you can combine all three patterns in a single DSL to take advantage of all three
    techniques.
  id: totrans-869
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Java中实现DSL所使用的三个主要模式是方法链、嵌套函数和函数序列。每种模式都有其优缺点，但你可以在单个DSL中结合所有三种模式，以利用所有三种技术。
- en: 'Many Java frameworks and libraries allow their features to be used through
    a DSL. This chapter looked at three of them: jOOQ, an SQL mapping tool; Cucumber,
    a BDD framework; and Spring Integration, a Spring extension that implements Enterprise
    Integration Patterns.'
  id: totrans-870
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多Java框架和库允许通过领域特定语言（DSL）使用其功能。本章探讨了其中的三个：jOOQ，一个SQL映射工具；Cucumber，一个行为驱动开发（BDD）框架；以及Spring
    Integration，一个实现企业集成模式的Spring扩展。
