- en: 7 Finding hidden issues using profiling techniques
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 7 使用剖析技术寻找隐藏问题
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Sampling an app’s execution to find the currently executing methods
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对应用程序执行进行采样以找到当前正在执行的方法
- en: Observing execution times
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 观察执行时间
- en: Identifying SQL queries the app executes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别应用程序执行的SQL查询
- en: In chapter 6, I said a profiler is a powerful tool that can show you a path
    when all the lights have gone out. But what we discussed was just a small part
    of the profiler’s capabilities. A profiler offers powerful tools for investigating
    an app’s execution, and learning to use these tools properly can help you in many
    scenarios.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在第6章中，我说过分析器是一个强大的工具，可以在所有灯光都熄灭时为你指明一条道路。但我们讨论的只是分析器能力的一小部分。分析器为调查应用程序的执行提供了强大的工具，学会正确使用这些工具可以在许多场景中帮助你。
- en: 'In many cases, I have had to evaluate or investigate app executions for codebases
    I could barely read—old apps with poorly modeled code design, which some companies
    kept hidden in a wardrobe. In such cases, the profiler was the only efficient
    way to find what was executing when a specific capability was triggered. Now you
    can see why I compared a profiler with the light of Eärendil: as Galadriel says,
    it really was a light in many dark places where all the other lights were out.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，我不得不评估或调查我几乎无法阅读的代码库中的应用程序执行——一些公司将其隐藏在衣柜中的旧应用程序，其代码设计不佳。在这种情况下，分析器是找到在特定功能被触发时正在执行什么的唯一有效方法。现在你可以看到为什么我把分析器比作Eärendil的光：正如加拉德丽尔所说，它真的是许多黑暗地方的灯光，其他所有灯光都已熄灭。
- en: 'In this chapter, we will analyze three investigation techniques through profiling,
    which I consider extremely valuable:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过剖析分析三种调查技术，我认为这些技术非常有价值：
- en: Sampling for finding out what part of an app’s code executes
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 采样以找出应用程序代码的哪个部分在执行
- en: Profiling the execution (also called *instrumentation*) to identify wrong behavior
    and optimization
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 剖析执行（也称为*仪器化*）以识别错误行为和优化
- en: Profiling the app to identify SQL queries it uses to communicate with a database
    management system (DBMS)
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 剖析应用程序以识别其用于与数据库管理系统（DBMS）通信的SQL查询
- en: We’ll continue our discussion in chapter 8 on advanced visualization techniques
    of an app’s execution. When used appropriately, these techniques can save you
    a lot of time finding the causes of various issues. Unfortunately, even though
    these techniques are powerful, many developers are unfamiliar with them. Some
    developers know these techniques exist but tend to believe they are difficult
    to use (in this chapter I’ll show you the opposite is true). Consequently, they
    try using other methods to solve problems that could be solved much more efficiently
    with a profiler (as presented in this chapter).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第8章继续讨论应用程序执行的先进可视化技术。当适当使用时，这些技术可以节省你大量时间来找到各种问题的原因。不幸的是，尽管这些技术很强大，但许多开发者对它们不熟悉。一些开发者知道这些技术存在，但往往认为它们难以使用（在本章中，我将向你展示事实正好相反）。因此，他们尝试使用其他方法来解决可以用分析器（如本章所示）更高效解决的问题。
- en: To make sure you properly understand how to use these techniques and what issues
    can be investigated, I created four small projects. We’ll use these projects to
    apply the profiling techniques we discuss. Section 7.1 discusses sampling—a technique
    you use to identify what code executes at a given time. In section 7.2, you’ll
    learn how a profiler can provide more details about the execution than sampling
    can offer. Section 7.3 discusses how to use a profiler to get details about SQL
    queries an app sends to a DBMS.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保你正确理解如何使用这些技术以及可以调查哪些问题，我创建了四个小型项目。我们将使用这些项目来应用我们讨论的剖析技术。第7.1节讨论了采样——这是一种用于识别在特定时间执行哪些代码的技术。在第7.2节中，你将了解分析器如何提供比采样更多的执行细节。第7.3节讨论了如何使用分析器获取应用程序发送给数据库管理系统（DBMS）的SQL查询的详细信息。
- en: 7.1 Sampling to observe executing code
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.1 采样以观察执行代码
- en: What is sampling, and how can it benefit you? Sampling is an approach in which
    you use a profiler to identify what code the app executes. Sampling doesn’t provide
    many details about the execution, but it draws the big picture of what happens,
    giving you valuable information on what you need to analyze further. For this
    reason, sampling should always be the first step when profiling an app, and, as
    you’ll see, sampling may even be enough in many cases. For this section, I prepared
    project da-ch7-ex1\. We’ll use a profiler to sample this app and understand how
    we can use VisualVM to identify issues related to the execution time of a given
    capability.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是采样，它如何对你有益？采样是一种使用分析器来识别应用程序执行哪些代码的方法。采样不会提供关于执行的许多细节，但它描绘了发生的大致情况，为你提供了关于你需要进一步分析的有价值信息。因此，在分析应用程序时，采样始终应该是第一步，而且，正如你将看到的，在许多情况下，采样甚至可能足够。对于本节，我准备了项目
    da-ch7-ex1\. 我们将使用分析器来采样此应用程序，并了解我们如何使用 VisualVM 识别与特定功能执行时间相关的问题。
- en: The project we’ll use to demonstrate sampling is a tiny app that exposes an
    endpoint, `/demo`. When someone calls this endpoint using cURL, Postman, or a
    similar tool, the app further calls an endpoint exposed by [httpbin.org](http://httpbin.org/).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用的一个用于演示采样的项目是一个小型应用程序，它暴露了一个端点 `/demo`。当有人使用 cURL、Postman 或类似工具调用此端点时，应用程序会进一步调用由
    [httpbin.org](http://httpbin.org/) 暴露的端点。
- en: I like using [httpbin.org](http://httpbin.org/) for many examples and demonstrations.
    [Httpbin.org](http://httpbin.org/) is an open source web app and tool written
    in Python that exposes mock endpoints you can use to test different things you’re
    implementing.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢使用 [httpbin.org](http://httpbin.org/) 来演示许多示例和演示。[Httpbin.org](http://httpbin.org/)
    是一个开源的用 Python 编写的 Web 应用程序和工具，它暴露了你可以用来测试你实现的不同内容的模拟端点。
- en: Here, we call an endpoint where [httpbin.org](http://httpbin.org/) responds
    with a given delay. We’ll use a 5-second delay for this example to simulate a
    latency scenario in our app, and [httpbin.org](http://httpbin.org/) simulates
    the root cause of the problem.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们调用一个端点，[httpbin.org](http://httpbin.org/) 以给定的延迟响应。我们将在这个示例中使用 5 秒的延迟来模拟应用程序中的延迟场景，而
    [httpbin.org](http://httpbin.org/) 模拟了问题的根本原因。
- en: With latency, we understand how an app reacts slower than expected.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 对于延迟，我们理解应用程序的反应速度比预期慢。
- en: '![](../../OEBPS/Images/icon_guy3.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/icon_guy3.png)'
- en: The scenario is also visually represented in figure 7.1.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这种场景也在图 7.1 中进行了视觉表示。
- en: '![](../../OEBPS/Images/CH07_F01_Spilca3.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH07_F01_Spilca3.png)'
- en: 'Figure 7.1 The app we are investigating exposes an endpoint: `/demo`. When
    you call this endpoint, you must wait for 5 seconds for the app to respond. We
    need to understand why it takes so long for the endpoint to respond. We know our
    app calls a mock endpoint from [httpbin.org](http://httpbin.org/), which causes
    the delay, but we want to learn how to investigate this scenario with a profiler.
    This way, you’ll know how to use similar techniques for real-world situations.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.1 我们正在调查的应用程序暴露了一个端点：`/demo`。当你调用此端点时，你必须等待 5 秒以等待应用程序响应。我们需要了解为什么端点响应需要这么长时间。我们知道我们的应用程序从
    [httpbin.org](http://httpbin.org/) 调用一个模拟端点，这导致了延迟，但我们要学习如何使用分析器来调查这种场景。这样，你就会知道如何使用类似的技术来解决现实世界中的问题。
- en: 'The profiling approach has two steps:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 分析方法分为两个步骤：
- en: Sampling to find out what code executes and where you should go into more detail
    (the approach we discuss in this section).
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 采样以找出执行了哪些代码以及你应该在哪里进行更详细的调查（本节中讨论的方法）。
- en: Profiling (also called *instrumentation*) to get more details about the execution
    of specific pieces of code.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分析（也称为 *instrumentation*）以获取有关特定代码执行更多细节。
- en: Sometimes step 1 (sampling) is enough to understand a problem, and you may not
    need to profile the app (step 2). As you’ll learn in this chapter and chapters
    8 to 10, profiling can provide more details about the execution if needed. But
    first you need to know what part of the code to profile, and for that, you use
    sampling.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 有时步骤 1（采样）就足以理解一个问题，你可能不需要分析应用程序（步骤 2）。正如你将在本章和第 8 章到第 10 章中学习的，如果需要，分析可以提供更多关于执行的细节。但首先，你需要知道要分析代码的哪个部分，而为此，你使用采样。
- en: How does the problem occur in our example? When calling the `/demo` endpoint,
    the execution takes 5 seconds (figure 7.2), which we consider too long. Ideally,
    we want the execution to take less than 1 second, so we need to understand why
    calling the `/demo` endpoint takes so long. What causes the latency? Is it our
    app, or something else?
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，问题是如何发生的？当调用`/demo`端点时，执行需要5秒钟（如图7.2），我们认为这太长了。理想情况下，我们希望执行时间少于1秒，因此我们需要了解为什么调用`/demo`端点需要这么长时间。延迟是由什么引起的？是我们的应用程序，还是其他原因？
- en: When you investigate a slowness problem in an unknown codebase, using a profiler
    should be your first choice. The problem doesn’t necessarily need to involve an
    endpoint. For this example, an endpoint was the easiest solution. But in any situation
    involving slowness—calling an endpoint, executing a process, or using a simple
    method call on a particular event—a profiler should be your first option.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在未知代码库中调查缓慢问题时，使用分析器应该是你的首选。问题不一定需要涉及端点。在这个例子中，端点是最简单的解决方案。但在任何涉及缓慢的情况——调用端点、执行进程或对特定事件进行简单方法调用——分析器都应该是你的首选。
- en: '![](../../OEBPS/Images/CH07_F02_Spilca3.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图7.2](../../OEBPS/Images/CH07_F02_Spilca3.png)'
- en: Figure 7.2 When the endpoint is called (in this figure, using cURL), the app
    takes about 5 seconds to respond. In our scenario, we use a profiler to investigate
    this latency problem.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2 当调用端点时（在这个图中，使用cURL），应用程序大约需要5秒钟来响应。在我们的场景中，我们使用分析器来调查这个延迟问题。
- en: First, start the app and then VisualVM (the profiler we will use for our investigations).
    Remember to add the VM option `-Djava.rmi.server.hostname=localhost,` as we discussed
    in chapter 6\. This allows VisualVM to connect to the process. Select the process
    from the list on the left, and then select the Sampler tab, as presented in figure
    7.3, to start sampling the execution.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，启动应用程序，然后启动VisualVM（我们将用它来进行调查）。记住要添加VM选项`-Djava.rmi.server.hostname=localhost,`，正如我们在第6章中讨论的那样。这允许VisualVM连接到进程。从左侧的列表中选择进程，然后选择采样标签，如图7.3所示，以开始采样执行。
- en: '![](../../OEBPS/Images/CH07_F03_Spilca3.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图7.3](../../OEBPS/Images/CH07_F03_Spilca3.png)'
- en: Figure 7.3 To start sampling the execution, select the process from the list
    on the left side, and then select the Sampler tab.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3 要开始采样执行，从左侧的列表中选择进程，然后选择采样标签。
- en: 'Sampling the execution has three purposes:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 采样执行有三个目的：
- en: '*To find out what code executes*—Sampling shows you what executes behind the
    scenes and is an excellent way to find the part of the app you need to investigate.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*为了找出什么代码在执行*——采样显示了幕后执行的代码，这是找到需要调查的应用程序部分的一种极好方式。'
- en: '*To identify CPU consumption*—We’ll use this to investigate latency issues
    and understand which methods share execution time.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*为了识别CPU消耗*——我们将使用它来调查延迟问题并了解哪些方法共享执行时间。'
- en: '*To identify memory consumption*—This allows us to analyze memory-related issues.
    We’ll discuss sampling and profiling memory more in chapter 11.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*为了识别内存消耗*——这允许我们分析与内存相关的问题。我们将在第11章中更详细地讨论采样和内存分析。'
- en: '![](../../OEBPS/Images/CH07_F04_Spilca3.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图7.4](../../OEBPS/Images/CH07_F04_Spilca3.png)'
- en: Figure 7.4 The profiler shows all the active threads in a list. You can expand
    each item to see the execution stack and an approximate execution time. When the
    app executes, the newly created threads appear in the list, and you can analyze
    their execution.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4 分析器以列表形式显示所有活动线程。你可以展开每个项目以查看执行堆栈和近似执行时间。当应用程序执行时，新创建的线程会出现在列表中，你可以分析它们的执行。
- en: Select CPU (as shown in figure 7.4) to start sampling performance data. VisualVM
    displays a list of all the active threads and their stack traces. The profiler
    then intercepts the process execution and displays all the methods called and
    the approximate execution time. When you call the `/demo` endpoint, the profiler
    shows what happens behind the scenes when the app executes that capability.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 选择CPU（如图7.4所示）以开始采样性能数据。VisualVM显示所有活动线程及其堆栈跟踪。然后分析器拦截进程执行并显示所有调用的方法和近似执行时间。当你调用`/demo`端点时，分析器会显示应用程序执行该功能时幕后发生的事情。
- en: '![](../../OEBPS/Images/CH07_F05_Spilca3.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图7.5](../../OEBPS/Images/CH07_F05_Spilca3.png)'
- en: Figure 7.5 The stack trace shows what the app executes. You can see every method
    and each subsequent method that is called. This view helps you quickly find the
    code you want to focus on when investigating a certain capability.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5 堆栈跟踪显示了应用程序执行的代码。你可以看到每个方法和随后调用的每个方法。这种视图有助于你在调查特定功能时快速找到想要关注的代码。
- en: We can now call the `/demo` endpoint and observe what happens. As shown in figure
    7.5, some new threads appear in the list. The app started these threads when we
    called the `/demo` endpoint. When you open them, you should see precisely what
    the app does during its execution.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以调用 `/demo` 端点并观察会发生什么。如图 7.5 所示，列表中出现了一些新的线程。当调用 `/demo` 端点时，应用启动了这些线程。当你打开它们时，你应该能够精确地看到应用在执行过程中的行为。
- en: 'Before I discuss details such as the execution time, I want to highlight how
    vital this first step is. Many times when I’ve analyzed code, I used just sampling
    to figure out where to look for the problem. I may not have even been investigating
    a performance or latency issue but was simply looking for the point to start debugging.
    Remember our discussions in chapters 2 to 4: to debug something, you need to know
    where to add that breakpoint to pause the app’s execution. If you have no clue
    where to add a breakpoint, you can’t debug. Sampling can be a way to shed some
    light on a situation when you can’t figure out where to start debugging (especially
    in cases like those I mentioned at the beginning of the chapter in which an app
    lacks clean code design).'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在我讨论执行时间等细节之前，我想强调这个第一步是多么重要。很多时候，当我分析代码时，我只是使用采样来确定查找问题的位置。我可能甚至没有在调查性能或延迟问题，而只是在寻找开始调试的点。记住我们第
    2 章到第 4 章的讨论：要调试某个东西，你需要知道在哪里添加断点来暂停应用的执行。如果你不知道在哪里添加断点，你就无法调试。采样可以在你不知道从哪里开始调试的情况下为你提供一些线索（特别是在本章开头提到的那些情况下，应用缺乏清晰的代码设计）。
- en: Let’s look at the execution stack to understand what the profiler shows us.
    When you want to figure out what code executes, you simply expand the stack trace
    up to the point where it displays the methods of the app you are interested in.
    When you are investigating a latency problem (as in this example), you can expand
    the stack trace to observe the maximum execution time, as shown in figure 7.6.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们查看执行堆栈以了解分析器向我们展示了什么。当你想要找出哪些代码正在执行时，你只需展开堆栈跟踪，直到它显示你感兴趣的应用的函数。当你调查一个延迟问题（如本例所示）时，你可以展开堆栈跟踪以观察最大执行时间，如图
    7.6 所示。
- en: '![](../../OEBPS/Images/CH07_F06_Spilca3.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH07_F06_Spilca3.png)'
- en: Figure 7.6 When you expand the execution stack, you find which methods execute
    and how much time they spend executing. You can also deduce how long they wait
    and how much they work. The profiler shows both the app’s codebase methods and
    the methods called from specific dependencies (libraries or frameworks) the app
    uses.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.6 当你展开执行堆栈时，你可以找到哪些方法正在执行以及它们执行花费了多长时间。你还可以推断出它们等待了多久以及它们工作了多少。分析器显示了应用的代码库方法以及应用使用的特定依赖项（库或框架）中调用的方法。
- en: 'I expanded the execution stack by selecting the small (+) button in the last
    method. The profiler shows it took about 5 seconds to understand the execution
    and find which method causes the latency. In this particular case, we see that
    just one method causes the slowness: `getResponseCode()` of the `HttpURLConnection`
    class.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我通过选择最后一个方法中的小 (+) 按钮来展开执行堆栈。分析器显示，理解执行并找到导致延迟的方法大约花费了 5 秒。在这种情况下，我们看到只有一个方法导致了缓慢：`HttpURLConnection`
    类的 `getResponseCode()` 方法。
- en: TIP Remember that it’s not always one method that spends all the execution time
    in real-world scenarios. You’ll often find that the time spent is shared among
    multiple methods that execute. The rule is to first focus on the method that takes
    the longest time to execute.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：记住，在现实世界的场景中，并不总是只有一个方法花费了所有的执行时间。你经常会发现，时间被多个执行的方法所共享。规则是首先关注执行时间最长的那个方法。
- en: '![](../../OEBPS/Images/icon_girl2.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/icon_girl2.png)'
- en: An important aspect of this example is that the CPU time (how long the method
    works) is zero. Although the method spends 5 seconds in execution, it doesn’t
    use CPU resources because it is waiting for the HTTP call to end and to get a
    response. We can conclude that the problem is not in the app; rather, it’s slow
    only because it waits for a response to its HTTP request.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 本例的一个重要方面是 CPU 时间（方法工作的时间）为零。尽管该方法在执行过程中花费了 5 秒，但它没有使用 CPU 资源，因为它正在等待 HTTP 调用结束并获取响应。我们可以得出结论，问题不在于应用；相反，它之所以缓慢，仅仅是因为它等待
    HTTP 请求的响应。
- en: 'It’s extremely valuable to differentiate between the total CPU time and the
    total execution time. If a method spends CPU time, it means the method “works.”
    To improve the performance in such a case, you usually have to adjust (if possible)
    the algorithm to minimize its complexity. If the execution spends a small amount
    of CPU time but has a long execution time, the method is likely waiting for something:
    an action may take a long time, but the app doesn’t do anything. In this case,
    you need to figure out what your app is waiting for.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 区分总CPU时间和总执行时间非常有价值。如果一个方法消耗CPU时间，这意味着该方法“工作”了。在这种情况下，为了提高性能，你通常必须调整（如果可能）算法以最小化其复杂性。如果一个方法的执行消耗了少量的CPU时间但具有较长的执行时间，那么这个方法很可能是正在等待某事：一个动作可能需要很长时间，但应用什么也不做。在这种情况下，你需要弄清楚你的应用正在等待什么。
- en: Another essential aspect to observe is that the profiler doesn’t just intercept
    your app’s codebase. You can see that the dependencies’ methods are also called
    during the app’s execution. In this example, the app uses a dependency named OpenFeign
    to call the `httpbin.org` endpoint. You can see this in the stack trace packages
    that don’t belong to your app’s codebase. These packages are part of the dependencies
    your app uses to implement its capabilities. OpenFeign can be one of them, like
    in this example.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要观察的重要方面是，分析器不仅拦截你的应用代码库。你可以看到，在应用执行期间也会调用依赖项的方法。在这个例子中，应用使用名为OpenFeign的依赖项来调用`httpbin.org`端点。你可以在不属于你应用代码库的堆栈跟踪包中看到这一点。这些包是你应用用来实现其功能的依赖项的一部分。OpenFeign可能是其中之一，就像这个例子一样。
- en: OpenFeign is a project from the Spring ecosystem of technologies that a Spring
    app can use to call REST endpoints. Since this example is a Spring app, you will
    find packages of Spring-related technologies in the stack trace. You don’t have
    to understand what each part of the stack trace does. You won’t know this in a
    real-world scenario either. In fact, this book is about understanding code that
    you don’t yet know. If you want to learn Spring, I recommend starting with *Spring
    Start Here* (Manning, 2021), another book I wrote. You’ll also find details about
    OpenFeign in *Spring Start Here*.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: OpenFeign是Spring技术生态系统中的一项项目，Spring应用可以使用它来调用REST端点。由于这个例子是一个Spring应用，你将在堆栈跟踪中找到与Spring相关的技术包。你不需要了解堆栈跟踪的每一部分做什么。在现实世界的场景中，你也不会知道这一点。实际上，这本书是关于理解你还不了解的代码。如果你想学习Spring，我建议从*Spring
    Start Here*（Manning，2021）开始，这是另一本我写的书。你还可以在*Spring Start Here*中找到关于OpenFeign的详细信息。
- en: Why is observing dependencies’ methods so important? Because, sometimes, it’s
    almost impossible to figure out what executes from a given dependency using other
    means. Look at the code written in our app to call the `httpbin.org` endpoint
    (see listing 7.1). You can’t see the actual implementation for sending the HTTP
    request. That’s because, as happens in many Java frameworks today, the dependency
    uses dynamic proxies to decouple the implementation.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么观察依赖项的方法如此重要？因为，有时，使用其他方法几乎不可能确定给定依赖项的执行内容。看看我们应用中编写的调用`httpbin.org`端点的代码（参见列表7.1）。你无法看到发送HTTP请求的实际实现。这是因为，正如今天许多Java框架所发生的那样，依赖项使用动态代理来解耦实现。
- en: Listing 7.1 The HTTP client implementation using OpenFeign
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.1 使用OpenFeign的HTTP客户端实现
- en: '[PRE0]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Dynamic proxies* give an app a way to choose a method implementation at run
    time. When an app capability uses dynamic proxies, it might actually call a method
    declared by an interface without knowing what implementation it will be given
    to execute at run time (figure 7.7). It is easier to use the framework’s capabilities,
    but the disadvantage is that you don’t know where to investigate an issue.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*动态代理*为应用提供了一种在运行时选择方法实现的方式。当一个应用功能使用动态代理时，它实际上可能调用一个接口声明的方 法，而不知道在运行时会给它什么实现来执行（图7.7）。使用框架的功能更容易，但缺点是不知道在哪里调查问题。'
- en: '![](../../OEBPS/Images/CH07_F07_Spilca3.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH07_F07_Spilca3.png)'
- en: Figure 7.7 The framework keeps the implementations for an abstraction separate
    and provides them dynamically during execution. Because the implementation is
    decoupled and the app provides it during run time, it’s more difficult to find
    it by reading the code.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.7 框架将抽象的实现保持独立，并在执行期间动态提供它们。因为实现是解耦的，并且应用在运行时提供它，所以通过阅读代码很难找到它。
- en: One of my personal uses for sampling is when learning a new framework or library.
    Sampling helps me to understand what executes behind the scenes in a new functionality.
    I applied this approach when learning Hibernate and Spring Security, which have
    complex functionality, and it helped me quickly understand how to work with the
    given capabilities.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我个人使用采样的一种情况是在学习一个新的框架或库时。采样帮助我理解新功能背后执行的内容。我在学习Hibernate和Spring Security时应用了这种方法，这两个框架功能复杂，这帮助我快速理解如何使用给定的功能。
- en: '![](../../OEBPS/Images/icon_guy3.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图标](../../OEBPS/Images/icon_guy3.png)'
- en: 7.2 Profiling to learn how many times a method executed
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.2 分析以了解方法执行了多少次
- en: Finding what code executes is essential, but sometimes it is not enough. Often,
    we need more details to precisely understand a given behavior. For example, sampling
    does not provide the number of method invocations. An app may take only 50 milliseconds
    to execute, but if it calls the method a thousand times, then it takes 50 seconds
    to execute when sampling. To demonstrate how to get details about the execution
    using a profiler and to identify situations where this is useful, we’ll again
    use some projects provided with the book. We’ll start with project da-ch7-ex1,
    which we also used in section 7.1, but this time we’ll discuss profiling for details
    about the execution.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 找到执行哪些代码是至关重要的，但有时这还不够。我们经常需要更多细节来精确理解给定的行为。例如，采样不提供方法调用的次数。一个应用程序可能只花费50毫秒执行，但如果它调用方法一千次，那么在采样时它将花费50秒来执行。为了演示如何使用分析器获取执行细节并确定何时有用，我们将再次使用书中提供的一些项目。我们将从项目da-ch7-ex1开始，我们也在7.1节中使用过，但这次我们将讨论关于执行细节的分析。
- en: Start the app provided with project da-ch7-ex1\. When you profile an app, you
    shouldn’t investigate the entire codebase. Instead, you need to filter only on
    what’s essential to your investigation. Profiling is a very resource-consuming
    operation, so unless you have a really powerful system, profile everything would
    take a ton of time. That’s one more reason we always start with sampling—to identify
    what to profile further if needed.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 启动项目da-ch7-ex1提供的应用程序。当您分析应用程序时，您不应该调查整个代码库。相反，您只需要过滤对您调查至关重要的部分。分析是一个非常消耗资源的操作，所以除非您有一个非常强大的系统，否则分析整个应用程序将花费大量时间。这也是我们总是从采样开始的原因之一——如果需要，确定进一步分析的部分。
- en: TIP Never profile the app’s entire codebase. You should always first decide,
    based on sampling, which part of the app you want to profile to get more details.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：永远不要分析应用程序的整个代码库。您应该首先基于采样决定您想要分析以获取更多细节的应用程序部分。
- en: '![](../../OEBPS/Images/icon_girl2.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图标](../../OEBPS/Images/icon_girl2.png)'
- en: For this example, we’ll ignore the app’s codebase (without dependencies) and
    only take OpenFeign classes from the dependencies. Be aware that you can’t refer
    to an app’s entire code in a real-world app since that would likely be time- and
    resource-consumptive. For this small example, it won’t be a problem, but for large
    apps, always restrict the intercepted code as much as possible when profiling.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将忽略应用程序的代码库（不包括依赖项），只从依赖项中获取OpenFeign类。请注意，在实际应用程序中，您不能引用整个应用程序的代码，因为这可能会消耗大量时间和资源。在这个小例子中，这不会成为问题，但对于大型应用程序，在分析时始终尽可能限制拦截的代码。
- en: 'In figure 7.8, you see how to apply these restrictions. On the right side of
    the Profiler tab, you can specify which part of the app to intercept. In this
    example, we use the following:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在图7.8中，您可以看到如何应用这些限制。在“分析器”标签页的右侧，您可以指定要拦截应用程序的哪个部分。在这个例子中，我们使用以下设置：
- en: '`com.example.**`—The code in all the packages and subpackages of `com.example`'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`com.example.**`—`com.example`所有包和子包中的代码'
- en: '`feign.**`—Code in all the packages and subpackages of `feign`'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`feign.**`—`feign`所有包和子包中的代码'
- en: '![](../../OEBPS/Images/CH07_F08_Spilca3.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图标](../../OEBPS/Images/CH07_F08_Spilca3.png)'
- en: Figure 7.8 Profiling a part of the app during execution to get details about
    the times a given method was invoked. We can see that the method causing the 5
    seconds of latency is invoked only once, meaning the number of invocations doesn’t
    cause a problem here.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.8 在执行过程中分析应用程序的一部分以获取给定方法被调用的次数的详细信息。我们可以看到导致5秒延迟的方法只被调用了一次，这意味着调用次数在这里不会引起问题。
- en: 'The syntax you can use to filter the packages and classes you want to profile
    has just a few simple rules:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下简单规则来过滤您想要分析包和类：
- en: Write each rule on a separate line.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将每条规则写在单独的一行上。
- en: Use one asterisk (*) to refer to a package; for example, we could use `com.example.*`
    if we wanted to profile all classes in the package `com.example`.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用一个星号（*）来引用一个包；例如，如果我们想分析 `com.example` 包中的所有类，我们可以使用 `com.example.*`。
- en: Use two asterisks (**) to refer to a package and all its subpackages. In this
    case, by using `com.example.**`, we mean all classes in the package `com.example`
    as well as any of its subpackages.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用两个星号（**）来引用一个包及其所有子包。在这种情况下，通过使用 `com.example.**`，我们指的是 `com.example` 包中的所有类以及其任何子包中的类。
- en: Write the full name of a class if you want to profile only that class; for example,
    we could use `com.example.controllers.DemoController` to profile only this class.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你只想分析某个类，请写出该类的全名；例如，我们可以使用 `com.example.controllers.DemoController` 来仅分析这个类。
- en: I chose these packages after sampling the execution, as discussed in section
    7.1\. Because I observed that the method call with the latency problem comes from
    classes of the `feign` package, I decided to add this package and its subpackages
    to the list to get more information.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我在 7.1 节中讨论的采样执行后选择了这些包。因为我观察到具有延迟问题的方法调用来自 `feign` 包的类，所以我决定将这个包及其子包添加到列表中，以获取更多信息。
- en: 'In this particular case, the number of invocations doesn’t seem to cause issues:
    the method executes only once and takes about 5 seconds to finish its execution.
    A small number of method invocations implies that we don’t have repeated unnecessary
    executions (which, as you’ll learn later in this chapter, is a common problem
    in many apps).'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个特定情况下，调用次数似乎并没有引起问题：该方法只执行一次，并且大约需要 5 秒钟来完成其执行。少量方法调用意味着我们没有重复不必要的执行（正如你将在本章后面学到的那样，这是许多应用程序中常见的问题）。
- en: In another scenario, you may have observed that the call to the given endpoint
    takes just 1 second, but the method is (because of some poor design) called 5
    times. Then, the problem would have been in the app, and we would know how and
    where to solve it. In section 7.3, we’ll analyze such a problem.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一种情况下，你可能观察到对给定端点的调用仅花费了 1 秒钟，但方法（由于某些设计不佳）被调用了 5 次。那么，问题就出在应用程序中，我们就知道如何以及在哪里解决它。在第
    7.3 节中，我们将分析这样的问题。
- en: 7.3 Using a profiler to identify SQL queries an app executes
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.3 使用分析器识别应用程序执行的 SQL 查询
- en: In this section, you’ll learn how to use a profiler to identify SQL queries
    an app sends to a DBMS. This subject is by far one of my favorites. Today, almost
    every app uses at least one relational database, and almost all scenarios encounter
    latencies caused by SQL queries from time to time. Moreover, today, apps use fancier
    ways to implement the persistence layer; in many cases, the SQL queries that the
    app sends are created dynamically by a framework or library. These dynamically
    generated queries are hard to identify, but a profiler can do some magic and greatly
    simplify your investigation.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习如何使用分析器来识别应用程序发送给数据库管理系统的 SQL 查询。这个主题无疑是我的最爱之一。如今，几乎每个应用程序都至少使用一个关系型数据库，而且几乎在所有情况下，都会时不时地遇到由
    SQL 查询引起的延迟。此外，如今的应用程序使用更高级的方法来实现持久层；在许多情况下，应用程序发送的 SQL 查询是由框架或库动态创建的。这些动态生成的查询难以识别，但分析器可以施展一些魔法，极大地简化你的调查。
- en: We’ll use a scenario implemented with project da-ch7-ex2 to learn how many times
    a method executes and intercepts a SQL query the app runs on a relational database.
    We’ll then demonstrate that the executed SQL queries can be retrieved even when
    the app works with a framework and doesn’t handle the queries directly. Finally,
    we’ll discuss this subject further using a couple of examples.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用项目 da-ch7-ex2 实现的场景来学习一个方法执行了多少次，并拦截应用程序在关系型数据库上运行的 SQL 查询。然后，我们将演示即使在应用程序与框架一起工作且不直接处理查询的情况下，也可以检索执行的
    SQL 查询。最后，我们将通过几个示例进一步讨论这个主题。
- en: 7.3.1 Using a profiler to retrieve SQL queries not generated by a framework
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3.1 使用分析器检索框架未生成的 SQL 查询
- en: This section uses an example to demonstrate how to use a profiler to obtain
    the SQL queries an app executes. We’ll use a simple app that sends the queries
    directly to a DBMS directly without using a framework.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 本节通过一个示例演示如何使用分析器获取应用程序执行的 SQL 查询。我们将使用一个简单的应用程序，该应用程序直接将查询发送到数据库管理系统，而不使用框架。
- en: Let’s start project da-ch7-ex2 and use the Profiler tab, as you learned in section
    7.2\. Project da-ch7-ex2 is also a small app. It configures an in-memory database
    with two tables (product and purchase) and populates the tables with a few records.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始项目 da-ch7-ex2 并使用“分析器”选项卡，正如你在第 7.2 节中学到的。项目 da-ch7-ex2 也是一个小型应用程序。它配置了一个内存数据库，包含两个表（产品表和购买表），并使用一些记录填充了这两个表。
- en: The app exposes all purchased products when calling the endpoint `/products`.
    By “purchased products,” I mean products that have at least one purchase record
    in the purchase table. The purpose is to analyze the app’s behavior when calling
    this endpoint without first analyzing the code. This way, we can see how much
    we can get just by using the profiler.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用 `/products` 端点时，应用程序会公开所有已购买的产品。这里的“已购买产品”指的是在购买表中至少有一条购买记录的产品。目的是在不首先分析代码的情况下分析应用程序调用此端点时的行为。这样，我们可以看到仅通过使用分析器我们可以得到多少信息。
- en: 'In figure 7.9, we use the Profiler tab since you already learned sampling in
    section 7.1, but remember that in any real-world scenario, you start with sampling.
    We start the app, and, using cURL or Postman, we call the `/products` endpoint.
    The profiler shows us precisely what happens:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在图 7.9 中，我们使用“分析器”选项卡，因为你已经学过了第 7.1 节中的采样，但请记住，在任何实际场景中，你都是从采样开始的。我们启动应用程序，并使用
    cURL 或 Postman 调用 `/products` 端点。分析器精确地显示了发生了什么：
- en: A method `findPurchasedProductNames()` that belongs to the `PurchaseController`
    class was called.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用了属于 `PurchaseController` 类的 `findPurchasedProductNames()` 方法。
- en: This method delegated the call to the method `getProductNamesForPurchases``()`
    in class `PurchaseService`.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此方法将调用委托给了 `PurchaseService` 类中的 `getProductNamesForPurchases()` 方法。
- en: The method `getProductNamesForPurchases()` in `ProductService` calls `findAll()`
    in `PurchaseRepository`.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ProductService` 类中的 `getProductNamesForPurchases()` 方法调用了 `PurchaseRepository`
    中的 `findAll()`。'
- en: The method `getProductNamesForPurchases``()` in `ProductService` calls `findProduct()`
    in `ProductRepository` 10 times.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ProductService` 类中的 `getProductNamesForPurchases()` 方法调用了 `ProductRepository`
    中的 `findProduct()` 10 次。'
- en: '![](../../OEBPS/Images/CH07_F09_Spilca3.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH07_F09_Spilca3.png)'
- en: Figure 7.9 When profiling the app, we observe that one of the methods is called
    10 times. We now need to ask ourselves if this is a design issue. Since we now
    have a big picture of the entire algorithm and we know what code is executed,
    we can also debug the app if we can’t figure out what happens.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.9 当分析应用程序时，我们观察到其中一个方法被调用了 10 次。我们现在需要问自己这是否是一个设计问题。因为我们现在对整个算法有了大致的了解，并且知道执行了哪些代码，如果我们无法弄清楚发生了什么，我们还可以调试应用程序。
- en: Isn’t this amazing? We didn’t even look into the code, and we already know a
    lot of things about this execution. These details are fantastic, because now you
    know exactly where to go into the code and what you can expect to find. The profiler
    gave you class names, method names, and how they call each other. Let’s now look
    into the code in listing 7.2 and figure out where all this happens. By using the
    profiler, we can see that most things happen in the `getProductNamesForPurchases()`
    method in the `PurchaseService` class, so that’s most likely the place we need
    to analyze.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这不令人惊叹吗？我们甚至没有查看代码，就已经对这次执行了解了很多。这些细节非常棒，因为现在你知道了确切的位置可以进入代码，以及你可以期望找到什么。分析器给你提供了类名、方法名以及它们是如何相互调用的。现在让我们来看看列表
    7.2 中的代码，并找出所有这些发生的地方。通过使用分析器，我们可以看到大多数事情都发生在 `PurchaseService` 类中的 `getProductNamesForPurchases()`
    方法中，所以这很可能是我们需要分析的地方。
- en: Listing 7.2 The algorithm’s implementation in the `PurchaseService` class
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.2 在 `PurchaseService` 类中实现的算法
- en: '[PRE1]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ Gets all the purchases from the database table
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 从数据库表获取所有购买记录
- en: ❷ Iterates through each product
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 遍历每个产品
- en: ❸ Gets the details about the purchased product
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 获取已购买产品的详细信息
- en: ❹ Adds the product into a set
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 将产品添加到集合中
- en: ❺ Returns the set of products
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 返回产品集合
- en: 'Observe the implemented behavior: the app fetches some data in a list and then
    iterates over it to get more data from the database. Such an implementation typically
    indicates a design issue because you can usually reduce the execution of so many
    queries to one. Obviously, the fewer queries executed, the more efficient the
    app is.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 观察实现的行为：应用程序在列表中获取一些数据，然后迭代它以从数据库中获取更多数据。这样的实现通常表明存在设计问题，因为你通常可以将这么多查询的执行减少到一次。显然，执行的查询越少，应用程序就越高效。
- en: In this example, it’s effortless to retrieve the queries directly from the code.
    Since the profiler shows us exactly where they are, and the app is tiny, finding
    the queries isn’t a problem. But real-world apps are not small, and in many cases,
    it’s not easy to retrieve the queries directly from the code. But fear no more!
    You can use the profiler to retrieve all the SQL queries the app sends to a DBMS.
    You find this demonstrated in figure 7.10\. Instead of selecting the CPU button,
    you select the JDBC button to start profiling for SQL queries.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，直接从代码中检索查询是轻而易举的。由于性能分析器显示了它们的确切位置，并且应用程序很小，因此找到查询不是问题。但是，现实世界的应用程序并不小，在许多情况下，直接从代码中检索查询并不容易。但不必再担心了！你可以使用性能分析器检索应用程序发送给数据库管理系统的所有SQL查询。你可以在图7.10中看到这一演示。不是选择CPU按钮，而是选择JDBC按钮以开始对SQL查询进行性能分析。
- en: '![](../../OEBPS/Images/CH07_F10_Spilca3.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH07_F10_Spilca3.png)'
- en: Figure 7.10 The profiler intercepts the SQL queries the app sends to the DBMS
    through the JDBC driver. This gives you an easy way to get the queries, run them,
    observe what part of the codebase runs them, and know how many times a query is
    executed.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.10 性能分析器拦截了应用程序通过JDBC驱动程序发送到数据库管理系统的SQL查询。这为你提供了一个简单的方法来获取查询，运行它们，观察代码库的哪个部分运行了它们，以及查询执行了多少次。
- en: 'What the tool does behind the scenes is pretty simple: a Java app sends the
    SQL queries to a DBMS through a JDBC driver. The profiler intercepts the driver
    and copies the queries before the driver sends them to the DBMS. Figure 7.11 shows
    this approach. The result is fantastic, as you can simply copy and paste the queries
    in your database client, where you can run them or investigate their plan.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 工具在幕后执行的操作非常简单：Java应用程序通过JDBC驱动程序将SQL查询发送到数据库管理系统。性能分析器拦截驱动程序并在驱动程序将查询发送到数据库管理系统之前复制它们。图7.11显示了这种方法。结果是令人惊叹的，因为你可以直接复制并粘贴查询到你的数据库客户端中，在那里你可以运行它们或调查它们的计划。
- en: '![](../../OEBPS/Images/CH07_F11_Spilca3.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH07_F11_Spilca3.png)'
- en: Figure 7.11 In a Java app, the communication with a relational DBMS is done
    through the JDBC driver. A profiler can intercept all method calls, including
    those of the JDBC driver, and retrieve the SQL queries the app sends to a DBMS.
    You can get the queries and use them in your investigations.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.11 在Java应用程序中，与关系型数据库管理系统的通信是通过JDBC驱动程序完成的。性能分析器可以拦截所有方法调用，包括JDBC驱动程序的方法调用，并检索应用程序发送给数据库管理系统的SQL查询。你可以获取这些查询并在你的调查中使用它们。
- en: The profiler also shows you how many times a query was sent. In this case, the
    app sent the first query 10 times. This design is faulty since it repeats the
    same query multiple times and thus spends unnecessary time and resources. The
    developer who implemented the code tried to obtain the purchases and then get
    the product details for each purchase. But a straightforward query with a join
    between the two tables (product and purchase) would solve the problem in one step.
    Fortunately, using VisualVM, you identified the cause, and you know exactly what
    to change to improve this app.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 性能分析器还显示了查询发送的次数。在这种情况下，应用程序第一次查询发送了10次。这种设计是有缺陷的，因为它多次重复相同的查询，从而浪费了不必要的时间和资源。实现代码的开发者试图获取购买信息，然后获取每个购买的详细信息。但是，通过在两个表（产品和购买）之间进行连接的简单查询就可以一步解决问题。幸运的是，使用VisualVM，你确定了原因，并且你知道如何确切地更改以改进这个应用程序。
- en: Figure 7.12 shows you how to find the part of the codebase that sent the query.
    You can expand the execution stack and usually find the first method in the app’s
    codebase.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.12显示了如何找到发送查询的代码库部分。你可以展开执行堆栈，通常可以在应用程序代码库中找到第一个方法。
- en: '![](../../OEBPS/Images/CH07_F12_Spilca3.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH07_F12_Spilca3.png)'
- en: Figure 7.12 For each query, the profiler also provides the execution stack trace.
    You can use the stack trace to identify which part of your app’s codebase sent
    the query.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.12 对于每个查询，性能分析器还提供了执行堆栈跟踪。你可以使用堆栈跟踪来识别你的应用程序代码库的哪个部分发送了查询。
- en: Listing 7.2 shows the code whose call we identified using the profiler. Once
    you identify where the problem comes from, it’s time to read the code and find
    a way to optimize the implementation. In this example, everything could have been
    merged into one query. It may look like a silly mistake, but trust me, you’ll
    find these types of cases, even in larger apps implemented by powerful organizations.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 列表7.2显示了性能分析器识别的代码。一旦你确定了问题的来源，就是时候阅读代码并找到一种优化实现的方法。在这个例子中，所有内容都可以合并为一个查询。这看起来可能像是一个愚蠢的错误，但请相信我，你甚至会在由强大组织实施的大型应用程序中找到这类情况。
- en: Listing 7.3 The algorithm’s implementation in the `ProductService` class
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.3 `ProductService` 类中算法的实现
- en: '[PRE2]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ The app gets a list of all products.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 应用程序获取所有产品的列表。
- en: ❷ Iterates through each product
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 遍历每个产品
- en: ❸ Gets the product details
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 获取产品详情
- en: 'Example da-ch7-ex2 uses JDBC to send the SQL queries to a DBMS. The app has
    the SQL queries directly in the Java code (listing 7.3) and in their native shape,
    so you may think that copying the queries directly from the code is not that difficult.
    But in today’s apps, you’ll encounter native queries in the code less often. Nowadays,
    many apps use frameworks such as Hibernate (the most-used Java Persistence API
    [JPA] implementation) or Java Object Oriented Querying (JOOQ), and the native
    queries are not directly in the code. (You can find more details about JOOQ on
    their GitHub repository here: [https://github.com/jOOQ/jOOQ](https://github.com/jOOQ/jOOQ)).'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 da-ch7-ex2 使用 JDBC 将 SQL 查询发送到数据库管理系统 (DBMS)。应用程序直接在 Java 代码（列表 7.3）中以原生形式包含
    SQL 查询，因此你可能认为直接从代码中复制查询并不那么困难。但在当今的应用程序中，你不太可能在代码中遇到原生查询。如今，许多应用程序使用诸如 Hibernate（最常用的
    Java 持久化 API [JPA] 实现）或 Java 面向对象查询（JOOQ）之类的框架，而原生查询并不直接在代码中。（你可以在他们的 GitHub 仓库中找到有关
    JOOQ 的更多详细信息：[https://github.com/jOOQ/jOOQ](https://github.com/jOOQ/jOOQ)）。
- en: Listing 7.4 A repository using native SQL queries
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.4 使用原生 SQL 查询的存储库
- en: '[PRE3]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ A native SQL query the app sends to the DBMS
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 应用程序发送到 DBMS 的原生 SQL 查询
- en: 7.3.2 Using the profiler to get the SQL queries generated by a framework
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3.2 使用分析器获取框架生成的 SQL 查询
- en: 'Let’s look at something even more extraordinary. To further prove the usefulness
    of a profiler in investigating SQL queries, let’s review project da-ch7-ex3\.
    From an algorithm point of view, this project does the same thing as the previous
    one: it returns the name of the purchased products. I intentionally kept the same
    logic to simplify the example and make it comparable.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些更加非凡的事情。为了进一步证明分析器在调查 SQL 查询方面的有用性，让我们回顾项目 da-ch7-ex3。从算法的角度来看，这个项目与上一个项目做的是同样的事情：返回购买产品的名称。我故意保留了相同的逻辑以简化示例并使其具有可比性。
- en: The next code fragment shows the definition of a Spring Data JPA repository.
    The repository is a simple interface, and you don’t see the SQL queries anywhere.
    With Spring Data JPA, the app generates the queries behind the scenes based on
    either the method’s names or on a particular way of defining the queries, called
    Java Persistence Query Language (JPQL), which is based on the app’s objects. Either
    way, there’s no simple way to copy and paste the query from the code.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个代码片段显示了 Spring Data JPA 存储库的定义。存储库是一个简单的接口，你无处看到 SQL 查询。使用 Spring Data JPA，应用程序根据方法的名称或以特定方式定义查询的方式（称为
    Java 持久化查询语言 [JPQL]，它基于应用程序的对象）在幕后生成查询。无论哪种方式，都没有简单的方法可以从代码中复制和粘贴查询。
- en: 'Some frameworks generate the SQL queries behind the scenes based on the code
    and configurations you write. In these cases, it’s more challenging to get the
    executed queries. But a profiler can help you by extracting them from the JDBC
    driver before they are sent to the DBMS:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 一些框架根据你编写的代码和配置在幕后生成 SQL 查询。在这些情况下，获取执行的查询更具挑战性。但分析器可以通过在它们发送到 DBMS 之前从 JDBC
    驱动程序中提取它们来帮助你：
- en: '[PRE4]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The profiler comes to the rescue. Since the tool intercepts the queries before
    the app sends them to the DBMS, we can still use it to find exactly what queries
    the app uses. Start app da-ch7-ex3 and use VisualVM to profile the SQL queries
    like we did for the previous two projects.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 分析器来救命。由于该工具在应用程序将查询发送到 DBMS 之前拦截查询，我们仍然可以使用它来找出应用程序使用的确切查询。启动应用程序 da-ch7-ex3
    并使用 VisualVM 分析 SQL 查询，就像我们之前对前两个项目所做的那样。
- en: Figure 7.13 shows you what the tool displays when profiling the `/products`
    endpoint call. The app sent two SQL queries. Notice that the aliases in the query
    have strange names because the queries are framework generated. Also notice that
    even if the logic in the service is the same, and the app calls the repository
    method 10 times, the second query is executed only once because Hibernate optimizes
    the execution where it can. Now you can copy and investigate this query with a
    SQL development client if needed. In many cases, investigating a slow query requires
    running it in a SQL client to observe which part of the query causes difficulty
    for the DBMS.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.13显示了在分析`/products`端点调用时工具显示的内容。应用程序发送了两个SQL查询。请注意，查询中的别名有奇怪的名字，因为查询是由框架生成的。此外，请注意，即使服务中的逻辑相同，并且应用程序调用存储库方法10次，第二个查询也只执行一次，因为Hibernate在可能的情况下优化了执行。现在，如果需要，您可以复制并使用SQL开发客户端调查这个查询。在许多情况下，调查慢查询需要在SQL客户端中运行以观察查询的哪个部分给DBMS带来了困难。
- en: '![](../../OEBPS/Images/CH07_F13_Spilca3.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/CH07_F13_Spilca3.png)'
- en: Figure 7.13 Even when working with a framework, the profiler can still intercept
    the SQL queries. This makes your investigation a lot easier because you can’t
    copy the query directly from the code as you can when using JDBC and native queries.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.13 即使在使用框架时，分析器仍然可以拦截SQL查询。这使得调查变得容易得多，因为您不能像使用JDBC和原生查询那样直接从代码中复制查询。
- en: The query is executed only once even though the method is called 10 times. Do
    persistence frameworks usually do these kinds of tricks? Although they are smart,
    sometimes what they do behind the scenes can add complexity. Also, someone who
    does not properly understand the framework could write code that causes problems.
    This is another reason to use a profiler to check the queries the framework generates
    and make sure the app does what you expect.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 查询只执行一次，即使方法被调用了10次。持久化框架通常会做这类技巧吗？虽然它们很聪明，但有时它们在幕后所做的事情可能会增加复杂性。此外，如果有人没有正确理解框架，可能会编写出导致问题的代码。这也是使用分析器检查框架生成的查询并确保应用程序按预期工作的重要原因。
- en: 'The issues I mostly encounter with frameworks that require investigation are
    as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我遇到的大多数需要调查的框架问题如下：
- en: '*Slow queries causing latencies*—Easy to spot using a profiler to examine the
    execution time'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*慢查询导致的延迟*——使用分析器检查执行时间很容易发现'
- en: '*Multiple unneeded queries generated by the framework* (usually caused by what
    developers call the N+1 query problem)—Easy to spot using a profiler to determine
    the number of executions of a query'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*框架生成的多个不必要的查询*（通常由开发人员称为N+1查询问题引起）——使用分析器确定查询执行次数很容易发现'
- en: '*Long transaction commits generated by poor app design*—Easy to spot using
    CPU profiling'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*由糟糕的应用程序设计生成的长事务提交*——使用CPU分析很容易发现'
- en: When a framework needs to get data from multiple tables, it usually knows to
    compose one query and get all the data in one call. However, if you don’t correctly
    use the framework, it may take just part of the data with an initial query and
    then, for each record initially retrieved, run a separate query. So, instead of
    running just one query, the framework will send an initial query plus *N* others
    (one for each of the *N* records retrieved by the first); we call this an *N+1
    query problem*, which usually creates significant latency by executing many queries
    instead of just one.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当框架需要从多个表中获取数据时，它通常知道要组合一个查询并在一次调用中获取所有数据。然而，如果您没有正确使用框架，它可能只使用初始查询获取部分数据，然后，对于最初检索到的每条记录，运行一个单独的查询。因此，而不是只运行一个查询，框架将发送一个初始查询加上*N*个其他查询（一个用于第一次查询检索到的*N*条记录中的每一条）；我们称这种情况为*N+1查询问题*，这通常通过执行多个查询而不是一个查询来创建显著的延迟。
- en: Most developers seem to be tempted to work with logs or a debugger to investigate
    such problems. But, in my experience, neither one is the best option to identify
    the problem’s root cause.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数开发人员似乎都倾向于使用日志或调试器来调查这类问题。但根据我的经验，这两种方法都不是确定问题根本原因的最佳选择。
- en: The first issue with using logs for this type of case is that it’s challenging
    to identify which query causes a problem. In real-world scenarios, the app may
    send dozens of queries—some of these multiple times, and in most cases, they are
    long and use a large number of parameters. With a profiler, which displays all
    the queries in a list with their execution time and the number of executions,
    you can almost instantaneously spot the problem. The second issue is that, even
    if you identify the potential query causing the problem (say, while monitoring
    logs, you observe that the app takes a long time to execute a given query), it’s
    not straightforward to take the query and run it. In the log, you find parameters
    separated from the query.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 使用日志处理此类情况的首要问题是难以确定哪个查询导致了问题。在现实场景中，应用程序可能会发送数十个查询——其中一些多次执行，而且在大多数情况下，它们都很长并且使用了大量参数。使用性能分析器，它以列表形式显示所有查询及其执行时间和执行次数，你可以几乎瞬间发现问题。第二个问题是，即使你确定了可能引起问题的查询（比如说，在监控日志时，你观察到应用程序执行某个查询需要很长时间），直接运行该查询也不是一件简单的事情。在日志中，你发现参数与查询是分开的。
- en: 'You can configure your app to print the queries generated by Hibernate in the
    logs by adding some parameters to the application properties of the da-ch7-ex3
    file:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过向 da-ch7-ex3 文件的应用程序属性中添加一些参数来配置应用程序以打印 Hibernate 生成的查询：
- en: '[PRE5]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Beware that you’ll have to use different ways to configure the logging depending
    on what technologies you use to implement the app. In the example provided with
    the book, we use Spring Boot and Hibernate. The next listing shows how the app
    prints the query in the logs.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你必须使用不同的方式来配置日志，具体取决于你用来实现应用程序的技术。在本书提供的示例中，我们使用 Spring Boot 和 Hibernate。下面的列表显示了应用程序如何在日志中打印查询。
- en: Listing 7.5 Logs showing the native queries Hibernate sends
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.5 Hibernate 发送的本地查询日志
- en: '[PRE6]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ The query generated by the app
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 应用程序生成的查询
- en: ❷ The first parameter’s value
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 第一个参数的值
- en: ❸ The second parameter’s value
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 第二个参数的值
- en: The logs show us the query and give us both the input and the output of the
    query. But you need to bind the parameter values to the query if you want to run
    it separately. And, when multiple queries are logged, looking for what you need
    can be really frustrating. Logs also don’t show you which part of the app runs
    the query, which can make your investigation even more challenging.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 日志显示查询并给出查询的输入和输出。但如果你想单独运行它，你需要将参数值绑定到查询上。而且，当多个查询被记录时，寻找所需内容可能会非常令人沮丧。日志也不会显示应用程序的哪个部分运行了查询，这可能会使你的调查更加困难。
- en: I recommend you always start with a profiler when investigating latency issues.
    Your first step should be sampling. When you suspect SQL query-related problems,
    continue profiling for JDBC. Then, problems will be easy understand, and you can
    use a debugger or the logs to confirm your speculations as needed.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议你在调查延迟问题时始终从性能分析器开始。你的第一步应该是采样。当你怀疑与 SQL 查询相关的问题时，继续对 JDBC 进行性能分析。然后，问题将容易理解，你可以根据需要使用调试器或日志来确认你的猜测。
- en: '![](../../OEBPS/Images/icon_guy3.png)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/icon_guy3.png)'
- en: 7.3.3 Using the profiler to get programmatically generated SQL queries
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3.3 使用性能分析器获取编程生成的 SQL 查询
- en: 'For completeness, let’s work on one more example that demonstrates how a profiler
    works when an app programmatically defines the queries. We’ll investigate a performance
    problem with a query generated by Hibernate (the framework our example uses) in
    an app using *criteria queries*: a programmatic way of defining the app’s persistence
    layer with Hibernate. You never write a query with this approach, either native
    or JPQL.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完整性，让我们再举一个例子，演示当应用程序以编程方式定义查询时，性能分析器是如何工作的。我们将调查一个由 Hibernate（我们示例中使用的框架）生成的查询在应用程序中使用
    *criteria 查询*（一种使用 Hibernate 定义应用程序持久层的编程方式）时的性能问题。你永远不会使用这种方法编写查询，无论是原生的还是 JPQL。
- en: As you can see in listing 7.6, which presents the `ProductRepository` class
    reimplemented with a criteria query, this approach is more verbose. It’s usually
    considered more difficult and leaves more room for mistakes. The implementation
    in project da-ch7-ex4 contains a mistake, which can cause significant performance
    problems in real-world apps. Let’s see if we can find this issue and determine
    how the profiler can help us understand what’s wrong.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 正如列表 7.6 所示，它展示了使用条件查询重新实现的 `ProductRepository` 类，这种方法更冗长。通常认为它更难，并且更容易出错。项目
    da-ch7-ex4 中的实现包含一个错误，这可能导致现实世界应用程序中出现重大的性能问题。让我们看看我们能否找到这个问题，并确定分析器如何帮助我们理解出了什么问题。
- en: Listing 7.6 The repository defined with a criteria query
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.6 使用条件查询定义的存储库
- en: '[PRE7]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ Creates a new query
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个新的查询
- en: ❷ Specifies that the query selects products
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 指定查询选择产品
- en: ❸ Selects the products
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 选择产品
- en: ❹ Defines the condition that becomes part of the where clause on the next line
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 在下一行定义成为 where 子句一部分的条件
- en: ❺ Defines the where clause
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 定义 where 子句
- en: ❻ Runs the query and extracts the result
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 运行查询并提取结果
- en: We use JDBC profiling to intercept the queries the app sends to the DBMS. You
    can see that it contains a cross join between the product table and itself (figure
    7.14). This is a huge problem! With the 10 records in our table, we don’t observe
    anything suspicious here. But in a real-world app, where the table would have
    more records, this cross join would create huge latencies and eventually even
    wrong output (duplicated rows). Simply intercepting the query with VisualVM and
    reading it shows us the issue.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 JDBC 分析来拦截应用程序发送给 DBMS 的查询。你可以看到它包含产品表与自身的交叉连接（图 7.14）。这是一个大问题！在我们的表中只有
    10 条记录时，我们没有观察到任何可疑之处。但在现实世界的应用程序中，表会有更多的记录，这个交叉连接将创建巨大的延迟，最终甚至产生错误的输出（重复的行）。简单地使用
    VisualVM 拦截查询并读取它就能显示问题。
- en: '![](../../OEBPS/Images/CH07_F14_Spilca3.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH07_F14_Spilca3.png)'
- en: Figure 7.14 The profiler can intercept any SQL query sent to the DBMS through
    the JDBC driver. Here, we spot an issue in the generated query—an unneeded cross
    join that causes performance problems.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.14 分析器可以通过 JDBC 驱动程序拦截发送给 DBMS 的任何 SQL 查询。在这里，我们发现了生成的查询中的一个问题——一个不必要的交叉连接，它会导致性能问题。
- en: 'The next question is, “Why did the app generate the query this way?” I like
    the statement about JPA implementations, such as Hibernate: “The excellent thing
    is that they make the query generation transparent and minimize work. The bad
    thing is that they make the query generation transparent, making the app more
    prone to errors.” When working with such frameworks. I generally recommend that
    developers profile the queries as part of the development process to discover
    such issues up front. Using a profiler is more for auditing purposes than finding
    issues, but doing so is a good safety measure.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个问题，“为什么应用程序以这种方式生成查询？” 我喜欢关于 JPA 实现，如 Hibernate 的说法：“好事是它们使查询生成透明并最小化工作。坏事是它们使查询生成透明，使应用程序更容易出错。”
    当与这样的框架一起工作时，我通常建议开发者在开发过程中分析查询，以便提前发现此类问题。使用分析器更多的是为了审计目的，而不是寻找问题，但这样做是一个良好的安全措施。
- en: In the following example, I intentionally introduced this tiny error with a
    significant impact. I called the `from()` method twice, instructing Hibernate
    to make a cross join.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的例子中，我故意引入了这个具有重大影响的小错误。我两次调用了 `from()` 方法，指示 Hibernate 进行交叉连接。
- en: Listing 7.7 The cause of the cross-join issue
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.7 交叉连接问题的原因
- en: '[PRE8]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ Calls the CriteriaQuery from() method once
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 只调用一次 CriteriaQuery 的 from() 方法
- en: ❷ Calls the CriteriaQuery from() method again
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 再次调用 CriteriaQuery 的 from() 方法
- en: 'Solving this problem is easy: use the product instance instead of calling the
    `CriteriaQuery` `from()` method the second time, as in the following listing.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题很简单：使用产品实例而不是在第二次调用 `CriteriaQuery` 的 `from()` 方法，如下所示。
- en: Listing 7.8 Correcting the cross-join issue
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 7.8 修正交叉连接问题
- en: '[PRE9]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ❶ Use the already existing Root object.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用已经存在的 Root 对象。
- en: Once you make this small change, the generated SQL query will no longer contain
    the unneeded cross join (figure 7.15). Still, the app runs the same query multiple
    times, which is not optimal. The algorithm the app runs should be refactored to
    get the data, preferably using only one query.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你做出这个小的改动，生成的 SQL 查询将不再包含不必要的交叉连接（图 7.15）。然而，应用程序仍然多次运行相同的查询，这并不理想。应用程序运行的计算算法应该重构以获取数据，最好只使用一个查询。
- en: '![](../../OEBPS/Images/CH07_F15_Spilca3.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/CH07_F15_Spilca3.png)'
- en: Figure 7.15 By eliminating the supplementary `select()` method call, the cross
    join disappeared. However, the overall algorithm for this app should be revised,
    since it still runs the same query multiple times, which is not optimal.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.15 通过消除辅助的 `select()` 方法调用，交叉连接消失了。然而，这个应用程序的整体算法应该进行修订，因为它仍然多次运行相同的查询，这并不理想。
- en: Summary
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: A profiler intercepts the app’s execution and provides essential details about
    the code in execution, such as the execution stack trace for each thread, how
    long it takes for each method to execute, and how many times a certain method
    was called.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析器拦截应用程序的执行并提供有关正在执行代码的基本细节，例如每个线程的执行堆栈跟踪、每个方法执行所需的时间以及某个特定方法被调用的次数。
- en: When investigating latency problems, the first step to using a profiler is sampling—a
    way for the profiler to intercept the executing code without getting many details.
    Sampling is less resource consuming and allows you to observe the big picture
    of execution.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在调查延迟问题时，使用分析器的第一步是采样——这是分析器拦截正在执行代码的一种方式，而不需要获取很多细节。采样资源消耗较少，并允许您观察执行的总体情况。
- en: 'Sampling gives you three essential details:'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 样本提供三个基本细节：
- en: '*What code executes*—When investigating an issue, you sometimes don’t know
    what part of the code executes, and you can find this aspect by sampling.'
  id: totrans-184
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*执行了什么代码*——在调查问题时，有时您不知道代码的哪个部分被执行，您可以通过采样找到这个方面。'
- en: '*Total execution time of every method*—This detail helps you to identify what
    part of the code causes potential latency problems.'
  id: totrans-185
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*每个方法的总执行时间*——这个细节有助于您确定代码的哪个部分可能导致潜在的延迟问题。'
- en: '*Total CPU execution time*—This detail helps you to identify whether your code
    spends the execution time “working” or waiting for something.'
  id: totrans-186
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*总 CPU 执行时间*——这个细节有助于您确定代码是否将执行时间花在“工作”还是等待某事上。'
- en: Sometimes sampling is enough to understand where a problem comes from. But in
    many cases, you need more details. You can get these details profiling the execution.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有时采样就足以了解问题的来源。但在许多情况下，您需要更多细节。您可以通过分析执行来获取这些细节。
- en: Profiling is a resource-consuming process. With a real-world app, it’s almost
    always impossible to profile the whole codebase. For this reason, when profiling
    for details, you should filter specific packages and classes on which you want
    to focus your investigation. You can usually determine what part of the app to
    focus on by sampling the execution first.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析是一个资源消耗的过程。在现实世界的应用程序中，几乎总是不可能分析整个代码库。因此，当分析细节时，您应该过滤特定的包和类，这些包和类是您想要集中调查的对象。通常，您可以通过首先采样执行来确定应用程序的哪个部分需要关注。
- en: An essential detail you get by profiling is the number of invocations of a method.
    When sampling, you know the total time a method spends executing, but not how
    often it was called. This aspect is important in identifying a method that is
    slow or wrongly used.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过分析获得的必要细节是方法调用的次数。在采样时，您知道方法执行的总时间，但不知道它被调用的频率。这个方面在识别运行缓慢或使用错误的方法时非常重要。
- en: You can use a profiler to get SQL queries the app sends to a DBMS. The profiler
    intercepts any queries, regardless of the technology used to implement the app’s
    persistence layer. This is invaluable when investigating slow queries for apps
    that use frameworks (such as Hibernate) to work with a database.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以使用分析器来获取应用程序发送给数据库管理系统的 SQL 查询。分析器拦截任何查询，无论应用程序的持久层使用什么技术实现。这对于调查使用框架（如 Hibernate）与数据库交互的应用程序的慢查询非常有价值。
