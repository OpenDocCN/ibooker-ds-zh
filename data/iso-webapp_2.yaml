- en: Part 3\. Isomorphic architecture
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第3部分\. 同构架构
- en: Now that you’ve seen how isomorphic architecture works and what foundational
    skills are needed to build a React application, it’s time to dive into the nitty-gritty
    of isomorphic apps. This part covers a wide range of topics while focusing on
    getting you ready to build a production-ready isomorphic application. It takes
    the concepts introduced in [chapter 2](kindle_split_012_split_000.xhtml#ch02)
    and examines each piece of the flow in detail. It also covers several advanced
    topics, including testing, real-world app challenges, user sessions, and caching.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了同构架构的工作原理以及构建 React 应用所需的基础技能，现在是时候深入了解同构应用的具体细节了。本部分涵盖了广泛的主题，同时着重于帮助你准备好构建一个生产就绪的同构应用。它详细考察了在[第2章](kindle_split_012_split_000.xhtml#ch02)中引入的概念中的每一部分。它还涵盖了几个高级主题，包括测试、现实世界的应用挑战、用户会话和缓存。
- en: The first two chapters in this section cover isomorphic architecture basics.
    In [chapter 7](kindle_split_019_split_000.xhtml#ch07), you’ll learn to use Express
    and how to use React and React Router on the server to enable server-rendered
    app routes. In [chapter 8](kindle_split_020_split_000.xhtml#ch08), you’ll see
    how to hand off the server-rendered page to the browser in a seamless way.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的前两章涵盖了同构架构的基础。在第7章（kindle_split_019_split_000.xhtml#ch07）中，你将学习如何使用 Express
    以及如何在服务器上使用 React 和 React Router 来启用服务器端渲染的应用路由。在第8章（kindle_split_020_split_000.xhtml#ch08）中，你将了解如何无缝地将服务器端渲染的页面传递给浏览器。
- en: The next three chapters cover the advanced topics. In [chapter 9](kindle_split_021_split_000.xhtml#ch09),
    you’ll learn how to think about testing in the context of an application that
    behaves as both a server-rendered page and a single-page application. In [chapter
    10](kindle_split_022_split_000.xhtml#ch10), you’ll learn how to handle cases such
    as code that can run only in the browser because it uses the `window` object and
    how to avoid duplicating your error-handling code. Finally, in [chapter 11](kindle_split_023_split_000.xhtml#ch11),
    you’ll get your app ready for production. You’ll learn performance best practices,
    caching strategies, and how to handle user sessions in an isomorphic app.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的三章将涵盖高级主题。在第9章（kindle_split_021_split_000.xhtml#ch09）中，你将学习如何在既作为服务器端渲染的页面又作为单页应用程序的行为的应用程序上下文中考虑测试。在第10章（kindle_split_022_split_000.xhtml#ch10）中，你将学习如何处理只能在浏览器中运行的代码（因为它使用了
    `window` 对象）以及如何避免重复错误处理代码。最后，在第11章（kindle_split_023_split_000.xhtml#ch11）中，你将让你的应用为生产做好准备。你将学习性能最佳实践、缓存策略以及如何在同构应用中处理用户会话。
- en: Chapter 7\. Building the server
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第7章\. 构建服务器
- en: '*This chapter covers*'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Setting up Node.js with Express
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Express 设置 Node.js
- en: Writing Express middleware
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写 Express 中间件
- en: Using React Router on the server to handle view routing
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在服务器上使用 React Router 处理视图路由
- en: Rendering React on the server with the `renderToString` function
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `renderToString` 函数在服务器上渲染 React
- en: Fetching data on the server using Redux
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Redux 在服务器上获取数据
- en: Implementing a static method on your components to handle data fetching
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的组件上实现静态方法以处理数据获取
- en: This chapter is all about the code that needs to happen on the server. I’ll
    cover server-specific topics including using Express and using your component
    and routing code on the server. For example, you’ll learn how to declare the actions
    of your application in a way that allows the server to fetch them automatically
    on every page render.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章全部关于需要在服务器上执行的代码。我将涵盖服务器特定的主题，包括使用 Express 以及在服务器上使用你的组件和路由代码。例如，你将学习如何以允许服务器在每次页面渲染时自动获取它们的方式声明你应用程序的动作。
- en: 'Yes, you read that correctly: you’re going to run your React, React Router,
    and Redux code on the server. React and React Router each provides server-specific
    APIs to make this work. Redux needs only minor changes—mostly you’ll call actions
    from the server. [Figure 7.1](kindle_split_019_split_000.xhtml#ch07fig01) illustrates
    how this works.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，你没有看错：你将在服务器上运行你的 React、React Router 和 Redux 代码。React 和 React Router 各自提供了针对服务器的特定
    API 来实现这一点。Redux 只需要做些小的改动——大多数情况下，你将从服务器调用动作。[图7.1](kindle_split_019_split_000.xhtml#ch07fig01)展示了这是如何工作的。
- en: Figure 7.1\. The main differences between server and browser code for React
    and React Router
  id: totrans-14
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.1\. React 和 React Router 服务器和浏览器代码之间的主要区别
- en: '![](Images/07fig01_alt.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![Images/07fig01_alt.jpg](Images/07fig01_alt.jpg)'
- en: 'To get the code shown in [figure 7.1](kindle_split_019_split_000.xhtml#ch07fig01)
    working, you need to do the following things:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让[图7.1](kindle_split_019_split_000.xhtml#ch07fig01)中显示的代码工作，你需要做以下几件事情：
- en: Set up app routing with Express
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Express 设置应用路由
- en: Handle specific routes (for example, the cart and products routes) with React
    Router using the `match` function
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 React Router 的 `match` 函数处理特定路由（例如，购物车和产品路由）
- en: Render your React components on the server using `renderToString`
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `renderToString` 在服务器上渲染你的 React 组件
- en: Fetch the data for your components on the server
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在服务器上获取组件的数据
- en: Respond to requests with the rendered app
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用渲染的应用程序响应请求
- en: These pieces make up the server-rendered part of an isomorphic application.
    That includes everything from the initial user request for your app to sending
    a rendered response to the browser.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这些部分构成了同构应用程序的服务器端渲染部分。这包括从用户对应用程序的初始请求到向浏览器发送渲染响应的整个过程。
- en: renderToString vs. render
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: renderToString 与 render
- en: Let’s go over the differences between the `render` and `renderToString` methods
    so you can better understand why we treat the render on the server as different
    from the browser render. [Table 7.1](kindle_split_019_split_001.xhtml#ch07table01)
    describes the output and use case for each method.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾 `render` 和 `renderToString` 方法之间的差异，以便你更好地理解为什么我们将服务器上的渲染视为与浏览器渲染不同。[表
    7.1](kindle_split_019_split_001.xhtml#ch07table01) 描述了每种方法的输出和用例。
- en: Table 7.1\. Comparing `render` and `renderToString`
  id: totrans-25
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表 7.1. 比较 `render` 和 `renderToString`
- en: '|   | Output | Runs once? | Environment |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '|   | 输出 | 是否运行一次？ | 环境 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| render | JavaScript representation of your components | No. Runs every time
    there’s an update. | Browser |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| render | 你的组件的 JavaScript 表示 | 否。每次更新时都会运行。 | 浏览器 |'
- en: '| renderToString | A string of DOM elements | Yes. Doesn’t hold any state.
    | Server |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| renderToString | DOM 元素的字符串表示 | 是。不保留任何状态。 | 服务器 |'
- en: '[Figure 7.2](kindle_split_019_split_001.xhtml#ch07fig02) shows the part of
    the isomorphic application flow that this chapter covers. The app you’ll build
    in this chapter is the All Things Westies app that you started working on in [chapter
    4](kindle_split_015_split_000.xhtml#ch04). You’ll build the server-rendered portion
    of the cart but not any of the browser-specific code or interactions. In this
    chapter, all the data will be mocked out from the server. [Figure 7.3](kindle_split_019_split_001.xhtml#ch07fig03)
    shows what this app looks like after it’s built out. (You’ll build the rest of
    the app in later chapters.)'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 7.2](kindle_split_019_split_001.xhtml#ch07fig02) 展示了本章涵盖的同构应用流程的一部分。在本章中，你将构建的
    All Things Westies 应用程序是你从 [第 4 章](kindle_split_015_split_000.xhtml#ch04) 开始工作的应用程序。你将构建购物车的服务器端渲染部分，但不会构建任何浏览器特定的代码或交互。在本章中，所有数据都将从服务器模拟。![图
    7.3](Images/07fig03_alt.jpg) 展示了构建完成后的应用程序的外观。（你将在后面的章节中构建应用程序的其余部分。）'
- en: Figure 7.2\. Isomorphic app flow—server render only
  id: totrans-31
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.2. 同构应用流程—仅服务器渲染
- en: '![](Images/07fig02_alt.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/07fig02_alt.jpg)'
- en: Figure 7.3\. The portion of the app you’ll build and render on the server in
    this chapter
  id: totrans-33
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.3. 本章中你将在服务器上构建和渲染的应用程序部分
- en: '![](Images/07fig03_alt.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/07fig03_alt.jpg)'
- en: You can find the code for this app at [http://mng.bz/8gV8](http://mng.bz/8gV8).
    After you’ve pulled this code down, you’ll want to switch to the chapter-7-express
    branch to follow along (`git checkout chapter-7-express`). Before you add the
    `renderToString` call, you first need to set up your app server. Let’s walk through
    Express basics and get the app server set up.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [http://mng.bz/8gV8](http://mng.bz/8gV8) 找到这个应用程序的代码。在拉取此代码后，你将想要切换到 chapter-7-express
    分支以继续操作（`git checkout chapter-7-express`）。在你添加 `renderToString` 调用之前，首先需要设置你的应用程序服务器。让我们回顾
    Express 基础知识并设置应用程序服务器。
- en: 7.1\. Introduction to Express
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.1. Express 简介
- en: When I started as a client app developer (building the UI portions of apps),
    there wasn’t much need to be able to do full-stack development. These days, the
    ability to implement and understand web servers, infrastructure, and distributed
    systems is a sought-after skill. The good news is that being able to build a server
    that renders the initial page load of your isomorphic app will go a long way toward
    improving your knowledge in this area.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当我开始作为客户端应用程序开发者（构建应用程序的用户界面部分）时，并没有太多需要能够进行全栈开发的需求。如今，能够实现和理解 Web 服务器、基础设施和分布式系统是一项备受追捧的技能。好消息是，能够构建一个渲染同构应用程序初始页面加载的服务器将大大有助于提高你在这一领域的知识。
- en: Express is a framework for Node.js that makes it easy to build REST APIs and
    to implement view rendering. In the All Things Westies app, Express handles the
    incoming requests to the Node.js server—for example, when the user wants to go
    to the Products page, the first place the request gets handled is by the Express
    app routing. Part of building an isomorphic app with JavaScript is handling initial
    requests to your web server; the server handles routing, fetching data, and rendering
    the page. The fully rendered page is then sent in the response to the browser.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Express 是一个 Node.js 框架，它使得构建 REST API 和实现视图渲染变得容易。在 All Things Westies 应用中，Express
    处理传入到 Node.js 服务器的请求——例如，当用户想要访问产品页面时，请求首先由 Express 应用程序路由处理。使用 JavaScript 构建同构应用程序的一部分是处理对您的
    web 服务器的初始请求；服务器处理路由、获取数据和渲染页面。然后，完全渲染的页面被发送到浏览器的响应中。
- en: 7.1.1\. Setting up the server entry point
  id: totrans-39
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.1.1\. 设置服务器入口点
- en: First, you need to get a basic server up and running. You want to use the command
    line to start your server and get it running on port 3000, as shown in [figure
    7.4](kindle_split_019_split_002.xhtml#ch07fig04). I’ve already supplied the root
    entry point files for you (server.js and app.es6).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要启动一个基本的服务器并运行。你想要使用命令行来启动你的服务器，并在端口 3000 上运行，如图 7.4 所示。我已经为你提供了根入口点文件（server.js
    和 app.es6）。
- en: Figure 7.4\. Starting the Node.js server
  id: totrans-41
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.4\. 启动 Node.js 服务器
- en: '![](Images/07fig04_alt.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/07fig04_alt.jpg)'
- en: 'In the current branch, Express is already in package.json. To use it with your
    Node.js application, you need to install it with npm. This will install all the
    packages needed for this section:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前分支中，Express 已经在 package.json 中。为了在你的 Node.js 应用程序中使用它，你需要使用 npm 安装它。这将安装本节所需的所有包：
- en: '[PRE0]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: When you navigate to localhost:3000, you’ll see an error, as in [figure 7.5](kindle_split_019_split_002.xhtml#ch07fig05).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当你导航到 localhost:3000 时，你会看到一个错误，如图 7.5 所示。
- en: Figure 7.5\. Without route handling, the server throws an error.
  id: totrans-46
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.5\. 没有路由处理，服务器会抛出错误。
- en: '![](Images/07fig05.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/07fig05.jpg)'
- en: The following listing shows the server entry file that’s already provided for
    you in the base code on the chapter-7-express branch.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了在章节-7-express 分支的基代码中已经为你提供的服务器入口文件。
- en: Listing 7.1\. Server entry—src/app.es6
  id: totrans-49
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.1\. 服务器入口—src/app.es6
- en: '[PRE1]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '***1* Include Express framework in project.**'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 在项目中包含 Express 框架。**'
- en: '***2* Initialize Express and assign it to app.**'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 初始化 Express 并将其分配给 app。**'
- en: '***3* Call listen on app and set port to 3000—you can do anything in the callback,
    the console.log statement lets the user know which port the server is running
    on.**'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 在 app 上调用 listen 并设置端口为 3000——你可以在回调中做任何事，console.log 语句让用户知道服务器正在哪个端口上运行。**'
- en: Now that you’ve seen the initial setup of the server code, you’ll add routing
    with Express.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到了服务器代码的初始设置，你将使用 Express 添加路由。
- en: 7.1.2\. Setting up routing with Express
  id: totrans-55
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.1.2\. 使用 Express 设置路由
- en: The Express router handles all incoming requests to the application and decides
    what to do with each request. For example, if you want to have a route such as
    /test that returns text and a 200 response, you need to add code that handles
    this route to the app.es6 file. [Figure 7.6](kindle_split_019_split_002.xhtml#ch07fig06)
    shows the expected output. Because you haven’t added route handling, this won’t
    work right now. Eventually, this route handling will allow you to render app routes
    with React.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Express 路由器处理应用程序的所有传入请求，并决定对每个请求做什么。例如，如果你想要一个返回文本和 200 响应的路由 /test，你需要添加处理此路由的代码到
    app.es6 文件中。[图 7.6](kindle_split_019_split_002.xhtml#ch07fig06) 显示了预期的输出。因为你还没有添加路由处理，所以现在这不会工作。最终，这个路由处理将允许你使用
    React 渲染应用程序路由。
- en: Figure 7.6\. Routing to the test route with Express
  id: totrans-57
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.6\. 使用 Express 路由到测试路由
- en: '![](Images/07fig06.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/07fig06.jpg)'
- en: '|  |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-60
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: In Express, every incoming request is represented by a request object. This
    object holds information about the URL, cookies, and other HTTP information such
    as any headers that were sent.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Express 中，每个传入的请求都由一个请求对象表示。该对象包含有关 URL、cookies 以及其他 HTTP 信息，例如发送的任何头部信息。
- en: '|  |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: You can set up specific routes for any type of HTTP verb (`GET`, `POST`, `PUT`,
    `OPTIONS`, `DELETE`). For the main portion of the app, you’ll need to implement
    only `GET` requests to respond to user requests for individual web app pages.
    [Listing 7.2](kindle_split_019_split_002.xhtml#ch07ex02) shows how to add a route
    handler for a `GET` request to the /test route. You’ll add the code in the listing
    to app.es6.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以为任何类型的 HTTP 动词（`GET`、`POST`、`PUT`、`OPTIONS`、`DELETE`）设置特定的路由。对于应用的主要部分，您只需要实现
    `GET` 请求来响应用户对单个网页应用页面的请求。[列表 7.2](kindle_split_019_split_002.xhtml#ch07ex02)
    展示了如何为 /test 路由添加一个 `GET` 请求的路由处理程序。您需要将列表中的代码添加到 app.es6 中。
- en: '|  |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-65
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: Express creates a response object for every incoming request. This object holds
    information that will be sent back to the browser such as headers, cookies, status
    code, and response body. It also has helper functions for setting the response
    body and status code.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Express 为每个传入的请求创建一个响应对象。该对象包含将发送回浏览器的信息，例如头信息、cookie、状态码和响应体。它还具有用于设置响应体和状态码的辅助函数。
- en: '|  |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Listing 7.2\. Add a route—src/app.es6
  id: totrans-68
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.2\. 添加路由—src/app.es6
- en: '[PRE2]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '***1* get function takes in route (/test) and a callback.**'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 获取函数接收路由 (/test) 和一个回调函数。**'
- en: '***2* Callback must respond to the response (or the request will hang indefinitely).**'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 回调必须响应响应（否则请求将无限期挂起）。**'
- en: Here you’re sending a simple string back to the browser indicating that the
    route exists. The response is sent with the `send()` method, which is found on
    the response object.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这里您向浏览器发送一个简单的字符串，表示该路由存在。响应是通过 `send()` 方法发送的，该方法位于响应对象上。
- en: Regular expressions in routes
  id: totrans-73
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 路由中的正则表达式
- en: In addition to hardcoding full string paths such as /test, Express supports
    regular expressions as routes. This is helpful for building an app with React
    Router because you want to hand off the route handling to React Router instead
    of having individual Express routes. If you wanted the Express app to know about
    routes such as /cart and /products, you’d have to have duplicate logic in place
    in both Express and React Router. [Figure 7.7](kindle_split_019_split_002.xhtml#ch07fig07)
    illustrates the differences.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 除了硬编码完整的字符串路径，如 /test，Express 还支持正则表达式作为路由。这对于使用 React Router 构建应用很有帮助，因为您希望将路由处理传递给
    React Router 而不是在 Express 中设置单独的路由。如果您希望 Express 应用了解如 /cart 和 /products 这样的路由，您必须在
    Express 和 React Router 中放置重复的逻辑。[图 7.7](kindle_split_019_split_002.xhtml#ch07fig07)
    说明了这些差异。
- en: Figure 7.7\. Efficiency versus lots of code duplication makes server routing
    with React Router the best choice.
  id: totrans-75
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.7\. 效率与大量代码重复，使使用 React Router 的服务器路由成为最佳选择。
- en: '![](Images/07fig07_alt.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/07fig07_alt.jpg)'
- en: If you re-create the routes in Express (the bad option in [figure 7.7](kindle_split_019_split_002.xhtml#ch07fig07))
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在 Express 中重新创建路由（如图 7.7 中的不良选择 [figure 7.7](kindle_split_019_split_002.xhtml#ch07fig07)）
- en: You have code duplication and no single source of truth for routes.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您有代码重复，并且没有路由的单个真相来源。
- en: You need to somehow provide the same React Router interface to these routes
    so that your app render on the server ends up matching your app render in the
    browser. *This is a lot of work!*
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您需要以某种方式为这些路由提供相同的 React Router 接口，以便您的应用在服务器上的渲染最终与浏览器上的渲染相匹配。*这是一项大量工作！*
- en: By reusing React Router and taking advantage of its built-in server functions,
    you save time and you don’t have to worry about your initial app state on the
    server being different from the initial app state on the browser.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 通过重用 React Router 并利用其内置的服务器功能，您可以节省时间，并且无需担心服务器上的初始应用状态与浏览器上的初始应用状态不同。
- en: You want to do this in an isomorphic application because it lets you reuse more
    of your code by using the routes from React Router. That lets you use the same
    routes in both environments. [Figure 7.8](kindle_split_019_split_002.xhtml#ch07fig08)
    shows how typing in an arbitrary route will print that route with a success message.
    This route won’t work until you add the code from [listing 7.3](kindle_split_019_split_002.xhtml#ch07ex03).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 您想在同构应用中这样做，因为它允许您通过使用 React Router 的路由来重用更多代码。这使您可以在两个环境中使用相同的路由。[图 7.8](kindle_split_019_split_002.xhtml#ch07fig08)
    展示了如何输入任意路由，并将该路由与成功消息一起打印出来。此路由在您添加 [列表 7.3](kindle_split_019_split_002.xhtml#ch07ex03)
    中的代码之前不会工作。
- en: Figure 7.8\. The `GET` route handler for all routes allows you to pass any route
    to the server.
  id: totrans-82
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.8\. 所有路由的 `GET` 路由处理程序允许您将任何路由传递到服务器。
- en: '![](Images/07fig08_alt.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/07fig08_alt.jpg)'
- en: '[Listing 7.3](kindle_split_019_split_002.xhtml#ch07ex03) shows how to set up
    a global route handler in your app.js file. The global route handler will always
    come last. It’ll call a middleware function (renderView.jsx—see [listing 7.4](kindle_split_019_split_003.xhtml#ch07ex04)
    in the next section) that uses React Router’s match logic to figure out which
    view to render.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 7.3](kindle_split_019_split_002.xhtml#ch07ex03)展示了如何在 app.js 文件中设置全局路由处理器。全局路由处理器始终放在最后。它将调用一个中间件函数（renderView.jsx—见下一节的[列表
    7.4](kindle_split_019_split_003.xhtml#ch07ex04)）来使用 React Router 的匹配逻辑确定要渲染哪个视图。'
- en: Listing 7.3\. Add a route to handle any view—src/app.es6
  id: totrans-85
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.3\. 为任何视图添加路由—src/app.es6
- en: '[PRE3]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `get` function takes in a regular expression. * will match all routes—any
    routes that are matched before the /* route won’t be handled by this route handler.
    The callback responds with a string that prints the current URL. If you restart
    the server at this point, you’ll see the output in [figure 7.8](kindle_split_019_split_002.xhtml#ch07fig08).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`get` 函数接受一个正则表达式。`*` 将匹配所有路由—在 `/*` 路由之前匹配的所有路由将不会被此路由处理器处理。回调响应以字符串形式打印当前
    URL。如果你在此处重新启动服务器，你将看到[图 7.8](kindle_split_019_split_002.xhtml#ch07fig08)中的输出。'
- en: Next you’ll add middleware to your route handlers.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将为路由处理器添加中间件。
- en: 7.2\. Adding middleware for view rendering
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.2\. 为视图渲染添加中间件
- en: So far, you’ve set up routes that are terminated in a single function that takes
    in the request and responds to it with the response object. Next, you want to
    implement a middleware function that checks for a route match with one of the
    app views (for example, /cart). Express can chain multiple functions together
    to handle complex business logic. These individual functions are called *middleware*.
    (If you’re thinking this sounds a lot like Redux middleware, it is!)
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经设置了以单个函数结束的路由，该函数接受请求并以响应对象的形式响应。接下来，你想要实现一个中间件函数，该函数检查与应用视图之一（例如，/cart）的路径匹配。Express
    可以将多个函数链接在一起来处理复杂业务逻辑。这些单个函数被称为 *中间件*。（如果你认为这听起来很像 Redux 中间件，那是对的！）
- en: 'Because we’ve decided to let React Router handle all the view routing, you’ll
    use the same sharedRoutes file you created in [chapter 4](kindle_split_015_split_000.xhtml#ch04).
    You can review the code in shared/sharedRoutes.jsx. There are four routes inside
    a root route (and an `IndexRoute` to make sure something renders on the root route):'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们已经决定让 React Router 处理所有视图路由，所以你会使用你在[第 4 章](kindle_split_015_split_000.xhtml#ch04)中创建的相同共享路由文件。你可以查看
    shared/sharedRoutes.jsx 中的代码。在根路由内部有四个路由（以及一个 `IndexRoute` 以确保在根路由上渲染某些内容）：
- en: '[PRE4]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '|  |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-94
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: If you’re using React Router 4, check out [appendix A](kindle_split_027_split_000.xhtml#app01)
    for an overview of setting up the routes.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用 React Router 4，请查看[附录 A](kindle_split_027_split_000.xhtml#app01)以了解设置路由的概述。
- en: '|  |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: After you’ve configured the React Router routes, it’s time to write your first
    Express middleware, which will call the `match` function and determine whether
    the requested route exists in your app.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置了 React Router 路由后，是时候编写你的第一个 Express 中间件了，它将调用 `match` 函数并确定请求的路由是否存在于你的应用中。
- en: 7.2.1\. Using match to handle routing
  id: totrans-98
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.2.1\. 使用匹配处理路由
- en: The `renderView` middleware handles route matching. It uses a function called
    `match` that’s provided by React Router. After you’ve added it, you’ll be able
    to navigate to each route you created in sharedRoutes. [Figure 7.9](kindle_split_019_split_003.xhtml#ch07fig09)
    shows sample output of navigating to localhost:3000/cart after you add the code
    from [listings 7.4](kindle_split_019_split_003.xhtml#ch07ex04) and [7.5](kindle_split_019_split_003.xhtml#ch07ex05).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`renderView` 中间件处理路由匹配。它使用 React Router 提供的 `match` 函数。添加后，你将能够导航到在 sharedRoutes
    中创建的每个路由。[图 7.9](kindle_split_019_split_003.xhtml#ch07fig09)显示了在添加了[列表 7.4](kindle_split_019_split_003.xhtml#ch07ex04)和[7.5](kindle_split_019_split_003.xhtml#ch07ex05)中的代码后导航到
    localhost:3000/cart 的示例输出。'
- en: Figure 7.9\. The middleware allows routing on the server to respond correctly
    based on the React Router shared routes.
  id: totrans-100
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.9\. 中间件允许服务器根据 React Router 共享路由正确响应。
- en: '![](Images/07fig09_alt.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图片 7.9](Images/07fig09_alt.jpg)'
- en: '|  |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-103
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: If you’re using React Router 4, check out [appendix B](kindle_split_028.xhtml#app02)
    for an overview of how to handle the routes on the server.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用 React Router 4，请查看[附录 B](kindle_split_028.xhtml#app02)以了解如何在服务器上处理路由的概述。
- en: '|  |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: To get the middleware hooked up to the `/*` (all) route handler you set up in
    the previous section, you’ll replace the request handler function with the `renderView`
    middleware function. The following listing shows the basic route-matching logic
    of the middleware.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将中间件连接到上一节中设置的`/*`（所有）路由处理程序，你需要将请求处理函数替换为`renderView`中间件函数。以下列表显示了中间件的基本路由匹配逻辑。
- en: Listing 7.4\. Route-matching middleware—src/middleware/renderView.jsx
  id: totrans-107
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.4\. 路由匹配中间件—src/middleware/renderView.jsx
- en: '[PRE5]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '***1* Include match function from React Router.**'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 包含React Router中的匹配函数。**'
- en: '***2* Include the routes from shared routes.**'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 包含共享路由中的路由。**'
- en: '***3* Middleware function takes in several parameters.**'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 中间件函数接受几个参数。**'
- en: '***4* Configure the match function options. The object requires your shared
    routes as well as the location being requested (the URL from the request).**'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 配置匹配函数选项。该对象需要你的共享路由以及请求的位置（请求的URL）。**'
- en: '***5* This callback will be called from the match function after it determines
    what to do with the current route.**'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 这个回调将在匹配函数确定如何处理当前路由后从匹配函数中被调用。**'
- en: '***6* Check to make sure there isn’t an error or redirect.**'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 确保没有错误或重定向。**'
- en: '***7* Call match function with options and callback.**'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 使用选项和回调调用匹配函数。**'
- en: 'Multiple callbacks are used in the listing. The request and response objects
    are passed to each middleware function. The next parameter is a callback function
    used to pass to the next middleware in the chain. The other callback for React
    Router has three parameters: an `error` object, a redirect location, and `renderProps`,
    which represents the components to be rendered if the route is valid.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 列表中使用了多个回调。请求和响应对象被传递给每个中间件函数。`next`参数是一个回调函数，用于传递给链中的下一个中间件。React Router的另一个回调有三个参数：一个`error`对象、一个重定向位置和`renderProps`，它代表如果路由有效则要渲染的组件。
- en: After you have the middleware set up, you also need to use it in app.es6\. The
    following listing shows how to import and apply the middleware by passing it in
    as a callback to the route handler. Update app.es6 with the code from the listing.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置好中间件之后，你还需要在app.es6中使用它。以下列表显示了如何通过将中间件作为回调传递给路由处理程序来导入和应用中间件。用列表中的代码更新app.es6。
- en: Listing 7.5\. Using `renderView` middleware for the catchall route—src/app.es6
  id: totrans-118
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.5\. 使用`renderView`中间件处理通配符路由—src/app.es6
- en: '[PRE6]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '***1* Import your renderView middleware.**'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 导入你的renderView中间件。**'
- en: '***2* Replace inline anonymous route handler (you pass middleware function
    into the route handler).**'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 替换内联匿名路由处理程序（你将中间件函数传递到路由处理程序中）。**'
- en: '[Figure 7.10](kindle_split_019_split_003.xhtml#ch07fig10) shows how a request
    enters your app via Express, gets routed by the /* router in Express, and then
    passes through various middleware functions that handle React Router routes such
    as /cart or errors. Each middleware function has the option to either terminate
    the request (successfully or with an HTTP error response code) or call the next
    callback. Calling `next` passes the request to the next middleware function in
    the chain.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '[图7.10](kindle_split_019_split_003.xhtml#ch07fig10)展示了请求如何通过Express进入你的应用，通过Express中的`/*`路由器进行路由，然后通过处理React
    Router路由（如/cart或错误）的各种中间件函数。每个中间件函数都有选择终止请求（成功或带有HTTP错误响应代码）或调用下一个回调的选项。调用`next`将请求传递给链中的下一个中间件函数。'
- en: Figure 7.10\. The flow of a request through the Express router and associated
    middleware that use React Router to check for the presence of a valid route
  id: totrans-123
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图7.10\. 请求通过Express路由器和相关中间件（使用React Router检查有效路由的存在）的流程
- en: '![](Images/07fig10_alt.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/07fig10_alt.jpg)'
- en: This section covered how to use Express middleware alongside React Router on
    the server to determine the existence of app routes. Next, you’ll render the components
    on the server.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了如何在服务器上使用Express中间件和React Router来确定应用路由的存在。接下来，你将在服务器上渲染组件。
- en: 7.2.2\. Rendering components on the server
  id: totrans-126
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.2.2\. 在服务器上渲染组件
- en: Phew! You’ve reached the critical juncture—the climax of the story, so to speak.
    (I saw you roll your eyes.) This section covers the core of getting your components
    rendered on the server. The goal is to end up with a string representation of
    the DOM that can be sent as the response to the browser ([figure 7.11](kindle_split_019_split_003.xhtml#ch07fig11)).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 呼！你已经到达了关键点——故事的顶点，可以说是。 （我看到你翻了个白眼。）本节涵盖了在服务器上渲染组件的核心。目标是得到一个DOM的字符串表示形式，可以将其作为响应发送到浏览器（[图7.11](kindle_split_019_split_003.xhtml#ch07fig11)）。
- en: Figure 7.11\. Rendered output for the HTML in string form
  id: totrans-128
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.11\. 字符串形式的 HTML 渲染输出
- en: '![](Images/07fig11_alt.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/07fig11_alt.jpg)'
- en: Rendering your components on the server has two parts. Let’s imagine what happens
    when the user requests the /cart route. [Figure 7.12](kindle_split_019_split_003.xhtml#ch07fig12)
    shows this flow.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器上渲染你的组件有两个部分。让我们想象一下当用户请求 /cart 路由时会发生什么。[图 7.12](kindle_split_019_split_003.xhtml#ch07fig12)
    展示了这个流程。
- en: Figure 7.12\. The two-step process of rendering a valid HTML route
  id: totrans-131
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.12\. 渲染有效 HTML 路由的两步过程
- en: '![](Images/07fig12_alt.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/07fig12_alt.jpg)'
- en: 'Here are the steps:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是步骤：
- en: '**1**.  Each view request must render the React tree based on the route matched
    with React Router. For /cart, this includes the App component, Cart component,
    and Item component. You saw the App component in [chapter 4](kindle_split_015_split_000.xhtml#ch04),
    and we’ll go over the other components in this chapter.'
  id: totrans-134
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**.  每个视图请求都必须根据与 React Router 匹配的路由渲染 React 树。对于 /cart，这包括 App 组件、Cart
    组件和 Item 组件。你在 [第 4 章](kindle_split_015_split_000.xhtml#ch04) 中看到了 App 组件，我们将在本章中介绍其他组件。'
- en: '**2**.  The final request must contain a complete HTML page with head and body
    tags. Your core App components don’t include this markup. Instead, you need to
    create an HTML.jsx component that handles the wrapper markup. Think of this as
    your index.html file.'
  id: totrans-135
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**.  最终的请求必须包含一个完整的 HTML 页面，包括 head 和 body 标签。你的核心 App 组件不包括这个标记。相反，你需要创建一个
    HTML.jsx 组件来处理包装标记。把这看作是你的 index.html 文件。'
- en: These two steps require you to render twice on the server. (This method has
    alternatives, but they all require additional templating languages and setup.
    If you want to explore one of these other options, either EJS or Pug work nicely
    with Node.js.) The first React app I worked on used Pug. Although there’s nothing
    wrong with this approach, it presents challenges. For one, you need to be up-to-date
    on yet another library. Also, it doesn’t play as nicely with some of the cool
    tools available for your workflow such as the Webpack Dev Server.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个步骤要求你在服务器上渲染两次。（这种方法有替代方案，但它们都需要额外的模板语言和设置。如果你想探索这些其他选项之一，EJS 或 Pug 与 Node.js
    一起工作得很好。）我工作的第一个 React 应用程序使用了 Pug。尽管这种方法没有问题，但它提出了挑战。首先，你需要对另一个库保持最新。此外，它并不像一些用于你的工作流程的酷工具那样配合得很好，例如
    Webpack Dev Server。
- en: Building your index component
  id: totrans-137
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 构建 index 组件
- en: First, let’s render a basic HTML page so you have a container to put your components
    into. If you’ve been following along, you can continue in the current branch.
    If you’ve gotten lost or want to skip to the next checkpoint, you can change branches
    to the chapter-7-rendering branch (`git checkout chapter-7-rendering`). The following
    listing shows the React component that represents your root HTML container. Add
    this code to html.jsx.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们渲染一个基本的 HTML 页面，以便你有一个容器来放置你的组件。如果你一直在跟随，你可以在当前分支中继续。如果你迷路了或者想要跳到下一个检查点，你可以切换到
    chapter-7-rendering 分支（`git checkout chapter-7-rendering`）。以下列表显示了代表你的根 HTML 容器的
    React 组件。将此代码添加到 html.jsx 中。
- en: Listing 7.6\. HTML container—src/components/html.jsx
  id: totrans-139
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.6\. HTML 容器—src/components/html.jsx
- en: '[PRE7]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '***1* Will be rendered only on the server, will never have state and can be
    a pure (stateless) component represented by a function.**'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 只会在服务器上渲染，永远不会具有状态，可以是一个纯（无状态）组件，由一个函数表示。**'
- en: '***2* Build basic HTML structure with <html>, <head>, and <body> tags.**'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 使用 <html>、<head> 和 <body> 标签构建基本的 HTML 结构。**'
- en: '***3* Include SemanticUI CSS library.**'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 包含 SemanticUI CSS 库。**'
- en: '***4* Where rendered React component markup for the current route will go**'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 当前路由渲染的 React 组件标记将放置于此**'
- en: '***5* Add prop type string to indicate rendered components will be provided
    as string.**'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 添加 prop 类型字符串以指示渲染的组件将以字符串形式提供。**'
- en: The rendered React component markup will be passed in as a string. Because you’re
    injecting HTML, you must use `dangerouslySetInnerHTML` to insert the DOM elements.
    The most important piece of this React component is that it takes in the rendered
    HTML that makes up the rest of the component tree. In the next section, you’ll
    render the main component tree into the html.jsx component.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染的 React 组件标记将以字符串形式传递。由于你正在注入 HTML，你必须使用 `dangerouslySetInnerHTML` 来插入 DOM
    元素。这个 React 组件最重要的部分是它接收构成其余组件树的渲染 HTML。在下一节中，你将把主组件树渲染到 html.jsx 组件中。
- en: Remember that components are always rendered only once on the server, so only
    the first React lifecycle is triggered. Components that are used only on the server
    (such as html.jsx) can be stateless if they don’t rely on `componentWillUpdate`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，组件在服务器上总是只渲染一次，因此只触发第一个 React 生命周期。仅用于服务器上的组件（如 html.jsx）如果它们不依赖于 `componentWillUpdate`，则可以是无状态的。
- en: '|  |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**dangerouslySetInnerHTML**'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '**dangerouslySetInnerHTML**'
- en: The `dangerouslySetInnerHTML` property is provided by React to allow you to
    inject HTML into React components. Generally speaking, you *shouldn’t* use this
    property. But sometimes you need to. Every rule has exceptions!
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`dangerouslySetInnerHTML` 属性由 React 提供，允许你将 HTML 注入到 React 组件中。一般来说，你 *不应该*
    使用此属性。但有时你需要。每个规则都有例外！'
- en: What’s really happening when you set this attribute? Under the hood, React is
    setting the `innerHTML` property. But setting `innerHTML` is a security risk.
    It can expose you to cross-site scripting (XSS) attacks.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当你设置此属性时，实际上发生了什么？在底层，React 正在设置 `innerHTML` 属性。但是设置 `innerHTML` 是一个安全风险。它可能会使你面临跨站脚本（XSS）攻击。
- en: React considers using `dangerouslySetInnerHTML` a best practice because it reminds
    you that you don’t want to be setting `innerHTML` most of the time. For more information,
    see [http://mng.bz/69Ne](http://mng.bz/69Ne).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: React 将使用 `dangerouslySetInnerHTML` 视为一个最佳实践，因为它提醒你大多数时候你不想设置 `innerHTML`。有关更多信息，请参阅
    [http://mng.bz/69Ne](http://mng.bz/69Ne)。
- en: '|  |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 7.2.3\. Using renderToString to create the view
  id: totrans-154
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.2.3\. 使用 renderToString 创建视图
- en: The next step is rendering output into the HTML container from [listing 7.6](kindle_split_019_split_003.xhtml#ch07ex06).
    In the following listing, you can see how to call `renderToString` twice to get
    your main content rendered into an HTML page. Update the `renderView` middleware
    with this code.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将输出渲染到 HTML 容器中，来自 [列表 7.6](kindle_split_019_split_003.xhtml#ch07ex06)。在以下列表中，你可以看到如何调用
    `renderToString` 两次以将主内容渲染到 HTML 页面中。使用此代码更新 `renderView` 中间件。
- en: Listing 7.7\. Render HTML output in the middleware—src/middleware/renderView.jsx
  id: totrans-156
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.7\. 在中间件中渲染 HTML 输出—src/middleware/renderView.jsx
- en: '[PRE8]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '***1* Include React because of JSX in middleware (this is why it’s a .jsx file).**'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 由于中间件中的 JSX 包含 React（这就是为什么它是 .jsx 文件）。**'
- en: '***2* Import renderToString function from React DOM library.**'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 从 React DOM 库导入 renderToString 函数。**'
- en: '***3* Include the HTML component.**'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 包含 HTML 组件。**'
- en: '***4* Call renderToString on placeholder <div>.**'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 在占位符 <div> 上调用 renderToString 方法。**'
- en: '***5* Call renderToString on HTML component, inject rendered app content into
    component.**'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 在 HTML 组件上调用 renderToString 方法，将渲染的应用内容注入到组件中。**'
- en: '***6* Send composed string back on response, append DOCTYPE tag to make markup
    valid.**'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 将组合后的字符串发送回响应，添加 DOCTYPE 标签以使标记有效。**'
- en: Calling `renderToString` on the placeholder `<div>` creates the page content
    that will be inserted in the HTML component.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在占位符 `<div>` 上调用 `renderToString` 创建将插入到 HTML 组件中的页面内容。
- en: In the next section, you’ll replace this with the App component.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将用 App 组件替换此内容。
- en: Rendering components
  id: totrans-166
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 渲染组件
- en: 'The final step is to completely render a route inside the middleware. This
    requires the following:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是在中间件中完全渲染一个路由。这需要以下步骤：
- en: Dynamically rendering app.jsx and a child component based on the route (for
    example, the cart and all its children)
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据路由（例如，购物车及其所有子组件）动态渲染 app.jsx 和子组件
- en: Taking the string output from the render and passing it into html.jsx as a property
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从渲染中获取字符串输出并将其作为属性传递给 html.jsx
- en: You already built the App component in [chapter 4](kindle_split_015_split_000.xhtml#ch04).
    It’s in src/components/app.jsx. You now need to add the Cart component.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经在第 4 章中构建了 App 组件 [章节 4](kindle_split_015_split_000.xhtml#ch04)。它在 src/components/app.jsx
    中。你现在需要添加购物车组件。
- en: The Cart component renders the items in a user’s cart and displays the total
    cost. It also has a Checkout button. For now, this component has placeholder text
    (the linter will complain, but you’ll fix this soon). In the next section, you’ll
    add Redux and data fetching, and the cart will dynamically render the items you
    pass into it. You already have a cart.jsx from [chapter 4](kindle_split_015_split_000.xhtml#ch04).
    Replace the existing code with the following listing.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 购物车组件渲染用户购物车中的项目并显示总成本。它还有一个结账按钮。目前，此组件有占位符文本（代码检查器会抱怨，但你会很快修复这个问题）。在下一节中，你将添加
    Redux 和数据获取，购物车将动态渲染传递给它的项目。你已经有了来自第 4 章的 cart.jsx [章节 4](kindle_split_015_split_000.xhtml#ch04)。用以下列表替换现有代码。
- en: Listing 7.8\. Cart component—src/components/cart.jsx
  id: totrans-172
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.8\. 购物车组件—src/components/cart.jsx
- en: '[PRE9]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '***1* Container for rendering cart items**'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 渲染购物项的容器**'
- en: '***2* Render total number of items in cart.**'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 渲染购物车中物品的总数。**'
- en: '***3* Checkout button**'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 结账按钮**'
- en: Now that you have the components for the /cart route, you still need to render
    them on the server. [Listing 7.9](kindle_split_019_split_003.xhtml#ch07ex09) shows
    you how to take the middleware code and update it to work with dynamic routes.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经拥有了 /cart 路由的组件，你仍然需要在服务器上渲染它们。[列表 7.9](kindle_split_019_split_003.xhtml#ch07ex09)
    展示了如何将中间件代码更新以支持动态路由。
- en: '|  |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-179
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: If you’re using React Router 4, check out [appendix B](kindle_split_028.xhtml#app02)
    for an overview of how to handle the routes on the server.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是 React Router 4，请查看[附录 B](kindle_split_028.xhtml#app02)以了解如何在服务器上处理路由的概述。
- en: '|  |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Listing 7.9\. Render—src/middleware/renderView.jsx
  id: totrans-182
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.9\. 渲染—src/middleware/renderView.jsx
- en: '[PRE10]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '***1* RouterContext is a React Router component used to properly render your
    component tree on the server.**'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* RouterContext 是一个 React Router 组件，用于在服务器上正确渲染你的组件树。**'
- en: '***2* Pass in shared routes to RouterContext so the location is properly initialized
    and matches the browser render.**'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将共享路由传递到 RouterContext 中，以便正确初始化位置并匹配浏览器渲染。**'
- en: '***3* Calculated by the match function from React Router, passed into RouterContext,
    which knows how to pull out the correct component to render.**'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 由 React Router 的匹配函数计算得出，传递到 RouterContext 中，该上下文知道如何提取正确的组件进行渲染。**'
- en: The key takeaway is to use the `renderProps` value (passed into your callback
    from React Router). This lets the Router know which component to render. It’s
    also how you make the routing consistent on both the server and the browser.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 关键要点是使用 `renderProps` 值（从 React Router 传递到你的回调函数）。这使 Router 知道要渲染哪个组件。这也是你如何在服务器和浏览器上保持路由一致性的方法。
- en: So far, you’ve learned how to take advantage of React’s `renderToString` to
    render your components on the server. But you also need to be able to fetch the
    data that populates your components on the server. In the next section, you’ll
    hook up Redux and add a static method called `prefetchActions` to your React components
    to indicate what actions need to be called for an individual component to be rendered
    properly at runtime.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经学会了如何利用 React 的 `renderToString` 在服务器上渲染你的组件。但你也需要能够在服务器上获取填充组件的数据。在下一节中，你将连接
    Redux 并为你的 React 组件添加一个名为 `prefetchActions` 的静态方法，以指示在运行时需要调用哪些操作才能使单个组件正确渲染。
- en: 7.3\. Adding Redux
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.3\. 添加 Redux
- en: As you add Redux to the app, you’ll be rendering the fetched data into the view,
    as in [figure 7.13](kindle_split_019_split_004.xhtml#ch07fig13).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将 Redux 添加到应用中时，你将渲染获取的数据到视图中，如[图 7.13](kindle_split_019_split_004.xhtml#ch07fig13)所示。
- en: Figure 7.13\. The data fetched by Redux on the server will be rendered into
    the list view in the cart.
  id: totrans-191
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.13\. 服务器上 Redux 获取的数据将被渲染到购物车中的列表视图。
- en: '![](Images/07fig13_alt.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/07fig13_alt.jpg)'
- en: One of the trickiest parts of building web apps (or any data-driven, user-facing
    app) is handling asynchronous code. It’s kind of like when I’m cooking breakfast
    and my premade breakfast sausages say they’ll take 6–8 minutes to make. Does that
    mean I should start my eggs 4 minutes after starting to cook the sausages, or
    8 minutes? My eggs will cook much faster than the sausages, but I want everything
    to be ready at the same time.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 构建网络应用（或任何数据驱动的、面向用户的程序）中最棘手的部分之一是处理异步代码。这有点像我煮早餐时，预先做好的早餐香肠说需要 6-8 分钟来制作。这意味着我应该在我开始煮香肠后
    4 分钟开始煮鸡蛋，还是 8 分钟？我的鸡蛋会比香肠煮得快得多，但我想让所有东西同时准备好。
- en: Similarly, when using Redux on the server, you need your data to be ready before
    you render your view, or the view created on the server and the view created after
    the browser code runs won’t always match. You need to guarantee that the data
    needed by the view is available before you begin to render the view. [Figure 7.14](kindle_split_019_split_004.xhtml#ch07fig14)
    shows the flow of Redux on the server.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，当你在服务器上使用 Redux 时，你需要确保在渲染视图之前数据已经准备好，否则服务器上创建的视图和浏览器代码运行后创建的视图可能不会总是匹配。你需要确保在开始渲染视图之前，视图所需的数据是可用的。[图
    7.14](kindle_split_019_split_004.xhtml#ch07fig14) 展示了服务器上 Redux 的流程。
- en: Figure 7.14\. The Redux flow on the server
  id: totrans-195
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 7.14\. 服务器上的 Redux 流程
- en: '![](Images/07fig14_alt.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/07fig14_alt.jpg)'
- en: 'You’ll take several steps to make sure you can fetch all the necessary data
    for the Cart component (the same process can be applied to other parts of the
    app):'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要采取几个步骤来确保你可以获取 Cart 组件（该过程可以应用于应用的其它部分）的所有必要数据：
- en: Create cart actions and reducers to fetch the cart data
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建购物车动作和减少器以获取购物车数据
- en: Use the `renderView` middleware to call actions
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `renderView` 中间件来调用动作
- en: Use a static method on your Cart component to allow the middleware to know what
    actions it needs to call
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的购物车组件上使用静态方法，以便中间件知道它需要调用哪些动作
- en: Display the fetched data in the Cart component
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在购物车组件中显示获取的数据
- en: 7.3.1\. Setting up the cart actions and reducers
  id: totrans-202
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.3.1\. 设置购物车动作和减少器
- en: The All Things Westies app has the concept of user sessions and being logged
    out or logged in. Therefore, the app can track items in the user’s cart and then
    persist this data so the user can come back later and finish the transaction.
    (You could also use cookies or local storage to do this.)
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: All Things Westies 应用具有用户会话的概念，以及注销或登录。因此，应用可以跟踪用户购物车中的项目，然后持久化这些数据，以便用户稍后回来完成交易。（你也可以使用
    cookie 或本地存储来完成此操作。）
- en: In this section, you’re going to assume that the user has previously put items
    in the cart and has come back directly to the cart to finish shopping. You’ll
    be working with the cart route (http://localhost:3000/cart).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将假设用户之前已经将项目放入购物车，并直接回到购物车完成购物。你将使用购物车路由（http://localhost:3000/cart）。
- en: First you need to initialize Redux on the server. The following listing shows
    the Redux configuration that you need to add to init-redux.es6\. If you’ve been
    following along, you can add this code, or you can switch to chapter-7-adding-redux
    (`git checkout chapter-7-adding-redux`).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要在服务器上初始化 Redux。以下列表显示了你需要添加到 init-redux.es6 的 Redux 配置。如果你一直在跟随，你可以添加此代码，或者你可以切换到
    chapter-7-adding-redux (`git checkout chapter-7-adding-redux`)。
- en: Listing 7.10\. Initialize the Redux store—src/shared/init-redux.es6
  id: totrans-206
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.10\. 初始化 Redux 存储—src/shared/init-redux.es6
- en: '[PRE11]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '***1* Import all functions needed from Redux.**'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 从 Redux 导入所有需要的函数。**'
- en: '***2* Import Thunk middleware so you can use asynchronous actions.**'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 导入 Thunk 中间件，以便你可以使用异步动作。**'
- en: '***3* Import logger middleware to help with debugging—on the server, it’ll
    log in terminal.**'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 导入日志记录中间件以帮助调试——在服务器上，它将在终端中记录。**'
- en: '***4* Import cart reducer.**'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 导入购物车减少器。**'
- en: '***5* Create the root reducer, which will eventually have other subreducers
    for user, product, and blog data.**'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 创建根减少器，它最终将包含用户、产品和博客数据的子减少器。**'
- en: '***6* Set up the middleware.**'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 设置中间件。**'
- en: '***7* Compose the middleware and reducers to create new store.**'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 组合中间件和减少器以创建新的存储。**'
- en: You also need to create the action you’ll be calling to fetch the cart data.
    The cart needs to know what items are currently in the user’s cart. You add this
    code in the cart-action-creators.es6 file, shown in the following listing.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要创建你将调用来获取购物车数据的动作。购物车需要知道用户购物车中当前有什么项目。你将此代码添加到 cart-action-creators.es6
    文件中，以下列表显示了。
- en: Listing 7.11\. Cart actions—src/shared/cart-action-creators.es6
  id: totrans-216
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.11\. 购物车动作—src/shared/cart-action-creators.es6
- en: '[PRE12]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '***1* String constant for the action**'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 动作字符串常量**'
- en: '***2* On the server, the getCartItems action will be called from the renderView
    middleware.**'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 在服务器上，getCartItems 动作将由 renderView 中间件调用。**'
- en: '***3* Use fetch API to get cart data from the Node.js server.**'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 使用 fetch API 从 Node.js 服务器获取购物车数据。**'
- en: '***4* On a success response, read JSON from the response.**'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 在成功响应中，从响应中读取 JSON。**'
- en: '***5* Take parsed JSON; return action object.**'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 解析 JSON；返回动作对象。**'
- en: In that last line, the `type` is the string constant, and the `data` is the
    items array from the JSON. [Listing 7.12](kindle_split_019_split_004.xhtml#ch07ex12)
    shows what this data looks like.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一行，`type` 是字符串常量，而 `data` 是来自 JSON 的项目数组。[列表 7.12](kindle_split_019_split_004.xhtml#ch07ex12)
    展示了这些数据的样子。
- en: For the All Things Westies app, all the data will be handled on your Node.js
    server. Everything is mocked out in JSON files. The cart data is shown in the
    following listing. It’s already provided for you in the branch.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 All Things Westies 应用，所有数据都将由你的 Node.js 服务器处理。所有内容都在 JSON 文件中模拟。以下列表显示了购物车数据。它已经为你提供在分支中。
- en: Listing 7.12\. Mock cart data—data/cart.json
  id: totrans-225
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.12\. 模拟购物车数据—data/cart.json
- en: '[PRE13]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '***1* JSON returns object with an array of cart items.**'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* JSON 返回包含购物车项目数组的对象。**'
- en: '***2* Each item has a name that’s a string.**'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 每个项目都有一个名称，它是一个字符串。**'
- en: '***3* Each item has a price that’s a number.**'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 每个项目都有一个价格，它是一个数字。**'
- en: '***4* Each item has a thumbnail that’s a string with an image URL.**'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 每个项目都有一个缩略图，它是一个包含图像 URL 的字符串。**'
- en: After the cart data is fetched from the server by the `getCartItems` action,
    your cart reducer will put the data in the Redux store. [Listing 7.13](kindle_split_019_split_004.xhtml#ch07ex13)
    shows the code required to set up the cart reducer. Remember that the job of the
    reducer is to take in the current store and an action. It then uses the action
    to update the store and return a new state of the app. Add the code from the listing
    to the cart reducer.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在通过 `getCartItems` 动作从服务器获取购物车数据后，您的购物车 reducer 将数据放入 Redux 存储。[列表 7.13](kindle_split_019_split_004.xhtml#ch07ex13)
    显示了设置购物车 reducer 所需的代码。请记住，reducer 的任务是接收当前存储和动作。然后它使用动作来更新存储并返回应用程序的新状态。将列表中的代码添加到购物车
    reducer 中。
- en: Listing 7.13\. Cart reducers—src/shared/cart-reducer.es6
  id: totrans-232
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.13\. 购物车 reducers—src/shared/cart-reducer.es6
- en: '[PRE14]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '***1* Use an action string constant to ensure consistency.**'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 使用动作字符串常量以确保一致性。**'
- en: '***2* Read the type from the action passed into reducer to see if you should
    handle the action in this reducer.**'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 从传递给 reducer 的动作中读取类型，以查看是否应该在此 reducer 中处理该动作。**'
- en: '***3* Write data from theaction into current state.**'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 将动作中的数据写入当前状态。**'
- en: Good job! You’ve created all the pieces of Redux (setup, action, and reducer)
    needed to fetch the route data in the `renderView` middleware. Next, you’ll implement
    the data-fetching logic so you can see the data loaded into the view.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好！您已经创建了 Redux 所需的所有组件（设置、动作和 reducer），以便在 `renderView` 中间件中获取路由数据。接下来，您将实现数据获取逻辑，以便您可以看到加载到视图中的数据。
- en: 7.3.2\. Using Redux in renderView middleware
  id: totrans-238
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.3.2\. 在 renderView 中间件中使用 Redux
- en: Now you need to include the store in your `renderView` middleware. The following
    listing shows how to add this in.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您需要将存储包含在您的 `renderView` 中间件中。以下列表显示了如何添加此功能。
- en: Listing 7.14\. Adding the Redux store to your middleware—src/middleware/renderView.jsx
  id: totrans-240
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.14\. 将 Redux 存储添加到您的中间件—src/middleware/renderView.jsx
- en: '[PRE15]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '***1* Include initialization code in middleware.**'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 在中间件中包含初始化代码。**'
- en: '***2* Call initialization function and store it on a const variable called
    store.**'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 调用初始化函数并将其存储在名为 store 的常量变量中。**'
- en: After you have the store in the middleware, you can dispatch actions on the
    server. But you want to be smart and dispatch only the actions for the current
    route. To do that, you need to extend your React components to be able to declare
    your actions on a per-route basis.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在您将存储放入中间件之后，您可以在服务器上分发动作。但您想变得聪明，只分发当前路由的动作。为此，您需要扩展您的 React 组件，以便能够在每个路由的基础上声明您的动作。
- en: Setting up initial actions
  id: totrans-245
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 设置初始动作
- en: There are a couple of valid ways to declare the data needs for a route. You
    can store this information with the route declaration or you can put the data
    declaration on the components. I’m going to show you how to put the data declaration
    on the components. The Cart component knows which action creator functions need
    to be called to fetch the appropriate data for the cart view. Later, the `renderView`
    middleware will use these function references and call them to get the JSON data
    responses needed to populate the store.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 声明路由的数据需求有几种有效的方法。您可以将此信息与路由声明一起存储，或者您可以将数据声明放在组件上。我将向您展示如何将数据声明放在组件上。购物车组件知道需要调用哪些动作创建器函数来获取购物车视图所需的相关数据。稍后，`renderView`
    中间件将使用这些函数引用并调用它们以获取填充存储所需的 JSON 数据响应。
- en: With React Router, you can easily access any component you’ve declared in a
    route component. By declaring the data needs on the components that are in your
    shared routes, you can compose a list of actions from multiple components in the
    middleware. The next listing shows how the Cart component declares its action
    needs. In this case, it needs the data fetched by the `getCartItems` action. To
    indicate that, it stores a reference to the action creator function. The `renderView`
    middleware will call this action.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 React Router，您可以轻松访问在路由组件中声明的任何组件。通过在共享路由中的组件上声明数据需求，您可以在中间件中组合来自多个组件的动作列表。下一个列表显示了购物车组件如何声明其动作需求。在这种情况下，它需要通过
    `getCartItems` 动作获取的数据。为了表示这一点，它存储了对动作创建器函数的引用。`renderView` 中间件将调用此动作。
- en: Listing 7.15\. Declaring initial actions—components/cart.jsx
  id: totrans-248
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.15\. 声明初始动作—components/cart.jsx
- en: '[PRE16]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '***1* Declare static function.**'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 声明静态函数。**'
- en: '***2* Return array so you can list multiple action creators (actions hold business
    logic of how to fetch data and update app state).**'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 返回数组，以便您可以列出多个动作创建器（动作包含如何获取数据和更新应用程序状态的业务逻辑）。**'
- en: '***3* List action creators needed for component (don’t call them here, just
    pass them as function references).**'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 列出组件需要的动作创建者（在这里不要调用它们，只需将它们作为函数引用传递）。**'
- en: Remember that static functions aren’t part of the class instance. They don’t
    have access to any specifics of the component instance such as properties or state.
    Any context for a static function needs to be passed in from the caller. In this
    case, you don’t need any context.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，静态函数不是类实例的一部分。它们无法访问组件实例的任何具体信息，如属性或状态。静态函数的任何上下文都需要从调用者那里传入。在这种情况下，你不需要任何上下文。
- en: '|  |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Static functions**'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '**静态函数**'
- en: '*Static functions* live on the React class or any JavaScript class. These functions
    can be called without instantiating an instance of the class.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '*静态函数*存在于 React 类或任何 JavaScript 类中。这些函数可以在不实例化类的情况下被调用。'
- en: Why would you want to use a static function? Usually, they’re used to provide
    a utility. In an isomorphic application, you can use static functions to define
    the data calls that a React component needs to be rendered.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 你为什么要使用静态函数呢？通常，它们被用来提供工具。在同构应用中，你可以使用静态函数来定义 React 组件需要渲染的数据调用。
- en: '|  |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 7.3.3\. Adding data prefetching via middleware
  id: totrans-259
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 7.3.3\. 通过中间件添加数据预取
- en: Now that your Cart component is declaring its own data needs by defining the
    actions that need to be called for it be rendered properly, you can use the middleware
    to fetch the data before you render the components. The first thing you need to
    add is code that collects all the actions from the components on `renderProps`.
    The following listing shows you what to add to get this working.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 现在由于你的购物车组件通过定义需要调用的动作来声明其自己的数据需求，以便正确渲染，你可以使用中间件在渲染组件之前获取数据。你需要添加的第一件事是收集来自
    `renderProps` 组件上的所有动作的代码。以下列表展示了你需要添加什么来使它工作。
- en: Listing 7.16\. Calling all initial actions on components—src/middleware/renderView.jsx
  id: totrans-261
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.16\. 在组件上调用所有初始动作—src/middleware/renderView.jsx
- en: '[PRE17]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '***1* Run map on each component returned by renderProps.**'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 对 renderProps 返回的每个组件运行 map。**'
- en: '***2* Check if component is wrapped by looking for ‘connect’ (check for and
    call prefetchActions on WrappedComponent property).**'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 通过查找 ''connect'' 来检查组件是否被包裹（检查 WrappedComponent 属性并调用 prefetchActions）。**'
- en: '***3* Call prefetchActions on component if function exists, should always return
    array.**'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 如果存在，在组件上调用 prefetchActions，应该总是返回数组。**'
- en: '***4* map function will create an array of arrays—reduce it so you can concat
    them into one array.**'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* map 函数将创建一个数组数组—将其缩减以合并成一个数组。**'
- en: This code enables the server to know what actions to call for the route. Remember,
    you can call `prefetchActions` only on components that are known to React Router.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码使服务器知道为路由调用哪些动作。记住，你只能在 React Router 已知的组件上调用 `prefetchActions`。
- en: The actions array is now a list of action creators that can be called. Next
    you’ll set them up to dispatch and then use `Promise.all` to wait until all your
    initial actions complete before rendering the React components. Remember, you’re
    calling only the actions required for the current route. The following listing
    shows how to add the asynchronous code handling so that you wait to render the
    components until you have all the data needed for the route.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 动作数组现在是一个可以调用的动作创建者列表。接下来，你需要将它们设置好以进行分发，然后使用 `Promise.all` 等待所有初始动作完成后再渲染 React
    组件。记住，你只调用当前路由所需的动作。以下列表展示了如何添加异步代码处理，以便在渲染组件之前等待获取到路由所需的所有数据。
- en: Listing 7.17\. Calling all initial actions on components—src/middleware/renderView.jsx
  id: totrans-269
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 7.17\. 在组件上调用所有初始动作—src/middleware/renderView.jsx
- en: '[PRE18]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '***1* Import Provider component from React Redux (to create components with
    Redux on the server).**'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 从 React Redux 导入 Provider 组件（用于在服务器上创建带有 Redux 的组件）。**'
- en: '***2* Call store.dispatch on each action creator.**'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 在每个动作创建者上调用 store.dispatch。**'
- en: '***3* Call Promise.all on your actions—after they’ve resolved, you can render
    components.**'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 在你的动作上调用 Promise.all—在它们解析后，你可以渲染组件。**'
- en: '***4* Wrap React Router component inside Provider.**'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 将 React Router 组件包裹在 Provider 中。**'
- en: After you wrap the React Router component inside Provider, you pass the store
    into Provider. The store will now be updated with all the data fetched and updated
    by your actions.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在将 React Router 组件包裹在 Provider 中之后，你将 store 传递给 Provider。现在，store 将会更新为你的动作获取和更新的所有数据。
- en: Displaying data in the cart
  id: totrans-276
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 在购物车中显示数据
- en: Because the app is now fetching the data for the route, you can make your Cart
    component update with the dynamic data. The following listing shows the additional
    logic in your Cart component that displays each cart item.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 因为应用现在正在获取路由的数据，你可以使购物车组件根据动态数据更新。以下列表显示了购物车组件中显示每个购物车项目的附加逻辑。
- en: Listing 7.18\. Complete Cart component—components/cart.jsx
  id: totrans-278
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表7.18\. 完整的购物车组件—components/cart.jsx
- en: '[PRE19]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '***1* Calculate total based on cart items on prop, use reduce to return sum
    of all prices.**'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 基于属性上的购物车项目计算总额，使用reduce函数返回所有价格的总和。**'
- en: '***2* Placeholder click handler for button (you won’t see console.log output
    because you haven’t hooked up the browser code).**'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 按钮的占位符点击处理程序（因为你还没有连接浏览器代码，所以你不会看到控制台输出）。**'
- en: '***3* Render cart items with the Item component, create new Item for each item
    in items array.**'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 使用Item组件渲染购物车项目，为items数组中的每个项目创建新的Item。**'
- en: '***4* Hook up cart to Redux so it can get cart items on props.**'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 将购物车连接到Redux，以便它可以从props中获取购物车项目。**'
- en: Restart the app. Then if you navigate to /cart, you’ll see each item fully rendered.
    But the Checkout button doesn’t work! You won’t see any console output when you
    click it because you haven’t rehydrated the React tree in the browser. [Chapter
    8](kindle_split_020_split_000.xhtml#ch08) will teach you how to make the server/browser
    handoff and get the browser-specific code working.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 重新启动应用。然后如果你导航到/cart，你会看到每个项目都完全渲染。但是结账按钮不起作用！当你点击它时，你不会看到任何控制台输出，因为你还没有在浏览器中重新激活React树。[第8章](kindle_split_020_split_000.xhtml#ch08)将教你如何进行服务器/浏览器交接并使浏览器特定的代码工作。
- en: Summary
  id: totrans-285
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to implement server-side rendering. You wrote
    Express middleware that handles the routing and rendering for your app. And you
    learned how to use Redux on the server and prefetch your data to create the Cart
    component on the server.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何实现服务器端渲染。你编写了Express中间件来处理你的应用的路由和渲染。你还学习了如何在服务器上使用Redux并预取数据以在服务器上创建购物车组件。
- en: Express can be used to render your views.
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Express可以用来渲染你的视图。
- en: You can use React Router on the server so you don’t have to duplicate your routing
    code.
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在服务器上使用React Router，这样你就不必重复你的路由代码。
- en: You create and use custom Express middleware to determine the route you’re on
    and render the components for the current route.
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你创建并使用自定义Express中间件来确定你所在的路线并渲染当前路线的组件。
- en: React provides a method called `renderToString` that allows you to return a
    string including the markup from your route.
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React提供了一个名为`renderToString`的方法，它允许你返回一个字符串，包括来自你的路由的标记。
- en: Instead of letting the normal app flow fetch your data, you prefetch the data
    needed for your components.
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要让正常的应用流程获取你的数据，而是预取你组件所需的数据。
- en: Chapter 8\. Isomorphic view rendering
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第8章\. 同构视图渲染
- en: '*This chapter covers*'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Creating an entry point for the browser code that renders your React components
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建浏览器代码的渲染React组件的入口点
- en: Serializing the data so the browser code can start up (bootstrap) with the state
    from the server
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 序列化数据，以便浏览器代码可以从服务器状态启动（引导）
- en: Deserializing the data in the browser to hydrate your code
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在浏览器中反序列化数据以使你的代码生效
- en: Including information from the original server request in your serialized data
    to maintain a consistent state between the browser and the server
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的序列化数据中包含来自原始服务器请求的信息，以在浏览器和服务器之间保持一致的状态
- en: Transitioning to a single-page application (SPA) experience to handle user interactions
    in the browser
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转向单页应用程序（SPA）体验以处理浏览器中的用户交互
- en: Throughout this chapter, you’ll build the browser portion of the isomorphic
    view render. You’re focusing on the lower half of the image in [figure 8.1](kindle_split_020_split_000.xhtml#ch08fig01).
    You’ve seen this figure many times, but I’m revisiting it here to give context
    to this chapter.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将构建同构视图渲染的浏览器部分。你将专注于图像的下半部分[图8.1](kindle_split_020_split_000.xhtml#ch08fig01)。你已经看到这个图多次了，但我在这里重新讨论它，以提供本章的背景。
- en: Figure 8.1\. This chapter focuses on the lower half of the flow, everything
    that happens after the server render (the browser render and the SPA logic).
  id: totrans-300
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.1\. 本章重点介绍流程的下半部分，即服务器渲染之后发生的一切（浏览器的渲染和SPA逻辑）。
- en: '![](Images/08fig01_alt.jpg)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/08fig01_alt.jpg)'
- en: All the code for this chapter is in the same GitHub repo that’s used in [chapter
    7](kindle_split_019_split_000.xhtml#ch07), which can be found at [http://mng.bz/8gV8](http://mng.bz/8gV8).
    After you’ve pulled down this code, switch to chapter-8.1.1 (`git checkout chapter-8.1.1`),
    which has the code for the first section of the chapter. Each branch provided
    in a section includes the skeleton code needed from previous sections, but not
    what will be added in that specific section. The next section’s code will contain
    the complete code from previous sections. Each time you need to switch branches,
    I’ll let you know.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有代码都在与第7章相同的GitHub仓库中，该仓库可以在[http://mng.bz/8gV8](http://mng.bz/8gV8)找到。在您拉取此代码后，切换到chapter-8.1.1（`git
    checkout chapter-8.1.1`），其中包含本章第一部分的代码。每个部分提供的分支都包括从前一节需要的骨架代码，但不包括在该特定节中添加的内容。下一节的代码将包含前一节的完整代码。每次您需要切换分支时，我都会通知您。
- en: 'Remember that you need to run the `start` command each time you want to build
    the code (and after you make any changes):'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，每次您想要构建代码（以及您做出任何更改后）都需要运行`start`命令：
- en: '[PRE20]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The app runs at http://localhost:3000 in your browser.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序在您的浏览器中以http://localhost:3000运行。
- en: 8.1\. Setting up the browser entry point
  id: totrans-306
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.1\. 设置浏览器入口点
- en: 'The first thing you need to do to render your code in the browser is to set
    up your browser entry point. This is called main.jsx. It’ll be where you bootstrap
    (initialize) your React code in the browser. Your main.jsx entry point will end
    up being responsible for several things, including the following:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要做的第一件事是将代码在浏览器中渲染，就是设置您的浏览器入口点。这被称为main.jsx。它将是您在浏览器中引导（初始化）React代码的地方。您的main.jsx入口点最终将负责几件事情，包括以下内容：
- en: Deserializing the server state
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反序列化服务器状态
- en: Initializing Redux with the current state
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用当前状态初始化Redux
- en: Setting up React Router
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置React Router
- en: Rendering React components in the browser
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在浏览器中渲染React组件
- en: 8.1.1\. Referencing the browser code
  id: totrans-312
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.1.1\. 引用浏览器代码
- en: To get the browser code loading, you need to make sure to reference it from
    your HTML. It needs to be included as a script in the page, at the end of the
    body. That ensures it doesn’t block page loading and rendering. Because the page
    was already rendered once on the server, your user won’t know the script hasn’t
    loaded yet!
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 要使浏览器代码加载，您需要确保从您的HTML中引用它。它需要作为页面中的脚本包含在body的末尾。这确保了它不会阻止页面加载和渲染。因为页面已经在服务器上渲染了一次，所以您的用户不会知道脚本尚未加载！
- en: The code in the branch (chapter-8.1.1) already includes the webpack configuration.
    When you run `npm start`, the browser code is created by webpack and is available
    to use in the app. Open the html.jsx file and use the code from the following
    listing to add a reference to the bundled browser file. Note that in production,
    you’d want to make this URL configurable to wherever your static asset files will
    live.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 分支（chapter-8.1.1）中的代码已经包含了webpack配置。当您运行`npm start`时，webpack会创建浏览器代码，并在应用程序中使用。打开html.jsx文件，并使用以下列表中的代码添加对打包的浏览器文件的引用。请注意，在生产环境中，您可能希望将此URL配置为静态资产文件所在的位置。
- en: Listing 8.1\. Adding your browser source code—src/components/html.jsx
  id: totrans-315
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.1\. 添加您的浏览器源代码—src/components/html.jsx
- en: '[PRE21]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '***1* Insert a script tag that points to your JavaScript bundle.**'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 插入一个指向您的JavaScript包的script标签。**'
- en: After you’ve done this, restart the server. To check whether the browser.js
    file is properly loading, use the Network tab in Chrome DevTools to see if it
    loaded. [Figure 8.2](kindle_split_020_split_001.xhtml#ch08fig02) shows what to
    look for.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在您完成此操作后，重新启动服务器。要检查browser.js文件是否正确加载，请使用Chrome DevTools中的网络标签查看是否已加载。[图8.2](kindle_split_020_split_001.xhtml#ch08fig02)显示了您需要查找的内容。
- en: Figure 8.2\. Using the Network tab of Chrome Developer Tools to confirm that
    your JavaScript code is loading in the browser
  id: totrans-319
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.2\. 使用Chrome开发者工具的网络标签确认您的JavaScript代码是否在浏览器中加载
- en: '![](Images/08fig02_alt.jpg)'
  id: totrans-320
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/08fig02_alt.jpg)'
- en: You should also try adding a `console.log` statement or setting a breakpoint
    to verify that your script is loading. After you get this working, you’re ready
    to render your React components in the browser.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 您还应该尝试添加一个`console.log`语句或设置一个断点来验证您的脚本是否已加载。在您成功完成此操作后，您就可以在浏览器中渲染您的React组件了。
- en: 8.1.2\. Rendering React in the browser
  id: totrans-322
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.1.2\. 在浏览器中渲染React
- en: This section covers how to render React in the browser. We already covered this
    in [chapter 3](kindle_split_014_split_000.xhtml#ch03), when you learned all about
    using React. I’m going to revisit the core implementation details here. Also,
    I’ll demonstrate why this step is necessary.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了如何在浏览器中渲染React。我们已经在[第3章](kindle_split_014_split_000.xhtml#ch03)中介绍了这一点，当时你学习了所有关于使用React的内容。我将在这里重新回顾核心实现细节。此外，我将演示这一步骤为什么是必要的。
- en: Let’s start with the /cart route because it’s already built out from [chapter
    7](kindle_split_019_split_000.xhtml#ch07). In case you don’t remember, [figure
    8.3](kindle_split_020_split_001.xhtml#ch08fig03) shows what it looked like by
    the end of [chapter 7](kindle_split_019_split_000.xhtml#ch07).
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`/cart`路由开始，因为它已经在[第7章](kindle_split_019_split_000.xhtml#ch07)中构建出来了。如果你不记得，[图8.3](kindle_split_020_split_001.xhtml#ch08fig03)展示了它在[第7章](kindle_split_019_split_000.xhtml#ch07)结束时的样子。
- en: Figure 8.3\. The Cart page of your application before rendering in the browser
    or adding SPA functionality
  id: totrans-325
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.3\. 在浏览器渲染或添加SPA功能之前的应用程序购物车页面
- en: '![](Images/08fig03_alt.jpg)'
  id: totrans-326
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/08fig03_alt.jpg)'
- en: So far, you’ve made this render only on the server. Some things don’t yet work,
    such as the Checkout button, which has a button handler with additional logic.
    The first step to getting that hooked up in the browser is to call `ReactDOM.render`
    in the browser. You’re going to add a simple render call that displays a Browser
    Render message after the browser code is executed and rendered. [Figure 8.4](kindle_split_020_split_001.xhtml#ch08fig04)
    shows what this looks like.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你只在这个服务器上进行了渲染。一些事情还没有工作，比如具有附加逻辑的结账按钮。在浏览器中连接这一步骤的第一步是在浏览器中调用`ReactDOM.render`。你将添加一个简单的渲染调用，在浏览器代码执行并渲染后显示浏览器渲染消息。[图8.4](kindle_split_020_split_001.xhtml#ch08fig04)显示了它的样子。
- en: Figure 8.4\. The expected output after you render a simple `div` and message
    in the browser
  id: totrans-328
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.4\. 在浏览器中渲染一个简单的`div`和消息后的预期输出
- en: '![](Images/08fig04_alt.jpg)'
  id: totrans-329
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/08fig04_alt.jpg)'
- en: To get this output, you need to set up main.jsx with React and then call `render`.
    [Listing 8.2](kindle_split_020_split_001.xhtml#ch08ex02) shows your entry point
    file rendering a simple `div` with a message. Add the code from the listing to
    main.jsx. If you need to catch up, all the code up to this point is on the branch
    called chapter-8.1.2 (`git checkout chapter-8.1.2`). Or you can keep working on
    your code that you have up to this point.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 要得到这个输出，你需要使用React设置main.jsx，然后调用`render`。[列表8.2](kindle_split_020_split_001.xhtml#ch08ex02)显示了你的入口文件如何渲染一个带有消息的简单`div`。将列表中的代码添加到main.jsx中。如果你需要赶上进度，所有这些代码都在名为chapter-8.1.2的分支上（`git
    checkout chapter-8.1.2`）。或者你也可以继续编写你到目前为止的代码。
- en: Listing 8.2\. Rendering an HTML element in the browser—src/main.jsx
  id: totrans-331
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.2\. 在浏览器中渲染HTML元素—src/main.jsx
- en: '[PRE22]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '***1* You must include React and React DOM to call render in this file.**'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 你必须包含React和React DOM才能在这个文件中调用render。**'
- en: '***2* Create an init function so you can add asynchronous code to your entry
    point.**'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 创建一个init函数，这样你就可以在你的入口点添加异步代码。**'
- en: '***3* Call render function with a simple div element.**'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 使用简单的div元素调用render函数。**'
- en: '***4* Pass in the DOM element; React will render your div into.**'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 传入DOM元素；React将你的div渲染到其中。**'
- en: The obvious problem with this code is that your application has disappeared!
    That’s not what you want to happen. Open your developer tools and select the Sources
    tab to set a breakpoint in your main.jsx file. (Use Cmd-P and search for main.jsx—then
    you’ll be able to set the breakpoint.) [Figure 8.5](kindle_split_020_split_001.xhtml#ch08fig05)
    shows what your Chrome DevTools will look like after setting the breakpoint.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的明显问题是你的应用程序消失了！这不是你想要发生的。打开你的开发者工具并选择资源标签页，在main.jsx文件中设置断点。（使用Cmd-P并搜索main.jsx—然后你将能够设置断点。）[图8.5](kindle_split_020_split_001.xhtml#ch08fig05)显示了设置断点后你的Chrome
    DevTools将看起来是什么样子。
- en: Figure 8.5\. Set a breakpoint on line 5 of main.jsx in the Sources tab of Chrome
    Developer Tools. This lets you view the browser output before the browser JavaScript
    runs.
  id: totrans-338
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.5\. 在Chrome开发者工具的资源标签页中设置main.jsx的第5行断点。这让你可以在浏览器JavaScript运行之前查看浏览器输出。
- en: '![](Images/08fig05_alt.jpg)'
  id: totrans-339
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/08fig05_alt.jpg)'
- en: Now that you’ve set the breakpoint, refresh your browser. The code execution
    will pause on your breakpoint. Look at your app in the main browser window. It’ll
    look correct, with the cart route rendered (as in [figure 8.3](kindle_split_020_split_001.xhtml#ch08fig03)).
    If your app is loading but you notice a React error in the console output, don’t
    worry about it for now (something like “React attempted to reuse markup in a container”).
    I’ll explain that later in the chapter.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经设置了断点，刷新你的浏览器。代码执行将在你的断点上暂停。查看主浏览器窗口中的你的应用。它看起来应该是正确的，购物车路由已渲染（如[图8.3](kindle_split_020_split_001.xhtml#ch08fig03)所示）。如果你的应用正在加载，但你在控制台输出中注意到React错误，现在不用担心（类似于“React尝试在容器中重用标记”的错误）。我将在本章后面解释这一点。
- en: Compare the DOM markup from the two states to see what’s going on before and
    after the browser render. [Figure 8.6](kindle_split_020_split_001.xhtml#ch08fig06)
    shows the markup before and after the browser render call is made.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 将两个状态中的DOM标记进行比较，以查看浏览器渲染前后的情况。[图8.6](kindle_split_020_split_001.xhtml#ch08fig06)显示了浏览器渲染调用之前的标记。
- en: Figure 8.6\. Comparing the DOM from the server render with the DOM from the
    `div` rendered in main.jsx
  id: totrans-342
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.6\. 比较服务器渲染的DOM与main.jsx中渲染的`div`的DOM
- en: '![](Images/08fig06_alt.jpg)'
  id: totrans-343
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/08fig06_alt.jpg)'
- en: In this section, you’ve set up the browser code to run and added a simple React
    render to the browser. This illustrates the interaction between the server render
    and the initial browser render. In the next section, we’ll walk through using
    the server state in the browser.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你已经设置了浏览器代码以运行，并向浏览器添加了一个简单的React渲染。这说明了服务器渲染和初始浏览器渲染之间的交互。在下一节中，我们将介绍如何在浏览器中使用服务器状态。
- en: 8.2\. Matching server state on the first render
  id: totrans-345
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.2\. 首次渲染时匹配服务器状态
- en: 'To make the app isomorphic, you need to re-create the state from the server.
    Follow these steps:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 要使应用同构，你需要从服务器重新创建状态。按照以下步骤操作：
- en: '**1**.  Serialize the state of the app on the server and send it down in the
    stringified DOM markup.'
  id: totrans-347
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**. 在服务器上序列化应用状态，并将其以字符串化的DOM标记形式发送下来。'
- en: '**2**.  Deserialize the state on the browser so it’s a consumable JSON object.'
  id: totrans-348
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**. 在浏览器上反序列化状态，使其成为一个可消费的JSON对象。'
- en: '**3**.  Initialize Redux with the app state (JSON object).'
  id: totrans-349
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**3**. 使用应用状态（JSON对象）初始化Redux。'
- en: '**4**.  Pass the initialized Redux store into your React components.'
  id: totrans-350
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**4**. 将初始化的Redux存储传递给你的React组件。'
- en: '[Figure 8.7](kindle_split_020_split_002.xhtml#ch08fig07) shows this flow in
    the context of the All Things Westies app.'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '[图8.7](kindle_split_020_split_002.xhtml#ch08fig07)显示了在All Things Westies应用上下文中的此流程。'
- en: Figure 8.7\. The flow of the state serialization/deserialization
  id: totrans-352
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.7\. 状态序列化/反序列化的流程
- en: '![](Images/08fig07_alt.jpg)'
  id: totrans-353
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/08fig07_alt.jpg)'
- en: It’s important to remember that the state created on the server needs to *exactly*
    match the state used to bootstrap your React code on the browser. That ensures
    that there’s no need to update the browser DOM during the initial load of the
    page.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，在服务器上创建的状态需要与用于在浏览器上启动你的React代码的状态**完全匹配**。这确保了在页面初始加载期间无需更新浏览器DOM。
- en: First, let’s set up the data on the server—both serializing it and then sending
    it down to the browser to be consumed.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们在服务器上设置数据——既序列化它，然后将其发送到浏览器以供消费。
- en: 8.2.1\. Serializing the data on the server
  id: totrans-356
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.2.1\. 在服务器上序列化数据
- en: In this section, you’ll update the code in renderView.jsx (created in [chapter
    7](kindle_split_019_split_000.xhtml#ch07)). The first step is to capture and serialize
    the current app state.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将更新renderView.jsx中的代码（在[第7章](kindle_split_019_split_000.xhtml#ch07)中创建）。第一步是捕获和序列化当前应用状态。
- en: '|  |'
  id: totrans-358
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Definition
  id: totrans-359
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 定义
- en: '*Serialization* is the act of taking data (often JSON in JavaScript) and converting
    it to a format that can be sent between environments. In this case, you send it
    from the server to the browser via a network request.'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '*序列化*是将数据（通常是JavaScript中的JSON）转换为可以在环境之间发送的格式的行为。在这种情况下，你通过网络请求从服务器发送到浏览器。'
- en: '|  |'
  id: totrans-361
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: By the end of this section, you’ll be able to access your server state in the
    console because you’ll be putting the server state on the `window` object. [Figure
    8.8](kindle_split_020_split_002.xhtml#ch08fig08) shows this output in Chrome Developer
    Tools.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 到本节结束时，你将能够通过在`window`对象上放置服务器状态来在控制台中访问你的服务器状态。[图8.8](kindle_split_020_split_002.xhtml#ch08fig08)显示了在Chrome开发者工具中的此输出。
- en: Figure 8.8\. The serialized state in the browser
  id: totrans-363
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图8.8\. 浏览器中的序列化状态
- en: '![](Images/08fig08_alt.jpg)'
  id: totrans-364
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/08fig08_alt.jpg)'
- en: You can switch to the chapter-8.2.1 branch to get the base code for this section
    (`git checkout chapter-8.2.1`), or keep following along with the code you’ve added
    so far. The branch has all the code listings so far. The following listing walks
    you through how to get and serialize your app’s current state in your `renderView`
    middleware. Add this new code to the `renderView` middleware.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以切换到chapter-8.2.1分支以获取本节的基础代码（`git checkout chapter-8.2.1`），或者继续使用你迄今为止添加的代码。该分支包含迄今为止的所有代码列表。以下列表指导你如何在`renderView`中间件中获取和序列化你的应用当前状态。将此新代码添加到`renderView`中间件。
- en: Listing 8.3\. Capture and serialize current app state—src/middleware/renderView.jsx
  id: totrans-366
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.3\. 捕获并序列化当前应用状态—src/middleware/renderView.jsx
- en: '[PRE23]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '***1* Get current state of the Redux store—getState() is a helper method that
    returns the store.**'
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 获取Redux存储的当前状态——getState()是一个辅助方法，它返回存储。**'
- en: '***2* Serialize the state by creating a string from the JSON.**'
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 通过从JSON创建字符串来序列化状态。**'
- en: '***3* Pass the serialized state into the HTML component as a serverState prop.**'
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 将序列化状态作为serverState属性传递给HTML组件。**'
- en: Now that you’ve created the string representation of the current app state,
    you need to set it in the DOM markup. You do that using `dangerouslySetInnerHTML`
    and a script tag. The following listing shows the code to add to html.jsx.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经创建了当前应用状态的字符串表示，你需要将其设置在DOM标记中。你使用`dangerouslySetInnerHTML`和script标签来完成这个操作。以下列表显示了要添加到html.jsx中的代码。
- en: Listing 8.4\. Set the serialized state in the DOM—src/components/html.jsx
  id: totrans-372
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.4\. 在DOM中设置序列化状态—src/components/html.jsx
- en: '[PRE24]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '***1* Should be placed at end of body (so it isn’t render blocking) but before
    main JavaScript executes—browser.js depends on the state being available on the
    window object.**'
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 应放置在body的末尾（这样就不会阻塞渲染）但在主JavaScript执行之前—browser.js依赖于状态在window对象上可用。**'
- en: '***2* Set innerHTML of script tag so the string of JSON is placed inside the
    script tag.**'
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 设置script标签的innerHTML，以便JSON字符串放在script标签内。**'
- en: '***3* Set state on the __SERIALIZED_STATE__ property of window.**'
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 在window的__SERIALIZED_STATE__属性上设置状态。**'
- en: '***4* Assign stringified server state.**'
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 分配字符串化的服务器状态。**'
- en: 'Upon restarting the server, you’ll be able to see your app state stringified
    and printed in the browser console (as in [figure 8.8](kindle_split_020_split_002.xhtml#ch08fig08))
    by running the following:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 重新启动服务器后，你将能够在浏览器控制台中看到你的应用状态字符串化并打印出来（如[图8.8](kindle_split_020_split_002.xhtml#ch08fig08)所示），通过运行以下命令：
- en: '[PRE25]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Although it’s cool that you can now see your state in the browser, this isn’t
    useful. In the next two sections, we’ll walk through how to take this state and
    use it with Redux and your React components.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你现在可以在浏览器中看到你的状态很酷，但这并没有什么用。在接下来的两个部分中，我们将介绍如何使用Redux和你的React组件来使用这个状态。
- en: 8.2.2\. Deserializing the data in the browser
  id: totrans-381
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.2.2\. 在浏览器中反序列化数据
- en: If this sounds complicated and scary, don’t fear! It’s simple. In fact, it’s
    easier than serializing the state in the first place. The goal is to take the
    stringified data that the server sends down and get it into a state that the app
    can work with. You take a string input and turn it back into a JavaScript object.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这听起来复杂且令人害怕，别担心！其实很简单。实际上，这比最初序列化状态还要简单。目标是获取服务器发送下来的字符串化数据，并将其转换成应用可以处理的状态。你接收一个字符串输入，并将其转换回一个JavaScript对象。
- en: '|  |'
  id: totrans-383
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Definition
  id: totrans-384
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 定义
- en: '*Deserialization* is the act of taking serialized data and converting it to
    a format that’s usable by the current environment. In this case, you take a string
    and convert it to a JavaScript object.'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '*反序列化*是指将序列化数据转换为当前环境可用的格式。在这种情况下，你将一个字符串转换为JavaScript对象。'
- en: '|  |'
  id: totrans-386
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The following listing shows the code you need to add to main.jsx to get the
    state off the window object. Parse the `window.__SERIALIZED_STATE__` value and
    save it to a variable.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了你需要添加到main.jsx中的代码，以从window对象获取状态。解析`window.__SERIALIZED_STATE__`值并将其保存到变量中。
- en: Listing 8.5\. Getting the state in the browser—src/main.jsx
  id: totrans-388
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表8.5\. 在浏览器中获取状态—src/main.jsx
- en: '[PRE26]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '***1* Parse string into an usable object.**'
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将字符串解析成可用的对象。**'
- en: '***2* Add log statement to see that it worked in the console.**'
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 在控制台添加日志语句以查看它是否工作。**'
- en: If you view the browser console, you’ll see the state. That’s all there is to
    deserializing the app state. Next, you’ll take this state and inject it into Redux
    so your app starts up in the same state as on the server.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看浏览器控制台，你会看到状态。这就是反序列化应用状态的全部内容。接下来，你将这个状态注入到Redux中，以便你的应用以与服务器相同的状态启动。
- en: 8.2.3\. Hydrating the store
  id: totrans-393
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.2.3\. 储存活化
- en: Now that you have the state deserialized, you need to initialize Redux with
    the state that was generated on the server. You don’t need to add any new Redux
    code; everything you created in [chapter 7](kindle_split_019_split_000.xhtml#ch07)
    works perfectly here. The branch for this section is chapter-8.2.3 (`git checkout`).
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经反序列化了状态，你需要使用在服务器上生成的状态初始化 Redux。你不需要添加任何新的 Redux 代码；你在第 7 章（kindle_split_019_split_000.xhtml#ch07）中创建的所有内容在这里都工作得很好。本节的分支是
    chapter-8.2.3 (`git checkout`）。
- en: '|  |'
  id: totrans-395
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-396
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: If you’re using React Router 4, check out [appendix A](kindle_split_027_split_000.xhtml#app01)
    for an overview of setting up the routes and related router code. The appendix
    shows the main.jsx setup code compared to the Router code in [listing 8.6](kindle_split_020_split_002.xhtml#ch08ex06)
    in this chapter.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是 React Router 4，请查看附录 A（kindle_split_027_split_000.xhtml#app01），了解设置路由和相关路由代码的概述。附录显示了与本章中列表
    8.6（kindle_split_020_split_002.xhtml#ch08ex06）中的 Router 代码相比的 main.jsx 设置代码。
- en: '|  |'
  id: totrans-398
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: All you need to do in main.jsx is initialize Redux with the correct state. The
    following listing shows you how to pass in the state to the init Redux function.
    You should update main.jsx with this code (replacing the placeholder code from
    the previous sections).
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 在 main.jsx 中，你需要做的只是使用正确的状态初始化 Redux。以下列表显示了如何将状态传递给 init Redux 函数。你应该使用此代码更新
    main.jsx（替换前几节中的占位符代码）。
- en: Listing 8.6\. Setting up Redux and the component tree—src/main.jsx
  id: totrans-400
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.6\. 设置 Redux 和组件树—src/main.jsx
- en: '[PRE27]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '***1* Include the Provider component from React Redux so components have access
    to the store as needed.**'
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 包含 React Redux 的 Provider 组件，以便组件可以根据需要访问存储。**'
- en: '***2* Include the Router component from React Router, which configures Routes
    from sharedRoutes, and include the correct history for the browser environment.**'
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 包含 React Router 的 Router 组件，从 sharedRoutes 配置路由，并包含浏览器环境的正确历史记录。**'
- en: '***3* Include Redux bootstrapping code.**'
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 包含 Redux 引导代码。**'
- en: '***4* Include sharedRoutes.**'
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 包含 sharedRoutes。**'
- en: '***5* Create Redux store based on deserialized state.**'
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 根据反序列化状态创建 Redux 存储。**'
- en: '***6* Pass store into the Provider component as a prop.**'
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 将存储作为属性传递给 Provider 组件。**'
- en: '***7* Pass sharedRoutes and browserHistory into Router as props.**'
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 将 sharedRoutes 和 browserHistory 作为属性传递给 Router。**'
- en: 'Main.jsx imports initRedux from initRedux.jsx. The code in the initRedux.jsx
    module takes in the state and creates the store. That’s how you hydrate the store.
    You added this code in [chapter 7](kindle_split_019_split_000.xhtml#ch07). It’s
    shown here as a reminder, but it’s already in the repo for you in src/shared/init-redux.es6:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: Main.jsx 从 initRedux.jsx 导入 initRedux。initRedux.jsx 模块中的代码接受状态并创建存储。这就是你如何使存储保持一致。你已经在第
    7 章（kindle_split_019_split_000.xhtml#ch07）中添加了此代码。这里显示为提醒，但它已经包含在 src/shared/init-redux.es6
    的代码库中：
- en: '[PRE28]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Notice that the `initialStore` param that’s passed into the function is used
    in the `createStore` function to initialize the Redux store. Because this happens
    before your components are created, the first render of your components ends up
    using the state from the server.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，传递给函数的 `initialStore` 参数在 `createStore` 函数中使用，以初始化 Redux 存储。因为这是在创建组件之前发生的，所以你的组件的第一次渲染最终使用了来自服务器的状态。
- en: With the state from the server, React is able to calculate that the initial
    virtual DOM matches the DOM attached to the root container provided to the render
    function. It knows that making any browser DOM updates is unnecessary.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 使用来自服务器的状态，React 能够计算出初始虚拟 DOM 与提供给 render 函数的根容器附加的 DOM 匹配。它知道不需要进行任何浏览器 DOM
    更新。
- en: Now that you’ve successfully rendered the view in the browser, let’s explore
    potential gotchas around the details of the first render in the browser. Note
    that up to this point, you’ve only set up the code that handles the initial render.
    Later in the chapter, you’ll add support for getting data when routing in the
    browser.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经在浏览器中成功渲染了视图，让我们来探讨浏览器中第一次渲染的潜在问题。请注意，到目前为止，你只设置了处理初始渲染的代码。在本章的后面部分，你将添加在浏览器中路由时获取数据的功能。
- en: 8.3\. Performing the first load
  id: totrans-414
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.3\. 执行第一次加载
- en: At this point, it should be clear how to get your app loading in the browser.
    It’s also important to understand what happens during the initial render in the
    browser, because it’s different from what happens later as the user interacts
    with the app.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你应该清楚如何在浏览器中加载你的应用程序。了解浏览器中初始渲染过程中发生的事情也很重要，因为这与用户与应用程序交互后发生的情况不同。
- en: 8.3.1\. The React lifecycle on the first load
  id: totrans-416
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.3.1\. 第一次加载时的 React 生命周期
- en: 'This section walks you through the first render of React in the browser. React
    begins to bootstrap in your main.jsx file when you call `ReactDOM.render`. Each
    component that’s being initiated goes through the following steps:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将带您了解 React 在浏览器中的首次渲染。当您调用 `ReactDOM.render` 时，React 开始在您的 main.jsx 文件中进行引导。每个正在启动的组件都会经过以下步骤：
- en: '**1**.  The constructor is called.'
  id: totrans-418
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**. 调用构造函数。'
- en: '**2**.  `componentWillMount` is triggered.'
  id: totrans-419
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**. 触发 `componentWillMount`。'
- en: '**3**.  The render method is called.'
  id: totrans-420
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**3**. 调用渲染方法。'
- en: '**4**.  `componentDidMount` is called.'
  id: totrans-421
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**4**. 调用 `componentDidMount`。'
- en: Remember that this starts with the root components, which all come from third-party
    libraries (React Redux and React Router). It then moves on to the components that
    React Router calculates need to be loaded for the current route. Then any of their
    child components are rendered.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，这从根组件开始，所有这些组件都来自第三方库（React Redux 和 React Router）。然后它继续到 React Router 计算出需要加载当前路由的组件。然后渲染它们的任何子组件。
- en: Initial render differences
  id: totrans-423
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 初始渲染差异
- en: 'It’s important to understand that `componentWillMount` is called on the first
    load for every component on both the server and the browser! Any code you have
    in it needs to be truly isomorphic. For example, if you were to add the following
    code to src/components/app.jsx, your server would break and be unable to load
    any routes:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解 `componentWillMount` 在服务器和浏览器的每个组件的首次加载时都会被调用！其中任何代码都需要真正是同构的。例如，如果您要将以下代码添加到
    src/components/app.jsx 中，您的服务器将崩溃并且无法加载任何路由：
- en: '[PRE29]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: That’s because your server can’t find a global variable called `window`. The
    `window` object doesn’t exist in Node.js. If you put this code into any of the
    methods that run during the first render (`constructor`, `componentWillMount`,
    or `render`), it’ll break on the server.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为您的服务器找不到一个名为 `window` 的全局变量。`window` 对象在 Node.js 中不存在。如果您将此代码放入任何在首次渲染期间运行的方法（`constructor`、`componentWillMount`
    或 `render`）中，它将在服务器上崩溃。
- en: Conversely, `componentDidMount`, which runs after the first render is complete,
    is called only in the browser. This distinction becomes powerful when you need
    to update a component after reaching the browser but you don’t want to break the
    isomorphic render.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，`componentDidMount` 在首次渲染完成后运行，仅在浏览器中调用。当您需要在到达浏览器后更新组件但不想破坏同构渲染时，这种区别变得非常有用。
- en: 8.3.2\. Isomorphic render errors
  id: totrans-428
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.3.2\. 同构渲染错误
- en: You may have noticed a big red warning in the console early in this chapter.
    [Figure 8.9](kindle_split_020_split_003.xhtml#ch08fig09) shows what that looks
    like.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能在本章早期注意到控制台中的一个大红色警告。[图 8.9](kindle_split_020_split_003.xhtml#ch08fig09)
    展示了它的样子。
- en: Figure 8.9\. The isomorphic warning log that React issues when it’s detected
    an isomorphic render that isn’t truly isomorphic. This happens when the virtual
    DOM from the initial render cycle and the browser DOM don’t match.
  id: totrans-430
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 8.9\. 当 React 检测到非真正同构的同构渲染时，它发出的同构警告日志。这发生在初始渲染周期的虚拟 DOM 和浏览器 DOM 不匹配时。
- en: '![](Images/08fig09_alt.jpg)'
  id: totrans-431
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/08fig09_alt.jpg)'
- en: 'This isn’t a fun error. (To be fair, errors aren’t usually fun.) It sounds
    hard to debug the first time you read it: “the checksum was invalid”—what the
    bleep does that mean?'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一个有趣的错误。（公平地说，错误通常都不好玩。）第一次看到它时，感觉很难调试：“校验和无效”——这究竟是什么意思？
- en: It means React rendered the component tree in the browser, compared it to the
    DOM that already exists, and found it to be different. But React is smart and
    knows that if there are already children inside the DOM element that you told
    it to render into, this is an isomorphic render. The two DOMs should match on
    the first render. But something broke, and they didn’t match!
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着 React 在浏览器中渲染了组件树，将其与已存在的 DOM 进行比较，并发现它们不同。但 React 很聪明，知道如果 DOM 元素中已经存在您告诉它渲染的子元素，这是一个同构渲染。这两个
    DOM 在首次渲染时应该匹配。但出了点问题，它们没有匹配！
- en: The experiment that broke the render
  id: totrans-434
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 破坏渲染的实验
- en: At work, we often run a/b tests to experiment with various design and UX implementations
    to find out what works best to meet our goals with the product. One day we went
    to test our Login button. We wanted to find out whether we should call it “Login”
    or “Signup.” Even though the team is experienced in working with an isomorphic
    app, the experiment still ended up being run inside `componentWillMount` of our
    header component, and the isomorphic render warning started getting thrown.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 在工作中，我们经常运行 A/B 测试来尝试各种设计和 UX 实现，以找出什么最能帮助我们实现产品目标。有一天我们去测试我们的登录按钮。我们想知道是否应该将其称为“登录”或“注册”。尽管团队在处理同构应用方面经验丰富，但实验最终还是在我们头部组件的
    `componentWillMount` 中进行，同构渲染警告开始被抛出。
- en: Adding to our problems, another update was made to the code (around the same
    time) that changed the app state inside `componentWillMount`. It turns out that
    React will display this warning only for the first instance it runs into, which
    meant that when we fixed the first problem, we uncovered the second problem.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 更糟糕的是，代码（大约在同一时间）的另一个更新改变了 `componentWillMount` 内的应用状态。结果发现，React 只会为第一次遇到的情况显示此警告，这意味着当我们解决了第一个问题时，我们发现了第二个问题。
- en: It’s surprisingly easy to get into this situation. One small change in the browser
    to the app state anytime in the first render (inside your `constructor`, `componentWillMount`,
    or `render`) can cause the error. The most common reason I’ve seen for getting
    into this situation is changing state based on cookies.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 进入这种状况出奇地容易。在第一次渲染（在你的 `constructor`、`componentWillMount` 或 `render` 方法内部）的任何时候对浏览器中的应用状态进行微小更改都可能导致错误。我见到的进入这种状况的最常见原因是根据
    cookies 改变状态。
- en: '|  |'
  id: totrans-438
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Warning
  id: totrans-439
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 警告
- en: '*Cookies* are global state that lives outside your app code. They’re a powerful
    and important tool for web app development. But they can complicate your initial
    app state. You either should account for the cookies on the server, or make sure
    to deal with them at the correct time in the browser. [Chapter 10](kindle_split_022_split_000.xhtml#ch10)
    covers this in more depth.'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: '*Cookies* 是存在于你的应用代码之外的全局状态。它们是网络应用开发中强大且重要的工具。但它们可能会使你的初始应用状态复杂化。你要么应该在服务器上考虑
    cookies，要么确保在浏览器中正确处理它们。第 10 章 [Chapter 10](kindle_split_022_split_000.xhtml#ch10)
    将更深入地介绍这一点。'
- en: '|  |'
  id: totrans-441
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The reason you should care about this warning is that you lose all the positive
    benefits of your isomorphic render. You still have the good perceived performance—the
    UI and content is shown right away—but it can take a noticeably long time for
    the page to become usable, causing frustration for your user.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该关注这个警告的原因是，你将失去同构渲染的所有积极好处。你仍然有良好的感知性能——UI 和内容立即显示——但页面变得可用的过程可能会明显变长，这可能会让用户感到沮丧。
- en: This is where `componentDidMount` becomes a powerful tool in your application.
    The next section explores how to use it to avoid isomorphic render errors.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么 `componentDidMount` 在你的应用中成为一个强大的工具。下一节将探讨如何使用它来避免同构渲染错误。
- en: 8.3.3\. Using componentDidMount to prevent isomorphic load errors
  id: totrans-444
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.3.3\. 使用 componentDidMount 防止同构加载错误
- en: Let’s say you wanted to save a user preference in the cookies. A common use
    case is whether to show a site-wide dismissible banner. This is beneficial to
    the user because it allows for global, easily accessible state in the browser.
    But you must be vigilant about when to check for these cookies to prevent isomorphic
    errors.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想要在 cookies 中保存用户偏好。一个常见的用例是是否显示全站可关闭横幅。这对用户来说是有益的，因为它允许在浏览器中实现全局、易于访问的状态。但你必须警惕何时检查这些
    cookies 以防止同构错误。
- en: '|  |'
  id: totrans-446
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-447
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: This example and solution assume you don’t want to read cookies on the server.
    In some apps, it may be more practical to read the cookies on the server and start
    with the correct app state in the server. We’ll walk through these trade-offs
    in more depth in [chapter 10](kindle_split_022_split_000.xhtml#ch10).
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例和解决方案假设你不想在服务器上读取 cookies。在某些应用中，在服务器上读取 cookies 并从正确的应用状态开始可能更为实用。我们将在第
    10 章 [chapter 10](kindle_split_022_split_000.xhtml#ch10) 中更深入地探讨这些权衡。
- en: '|  |'
  id: totrans-449
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'In this example, you’ll add a banner that informs users of a semi-annual sale.
    The rules for showing the banner are: show it to a user if they’ve never seen
    it before, and continue showing it until they dismiss it. You track whether they’ve
    seen it by writing a cookie in the browser. [Figure 8.10](kindle_split_020_split_003.xhtml#ch08fig10)
    shows what you want this to look like.'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你将添加一个横幅，通知用户关于半年度促销的信息。显示横幅的规则是：如果用户之前从未见过它，就显示它，直到他们将其关闭。你通过在浏览器中写入一个
    cookie 来跟踪他们是否见过它。[图 8.10](kindle_split_020_split_003.xhtml#ch08fig10) 展示了你希望它看起来像什么。
- en: Figure 8.10\. Adding a banner to the bottom of the page
  id: totrans-451
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 8.10. 在页面底部添加横幅
- en: '![](Images/08fig10_alt.jpg)'
  id: totrans-452
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/08fig10_alt.jpg)'
- en: Now you need to add a banner. If you want to check out the base code, switch
    to branch 8.3.3 (`git checkout chapter-8.3.3`), which has all the code added in
    this chapter so far and already has this banner component created for you (writing
    this component isn’t important to understanding this concept, but I’ve provided
    it for you in the following listing so you have some context).
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你需要添加一个横幅。如果你想查看基本代码，切换到分支 8.3.3 (`git checkout chapter-8.3.3`)，其中包含了本章迄今为止添加的所有代码，并且已经为你创建了这个横幅组件（编写这个组件对于理解这个概念并不重要，但我已经为你提供了它，以便你有一些上下文）。
- en: Listing 8.7\. Banner component—src/components/banner.jsx
  id: totrans-454
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.7. 横幅组件——src/components/banner.jsx
- en: '[PRE30]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '***1* Click handler placeholder for the dismiss button.**'
  id: totrans-456
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 添加 dismiss 按钮的点击处理占位符。**'
- en: '***2* Dismiss button lives here.**'
  id: totrans-457
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* dismiss 按钮位于此处。**'
- en: '***3* onClick handler references the handleDismissBanner function.**'
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* onClick 处理器引用 handleDismissBanner 函数。**'
- en: '***4* Parent component sets children for banner (making it more reusable).**'
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 父组件为横幅设置子组件（使其更具可重用性）。**'
- en: 'Additionally, the following code has been added after the header in src/components/app.jsx
    (~line 13):'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，以下代码已添加到 src/components/app.jsx 的标题之后（约第 13 行）：
- en: '[PRE31]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Now you need to add the code that decides whether to show this banner when the
    page loads. That involves checking a cookie and then telling the banner to be
    visible or stay hidden. The following listing shows how to update banner.jsx to
    make this work.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你需要添加决定页面加载时是否显示此横幅的代码。这涉及到检查一个 cookie，然后告诉横幅是可见的还是保持隐藏。以下列表显示了如何更新 banner.jsx
    以使其工作。
- en: Listing 8.8\. Showing the banner component—src/components/banner.jsx
  id: totrans-463
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.8. 显示横幅组件——src/components/banner.jsx
- en: '[PRE32]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '***1* Create initial state in constructor—to match the server, banner should
    be hidden by default.**'
  id: totrans-465
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 在构造函数中创建初始状态——为了与服务器匹配，横幅默认应隐藏。**'
- en: '***2* Get cookies, see if user has previously dismissed the banner—if not,
    set state to show banner (will trigger re-render).**'
  id: totrans-466
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 获取 cookies，查看用户是否之前关闭了横幅——如果没有，设置状态以显示横幅（将触发重新渲染）。**'
- en: '***3* When user dismisses the browser, write cookie to page and set state to
    hidden.**'
  id: totrans-467
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 当用户关闭浏览器时，将 cookie 写入页面并将状态设置为隐藏。**'
- en: '***4* Use state to generate banner classes.**'
  id: totrans-468
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 使用状态生成横幅类。**'
- en: Using state to generate banner classes will add a class called `show` when the
    banner is visible. The CSS for this class changes the display to block so the
    component becomes visible.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 使用状态生成横幅类将在横幅可见时添加一个名为 `show` 的类。这个类的 CSS 将显示属性更改为块，使组件变得可见。
- en: Generally, you don’t want to set state in `componentDidMount`. But in this case,
    the isomorphic render makes it the best place to update the state, because we
    want to ensure that the first render matches the server state. Be careful setting
    state in this function—you can easily get into a situation where you cause unnecessary
    re-renders of your component.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你不想在 `componentDidMount` 中设置状态。但在这个例子中，同构渲染使其成为更新状态的最好位置，因为我们想确保第一次渲染与服务器状态匹配。在这个函数中设置状态时要小心——你很容易导致组件不必要的重新渲染。
- en: 8.4\. Adding single-page app interactions
  id: totrans-471
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 8.4. 添加单页应用交互
- en: Congrats, you’ve made it! Your app loads and renders from the server and successfully
    renders in the browser. Sadly, it still doesn’t do anything in the browser because
    you haven’t told it to do anything. Let’s make the app load data in the browser
    when routing between routes.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜你，你已经做到了！你的应用从服务器加载并渲染，并在浏览器中成功渲染。遗憾的是，它仍然在浏览器中没有任何操作，因为你还没有告诉它要做什么。让我们让应用在路由之间切换时在浏览器中加载数据。
- en: '8.4.1\. Browser routing: data fetching'
  id: totrans-473
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 8.4.1. 浏览器路由：数据获取
- en: The routes you’ve set up will make the routes at the top of the page work. But
    if you navigate first to the root or to /products and then click Cart, you’ll
    find that the cart loads without any items. That’s because you haven’t set up
    the SPA portion of the app to fetch any data. [Figure 8.11](kindle_split_020_split_004.xhtml#ch08fig11)
    shows what this looks like.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 您设置的路线将使页面顶部的路线工作。但如果你首先导航到根目录或 /products，然后点击购物车，你会发现购物车加载时没有任何项目。这是因为您还没有设置应用程序的
    SPA 部分来获取任何数据。[图 8.11](kindle_split_020_split_004.xhtml#ch08fig11) 展示了这看起来是什么样子。
- en: Figure 8.11\. Loading the cart from the Products page results in an empty state.
  id: totrans-475
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 8.11\. 从产品页面加载购物车导致状态为空。
- en: '![](Images/08fig11_alt.jpg)'
  id: totrans-476
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/08fig11_alt.jpg)'
- en: To get the app fetching data in the browser, you’ll take advantage of the `prefetchActions`
    static function to fetch the data on each route. React Router provides callbacks
    for various portions of its own lifecycle. There’s an `onChange` callback that
    can be configured. The function provided will be called before each route is rendered,
    giving you the opportunity to fetch any data from your API that’s needed for the
    route.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 要使应用程序在浏览器中获取数据，您将利用 `prefetchActions` 静态函数在每个路由上获取数据。React Router 为其生命周期中的各个部分提供了回调。有一个
    `onChange` 回调可以配置。提供的函数将在每个路由渲染之前被调用，这为您提供了从 API 获取所需数据的路由的机会。
- en: '|  |'
  id: totrans-478
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-479
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: If you’re using React Router 4, check out [appendix A](kindle_split_027_split_000.xhtml#app01)
    for an overview of setting up the routes and related router code. It also shows
    how to prefetch the data on the browser and handle route changes in the React
    lifecycle instead of the React Router lifecycle.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用 React Router 4，请查看附录 A [kindle_split_027_split_000.xhtml#app01]，以了解设置路线和相关路由代码的概述。它还展示了如何在浏览器上预取数据以及如何在
    React 生命周期中而不是在 React Router 生命周期中处理路线更改。
- en: '|  |'
  id: totrans-481
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: If you want to check out the base code, switch to branch 8.4.1 (`git checkout
    chapter-8.4.1`). The following listing shows the code to add to sharedRoutes.jsx.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想查看基本代码，请切换到分支 8.4.1 (`git checkout chapter-8.4.1`)。以下列表显示了要添加到 sharedRoutes.jsx
    中的代码。
- en: Listing 8.9\. Fetching data in the browser—src/shared/sharedRoutes.jsx
  id: totrans-483
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.9\. 在浏览器中获取数据—src/shared/sharedRoutes.jsx
- en: '[PRE33]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '***1* Declare onChange handler, which takes in the dispatch function from Redux
    and parameters provided from React Router, prevState, and nextState.**'
  id: totrans-485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 声明 `onChange` 处理器，该处理器接受来自 Redux 的 `dispatch` 函数和来自 React Router 的参数，包括
    `prevState` 和 `nextState`。**'
- en: '***2* Pull routes array from nextState so you can iterate over the components
    and get the actions from prefetchActions**'
  id: totrans-486
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 从 `nextState` 中提取路线数组，以便您可以迭代组件并从 `prefetchActions` 获取操作。**'
- en: '***3* Create a routes function that returns the routes, letting you pass in
    the onChange handler.**'
  id: totrans-487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 创建一个返回路线的 `routes` 函数，让您传入 `onChange` 处理器。**'
- en: '***4* Assign onChange handler to top-level route—all changes between children
    routes will trigger this handler.**'
  id: totrans-488
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 将 `onChange` 处理器分配给顶级路由——所有子路由之间的更改都将触发此处理器。**'
- en: '***5* Default export of module is now a function, requires Redux store passed
    in.**'
  id: totrans-489
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 模块的默认导出现在是一个函数，需要传入 Redux 存储。**'
- en: '***6* Bind dispatch to onChange handler.**'
  id: totrans-490
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 将 `dispatch` 绑定到 `onChange` 处理器。**'
- en: '***7* Returns routes function with onChange handler passed in.**'
  id: totrans-491
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 返回带有传入 `onChange` 处理器的 `routes` 函数。**'
- en: Passing in the `onChange` handler is necessary because you need to bind `dispatch`
    to it in the browser. This function is exported so the server code can call it.
    A couple of things are important here. First, you need to add the `onChange` handler
    only to the top-level route. That’s because `onChange` fires whenever a subroute
    changes. When the user changes between cart or products, it’ll be fired. This
    also means it won’t fire on the initial render. That would be unnecessary because
    the data is already available from the server state.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中传递 `onChange` 处理器是必要的，因为您需要将其绑定到 `dispatch`。此函数被导出，以便服务器代码可以调用它。这里有几个重要的事项。首先，您只需要将
    `onChange` 处理器添加到顶级路由。这是因为 `onChange` 会在子路由更改时触发。当用户在购物车或产品之间切换时，它会被触发。这也意味着它不会在初始渲染时触发。这将是多余的，因为数据已经从服务器状态中可用。
- en: The most complicated piece of this logic is getting the `prefetchActions` array
    from the components. This is where the `routes` variable from `nextState` is important.
    The `routes` variable is an array of objects. Each route has a component listed
    on it. From this, it’s possible to collect all the actions that need to be called
    for the route. The following listing shows the last piece of code you need in
    order to make all this work. Add the code to sharedRoutes.jsx. You’ll notice it’s
    similar to the code in renderView.jsx.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 这段逻辑中最复杂的部分是从组件中获取 `prefetchActions` 数组。这是 `nextState` 中的 `routes` 变量很重要的地方。`routes`
    变量是一个对象数组。每个路由上都有一个组件列表。从这些中，可以收集需要为路由调用的所有动作。以下列表显示了您需要添加的最后一段代码，以便使所有这些工作。将代码添加到
    sharedRoutes.jsx 中。您会注意到它与 renderView.jsx 中的代码类似。
- en: Listing 8.10\. Call `prefetchActions` on route change—src/shared/sharedRoutes.jsx
  id: totrans-494
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.10\. 在路由更改时调用 `prefetchActions`—src/shared/sharedRoutes.jsx
- en: '[PRE34]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '***1* Use map to iterate over each route in the array (root app route and whatever
    route was requested).**'
  id: totrans-496
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 使用 map 遍历数组中的每个路由（根应用路由和请求的路由）。**'
- en: '***2* Grab the component from route.**'
  id: totrans-497
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 从路由中获取组件。**'
- en: '***3* Check if component is HOC connect component—if so, grab subproperty of
    component.**'
  id: totrans-498
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 检查组件是否为 HOC connect 组件——如果是，则获取组件的子属性。**'
- en: '***4* If component has WrappedComponent property, call prefetchActions.**'
  id: totrans-499
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 如果组件有 WrappedComponent 属性，则调用 prefetchActions。**'
- en: '***5* Take results of map, which can be a nested array of arrays, and reduce
    them to single array.**'
  id: totrans-500
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 将映射的结果，可能是一个嵌套数组，缩减为单个数组。**'
- en: '***6* Use map to iterate over the final flattened array; on each item call
    dispatch with the action.**'
  id: totrans-501
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 使用 map 遍历最终的扁平化数组；对每个项目调用 dispatch 以执行操作。**'
- en: You may notice that the structure of `sharedRoutes` has changed quite a bit.
    That’s because you need access to the `dispatch` method from Redux to trigger
    actions. In both main.jsx and renderView.jsx, you need to update the way you’re
    accessing the shared routes. The following listing shows the change that needs
    to be made in main.jsx.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会注意到 `sharedRoutes` 的结构改变了很多。这是因为您需要访问 Redux 的 `dispatch` 方法来触发动作。在 `main.jsx`
    和 `renderView.jsx` 中，您需要更新访问共享路由的方式。以下列表显示了 `main.jsx` 中需要做出的更改。
- en: Listing 8.11\. Updating Main to call sharedRoutes—src/main.jsx
  id: totrans-503
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.11\. 更新 Main 以调用 sharedRoutes—src/main.jsx
- en: '[PRE35]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Instead of directly plugging in the routes, the default export is now a function.
    Here you call the function, passing in the store so that `sharedRoutes` can pass
    `dispatch` into the `onChange` handler.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是直接插入路由，默认导出现在是一个函数。在这里，您调用该函数，传入存储，以便 `sharedRoutes` 可以将 `dispatch` 传递到 `onChange`
    处理器。
- en: The change to the `renderView` middleware is similar to the change in main.jsx.
    But you have to first change the import because on the server you don’t need to
    do the `onChange` logic—it’ll never fire. The following listing demonstrates what
    needs to change.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: '`renderView` 中间件的更改与 `main.jsx` 中的更改类似。但您必须首先更改导入，因为在服务器上您不需要执行 `onChange`
    逻辑——它永远不会触发。以下列表展示了需要更改的内容。'
- en: Listing 8.12\. Updating `renderView` to use routes—src/middleware/renderView.jsx
  id: totrans-507
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 8.12\. 更新 `renderView` 以使用路由—src/middleware/renderView.jsx
- en: '[PRE36]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '***1* Include routes instead of the default export—the server doesn’t need
    to initialize the onChange handler because it’ll never be called on the server.**'
  id: totrans-509
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 包含路由而不是默认导出——服务器不需要初始化 onChange 处理器，因为它在服务器上永远不会被调用。**'
- en: '***2* Call the routes function to get the shared routes.**'
  id: totrans-510
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 调用路由函数以获取共享路由。**'
- en: With everything configured to load data on the server, you should see the cart
    populated. Additionally, if you view the Network tab, you’ll see the cart data
    being fetched from the server. This will be shown only if you load the app via
    /products first and then select Cart from the navigation. [Figure 8.12](kindle_split_020_split_004.xhtml#ch08fig12)
    shows what you’re looking for.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 在一切配置为在服务器上加载数据后，您应该看到购物车已填充。此外，如果您查看网络标签页，您将看到从服务器获取的购物车数据。这只有在您首先通过 /products
    加载应用程序，然后从导航中选择购物车时才会显示。[图 8.12](kindle_split_020_split_004.xhtml#ch08fig12) 展示了您要查找的内容。
- en: Figure 8.12\. Now that the browser fetches data, you see the XHR call in the
    Network tab of the Chrome Developer Tools.
  id: totrans-512
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 8.12\. 现在浏览器获取数据后，您可以在 Chrome 开发者工具的网络标签页中看到 XHR 调用。
- en: '![](Images/08fig12_alt.jpg)'
  id: totrans-513
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/08fig12_alt.jpg)'
- en: Now that you’ve built out the browser portion of the code, you can review the
    complete code for this chapter on branch chapter-8-complete (`git checkout chapter-8-complete`).
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经构建了代码的浏览器部分，您可以查看该章节的完整代码，分支为 chapter-8-complete (`git checkout chapter-8-complete`)。
- en: Summary
  id: totrans-515
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to build the browser portion of an isomorphic
    app. You added a browser entry-point file called main.jsx and handled the initialization
    logic required to make the app start in the browser in the same state that it
    was rendered on the server.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您学习了如何构建同构应用的浏览器部分。您添加了一个名为 main.jsx 的浏览器入口点文件，并处理了使应用在浏览器中以与服务器上渲染相同的状态启动所需的初始化逻辑。
- en: The initial server state is added to the DOM as a string and sent down as part
    of the server-rendered page.
  id: totrans-517
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始服务器状态以字符串形式添加到 DOM 中，并作为服务器渲染页面的一部分发送下来。
- en: The browser entry point handles deserializing the server-created state, initializing
    Redux, and rendering the React component tree into the DOM.
  id: totrans-518
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浏览器入口点处理反序列化服务器创建的状态，初始化 Redux，并将 React 组件树渲染到 DOM 中。
- en: The server attaches the state of the app to the DOM as a string.
  id: totrans-519
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器将应用的状态附加到 DOM 上作为字符串。
- en: The browser reads the string into an object that can be passed into Redux.
  id: totrans-520
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浏览器将字符串读入一个对象，该对象可以传递给 Redux。
- en: Redux can be initialized with a base state, which is the deserialized state
    from the server.
  id: totrans-521
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Redux 可以使用从服务器反序列化的基本状态进行初始化。
- en: React’s component lifecycle can make or break an isomorphic render. It’s important
    to make updates to the app state at the correct point in the lifecycle.
  id: totrans-522
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React 的组件生命周期可以决定同构渲染的成功与否。在生命周期中的正确点更新应用状态非常重要。
- en: The browser code also needs to handle data fetching for the single-page application
    portion of the app.
  id: totrans-523
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 浏览器代码还需要处理应用的单页应用部分的数据获取。
- en: Chapter 9\. Testing and debugging
  id: totrans-524
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 9 章：测试和调试
- en: '*This chapter covers*'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Creating a test environment that reflects the complexities of an isomorphic
    app
  id: totrans-526
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个反映同构应用复杂性的测试环境
- en: Using Enzyme to create unit tests for your React components
  id: totrans-527
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Enzyme 为您的 React 组件创建单元测试
- en: Using React Developer Tools to debug in the browser
  id: totrans-528
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 React 开发者工具在浏览器中进行调试
- en: Using Redux Dev Tools to debug in the browser
  id: totrans-529
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Redux 开发者工具在浏览器中进行调试
- en: 'Have you ever worked in a code base that has lots of tests, but the tests break
    randomly, require constant updating, and never prevent you from creating regression
    errors? This situation is surprisingly easy to create when you have more than
    two developers working on a code base. Having a solid testing strategy and understanding
    where to draw the line between unit tests and integration tests is important for
    any app. But isomorphic apps have an additional level of complexity that needs
    to be thought through: is this a test for code that runs on the server, in the
    browser, or in both environments?'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 您是否曾在拥有大量测试的代码库中工作过，但测试会随机崩溃，需要不断更新，并且从未阻止您创建回归错误？当您有超过两个开发者在一个代码库上工作时，这种情况出人意料地容易发生。拥有一个稳固的测试策略，并理解单元测试和集成测试之间的界限在哪里，对于任何应用都很重要。但是，同构应用有一个额外的复杂层次需要考虑：这是针对在服务器上运行、在浏览器上运行还是在两个环境中都运行的代码的测试吗？
- en: The first part of this chapter explores how to think about testing an isomorphic
    app. You’ll learn to test React with Enzyme and how to test your components in
    multiple environments. The second part of the chapter covers debugging tools that
    can help with real-world development.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的第一部分探讨了如何思考测试同构应用。您将学习如何使用 Enzyme 测试 React，以及如何在多个环境中测试您的组件。本章的第二部分涵盖了有助于实际开发的调试工具。
- en: 'The code for this chapter can be found in the complete-isomorphic-example repo
    on GitHub:'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在 GitHub 上的 complete-isomorphic-example 仓库中找到：
- en: '[PRE37]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Each section has base code provided in a branch. The first branch you’ll use
    is chapter-9.1.1:'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 每个部分都提供了一个分支中的基本代码。您将使用的第一个分支是 chapter-9.1.1：
- en: '[PRE38]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '9.1\. Testing: React components'
  id: totrans-536
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1\. 测试：React 组件
- en: 'The goal of the first half of this chapter is to walk you through how to approach
    testing when you have code that can run in multiple environments. Doing that requires
    the following:'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 本章前半部分的目标是指导您了解在代码可以在多个环境中运行时如何进行测试。要做到这一点，需要以下条件：
- en: Having the right tools to run tests in both the server and browser environments
  id: totrans-538
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拥有在服务器和浏览器环境中运行测试的正确工具
- en: Knowing when code should be tested in a specific environment (for example, you
    don’t need to test Express middleware in the browser)
  id: totrans-539
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 知道何时在特定环境中测试代码（例如，您不需要在浏览器中测试 Express 中间件）
- en: There are many categories of tests, including unit tests, integration tests,
    contract tests, end-to-end tests, and so on. Whenever possible, you want to match
    your real-word development builds with the way you build your test. You also want
    to run unit tests for your code in a way that allows for browser and server verification.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 测试有很多类别，包括单元测试、集成测试、契约测试、端到端测试等等。尽可能的情况下，你希望你的实际开发构建与你的测试构建方式相匹配。你还希望以允许浏览器和服务器验证的方式运行你的代码的单元测试。
- en: I’ve already set up much of the unit-testing environment for you. We’ll be using
    Mocha as the test library and Karma as our test runner (so that debugging the
    browser tests is straightforward). If you’re new to unit testing or need a refresher,
    I highly recommend *The Art of Unit Testing* by Roy Osherove (Manning, 2013).
    This book was my introduction to unit testing and is an invaluable resource. To
    see documentation on Karma, visit [https://karma-runner.github.io/1.0/index.html](https://karma-runner.github.io/1.0/index.html).
    You can learn more about Mocha at [https://mochajs.org](https://mochajs.org).
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经为你设置了许多单元测试环境。我们将使用 Mocha 作为测试库，Karma 作为我们的测试运行器（这样调试浏览器测试就简单了）。如果你是单元测试的新手或者需要复习，我强烈推荐
    Roy Osherove 的《单元测试的艺术》（Manning，2013）。这本书是我的单元测试入门，是一个无价资源。要查看 Karma 的文档，请访问 [https://karma-runner.github.io/1.0/index.html](https://karma-runner.github.io/1.0/index.html)。你可以在
    [https://mochajs.org](https://mochajs.org) 上了解更多关于 Mocha 的信息。
- en: If you’d like to see how I set up the unit-testing configuration for this chapter,
    you’ll find the config file in karma.conf.js (located in the root directory) and
    the script in package.json under test:browser. The tests are set up with Karma
    (test-runner), Mocha (test library), and Chai (assertion library). The Karma test
    configuration uses webpack with the same config you use for development to bundle
    the tests. The code under test is compiled the same way that the app code is compiled.
    By the end of this section, you’ll have test output in the terminal that looks
    something like [figure 9.1](kindle_split_021_split_001.xhtml#ch09fig01).
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要看看我是如何为这一章设置单元测试配置的，你可以在根目录下的 karma.conf.js 文件中找到配置文件，以及在 package.json
    下的 test:browser 下的脚本。测试是用 Karma（测试运行器）、Mocha（测试库）和 Chai（断言库）设置的。Karma 测试配置使用与开发相同的配置的
    webpack 打包测试。被测试的代码是以与应用程序代码相同的方式编译的。在本节结束时，你将在终端中看到类似 [figure 9.1](kindle_split_021_split_001.xhtml#ch09fig01)
    的测试输出。
- en: Figure 9.1\. The browser test output when all the tests are passing
  id: totrans-543
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 9.1\. 所有测试通过时的浏览器测试输出
- en: '![](Images/09fig01_alt.jpg)'
  id: totrans-544
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/09fig01_alt.jpg)'
- en: 'To run the tests for this section, run the following:'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行本节的测试，请运行以下命令：
- en: '[PRE39]'
  id: totrans-546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: For now, there are no tests, so you’ll see “Executed 0 out of 0” in the terminal.
    Notice that a new instance of Google Chrome is also opened, as shown in [figure
    9.2](kindle_split_021_split_001.xhtml#ch09fig02).
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 目前还没有测试，所以你会在终端中看到“已执行 0 个，共 0 个”。注意，还会打开一个新的 Google Chrome 实例，如图 9.2 所示 [figure
    9.2](kindle_split_021_split_001.xhtml#ch09fig02)。
- en: Figure 9.2\. Karma launches Google Chrome for you so that your test runs in
    a real browser environment.
  id: totrans-548
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 9.2\. Karma 会为你启动 Google Chrome，以便你的测试在真实浏览器环境中运行。
- en: '![](Images/09fig02_alt.jpg)'
  id: totrans-549
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/09fig02_alt.jpg)'
- en: Try clicking the Debug button. It opens a new tab. You can use this tab to open
    the Chrome DevTools and debug your tests as you’d debug your application when
    you get stuck.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试点击调试按钮。它会打开一个新标签页。你可以使用这个标签页打开 Chrome DevTools 并调试你的测试，就像你在遇到问题时调试应用程序一样。
- en: Now let’s learn how to use Enzyme to write your first React test.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来学习如何使用 Enzyme 编写你的第一个 React 测试。
- en: '|  |'
  id: totrans-552
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Testing alternatives: Jest**'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试替代方案：Jest**'
- en: Another good testing library is Jest. Documentation can be found at [https://facebook.github.io/jest/docs/en/getting-started.html](https://facebook.github.io/jest/docs/en/getting-started.html).
    Jest is a testing framework built by Facebook that provides everything you need
    with zero configuration. In the world of testing, that’s a nice change!
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个很好的测试库是 Jest。文档可以在 [https://facebook.github.io/jest/docs/en/getting-started.html](https://facebook.github.io/jest/docs/en/getting-started.html)
    找到。Jest 是由 Facebook 开发的一个测试框架，它提供了零配置所需的一切。在测试的世界里，这是一个很好的变化！
- en: By default, Jest ships with Jasmine and its own mocking utilities. It’s also
    fast out of the box, which saves you time locally and when running tests on a
    continuous integration server.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Jest 随附 Jasmine 和它自己的模拟工具。它也开箱即用就很快，这可以在本地运行测试以及在持续集成服务器上运行测试时节省你的时间。
- en: 'You’ll have trade-offs when using Jest with a webpack-configured project. You’ll
    probably have to do some extra setup (so, not exactly zero configuration). The
    docs provide a helpful guide: [https://facebook.github.io/jest/docs/en/webpack.html#content](https://facebook.github.io/jest/docs/en/webpack.html#content).'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在 webpack 配置的项目中使用 Jest 时，你将面临权衡。你可能需要进行一些额外的设置（所以，并不是零配置）。文档提供了一个有用的指南：[https://facebook.github.io/jest/docs/en/webpack.html#content](https://facebook.github.io/jest/docs/en/webpack.html#content)。
- en: Additionally, you’re no longer running your tests in the context of a browser.
    Karma even lets you run your tests in multiple browsers. But you may not find
    this important for your project, and Karma is much slower than Jest. If you value
    the speed and easy configuration more, I recommend trying Jest.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你不再在浏览器上下文中运行你的测试。Karma 甚至允许你在多个浏览器中运行你的测试。但你可能觉得这对你的项目并不重要，而且 Karma 比 Jest
    慢得多。如果你更重视速度和易于配置，我建议尝试 Jest。
- en: '|  |'
  id: totrans-558
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 9.1.1\. Using Enzyme to test components
  id: totrans-559
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.1.1\. 使用 Enzyme 测试组件
- en: A library called Enzyme has become popular for testing React components ([https://github.com/airbnb/enzyme](https://github.com/airbnb/enzyme)).
    It provides an API that makes writing test assertions against your view components
    straightforward.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 一个名为 Enzyme 的库已经成为测试 React 组件的流行选择（[https://github.com/airbnb/enzyme](https://github.com/airbnb/enzyme)）。它提供了一个
    API，使得针对你的视图组件编写测试断言变得简单。
- en: The simplest form of unit test you can write with Enzyme renders a shallow version
    of the component you’re testing. Any child components won’t be rendered. That’s
    important because it allows you to test a single component without reaching down
    into child components. This makes your tests true unit tests, which results in
    less-brittle, cleaner tests.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 Enzyme 编写的最简单的单元测试形式是渲染你正在测试的组件的浅版本。任何子组件都不会被渲染。这很重要，因为它允许你测试单个组件而不需要深入到子组件中。这使得你的测试成为真正的单元测试，从而产生更不脆弱、更干净的测试。
- en: The first test you’ll add is for the App component. App has multiple children,
    including the Link component from React Router, which we aren’t interested in
    testing. The following listing shows how to use shallow rendering to do basic
    assertions on a component. Add the code from the listing to a new test file test/components/app.spec.jsx.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 你将要添加的第一个测试是针对 App 组件的。App 有多个子组件，包括来自 React Router 的 Link 组件，而我们并不想测试这个组件。下面的列表显示了如何使用浅渲染对组件进行基本断言。将列表中的代码添加到一个新的测试文件
    test/components/app.spec.jsx 中。
- en: Listing 9.1\. Rendering with `shallow`—test/components/app.spec.jsx
  id: totrans-563
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.1\. 使用 `shallow` 渲染 —— test/components/app.spec.jsx
- en: '[PRE40]'
  id: totrans-564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '***1* Include React—you’ll use JSX to shallow load the App component.**'
  id: totrans-565
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 包含 React —— 你将使用 JSX 来浅加载 App 组件。**'
- en: '***2* Include expect from Chai to write assertions—you can subsitute a preferred
    assertion style.**'
  id: totrans-566
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 包含来自 Chai 的 expect 来编写断言 —— 你可以替换你喜欢的断言风格。**'
- en: '***3* Include shallow function from Enzyme, which loads the component without
    loading its child components (loads only one level of the React tree).**'
  id: totrans-567
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 包含来自 Enzyme 的 shallow 函数，它加载组件而不加载其子组件（只加载 React 树的一级）。**'
- en: '***4* Enzyme supports using React component references to check for existence
    within a component—here you’re checking for the presence of a Link component.**'
  id: totrans-568
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* Enzyme 支持使用 React 组件引用来检查组件内的存在性——这里你正在检查 Link 组件的存在。**'
- en: '***5* App component is loaded via the shallow function, returns wrapped component
    that gives you methods you can use to interact with and assert against the component
    under test.**'
  id: totrans-569
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* App 组件通过 shallow 函数加载，返回一个包装组件，它提供了你可以用来与测试中的组件交互和断言的方法。**'
- en: '***6* Take advantage of Mocha’s beforeEach and afterEach, which execute once
    before and after each test.**'
  id: totrans-570
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 利用 Mocha 的 beforeEach 和 afterEach，它们在每个测试前后各执行一次。**'
- en: '***7* Demonstrates another type of selector you can use with Enzyme, here asserting
    that an element with attribute “to” exists, with each assertion looking for a
    specific route.**'
  id: totrans-571
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 展示了你可以与 Enzyme 一起使用的另一种类型的选择器，这里断言具有属性“to”的元素存在，每个断言都在寻找特定的路由。**'
- en: Enzyme selectors
  id: totrans-572
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Enzyme 选择器
- en: 'The two tests you just added show two of the three possible ways you can apply
    Enzyme selectors to find elements within the rendered tree:'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚添加的两个测试展示了你可以将 Enzyme 选择器应用于渲染树中查找元素的三种可能方法中的两种：
- en: Component selectors (takes a React component reference)
  id: totrans-574
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件选择器（接受一个 React 组件引用）
- en: Attribute selectors (takes an object)
  id: totrans-575
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性选择器（接受一个对象）
- en: 'There’s a third selector type: CSS selectors. They work like JQuery selectors:
    to find an element by ID, you look for `#id`. To find a component by class, you
    look for `.class` or `.multiple.class`.'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 还有第三种选择器类型：CSS选择器。它们的工作方式类似于JQuery选择器：要按ID查找元素，你查找`#id`。要按类查找组件，你查找`.class`或`.multiple.class`。
- en: Let’s look at one more example that uses the class selector to find the element
    that contains the unit under test. In this example, you’re adding tests for the
    Item component—a presentation component whose only job is to display properties
    passed in. In [listing 9.2](kindle_split_021_split_001.xhtml#ch09ex02), you can
    see how to use Enzyme to assert that the expected parts of the Item component
    are rendered correctly. Notice that you’re adding only tests that assert on the
    parts of the markup that are changed by the properties that are passed in. This
    reduces the brittleness of your tests. Asserting directly on the markup means
    your unit tests are subject to change because a class changed. Add the code in
    the listing to a new file called test/components/item.spec.jsx.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看另一个使用类选择器查找包含被测试单元的元素的例子。在这个例子中，你正在为Item组件添加测试——这是一个展示组件，它的唯一任务是显示传入的属性。在[列表9.2](kindle_split_021_split_001.xhtml#ch09ex02)中，你可以看到如何使用Enzyme断言Item组件的预期部分渲染正确。请注意，你只添加了断言那些由传入的属性更改的标记部分的测试。这减少了测试的脆弱性。直接在标记上断言意味着你的单元测试可能会因为类更改而改变。将列表中的代码添加到名为`test/components/item.spec.jsx`的新文件中。
- en: Listing 9.2\. Testing a presentation component—test/components/item.spec.jsx
  id: totrans-578
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.2\. 测试一个展示组件—test/components/item.spec.jsx
- en: '[PRE41]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '***1* For this test, provide a mocked props object.**'
  id: totrans-580
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 对于这个测试，提供一个模拟的props对象。**'
- en: '***2* Test asserts that the thumbnail gets assigned to the src property.**'
  id: totrans-581
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 测试断言缩略图被分配给了src属性。**'
- en: '***3* Test asserts the name gets put in the correct element; text() returns
    inner contents of a HTML tag.**'
  id: totrans-582
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 测试断言名称被放入正确的元素中；text()返回HTML标签的内部内容。**'
- en: '***4* Test asserts the price gets placed in the component correctly.**'
  id: totrans-583
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 测试断言价格被正确地放置在组件中。**'
- en: The double dollar sign looks weird because of the string interpolation. The
    first $ is the literal one displayed in the view. The other is for the variable
    in the string.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 双美元符号看起来很奇怪，这是因为字符串插值。第一个美元符号是显示在视图中的字面量美元符号。另一个是字符串中的变量。
- en: Keep in mind that you want to use selectors for your tests that are unlikely
    to change frequently. You can’t always predict that, but putting some thought
    into it ahead of time can reduce test refactoring.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，你想要使用的选择器不太可能频繁更改。你并不总能预测这一点，但提前思考一下可以减少测试重构。
- en: Now that you understand the basics of using Enzyme to unit test your React components,
    let’s look at how to write a test that validates user interaction with a component.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了使用Enzyme对React组件进行单元测试的基本知识，让我们看看如何编写一个测试来验证用户与组件的交互。
- en: 9.1.2\. Testing user actions
  id: totrans-587
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.1.2\. 测试用户操作
- en: 'Testing with shallow rendering also lets you test user interactions. In this
    section, you’ll add a test to the Cart component to see whether a button click
    properly triggers a route update. Note that to do this test, I’ve added a route
    for /cart/payment to `sharedRoutes` and updated the Checkout button in `cart`
    to navigate to this route:'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 使用浅渲染进行测试也允许你测试用户交互。在本节中，你将向购物车组件添加一个测试，以查看按钮点击是否正确触发了路由更新。请注意，要进行此测试，我已在`sharedRoutes`中添加了一个路由`/cart/payment`，并将`cart`中的结账按钮更新为导航到该路由：
- en: '[PRE42]'
  id: totrans-589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: You can see this added code if you switch to the chapter-9.1.2 branch (`git
    checkout chapter-9.1.2`). If you’re following along, you need to update `proceedToCheckout`
    for the test in [listing 9.4](kindle_split_021_split_001.xhtml#ch09ex04) to pass.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你切换到`chapter-9.1.2`分支（`git checkout chapter-9.1.2`），你可以看到这段添加的代码。如果你在跟进，你需要更新[列表9.4](kindle_split_021_split_001.xhtml#ch09ex04)中的`proceedToCheckout`以通过测试。
- en: You also need to make another update to the Cart component. Currently, the component
    is wrapped with Connect and then exported, making it extremely difficult to test.
    It also means you’re testing a composed component instead of the Cart component
    in isolation. The following listing shows you how to update the Cart component
    to export the nonwrapped version for testing.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要对购物车组件进行另一个更新。目前，该组件被Connect包装然后导出，这使得测试变得极其困难。这也意味着你正在测试一个组合组件而不是独立的购物车组件。以下列表显示了如何更新购物车组件以导出非包装版本进行测试。
- en: Listing 9.3\. Add a second export to the Cart component—src/components/cart.jsx
  id: totrans-592
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.3\. 向购物车组件添加第二个导出—src/components/cart.jsx
- en: '[PRE43]'
  id: totrans-593
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '***1* Add an export to the class definition and update the component name (allows
    for future named exports).**'
  id: totrans-594
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 在类定义中添加一个导出并更新组件名称（允许未来使用命名导出）。**'
- en: '***2* Update all references to Cart.**'
  id: totrans-595
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 更新所有对 Cart 的引用。**'
- en: '***3* Update all references to Cart—note you still export a connect wrapped
    component.**'
  id: totrans-596
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 更新所有对 Cart 的引用—注意你仍然导出了一个 connect 包装的组件。**'
- en: '[Listing 9.4](kindle_split_021_split_001.xhtml#ch09ex04) shows how to test
    that the Cart component properly calls the History component to navigate to the
    checkout section. The test imports the named export `CartComponent` instead of
    the default wrapped component. Add this code to a new file called test/components/cart.spec.jsx.'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 9.4](kindle_split_021_split_001.xhtml#ch09ex04) 展示了如何测试 Cart 组件正确调用 History
    组件以导航到结账部分。测试导入命名导出 `CartComponent` 而不是默认包装组件。将此代码添加到名为 test/components/cart.spec.jsx
    的新文件中。'
- en: Listing 9.4\. Testing user interactions—test/components/cart.spec.jsx
  id: totrans-598
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.4\. 测试用户交互—test/components/cart.spec.jsx
- en: '[PRE44]'
  id: totrans-599
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '***1* To run the test, you need an additional dependency; with Sinon you create
    mock functions that track whether they were called during a test.**'
  id: totrans-600
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 要运行测试，你需要一个额外的依赖项；使用 Sinon 你可以创建在测试期间被调用的模拟函数。**'
- en: '***2* Use sinon.spy() to mock out the router.push() function called in the
    proceedToCheckout() function in cart.jsx.**'
  id: totrans-601
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 使用 sinon.spy() 模拟 cart.jsx 中 proceedToCheckout() 函数中调用的 router.push()
    函数。**'
- en: '***3* Use the simulate() method to generate a click on the Checkout button.**'
  id: totrans-602
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 使用 simulate() 方法生成对 Checkout 按钮的点击。**'
- en: '***4* Use the called property of the sinon spy to assert that the router.push()
    method was called by your component.**'
  id: totrans-603
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 使用 sinon spy 的 called 属性来断言你的组件调用了 router.push() 方法。**'
- en: '***5* Use the calledWith property of sinon spy to assert the proper route was
    passed in.**'
  id: totrans-604
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 使用 sinon spy 的 calledWith 属性来断言传递了正确的路由。**'
- en: The listing uses Sinon to create function mocks. To learn more about Sinon,
    visit their docs at [http://sinonjs.org](http://sinonjs.org). The listing also
    uses Enzyme to test the event. One thing to note about `simulate` is that it doesn’t
    propagate the mock events—you must find the element on which you have the event
    listener to trigger the listener. That applies to all components loaded via Enzyme,
    even ones that use `mount`. In the next section, you’ll learn about writing integration
    tests with `mount`.
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 列表使用 Sinon 创建函数模拟。要了解更多关于 Sinon 的信息，请访问他们的文档[http://sinonjs.org](http://sinonjs.org)。列表还使用
    Enzyme 来测试事件。关于 `simulate` 有一点需要注意，它不会传播模拟事件——你必须找到具有事件监听器的元素来触发监听器。这适用于所有通过 Enzyme
    加载的组件，即使是使用 `mount` 的组件。在下文中，你将学习如何使用 `mount` 编写集成测试。
- en: 9.1.3\. Testing nested components
  id: totrans-606
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.1.3\. 测试嵌套组件
- en: Enzyme provides a second way to test your components, called `mount`. This fully
    renders your component along with all its children. It’s most useful for integration
    tests, where you’re testing bigger portions of an application. I don’t recommend
    using it for unit tests, as `mount` makes your tests more brittle. A change in
    a subcomponent will break the tests for any parent components that are using `mount`
    to test.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: Enzyme 提供了测试组件的第二种方法，称为 `mount`。这会完全渲染你的组件及其所有子组件。它对于集成测试非常有用，因为你正在测试应用程序的更大部分。我不建议将其用于单元测试，因为
    `mount` 使得测试更加脆弱。子组件的更改将破坏使用 `mount` 进行测试的任何父组件的测试。
- en: '[Listing 9.5](kindle_split_021_split_001.xhtml#ch09ex05) shows how to add an
    integration test that loads the entire React tree, including React Router. This
    allows you to assert on the complete React tree, including all child components.
    The code up to this point is in chapter-9.1.3 (`git checkout chapter-9.1.3`).
    Add the code in the listing to the app specification. Note that this is a different
    app.spec.jsx that lives in the integration folder.'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 9.5](kindle_split_021_split_001.xhtml#ch09ex05) 展示了如何添加一个集成测试，该测试加载整个 React
    树，包括 React Router。这允许你断言完整的 React 树，包括所有子组件。到目前为止的代码位于 chapter-9.1.3（`git checkout
    chapter-9.1.3`）。将列表中的代码添加到应用程序规范中。请注意，这是一个位于集成文件夹中的不同的 app.spec.jsx。'
- en: '|  |'
  id: totrans-609
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-610
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: If you’re using React Router 4, check out [appendix A](kindle_split_027_split_000.xhtml#app01)
    for an overview of setting up the routes and related router code. The following
    listing shows the main.jsx code that also applies to test setup.
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用 React Router 4，请查看附录 A（kindle_split_027_split_000.xhtml#app01）以了解设置路由和相关路由代码的概述。以下列表显示了
    main.jsx 代码，这也适用于测试设置。
- en: '|  |'
  id: totrans-612
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Listing 9.5\. Rendering with `mount`—test/integration/app.spec.jsx
  id: totrans-613
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.5\. 使用 `mount` 渲染—test/integration/app.spec.jsx
- en: '[PRE45]'
  id: totrans-614
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '***1* Include dependencies to render React Router.**'
  id: totrans-615
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 包含依赖以渲染 React Router。**'
- en: '***2* Instead of browser history use createMemoryHistory, it lets you declare
    an initial route for router (without having to navigate in the browser).**'
  id: totrans-616
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 而不是使用浏览器历史记录，使用createMemoryHistory，它允许你为路由器声明一个初始路由（无需在浏览器中进行导航）。**'
- en: '***3* Assert that search is loaded, which lives only on the product page.**'
  id: totrans-617
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 断言搜索已加载，它仅存在于产品页面上。**'
- en: The test in the previous example is trivial. In a real integration test, you’d
    want to test something more complex, such as searching in the search box. Before
    moving on, here are some additional methods you can use to write more-complex
    test cases.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 之前示例中的测试很简单。在真正的集成测试中，你想要测试更复杂的事情，比如在搜索框中进行搜索。在继续之前，这里有一些你可以用来编写更复杂测试用例的额外方法。
- en: Advanced enzyme API methods
  id: totrans-619
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 高级酶API方法
- en: 'Enzyme has many additional methods that can be called on your shallow or mounted
    React components. Here’s a list of some of the most useful ones:'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: Enzyme有许多可以在你的浅层或挂载的React组件上调用的额外方法。以下是一些最有用的方法列表：
- en: '**`setProps`—** Use this method to pass in updated properties to a loaded component.
    Useful for testing logic that happens in React lifecycle methods.'
  id: totrans-621
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`setProps`—** 使用此方法向已加载组件传递更新的属性。对于测试在React生命周期方法中发生的逻辑很有用。'
- en: '**`setState`—** Use this method to change the state of a loaded component.
    It lets you test complex cases, such as the search input in products.jsx.'
  id: totrans-622
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`setState`—** 使用此方法来更改已加载组件的状态。它允许你测试复杂的情况，例如products.jsx中的搜索输入。'
- en: '**`debug`—** Useful for seeing the rendered HTML of the component at any point
    in time. Useful for debugging.'
  id: totrans-623
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`debug`—** 在任何时间点查看组件渲染的HTML非常有用。这对于调试很有帮助。'
- en: '**`unmount`—** Test any code that happens in your `componentWillUnmount`.'
  id: totrans-624
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`unmount`—** 测试在`componentWillUnmount`中发生的任何代码。'
- en: '9.2\. Testing: thinking isomorphically'
  id: totrans-625
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2\. 测试：同构思考
- en: With an isomorphic app, it isn’t enough to write unit tests that run in the
    browser. The goal of your tests should be to run your code in all the environments
    it’ll be run in.
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 使用同构应用程序，仅编写在浏览器中运行的单元测试是不够的。你的测试目标应该是运行你的代码将在其中运行的所有环境中。
- en: Any code in your app that runs on the server should be tested with Mocha in
    the terminal. Any code that runs in the browser should be tested in a browser
    environment with Karma. But code that runs *only* in the server or *only* in the
    browser doesn’t need to be tested in the opposite environment. [Table 9.1](kindle_split_021_split_002.xhtml#ch09table01)
    illustrates this with the types of code that run in the All Things Westies app.
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的应用程序中运行在服务器上的任何代码都应该在终端中使用Mocha进行测试。在浏览器中运行的任何代码都应该在Karma浏览器环境中进行测试。但是，仅在服务器或仅在浏览器中运行的代码不需要在相反的环境中测试。[表9.1](kindle_split_021_split_002.xhtml#ch09table01)
    使用在All Things Westies应用程序中运行的代码类型说明了这一点。
- en: Table 9.1\. In an isomorphic app, it’s important to test code in all environments
  id: totrans-628
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表9.1\. 在同构应用程序中，测试所有环境中的代码很重要
- en: '|   | Server tests | Browser tests |'
  id: totrans-629
  prefs: []
  type: TYPE_TB
  zh: '|   | 服务器测试 | 浏览器测试 |'
- en: '| --- | --- | --- |'
  id: totrans-630
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Components | Yes | Yes |'
  id: totrans-631
  prefs: []
  type: TYPE_TB
  zh: '| 组件 | 是 | 是 |'
- en: '| Shared folder code | Yes | Yes |'
  id: totrans-632
  prefs: []
  type: TYPE_TB
  zh: '| 共享文件夹代码 | 是 | 是 |'
- en: '| Middleware | Yes | No |'
  id: totrans-633
  prefs: []
  type: TYPE_TB
  zh: '| 中间件 | 是 | 否 |'
- en: '| Server entry code | Yes | No |'
  id: totrans-634
  prefs: []
  type: TYPE_TB
  zh: '| 服务器入口代码 | 是 | 否 |'
- en: '| Browser entry code | No | Yes |'
  id: totrans-635
  prefs: []
  type: TYPE_TB
  zh: '| 浏览器入口代码 | 否 | 是 |'
- en: 9.2.1\. Testing React components on the server
  id: totrans-636
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.2.1\. 在服务器上测试React组件
- en: The great thing about Enzyme is that the `shallow` function doesn’t require
    a real DOM. You can run these tests with Karma and with Mocha in the terminal.
    But if you want to more accurately test your components in the way they’ll be
    used on the server, you can add an additional server-only test. (You can switch
    to the chapter-9.2.1 branch if you want to start this section with all the code
    so far.)
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: Enzyme的伟大之处在于`shallow`函数不需要真实的DOM。你可以使用Karma和终端中的Mocha运行这些测试。但是，如果你想更准确地测试你的组件，就像它们在服务器上使用的那样，你可以添加一个额外的仅服务器测试。（如果你想从这个部分开始，你可以切换到chapter-9.2.1分支。）
- en: '[Figure 9.3](kindle_split_021_split_002.xhtml#ch09fig03) shows the output of
    the server tests. The server tests are already running several of the tests you
    wrote previously. The only test that isn’t running is the integration test, because
    that relies on having a browser environment.'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: '[图9.3](kindle_split_021_split_002.xhtml#ch09fig03) 展示了服务器测试的输出。服务器测试已经运行了你之前编写的一些测试。唯一没有运行的是集成测试，因为那需要有一个浏览器环境。'
- en: Figure 9.3\. The server test output
  id: totrans-639
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.3\. 服务器测试输出
- en: '![](Images/09fig03_alt.jpg)'
  id: totrans-640
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/09fig03_alt.jpg)'
- en: 'Run the server tests with this command, which uses the Mocha CLI:'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令运行服务器测试，该命令使用Mocha CLI：
- en: '[PRE46]'
  id: totrans-642
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: To understand why running your tests on the server adds value, look at [figure
    9.4](kindle_split_021_split_002.xhtml#ch09fig04). It shows the server test failing
    because of a reference to browser environment code.
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解为什么在服务器上运行测试会增加价值，请看[图9.4](kindle_split_021_split_002.xhtml#ch09fig04)。它显示了由于浏览器环境代码的引用而导致服务器测试失败。
- en: Figure 9.4\. Your tests will break if references are added that require a browser
    environment.
  id: totrans-644
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.4. 如果添加了需要浏览器环境的引用，你的测试将失败。
- en: '![](Images/09fig04_alt.jpg)'
  id: totrans-645
  prefs: []
  type: TYPE_IMG
  zh: '![图片9.4](Images/09fig04_alt.jpg)'
- en: 'To try this yourself, add a reference to the `window` object in the Item component’s
    render function, like this:'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 要亲自尝试，请在Item组件的渲染函数中添加对`window`对象的引用，如下所示：
- en: '[PRE47]'
  id: totrans-647
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: When you run this code in your tests, it’ll fail. If you try to run the app,
    you won’t be able to navigate directly to localhost:3000/cart. Testing on the
    server prevents nasty environment-specific bugs.
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在测试中运行此代码时，它将失败。如果你尝试运行应用程序，你将无法直接导航到localhost:3000/cart。在服务器上进行测试可以防止特定环境的糟糕问题。
- en: One of the benefits of tests is that as new people join to work on a project,
    the tests prevent them from causing problems for things they’re unaware of. This
    type of server test helps because it takes some time for new team members to get
    used to thinking isomorphically.
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 测试的一个好处是，随着新成员加入项目，测试可以防止他们因不了解而造成问题。这种类型的服务器测试有助于新团队成员逐渐习惯于同构式思考。
- en: 9.2.2\. Testing all the things
  id: totrans-650
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.2.2. 测试所有事物
- en: Depending on your project and the size of your team or organization, you may
    do some end-to-end or feature-automated testing with a tool like Selenium. Or
    you may have manual QA testers who look for bugs in your product. Or maybe your
    developers do the manual testing.
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的项目和团队或组织的大小，你可能使用Selenium等工具进行一些端到端或功能自动化测试。或者你可能有一些手动质量保证测试员在产品中寻找错误。或者也许你的开发者进行手动测试。
- en: 'In all these cases, it’s important to account for the multiple ways of getting
    to each part of your app:'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些情况下，考虑到达应用程序每个部分的多种方式是很重要的：
- en: The initial page load from the server
  id: totrans-653
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从服务器加载的初始页面
- en: Navigating in your app via single-page application (SPA) flow
  id: totrans-654
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过单页应用程序（SPA）流程在应用程序中导航
- en: Although that may seem obvious to you at this point in the book, it’s not an
    easy concept for those who don’t work on an isomorphic app to grasp. To do manual
    QA, you have to run many test cases twice. Think about testing the cart in this
    app. Because the app assumes the user session is saved, you need to test loading
    the cart directly off the server and test navigating to the cart from another
    part of the app.
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在本书的这个阶段这对你来说可能很显然，但对于那些不从事同构式应用程序开发的人来说，这并不是一个容易理解的概念。要进行手动质量保证，你必须运行许多测试用例两次。考虑一下在这个应用程序中测试购物车。因为应用程序假设用户会话已保存，你需要测试直接从服务器加载购物车，并测试从应用程序的另一部分导航到购物车。
- en: To illustrate this point, [figure 9.5](kindle_split_021_split_002.xhtml#ch09fig05)
    shows the network output of the Cart page when you first load it from the server,
    compared with the network output of the Cart when you load it from another part
    of the app (SPA flow).
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，[图9.5](kindle_split_021_split_002.xhtml#ch09fig05)显示了从服务器首次加载购物车页面时的网络输出，与从应用程序的另一部分（SPA流程）加载购物车时的网络输出进行了比较。
- en: Figure 9.5\. The differences between initial load and the SPA load require testing
    both use cases.
  id: totrans-657
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.5. 初始加载和SPA加载之间的差异需要测试这两种用例。
- en: '![](Images/09fig05_alt.jpg)'
  id: totrans-658
  prefs: []
  type: TYPE_IMG
  zh: '![图片9.5](Images/09fig05_alt.jpg)'
- en: In this section, you learned how to think about testing isomorphically. The
    next section will add debugging tools to your tool belt.
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你学习了如何考虑同构式测试。下一节将向你介绍调试工具。
- en: 9.3\. Using debugging tools
  id: totrans-660
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3. 使用调试工具
- en: One of my favorite teaching moments with new developers or JavaScript newcomers
    is to show them how to use Chrome DevTools to improve their ability to troubleshoot
    and debug problems. Going from `console.log` statements littered throughout code
    to using breakpoints is often a mind-blowing moment for those who are new to troubleshooting
    and debugging. Breakpoints are useful because you can pause and inspect your code,
    stepping through the code to find problems. Chrome DevTools has several advanced
    options for breakpoints as well (find dev tips galore at [https://umaar.com/dev-tips/28-dom-breakpoint-pane/](https://umaar.com/dev-tips/28-dom-breakpoint-pane/)).
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 我最喜欢的新开发人员或 JavaScript 新手教学时刻之一是向他们展示如何使用 Chrome DevTools 提高他们调试和解决问题的能力。从代码中散布的
    `console.log` 语句到使用断点，对于新手来说，这通常是一个令人震惊的时刻。断点很有用，因为您可以暂停并检查您的代码，逐步执行代码以找到问题。Chrome
    DevTools 还提供了断点的几个高级选项（在 [https://umaar.com/dev-tips/28-dom-breakpoint-pane/](https://umaar.com/dev-tips/28-dom-breakpoint-pane/)
    找到大量开发技巧）。
- en: 'I assume you have experience with the Chrome DevTools, but I want to walk you
    through two additional tools that can make your life much simpler when working
    with React and Redux. They’re useful for debugging and manually testing your code:'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 我假设您有 Chrome DevTools 的经验，但我想向您介绍两个额外的工具，它们可以使您在使用 React 和 Redux 时的工作变得更加简单。它们对于调试和手动测试您的代码很有用：
- en: '***React Chrome Extension*—** Browser extension that shows you the React components
    in your markup and displays the properties and current state for each component'
  id: totrans-663
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***React Chrome Extension*—** 浏览器扩展程序，显示您标记中的 React 组件，并显示每个组件的属性和当前状态'
- en: '***Redux Chrome Extension*—** Browser extension that shows you the Redux actions
    in your application and allows you to replay a sequence of actions'
  id: totrans-664
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***Redux Chrome Extension*—** 浏览器扩展程序，显示您应用程序中的 Redux 动作，并允许您重放一系列动作'
- en: 9.3.1\. React Chrome Extension
  id: totrans-665
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.3.1\. React Chrome Extension
- en: The React Chrome Extension loads React Dev Tools and gives you direct insight
    into the React components in your running app. It lets you inspect the HTML structure
    and see how components are wrapped. It also shows you what properties and state
    are set on each component.
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: React Chrome Extension 加载 React Dev Tools，并让您直接了解运行中的应用程序中的 React 组件。它让您检查 HTML
    结构，并查看组件是如何包装的。它还显示了每个组件上设置的属性和状态。
- en: You install this extension from [http://mng.bz/mt5P](http://mng.bz/mt5P). After
    you’ve installed it, load the app and inspect it. Navigate to the React tab. [Figure
    9.6](kindle_split_021_split_003.xhtml#ch09fig06) shows what you should see.
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从 [http://mng.bz/mt5P](http://mng.bz/mt5P) 安装此扩展程序。安装后，加载应用程序并检查它。导航到 React
    选项卡。[图 9.6](kindle_split_021_split_003.xhtml#ch09fig06) 展示了您应该看到的内容。
- en: Figure 9.6\. The React Dev Tools tab open in Chrome DevTools
  id: totrans-668
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 9.6\. 在 Chrome DevTools 中打开的 React Dev Tools 选项卡
- en: '![](Images/09fig06_alt.jpg)'
  id: totrans-669
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/09fig06_alt.jpg)'
- en: You can do many things with React Dev Tools. One useful tool is the ability
    to see every component in the tree, including higher-order components ([figure
    9.7](kindle_split_021_split_003.xhtml#ch09fig07)).
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 React Dev Tools 做很多事情。一个有用的工具是查看树中的每个组件的能力，包括高阶组件（[图 9.7](kindle_split_021_split_003.xhtml#ch09fig07)）。
- en: Figure 9.7\. React Dev Tools let you inspect components that don’t show up in
    regular HTML.
  id: totrans-671
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 9.7\. React Dev Tools 允许您检查在常规 HTML 中不显示的组件。
- en: '![](Images/09fig07_alt.jpg)'
  id: totrans-672
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/09fig07_alt.jpg)'
- en: Another useful feature is the ability to see properties and state. [Figure 9.8](kindle_split_021_split_003.xhtml#ch09fig08)
    shows how to view the properties and state for the Products component.
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的功能是查看属性和状态的能力。[图 9.8](kindle_split_021_split_003.xhtml#ch09fig08) 展示了如何查看
    Products 组件的属性和状态。
- en: Figure 9.8\. Inspecting the state and props for the Products component. You
    can manipulate the state from this panel.
  id: totrans-674
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 9.8\. 检查 Products 组件的状态和属性。您可以从此面板操作状态。
- en: '![](Images/09fig08.jpg)'
  id: totrans-675
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/09fig08.jpg)'
- en: Try changing the state property for `searchQuery`. Notice that it updates in
    the search box when you change it. This ability to override state live in the
    app is helpful for debugging.
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试更改 `searchQuery` 的状态属性。注意，当您更改它时，它会在搜索框中更新。这种在应用程序中实时覆盖状态的能力对于调试很有帮助。
- en: 9.3.2\. Redux Chrome Extension
  id: totrans-677
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.3.2\. Redux Chrome Extension
- en: The Redux Chrome Extension provides a nearly zero-configuration implementation
    of Redux Dev Tools. Install it in Chrome by visiting [http://mng.bz/NEBG](http://mng.bz/NEBG).
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: Redux Chrome Extension 提供了 Redux Dev Tools 的几乎零配置实现。通过访问 [http://mng.bz/NEBG](http://mng.bz/NEBG)
    在 Chrome 中安装它。
- en: Redux Dev Tools is an npm package that you can include in your project, but
    installing the extension is the fastest way to get up and running. You’ll find
    all the documentation for the Redux Dev Tools Extension at the GitHub repo [https://github.com/zalmoxisus/redux-devtools-extension](https://github.com/zalmoxisus/redux-devtools-extension).
    [Figure 9.9](kindle_split_021_split_003.xhtml#ch09fig09) shows what Redux Dev
    Tools looks like running with your app.
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: Redux Dev Tools是一个npm包，你可以将其包含在你的项目中，但安装扩展是快速启动和运行的最快方式。你可以在GitHub仓库[https://github.com/zalmoxisus/redux-devtools-extension](https://github.com/zalmoxisus/redux-devtools-extension)找到Redux
    Dev Tools扩展的所有文档。[图9.9](kindle_split_021_split_003.xhtml#ch09fig09)展示了Redux Dev
    Tools在你的应用中运行时的样子。
- en: Figure 9.9\. Redux Dev Tools inside Chrome DevTools
  id: totrans-680
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.9\. Redux Dev Tools在Chrome DevTools内部
- en: '![](Images/09fig09_alt.jpg)'
  id: totrans-681
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/09fig09_alt.jpg)'
- en: To get Redux Dev Tools to see the Redux store in your app, you must update the
    `compose` function that’s used by the initialize Redux code. The following listing
    shows how to do this. You use this code to replace the old `compose` call in `initRedux`.
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 要让Redux Dev Tools在你的应用中看到Redux存储，你必须更新initialize Redux代码中使用的`compose`函数。以下列表展示了如何进行此操作。你使用此代码来替换`initRedux`中的旧`compose`调用。
- en: Listing 9.6\. Enable Redux Dev Tools—src/shared/initRedux.es6
  id: totrans-683
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.6\. 启用Redux Dev Tools—src/shared/initRedux.es6
- en: '[PRE48]'
  id: totrans-684
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '***1* Updated compose function lives on window, but will break server—check
    for presence of window.**'
  id: totrans-685
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 更新的compose函数位于window上，但会破坏服务器—检查window的存在。**'
- en: '***2* Grab compose function from window object.**'
  id: totrans-686
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 从window对象中获取compose函数。**'
- en: '***3* If developer doesn’t have Redux Dev Tools installed, fall back to base
    compose.**'
  id: totrans-687
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 如果开发者没有安装Redux Dev Tools，则回退到基本compose。**'
- en: '***4* Use new compose function to set up Redux.**'
  id: totrans-688
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 使用新的compose函数设置Redux。**'
- en: Now that you’ve enabled the Redux tools, let’s walk through some of its features.
    [Figure 9.10](kindle_split_021_split_003.xhtml#ch09fig10) shows how to use some
    of the testing features of Redux Dev Tools.
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经启用了Redux工具，让我们来了解一下它的部分功能。[图9.10](kindle_split_021_split_003.xhtml#ch09fig10)展示了如何使用Redux
    Dev Tools的一些测试功能。
- en: Figure 9.10\. Using the testing features of Redux Dev Tools
  id: totrans-690
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.10\. 使用Redux Dev Tools的测试功能
- en: '![](Images/09fig10_alt.jpg)'
  id: totrans-691
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/09fig10_alt.jpg)'
- en: Finally, one of the coolest features of this debugging tool is the ability to
    replay actions. [Figure 9.11](kindle_split_021_split_003.xhtml#ch09fig11) shows
    how to walk through the various states of the cart route.
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这个调试工具最酷的功能之一是能够重放操作。[图9.11](kindle_split_021_split_003.xhtml#ch09fig11)展示了如何遍历购物车路由的各种状态。
- en: Figure 9.11\. Using the playback feature of Redux Dev Tools
  id: totrans-693
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.11\. 使用Redux Dev Tools的回放功能
- en: '![](Images/09fig11_alt.jpg)'
  id: totrans-694
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/09fig11_alt.jpg)'
- en: Summary
  id: totrans-695
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to improve your developer workflow with React-specific
    testing and debugging tools for both the browser and the server. Now you can improve
    your speed of React and isomorphic development!
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何通过React特定的测试和调试工具来改进你的开发工作流程，这些工具适用于浏览器和服务器。现在你可以提高你的React和同构开发速度了！
- en: Enzyme is a library for testing React components. It provides a way to test
    components in isolation via `shallow` and a way to write integration tests with
    `mount`.
  id: totrans-697
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Enzyme是一个用于测试React组件的库。它提供了一种通过`shallow`在隔离环境中测试组件的方法，以及通过`mount`编写集成测试的方法。
- en: Testing an isomorphic app requires thinking through where the code will run
    and how that translates to testing. Unit tests should test code in the environment(s)
    it will run in. End-to-end tests and manual testing should take into account the
    initial load versus the SPA experience.
  id: totrans-698
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试同构应用需要考虑代码将在何处运行以及这如何转化为测试。单元测试应该测试将在其中运行的代码环境（们）。端到端测试和手动测试应考虑初始加载与SPA体验之间的差异。
- en: React Dev Tools can be used via a Chrome extension and makes inspecting your
    React components easier. It also allows you to manipulate state in real time.
  id: totrans-699
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: React Dev Tools可以通过Chrome扩展使用，它使得检查你的React组件变得更容易。它还允许你实时地操作状态。
- en: Redux Dev Tools can be used via a Chrome extension. It lets you walk through
    your actions and clearly see the store update over time.
  id: totrans-700
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Redux Dev Tools可以通过Chrome扩展使用。它让你可以遍历你的操作，并清楚地看到随时间推移的存储更新。
- en: Chapter 10\. Handling server/browser differences
  id: totrans-701
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第10章\. 处理服务器/浏览器差异
- en: '*This chapter covers*'
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Isolating environment-specific code
  id: totrans-703
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将环境特定的代码隔离
- en: Enabling routes that are used on only the browser or the server
  id: totrans-704
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用仅在浏览器或服务器上使用的路由
- en: Using static methods to add headers and page metadata to each app route
  id: totrans-705
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用静态方法向每个应用路由添加标题和页面元数据
- en: Implementing consistent usage of a user agent between the server and the browser
  id: totrans-706
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在服务器和浏览器之间实现用户代理的一致使用
- en: This chapter and the next cover a variety of topics that will help you deal
    with real-world cases that I’ve run into when building isomorphic apps. As you
    embark on building a production-ready app, you’ll often run into use cases that
    need special handling within the context of this type of architecture. [Table
    10.1](kindle_split_022_split_000.xhtml#ch10table01) lists examples of these kinds
    of situations.
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 本章和下一章将涵盖各种主题，这些主题将帮助你处理我在构建同构应用程序时遇到的真实世界案例。当你开始构建一个生产就绪的应用程序时，你经常会遇到需要在这种架构的上下文中进行特殊处理的使用案例。[表10.1](kindle_split_022_split_000.xhtml#ch10table01)列出了这些情况的一些示例。
- en: Table 10.1\. Common problems and solutions within an isomorphic app
  id: totrans-708
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表10.1. 同构应用程序中的常见问题和解决方案
- en: '| Problem | Solution | Server | Browser |'
  id: totrans-709
  prefs: []
  type: TYPE_TB
  zh: '| 问题 | 解决方案 | 服务器 | 浏览器 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-710
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Initialization code that can run only in the browser. | Use an environment
    Boolean flag. |   | ✓ |'
  id: totrans-711
  prefs: []
  type: TYPE_TB
  zh: '| 只能在浏览器中运行的初始化代码。 | 使用环境布尔标志。 |   | ✓ |'
- en: '| Define SEO metatags so they’re rendered on the server. | Use a static function
    on top-level route components. | ✓ |   |'
  id: totrans-712
  prefs: []
  type: TYPE_TB
  zh: '| 定义SEO元标签，以便在服务器上渲染。 | 在顶级路由组件上使用静态函数。 | ✓ |   |'
- en: '| Progressive enhancement: feature detection is different between the browser
    and the server. | Feature-detect only on the browser. |   | ✓ |'
  id: totrans-713
  prefs: []
  type: TYPE_TB
  zh: '| 渐进增强：浏览器和服务器之间的功能检测不同。 | 仅在浏览器中进行功能检测。 |   | ✓ |'
- en: '| Progressive enhancement: if user agent detection is required, how do you
    create a single source of truth? | Use the server user agent and store it in a
    standard way in the app store. | ✓ |   |'
  id: totrans-714
  prefs: []
  type: TYPE_TB
  zh: '| 渐进增强：如果需要用户代理检测，如何创建单一的真实来源？ | 使用服务器用户代理并以标准方式将其存储在应用程序存储中。 | ✓ |   |'
- en: '| Error handling duplication—both the server and the browser have logic to
    handle 404 states. | Save user-facing errors in a standard format that makes determining
    when to show a 404 easy. | ✓ | ✓ |'
  id: totrans-715
  prefs: []
  type: TYPE_TB
  zh: '| 错误处理重复——服务器和浏览器都有处理404状态的逻辑。 | 将面向用户的错误保存为标准格式，以便轻松确定何时显示404。 | ✓ | ✓ |'
- en: 'All the code for this chapter can be found in the same shared GitHub repository
    as previous chapters: [http://mng.bz/8gV8](http://mng.bz/8gV8). We’ll continue
    to use the branch system to step through the examples in this chapter. As usual,
    you can install and run the code:'
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有代码都可以在之前章节相同的共享GitHub仓库中找到：[http://mng.bz/8gV8](http://mng.bz/8gV8)。我们将继续使用分支系统来逐步展示本章的示例。像往常一样，你可以安装并运行代码：
- en: '[PRE49]'
  id: totrans-717
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Let’s explore how to gate your code based on the browser or the server environment.
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探讨如何根据浏览器或服务器环境来控制你的代码。
- en: 10.1\. Isolate browser-specific code
  id: totrans-719
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1. 隔离浏览器特定代码
- en: 'Every web app I’ve ever built has a dependency on the `window` or `document`
    object. Sometimes it’s to support a social widget, and other times it’s a specific
    library I want to use (for example, analytics or bug tracking). But this poses
    a problem in an isomorphic app: how do you continue to use this kind of code without
    breaking your app on the server?'
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 我所构建的每一个Web应用程序都依赖于`window`或`document`对象。有时是为了支持社交小部件，有时是为了使用特定的库（例如，分析或错误跟踪）。但在同构应用程序中，这会引发一个问题：如何在服务器上继续使用这类代码而不破坏你的应用程序？
- en: Imagine you have a reusable module for your analytics code. Your analytics doesn’t
    need to run on the server because it’s focused purely on user interactions with
    the page. But you want to ensure that six months from now, you or another developer
    doesn’t accidentally run this code on the server. [Figure 10.1](kindle_split_022_split_001.xhtml#ch10fig01)
    shows the state of the code in the branch for this section, chapter-10.1 (`git
    checkout chapter-10.1`).
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个用于分析代码的可重用模块。你的分析代码不需要在服务器上运行，因为它纯粹关注于用户与页面的交互。但你希望确保六个月后，你或另一位开发者不会意外地在服务器上运行此代码。[图10.1](kindle_split_022_split_001.xhtml#ch10fig01)显示了本节分支中代码的状态，章节-10.1（`git
    checkout chapter-10.1`）。
- en: Figure 10.1\. The console output without preventing the analytics module from
    running on the server
  id: totrans-722
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.1. 在服务器上不阻止分析模块运行时的控制台输出
- en: '![](Images/10fig01_alt.jpg)'
  id: totrans-723
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/10fig01_alt.jpg)'
- en: 'In this section, you’ll fix this error by wrapping the analytics module in
    code that prevents it from running on the server. This requires a couple of steps
    ([figure 10.2](kindle_split_022_split_001.xhtml#ch10fig02) shows the end result):'
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将通过将分析模块包裹在防止其在服务器上运行的代码中来修复此错误。这需要几个步骤（[图10.2](kindle_split_022_split_001.xhtml#ch10fig02)显示了最终结果）：
- en: '**1**.  Add environment variables (via webpack for the browser code).'
  id: totrans-725
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**. 通过webpack（浏览器代码）添加环境变量。'
- en: '**2**.  Wrap the references to `window` in checks for the browser environment.'
  id: totrans-726
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**. 在对 `window` 的引用周围添加浏览器环境检查。'
- en: Figure 10.2\. Use the environment variable to determine when to run the analytics
    code, which relies on the `window` object.
  id: totrans-727
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.2\. 使用环境变量确定何时运行分析代码，该代码依赖于 `window` 对象。
- en: '![](Images/10fig02_alt.jpg)'
  id: totrans-728
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/10fig02_alt.jpg)'
- en: This analytics module is shown in [listing 10.1](kindle_split_022_split_001.xhtml#ch10ex01).
    I’ve already created the base code of the analytics module for you. I’ve also
    created a mock endpoint on the Node.js server that responds with a 200 when you
    hit the endpoint. But if you run the code in this branch as is, you’ll notice
    it’s broken!
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 此分析模块在 [列表10.1](kindle_split_022_split_001.xhtml#ch10ex01) 中展示。我已经为你创建了分析模块的基础代码。我还在Node.js服务器上创建了一个模拟端点，当你访问端点时，它会返回200。但如果你直接运行此分支中的代码，你会注意到它是出错的！
- en: Listing 10.1\. Analytics module—src/analytics.es6
  id: totrans-730
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.1\. 分析模块—src/analytics.es6
- en: '[PRE50]'
  id: totrans-731
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '***1* Here, analytics library is a mock object added for you to the window
    object (in a real app, you’d import your library).**'
  id: totrans-732
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 这里，分析库是一个为你添加到window对象（在实际应用中，你会导入你的库）的模拟对象。**'
- en: '***2* Mock analytics library has one method, send, which takes in an options
    object.**'
  id: totrans-733
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 模拟分析库有一个方法，send，它接受一个选项对象。**'
- en: '***3* Send makes a POST request to the Node.js server (in a real app, the endpoint
    would be your analytics service).**'
  id: totrans-734
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* Send 向Node.js服务器（在实际应用中，端点将是你的分析服务）发送POST请求。**'
- en: '***4* In this mock example, results and errors are being logged.**'
  id: totrans-735
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 在此模拟示例中，结果和错误被记录。**'
- en: '***5* Analytics module implements a getter method for the analytics object.**'
  id: totrans-736
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 分析模块实现了分析对象的getter方法。**'
- en: '***6* Analytics module implements a sendData method, which calls send on the
    mock analytics object.**'
  id: totrans-737
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 分析模块实现了 sendData 方法，该方法在模拟分析对象上调用 send。**'
- en: '`sendData` is the public method that will be called from view modules. The
    code is broken because it’s being called from shared routes, which are run on
    both the server and the browser. Because the server doesn’t have a `window` object,
    the code breaks the app. [Listing 10.2](kindle_split_022_split_001.xhtml#ch10ex02)
    shows the `sharedRoutes` code that’s calling the analytics module. I’ve already
    provided this for you.'
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: '`sendData` 是一个公共方法，它将从视图模块中被调用。代码出错是因为它从共享路由中被调用，这些路由在服务器和浏览器上都会运行。因为服务器没有
    `window` 对象，所以代码导致应用崩溃。[列表10.2](kindle_split_022_split_001.xhtml#ch10ex02) 展示了调用分析模块的
    `sharedRoutes` 代码。我已经为你提供了这个代码。'
- en: '|  |'
  id: totrans-739
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-740
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: If you’re using React Router 4, check out the first listing in [appendix C](kindle_split_029_split_000.xhtml#app03)
    for how to use the React lifecycle to handle this example, instead of the React
    Router lifecycle.
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用React Router 4，请查看附录C中的第一个列表，了解如何使用React生命周期来处理此示例，而不是React Router生命周期。
- en: '|  |'
  id: totrans-742
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Listing 10.2\. Calling the analytics code—src/shared/sharedRoutes.jsx
  id: totrans-743
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.2\. 调用分析代码—src/shared/sharedRoutes.jsx
- en: '[PRE51]'
  id: totrans-744
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '***1* Import the sendData function from the analytics module.**'
  id: totrans-745
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 从分析模块导入 sendData 函数。**'
- en: '***2* Call sendData to track each location update.**'
  id: totrans-746
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 调用 sendData 以跟踪每个位置更新。**'
- en: To make this module work, you’ll create environment-specific Boolean flags for
    detecting whether the code is running in the server or in the browser. Creating
    environment flags in Node.js is already built into the system. But to create the
    browser environment flag, you’ll need to take advantage of webpack’s plugin system.
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: 要使此模块工作，你需要创建特定于环境的布尔标志，以检测代码是在服务器上还是在浏览器上运行。在Node.js中创建环境标志已经内置到系统中。但为了创建浏览器环境标志，你需要利用webpack的插件系统。
- en: 10.1.1\. Creating the environment variable for the server
  id: totrans-748
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.1.1\. 为服务器创建环境变量
- en: On the server, providing an environment flag is done the same way you set the
    `NODE_ENV` variable. You pass in a `SERVER` value before starting the server.
    The following listing shows how to add this to the package.json start script.
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器上，提供环境标志的方式与设置 `NODE_ENV` 变量的方式相同。在启动服务器之前，传递一个 `SERVER` 值。以下列表展示了如何将此添加到
    package.json 的启动脚本中。
- en: Listing 10.3\. Server startup script—package.json
  id: totrans-750
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.3\. 服务器启动脚本—package.json
- en: '[PRE52]'
  id: totrans-751
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '***1* Add an environment variable to the start script.**'
  id: totrans-752
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 在启动脚本中添加环境变量。**'
- en: After you’ve added this variable, you’ll set up webpack to provide the `BROWSER`
    environment value.
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: 添加此变量后，你将设置webpack以提供 `BROWSER` 环境值。
- en: 10.1.2\. Creating the environment variable for the browser
  id: totrans-754
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.1.2\. 为浏览器创建环境变量
- en: In [chapter 5](kindle_split_016_split_000.xhtml#ch05), I showed you how to create
    a custom webpack plugin to set the stage environment variable. This allowed you
    to indicate a production versus developer build. To create the `BROWSER` and `SERVER`
    variables in webpack, you follow the same pattern. The following listing indicates
    the code you need to add to the webpack configuration to create the environment
    variable for use in your browser code.
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 5 章](kindle_split_016_split_000.xhtml#ch05) 中，我向你展示了如何创建一个自定义 webpack 插件来设置阶段环境变量。这允许你指示生产与开发者构建。要在
    webpack 中创建 `BROWSER` 和 `SERVER` 变量，你遵循相同的模式。以下列表显示了你需要添加到 webpack 配置中的代码，以创建用于浏览器代码的环境变量。
- en: Listing 10.4\. Adding the webpack plugin
  id: totrans-756
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.4\. 添加 webpack 插件
- en: '[PRE53]'
  id: totrans-757
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '***1* Import webpack to call DefinePlugin.**'
  id: totrans-758
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 导入 webpack 以调用 DefinePlugin。**'
- en: '***2* Re-create the process.env object structure.**'
  id: totrans-759
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 重新创建 process.env 对象结构。**'
- en: '***3* Add environment variables into the object, include BROWSER and SERVER.**'
  id: totrans-760
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 在对象中添加环境变量，包括 BROWSER 和 SERVER。**'
- en: '***4* Include plugins array in the options and add injectVariables to the array.**'
  id: totrans-761
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 在选项中包含插件数组，并将 injectVariables 添加到数组中。**'
- en: In the first line, you need to use `require` instead of the `import` statement
    because this file isn’t being compiled by Babel. The final step is to use the
    `BROWSER` variable in the analytics module.
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行，你需要使用 `require` 而不是 `import` 语句，因为此文件不是由 Babel 编译的。最后一步是在分析模块中使用 `BROWSER`
    变量。
- en: 10.1.3\. Using the variables
  id: totrans-763
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.1.3\. 使用变量
- en: Now that the `BROWSER` and `SERVER` variables exist in the appropriate environments,
    you can use the `BROWSER` variable to wrap your analytics implementation code.
    Add the code in the following listing into the analytics module.
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 `BROWSER` 和 `SERVER` 变量已存在于适当的环境中，你可以使用 `BROWSER` 变量来包装你的分析实现代码。将以下列表中的代码添加到分析模块中。
- en: Listing 10.5\. Checking for environment—src/analytics.es6
  id: totrans-765
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.5\. 检查环境—src/analytics.es6
- en: '[PRE54]'
  id: totrans-766
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '***1* Add a check for process.env.BROWSER around the analytics mock object.**'
  id: totrans-767
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 在分析模拟对象周围添加 process.env.BROWSER 的检查。**'
- en: '***2* Add a check around any code that accesses the window object.**'
  id: totrans-768
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 在访问 window 对象的任何代码周围添加检查。**'
- en: Now you can run the code without anything breaking! Try it for yourself.
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以运行代码而不会出现任何问题！自己试试看。
- en: Next let’s discuss how this strategy can be expanded to feature flagging based
    on environment.
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来让我们讨论如何将此策略扩展到基于环境的特性标志。
- en: Environment-aware routes
  id: totrans-771
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 环境感知路由
- en: Other common use cases exist for changing code based on the environment. Another
    common reason you’d need to know the environment is to control which app routes
    are available. For example, maybe you need to create an internal access route—something
    that only a small number of people need access to. That might be an admin page
    or testing route. Conversely, you may want to have certain pages that aren’t directly
    accessible from the server, maybe for privacy reasons or because you don’t want
    the route to be accessible directly from the server.
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 根据环境更改代码的其他常见用例存在。另一个需要知道环境的原因是控制哪些应用程序路由可用。例如，你可能需要创建一个内部访问路由——只有少数人需要访问的东西。那可能是一个管理页面或测试路由。相反，你可能希望有一些页面不能直接从服务器访问，可能是出于隐私原因，或者因为你不想让路由直接从服务器访问。
- en: To do that, you use the same check for `process.env.BROWSER` that you added
    to the analytics module. In this case, you’d add the check in the sharedRoutes.jsx
    component.
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，你使用与添加到分析模块中相同的 `process.env.BROWSER` 检查。在这种情况下，你会在 sharedRoutes.jsx
    组件中添加检查。
- en: Another common use case occurs when you’re developing a new feature and you
    want to make the route available only for testing in your development and staging
    environments. You can also add a check for the `NODE_ENV` value. This lets you
    determine whether a route should be shown only in development/staging or also
    in production. The following listing shows how to add this code to the sharedRoutes
    file.
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的用例发生在你开发一个新功能，并且只想在开发和预发布环境中使路由可用时。你还可以添加对 `NODE_ENV` 值的检查。这让你可以确定路由是否只应在开发/预发布中显示，或者也应在生产中显示。以下列表显示了如何将此代码添加到
    sharedRoutes 文件中。
- en: '|  |'
  id: totrans-775
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-776
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: If you’re using React Router 4, check out the second listing in [appendix C](kindle_split_029_split_000.xhtml#app03)
    to see how to add a dynamic route.
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是 React Router 4，请查看附录 C 中的第二个列表，了解如何添加动态路由。
- en: '|  |'
  id: totrans-778
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Listing 10.6\. Enabling routes—src/shared/sharedRoutes.jsx
  id: totrans-779
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.6\. 启用路由—src/shared/sharedRoutes.jsx
- en: '[PRE55]'
  id: totrans-780
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '***1* Add a variable that will hold the Route component.**'
  id: totrans-781
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 添加一个将保存路由组件的变量。**'
- en: '***2* Render route.**'
  id: totrans-782
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 渲染路由。**'
- en: 'In the first lines, if the environment is production, the value will be null—otherwise,
    it’ll be the route. To test that this code is working, change the `NODE_ENV` variable
    in your webpack config to `production`. The route will then be found on the server
    but won’t exist on the browser, so it’ll return a blank screen:'
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几行，如果环境是生产环境，值将是null——否则，它将是路由。为了测试此代码是否正常工作，将您的webpack配置中的`NODE_ENV`变量更改为`production`。然后路由将在服务器上找到，但在浏览器上不存在，因此它将返回一个空白屏幕：
- en: '[PRE56]'
  id: totrans-784
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Or you can change the value in the start script to be `production` on the server.
    This will result in a “Cannot GET /dev-test” error from the server:'
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以将服务器上的启动脚本中的值更改为`production`。这将导致服务器返回“Cannot GET /dev-test”错误：
- en: '[PRE57]'
  id: totrans-786
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Don’t forget to change these values back when you’re finished.
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后不要忘记将这些值改回来。
- en: 10.2\. SEO and sharing
  id: totrans-788
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2. SEO和分享
- en: When building a public site, whether it’s content-based or e-commerce as in
    the example, search engine optimization (SEO) is an important factor. Good SEO
    leads to higher rankings in search engines, which in turn leads to more users
    for your web app. One of the reasons to build an isomorphic site is to make supporting
    good SEO easy.
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建公共站点时，无论是基于内容还是如示例中的电子商务，搜索引擎优化（SEO）都是一个重要因素。良好的SEO会导致搜索引擎中的排名更高，这反过来又会导致您的Web应用程序的用户数量增加。构建同构站点的其中一个原因是为了使支持良好的SEO变得容易。
- en: In technical terms, this translates into adding SEO metatags and other metadata
    specifically for search engines to see when they crawl the app. [Figure 10.3](kindle_split_022_split_002.xhtml#ch10fig03)
    shows an example of a featured page and a high-ranking page in Google search results.
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术角度来说，这相当于添加SEO元标签和其他特定于搜索引擎的元数据，以便在它们爬取应用程序时可以看到。![图10.3](kindle_split_022_split_002.xhtml#ch10fig03)显示了谷歌搜索结果中的特色页面和高排名页面的示例。
- en: Figure 10.3\. Thoughtful SEO implementation leads to high rankings or featured
    rankings in Google search.
  id: totrans-791
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.3。深思熟虑的SEO实现导致在谷歌搜索中获得高排名或特色排名。
- en: '![](Images/10fig03_alt.jpg)'
  id: totrans-792
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/10fig03_alt.jpg)'
- en: But much of this metadata gets inserted in the head of the HTML page, making
    it difficult to implement alongside a React component. (Remember, React renders
    into a specific tag in the body of your HTML—it has no awareness of the rest of
    the HTML.) I’m going to walk you through using static functions and code specific
    to the server to handle this use case. I’ve used this method successfully. After
    you set it up the first time in an app, continuing to use the logic is straightforward.
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: 但大部分元数据都插入到了HTML页面的头部，这使得在React组件旁边实现变得困难。（记住，React将渲染到HTML体中的特定标签——它对其他HTML没有感知。）我将向您展示如何使用静态函数和针对服务器的特定代码来处理这个用例。我已经成功使用过这种方法。在应用程序中第一次设置后，继续使用逻辑就很简单了。
- en: 'You’re going to work on a portion of the site you haven’t touched yet: the
    product detail pages. Ideally, you want your products to rank high in Google searches
    so that more people come to the site and make purchases. [Figure 10.4](kindle_split_022_split_002.xhtml#ch10fig04)
    shows what the detail page looks like to the user. The code you’ll be adding is
    not directly for user consumption but for Googlebot and sharebots (for example,
    Facebook or Twitter—both sites hit your page directly to determine what content
    should be shared based on metatags).'
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: 您将开始处理您尚未接触过的网站部分：产品详情页面。理想情况下，您希望您的产品在谷歌搜索中获得高排名，以便更多的人访问网站并进行购买。[图10.4](kindle_split_022_split_002.xhtml#ch10fig04)显示了用户看到的详情页面。您将添加的代码不是直接供用户消费的，而是供Googlebot和分享机器人（例如，Facebook或Twitter——这两个网站直接访问您的页面以确定应根据元标签共享哪些内容）。
- en: Figure 10.4\. The product detail page
  id: totrans-795
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.4。产品详情页面
- en: '![](Images/10fig04_alt.jpg)'
  id: totrans-796
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/10fig04_alt.jpg)'
- en: I’ve already provided the Product Detail component for you. You’ll want to switch
    to branch chapter-10.2 (`git checkout chapter-10.2`). [Listing 10.7](kindle_split_022_split_002.xhtml#ch10ex07)
    shows the Product Detail component as it exists when you check out the code (if
    you’re following along, you’ll need to add this code yourself).
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经为您提供了产品详情组件。您需要切换到分支chapter-10.2（`git checkout chapter-10.2`）。[列表10.7](kindle_split_022_split_002.xhtml#ch10ex07)显示了在检出代码时产品详情组件的状态（如果您在跟随，您需要自己添加此代码）。
- en: Listing 10.7\. Product Detail component—src/components/detail.jsx
  id: totrans-798
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.7. 产品详情组件—src/components/detail.jsx
- en: '[PRE58]'
  id: totrans-799
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '***1* Include dependencies—this component is a container, so it’s connected
    to Redux.**'
  id: totrans-800
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 包含依赖项——这个组件是一个容器，因此它与Redux连接。**'
- en: '***2* Implements prefetchActions to get the appropriate state for the detail
    route.**'
  id: totrans-801
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 实现`prefetchActions`以获取详细路由的适当状态。**'
- en: '***3* render function displays the data fetched in prefetchActions.**'
  id: totrans-802
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 渲染函数显示prefetchActions中获取的数据。**'
- en: Next, you’ll add the necessary SEO metatags to the component.
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您将向组件添加必要的SEO元标签。
- en: 10.2.1\. Setting up metadata tags
  id: totrans-804
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.2.1\. 设置元数据标签
- en: There are many parts to implementing good SEO on the detail pages (microdata
    tags, proper page markup, and so forth). Most of these things are handled easily
    within React components. But the metadata tags that should go in the head of every
    page aren’t part of a React component. Metadata tags go in the head, which is
    static after being rendered by the server. It doesn’t change on each React render
    cycle.
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: 在详细页面上实现良好的SEO有许多部分（微数据标签、正确的页面标记等）。这些事情中的大多数都可以在React组件中轻松处理。但是，应该放在每个页面head中的元数据标签不是React组件的一部分。元数据标签放在head中，在服务器渲染后是静态的。它不会在每个React渲染周期中改变。
- en: To create the SEO metatags in the head, I recommend using a `static` function
    so that your components can optionally declare their SEO metadata needs. The following
    listing shows the code you need to add to the detail.jsx component so that you
    can later add the metatags to the head.
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: 要在head中创建SEO元标签，我建议使用`static`函数，这样您的组件可以可选地声明它们的SEO元数据需求。以下列表显示了您需要添加到detail.jsx组件中的代码，以便您可以在以后将元标签添加到head中。
- en: Listing 10.8\. Add a `static` function for creating metatags—src/components/detail.jsx
  id: totrans-807
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.8\. 为创建元标签添加`static`函数——src/components/detail.jsx
- en: '[PRE59]'
  id: totrans-808
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '***1* Define static function.**'
  id: totrans-809
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 定义静态函数。**'
- en: '***2* Set up an array to store each metatag.**'
  id: totrans-810
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 设置一个数组来存储每个元标签。**'
- en: '***3* Each metatag is represented by two keys—name and content or property
    and content—depending on the specific metatag.**'
  id: totrans-811
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 每个元标签由两个键表示——名称和内容或属性和内容，具体取决于特定的元标签。**'
- en: The `static` function takes in a `params` object (just like `prefetchActions`)
    and the store so that it can grab the current product.
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: '`static`函数接受一个`params`对象（就像`prefetchActions`一样）和store，以便它可以获取当前产品。'
- en: 10.2.2\. Rendering metatags into the head on the server
  id: totrans-813
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.2.2\. 在服务器上将元标签渲染到head中
- en: On the server, you can take advantage of these `static` functions to generate
    the metatags into the html.jsx component that’s rendered and returned to the browser.
    The following listing shows the code you need to add.
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器上，您可以利用这些`static`函数将元标签生成到渲染并返回给浏览器的html.jsx组件中。以下列表显示了您需要添加的代码。
- en: Listing 10.9\. Render metatags as part of html.jsx—src/components/html.jsx
  id: totrans-815
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.9\. 将元标签作为html.jsx的一部分渲染——src/components/html.jsx
- en: '[PRE60]'
  id: totrans-816
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '***1* Loop through each item provided in the metatags array and create a metatag
    with item’s properties.**'
  id: totrans-817
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 遍历元标签数组中提供的每个项目，并创建一个具有项目属性的元标签。**'
- en: '***2* Add metatags HTML to the <head>.**'
  id: totrans-818
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将元标签HTML添加到<head>中。**'
- en: Finally, you need to add the code to renderView.jsx that will pull the metatag
    arrays out of the individual components. This code is identical to the code you
    added in [chapter 7](kindle_split_019_split_000.xhtml#ch07) for `prefetchActions`.
    I’ve pulled the code from [chapter 7](kindle_split_019_split_000.xhtml#ch07) into
    a reusable function for you.
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您需要在renderView.jsx中添加代码，以从单个组件中提取元标签数组。此代码与您在[第7章](kindle_split_019_split_000.xhtml#ch07)中为`prefetchActions`添加的代码相同。我已经将此代码从[第7章](kindle_split_019_split_000.xhtml#ch07)提取到一个可重用的函数中供您使用。
- en: Listing 10.10\. `flattenStaticFunction` code—src/middleware/renderView.jsx
  id: totrans-820
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.10\. `flattenStaticFunction`代码——src/middleware/renderView.jsx
- en: '[PRE61]'
  id: totrans-821
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '***1* Reusable function declaration takes in renderProps and the store so it
    can pull out the appropriate information.**'
  id: totrans-822
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 可重用函数声明接受renderProps和store，以便它可以提取适当的信息。**'
- en: '***2* Use the staticFnName variable instead of hardcoding the prefetchActions
    function name.**'
  id: totrans-823
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 使用staticFnName变量而不是硬编码prefetchActions函数名称。**'
- en: '***3* Some of the static functions need information about the request such
    as the headers. It’s passed in here to give access to that information.**'
  id: totrans-824
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 一些静态函数需要有关请求的信息，例如头信息。它在这里传递以提供对该信息的访问权限。**'
- en: The reuseable function also takes in a `staticFnName`. This is the reusable
    bit that will let you use this function for multiple types of `static` functions
    (`prefetchActions`, `seoTags`, and so on). Because this code already exists for
    you, all you need to do is add the code in the following listing to renderView.jsx.
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: 可重用函数还接受一个`staticFnName`。这是可重用的部分，将允许您使用此函数进行多种类型的`static`函数（`prefetchActions`、`seoTags`等）。因为此代码已经为您准备好了，所以您需要做的只是将以下列表中的代码添加到renderView.jsx中。
- en: Listing 10.11\. Fetch metatags array—src/middleware/renderView.jsx
  id: totrans-826
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.11\. 获取metatags数组—src/middleware/renderView.jsx
- en: '[PRE62]'
  id: totrans-827
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '***1* Call flattenStaticFunction with React Router renderProps, the name of
    the function to call, and the current state of the store—returns metatags array.**'
  id: totrans-828
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 使用React Router的renderProps调用flattenStaticFunction，调用函数的名称以及存储的当前状态——返回metatags数组。**'
- en: '***2* Pass these tags into the HTML component so they can be used by the code
    added in [listing 10.9](kindle_split_022_split_002.xhtml#ch10ex09).**'
  id: totrans-829
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将这些标签传递给HTML组件，以便它们可以在[列表10.9](kindle_split_022_split_002.xhtml#ch10ex09)中添加的代码中使用。**'
- en: Now that you’ve seen how to handle SEO and sharing metatags, let’s look at handling
    the title on the browser and the server.
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到了如何处理SEO和共享metatags，让我们看看如何在浏览器和服务器上处理标题。
- en: 10.2.3\. Handling the title
  id: totrans-831
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.2.3\. 处理标题
- en: Titles are important for SEO and for a good user experience. The combination
    of title and favicon makes your tab or window in a browser distinct from all the
    others. [Figure 10.5](kindle_split_022_split_002.xhtml#ch10fig05) shows what this
    looks like in the browser.
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: 标题对于搜索引擎优化（SEO）和良好的用户体验非常重要。标题和favicon的组合使你的浏览器标签或窗口与其他所有标签或窗口区分开来。[图10.5](kindle_split_022_split_002.xhtml#ch10fig05)显示了在浏览器中看起来是什么样子。
- en: Figure 10.5\. The title displayed in the browser
  id: totrans-833
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.5\. 浏览器中显示的标题
- en: '![](Images/10fig05_alt.jpg)'
  id: totrans-834
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/10fig05_alt.jpg)'
- en: Title on the server
  id: totrans-835
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 服务器上的标题
- en: Handling the title on the server is similar to handling the metadata on the
    server. Each top-level component should provide a `static` function that outputs
    the title. In addition, I suggest breaking out the title output from the function
    that takes in the server data so you can reuse some of your logic on the browser.
    Add the code in the following listing to the Detail component.
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器上处理标题与处理元数据类似。每个顶级组件都应该提供一个`static`函数来输出标题。此外，我建议将标题输出从接收服务器数据的函数中分离出来，这样你就可以在浏览器上重用一些逻辑。将以下列表中的代码添加到Detail组件中。
- en: Listing 10.12\. Create title `static` function—src/components/detail.jsx
  id: totrans-837
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.12\. 创建标题`static`函数—src/components/detail.jsx
- en: '[PRE63]'
  id: totrans-838
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '***1* Static function creates the title from props, an abstraction that’ll
    make creating the title on the browser easier.**'
  id: totrans-839
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 静态函数从属性中创建标题，这是一个抽象，将使在浏览器上创建标题更容易。**'
- en: '***2* On the server, renderView middleware will call getTitle, which takes
    in the store and pulls out the currentProduct data.**'
  id: totrans-840
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 在服务器上，renderView中间件将调用getTitle，该函数接收存储并提取当前Product数据。**'
- en: After you have a component with the proper `static` function, you can set up
    the title on the server. In the `renderView` code, you add a call to get the title.
    The following listing shows the code you add to renderView.jsx.
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: 在你有一个具有适当`static`函数的组件后，你可以在服务器上设置标题。在`renderView`代码中，你添加了一个获取标题的调用。以下列表显示了添加到renderView.jsx中的代码。
- en: Listing 10.13\. Add title for the route—src/middleware/renderView.jsx
  id: totrans-842
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.13\. 为路由添加标题—src/middleware/renderView.jsx
- en: '[PRE64]'
  id: totrans-843
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The first lines call `flattenStaticFunction` with the React Router `renderProps`,
    the name of the function (`getTitle`), and the `serverState` so that the title
    details can be fetched. A string title is returned. At the end, you pass the title
    into the HTML component.
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: 前几行使用React Router的`renderProps`调用`flattenStaticFunction`，函数名称（`getTitle`）和`serverState`，以便可以获取标题详细信息。返回一个字符串标题。最后，你将标题传递到HTML组件中。
- en: Finally, you need to change the title in html.jsx to use the passed-in prop.
    The following listing shows you what to add.
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你需要将html.jsx中的标题更改为使用传入的属性。以下列表显示了你需要添加的内容。
- en: Listing 10.14\. Render the title for the route—src/components/html.jsx
  id: totrans-846
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.14\. 渲染路由的标题—src/components/html.jsx
- en: '[PRE65]'
  id: totrans-847
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Use `dangerouslySetInnerHTML` to output the title string. If you render the
    title directly into the tag, React will append a comment that will then show up
    in the browser. If you run the server and reload the detail page, the title will
    be based on the product title.
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`dangerouslySetInnerHTML`输出标题字符串。如果你直接将标题渲染到标签中，React将附加一个注释，然后它将显示在浏览器中。如果你运行服务器并重新加载详细页面，标题将基于产品标题。
- en: Next, let’s look at updating the title in the browser.
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看如何在浏览器中更新标题。
- en: Title on the browser
  id: totrans-850
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 浏览器上的标题
- en: Most metatags are needed on only the initial render to serve to Googlebot (and
    sharebots). But the title tag is user facing and should get updated on every route
    change. This creates a unique situation, where you need to update a part of the
    DOM that isn’t controlled by React. The following listing shows you what to add.
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数元标签只需要在初始渲染时使用，以服务于Googlebot（以及分享机器人）。但标题标签是面向用户的，并且应该在每次路由更改时更新。这创造了一个独特的情况，你需要更新一个不由React控制的DOM部分。以下列表显示了你需要添加的内容。
- en: Listing 10.15\. Add title update code to Detail—src/components/detail.jsx
  id: totrans-852
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.15\. 将标题更新代码添加到Detail—src/components/detail.jsx
- en: '[PRE66]'
  id: totrans-853
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '***1* Add a call to update the contents of the title tag in both componentDidUpdate
    and componentDidMount.**'
  id: totrans-854
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 在`componentDidUpdate`和`componentDidMount`中添加一个调用以更新标题标签的内容。**'
- en: This kind of situation is rare, but when it occurs, using direct DOM access
    is fine. Just make sure to ask yourself, “Can I do this the React way?” before
    accessing the DOM.
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况很少见，但一旦发生，使用直接DOM访问是可以的。只是确保在访问DOM之前问自己，“我能用React的方式做到这一点吗？”
- en: To practice the techniques from this section, you can add metatags and titles
    to other top-level React components in the project. This strategy can be applied
    anytime you need to have server-generated information based on a top-level component
    (for example, generating route-specific headers).
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: 为了练习本节中的技术，你可以在项目中添加其他顶级React组件的元标签和标题。这种策略可以应用于你需要基于顶级组件生成服务器信息的情况（例如，生成特定路由的头部信息）。
- en: 10.3\. Multiple sources of truth
  id: totrans-857
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3\. 多个真实来源
- en: When building isomorphic apps, you may run into cases where you can get the
    same information from the server and the browser. Common examples are user agent
    and locale, which are both sent as headers to the server but can also be accessed
    in the browser. How do you approach handling these situations?
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: 当构建同构应用时，你可能会遇到可以从服务器和浏览器中获取相同信息的情况。常见的例子是用户代理和区域设置，它们都作为头部信息发送到服务器，但也可以在浏览器中访问。你如何处理这些情况？
- en: 'Simple: pick a single source of truth. The first place your app runs code is
    the server, so if possible, use the server as the source of truth.'
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说：选择一个单一的真实来源。你的应用首次运行代码的地方是服务器，所以如果可能的话，使用服务器作为真实来源。
- en: 10.3.1\. User agent best practices
  id: totrans-860
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.3.1\. 用户代理最佳实践
- en: I’ve worked with video for most of my career, and one of the challenges with
    video on the web is that it isn’t standardized at all. For example, every browser
    supports a different set of video-encoding options. Safari (desktop and mobile)
    support different options than Chrome, Firefox, and Microsoft Edge. Although there
    are some built-in ways to handle this problem (with the `<video>` tag and feature
    detection via `canPlayType`), in custom high-performance video players, you often
    have to handle the differences on your own.
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
  zh: 我的大部分职业生涯都与视频工作有关，而网页上视频的一个挑战是它根本没有任何标准。例如，每个浏览器都支持不同的视频编码选项。Safari（桌面和移动）支持的选项与Chrome、Firefox和Microsoft
    Edge不同。尽管有一些内置的方式来处理这个问题（使用`<video>`标签和通过`canPlayType`进行功能检测），但在自定义高性能视频播放器中，你通常必须自己处理这些差异。
- en: 'This is one of the few places I’ve run into building web apps that consistently
    requires user agent detection. Although user agent detection is best avoided,
    it’s worth covering here in case you do run into a similar situation. I have two
    principles to follow when using user agent detection in an isomorphic app:'
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我遇到过的在构建Web应用时需要持续进行用户代理检测的少数地方之一。尽管用户代理检测最好避免，但在这里介绍它是有价值的，以防你遇到类似的情况。在异构应用中使用用户代理检测时，我遵循以下两个原则：
- en: '***Always use a single source of truth*—** This means parsing the user agent
    on the server and passing it down to the browser.'
  id: totrans-863
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '***始终使用单一的真实来源*—** 这意味着在服务器上解析用户代理并将其传递到浏览器。'
- en: '***Use the broadest definition possible*—** Rather than ask, “Is this an iPhone?”
    ask, “Is this a mobile device?” It’s extremely rare to need to know a specific
    version of a device category or specific browser.'
  id: totrans-864
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '***尽可能使用最广泛的定义*—** 而不是问“这是一个iPhone吗？”而是问“这是一个移动设备吗？”需要知道特定设备类别或特定浏览器的具体版本的情况极为罕见。'
- en: 10.3.2\. Parse the user agent
  id: totrans-865
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.3.2\. 解析用户代理
- en: You need two things to parse out the user agent into a usable value for your
    application. First, you need to add an action and reducer. Second, you need to
    pass the `User-Agent` header information into that action on the server. You’ll
    want to switch to branch chapter-10.3 (`git checkout chapter-10.3`), which has
    all the code from the previous sections.
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要两样东西来解析用户代理，以便在您的应用中使用。首先，您需要添加一个动作和缩减器。其次，您需要将`User-Agent`头信息传递到服务器上的该动作。您可能想要切换到分支chapter-10.3（`git
    checkout chapter-10.3`），其中包含上一节的所有代码。
- en: '[Listing 10.16](kindle_split_022_split_003.xhtml#ch10ex16) shows the code you
    need to add to the project: a new action in a new action file called app-action-creators.es6\.
    This action will take in the request headers and parse them into a usable object
    using a third-party library. I’ve picked ua-parser-js here, but you could use
    any library of your choice that’s isomorphic ([https://github.com/faisalman/ua-parser-js](https://github.com/faisalman/ua-parser-js)).
    Make sure to install this package if you’re following along:'
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表10.16](kindle_split_022_split_003.xhtml#ch10ex16)显示了您需要添加到项目中的代码：在名为app-action-creators.es6的新动作文件中添加一个新动作。此动作将接受请求头，并使用第三方库将它们解析为可用的对象。我在这里选择了ua-parser-js，但您可以使用任何您选择的同构库（[https://github.com/faisalman/ua-parser-js](https://github.com/faisalman/ua-parser-js)）。如果您正在跟随，请确保安装此包：'
- en: '[PRE67]'
  id: totrans-868
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Listing 10.16\. User agent action—src/shared/app-action-creators.es6
  id: totrans-869
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.16\. 用户代理动作—src/shared/app-action-creators.es6
- en: '[PRE68]'
  id: totrans-870
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '***1* Include the user agent parser library.**'
  id: totrans-871
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 包含用户代理解析库。**'
- en: '***2* Construct new instance of user agent parser.**'
  id: totrans-872
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 构造新的用户代理解析器实例。**'
- en: '***3* Make sure there are request headers and a user agent request header.**'
  id: totrans-873
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 确保存在请求头和用户代理请求头。**'
- en: '***4* Pass current user agent string into parser.**'
  id: totrans-874
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 将当前用户代理字符串传递给解析器。**'
- en: '***5* Create the object that represents the user agent.**'
  id: totrans-875
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 创建表示用户代理的对象。**'
- en: '***6* Return the action to the reducer.**'
  id: totrans-876
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 将动作返回给缩减器。**'
- en: After you’ve created the action code, it’s time to add the reducer. The following
    listing shows the code you need to add to a new file called app-reducer.es6.
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: 在您创建了动作代码之后，是时候添加缩减器了。以下列表显示了您需要添加到新文件app-reducer.es6中的代码。
- en: Listing 10.17\. User agent reducer—src/shared/app-reducer.es6
  id: totrans-878
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.17\. 用户代理缩减器—src/shared/app-reducer.es6
- en: '[PRE69]'
  id: totrans-879
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '***1* Set userAgent from the action on the state (if user agent on action is
    undefined, use previous state).**'
  id: totrans-880
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 在状态上设置从动作中获取的用户代理（如果动作中的用户代理未定义，则使用上一个状态）。**'
- en: Don’t forget that in order to wire up Redux actions and reducers, you have to
    add the reducer to the init-redux file. The following listing shows you the code
    to add.
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记，为了连接Redux动作和缩减器，您必须将缩减器添加到init-redux文件中。以下列表显示了添加的代码。
- en: Listing 10.18\. Importing the app reducer—src/shared/init-redux.es6
  id: totrans-882
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.18\. 导入app缩减器—src/shared/init-redux.es6
- en: '[PRE70]'
  id: totrans-883
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '***1* Include app reducer.**'
  id: totrans-884
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 包含app缩减器。**'
- en: '***2* Add reducer to combineReducers statement.**'
  id: totrans-885
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将缩减器添加到combineReducers语句。**'
- en: Now that your Redux business logic is in place, you need to call this action
    from the view. Rather than add this action to every single top-level component,
    you can add it to the root component (App). Remember, this component is loaded
    by the topmost route in your app. The following listing shows the code to add
    to app.jsx.
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您的Redux业务逻辑已经就绪，您需要从视图中调用此动作。与其将此动作添加到每个顶级组件，不如将其添加到根组件（App）。请记住，此组件由您的应用中最顶层的路由加载。以下列表显示了添加到app.jsx的代码。
- en: Listing 10.19\. Calling `parseUserAgent` from the view—src/components/app.jsx
  id: totrans-887
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.19\. 从视图调用`parseUserAgent`—src/components/app.jsx
- en: '[PRE71]'
  id: totrans-888
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '***1* Import the action from action creators file.**'
  id: totrans-889
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 从动作创建文件导入动作。**'
- en: '***2* Return the action and bind request headers (on the browser, it’ll be
    empty, on the server, you’ll pass in the request object).**'
  id: totrans-890
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 返回动作并绑定请求头（在浏览器上，它将是空的，在服务器上，您将传递请求对象）。**'
- en: Finally, you need to add code to the middleware to pass in the request to the
    `prefetchActions` function. This will happen in the `flattenStaticFunction`. [Listing
    10.20](kindle_split_022_split_003.xhtml#ch10ex20) shows the code to add.
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您需要向中间件添加代码以将请求传递给`prefetchActions`函数。这将在`flattenStaticFunction`中发生。[列表10.20](kindle_split_022_split_003.xhtml#ch10ex20)显示了添加代码。
- en: Listing 10.20\. Pass request to `prefetchActions`—src/middleware/renderView.jsx
  id: totrans-892
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.20\. 将请求传递给`prefetchActions`—src/middleware/renderView.jsx
- en: '[PRE72]'
  id: totrans-893
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '***1* Make the request object a property passed into flattenStaticFunction**'
  id: totrans-894
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将请求对象作为传递给flattenStaticFunction的属性。**'
- en: '***2* Pass request object into static function being called (functions that
    don’t use it will ignore it because it’s the last parameter).**'
  id: totrans-895
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将请求对象传递给被调用的静态函数（不使用它的函数将忽略它，因为它是最后面的参数）。**'
- en: '***3* This use case of flattenStaticFunction doesn’t require the store state
    to work, pass null instead.**'
  id: totrans-896
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* flattenStaticFunction 的此用例不需要 store 状态来工作，传递 null。**'
- en: '***4* Make sure to pass req object into flattenStaticFunction when you call
    it for prefetchActions.**'
  id: totrans-897
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 确保在调用 prefetchActions 时将 req 对象传递给 flattenStaticFunction。**'
- en: Now you have a user agent parsed into your app state that doesn’t get overridden
    on the browser. Set a breakpoint in the browser to see how the user agent will
    be undefined in the reducer and not get overridden. [Figure 10.6](kindle_split_022_split_003.xhtml#ch10fig06)
    shows setting a breakpoint in the app-reducer.es6 code and inspecting the action
    value to see how it isn’t set at all on the browser.
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经将用户代理解析到你的应用状态中，它不会在浏览器中被覆盖。在浏览器中设置断点以查看用户代理在 reducer 中将如何被定义为 undefined
    并不会被覆盖。[图 10.6](kindle_split_022_split_003.xhtml#ch10fig06) 展示了在 app-reducer.es6
    代码中设置断点并检查动作值，以查看它根本不会在浏览器上设置。
- en: Figure 10.6\. Set a breakpoint in the app-reducer.es6 and inspect the `action.userAgent`
    value.
  id: totrans-899
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 10.6\. 在 app-reducer.es6 中设置断点并检查 `action.userAgent` 的值。
- en: '![](Images/10fig06_alt.jpg)'
  id: totrans-900
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/10fig06_alt.jpg)'
- en: Summary
  id: totrans-901
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned to handle the environment-specific edge cases that
    come up in a real-world application. You also learned to handle errors properly.
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何处理现实应用中出现的特定环境边缘情况。你还学习了如何正确处理错误。
- en: Handle browser- and server-only code using webpack to create the `process.env`
    object.
  id: totrans-903
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 webpack 处理浏览器和服务器专用的代码以创建 `process.env` 对象。
- en: Implement server and browser-specific routes as well as apply the same kind
    of logic to environment routes (development versus production).
  id: totrans-904
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现服务器和浏览器特定的路由，并将相同的逻辑应用于环境路由（开发与生产）。
- en: Determine SEO metadata tags and the page title on a per-route basis using static
    methods.
  id: totrans-905
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用静态方法根据每个路由确定 SEO 元数据标签和页面标题。
- en: Parse the user agent on the server and use it as the source of truth in the
    browser.
  id: totrans-906
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在服务器上解析用户代理并将其用作浏览器中的真实来源。
- en: Chapter 11\. Optimizing for production
  id: totrans-907
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 11 章\. 为生产优化
- en: '*This chapter covers*'
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Optimizing performance for the browser
  id: totrans-909
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为浏览器优化性能
- en: Using streaming on Node.js to improve server performance
  id: totrans-910
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Node.js 上使用流来提高服务器性能
- en: Using caching to improve performance on the server
  id: totrans-911
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用缓存来提高服务器性能
- en: Handling user sessions via cookies on the server and browser
  id: totrans-912
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过服务器和浏览器上的 cookie 处理用户会话
- en: Rather than doing a deep dive into any specific topic, this chapter covers a
    range of topics that will make your app perform better and improve your end-user
    experience. This includes React performance, Node.js performance, and various
    caching strategies. The last section of this chapter covers handling cookies in
    an isomorphic application and the trade-offs that this creates with some of the
    caching strategies.
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是深入研究任何特定主题，本章涵盖了一系列将使你的应用性能更好并提高最终用户体验的话题。这包括 React 性能、Node.js 性能和多种缓存策略。本章的最后部分涵盖了在同构应用中处理
    cookie 以及这给一些缓存策略带来的权衡。
- en: This chapter continues to use the complete-isomorphic-example repo on GitHub.
    It can be found at [http://mng.bz/8gV8](http://mng.bz/8gV8). The first section
    uses the code on branch chapter-11.1 (`git checkout chapter-11.1`). You can find
    the completed code for the chapter on the chapter-11.complete branch (`git checkout
    chapter-11-complete`).
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
  zh: 本章继续使用 GitHub 上的完整同构示例仓库。它可以在 [http://mng.bz/8gV8](http://mng.bz/8gV8) 找到。第一部分使用
    chapter-11.1 分支上的代码（`git checkout chapter-11.1`）。你可以在 chapter-11.complete 分支上找到本章的完整代码（`git
    checkout chapter-11-complete`）。
- en: 'To run each branch, make sure to use the following:'
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行每个分支，请确保使用以下命令：
- en: '[PRE73]'
  id: totrans-916
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 11.1\. Browser performance optimizations
  id: totrans-917
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.1\. 浏览器性能优化
- en: 'As I’ve spent more time with React, I’ve discovered that although it’s fast
    out of the box, in complex apps you’ll run into performance problems. To keep
    your React web app performant, you need to keep performance in mind as your app
    grows and adds more-complex feature interactions. Two specific cases start to
    cause performance issues as your app grows:'
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我花更多的时间在 React 上，我发现虽然它开箱即用很快，但在复杂的应用中你可能会遇到性能问题。为了保持你的 React 网页应用性能，你需要随着应用的增长和更复杂的功能交互的增加，始终考虑性能。随着应用的增长，以下两个特定情况开始引起性能问题：
- en: '***The size of your JavaScript*—** The next section covers using webpack chunking
    to reduce bundle size.'
  id: totrans-919
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***JavaScript 的大小*—** 下一节将介绍如何使用 webpack 分块来减小包大小。'
- en: '***Unnecessary renders*—** In [section 11.1.2](kindle_split_023_split_001.xhtml#ch11lev2sec2),
    we’ll go over the basics of using `shouldComponentRender` to reduce unnecessary
    renders.'
  id: totrans-920
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***不必要的渲染*—** 在 [第 11.1.2 节](kindle_split_023_split_001.xhtml#ch11lev2sec2)
    中，我们将介绍使用 `shouldComponentRender` 来减少不必要的渲染的基本方法。'
- en: 11.1.1\. Webpack chunking
  id: totrans-921
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.1.1\. Webpack 分块
- en: 'I’ve often experienced the following scenario when building an app of any kind:
    my app starts out small, and the JavaScript assets are small enough that they
    load quickly. Over time, I add features, get lazy about reviewing the size of
    included packages, and generally don’t pay attention to bundle size. (Code base
    size management is especially difficult on larger teams.) Then one day I check
    the load time of the page and realize my JavaScript file has become too big! It’s
    affecting the overall load time of the app. Cue freak-out moment!'
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建任何类型的应用程序时，我经常遇到以下场景：我的应用程序开始时规模较小，JavaScript 资产也足够小，可以快速加载。随着时间的推移，我添加了功能，对检查包含的包的大小变得懒惰，并且通常不关注包大小。（在大型团队中，代码库大小管理尤其困难。）然后有一天，我检查了页面的加载时间，发现我的
    JavaScript 文件变得太大！这影响了应用程序的整体加载时间。然后就是恐慌的时刻！
- en: Thankfully, webpack provides a way to solve this problem, by breaking the code
    into multiple bundles that can be loaded as they’re needed. The next two diagrams
    walk you through this concept.
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，webpack 提供了一种通过将代码拆分为多个按需加载的包来解决此问题的方法。接下来的两个图解将向您介绍这个概念。
- en: '|  |'
  id: totrans-924
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-925
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: If you’re using React Router 4, check out [appendix C](kindle_split_029_split_000.xhtml#app03)
    for information on code splitting with webpack.
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用的是 React Router 4，请参阅 [附录 C](kindle_split_029_split_000.xhtml#app03) 了解使用
    webpack 进行代码拆分的信息。
- en: '|  |'
  id: totrans-927
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '[Figure 11.1](kindle_split_023_split_001.xhtml#ch11fig01) demonstrates how
    the app is currently compiling. All the code is being pulled together into a single
    output file. This file is being referenced in html.jsx.'
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 11.1](kindle_split_023_split_001.xhtml#ch11fig01) 展示了应用程序当前是如何编译的。所有代码都被组合成一个输出文件。此文件在
    html.jsx 中被引用。'
- en: Figure 11.1\. The default behavior of webpack results in a single file that
    represents all your code.
  id: totrans-929
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 11.1\. webpack 的默认行为导致一个代表所有代码的单个文件。
- en: '![](Images/11fig01_alt.jpg)'
  id: totrans-930
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/11fig01_alt.jpg)'
- en: '[Figure 11.2](kindle_split_023_split_001.xhtml#ch11fig02) shows what you’ll
    implement in this section. The code is still combined in webpack’s compilation
    step, but it’s then split into multiple JavaScript files. This is configured by
    you in code (not in webpack configuration).'
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 11.2](kindle_split_023_split_001.xhtml#ch11fig02) 展示了本节中将实现的内容。代码在 webpack
    的编译步骤中仍然被组合，但随后被拆分为多个 JavaScript 文件。这是您在代码中配置的（而不是在 webpack 配置中）。'
- en: Figure 11.2\. Using code splitting, webpack outputs multiple files that can
    be dynamically loaded. The specific files will vary by app.
  id: totrans-932
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 11.2\. 使用代码拆分，webpack 输出多个可以动态加载的文件。具体文件将根据应用程序而异。
- en: '![](Images/11fig02_alt.jpg)'
  id: totrans-933
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/11fig02_alt.jpg)'
- en: 'To make this happen in your code, you need to update the way you import the
    routes. This process has three steps:'
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
  zh: 要在您的代码中实现这一点，您需要更新导入路由的方式。这个过程有三个步骤：
- en: '**1**.  Add Babel plugins that will handle dynamic import on the Node.js server
    and via the Babel loader in your webpack configuration.'
  id: totrans-935
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**1**.  添加 Babel 插件，这些插件将处理 Node.js 服务器上的动态导入以及您的 webpack 配置中的 Babel 加载器。'
- en: '**2**.  Add dynamic import to `sharedRoutes`.'
  id: totrans-936
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**2**.  将动态导入添加到 `sharedRoutes`。'
- en: '**3**.  Enable chunks in webpack with `chunkFilename`.'
  id: totrans-937
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**3**.  使用 `chunkFilename` 在 webpack 中启用块。'
- en: 'Installing and adding the new Babel plugins is the first step. Run the following
    commands in your terminal:'
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的终端中运行以下命令以安装和添加新的 Babel 插件：
- en: '[PRE74]'
  id: totrans-939
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Then you need to update .babelrc. [Listing 11.1](kindle_split_023_split_001.xhtml#ch11ex01)
    shows the updates that are needed. This is a significant change from the old version
    because you need different plugins for webpack and Node.js. Later you’ll make
    sure that webpack points at the webpack env config.
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
  zh: 然后您需要更新 .babelrc。[列表 11.1](kindle_split_023_split_001.xhtml#ch11ex01) 展示了所需的更新。与旧版本相比，这是一个重大变化，因为您需要为
    webpack 和 Node.js 使用不同的插件。稍后您将确保 webpack 指向 webpack 环境配置。
- en: Listing 11.1\. Add plugins to .babelrc
  id: totrans-941
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 11.1\. 在 .babelrc 中添加插件
- en: '[PRE75]'
  id: totrans-942
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '***1* Add an env config option.**'
  id: totrans-943
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 添加一个环境配置选项。**'
- en: '***2* Add two environments: development (the default) and webpack-env for webpack
    builds.**'
  id: totrans-944
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 添加两个环境：开发环境（默认）和 webpack-env 用于 webpack 构建。**'
- en: '***3* For webpack, add only the plugin that allows dynamic import syntax.**'
  id: totrans-945
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 对于 webpack，只添加允许动态导入语法的插件。**'
- en: '***4* For node, both the syntax and implementation plugins are required.**'
  id: totrans-946
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 对于 node，需要语法和实现插件。**'
- en: '***5* The original plugins array is left intact. Env options are merged with
    any default options.**'
  id: totrans-947
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 原始的插件数组保持不变。环境选项与任何默认选项合并。**'
- en: The main goal of the Babel config change is that it splits your Babel config
    into two versions, one for the server (development) and one for webpack (webpack-env).
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
  zh: Babel 配置更改的主要目标是将其分为两个版本，一个用于服务器（开发），另一个用于 webpack（webpack-env）。
- en: 'Next, you have to add a dynamic import. [Listing 11.2](kindle_split_023_split_001.xhtml#ch11ex02)
    shows how to create statements that tell webpack to create a code chunk. This
    replaces the `import` statements for components in `sharedRoutes`. For now, you’ll
    apply this pattern to a single route: `cart`. But in production apps, I recommend
    you apply this based on your own traffic patterns (chunk your highest traffic
    routes separately from your low-traffic routes, or chunk admin or other authenticated
    pages separately from public ones). Additionally, this code could be abstracted
    and made reusable for a production use case—but for this example, it illustrates
    the changes in a clear, concise way.'
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你必须添加一个动态导入。[列表 11.2](kindle_split_023_split_001.xhtml#ch11ex02) 展示了如何创建告诉
    webpack 创建代码块的语句。这替换了 `sharedRoutes` 中组件的 `import` 语句。目前，你将应用此模式到单个路由：`cart`。但在生产应用中，我建议你根据自己的流量模式应用此模式（将高流量路由与低流量路由分开分割，或将管理或其他认证页面与公共页面分开分割）。此外，此代码可以抽象化并用于生产环境，但在此示例中，它以清晰、简洁的方式说明了更改。
- en: Listing 11.2\. Configure code chunking—src/shared/sharedRoutes.jsx
  id: totrans-950
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 11.2\. 配置代码块分割—src/shared/sharedRoutes.jsx
- en: '[PRE76]'
  id: totrans-951
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '***1* Remove the old import statement for the cart component. I’ve commented
    here to demonstrate it gets removed, but you can delete it.**'
  id: totrans-952
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 删除对购物车组件的旧导入语句。我在这里添加了注释来演示它将被删除，但你也可以直接删除它。**'
- en: '***2* Use the getComponent prop.**'
  id: totrans-953
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 使用 getComponent 属性。**'
- en: '***3* Use async import. You pass the path to the cart component into it.**'
  id: totrans-954
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 使用异步导入。你将购物车组件的路径传递给它。**'
- en: '***4* Webpack reads these comments and uses them to determine how to handle
    the code chunk.**'
  id: totrans-955
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* Webpack 会读取这些注释并使用它们来确定如何处理代码块。**'
- en: '***5* Async import behaves like a Promise. Handle a success: take the loaded
    module and pass it to the React Router callback.**'
  id: totrans-956
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 异步导入的行为类似于 Promise。处理成功：获取加载的模块并将其传递给 React Router 回调。**'
- en: '***6* The component isn’t yet loaded when onChange is called. By manually calling
    onChange, the data will still be loaded.**'
  id: totrans-957
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 当调用 onChange 时，组件尚未加载。通过手动调用 onChange，数据仍然会被加载。**'
- en: '***7* Add error handling.**'
  id: totrans-958
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 添加错误处理。**'
- en: 'You’ll notice that you both replaced the default import with a dynamic load
    and moved that dynamic load into React Router’s `getComponent` property. The code
    will be lazy loaded (`webpackMode: lazy`); it won’t be loaded until the user navigates
    to this route. This is advantageous because it prevents unnecessary loading of
    code for features that the user hasn’t yet accessed.'
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
  zh: '你会注意到，你既用动态加载替换了默认导入，又将这个动态加载移动到了 React Router 的 `getComponent` 属性中。代码将会懒加载（`webpackMode:
    lazy`）；它不会在用户导航到这个路由之前加载。这有优势，因为它可以防止加载用户尚未访问的功能的代码。'
- en: Finally, it’s useful to name your webpack chunks. This is configurable in the
    webpack configuration file. The following listing shows you how to add this property
    to your webpack config file.
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，给你的 webpack 代码块命名是有用的。这可以在 webpack 配置文件中配置。以下列表展示了如何将此属性添加到你的 webpack 配置文件中。
- en: Listing 11.3\. Named webpack chunks—webpack.config.js
  id: totrans-961
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 11.3\. 命名 webpack 代码块—webpack.config.js
- en: '[PRE77]'
  id: totrans-962
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '***1* Add the chunkFilename option. Use [name] to indicate a dynamic naming
    of the compiled js file for each chunk.**'
  id: totrans-963
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 添加 chunkFilename 选项。使用 [name] 来指示为每个代码块动态命名编译后的 js 文件。**'
- en: In the next section, we’ll look at one way to improve React performance in situations
    where React’s base performance isn’t enough.
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨一种提高 React 性能的方法，这种方法适用于 React 的基本性能不足以满足需求的情况。
- en: 11.1.2\. Should component render
  id: totrans-965
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.1.2\. 组件是否应该渲染
- en: As your app grows, you’ll run into situations where your components are running
    through their render cycles unnecessarily (I’ve seen situations where re-renders
    get into the tens of seconds). If this is happening and causing a measurable impact
    on your application, use `shouldComponentRender` to limit the number of renders.
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你的应用增长，你可能会遇到组件不必要地运行其渲染周期的情况（我见过重渲染达到数十秒的情况）。如果这种情况发生并且对你的应用产生了可测量的影响，请使用`shouldComponentRender`来限制渲染次数。
- en: '|  |'
  id: totrans-967
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Performance measurement tools**'
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
  zh: '**性能测量工具**'
- en: Before making performance improvements, you should always profile your application.
    Record the performance metric you’re measuring in the current version of your
    app. Then make any performance updates. Finally, measure the same performance
    metric to confirm that your changes had a positive impact.
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行性能改进之前，你应该始终对你的应用进行性能分析。记录你在当前应用版本中测量的性能指标。然后进行任何性能更新。最后，再次测量相同的性能指标以确认你的更改产生了积极的影响。
- en: 'To get started profiling web apps, you should become an expert on the Chrome
    DevTools performance panels: [http://mng.bz/a9wf](http://mng.bz/a9wf).'
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始分析Web应用，你应该成为Chrome DevTools性能面板的专家：[http://mng.bz/a9wf](http://mng.bz/a9wf)。
- en: '|  |'
  id: totrans-971
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The best way to implement `shouldComponentRender` without causing yourself later
    pain and headaches is to make sure your properties are being created with immutable
    patterns. In this application, this is already being handled in the Redux reducers.
    By creating immutable objects, the object references change, and a shallow comparison
    becomes enough to check whether two objects are different from one another. [Listing
    11.4](kindle_split_023_split_001.xhtml#ch11ex04) shows you how to do this in the
    context of a Detail Page component. Add the code from the listing to detail.jsx.
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
  zh: 实现不引起自己未来痛苦和头痛的`shouldComponentRender`的最佳方式是确保你的属性是以不可变模式创建的。在这个应用中，这已经在Redux的reducer中得到了处理。通过创建不可变对象，对象的引用会改变，浅比较就足够用来检查两个对象是否不同。[列表11.4](kindle_split_023_split_001.xhtml#ch11ex04)展示了如何在Detail
    Page组件的上下文中实现这一点。将列表中的代码添加到detail.jsx中。
- en: '|  |'
  id: totrans-973
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Warning
  id: totrans-974
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 警告
- en: Using `shouldComponentRender` can send you down a rabbit hole of despair. Use
    it sparingly and use it wisely. (You can end up with complex, large functions
    that are calculating whether to render. That’s bad and should be avoided.)
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`shouldComponentRender`可能会让你陷入绝望的兔子洞。要谨慎使用，并明智地使用它。（你可能会得到复杂、庞大的函数，这些函数在计算是否渲染。这是不好的，应该避免。）
- en: '|  |'
  id: totrans-976
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Listing 11.4\. Block renders, `shouldComponentRender`—src/components/detail.jsx
  id: totrans-977
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表11.4\. 块渲染，`shouldComponentRender`—src/components/detail.jsx
- en: '[PRE78]'
  id: totrans-978
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '***1* Check each property to make sure it hasn’t changed.**'
  id: totrans-979
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 检查每个属性以确保它没有变化。**'
- en: '***2* Return false if nothing has changed; this prevents the component from
    rendering.**'
  id: totrans-980
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 如果没有任何变化，则返回false；这可以防止组件渲染。**'
- en: '***3* Return true if there have been changes; this allows the normal render
    to execute.**'
  id: totrans-981
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 如果有变化，则返回true；这允许正常的渲染执行。**'
- en: This will work for many situations but it’s not without gotchas. One problem
    is this implementation requires you to write many checks based on the implementation
    details of the properties. You could abstract the concept of this code—comparing
    each property on `this.props`/`nextProps`—into a function that can be reused for
    many components. The online article “Performance Optimisations for React Applications”
    by Alex Reardon ([http://mng.bz/QJk3](http://mng.bz/QJk3)) covers using `shouldComponentUpdate`
    with additional detail. It includes a sample implementation of an abstracted deep
    equals function that does only reference checks. Check out the code on GitHub
    ([http://mng.bz/q7yU](http://mng.bz/q7yU)).
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
  zh: 这将适用于许多情况，但它并非没有问题。一个问题是这个实现要求你根据属性的实现细节编写许多检查。你可以将此代码的概念——比较`this.props`/`nextProps`上的每个属性——抽象成一个可以被许多组件重用的函数。Alex
    Reardon的在线文章“React应用的性能优化”涵盖了使用`shouldComponentUpdate`的更多细节。它包括一个抽象的深度等于函数的示例实现，该函数只进行引用检查。查看GitHub上的代码([http://mng.bz/q7yU](http://mng.bz/q7yU))。
- en: Finally, if you need `shouldComponentUpdate` to only do a shallow comparison
    on both the `props` object and the `state` object, you can use React Pure Component.
    This is a class provided by React. You can find the docs at [https://reactjs.org/docs/react-api.html#react.purecomponent](https://reactjs.org/docs/react-api.html#react.purecomponent).
  id: totrans-983
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果你需要`shouldComponentUpdate`只对`props`对象和`state`对象进行浅比较，你可以使用React Pure Component。这是一个由React提供的类。你可以在[https://reactjs.org/docs/react-api.html#react.purecomponent](https://reactjs.org/docs/react-api.html#react.purecomponent)找到文档。
- en: 'Unfortunately, a deeper dive into React performance optimizations is outside
    the context of this book. Fortunately, many other great resources are available
    on this topic! Here are some that will take you deeper:'
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，更深入地探讨React性能优化超出了本书的范畴。幸运的是，关于这个主题有很多其他优秀的资源！以下是一些可以让你更深入了解的资源：
- en: '*React Perf Tools*—[https://facebook.github.io/react/docs/perf.html](https://facebook.github.io/react/docs/perf.html).
    Use these tools to profile your application. Don’t forget to run your app in production
    mode when you’re doing performance testing! (These are being deprecated for React
    16.)'
  id: totrans-985
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*React性能工具*—[https://facebook.github.io/react/docs/perf.html](https://facebook.github.io/react/docs/perf.html)。使用这些工具来分析你的应用程序。当你进行性能测试时，别忘了以生产模式运行你的应用程序！（这些工具在React
    16中已被弃用。）'
- en: '*React Performance Overview*—[http://mng.bz/l5J8](http://mng.bz/l5J8) and [http://mng.bz/eWHH](http://mng.bz/eWHH)
    provide good places to start with React performance.'
  id: totrans-986
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*React性能概述*—[http://mng.bz/l5J8](http://mng.bz/l5J8)和[http://mng.bz/eWHH](http://mng.bz/eWHH)是开始了解React性能的好地方。'
- en: '*More on* `shouldComponentRender`—[http://jamesknelson.com/should-i-use-shouldcomponentupdate/](http://jamesknelson.com/should-i-use-shouldcomponentupdate/)
    goes in depth on why you should avoid using `shouldComponentRender`.'
  id: totrans-987
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多关于`shouldComponentRender`的内容——[http://jamesknelson.com/should-i-use-shouldcomponentupdate/](http://jamesknelson.com/should-i-use-shouldcomponentupdate/)深入探讨了为什么你应该避免使用`shouldComponentRender`。
- en: In the next section, we’ll look at server-side performance improvements that
    can be used to have a positive impact on your Node.js application.
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨可以用于提高你的Node.js应用程序性能的服务器端性能改进。
- en: 11.2\. Server performance optimizations
  id: totrans-989
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2\. 服务器性能优化
- en: In an isomorphic app, your server’s performance is just as important as the
    browser performance. When we first started working with React at work, it greatly
    simplified building our pages for search bots. But we quickly realized that React’s
    server render was slower than we’d have liked. Creating a fully rendered string
    output for many components takes time and is a process-blocking task on the server.
    This limits the number of requests per second that your server is able to handle.
  id: totrans-990
  prefs: []
  type: TYPE_NORMAL
  zh: 在同构应用中，你服务器的性能和浏览器性能一样重要。当我们最初开始在工作中使用React时，它极大地简化了我们为搜索引擎构建页面。但我们很快意识到React的服务器渲染比我们希望的慢。为许多组件创建完整的渲染字符串输出需要时间，并且是服务器上的一个阻塞任务。这限制了服务器每秒能够处理请求数量。
- en: 'In the rest of this section, and in the caching section, I’ll discuss strategies
    you can use to improve your server performance times:'
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的剩余部分和缓存部分，我将讨论你可以使用的策略来提高你的服务器性能时间：
- en: Using streaming concepts to respond to requests sooner
  id: totrans-992
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用流概念来更快地响应请求
- en: Adding connection pooling to manage multiple HTTP requests from the server
  id: totrans-993
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加连接池来管理服务器上的多个HTTP请求
- en: The first thing you’ll add is the ability for your page response to be streamed
    to the browser. If you’re following along and want to switch to this section’s
    GitHub branch, check out chapter-11.2 (`git checkout chapter-11.2`).
  id: totrans-994
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先需要添加的是将页面响应流式传输到浏览器的能力。如果你正在跟随并想切换到本节的GitHub分支，请查看第11.2章（`git checkout chapter-11.2`）。
- en: 11.2.1\. Streaming React
  id: totrans-995
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.2.1\. 流式React
- en: If your main goal is to improve time to first byte and allow the DOM to start
    processing as soon as possible, streaming your rendered page response can be a
    good solution. Node.js streams are a way to represent large amounts of data and
    deliver it over time. Rather than wait for an entire HTML page to download, the
    page can be delivered in chunks over time (more info on streams at [http://mng.bz/s91m](http://mng.bz/s91m)).
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的主要目标是提高首次字节到达时间，并允许DOM尽快开始处理，那么流式传输渲染后的页面响应可以是一个好的解决方案。Node.js流是一种表示大量数据并在一段时间内交付数据的方式。而不是等待整个HTML页面下载完成，页面可以分块在一段时间内交付（关于流的更多信息请参阅[http://mng.bz/s91m](http://mng.bz/s91m)）。
- en: 'By turning the server response into a stream, you improve the speed at which
    the browser can begin downloading and displaying the HTML. [Listing 11.5](kindle_split_023_split_002.xhtml#ch11ex05)
    shows how to use the react-dom-stream library to render streams instead of strings.
    Add the code to renderView.jsx. You also need to run the following command before
    this code will work:'
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将服务器响应转换为流，你可以提高浏览器开始下载和显示HTML的速度。[列表 11.5](kindle_split_023_split_002.xhtml#ch11ex05)显示了如何使用react-dom-stream库来渲染流而不是字符串。将代码添加到renderView.jsx中。你还需要在运行以下命令之前：
- en: '[PRE79]'
  id: totrans-998
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: You can find more information about this package at [https://github.com/aickin/react-dom-stream](https://github.com/aickin/react-dom-stream).
    Note that it hasn’t been fully upgraded to work with the latest React, so you
    may not want to use it in production, but it illustrates the streaming concept
    well.
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://github.com/aickin/react-dom-stream](https://github.com/aickin/react-dom-stream)找到更多关于这个包的信息。请注意，它还没有完全升级以与最新的React一起使用，因此你可能不想在生产环境中使用它，但它很好地说明了流的概念。
- en: Listing 11.5\. Set up streaming library—src/middleware/renderView.jsx
  id: totrans-1000
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 11.5\. 设置流式库—src/middleware/renderView.jsx
- en: '[PRE80]'
  id: totrans-1001
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '***1* Instead of importing the React version of renderToString, use the streaming
    library’s version.**'
  id: totrans-1002
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 不要导入 renderToString 的 React 版本，而要使用流式库的版本。**'
- en: '***2* The initial render of the app components gets converted to the creation
    of a stream. Rename the variable for better context.**'
  id: totrans-1003
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 应用组件的初始渲染被转换为流的创建。为了更好的上下文，重命名变量。**'
- en: '***3* React DOM Stream supports nested streams in JSX. Now we pass the stream
    into HTML.jsx.**'
  id: totrans-1004
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* React DOM Stream 支持JSX中的嵌套流。现在我们将流传递到 HTML.jsx。**'
- en: '***4* Instead of responding to the request directly, the stream library pipes
    the render into the response.**'
  id: totrans-1005
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 不要直接响应请求，流库将渲染结果管道化到响应中。**'
- en: '***5* Add a listener for the end of the stream.**'
  id: totrans-1006
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 添加一个监听器以监听流的结束。**'
- en: '***6* Close the response.**'
  id: totrans-1007
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 关闭响应。**'
- en: 11.2.2\. Connection pooling
  id: totrans-1008
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.2.2\. 连接池
- en: In addition to using React, we also use GraphQL at work. This enables us to
    gather data from many microservices. More importantly, it also allows us to request
    the data we need for our views rather than use REST APIs with predetermined responses.
    Think of it as a front end for your back-end REST services. You can learn more
    about GraphQL at [http://graphql.org](http://graphql.org).
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用React，我们在工作中还使用GraphQL。这使我们能够从许多微服务中收集数据。更重要的是，它还允许我们请求我们视图所需的数据，而不是使用具有预定响应的REST
    API。把它想象成后端REST服务的客户端。你可以在[http://graphql.org](http://graphql.org)了解更多关于GraphQL的信息。
- en: This is a powerful setup, but GraphQL makes a lot of network calls. We ran into
    an issue of network calls that were timing out. The services we were talking to
    didn’t show any time-outs; they showed fast response times. After much investigation,
    the team figured out that we were making so many requests that the call stack
    was causing some of the requests to time out. The call stack became a block, and
    requests were timing out before they had a chance to receive any response.
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个强大的设置，但GraphQL会进行大量的网络调用。我们遇到了一些网络调用超时的问题。我们与之通信的服务没有显示任何超时；它们显示了快速的响应时间。经过大量的调查，团队发现我们发出的请求太多，导致调用栈导致一些请求超时。调用栈变成了一个瓶颈，请求在收到任何响应之前就已经超时了。
- en: This can also happen in your React isomorphic app. If a page of your app makes
    a lot of network calls for a specific view, you might run into this slow network
    request problem. One strategy to fix this is to enable connection pooling on your
    Node.js server.
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
  zh: 这也可能发生在你的React同构应用程序中。如果你的应用程序的一个页面为特定的视图进行了大量的网络调用，你可能会遇到这个缓慢的网络请求问题。解决这个问题的策略之一是在你的Node.js服务器上启用连接池。
- en: The solution to this problem in Node.js is to create a permanent connection
    pool to reduce the cost of opening connections. A *connection pool* guarantees
    that there are always available socket connections in your Node.js app. This saves
    time when making a request, because opening a socket takes time (for additional
    info, see the blog post at [www.madhur.co.in/blog/2016/09/05/nodejs-connection-pooling.html](http://www.madhur.co.in/blog/2016/09/05/nodejs-connection-pooling.html)).
    The following listing shows how to add this option to the server.
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
  zh: 在Node.js中解决这个问题的方法是创建一个永久的连接池以减少打开连接的成本。*连接池*确保你的Node.js应用程序中始终有可用的套接字连接。这可以在发出请求时节省时间，因为打开套接字需要时间（更多信息，请参阅[www.madhur.co.in/blog/2016/09/05/nodejs-connection-pooling.html](http://www.madhur.co.in/blog/2016/09/05/nodejs-connection-pooling.html)上的博客文章）。以下列表显示了如何将此选项添加到服务器中。
- en: Listing 11.6\. Enable connection pooling—src/app.es6
  id: totrans-1013
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表11.6\. 启用连接池—src/app.es6
- en: '[PRE81]'
  id: totrans-1014
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '***1* Import the http module.**'
  id: totrans-1015
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 导入http模块。**'
- en: '***2* Before the rest of the code on the server, setting the options for http.Agent.keepAlive:
    true tells the server to reuse connections. The other options can be adjusted
    to fit your use case.**'
  id: totrans-1016
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 在服务器上的其余代码之前，设置http.Agent.keepAlive: true的选项告诉服务器重用连接。其他选项可以根据您的用例进行调整。**'
- en: You could also use GraphQL, which will greatly reduce the number of network
    calls you make. But that’s a topic for another book.
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用GraphQL，这将大大减少您做出的网络调用次数。但这将是另一本书的主题。
- en: Node performance
  id: totrans-1018
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Node性能
- en: 'This isn’t a book about Node.js implementation and performance, but lots of
    good resources are available if you want to learn more about this topic. Here
    are some places to get started:'
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一本关于Node.js实现和性能的书籍，但如果您想了解更多关于这个主题的信息，有很多好的资源可用。以下是一些开始的地方：
- en: '*Tips from Nginx on optimizing Node.js apps*—[www.nginx.com/blog/5-performance-tips-for-node-js-applications/](http://www.nginx.com/blog/5-performance-tips-for-node-js-applications/)'
  id: totrans-1020
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Nginx关于优化Node.js应用的技巧*—[www.nginx.com/blog/5-performance-tips-for-node-js-applications/](http://www.nginx.com/blog/5-performance-tips-for-node-js-applications/)'
- en: '*Best practices for using Express in production*—[https://expressjs.com/en/advanced/best-practice-performance.html](https://expressjs.com/en/advanced/best-practice-performance.html)'
  id: totrans-1021
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Express在生产环境中的最佳实践*—[https://expressjs.com/en/advanced/best-practice-performance.html](https://expressjs.com/en/advanced/best-practice-performance.html)'
- en: '*Node profiling tools*—[https://nodejs.org/en/docs/guides/simple-profiling/](https://nodejs.org/en/docs/guides/simple-profiling/)'
  id: totrans-1022
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Node性能分析工具*—[https://nodejs.org/en/docs/guides/simple-profiling/](https://nodejs.org/en/docs/guides/simple-profiling/)'
- en: '*Netflix deep dive into flame profiling Node apps*—[https://medium.com/netflix-techblog/node-js-in-flames-ddd073803aa4](https://medium.com/netflix-techblog/node-js-in-flames-ddd073803aa4)'
  id: totrans-1023
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Netflix深入剖析火焰图分析Node应用*—[https://medium.com/netflix-techblog/node-js-in-flames-ddd073803aa4](https://medium.com/netflix-techblog/node-js-in-flames-ddd073803aa4)'
- en: 11.3\. Caching
  id: totrans-1024
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3\. 缓存
- en: Another powerful server performance tool is caching. I’ve employed caching in
    different forms, including edge caching, in-memory caching, and saving views in
    a Redis (a NoSQL database) persisted cache. Each of these strategies has trade-offs,
    so it’s important to understand what these are and then pick the right strategy
    for your use case. [Table 11.1](kindle_split_023_split_003.xhtml#ch11table01)
    lists caching options.
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个强大的服务器性能工具是缓存。我已经采用了不同形式的缓存，包括边缘缓存、内存缓存以及在Redis（一个NoSQL数据库）中持久化缓存中保存视图。每种策略都有其权衡之处，因此了解这些权衡并选择适合您用例的正确策略非常重要。[表11.1](kindle_split_023_split_003.xhtml#ch11table01)列出了缓存选项。
- en: Table 11.1\. Comparing caching options
  id: totrans-1026
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表11.1\. 比较缓存选项
- en: '|   | SEO | User sessions |'
  id: totrans-1027
  prefs: []
  type: TYPE_TB
  zh: '|   | SEO | 用户会话 |'
- en: '| --- | --- | --- |'
  id: totrans-1028
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| In-memory | ✓ | ✓ |'
  id: totrans-1029
  prefs: []
  type: TYPE_TB
  zh: '| 内存 | ✓ | ✓ |'
- en: '| Persisted storage | ✓ | (Higher overhead, but possible) |'
  id: totrans-1030
  prefs: []
  type: TYPE_TB
  zh: '| 持久化存储 | ✓ | (开销较高，但可行) |'
- en: '| Edge caching | ✓ |   |'
  id: totrans-1031
  prefs: []
  type: TYPE_TB
  zh: '| 边缘缓存 | ✓ |   |'
- en: '11.3.1\. Caching on the server: in-memory caching'
  id: totrans-1032
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.3.1\. 服务器端缓存：内存缓存
- en: The easiest (and most naïve) solution for caching involves saving components
    directly in memory. For simple apps, you can achieve this by using a basic LRU
    cache (size-limited) and stringifying your components after they’re rendered.
    [Figure 11.3](kindle_split_023_split_003.xhtml#ch11fig03) shows a timeline of
    using an in-memory cache. The first user to load a page gets a fully rendered
    (and slower) version of the page. This is also saved in the in-memory cache. All
    subsequent users get the cached version, until that page gets pushed out of the
    cache because the cache filled up.
  id: totrans-1033
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单（也是最天真）的缓存解决方案涉及直接在内存中保存组件。对于简单的应用程序，您可以通过使用基本的LRU缓存（大小限制）并在组件渲染后将其序列化来实现这一点。[图11.3](kindle_split_023_split_003.xhtml#ch11fig03)显示了使用内存缓存的时间线。第一个加载页面的用户会得到一个完全渲染（但较慢）的页面版本。这也被保存在内存缓存中。所有后续用户都会得到缓存的版本，直到该页面因缓存已满而被推出缓存。
- en: Figure 11.3\. In-memory caching allows some requests to benefit from faster
    response times.
  id: totrans-1034
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图11.3\. 内存缓存允许某些请求从更快的响应时间中受益。
- en: '![](Images/11fig03_alt.jpg)'
  id: totrans-1035
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/11fig03_alt.jpg)'
- en: The following listing shows how to add a simple caching module (abstracting
    this code will make it easier to update caching strategies to match your future
    needs). You should add this code to the new cache.es6 file in the shared directory.
  id: totrans-1036
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表显示了如何添加一个简单的缓存模块（抽象此代码将使更新缓存策略以匹配您的未来需求变得更容易）。您应该将此代码添加到共享目录中的新cache.es6文件中。
- en: Listing 11.7\. Add an LRU in memory cache—src/shared/cache.es6
  id: totrans-1037
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表11.7\. 添加内存LRU缓存—src/shared/cache.es6
- en: '[PRE82]'
  id: totrans-1038
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '***1* Import the lru cache.**'
  id: totrans-1039
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 导入lru缓存。**'
- en: '***2* Create the lru cache.**'
  id: totrans-1040
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 创建lru缓存。**'
- en: '***3* maxAge sets a time-based expiration for values stored in the cache.**'
  id: totrans-1041
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* maxAge为存储在缓存中的值设置基于时间的过期时间。**'
- en: '***4* max is the total allowed length of all items in the cache.**'
  id: totrans-1042
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* max是缓存中所有项目的总允许长度。**'
- en: '***5* length is the individual max allowed length for each value added.**'
  id: totrans-1043
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* length是每个添加的值的最大允许长度。**'
- en: '***6* This is a public set method that sets the key/value pair on the cache.**'
  id: totrans-1044
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 这是一个公共的设置方法，用于在缓存中设置键/值对。**'
- en: '***7* This is a public get method that retrieves a value based on a key from
    the cache.**'
  id: totrans-1045
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 这是一个公共的获取方法，根据键从缓存中检索值。**'
- en: '[Listing 11.8](kindle_split_023_split_003.xhtml#ch11ex08) shows how to take
    advantage of the caching module in renderView.jsx. Add its code to the module.
    Note that I recommend using either the caching logic or the streaming logic, but
    not both at the same time. If you want to cache and stream, you need a different
    streaming implementation than the one shown in this chapter.'
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 11.8](kindle_split_023_split_003.xhtml#ch11ex08)展示了如何在renderView.jsx中利用缓存模块。将它的代码添加到模块中。请注意，我建议使用缓存逻辑或流逻辑，但不要同时使用两者。如果你想缓存和流，你需要一个不同于本章中展示的流实现。'
- en: Listing 11.8\. Save and fetch cached pages—src/middleware/renderView.jsx
  id: totrans-1047
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 11.8\. 保存和获取缓存的页面—src/middleware/renderView.jsx
- en: '[PRE83]'
  id: totrans-1048
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '***1* Try to retrieve the value from the cache by using the cache module from
    [listing 11.7](kindle_split_023_split_003.xhtml#ch11ex07).**'
  id: totrans-1049
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 尝试使用[列表 11.7](kindle_split_023_split_003.xhtml#ch11ex07)中的缓存模块从缓存中检索值。**'
- en: '***2* If the value exists, use it to respond to the request.**'
  id: totrans-1050
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 如果值存在，则使用它来响应请求。**'
- en: '***3* If a full page render is required, save the rendered page before responding
    to the request.**'
  id: totrans-1051
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 如果需要完整页面的渲染，在响应请求之前保存已渲染的页面。**'
- en: 'This strategy will work, but it has some problems:'
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
  zh: 这种策略将有效，但它有一些问题：
- en: This solution is simple, but what happens when the use cases get more complex?
    What happens as you start to add users? Or multiple languages? Or you have tens
    of thousands of pages? This methodology doesn’t scale well to these use cases.
  id: totrans-1053
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个解决方案很简单，但当用例变得更加复杂时会发生什么？当你开始添加用户？或者多语言？或者你有成千上万的页面？这种方法不适用于这些用例。
- en: Writing to memory is a blocking task in Node.js, which means that if you’re
    trying to optimize for performance by using a cache, you’re trading one problem
    for another.
  id: totrans-1054
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Node.js中写入内存是一个阻塞任务，这意味着如果你试图通过使用缓存来优化性能，你是在用一个问题换取另一个问题。
- en: Finally, if you’re using a distributed scaling strategy to run your servers
    (which is common these days), the cache applies to only a single box or container
    (if using Docker). In this case, your server instances can’t share a common cache.
  id: totrans-1055
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，如果你正在使用分布式扩展策略来运行你的服务器（这在当今很常见），缓存仅适用于单个盒子或容器（如果使用Docker）。在这种情况下，你的服务器实例无法共享一个公共缓存。
- en: Next, we’ll look at another strategy, caching with Redis, which will allow the
    caching to be done asynchronously and nonblocking. We’ll also look at using a
    smarter caching implementation to cache individual components, which scales better
    for more-complex applications.
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨另一种策略，即使用Redis进行缓存，这将允许异步和非阻塞地进行缓存。我们还将探讨使用更智能的缓存实现来缓存单个组件，这对于更复杂的应用程序来说具有更好的可扩展性。
- en: '11.3.2\. Caching on the server: persisted storage'
  id: totrans-1057
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.3.2\. 服务器端缓存：持久化存储
- en: The first isomorphic React app I worked on was written before Redux and React
    Router were stable community best-choice libraries, so we home-rolled a lot of
    the code. Combine this decision with React being slow on the server, and we needed
    a solution that would speed up server renders.
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
  zh: 我参与开发的第一个同构React应用是在Redux和React Router成为稳定的社区首选库之前编写的，因此我们编写了大量的代码。结合React在服务器上的运行速度较慢，我们需要一个能够加快服务器渲染速度的解决方案。
- en: What we implemented was string storage of full pages in Redis. But storing full
    pages in Redis has significant trade-offs for larger sites. We had the potential
    for millions of entries to end up stored in Redis. Because full stringified HTML
    pages add up pretty fast, we were using quite a bit of space.
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现的是在Redis中存储完整页面的字符串存储。但是，对于较大的网站来说，在Redis中存储完整页面有显著的权衡。我们有可能有数百万条条目最终存储在Redis中。因为完整的字符串化HTML页面很快就会累积起来，所以我们使用了相当多的空间。
- en: 'Thankfully, the community has come up with improvements on this idea since
    then. Walmart Labs put out a library called electrode-react-ssr-caching that’s
    easy to use to cache your server-side renders. This library is powerful for a
    couple of reasons:'
  id: totrans-1060
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，社区自那时以来已经对这一想法进行了改进。Walmart Labs 发布了一个名为 electrode-react-ssr-caching 的库，该库易于使用，可以缓存您的服务器端渲染。这个库有几个强大的原因：
- en: It comes with a profiler that will tell you which components are most expensive
    on the server. That allows you to cache only the components you need to.
  id: totrans-1061
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它附带了一个分析器，可以告诉您哪些组件在服务器上最昂贵。这允许您只缓存您需要的组件。
- en: It provides a way to template components so you can cache the rendered components
    and insert the properties later.
  id: totrans-1062
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提供了一种模板组件的方法，这样您就可以缓存已渲染的组件，并在以后插入属性。
- en: In the long run, because of the number of pages we serve and the percentage
    of them that are served with 100% public-facing content, we ended up moving to
    an edge-caching strategy. But your use case may benefit from the Walmart Labs
    approach.
  id: totrans-1063
  prefs: []
  type: TYPE_NORMAL
  zh: 从长远来看，由于我们服务的页面数量以及其中以 100% 公开内容提供的页面百分比，我们最终转向了边缘缓存策略。但您的用例可能从 Walmart Labs
    方法中受益。
- en: 11.3.3\. CDN/edge strategies
  id: totrans-1064
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.3.3\. CDN/边缘策略
- en: Edge caching is the solution we currently use for our isomorphic React app at
    work. This is due to some business logic needing to expire content on demand (when
    things change at other points in the system, as in a CMS tool). Modern CDNs such
    as Fastly provide this capability out of the box and make it much easier to manage
    TTLs (time to live) and to force-expire web pages. [Figure 11.4](kindle_split_023_split_003.xhtml#ch11fig04)
    illustrates how this works.
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
  zh: Edge 缓存是我们目前在工作中的同构 React 应用程序中使用的解决方案。这是由于一些业务逻辑需要按需使内容过期（当系统其他点的某些内容发生变化时，如在
    CMS 工具中）。现代 CDN，如 Fastly，提供这种功能，并使管理 TTL（生存时间）和强制使网页过期的操作变得容易得多。[图 11.4](kindle_split_023_split_003.xhtml#ch11fig04)
    说明了这是如何工作的。
- en: Figure 11.4\. Adding an edge server moves the caching in front of the server.
  id: totrans-1066
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 11.4\. 添加边缘服务器将缓存移动到服务器前面。
- en: '![](Images/11fig04_alt.jpg)'
  id: totrans-1067
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/11fig04_alt.jpg)'
- en: Showing you how to implement this is beyond the scope of this book. If you have
    public-facing content that drives SEO (e-commerce, video sites, blogs, and so
    forth), you’ll definitely want a CDN in your stack.
  id: totrans-1068
  prefs: []
  type: TYPE_NORMAL
  zh: 向您展示如何实现这一点超出了本书的范围。如果您有面向公众的内容，这些内容可以推动 SEO（电子商务、视频网站、博客等），那么您在技术栈中肯定需要一个 CDN。
- en: One caveat with this approach is that it complicates user session management.
    The next section explores user sessions and covers the trade-offs with various
    caching strategies.
  id: totrans-1069
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的一个缺点是它使用户会话管理变得复杂。下一节将探讨用户会话，并涵盖各种缓存策略的权衡。
- en: 11.4\. User session management
  id: totrans-1070
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.4\. 用户会话管理
- en: Modern web applications use cookies in the browser almost without exception.
    Even if your main product isn’t directly using cookies, any ads, tracking, or
    other third-party tools that you use on your site will take advantage of cookies.
    Cookies let the web app know that the same person has come back over time. [Figure
    11.5](kindle_split_023_split_004.xhtml#ch11fig05) illustrates how this works.
  id: totrans-1071
  prefs: []
  type: TYPE_NORMAL
  zh: 现代网络应用程序几乎无一例外地在浏览器中使用 cookie。即使您的主要产品没有直接使用 cookie，您在网站上使用的任何广告、跟踪或其他第三方工具都将利用
    cookie。Cookies 让网络应用程序知道同一个人在一段时间后回来了。[图 11.5](kindle_split_023_split_004.xhtml#ch11fig05)
    说明了这是如何工作的。
- en: Figure 11.5\. Repeat visits by the same user on the server. Saving cookies lets
    you store information about the user that can be retrieved during future sessions.
  id: totrans-1072
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 11.5\. 同一用户在服务器上的重复访问。保存 cookie 允许您存储有关用户的信息，这些信息可以在未来的会话中检索。
- en: '![](Images/11fig05_alt.jpg)'
  id: totrans-1073
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/11fig05_alt.jpg)'
- en: '[Listing 11.9](kindle_split_023_split_004.xhtml#ch11ex09) shows an example
    module that handles both the browser and server cookie parsing for you. It uses
    Universal Cookie to help manage the cookies in both environments: [www.npmjs.com/package/universal-cookie](http://www.npmjs.com/package/universal-cookie).
    You need to install this library for the code to work:'
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 11.9](kindle_split_023_split_004.xhtml#ch11ex09) 展示了一个示例模块，该模块为您处理浏览器和服务器端
    cookie 解析。它使用通用 Cookie 来帮助管理两个环境中的 cookie：[www.npmjs.com/package/universal-cookie](http://www.npmjs.com/package/universal-cookie)。您需要安装这个库才能使代码正常工作：'
- en: '[PRE84]'
  id: totrans-1075
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Add the code in this listing to a new module src/shared/cookies.es6.
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
  zh: 将此列表中的代码添加到新的模块 src/shared/cookies.es6 中。
- en: Listing 11.9\. Using isomorphic cookie module—src/shared/cookies.es6
  id: totrans-1077
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 11.9\. 使用同构 cookie 模块—src/shared/cookies.es6
- en: '[PRE85]'
  id: totrans-1078
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '***1* Import the universal cookie library, which handles the differences between
    accessing browser and server cookies for you.**'
  id: totrans-1079
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 导入通用 cookie 库，该库为您处理访问浏览器和服务器 cookie 之间的差异。**'
- en: '***2* Check the environment to determine whether reqHeaders are needed.**'
  id: totrans-1080
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 检查环境以确定是否需要reqHeaders。**'
- en: '***3* If the headers have cookies, pass this into the cookie constructor.**'
  id: totrans-1081
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 如果头信息中有cookie，将其传递给cookie构造函数。**'
- en: '***4* In the getter and setter functions, initialize the cookie object, passing
    in reqHeaders so it works on the server.**'
  id: totrans-1082
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 在getter和setter函数中，初始化cookie对象，传递reqHeaders以便在服务器上工作。**'
- en: '***5* Return the result of the cookie lookup.**'
  id: totrans-1083
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 返回cookie查找的结果。**'
- en: '***6* Return the result of setting the cookie. In addition to a name and value,
    you can pass in all standard cookie options. In most cases you’ll call set from
    the browser.**'
  id: totrans-1084
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 返回设置cookie的结果。除了名称和值之外，您还可以传递所有标准cookie选项。在大多数情况下，您将从浏览器中调用set。**'
- en: Now that you’ve added a way to get and set cookies in both environments, you
    need to be able to store that information on the app state so you can access it
    in a consistent way in your application.
  id: totrans-1085
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经为两种环境都添加了获取和设置cookie的方法，您需要能够将此信息存储在应用状态中，以便您可以在应用程序中以一致的方式访问它。
- en: 11.4.1\. Accessing cookies universally
  id: totrans-1086
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.4.1. 全局访问cookie
- en: By fetching cookies with an action, you can standardize the way the app interacts
    with cookies. The following listing shows how to add a `storeUserId` action to
    fetch and store the user ID. Add this code to the app-action-creators file.
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用操作获取cookie，您可以标准化应用程序与cookie交互的方式。以下列表显示了如何添加一个`storeUserId`操作来获取和存储用户ID。将此代码添加到app-action-creators文件中。
- en: Listing 11.10\. Accessing cookies on the server—src/shared/app-action-creators.es6
  id: totrans-1088
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表11.10。在服务器上访问cookie—src/shared/app-action-creators.es6
- en: '[PRE86]'
  id: totrans-1089
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '***1* Import the cookie module.**'
  id: totrans-1090
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 导入cookie模块。**'
- en: '***2* Add a type for the new action.**'
  id: totrans-1091
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 为新操作添加一个类型。**'
- en: '***3* Add the action, which takes in requestHeaders so that it works on the
    server.**'
  id: totrans-1092
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 添加操作，它接受requestHeaders以便在服务器上工作。**'
- en: '***4* Pass the cookie name and requestHeaders to the cookie module.**'
  id: totrans-1093
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 将cookie名称和requestHeaders传递给cookie模块。**'
- en: '***5* Put the userId value on the action.**'
  id: totrans-1094
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 在操作上放置userId值。**'
- en: Now you have access to the user ID in your application! It’ll be fetched on
    the server and can be updated later in the browser as needed. You can apply this
    concept to any and all user session information. Managing user sessions as a whole
    is beyond the scope of this chapter.
  id: totrans-1095
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以在应用程序中访问用户ID了！它将在服务器上获取，并在需要时可以在浏览器中更新。您可以将此概念应用于任何用户会话信息。整体管理用户会话超出了本章的范围。
- en: 11.4.2\. Edge caching and users
  id: totrans-1096
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.4.2. 边缘缓存和用户
- en: When I first started building isomorphic applications, user management seemed
    simple. You used cookies to track user sessions in the browser as you would in
    a single-page application. Adding in the server complicates this, but you can
    read the cookies on the server. As you add in caching strategies, this becomes
    less straightforward.
  id: totrans-1097
  prefs: []
  type: TYPE_NORMAL
  zh: 当我开始构建同构应用程序时，用户管理看起来很简单。您使用cookie在浏览器中跟踪用户会话，就像在单页应用程序中一样。添加服务器使事情变得复杂，但您可以在服务器上读取cookie。随着您添加缓存策略，这变得不那么直接。
- en: Both the in-memory and persisted storage caching strategies work better with
    user sessions, as each user request still goes to the server, allowing the user’s
    information to be gathered. You can add the user’s identifying information into
    your cache key.
  id: totrans-1098
  prefs: []
  type: TYPE_NORMAL
  zh: 内存和持久化存储缓存策略与用户会话配合得更好，因为每个用户请求仍然会发送到服务器，允许收集用户信息。您可以将用户的标识信息添加到您的缓存键中。
- en: But edge caching doesn’t work as well. That’s because for each unique user,
    you must keep a unique copy of each page that has user-specific data on it. If
    you don’t, you could end up showing user 1’s information to user 2\. That would
    be bad! [Figure 11.6](kindle_split_023_split_004.xhtml#ch11fig06) illustrates
    this concept.
  id: totrans-1099
  prefs: []
  type: TYPE_NORMAL
  zh: 但边缘缓存的效果并不好。这是因为对于每个独特的用户，您必须保留每个包含特定用户数据的页面的唯一副本。如果您不这样做，您可能会向用户2展示用户1的信息。这会很糟糕！[图11.6](kindle_split_023_split_004.xhtml#ch11fig06)说明了这个概念。
- en: Figure 11.6\. When the edge has to cache pages per user, the benefit of overlapping
    requests is lost.
  id: totrans-1100
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图11.6。当边缘需要为每个用户缓存页面时，重叠请求的好处就消失了。
- en: '![](Images/11fig06_alt.jpg)'
  id: totrans-1101
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/11fig06_alt.jpg)'
- en: 'If you need to use edge caching and you have user data, you can employ one
    or more of the following strategies (depending on your content type and your traffic
    patterns):'
  id: totrans-1102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要使用边缘缓存并且有用户数据，您可以根据您的内容类型和流量模式采用以下策略之一（取决于您的应用程序类型和流量模式）：
- en: Create pages that have either user content or general consumption content (public).
    Then cache only the pages that are public on your edge servers.
  id: totrans-1103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建具有用户内容或通用消费内容（公共）的页面。然后仅在您的边缘服务器上缓存公共页面。
- en: Save a cookie that tells the edge server whether the user is in an active user
    session. Use this information to determine whether to serve a cached page or send
    the request to the server (pass through).
  id: totrans-1104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保存一个cookie，告知边缘服务器用户是否处于活跃会话中。使用此信息来决定是否提供缓存页面或将请求发送到服务器（透传）。
- en: Serve pages with placeholder content (solid shapes that show where content will
    load) and then decide what content to load in the browser.
  id: totrans-1105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供带有占位符内容（显示内容加载位置的实心形状）的页面，然后决定在浏览器中加载什么内容。
- en: Summary
  id: totrans-1106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter covered several topics that will make your production isomorphic
    app run better, including performance and caching. You also learned about the
    complexities of adding certain types of caching to an isomorphic app that deals
    with user sessions.
  id: totrans-1107
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了几个将使您的同构应用在生产环境中运行得更好的主题，包括性能和缓存。您还了解了向处理用户会话的同构应用添加某些类型缓存的复杂性。
- en: Use webpack chunking to improve browser performance.
  id: totrans-1108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用webpack分块来提高浏览器性能。
- en: Optimize render cycles with `shouldComponentRender`.
  id: totrans-1109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`shouldComponentRender`优化渲染周期。
- en: Improve the server’s performance with streaming and connection pooling.
  id: totrans-1110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过流和连接池来提高服务器的性能。
- en: Apply one of three caching strategies (in-memory, persisted, or edge) to improve
    render times on the server.
  id: totrans-1111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用三种缓存策略之一（内存、持久或边缘）以提高服务器上的渲染时间。
- en: Manage user sessions via cookies on the browser and the server.
  id: totrans-1112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过浏览器和服务器上的cookie管理用户会话。
- en: Understand the effects of caching strategies on user session management.
  id: totrans-1113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解缓存策略对用户会话管理的影响。
