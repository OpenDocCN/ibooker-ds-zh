- en: 3 Testing techniques
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3 测试技术
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Organizing your tests comprehensively
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全面组织你的测试
- en: Writing assertions that are flexible and robust
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写灵活且健壮的断言
- en: Isolating and instrumenting parts of your code for tests
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为测试隔离和配置代码的部分
- en: Defining strategies for choosing what to test and what not to
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义选择测试和不测试的策略
- en: Learning what code coverage is and how to measure it
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习代码覆盖率是什么以及如何衡量它
- en: 'Well-written tests have two main qualities: they break only when the application
    misbehaves, and they tell you precisely what’s wrong. In this chapter, we will
    focus on techniques that help you achieve these two goals.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 编写良好的测试有两个主要特点：它们只在应用程序行为异常时才会失败，并且它们会精确地告诉你出了什么问题。在本章中，我们将关注帮助你实现这两个目标的技巧。
- en: If you’ve written a test for the `addToCart` function, for example, you don’t
    want it to break if that function is still working. If the test does break, it
    will generate extra costs because you will have to spend time updating it. Ideally,
    your tests should be sensitive enough to catch as many bugs as possible but sufficiently
    robust so that they fail only when necessary.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你为`addToCart`函数编写了测试，你不希望该函数仍然正常工作时测试失败。如果测试确实失败了，它将产生额外的成本，因为你将不得不花费时间更新它。理想情况下，你的测试应该足够敏感，以捕捉尽可能多的错误，但足够健壮，只有在必要时才失败。
- en: Considering that your tests for the `addToCart` function broke for a good reason,
    they still wouldn’t be particularly helpful if their feedback was undecipherable
    or if 10 other unrelated tests failed when they shouldn’t. A carefully architected
    test suite provides you with high-quality feedback to fix problems as quickly
    as possible.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到你的`addToCart`函数的测试因为一个很好的原因而失败了，但如果它们的反馈无法理解，或者当它们不应该失败时，10个其他无关的测试失败了，那么这些测试仍然不会特别有帮助。一个精心设计的测试套件会为你提供高质量的反馈，以便尽可能快地解决问题。
- en: In this chapter, to achieve high-quality feedback and robust yet sensitive tests,
    I will focus on how to organize tests, write assertions, isolate code, and choose
    *what* to test and *how* to test it.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，为了实现高质量的反馈和健壮且敏感的测试，我将重点关注如何组织测试、编写断言、隔离代码以及选择测试的内容和方式。
- en: Learning how to organize your tests comprehensively will result in better feedback
    and less duplication. It will make tests easier to read, write, and update. Well-organized
    tests are the very beginning of highly effective testing practices.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 学习如何全面组织你的测试将导致更好的反馈和更少的重复。这将使测试更容易阅读、编写和更新。组织良好的测试是高效测试实践的开始。
- en: Extending Jest’s assertions, understanding their semantics, and learning how
    to choose the most accurate assertions for each particular case will help you
    get better error messages and make your tests more robust without depriving them
    of sensitivity to bugs. Isolating your code will help you write tests quicker
    and reduce the size of the unit under test, making it easier to determine what
    the root cause of a bug is. Sometimes, it might even be impossible to test specific
    parts of your code without using isolation techniques.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展Jest的断言，理解它们的语义，并学习如何为每个特定情况选择最准确的断言，这将帮助你获得更好的错误信息，并使你的测试更加健壮，同时不失对错误的敏感性。隔离你的代码将帮助你更快地编写测试，并减少待测试单元的大小，使确定错误的根本原因变得更加容易。有时，甚至可能无法使用隔离技术来测试代码的特定部分。
- en: But none of these disciplines is valuable if you can’t determine what you *will*
    test and, most importantly, what you *won’t*, which is what I will cover at the
    end of this chapter. You will learn how to use these techniques to reduce the
    number of tests you have to write without diminishing your quality threshold,
    therefore decreasing costs.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你无法确定你将测试什么，最重要的是你不会测试什么，那么这些学科都没有价值，这是我在本章末尾要涵盖的内容。你将学习如何使用这些技术来减少你必须编写的测试数量，而不会降低你的质量标准，从而降低成本。
- en: As there’s no one-size-fits-all approach to software testing, I will explain
    the trade-offs involved in each kind of situation and focus on empowering you
    to make the optimal decisions on each case. This outcome-focused approach will
    help you find a better balance between tests that are sensitive and provide useful
    feedback, but that won’t increase your software’s maintenance burden.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 由于没有一种适合所有情况的软件测试方法，我将解释每种情况下涉及的权衡，并专注于让你在每个案例中做出最佳决策。这种以结果为导向的方法将帮助你找到在敏感性和提供有用反馈的测试之间，以及不会增加软件维护负担的测试之间的更好平衡。
- en: Additionally, in the last section of this chapter, you will learn about code
    coverage. In it, I will explain how to understand what pieces of code your tests
    cover and, most importantly, which they do *not*. Furthermore, you will understand
    how to act on code coverage reports and why coverage measurements can be misleading
    sometimes.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在本章的最后部分，你将了解代码覆盖率。在其中，我将解释如何理解你的测试覆盖了哪些代码片段，以及最重要的是，哪些代码片段没有被覆盖。此外，你还将了解如何对代码覆盖率报告采取行动，以及为什么覆盖率测量有时可能会误导。
- en: Improving the way you write your tests will save you development time and create
    more reliable guarantees. It will help you deliver more software, faster, and
    more confidently.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 改进你的测试编写方式将节省你的开发时间并创建更可靠的保证。这将帮助你更快、更自信地交付更多软件。
- en: 3.1 Organizing test suites
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.1 组织测试套件
- en: In Louis’s bakery, every assistant and pastry chef can easily find any ingredient
    at any time. Each kind of ingredient has its own separate shelf, which, in turn,
    has its own special place in the bakery, depending on when that ingredient is
    more commonly used in the baking process. There’s a clear logic to how items are
    organized. Flour, for, example, is kept right next to the shelf that has eggs,
    close to the countertop where the baker turns these ingredients into a silky-smooth
    batter.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在路易斯的面包店，每个助手和糕点师都可以在任何时候轻松找到任何原料。每种原料都有自己的单独货架，而货架在面包店中的位置也因原料在烘焙过程中的常用程度而异。物品的排列有明确的逻辑。例如，面粉就放在鸡蛋货架旁边，靠近面包师将这些原料变成丝滑顺滑面糊的操作台。
- en: This systematic arrangement makes it easier for the bakery’s employees to work
    in parallel and to find and use whatever items they need. Because ingredients
    of the same kind are all kept together, it’s also easy to know when to order more.
    Louis’s bakery doesn’t let any of them rot or run out of stock.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这种系统性的安排使得面包店的员工更容易并行工作，并找到和使用他们需要的任何物品。因为同种类的原料都放在一起，也容易知道何时订购更多。路易斯的面包店不会让任何原料腐烂或缺货。
- en: Well-organized tests have the same effect on the making of software as an organized
    kitchen has on the making of cakes. Organized tests facilitate collaboration by
    enabling developers to work in parallel with as few conflicts as possible. When
    developers put tests together cohesively, they decrease the application’s overall
    maintenance burden. They make software easy to maintain because they reduce repetition
    while increasing readability. The first step in organizing your tests is to decide
    what criteria you will use to separate them.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 有序的测试对软件制作的影响与有序的厨房对蛋糕制作的影响相同。有序的测试通过允许开发者尽可能少地发生冲突来并行工作，从而促进协作。当开发者将测试紧密地放在一起时，他们减少了应用程序的整体维护负担。它们使软件易于维护，因为它们减少了重复，同时增加了可读性。组织你的测试的第一步是决定你将使用什么标准来区分它们。
- en: 'Let’s consider that you’ve split the code for placing and tracking orders into
    two separate modules: `cartController` and `orderController`, shown in figure
    3.1.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑你已经将下单和跟踪订单的代码拆分为两个独立的模块：`cartController`和`orderController`，如图3.1所示。
- en: '![](../Images/CH03_F01_DaCosta.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH03_F01_DaCosta.png)'
- en: Figure 3.1 The module for placing orders and the module for tracking orders
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 下单模块和订单跟踪模块
- en: Even though these modules integrate, they have different functionalities, and,
    therefore, their tests should be written in separate files. Separating tests for
    `cartController` and `orderController` into different files is already a great
    start, but separating the functions within these modules is equally valuable.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这些模块相互集成，但它们具有不同的功能，因此它们的测试应该分别编写。将`cartController`和`orderController`的测试分别写入不同的文件已经是一个很好的开始，但将这些模块内的功能分开同样有价值。
- en: To create different groups of tests within a file, you can nest them within
    a `describe` block. For the `cartController` module, for example, your test file
    could look as follows.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 要在文件内创建不同的测试组，你可以将它们嵌套在一个`describe`块中。例如，对于`cartController`模块，你的测试文件可能看起来如下。
- en: Listing 3.1 cartController.test.js
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.1 cartController.test.js
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ Groups different tests into a block called addItemToCart
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将不同的测试分组到一个名为addItemToCart的块中
- en: ❷ Groups different tests into a block called removeFromCart
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 将不同的测试分组到一个名为removeFromCart的块中
- en: You can also use Jest’s `describe` blocks to keep helper functions within the
    scope of a single group of tests. If you had, for example, a utility function
    to add items to the inventory, instead of adding it to the file’s entire scope,
    you could place it within the `describe` block that needs it, as shown next and
    illustrated by figure 3.2.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用 Jest 的 `describe` 块来将辅助函数限制在单个测试组的范围内。例如，如果你有一个用于向库存中添加项目的实用函数，而不是将其添加到文件的整个作用域中，你可以将其放置在需要它的
    `describe` 块中，如下所示，并如图 3.2 所示。
- en: Listing 3.2 cartController.test.js
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.2 cartController.test.js
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ This function is available only within the describe block’s callback.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 此函数仅在 `describe` 块的回调函数中可用。
- en: '![](../Images/CH03_F02_DaCosta.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH03_F02_DaCosta.png)'
- en: Figure 3.2 The grouping for `addIteToCart`’s tests and its helper function
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2 `addIteToCart` 测试及其辅助函数的分组
- en: Nesting utility functions within `describe` blocks helps to indicate which tests
    need them. If `insertInventoryItem` is within the `describe` block for the `addItemToCart`
    function, you can be sure that it’s necessary only for that group of tests. When
    you organize tests this way, they become easier to understand and quicker to change
    because you know where to look for the functions and variables they use.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `describe` 块内嵌套实用函数有助于指示哪些测试需要它们。如果 `insertInventoryItem` 在 `addItemToCart`
    函数的 `describe` 块内，你可以确信它仅对该测试组是必要的。当你以这种方式组织测试时，由于你知道在哪里查找它们使用的函数和变量，因此测试变得更容易理解且更易于更改。
- en: These `describe` blocks also change the scope of hooks. Any `beforeAll`, `afterAll`,
    `beforeEach`, and `afterEach` hooks become relative to the `describe` block in
    which they’re located, as in the example in figure 3.3\. For example, if you want
    to apply a specific setup routine to a few tests in a file, but not to all of
    them, you can group those tests and write your `beforeEach` hook within the `describe`
    block for those tests as follows.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这些 `describe` 块也会改变钩子的作用域。任何 `beforeAll`、`afterAll`、`beforeEach` 和 `afterEach`
    钩子都相对于它们所在的 `describe` 块，如图 3.3 中的示例所示。例如，如果你想将特定的设置程序应用于文件中的几个测试，而不是所有测试，你可以将这些测试分组，并在这些测试的
    `describe` 块中编写你的 `beforeEach` 钩子，如下所示。
- en: Listing 3.3 cartController.test.js
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.3 cartController.test.js
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ Runs once before each test in the addItemToCart describe block
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在 `addItemToCart` 描述块中的每个测试之前运行一次
- en: '![](../Images/CH03_F03_DaCosta.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH03_F03_DaCosta.png)'
- en: Figure 3.3 How nesting determines the tests to which a hook will be applied
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3 嵌套如何确定钩子将应用于哪些测试
- en: NOTE In the example above, Jest will wait for the hook with `insertInventoryItem`
    to resolve before proceeding with the tests.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在上面的示例中，Jest 将等待 `insertInventoryItem` 钩子解决，然后才会继续进行测试。
- en: Just like when you have asynchronous tests, asynchronous hooks will run to completion
    before Jest proceeds. If a hook returns a `promise` or takes `done` as an argument,
    Jest will wait for either the promise to resolve or for `done` to be called before
    running any of the file’s other hooks or tests.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在异步测试中一样，异步钩子在 Jest 继续执行之前会运行到完成。如果一个钩子返回一个 `promise` 或接受 `done` 作为参数，Jest
    将等待 promise 解决或 `done` 被调用，然后才会运行文件中的其他钩子或测试。
- en: The same applies to every hook. If you use a `beforeAll` hook, for example,
    it will run once before all the tests *within* the `describe` block it’s placed,
    as shown next and illustrated by figure 3.4.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这同样适用于每个钩子。例如，如果你使用了一个 `beforeAll` 钩子，它将在放置在 `describe` 块内的所有测试之前运行一次，如下所示，并如图
    3.4 所示。
- en: Listing 3.4 cartController.test.js
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.4 cartController.test.js
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ Runs before each test in the addItemToCart describe block
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在 `addItemToCart` 描述块中的每个测试之前运行
- en: ❷ Runs once before all tests in the checkout describe block
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在 `checkout` 描述块中的所有测试之前运行一次
- en: '![](../Images/CH03_F04_DaCosta.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH03_F04_DaCosta.png)'
- en: Figure 3.4 How different kinds of hooks apply to different groups of tests
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4 不同类型的钩子如何应用于不同的测试组
- en: By default, hooks that are outside of any `describe` blocks apply to the whole
    scope of a test file, as shown next.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，位于任何 `describe` 块之外的钩子适用于测试文件的整个范围，如下所示。
- en: Listing 3.5 cartController.test.js
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.5 cartController.test.js
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ Runs before each test in the file, no matter in which describe block the test
    is
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在文件中的每个测试之前运行，无论测试位于哪个 `describe` 块中
- en: ❷ Runs before each test in the addItemToCart describe block
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在 `addItemToCart` 描述块中的每个测试之前运行
- en: ❸ Runs once before all tests in the checkout describe block
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 在 `checkout` 描述块中的所有测试之前运行一次
- en: ❹ Runs once after all tests in the file finish
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 在文件中的所有测试完成后运行一次
- en: 'Jest executes hooks from the outermost to the innermost block. In the previous
    example, the order of execution would be the following:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Jest 从最外层到最内层执行钩子。在上一个示例中，执行顺序将是以下：
- en: '`beforeEach` ➝ `clearDatabase`'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`beforeEach` ➝ `clearDatabase`'
- en: '`beforeEach` ➝ `insertInventoryItem`'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`beforeEach` ➝ `insertInventoryItem`'
- en: '`test` ➝ add an available item to cart'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`test` ➝ 向购物车添加可用项目'
- en: '`beforeEach` ➝ `clearDatabase`'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`beforeEach` ➝ `clearDatabase`'
- en: '`beforeAll` ➝ `mockPaymentService`'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`beforeAll` ➝ `mockPaymentService`'
- en: '`test` ➝ checkout nonexisting cart'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`test` ➝ 检查不存在的购物车'
- en: '`afterAll` ➝ `destroyDbConnection`'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`afterAll` ➝ `destroyDbConnection`'
- en: Nesting life cycle hooks has benefits that are similar to nesting utility functions.
    You know exactly where to look for them and the scope to which they apply.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套生命周期钩子具有与嵌套实用函数类似的优点。你知道确切的位置在哪里查找它们，以及它们应用的范围。
- en: 3.1.1 Breaking down tests
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.1 分解测试
- en: Ideally, tests should be as small as possible and focus on checking a single
    aspect of the unit under test.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，测试应该尽可能小，并专注于检查被测试单元的单一方面。
- en: Let’s use the tests for the route that adds items to a cart as an example. This
    time, let’s consider that it will also update the inventory when adding items
    to a cart. To comply with the new spec, you will modify the route written in chapter
    2 that adds items to a cart.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以添加项目到购物车的路由的测试为例。这次，让我们考虑在添加项目到购物车时也会更新库存。为了符合新的规范，你将修改第 2 章中添加项目到购物车的路由。
- en: Listing 3.6 server.js
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.6 server.js
- en: '[PRE5]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ Stores the content of the users’ carts. Each username leads to an array of
    strings representing the items in the cart.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 存储用户购物车的内 容。每个用户名都对应一个表示购物车中项目的字符串数组。
- en: ❷ Stores the inventory’s state. Each item name leads to a number representing
    its quantity.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 存储库存的状态。每个项目名称都对应一个表示其数量的数字。
- en: ❸ Handles requests to POST /carts/:username/items/:item, adding items to a user’s
    cart
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 处理对 POST /carts/:username/items/:item 的请求，向用户的购物车添加项目
- en: ❹ Proceeds to add an item to the cart only if the item is in stock; if it’s
    not, responds with a 404 status
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 只有当项目有库存时才将项目添加到购物车中；如果没有，则响应状态为 404
- en: ❺ Creates a new array of items including the item in the request’s parameters
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 创建一个包含请求参数中项的新数组
- en: ❻ Updates the user’s cart with the new array of items
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 更新用户的购物车为新数组中的项
- en: ❼ Responds with the new array of items
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 响应：返回新的项目数组
- en: ❽ Binds the server to the port 3000, and exports it through the app property
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: ❽ 将服务器绑定到端口 3000，并通过 app 属性导出
- en: NOTE This time I want to focus *only* on the route that adds items to a cart.
    Because you will *not* write end-to-end-tests, you should export `inventory` and
    `carts`. The tests we will write in this chapter can coexist with the end-to-end
    tests you have already written because they have different levels of granularity.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：这次我想只关注添加项目到购物车的路由。因为你将不会编写端到端测试，所以你应该导出 `inventory` 和 `carts`。我们将在本章中编写的测试可以与您已经编写的端到端测试共存，因为它们的粒度级别不同。
- en: Even though the previous end-to-end tests are more loosely coupled and provide
    stronger guarantees from a user’s point of view, the tests in this chapter take
    less time to run and can cover smaller parts of your application at a time, as
    you will notice when we break down the tests.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管先前的端到端测试耦合度较低，并且从用户的角度提供了更强的保证，但本章的测试运行时间更短，可以一次覆盖应用的小部分，正如您将在分解测试时注意到的那样。
- en: Now, write the test file for this route as follows.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，按照以下方式编写此路由的测试文件。
- en: Listing 3.7 server.test.js
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.7 server.test.js
- en: '[PRE6]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '❶ Arrange: sets the number of cheesecakes in the inventory to 1'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 安排：将库存中的芝士蛋糕数量设置为 1
- en: '❷ Act: sends a request to the route that adds a cheesecake to the cart'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 行动：向添加芝士蛋糕到购物车的路由发送请求
- en: '❸ Assert: checks whether the response is an array including only the newly
    added cheesecake'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 断言：检查响应是否为仅包含新添加芝士蛋糕的数组
- en: '❹ Assert: verifies that the number of cheesecakes in the inventory is 0'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 断言：验证库存中芝士蛋糕的数量为 0
- en: '❺ Assert: verifies that the user’s cart contains only the newly added cheesecake'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 断言：验证用户的购物车中只包含新添加的芝士蛋糕
- en: '❻ Act: sends a request to add another cheesecake to the user’s cart'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 行动：向用户的购物车发送请求以添加另一个芝士蛋糕
- en: '❼ Assert: checks whether last response’s status was 404'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 断言：检查最后一个响应的状态是否为 404
- en: 'Despite the test for `addItem` being rigorous, it asserts on too many aspects
    of the route it’s testing. It verifies the following:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管对 `addItem` 的测试是严格的，但它对正在测试的路由的许多方面进行了断言。它验证以下内容：
- en: If `addItem` updated the cart’s contents
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 `addItem` 更新了购物车的内 容
- en: If the route’s response is correct
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果路由的响应正确
- en: If the inventory has been updated
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果库存已更新
- en: If the route refuses to add a sold-out item to the cart
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果路由拒绝向购物车添加已售罄的商品
- en: If the application doesn’t fulfill any of these expectations, the test will
    fail. When this test fails, because you rely on four different assertions, you
    won’t immediately be able to tell what the problem is. Because tests halt when
    an assertion fails, once you fix the test, you will also need to keep rerunning
    it to see if any assertions after the broken one will also fail.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序不满足这些期望中的任何一个，测试将失败。当这个测试失败时，因为您依赖于四个不同的断言，您将无法立即知道问题是什么。因为测试在断言失败时停止，一旦修复了测试，您还需要重新运行它以查看断言之后的任何断言是否也会失败。
- en: If we separate those checks into multiple tests, on a single execution we can
    instantly tell what all the problems with the `addItem` route are, as follows.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将这些检查分成多个测试，在单次执行中可以立即知道`addItem`路由的所有问题，如下所示。
- en: Listing 3.8 server.test.js
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.8 server.test.js
- en: '[PRE7]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ Empties all carts before each test in the addItem describe block
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在addItem描述块中的每个测试之前清空所有购物车
- en: ❷ Before each test, sets to 1 the number of cheesecakes available in the inventory
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在每个测试之前，将库存中可用的芝士蛋糕数量设置为1
- en: ❸ Tries to add one cheesecake to a user’s cart, and validates the response’s
    body and status
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 尝试向用户的购物车中添加一块芝士蛋糕，并验证响应体和状态
- en: ❹ Validates the number of cheesecakes in the inventory after adding an item
    to a user’s cart
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 验证在向用户的购物车添加商品后库存中芝士蛋糕的数量
- en: ❺ Tries to add one cheesecake to a user’s cart, and validates the cart’s contents
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 尝试向用户的购物车中添加一块芝士蛋糕，并验证购物车的商品内容
- en: ❻ Validates the response for a request that should fail when an item is unavailable
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 验证当商品不可用时应该失败的请求的响应
- en: Because these tests are much smaller, they are also easier to read.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些测试很小，它们也更容易阅读。
- en: The fewer assertions per test you have, the more granular the feedback, and
    the less time it takes for you to identify defects.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 每个测试中的断言越少，反馈越细粒度，您识别缺陷所需的时间就越少。
- en: 3.1.2 Parallelism
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.2 并行性
- en: If you have four test files that take one second each, sequentially running
    them would take, in total, four seconds, as shown by figure 3.5\. As the number
    of test files increase, so does the total execution time.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有四个测试文件，每个文件需要一秒钟，依次运行它们将总共需要四秒钟，如图3.5所示。随着测试文件数量的增加，总执行时间也会增加。
- en: '![](../Images/CH03_F05_DaCosta.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH03_F05_DaCosta.png)'
- en: Figure 3.5 What happens when running tests sequentially
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.5 依次运行测试时会发生什么
- en: To speed up your tests, Jest can run them in parallel, as figure 3.6 demonstrates.
    By default, Jest will parallelize tests that are in different files.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了加快测试速度，Jest可以将它们并行运行，如图3.6所示。默认情况下，Jest将并行化不同文件中的测试用例。
- en: Parallellizing tests Parallellizing tests mean using different threads to run
    test cases simultaneously.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 并行化测试 并行化测试意味着使用不同的线程同时运行测试用例。
- en: '![](../Images/CH03_F06_DaCosta.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH03_F06_DaCosta.png)'
- en: Figure 3.6 What happens when running tests in parallel
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.6 并行运行测试时会发生什么
- en: Parallellizing tests can be beneficial if they are well isolated, but it can
    be problematic if they share data. For example, if you have two test files using
    the same database table, you may have different results depending on the order
    in which they run.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果测试很好地隔离，并行化测试可能是有益的，但如果它们共享数据，则可能存在问题。例如，如果您有两个使用相同数据库表的测试文件，它们的结果可能取决于它们运行的顺序。
- en: If you can’t isolate your tests, make them run sequentially by passing Jest
    the `runInBand` option. It’s better to make your tests slow and reliable than
    fast and flaky.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您无法隔离测试，可以通过传递Jest的`runInBand`选项使它们按顺序运行。使测试慢而可靠比快而不可靠要好。
- en: Flaky tests A test is said to be *“flaky”* when its results may change, even
    though the unit under test and the test itself remain the same.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 不稳定的测试 当一个测试的结果可能会改变，即使被测试的单元和测试本身保持不变时，该测试被称为*“不稳定的”*。
- en: '[PRE8]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In case you have tests that can run simultaneously *within* a test suite, you
    can use `test.concurrent` to indicate which ones Jest should execute concurrently,
    as follows.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有可以在测试套件内同时运行的测试，可以使用`test.concurrent`来指示Jest应该并发执行哪些测试，如下所示。
- en: Listing 3.9 addItemToCart.test.js
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.9 addItemToCart.test.js
- en: '[PRE9]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ❶ These tests will run concurrently, so make sure to isolate the data used by
    each one of them.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 这些测试将并发运行，所以请确保隔离每个测试使用的数据。
- en: To control how many tests run at a time, you can use the `--maxConcurrencyOption`
    and specify how many tests Jest can run simultaneously. To manage the number of
    worker threads spawned to run tests, you can use the `--maxWorkers` option and
    specify how many threads to spawn.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 要控制同时运行的测试数量，你可以使用 `--maxConcurrencyOption` 并指定 Jest 可以同时运行多少个测试。要管理用于运行测试的工作线程数量，你可以使用
    `--maxWorkers` 选项并指定要启动多少个线程。
- en: Parallelizing tests can dramatically speed up execution time. And, because tests
    that run fast incentivize you to run them more often, I highly recommend you to
    adopt this approach. Its only downside is that you must be careful to make sure
    that tests are well isolated.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 并行化测试可以显著加快执行时间。而且，因为运行快的测试会激励你更频繁地运行它们，所以我强烈建议你采用这种方法。它的唯一缺点是，你必须小心确保测试得到良好的隔离。
- en: ➝ *Throughout the book, I will explain the importance of having deterministic
    tests in the context of each kind of application you will build.*
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: ➝ *在本书中，我将解释在构建每种应用时，拥有确定性测试的重要性。*
- en: 3.1.3 Global hooks
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.3 全局钩子
- en: Sometimes you may need to perform hooks before all tests begin or after all
    tests finish. You may need, for example, to start or stop a database process.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你可能需要在所有测试开始之前或结束后执行钩子。例如，你可能需要启动或停止数据库进程。
- en: 'Jest allows you to set up global hooks through two configuration options: `globalSetup`
    and `globalTeardown`. You can specify these options in your `jest.config.js` file.
    If you haven’t created one yet, you can place it right next to the `package.json`
    file in the root of your project.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Jest 允许你通过两个配置选项 `globalSetup` 和 `globalTeardown` 来设置全局钩子。你可以在你的 `jest.config.js`
    文件中指定这些选项。如果你还没有创建一个，你可以将它放在项目根目录中的 `package.json` 文件旁边。
- en: TIP You can use Jest’s CLI to create a configuration file quickly. When you
    run `jest --init`, you will be prompted to answer a few questions that will be
    used to generate your `jest.config.js` file.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士：你可以使用 Jest 的 CLI 快速创建配置文件。当你运行 `jest --init` 时，你将需要回答几个问题，这些问题将用于生成你的 `jest.config.js`
    文件。
- en: The filenames passed to `globalSetup` and `globalTeardown` should export the
    functions that Jest will call before and after all your tests run, as follows.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给 `globalSetup` 和 `globalTeardown` 的文件名应该导出 Jest 在所有测试运行前后将调用的函数，如下所示。
- en: Listing 3.10 jest.config.js
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.10 jest.config.js
- en: '[PRE10]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ❶ Jest runs this file’s exported async function once before all tests.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ Jest 在所有测试开始前会运行此文件导出的异步函数一次。
- en: ❷ Jest runs this file’s exported async function once after all tests.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ Jest 在所有测试结束后会运行此文件导出的异步函数一次。
- en: 'A setup file that, for example, initializes a database would look something
    like this:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个初始化数据库的设置文件可能看起来像这样：
- en: Listing 3.11 globalSetup.js
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.11 globalSetup.js
- en: '[PRE11]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Values assigned to the `global` object, like the one shown previously, will
    be available on the `globalTeardown` hook, too.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 分配给 `global` 对象的值，如前面所示，也将可在 `globalTeardown` 钩子中使用。
- en: Considering you have set up a database instance and assigned it to `_databaseInstance`
    on your `globalSetup`, you can use that same variable to stop that process once
    the tests have finished, as follows.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你在 `globalSetup` 中设置了一个数据库实例并将其分配给 `_databaseInstance`，你可以在测试完成后使用相同的变量来停止该进程，如下所示。
- en: Listing 3.12 globalTeardown.js
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.12 globalTeardown.js
- en: '[PRE12]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In case the setup and teardown functions are asynchronous, like the ones we’ve
    just written, Jest will run them to completion before proceeding.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果设置和清理函数是异步的，就像我们刚才写的那些，Jest 将在继续之前运行它们直到完成。
- en: 3.1.4 Atomicity
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.4 原子性
- en: When organizing tests, consider that any test should be capable of running adequately,
    even when isolated from all others. Running a test on its own should be no different
    from running it among another one thousand tests.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在组织测试时，请考虑任何测试都应能够在与其他所有测试隔离的情况下充分运行。单独运行一个测试应该与在成千上万的测试中运行它没有区别。
- en: Consider, for example, a few of the tests that you have previously written for
    the `addItem` function. For the sake of this example, I have removed the `beforeEach`
    hooks from the following `describe` block.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑你之前为 `addItem` 函数编写的几个测试。为了这个例子，我已经从下面的 `describe` 块中移除了 `beforeEach` 钩子。
- en: Listing 3.13 server.test.js
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.13 server.test.js
- en: '[PRE13]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ❶ Sets to 1 the number of cheesecakes available, and checks whether adding one
    cheesecake to a cart updates the inventory adequately
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将可用的芝士蛋糕数量设置为 1，并检查向购物车添加一个芝士蛋糕是否足以更新库存
- en: ❷ Tries to add a piece of cheesecake to a user’s cart, and checks whether the
    cart’s content is an array containing a single cheesecake
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 尝试向用户的购物车中添加一块芝士蛋糕，并检查购物车的内容是否为一个包含单个芝士蛋糕的数组
- en: ❸ Tries to add a cheesecake, and expects the server’s response’s status to be
    404
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 尝试添加一块芝士蛋糕，并期望服务器的响应状态为404
- en: In this case, the second test will always fail if the first one has run. On
    the other hand, the third test depends on the first to succeed.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，如果第一个测试已经运行，第二个测试将始终失败。另一方面，第三个测试依赖于第一个测试的成功。
- en: When tests interfere with one another, it can be hard to determine the root
    cause of bugs. Tests that are not atomic cause you to wonder whether the problem
    is in your test or your code.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 当测试相互干扰时，确定错误的根本原因可能很困难。非原子性的测试会让你怀疑问题是在你的测试还是你的代码中。
- en: Having atomic tests also helps you get quicker feedback. Because you can run
    a test separately from all others, you don’t need to wait for a long test suite
    to finish before knowing whether the code you have written works.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 具有原子性测试也有助于你更快地获得反馈。因为你可以单独运行一个测试，你不需要等待长时间测试套件完成才能知道你编写的代码是否工作。
- en: To keep tests atomic, it’s crucial to remember to write good setup and teardown
    hooks. For the sake of atomicity, add a `beforeEach` hook that adds a cheesecake
    to the inventory to the previous example and another that empties the user’s cart,
    as shown next.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持测试的原子性，记住编写好的设置和拆卸钩子至关重要。为了保持原子性，向先前的示例中添加一个将芝士蛋糕添加到库存中的`beforeEach`钩子，并添加另一个清空用户购物车的钩子，如下所示。
- en: Listing 3.14 server.test.js
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.14 server.test.js
- en: '[PRE14]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: ❶ Before each test, clears all carts
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在每个测试之前，清空所有购物车
- en: ❷ Before each test, sets the number of cheesecakes in the inventory to 1
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在每次测试之前，将库存中的芝士蛋糕数量设置为1
- en: Now, even with these hooks, the last test will fail. The first `beforeEach`
    hook you’ve added inserts a `cheesecake` into the inventory and, therefore, doesn’t
    cause the `addItem` function in the last test to fail.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，即使有这些钩子，最后一个测试也会失败。你添加的第一个`beforeEach`钩子将一个`cheesecake`插入到库存中，因此不会导致最后一个测试中的`addItem`函数失败。
- en: Because this last test is the only one that doesn’t require a cheesecake to
    be available, it’s better to avoid another hook. Instead, you can simply set the
    number of cheesecakes to zero within the test itself, as shown next.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这个最后一个测试是唯一一个不需要芝士蛋糕可用的测试，所以最好避免另一个钩子。相反，你可以在测试本身中将芝士蛋糕的数量简单地设置为零，如下所示。
- en: Listing 3.15 server.test.js
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.15 server.test.js
- en: '[PRE15]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: ❶ Sets the number of cheesecakes in the inventory to 0
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将库存中的芝士蛋糕数量设置为0
- en: Despite being excellent for encapsulating repetitive behavior in a clean and
    concise way, hooks can make your tests harder to read because they increase the
    distance between your test and its setup and teardown process.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管以干净和简洁的方式封装重复行为非常出色，但钩子可能会使你的测试更难以阅读，因为它们增加了测试与其设置和拆卸过程之间的距离。
- en: Avoiding hooks for particular cases makes tests more understandable because
    it causes all the relevant information to be closer to the actual testing code.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 避免特定情况的钩子可以使测试更易于理解，因为它使得所有相关信息都更接近实际的测试代码。
- en: When deciding whether to write a hook or an utility function, I’d advise you
    to think about how often you need to reproduce a certain scenario. If the scenario
    is needed for almost every test in a suite, I’d advise you to use a `hook` and
    consider it as “precondition” for the tests in that suite. On the other hand,
    if you don’t need to set up or tear down the exact same elements on every test,
    an utility function would probably be a better choice.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在决定是否编写钩子或实用函数时，我建议你考虑你需要多频繁地重现某个场景。如果该场景对于套件中的几乎所有测试都是必需的，我建议你使用`hook`并将其视为该套件测试的“先决条件”。另一方面，如果你不需要在每次测试中都设置或拆卸完全相同的元素，实用函数可能是一个更好的选择。
- en: 3.2 Writing good assertions
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.2 编写好的断言
- en: It takes a unique baker to recognize a unique cake. When examining a batter’s
    consistency or a cake’s texture, an excellent pastry chef knows what to look for.
    Without rigorous quality control, you can’t bake tasty desserts.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 要识别独特的蛋糕，需要独特的面包师。在检查面糊的稠度或蛋糕的质地时，优秀的糕点师知道要寻找什么。没有严格的质量控制，你无法烘焙美味的甜点。
- en: In the same way, excellent engineers know what to look for in the software they
    write. They write robust and precise assertions, catching as many bugs as possible
    without significantly increasing maintenance costs.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，优秀的工程师知道在他们所写的软件中寻找什么。他们编写健壮且精确的断言，尽可能多地捕获错误，而不显著增加维护成本。
- en: In this section, I will teach you techniques to help you write better assertions.
    You will learn how to make them catch as many bugs as possible, without having
    to update tests too often, adding extra maintenance burden.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将向您介绍一些技巧，帮助您编写更好的断言。您将学习如何使它们尽可能多地捕获错误，而无需频繁更新测试，从而减少额外的维护负担。
- en: 3.2.1 Assertions and error handling
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.1 断言和错误处理
- en: '**A test without assertions fails only if the application code can’t run**.
    If you have a `sum` function, for example, you must add assertions to ensure it
    does what it must do. Otherwise, it might as well be doing anything else. Without
    assertions, you simply ensure that the `sum` function runs to completion.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '**没有断言的测试只有在应用程序代码无法运行时才会失败**。例如，如果您有一个 `sum` 函数，您必须添加断言以确保它完成它必须完成的工作。否则，它可能做任何事情。没有断言，您只是确保
    `sum` 函数运行到完成。'
- en: To ensure that your tests contain assertions, Jest provides you with utilities
    that make your tests fail in case they don’t run the number of assertions you
    expect.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保您的测试包含断言，Jest 提供了使测试在未运行您期望的断言数量时失败的实用工具。
- en: Consider, for example, an `addToInventory` function that adds items to the store’s
    inventory and returns the new quantity available. If the amount specified is *not*
    a number, it should fail and should *not* add any items to the inventory, as follows.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一个 `addToInventory` 函数，该函数向商店的库存中添加项目并返回新的可用数量。如果指定的数量**不是**一个数字，它应该失败，并且不应该向库存中添加任何项目，如下所示。
- en: Listing 3.16 inventoryController.js
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.16 inventoryController.js
- en: '[PRE16]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: When testing this function, you must be careful not to create an execution path
    that could lead to no assertions ever running. Let’s use as an example the following
    test.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试此函数时，您必须小心不要创建一个可能导致永远不运行断言的执行路径。以下是一个示例。
- en: Listing 3.17 inventoryController.test.js
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.17 inventoryController.test.js
- en: '[PRE17]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: ❶ An assertion that runs only when the addToInventory call throws an error
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 只有在 addToInventory 调用抛出错误时才运行的断言
- en: This test will pass, but you won’t know whether it passed because the `addToInventory`
    function didn’t add an item to the inventory or because it didn’t throw any errors.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 此测试将通过，但您不会知道它是否通过，是因为 `addToInventory` 函数没有向库存中添加项目，还是因为它没有抛出任何错误。
- en: If you comment the line that throws an error and rerun the test, as shown next,
    you will see that, despite the function being incorrect, the test still passes.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您注释掉抛出错误的行并重新运行测试，如以下所示，您将看到，尽管函数是错误的，但测试仍然通过。
- en: Listing 3.18 inventoryController.js
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.18 inventoryController.js
- en: '[PRE18]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: To guarantee that your test will run assertions, you can use `expect.hasAssertions`,
    which will cause your test to fail if the test doesn’t run at least one assertion.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保您的测试将运行断言，您可以使用 `expect.hasAssertions`，这将导致如果测试没有运行至少一个断言，则测试失败。
- en: Go ahead and ensure that your test will run an assertion by adding `expect.hasAssertions`
    to it.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 请确保您的测试通过添加 `expect.hasAssertions` 来运行断言。
- en: Listing 3.19 inventoryController.js
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.19 inventoryController.js
- en: '[PRE19]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: ❶ Causes the test to fail if it doesn’t execute at least one assertion
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 如果测试没有执行至少一个断言，则会导致测试失败
- en: Now consider that you also want to add an assertion that ensures that the inventory
    has only one item.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑您还想要添加一个断言来确保库存中只有一个项目。
- en: Listing 3.20 inventoryController.test.js
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.20 inventoryController.test.js
- en: '[PRE20]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: ❶ An assertion that is always executed
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 总是执行的断言
- en: The previous test could still pass, even if the `catch` block was not executed.
    The `expect.hasAssertions` call within the test will ensure only that **any**
    assertions run, not that *all* of them run.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 即使 `catch` 块没有执行，之前的测试仍然可能通过。测试中的 `expect.hasAssertions` 调用将确保**任何**断言运行，而不是**所有**断言都运行。
- en: To solve this problem, you can use `expect.assertions` to explicitly determine
    how many assertions you expect to run. For example, if you want two assertions
    to run, use `expect.assertions(2)`. Using `expect.assertions` will cause your
    tests to fail whenever the number of assertions executed doesn’t match what you
    determined, as shown next.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，您可以使用 `expect.assertions` 来显式确定您期望运行多少个断言。例如，如果您想运行两个断言，请使用 `expect.assertions(2)`。使用
    `expect.assertions` 将导致您的测试在执行的断言数量与您确定的数量不匹配时失败，如以下所示。
- en: Listing 3.21 inventoryController.test.js
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.21 inventoryController.test.js
- en: '[PRE21]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: ❶ Causes the test to fail if it doesn’t execute two assertions
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 如果测试没有执行两个断言，则会导致测试失败
- en: Because assertion counting is not always practical, a simpler and more readable
    alternative would be to check whether a function call throws an error. To perform
    this assertion, use Jest’s `toThrow`, as shown next.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 由于断言计数并不总是实用的，一个更简单、更易读的替代方案是检查函数调用是否抛出错误。要执行此断言，请使用Jest的`toThrow`，如下所示。
- en: Listing 3.22 inventoryController.test.js
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.22 inventoryController.test.js
- en: '[PRE22]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: ❶ Causes the test to fail if the addToInventory function throws an error
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 如果`addToInventory`函数抛出错误，则测试失败
- en: Because `toThrow` usually makes tests less verbose and easier to read, I tend
    to prefer it. I use it to validate both functions that *should* throw errors and
    functions that shouldn’t.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`toThrow`通常使测试更简洁、更易读，我倾向于更喜欢它。我使用它来验证应该抛出错误和不应该抛出错误的函数。
- en: 3.2.2 Loose assertions
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.2 松散断言
- en: '**The goal of writing tests is for them to fail when your application doesn’t
    do what you want**. When writing assertions, you want to ensure that they will
    be sensitive enough so that they can make tests fail whenever anything goes wrong.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '**编写测试的目标是当你的应用程序没有按照你的意愿执行时，测试应该失败**。在编写断言时，你想要确保它们足够敏感，以便在出现任何错误时使测试失败。'
- en: Again, let’s use your `addToInventory` function as an example. For this function,
    you could write an assertion that ensures that the result of `addToInventory`
    is a `Number`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 再次以你的`addToInventory`函数为例。对于这个函数，你可以编写一个断言来确保`addToInventory`的结果是`Number`类型。
- en: Listing 3.23 inventoryController.test.js
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.23 inventoryController.test.js
- en: '[PRE23]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: ❶ Empties the inventory
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 清空库存
- en: ❷ Checks whether the result is a number
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 检查结果是否为数字
- en: Now think of how many possible results this assertion allows. Numbers in JavaScript
    can go from `5e-324` to precisely `1.7976931348623157e+308`. Given this enormous
    range, it’s clear that the set of possible results accepted by the assertion is
    too big, as illustrated in figure 3.7\. This assertion can guarantee that the
    `addToInventory` function won’t return, for example, a `String` or a `boolean`,
    but it can’t guarantee that the number returned is correct. By the way, you know
    what else is considered a `Number` in JavaScript? `NaN`, which stands for *not*
    a number.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑这个断言允许多少种可能的结果。JavaScript中的数字可以从`5e-324`精确到`1.7976931348623157e+308`。鉴于这个巨大的范围，很明显，断言接受的可能的值集太大，如图3.7所示。这个断言可以保证`addToInventory`函数不会返回例如`String`或`boolean`，但它不能保证返回的数字是正确的。顺便说一句，你知道在JavaScript中什么也被认为是`Number`吗？`NaN`，代表*不是*数字。
- en: '[PRE24]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '![](../Images/CH03_F07_DaCosta.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH03_F07_DaCosta.png)'
- en: Figure 3.7 The range of results accepted by the type assertion
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.7 类型断言接受的结果范围
- en: The more values an assertion accepts, the ***looser*** it is.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 一个断言接受的值越多，它就越***宽松***。
- en: One way of making this assertion accept fewer values—make it “tighter”—is to
    expect the result to be bigger than a particular value, as shown next.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 使这个断言接受更少的值——使其“更严格”——的一种方法就是期望结果大于某个特定的值，如下所示。
- en: Listing 3.24 inventoryController.test.js
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.24 inventoryController.test.js
- en: '[PRE25]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: ❶ Expects the result to be greater than 1
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 期望结果大于1
- en: The `toBeGreaterThan` assertion drastically reduces the number of accepted results,
    as you can see in figure 3.8, but it is still way looser than it should be.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如图3.8所示，`toBeGreaterThan`断言极大地减少了接受的结果数量，但它仍然比应有的宽松得多。
- en: '![](../Images/CH03_F08_DaCosta.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH03_F08_DaCosta.png)'
- en: Figure 3.8 The range of results accepted by the `toBeGreaterThan` assertion
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.8 `toBeGreaterThan`断言接受的结果范围
- en: The tighter and most valuable assertion you can write is an assertion that allows
    only a single result to pass, as shown in the following listing and illustrated
    by figure 3.9.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 你能写出的最严格且最有价值的断言是只允许单个结果通过的断言，如下面的列表和图3.9所示。
- en: '![](../Images/CH03_F09_DaCosta.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/CH03_F09_DaCosta.png)'
- en: Figure 3.9 The range of results accepted by the tight `toBe` assertion
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.9 严格的`toBe`断言接受的结果范围
- en: Listing 3.25 inventoryController.test.js
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.25 inventoryController.test.js
- en: '[PRE26]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: ❶ Expects the result to be exactly 2
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 期望结果正好是2
- en: '*Ideally*, your assertions should accept a single result. If your assertions
    customarily allow many results, it can be a sign that your code is **not** deterministic
    or that you don’t know it well enough. Loose assertions make it easier for tests
    to pass, but they make those tests less valuable because they might *not* fail
    when the application produces invalid output. **Writing tighter assertions makes
    it harder for your tests to pass when the application code has problems, making
    it easier to catch bugs**.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '*理想情况下*，你的断言应该接受单个结果。如果你的断言通常允许许多结果，这可能是一个迹象表明你的代码**不是**确定性的，或者你对它了解不够充分。松散的断言使测试更容易通过，但它们使这些测试的价值降低，因为它们可能在应用程序产生无效输出时不会失败。**编写更紧密的断言会使测试在应用程序代码有问题时更难通过，从而更容易捕获错误**。'
- en: Deterministic code A code is said to be deterministic when, given the same input,
    it always produces the same output.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 确定性代码 当给定相同的输入时，总是产生相同输出的代码被称为确定性代码。
- en: An assertion that, for example, verifies whether an array *includes* a value
    usually tells that you don’t know what the entire array should look like. Ideally,
    you should have written an assertion that checks the whole array.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个验证数组是否包含值的断言通常表明你不知道整个数组应该是什么样子。理想情况下，你应该编写一个检查整个数组的断言。
- en: Negated assertions—assertions that ensure an output *does not* match another
    value—also generate loose assertions. For example, when you assert that an output
    *is not* `2`, you accept an enormous range of values (*all* values, of *all* types,
    but `2`), as shown in figure 3.10\. **Avoid writing negated assertions whenever
    possible**.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 否定断言——确保输出不匹配另一个值的断言——也会生成松散的断言。例如，当你断言输出不是`2`时，你接受了一个巨大的值范围（所有类型的所有值，但不是`2`），如图
    3.10 所示。**尽可能避免编写否定断言**。
- en: Writing loose assertions is acceptable when you want tests not to be tied to
    factors you can’t control, like true randomness. Assume that you are testing a
    function that generates an array with random numbers. When testing this function,
    you probably want to check the length of the array and the type of its items but
    not the array’s exact content.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想测试不依赖于你无法控制的因素，如真正的随机性时，编写松散的断言是可以接受的。假设你正在测试一个生成随机数字数组的函数。在测试这个函数时，你可能想检查数组的长度和其项的类型，但不需要检查数组的确切内容。
- en: '![](../Images/CH03_F10_DaCosta.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH03_F10_DaCosta.png)'
- en: Figure 3.10 The range of results accepted by a negated assertion
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.10 否定断言接受的结果范围
- en: TIP Even though Jest has a diverse set of assertions—which you can find at [https://jestjs.io/docs/en/expect](https://jestjs.io/docs/en/expect)—I’d
    recommend readers to stick to `toBe` and `toEqual` whenever possible, because
    they are extremely strict.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 提示 尽管Jest有一系列断言——你可以在[https://jestjs.io/docs/en/expect](https://jestjs.io/docs/en/expect)中找到它们——但我建议读者尽可能坚持使用`toBe`和`toEqual`，因为它们非常严格。
- en: To make it easier to control how loose your assertions are, Jest has *asymmetric
    matchers*. Asymmetric matchers allow you to determine which aspects of a particular
    output Jest should validate loosely and which ones it should validate tightly.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更容易控制你的断言有多松散，Jest 有**非对称匹配器**。非对称匹配器允许你确定 Jest 应该松散验证特定输出的哪些方面，以及应该紧密验证哪些方面。
- en: Assume you have a function that returns the content of your inventory indexed
    by name. For auditing purposes, this function will also include the date at which
    the information was generated, as follows.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个返回按名称索引的库存内容的函数。出于审计目的，此函数还将包括生成信息时的日期，如下所示。
- en: Listing 3.26 inventoryController.js
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.26 inventoryController.js
- en: '[PRE27]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: ❶ Creates an object whose keys are the inventory item’s names and whose values
    are each item’s respective quantities
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个对象，其键是库存项目的名称，其值是每个项目的相应数量
- en: ❷ Returns a new object including all the properties in contents and a date
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 返回一个新对象，包括`contents`中的所有属性和一个日期
- en: When testing this function, your date will change whenever the test runs. To
    avoid asserting on the exact time the inventory report was generated, you can
    use an asymmetric matcher to ensure that the `generatedAt` field will contain
    a date. For the other properties, you can have tight assertions, as shown in the
    following code excerpt.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试此函数时，你的日期将在每次测试运行时更改。为了避免断言库存报告生成的确切时间，你可以使用非对称匹配器来确保`generatedAt`字段将包含一个日期。对于其他属性，你可以有紧密的断言，如下面的代码片段所示。
- en: Listing 3.27 inventoryController.test.js
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.27 inventoryController.test.js
- en: '[PRE28]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: ❶ Expects the result to match the object passed to the toEqual method
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 期望结果与传递给 toEqual 方法的对象匹配
- en: ❷ Allows the generatedAt property to be any date
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 允许 `generatedAt` 属性为任何日期
- en: Asymmetric matchers can perform many different kinds of verifications. They
    can, for example, check whether a string matches a regular expression or whether
    an array contains a specific item. Check Jest’s documentation to see which matchers
    are available out of the box.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 非对称匹配器可以执行许多不同的验证。例如，它们可以检查一个字符串是否与正则表达式匹配，或者一个数组是否包含特定项。查看 Jest 的文档以了解哪些匹配器是默认可用的。
- en: 3.2.3 Using custom matchers
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.3 使用自定义匹配器
- en: In the previous section, we’ve seen that, even though we want our assertions
    to be as strict as possible, in some instances, it’s still necessary to be flexible
    when it comes to verifying values.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们看到了尽管我们希望我们的断言尽可能严格，但在某些情况下，在验证值时仍然需要灵活。
- en: Just like when you encapsulate behavior into functions, you can encapsulate
    your verifications into new matchers.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 就像将行为封装到函数中一样，你还可以将你的验证封装到新的匹配器中。
- en: Let’s say, for example, that you are writing a test to ensure that the `generatedAt`
    field in the `getInventory` is not a date in the future. One of the ways you could
    do this is by manually comparing timestamps, as shown next.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 假设，例如，你正在编写一个测试来确保 `getInventory` 中的 `generatedAt` 字段不是未来的日期。你可以这样做的一种方法是通过手动比较时间戳，如下所示。
- en: Listing 3.28 inventoryController.test.js
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.28 inventoryController.test.js
- en: '[PRE29]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: ❶ Adds one millisecond to the current timestamp to ensure that the timestamps
    compared won’t be the same. Alternatively, you could wait for one millisecond
    before calling Date.now.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将当前时间戳增加一毫秒以确保比较的时间戳不会相同。或者，你可以在调用 Date.now 之前等待一毫秒。
- en: ❷ Checks whether the result’s generatedAt property is smaller than the one generated
    by the test and stores a Boolean value
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 检查结果 `generatedAt` 属性是否小于测试生成的属性，并存储一个布尔值
- en: ❸ Checks whether the stored Boolean value is true
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 检查存储的布尔值是否为真
- en: This test can be great when it passes, but when it fails, its feedback may not
    be as clear as you’d expect. Try, for example, to set the year in the `generatedAt`
    property to 3000 so that you can see what happens when the test fails.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 当这个测试通过时，它可以非常出色，但当它失败时，它的反馈可能不如你预期的那么清晰。例如，尝试将 `generatedAt` 属性中的年份设置为 3000，以便你可以看到测试失败时会发生什么。
- en: Listing 3.29 inventoryController.js
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.29 inventoryController.js
- en: '[PRE30]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: ❶ Creates a date in the year 3000
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个公元 3000 年的日期
- en: 'Running your tests should yield the following output:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 运行你的测试应该会产生以下输出：
- en: '[PRE31]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: As you can see, the diff generated by Jest doesn’t provide much information.
    It says that you expected `true` to be `false`, but it doesn’t tell you anything
    about *what* the subject of your assertion was. When a test fails with such a
    generic difference, you will need to reread its code to determine what went wrong
    and what the exact difference was between the actual and expected results.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，Jest 生成的差异没有提供太多信息。它说你期望 `true` 是 `false`，但它没有告诉你断言的主题是什么。当测试以这样的通用差异失败时，你需要重新阅读其代码以确定出了什么问题，以及实际结果和预期结果之间的确切差异是什么。
- en: To get access to more precise assertions, we will use `jest-extended`. The `jest-extended`
    module extends Jest’s assertions, providing you with even better and more flexible
    checks.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得更精确的断言，我们将使用 `jest-extended`。`jest-extended` 模块扩展了 Jest 的断言，为你提供了更好、更灵活的检查。
- en: NOTE You can find the documentation for `jest-extended` and its assertions at
    [https://github.com/jest-community/jest-extended](https://github.com/jest-community/jest-extended).
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：你可以在 [https://github.com/jest-community/jest-extended](https://github.com/jest-community/jest-extended)
    找到 `jest-extended` 和其断言的文档。
- en: Go ahead and install `jest-extended` as a dev dependency.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 前往并安装 `jest-extended` 作为开发依赖项。
- en: To set up `jest-extended` so that you can use its assertions, update your `jest
    .config.js`, and add `jest-extended` to the list of files that should run after
    setting up the test environment, as follows.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置 `jest-extended` 以使用其断言，更新你的 `jest .config.js` 文件，并将 `jest-extended` 添加到应在设置测试环境之后运行的文件列表中，如下所示。
- en: Listing 3.30 jest.config.js
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.30 jest.config.js
- en: '[PRE32]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: ❶ Extends Jest with assertions from jest-extended
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 通过 jest-extended 扩展 Jest 的断言
- en: Once you have done this, you will be able to use any of the assertions shipped
    with `jest-extended`.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些后，你将能够使用 `jest-extended` 中的任何断言。
- en: To make the test’s feedback clearer, we will use the `toBeBefore` assertion,
    which checks whether a `Date` is before another. Update your test so that it uses
    this new assertion, as shown next.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使测试的反馈更清晰，我们将使用 `toBeBefore` 断言，该断言检查一个 `Date` 是否在另一个 `Date` 之前。更新您的测试，使其使用这个新的断言，如下所示。
- en: Listing 3.31 inventoryController.test.js
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.31 inventoryController.test.js
- en: '[PRE33]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: ❶ Creates a date that is one millisecond ahead of the current time. Alternatively,
    you could wait for a millisecond before generating a Date.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个比当前时间早一毫秒的日期。或者，您也可以在生成 `Date` 之前等待一毫秒。
- en: ❷ Expects the result’s generatedAt property to be before the date generated
    in the line above
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 期望结果中的 `generatedAt` 属性在上一行生成的日期之前
- en: 'Now, when this test fails, the feedback provided by Jest will be way more precise:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当这个测试失败时，Jest 提供的反馈将更加精确：
- en: '[PRE34]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Now you know exactly what the test was checking and what the difference is between
    the two dates.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您确切地知道测试检查了什么，以及两个日期之间的差异是什么。
- en: Using precise assertions enables you to improve the quality of your test’s feedback
    by indicating what kind of output Jest should produce.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 使用精确断言可以使您通过指示 Jest 应该产生什么样的输出来提高测试反馈的质量。
- en: Tests with precise assertions are way easier to read and take less time to fix
    because it’s easier to understand what went wrong.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 使用精确断言的测试更容易阅读，修复所需时间也更短，因为更容易理解哪里出了问题。
- en: 3.2.4 Circular assertions
  id: totrans-286
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.2.4 循环断言
- en: Circular assertions are assertions that compare your application’s code to itself.
    You should avoid circular assertions because when comparing your code’s results
    to themselves, your tests will *never* fail.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 循环断言是比较您的应用程序代码与自身的断言。您应该避免循环断言，因为当比较代码的结果时，您的测试将 *永远不会* 失败。
- en: Let’s say, for example, that you create a route for returning the inventory’s
    content. This route uses the `getInventory` function you already have, as follows.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 假设，例如，您创建了一个返回库存内容的路由。此路由使用您已经拥有的 `getInventory` 函数，如下所示。
- en: Listing 3.32 server.js
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.32 server.js
- en: '[PRE35]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: To facilitate testing this route, you may feel tempted to use `getInventory`
    again within your test.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 为了便于测试此路由，您可能会倾向于在测试中使用 `getInventory`。
- en: Listing 3.33 server.test.js
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.33 server.test.js
- en: '[PRE36]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: ❶ Copies to a new object the properties in the getInventory function’s result,
    and includes a generatedAt property whose value is an asymmetric matcher
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将 getInventory 函数的结果中的属性复制到一个新对象中，并包含一个生成的 `generatedAt` 属性，其值是一个非对称匹配器
- en: ❷ Allows the generatedAt property to have any value
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 允许 `generatedAt` 属性具有任何值
- en: ❸ Compares the server’s response to the object created within the test
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 比较服务器响应与测试中创建的对象
- en: The problem with this approach is that, because both the route and the test
    depend on the same piece of code (`getInventory`), you end up comparing the application
    to itself. If there’s a problem in the `getInventory` route, it won’t cause this
    test to fail because the result you expect was also incorrect.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的问题在于，由于路由和测试都依赖于相同的代码片段 (`getInventory`)，您最终是在比较应用程序本身。如果 `getInventory`
    路由存在问题，它不会导致这个测试失败，因为您期望的结果也是错误的。
- en: Try, for example, changing `getInventory` so that it returns `1000` as the quantity
    for each item.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，尝试将 `getInventory` 改变，使其为每个项目返回 `1000` 作为数量。
- en: Listing 3.34 server.test.js
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.34 server.test.js
- en: '[PRE37]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: ❶ Uses the inventory’s entries to create an array of key and value pairs
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使用库存条目创建一个键值对数组
- en: ❷ Creates an object whose keys are the inventory item names and whose values
    are always set to 1000 and represent each item’s respective quantities
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 创建一个对象，其键是库存项目名称，其值始终设置为 1000，代表每个项目的相应数量
- en: ❸ Copies every property in contents to a new object, which also contains a generatedAt
    key whose value is a Date
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将 contents 中的每个属性复制到一个新对象中，该对象还包含一个 `generatedAt` 键，其值为一个 `Date`
- en: Even though the quantity of items in the inventory is now wrong, the test for
    your route will still pass.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 即使库存中项目的数量现在错误，您的路由测试仍然会通过。
- en: Circular assertions don’t tend to be a big problem if you are already testing
    the different parts of your application separately. In the previous case, for
    example, even though the route’s tests didn’t catch the bug, thorough tests for
    the `inventoryController` itself would have.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经单独测试了应用程序的不同部分，循环断言通常不会成为大问题。例如，在上一个案例中，即使路由的测试没有捕获到错误，对 `inventoryController`
    本身的彻底测试也会。
- en: Regardless of whether you could have caught that in a separate test, the tests
    for the route will pass even when they shouldn’t. This inaccurate feedback could
    cause confusion and, if you didn’t have rigorous tests for `inventoryController`,
    could have let the bug slip into production.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你是否可以在单独的测试中捕获它，即使测试不应该通过，路由的测试也会通过。这种不准确的反馈可能会导致混淆，如果你没有对`inventoryController`进行严格的测试，那么错误可能会悄悄地进入生产环境。
- en: A test that contains the expected result explicitly written into the assertion
    would have been far better. It would make the test more readable and facilitate
    debugging, as shown next.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在断言中明确写出预期结果，那么这个测试将会更好。这将使测试更易于阅读，并有助于调试，如下所示。
- en: Listing 3.35 server.test.js
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.35 server.test.js
- en: '[PRE38]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: ❶ Creates an object literal without using any dependencies
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 不使用任何依赖项创建一个对象字面量
- en: ❷ Expects the server’s response to match the object literal created within the
    test
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 期望服务器的响应与测试中创建的对象字面量匹配
- en: Whenever possible, create separate utility functions for your tests instead
    of just reusing the application’s code. It’s preferable to have a bit of duplication
    or hardcoded expected results than to have tests that never fail.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 在可能的情况下，为你的测试创建单独的实用函数，而不是仅仅重用应用程序的代码。有一点重复或硬编码的预期结果比有永远无法失败的测试更好。
- en: '3.3 Test doubles: Mocks, stubs, and spies'
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.3 测试替身：模拟、存根和间谍
- en: Mocks, stubs, and spies are objects used to modify and replace parts of your
    application to ease or enable testing. As a whole, they’re called test doubles.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟、存根和间谍是用于修改和替换应用程序部分的对象，以简化或启用测试。作为一个整体，它们被称为测试替身。
- en: '**Spies** record data related to the usage of a function without interfering
    in its implementation.'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**间谍**记录与函数使用相关的数据，而不干扰其实现。'
- en: '**Stubs** record data associated with the usage of a function *and* change
    its behavior, either by providing an alternative implementation or return value.'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**存根**记录与函数使用相关的数据，并改变其行为，无论是通过提供替代实现还是返回值。'
- en: '**Mocks** change a function’s behavior, but instead of just recording information
    about its usage, they have expectations preprogrammed.'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模拟**会改变一个函数的行为，但它们不仅记录其使用的信息，还预先编程了期望。'
- en: NOTE Engineers often conflate the terms *mocks*, *stubs*, and *spies*, even
    though, formally, these terms have different definitions.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：工程师们经常混淆**模拟**、**存根**和**间谍**这些术语，尽管在正式上，这些术语有不同的定义。
- en: Especially in the context of Jest, you will frequently see people referring
    to stubs and spies as *mocks*. This confusion happens because Jest’s API and documentation
    tends to use the name *mock* for every kind of test double.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 尤其是在Jest的上下文中，你经常会看到人们将存根和间谍称为**模拟**。这种混淆发生是因为Jest的API和文档倾向于使用名称**模拟**来指代所有类型的测试替身。
- en: Ironically, if we adhere to the most accepted definition of a *mock*, it’s the
    only kind of test double that Jest does not include.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 具有讽刺意味的是，如果我们遵循最广泛接受的**模拟**定义，那么它就是Jest不包含的唯一类型的测试替身。
- en: For the sake of readability and to conform with most people’s vocabulary, throughout
    this book I’ve used the term *mock* as a verb that means “to replace with a test
    double.”
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提高可读性和符合大多数人的词汇，在这本书中，我使用了**模拟**这个动词，意思是“用测试替身替换”。
- en: For our first example, let’s consider that, because of accountability purposes,
    you want to keep logs for whenever someone adds an item to the inventory.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一个例子中，让我们考虑出于责任原因，你想要记录每次有人向库存中添加项目时的日志。
- en: To implement this functionality, you’ll use `pino`, a lightweight library whose
    documentation you can find at [https://getpino.io](https://getpino.io). Go ahead
    and install `pino` as one of your application’s dependencies, as shown in the
    next listing. Then, create a `logger` file, which will contain the `logger` instance
    you will use. We will use it to expose only the logging functions we want.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现此功能，你将使用`pino`，这是一个轻量级的库，其文档可以在[https://getpino.io](https://getpino.io)找到。请继续安装`pino`作为你应用程序的依赖项，如下所示。然后，创建一个`logger`文件，其中将包含你将使用的`logger`实例。我们将使用它来公开我们想要的日志功能。
- en: Listing 3.36 logger.js
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.36 logger.js
- en: '[PRE39]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: ❶ Thanks to bind, the this value within these functions will always be the Pino
    instance in this file, not the logger object.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 由于bind的存在，这些函数中的this值将始终是此文件中的Pino实例，而不是日志对象。
- en: Now that you have a logger, modify the `addToInventory` function so that it
    logs whenever an item is added to the inventory, as shown next.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有了日志记录器，修改`addToInventory`函数，使其在向库存中添加项目时记录，如下所示。
- en: Listing 3.37 inventoryController.js
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.37 inventoryController.js
- en: '[PRE40]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: ❶ Logs the item added to the inventory
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 记录添加到库存的项目
- en: 'You can see that the logging works by running `node`’s REPL and executing the
    following code:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过运行 `node` 的 REPL 并执行以下代码来查看日志是如何工作的：
- en: '[PRE41]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'which will cause your logger to write something like this to your console:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致你的日志记录器将类似以下内容写入你的控制台：
- en: '[PRE42]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Given how crucial this requirement is, let’s say you decide to add a test to
    enforce that the `addToInventory` properly logs all items passed to it.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个要求至关重要，让我们假设你决定添加一个测试来强制 `addToInventory` 正确记录传递给它的所有项目。
- en: In this case, logging is a side effect that you can’t easily observe from outside
    the `addToInventory` function. How will you ensure that the logging happened if
    your tests can’t access it?
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，日志是一个难以从 `addToInventory` 函数外部观察到的副作用。如果你的测试无法访问它，你将如何确保日志发生了？
- en: To solve this problem, you’ll use a *spy*. **A spy can record any calls to a
    function**. In this case, you’ll use a spy to track calls to the `logger.logInfo`
    function so that you can assert on these calls later.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，你将使用一个 *间谍*。**间谍可以记录对函数的任何调用**。在这种情况下，你将使用间谍来跟踪对 `logger.logInfo` 函数的调用，以便你可以在之后对这些调用进行断言。
- en: NOTE We don’t want to test if the logging actually happens. Testing the logging
    library (`pino`) is the responsibility of the library’s authors. In the examples
    above, I’ve chosen to trust that the logger works. Instead of adding redundant
    tests, I simply check if the logging methods are called with the expected arguments.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：我们不想测试日志是否真的发生了。测试日志库（`pino`）是库作者的职责。在上面的示例中，我选择相信日志记录器是有效的。而不是添加冗余的测试，我只是检查日志方法是否以预期的参数被调用。
- en: Verifying calls instead of the logger’s actual behavior simplifies the testing
    and makes it quicker, but it does not necessarily guarantee that the unit under
    test logs any information.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 验证调用而不是日志记录器的实际行为简化了测试并使其更快，但这并不一定保证被测试的单元记录了任何信息。
- en: Verifying the logging itself would depend on an end-to-end test. A test of that
    kind would have access to the files or streams to which the logger writes.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 验证日志本身将取决于端到端测试。这种类型的测试将能够访问日志记录器写入的文件或流。
- en: Choosing the kinds of tests to write, as we’ve discussed in the previous chapter,
    depends on your goal and how much you can spend to achieve it.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 选择要编写的测试类型，正如我们在上一章中讨论的，取决于你的目标和你可以投入多少来实现它。
- en: To experiment with your first spy, create a test for the logging capability,
    and spy on the `logger.logInfo` function by using `jest.spyOn`. Once you have
    a spy for `logger .logInfo`, call the `addInventory` function and log `logger.logInfo`
    to see what’s inside it.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实验你的第一个间谍，创建一个测试来测试日志功能，并使用 `jest.spyOn` 间谍 `logger.logInfo` 函数。一旦你有了 `logger.logInfo`
    的间谍，调用 `addInventory` 函数并记录 `logger.logInfo` 以查看其内部内容。
- en: Listing 3.38 inventoryController.js
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.38 inventoryController.js
- en: '[PRE43]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: ❶ Wraps the logger’s logInfo method into a spy
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将日志记录器的 logInfo 方法包装成间谍
- en: 'The `console.log` in your test will show you that Jest wrapped `logger.logInfo`
    into a function that has plenty of properties that let you access and manipulate
    data about the usage of `logInfo`, as follows:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 你的测试中的 `console.log` 将显示 Jest 将 `logger.logInfo` 包装成一个具有许多属性的功能，这些属性允许你访问和操作
    `logInfo` 的使用数据，如下所示：
- en: '[PRE44]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Within the spy you’ve just logged, the property that contains the records with
    each call’s information is `mock`. Update your `console.log` to log `logger.logInfo.mock`
    instead. When running your test again, you should see the following:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 在你刚刚记录的间谍中，包含每个调用信息的记录的属性是 `mock`。更新你的 `console.log` 以记录 `logger.logInfo.mock`。当你再次运行测试时，你应该看到以下内容：
- en: '[PRE45]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In your test, you want to make sure that `logger.logInfo` is called with the
    correct values, so you will use `logger.logInfo.mock.calls` to compare the actual
    arguments with what you expected, as shown next.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的测试中，你想要确保 `logger.logInfo` 使用正确的值被调用，因此你将使用 `logger.logInfo.mock.calls` 来比较实际参数与你预期的参数，如下所示。
- en: Listing 3.39 inventoryController.js
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.39 inventoryController.js
- en: '[PRE46]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: ❶ Exercises the addToInventory function, which should then call the logger’s
    logInfo function, which is wrapped into a spy
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 测试 addToInventory 函数，该函数随后应调用被包装成间谍的日志记录器的 logInfo 函数
- en: ❷ The arguments passed to the logInfo function’s first invocation
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 传递给 logInfo 函数第一次调用的参数
- en: ❸ Expects the first invocation’s first argument to match an object that includes
    the item’s name and quantity
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 期望第一次调用的第一个参数匹配一个包含项目名称和数量的对象
- en: ❹ Checks whether the first invocation’s second argument matches the expected
    message
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 检查第一次调用的第二个参数是否与预期消息匹配
- en: Each new call to `logger.logInfo` adds a new record to `logger.logInfo.mock.calls`.
    That record is an array containing the arguments with which the function was called.
    For example, if you want to ensure that `logger.logInfo` is called only once,
    you can assert on the length of `logger.logInfo.mock.calls`.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用 `logger.logInfo` 都会将一条新记录添加到 `logger.logInfo.mock.calls` 中。该记录是一个包含函数被调用时使用的参数的数组。例如，如果您想确保
    `logger.logInfo` 只被调用一次，您可以对 `logger.logInfo.mock.calls` 的长度进行断言。
- en: Listing 3.40 inventoryController.test.js
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.40 inventoryController.test.js
- en: '[PRE47]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: ❶ Expects the logger’s logInfo function to have been called once
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 预期日志记录器的 logInfo 函数被调用一次
- en: To demonstrate spying throughout multiple tests, add logging to the `getInventory`
    function so that we can write a test for it, as follows.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示在多个测试中监视，向 `getInventory` 函数添加日志记录，以便我们可以为它编写测试，如下所示。
- en: Listing 3.41 inventoryController.js
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.41 inventoryController.js
- en: '[PRE48]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: ❶ Logs a message and the inventory’s contents every time getInventory runs
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 每次运行 getInventory 时记录一条消息和库存的内容
- en: Now that `getInventory` has logging capabilities, add a test for it. Because
    you will need to spy on `logger.logInfo` and clear the inventory before each test,
    use what you’ve learned in the previous chapter to organize the necessary hooks.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 `getInventory` 已经具有日志记录功能，为它添加一个测试。因为您需要监视 `logger.logInfo` 并在每个测试前清除库存，所以使用您在前一章中学到的知识来组织必要的钩子。
- en: Listing 3.42 inventoryController.test.js
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.42 inventoryController.test.js
- en: '[PRE49]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: ❶ Empties the inventory before each test
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在每个测试前清空库存
- en: ❷ Spies on the logger’s logInfo function once before all tests
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在所有测试之前监视日志记录器的 logInfo 函数一次
- en: ❸ Exercises the getInventory function, which should then call the spy that wraps
    the logger’s logInfo function
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 练习 getInventory 函数，然后它应该调用包装日志记录器 logInfo 函数的监视器
- en: ❹ Expects the logger’s logInfo function to have been called once
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 预期日志记录器的 logInfo 函数被调用一次
- en: ❺ Checks whether the first argument passed to the logger’s logInfo function
    matches the expected inventory contents
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 检查传递给日志记录器 logInfo 函数的第一个参数是否与预期的库存内容匹配
- en: ❻ Expects the second argument passed to the logger’s logInfo function to match
    the expected message
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 预期传递给日志记录器 logInfo 函数的第二个参数与预期消息匹配
- en: 'When running these two tests, you will notice that the second one will fail.
    Jest will tell you that it expected `logger.logInfo.mock.calls` to have been called
    only once, but that it has actually been called twice, as follows:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行这两个测试时，您将注意到第二个测试将失败。Jest 将告诉您它期望 `logger.logInfo.mock.calls` 只被调用一次，但实际上它被调用了两次，如下所示：
- en: '[PRE50]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Looking at the diff, we can see that the received array still contains the record
    for the call in the first test. This happens because, just like all other kinds
    of objects, spies retain their states until you reset them.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看差异，我们可以看到接收到的数组仍然包含第一个测试中的调用记录。这是因为，就像所有其他类型的对象一样，监视器会保留其状态，直到您重置它们。
- en: To reset the state of the `logger.logInfo` spy, you can use an `afterEach` to
    call `logger.logInfo.mockClear` after each test. The spy’s `mockClear` function
    will reset both the `spy.mock.calls` and `spy.mock.instances` arrays, as shown
    next.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 要重置 `logger.logInfo` 监视器的状态，您可以在每个测试后使用 `afterEach` 调用 `logger.logInfo.mockClear`。监视器的
    `mockClear` 函数将重置 `spy.mock.calls` 和 `spy.mock.instances` 数组，如下所示。
- en: Listing 3.43 inventoryController.test.js
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.43 inventoryController.test.js
- en: '[PRE51]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: ❶ After each test, resets the test double’s usage information recorded in its
    mock property
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在每个测试后，重置测试替身在它的模拟属性中记录的使用信息
- en: Clearing the mock after each test should make your tests pass again.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个测试后清除模拟应该使您的测试再次通过。
- en: TIP When your tests contain multiple test doubles, instead of manually clearing
    each one of them, you can reset all doubles at once by using `jest.clearAllMocks`
    within a single `beforeEach` hook.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：当您的测试包含多个测试替身时，而不是手动清除每个替身，您可以在单个 `beforeEach` 钩子中使用 `jest.clearAllMocks`
    一次性重置所有替身。
- en: Alternatively, you can add a `clearMocks` property to your `jest.config.js`
    file with the value `true` to automatically clear all test doubles’ records before
    each test.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以在 `jest.config.js` 文件中添加一个 `clearMocks` 属性，并将其值设置为 `true`，以在每个测试前自动清除所有测试替身的记录。
- en: Try adding some more logging and test it yourself. Try, for example, using `logger
    .logError` to log whenever `addToInventory` fails because the `quantity` argument
    passed is not a number.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试添加更多的日志记录并自行测试。例如，尝试使用 `logger .logError` 来记录每次 `addToInventory` 失败时，因为传递的
    `quantity` 参数不是一个数字。
- en: 'Once you have done that, rerun your tests as follows and check Jest’s output:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，按照以下方式重新运行你的测试，并检查 Jest 的输出：
- en: '[PRE52]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Perfect! All tests are passing, but your summary still gets polluted with the
    actual messages written by the logger.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 完美！所有测试都通过了，但你的摘要仍然被实际的日志消息所污染。
- en: These messages are still written to the console because spies *do not* replace
    the actual method that you are spying on. Instead, they wrap that method in a
    `spy` and allow calls to pass through.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 这些消息仍然被写入控制台，因为间谍 *并不* 替换你正在监视的实际方法。相反，它们将该方法包装在一个 `spy` 中，并允许调用通过。
- en: To avoid polluting your test’s output, replace the `logger.logInfo` function’s
    implementation with a dummy function. To do that, call the spy’s `mockImplementation`
    method, and pass it a dummy function created with `jest.fn`.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免污染测试的输出，将 `logger.logInfo` 函数的实现替换为一个虚拟函数。为此，调用间谍的 `mockImplementation`
    方法，并传递一个使用 `jest.fn` 创建的虚拟函数。
- en: TIP You can use `jest.fn` to quickly create stubs. You can either create a stub
    that does nothing besides tracking its usage, or you can pass it a function to
    wrap.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: TIP 你可以使用 `jest.fn` 快速创建存根。你可以创建一个除了跟踪其使用情况外什么都不做的存根，或者你可以传递一个函数来包装它。
- en: Because your tests are well-organized, you just need to update the `beforeAll`
    hook that sets up the spy, as shown next.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 因为你的测试组织得很好，你只需要更新设置间谍的 `beforeAll` 钩子，如以下所示。
- en: Listing 3.44 inventoryController.test.js
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.44 inventoryController.test.js
- en: '[PRE53]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: ❶ Replaces the logger’s logInfo implementation with a dummy function
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将日志的 `logInfo` 实现替换为一个虚拟函数
- en: Now that you have replaced `logger.logInfo` with a dummy function, you won’t
    see the actual logging in your test summary anymore.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经将 `logger.logInfo` 替换成了一个虚拟函数，你将不再在测试摘要中看到实际的日志。
- en: By replacing the `logger.logInfo` function with your own implementation, you
    have created a `stub`. **A stub *replaces* the original implementation of a function**.
    Stubs, just like spies, track the usage of a function so that you can assert on
    it later.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 通过用你自己的实现替换 `logger.logInfo` 函数，你已经创建了一个存根。**存根 *替换* 函数的原始实现**。存根，就像间谍一样，跟踪函数的使用情况，以便你可以在以后断言它。
- en: Important In Jest, all stubs are spies, but not all spies are stubs.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 重要 在 Jest 中，所有存根都是间谍，但并非所有间谍都是存根。
- en: In your previous test, you have replaced `logger.logInfo` with a dummy function,
    but you could actually have passed any function to `mockImplementation`. The function
    passed to `mockImplementation` would then replace the one you specified in `spyOn`,
    and it would still have all the same capabilities as a spy.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 在你之前的测试中，你将 `logger.logInfo` 替换成了一个虚拟函数，但实际上你可以传递任何函数给 `mockImplementation`。传递给
    `mockImplementation` 的函数将替换你在 `spyOn` 中指定的函数，并且它将仍然具有与间谍相同的所有功能。
- en: To demonstrate this, try updating `addToInventory` as shown in the next listing
    so that it includes the process’s memory usage on every log entry. For that, we’ll
    use Node’s `process.memoryUsage` function, whose docs can be found at [https://nodejs
    .org/api/process.html#process_process_memoryusage](https://nodejs.org/api/process.html#process_process_memoryusage).
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这一点，尝试更新 `addToInventory`，如下一列表所示，以便在每次日志条目中包含进程的内存使用情况。为此，我们将使用 Node 的
    `process.memoryUsage` 函数，其文档可以在 [https://nodejs.org/api/process.html#process_process_memoryusage](https://nodejs.org/api/process.html#process_process_memoryusage)
    找到。
- en: Listing 3.45 inventoryController.js
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.45 inventoryController.js
- en: '[PRE54]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: ❶ Logs the item’s name, its quantity, and the process’s memory usage whenever
    an item is added to the inventory
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 当向库存中添加项目时，记录项目的名称、数量和进程的内存使用情况
- en: This new field should now make your test for `addToInventory` fail because it
    doesn’t expect the log entry to include `memoryUsage`.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新字段现在应该会使你的 `addToInventory` 测试失败，因为它没有期望日志条目包含 `memoryUsage`。
- en: You could solve this by using an asymmetric matcher and expecting `memoryUsage`
    to contain any `Number`. The problem with this approach is that it does not guarantee
    that the `Number` in the `memoryUsage` field comes from `process.memoryUsage().rss`.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用非对称匹配器和期望 `memoryUsage` 包含任何 `Number` 来解决这个问题。这种方法的问题在于，它不能保证 `memoryUsage`
    字段中的 `Number` 来自 `process.memoryUsage().rss`。
- en: To make your tests pass again and ensure that the `memoryUsage` field comes
    from the right place, you can provide `mockImplementation` your own function and
    assert on the value that you know will be returned, as shown next.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使测试再次通过并确保 `memoryUsage` 字段来自正确的位置，你可以向 `mockImplementation` 提供你自己的函数，并断言你已知将返回的值，如以下所示。
- en: Listing 3.46 inventoryController.test.js
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.46 inventoryController.test.js
- en: '[PRE55]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: ❶ Before each test, replaces the process’s memoryUsage function with a test
    double that returns an object containing static values
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在每个测试之前，将进程的 `memoryUsage` 函数替换为返回包含静态值的对象的测试替身
- en: ❷ Expects the information registered by the logger’s logInfo function to include
    the memory in the object returned by the test double
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 期望记录器 `logInfo` 函数注册的信息包括测试替身返回的对象中的内存
- en: Warning The more stubs you use, the less your tests resemble what your program
    does at run time, and, therefore, the weaker the quality guarantees they create
    are.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 警告 使用越多替身，你的测试就越不像程序在运行时的行为，因此它们创建的质量保证就越弱。
- en: If the `memoryUsage` function had been deprecated, for example, your tests would
    still pass, even though your program wouldn’t work.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果 `memoryUsage` 函数已被弃用，那么即使你的程序无法工作，测试仍然会通过。
- en: Be thoughtful when using stubs. Use them to make tests run faster and to isolate
    dependencies or factors you can’t control, but make sure that you also have end-to-end
    tests to cover cases your stubs won’t.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 使用替身时要深思熟虑。使用它们来使测试运行更快，并隔离你无法控制的依赖项或因素，但请确保你也有端到端测试来覆盖替身无法覆盖的情况。
- en: You can make the `beforeEach` hook even shorter by using `mockReturnValue`,
    as shown next. It allows you to provide a canned response without having to create
    a function yourself.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用 `mockReturnValue` 来使 `beforeEach` 钩子更短，如下所示。它允许你提供预设响应，而无需自己创建函数。
- en: Listing 3.47 inventoryController.test.js
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.47 inventoryController.test.js
- en: '[PRE56]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: ❶ Causes the process’s memoryUsage function to always return an object with
    the same values
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 使进程的 `memoryUsage` 函数始终返回具有相同值的对象
- en: Just like `spies`, `stubs` will persist their states, including the canned behavior
    you defined, until they are reset. To reset a stub, you can call its `mockReset`
    method. Calling `mockReset` will cause it to reset all call records and any mocked
    behavior, but it will remain a spy. To completely restore the original implementation,
    you should call `mockRestore` instead.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 `spies` 一样，`stubs` 将保持其状态，包括你定义的预设行为，直到它们被重置。要重置一个替身，你可以调用它的 `mockReset`
    方法。调用 `mockReset` 将导致它重置所有调用记录和任何模拟行为，但它将保持为 `spy`。要完全恢复原始实现，你应该调用 `mockRestore`。
- en: '`mockClear` erases a test double’s records but keeps the double in place.'
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mockClear` 删除测试替身的记录，但保持替身位置不变。'
- en: '`mockReset` erases a test double’s records and any canned behavior but keeps
    the double in place.'
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mockReset` 删除测试替身的记录和任何预设行为，但保持替身位置不变。'
- en: '`mockRestore` completely removes the double, restoring the original implementation.'
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mockRestore` 完全删除替身，恢复原始实现。'
- en: TIP All of Jest’s reset methods have global functions that allow you to clear,
    reset, or restore all test doubles at once. To help you avoid having to write
    hooks on each test manually, Jest also allows you to add options to `jest .config.js`
    that automatically reset doubles for you. These options are `clearMocks`, `resetMocks`,
    and `restoreMocks`.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 提示 Jest 的所有重置方法都有全局函数，允许你一次性清除、重置或恢复所有测试替身。为了帮助你避免在每次测试时手动编写钩子，Jest 还允许你向 `jest.config.js`
    添加选项，这些选项可以自动为你重置替身。这些选项是 `clearMocks`、`resetMocks` 和 `restoreMocks`。
- en: In case you want to try different memory values for multiple invocations, by
    using `mockReturnValueOnce`, you can determine canned responses for individual
    calls, as shown next. This function makes it much easier to set up canned responses
    for tests that depend on multiple calls to a function.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要尝试为多次调用尝试不同的内存值，可以通过使用 `mockReturnValueOnce` 来确定单个调用的预设响应，如下所示。这个函数使得为依赖于多次调用函数的测试设置预设响应变得容易得多。
- en: Listing 3.48 inventoryController.test.js
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.48 inventoryController.test.js
- en: '[PRE57]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: ❶ Specifies which object to return on the first call
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在第一次调用中指定要返回的对象
- en: ❷ Specifies which object to return on the second call
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在第二次调用中指定要返回的对象
- en: ❸ Specifies which object to return on the third call
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 在第三次调用中指定要返回的对象
- en: 3.3.1 Mocking imports
  id: totrans-428
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.3.1 模拟导入
- en: So far we haven’t had any problems in mocking properties on the `logger` object
    we import. But now let’s see what happens if you try to import and use its methods
    directly. Start by changing your import so that you get the `logInfo` and `logError`
    functions straightaway.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们在模拟导入的 `logger` 对象属性时还没有遇到任何问题。但现在让我们看看如果你尝试直接导入并使用其方法会发生什么。首先，改变你的导入方式，以便直接获取
    `logInfo` 和 `logError` 函数。
- en: Listing 3.49 inventoryController.js
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.49 inventoryController.js
- en: '[PRE58]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: ❶ Extracts the exported logInfo and logError functions, and binds them to same
    names
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 提取导出的 `logInfo` 和 `logError` 函数，并将它们绑定到相同的名称
- en: Then, instead of calling `logger.logInfo` or `logger.logError`, directly call
    the functions you have imported in the previous step. The `addToInventory` function,
    for example, would look like the following listing.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，而不是调用 `logger.logInfo` 或 `logger.logError`，直接调用你在上一步中导入的函数。例如，`addToInventory`
    函数看起来如下所示。
- en: Listing 3.50 inventoryController.js
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.50 inventoryController.js
- en: '[PRE59]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: ❶ Directly calls the logError function exported by the logger
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 直接调用由 logger 导出的 logError 函数
- en: ❷ Directly calls the logInfo function exported by the logger
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 直接调用由 logger 导出的 logInfo 函数
- en: If you start directly using these functions, you will see that your tests start
    failing. By looking at the diffs, you might see that none of your test doubles
    are recording any calls, as if they never took effect. To understand why that
    happens, let’s first understand how `spyOn` works.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你开始直接使用这些函数，你将看到你的测试开始失败。通过查看差异，你可能会发现你的测试替身没有记录任何调用，好像它们从未生效过。为了理解为什么会这样，让我们首先了解
    `spyOn` 的工作原理。
- en: When you use `spyOn`, you replace a reference to a function by a reference to
    a function wrapped in a test double, as shown by figure 3.11\. Using `spyOn` essentially
    does a reassignment to the specified property.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 `spyOn` 时，你用一个测试替身包装的函数的引用替换了一个函数的引用，如图 3.11 所示。使用 `spyOn` 实质上是对指定属性进行了重新赋值。
- en: '![](../Images/CH03_F11_DaCosta.png)'
  id: totrans-440
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH03_F11_DaCosta.png)'
- en: Figure 3.11 What happens when using `spyOn`
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.11 使用 `spyOn` 时会发生什么
- en: By importing and using a function from logger directly, you end up **not** accessing
    the reference that `jest.spyOn` has replaced. In this case, you get the reference
    to the original function right when you require it, but what Jest replaces is
    the reference in `logger`, as you can see in figure 3.12.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 通过直接导入和使用 logger 中的函数，你最终**不会**访问到 `jest.spyOn` 替换的引用。在这种情况下，你可以在 require 时立即获得原始函数的引用，但
    Jest 替换的是 `logger` 中的引用，如图 3.12 所示。
- en: '![](../Images/CH03_F12_DaCosta.png)'
  id: totrans-443
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH03_F12_DaCosta.png)'
- en: Figure 3.12 What happens when using `spyOn` when you have direct references
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.12 使用 `spyOn` 时直接引用会发生什么
- en: To solve this, you could simply go back to importing `logger` and accessing
    properties in it, but in many cases, you will not be able to do that. If you are
    importing modules that directly export functions or if you simply don’t want to
    assign your functions to an object, you need a better alternative. Here’s when
    `jest.mock` comes into play.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，你可以简单地回到导入 `logger` 并访问其属性，但在许多情况下，你可能无法这样做。如果你正在导入直接导出函数的模块，或者你只是不想将你的函数分配给一个对象，你需要更好的替代方案。这就是
    `jest.mock` 发挥作用的时候。
- en: The `jest.mock` function allows you to determine what should be given back when
    modules are imported. By using `jest.mock`, you could, for example, replace the
    original `logger` that `inventoryController` receives when importing `./logger`,
    as shown next.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: '`jest.mock` 函数允许你确定当模块被导入时应该返回什么。通过使用 `jest.mock`，例如，你可以替换 `inventoryController`
    在导入 `./logger` 时接收到的原始 `logger`，如下所示。'
- en: Listing 3.51 inventoryController.test.js
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.51 inventoryController.test.js
- en: '[PRE60]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: ❶ Causes importing the logger to resolve to an object whose logInfo and logError
    functions are test doubles
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 导致导入 logger 解析为一个对象，其 logInfo 和 logError 函数是测试替身
- en: Using `jest.mock` in this way will change what modules receive when they import
    `logger`, including your test. Instead of receiving the original `logger`, they
    will now get the value returned by the function you passed to `jest.mock`.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式使用 `jest.mock` 将会改变模块导入 `logger` 时接收到的值，包括你的测试。它们现在将获得你传递给 `jest.mock`
    的函数返回的值，而不是接收原始的 `logger`。
- en: Adding the code snippet above to your `inventoryController.test.js` should now
    make all tests pass again.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 将上述代码片段添加到 `inventoryController.test.js` 中，现在应该可以使所有测试再次通过。
- en: NOTE The `jest.fn()` function returns empty test doubles. They will record information
    about their usage but won’t have any canned behavior configured. Their API is
    the same as the one for test doubles created with `spyOn`. You can still use methods
    like `mockReturnValue` or `mockReturnValueOnce`.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：`jest.fn()` 函数返回空的测试替身。它们将记录有关其使用的信息，但不会配置任何预设行为。它们的 API 与使用 `spyOn` 创建的测试替身相同。你仍然可以使用
    `mockReturnValue` 或 `mockReturnValueOnce` 等方法。
- en: To get the original `logger` module within your test again, you can use `jest.requireActual`
    as follows.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 要在测试中再次获取原始的 `logger` 模块，你可以使用 `jest.requireActual` 如下所示。
- en: Listing 3.52 inventoryController.test.js
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.52 inventoryController.test.js
- en: '[PRE61]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: ❶ Imports the actual logger
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 导入实际的 logger
- en: The `jest.requireActual` function can be handy when you want to replace some
    of a module’s exports but not all of them. In that case, you can just merge the
    original module with the one containing your test doubles, as shown next.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想要替换模块的一些导出而不是所有导出时，`jest.requireActual` 函数很有用。在这种情况下，你可以将原始模块与包含你的测试替身的一个模块合并，如下所示。
- en: Listing 3.53 inventoryController.test.js
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.53 inventoryController.test.js
- en: '[PRE62]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: ❶ Causes importing the logger to resolve to the object returned by the callback
    function
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 导致导入日志记录器解析为回调函数返回的对象
- en: ❷ Imports the actual logger
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 导入实际的日志记录器
- en: ❸ Returns a new object by merging the properties in the original logger with
    an object whose logInfo property is a test double
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 通过合并原始日志记录器中的属性与一个对象（其 logInfo 属性是一个测试替身）来返回一个新的对象
- en: In case you need to mock a module too frequently, Jest has an alternative to
    help you avoid having to pass a replacement function to `jest.mock` every time
    you use it.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要频繁地模拟一个模块，Jest有一个替代方案可以帮助你避免每次使用 `jest.mock` 时都必须传递一个替换函数。
- en: By creating a directory named `__mocks__` in the directory immediately adjacent
    from where the module is, all the imports to that module will automatically resolve
    to the eponymous file within `__mocks__` once `jest.mock` is called for that file.
    This kind of mock is called a *manual mock*.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在模块所在目录的相邻目录中创建一个名为 `__mocks__` 的目录，一旦为该文件调用 `jest.mock`，所有对该模块的导入都将自动解析到
    `__mocks__` 中的同名文件。这种模拟称为 *手动模拟*。
- en: 'To avoid having to mock `logger` in multiple tests, you could, for example,
    restructure your application’s directory like this:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免在多个测试中模拟 `logger`，例如，你可以重新组织你的应用程序目录如下：
- en: '[PRE63]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Within `__mocks__/logger.js`, you must export a value that will replace the
    original logger, as shown next.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `__mocks__/logger.js` 中，你必须导出一个值来替换原始日志记录器，如下所示。
- en: Listing 3.54 __mocks__/logger.js
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.54 __mocks__/logger.js
- en: '[PRE64]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Once you have done this, instead of having to pass a replacement function to
    `jest.mock` in every file, you can simply call `jest.mock` and give it the logger’s
    path.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成这些，你就不必在每一个文件中传递一个替换函数给 `jest.mock`，你只需调用 `jest.mock` 并给出日志记录器的路径。
- en: Listing 3.55 inventoryController.test.js
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.55 inventoryController.test.js
- en: '[PRE65]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: ❶ Causes the imports to logger to resolve to the object exported by the __mocks__/logger.js
    file
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 导致导入日志记录器解析为 __mocks__/logger.js 文件导出的对象
- en: If you want to avoid calling `jest.mock` at all, you can add a property called
    `automock` to your `jest.config.js` file and set its value to `true`. The `automock`
    option, when turned on, will cause all imports to resolve to your manual mocks
    regardless of whether you have called `jest.mock` before.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你完全不想调用 `jest.mock`，你可以在你的 `jest.config.js` 文件中添加一个名为 `automock` 的属性，并将其值设置为
    `true`。当 `automock` 选项开启时，无论你是否之前调用过 `jest.mock`，所有导入都将解析为你的手动模拟。
- en: NOTE In this section, we have seen a few different ways to create a test double.
    To choose which one you are going to use, think about what is it that you are
    trying to “mock.”
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在本节中，我们看到了创建测试替身的一些不同方法。为了选择你将要使用的方法，考虑一下你试图“模拟”的是什么。
- en: If you are mocking an object’s property, you should probably use `jest.spyOn`.
  id: totrans-476
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你正在模拟一个对象的属性，你可能应该使用 `jest.spyOn`。
- en: If you are mocking an import, you should probably use `jest.mock`.
  id: totrans-477
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你正在模拟一个导入，你可能应该使用 `jest.mock`。
- en: In case you have to use the same replacement in multiple test files, you should,
    ideally, use a manual mock placed on the `__mocks__` folder.
  id: totrans-478
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你必须在多个测试文件中使用相同的替换，理想情况下，你应该在 `__mocks__` 文件夹上放置一个手动模拟。
- en: 3.4 Choosing what to test
  id: totrans-479
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.4 选择要测试的内容
- en: Louis’s bakery produces more desserts than any other place in town, with half
    the staff and twice the flavor. To keep up the pace and the quality, Louis has
    carefully thought about which quality control checks to perform and when. He is
    familiar with the Pareto principle and has focused on the 20% of tests which generate
    80% of the results.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 洛uis的面包店生产的甜点比镇上任何其他地方都多，员工数量减半，风味翻倍。为了保持速度和质量，洛uis仔细考虑了哪些质量控制检查要执行以及何时执行。他熟悉帕累托法则，并专注于产生80%结果的20%的测试。
- en: Like Louis, we, as engineers, can focus on the 20% of tests that produce 80%
    of the results. Knowing what to test is valuable, but it’s even more relevant
    to determine what *not* to test.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 与洛uis一样，我们作为工程师，可以专注于产生80%结果的20%的测试。知道要测试什么是有价值的，但确定不测试什么更为重要。
- en: Ideally, you should have tests that touch every single line of your application,
    run every single branch of execution, and assert on all the behavior you want
    to enforce. But, in reality, things are not as sweet as they are in Louis’s bakery.
    Real-world projects have tight deadlines and limited resources. It’s up to you
    to make your software as safe as possible and your costs as low as you can.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，你应该拥有触及你应用程序每一行代码、运行每个执行分支并断言你想要强制执行的所有行为的测试。但在现实中，事情并不像路易斯的面包店那样甜蜜。现实世界的项目有紧迫的截止日期和有限的资源。取决于你如何使你的软件尽可能安全，并尽可能降低成本。
- en: Having many tests can be great when it comes to quality assurance, but it might
    be too burdensome to update all of them. Refactoring a large codebase that has
    an immense amount of tests may require you to spend more time updating the tests
    than updating the codebase itself. It’s because of this cost that having few tests
    with stronger quality guarantees is better than having many tests that don’t instill
    confidence.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈到质量保证时，拥有许多测试可能很好，但更新所有这些测试可能过于繁重。重构一个拥有大量测试的大型代码库可能需要你花费更多的时间来更新测试，而不是更新代码库本身。正因为这种成本，拥有少量但质量保证更强的测试比拥有许多不令人信服的测试更好。
- en: 3.4.1 Don’t test third-party software
  id: totrans-484
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4.1 不要测试第三方软件
- en: Choosing responsible suppliers, for example, might have taken Louis some time,
    but it did save him many headaches. Because he can trust that his suppliers provide
    him with high-quality ingredients, he has to spend less time inspecting them when
    they get to the bakery.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 选择负责任的供应商，例如，可能花费了路易斯一些时间，但它确实节省了他很多麻烦。因为他可以相信他的供应商为他提供高质量的原料，所以他不必花太多时间检查它们到达面包店时的情况。
- en: In the same way that Louis is picky about his suppliers, we should be extremely
    picky about the third-party software we use. As long as other people’s software
    is well-tested, we don’t have to spend time testing it ourselves. **You should
    test only the software that *you* write**.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 就像路易斯对他的供应商很挑剔一样，我们也应该对我们使用的第三方软件非常挑剔。只要其他人的软件经过良好测试，我们就不必花时间自己测试它。**你应该只测试你写的软件**。
- en: As we have seen in chapter 2, it is advisable to have end-to-end tests that
    make sure that you are using third-party software as you should, but you should
    *not* write tests that cover *only* the third-party piece of software itself.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在第 2 章中看到的，拥有确保你正确使用第三方软件的端到端测试是明智的，但你**不应该**只编写覆盖第三方软件本身的测试。
- en: Let’s again consider the `addItem` function we saw in chapter 2, shown in the
    next listing. This function adds an item to a cart by inserting a row into the
    database.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次考虑第 2 章中看到的`addItem`函数，该函数在下一个列表中展示。这个函数通过在数据库中插入一行来向购物车添加一个项目。
- en: Listing 3.56 cart.js
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.56 cart.js
- en: '[PRE66]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: What you *don’t* want to do in this case is test if `knex` is inserting items
    in the database. That’s the responsibility of the library’s authors.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你**不**想测试`knex`是否在数据库中插入项目。这是库作者的职责。
- en: 'In this case, you have the following two options: a) replace `knex` with a
    test double, and check if it’s called correctly; or b) spin up a test database,
    call `createCart`, and check the database to see if the row was inserted as you
    expected.'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你有以下两种选择：a) 用测试替身替换`knex`，并检查它是否被正确调用；或者 b) 启动一个测试数据库，调用`createCart`，并检查数据库以查看行是否如预期那样被插入。
- en: In neither of these cases do you test `knex` itself. You **always** focus on
    **your** use of the library. Testing other people’s libraries is a wasted effort.
    It almost always means that you are spending time to write tests that already
    exist elsewhere.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，你都不会测试`knex`本身。你**始终**关注**你**对库的使用。测试其他人的库是徒劳的。这几乎总是意味着你正在花费时间编写已经存在于其他地方的测试。
- en: Even if the tests you add for the library do not exist in the project’s own
    repository, it’s better to submit them to the upstream version than to keep them
    in your own codebase. When you add tests to the upstream project, everyone using
    it benefits, including you, who won’t be the only one responsible for keeping
    them up-to-date. Collaboration creates a virtuous cycle of safe and well-tested
    software.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你为库添加的测试在项目的自身仓库中不存在，将其提交到上游版本也比保留在你自己的代码库中更好。当你将测试添加到上游项目中时，所有使用它的人都会受益，包括你，你将不会是唯一一个负责保持它们更新的人。协作创造了安全且经过良好测试的软件的良性循环。
- en: '3.4.2 To mock, or not to mock: That’s the question'
  id: totrans-495
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4.2 要模拟，还是不要模拟：这是一个问题
- en: In the ideal world of tests, every project should have tests with different
    levels of isolation. You should have unit tests, which isolate a function as much
    as possible. You should have integration tests, which have some degree of mocking
    but still verify whether different pieces of your software work together. And
    you should have end-to-end tests, which barely do any mocking, if at all.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 在理想的测试世界中，每个项目都应该有不同隔离级别的测试。你应该有单元测试，尽可能隔离一个函数。你应该有集成测试，有一定的模拟程度，但仍然验证你的软件的不同部分是否可以一起工作。你还应该有端到端测试，几乎不做任何模拟，如果有的话。
- en: In reality, we usually can’t afford to be so methodical about the way we write
    tests, and, therefore, we have to decide which parts of your code we will isolate
    and which we won’t.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实中，我们通常无法负担得起如此细致地编写测试，因此我们必须决定哪些代码部分我们将隔离，哪些不会。
- en: Again, consider the same `addItem` function we’ve seen in the previous section.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 再次考虑我们在上一节中看到的相同的`addItem`函数。
- en: Listing 3.57 cart.js
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.57 cart.js
- en: '[PRE67]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Because we don’t want to test `knex`, as we’ve already mentioned, we can choose
    to either replace `knex` with a test double—a “mock”—or call the function and
    then check the database directly.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们不希望测试`knex`，正如我们之前提到的，我们可以选择用测试替身——“模拟”来替换`knex`，或者调用函数然后直接检查数据库。
- en: 'In the ideal world, we’d have time to write both tests: one with the test double
    and one without. In the real world, however, we must choose which one delivers
    the most value for the lowest cost in time and effort.'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 在理想的世界里，我们会有时间编写两个测试：一个带有测试替身，一个不带。然而，在现实世界中，我们必须选择哪个在时间和精力上成本最低，同时提供最大价值。
- en: In this case, mocking `knex` would require a tremendous amount of work. For
    that, you would need to create a piece of software that essentially emulates a
    database and replicates how `knex` interacts with it.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，模拟`knex`需要大量的工作。为此，你需要创建一个本质上模拟数据库并复制`knex`与之交互的软件。
- en: Creating a test double for `knex` is not only time-consuming but also error-prone.
    It would be so complicated that you would probably need tests for your tests.
    And then, when there’s an update in `knex`, you’d have to update your test double,
    too.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 为`knex`创建一个测试替身不仅耗时，而且容易出错。这会变得非常复杂，你可能还需要为你的测试编写测试。然后，当`knex`有更新时，你也必须更新你的测试替身。
- en: Now consider how hard it would be to *not* replace `knex` with a test double.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑一下如果不替换`knex`为测试替身会有多难。
- en: Without a test double, you would have to spin a database and make sure that
    your test is well isolated from others. Those extra steps would make the test
    a bit slower, but they make it way easier and quicker to write.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 没有测试替身，你将不得不启动数据库并确保你的测试与其他测试很好地隔离。这些额外的步骤会使测试稍微慢一些，但它们使编写测试变得容易得多，也快得多。
- en: Look, for example, at the test we’ve written for this function in chapter 2.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，看看我们在第2章为这个函数编写的测试。
- en: Listing 3.58 cart.js
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.58 cart.js
- en: '[PRE68]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: This test is almost as simple as a test that checks only the return value of
    a function. The only difference is that instead of saving the returned value to
    a variable, you have to access the database to get the result before you can check
    it.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试几乎和只检查函数返回值的测试一样简单。唯一的区别是，你必须在检查之前访问数据库以获取结果，而不是将返回值保存到变量中。
- en: Comparing the difficulties of mocking `knex` and the small benefits it produces
    with how easy it is to write an integration test and the immense value it generates,
    it’s clear that an integration test is the best option for this scenario.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 比较模拟`knex`的难度和它产生的小好处，以及编写集成测试的容易程度和它产生的巨大价值，很明显，集成测试是这种情况下的最佳选择。
- en: As a rule of thumb, **if mocking a dependency is too complicated, don’t mock
    it**.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一条经验法则，**如果模拟依赖项太复杂，就不要模拟它**。
- en: Replace only the parts of your software that are either easy to replace or that
    can’t be used in your tests at all, such as integration with paid third-party
    services.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 只替换你的软件中容易替换或根本不能用于测试的部分，例如与付费第三方服务的集成。
- en: Being able to write tests with different levels of isolation is great for obtaining
    precise feedback, but it creates a large amount of unnecessary overlap. These
    overlapping tests then become somewhat redundant and add costs without providing
    significant benefits when it comes to quality.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 能够编写不同隔离级别的测试对于获得精确的反馈非常好，但它会创建大量不必要的重叠。这些重叠的测试变得有些多余，并且在质量方面没有提供显著的好处时，会增加成本。
- en: How much mocking is too much mocking?
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟过多是多少？
- en: When you mock a particular layer of your application, you prevent your tests
    from reaching everything underneath it.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 当你模拟应用程序的某个特定层时，你会阻止你的测试触及它下面的所有内容。
- en: Consider, for example, that you have a route that uses the `cartController`
    module. The `cartController` uses a `notifier` module, which, in turn, calls a
    third-party API.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你有一个使用`cartController`模块的路由。`cartController`使用一个`notifier`模块，该模块反过来调用第三方API。
- en: By mocking `CartController`, you are choosing *not* to test all the layers underneath
    it; you are not running code that’s in the notifier module or in the third-party
    API.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 通过模拟`CartController`，你选择**不**测试其下所有层；你不会运行通知模块或第三方API中的代码。
- en: The more superficial the layer you choose to mock, the more you choose *not*
    to test. The more you want to hide complexity, the earlier you should mock.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 你选择的模拟层越表面，你选择**不**测试的就越多。你越想隐藏复杂性，就越早应该进行模拟。
- en: Mocking can be especially beneficial when working with legacy applications or
    applications that have no tests, for example. By using `mocks`, you can hide the
    layers that you haven’t yet refactored and therefore avoid testing code that is
    not ready to be tested yet. In figure 3.13, you can see which layers get hidden
    depending on where you place a test-double.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理遗留应用程序或没有测试的应用程序时，模拟特别有益。通过使用`mocks`，你可以隐藏尚未重构的层，从而避免测试尚未准备好的代码。在图3.13中，你可以看到根据测试替身放置的位置，哪些层被隐藏。
- en: '![](../Images/CH03_F13_DaCosta.png)'
  id: totrans-521
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/CH03_F13_DaCosta.png)'
- en: Figure 3.13 How much complexity is hidden by mocking each layer of your application
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.13 通过模拟应用程序的每一层隐藏的复杂性
- en: A downside of writing mocks is that they distance your test scenarios from real
    use-case scenarios. Therefore, tests that have more mocks provide weaker quality
    guarantees and make you less confident.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 编写模拟的一个缺点是它们将测试场景与实际用例场景隔离开来。因此，包含更多模拟的测试提供较弱的质量保证，并使你对自己的信心降低。
- en: In general, too much mocking is when you mock pieces of software that you could
    easily test *without* a mock.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，过多的模拟是指你可以不使用模拟就轻松测试的软件部分。
- en: 3.4.3 When in doubt, choose integration tests
  id: totrans-525
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.4.3 当有疑问时，选择集成测试
- en: Unit tests provide blazing fast and extremely precise feedback, but they don’t
    provide us with strong quality guarantees. End-to-end tests, on the other hand,
    are the strongest quality guarantees we can get, but they usually take a lot of
    time to run, provide generic feedback, and tend to be time-consuming to write.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试提供极快且极其精确的反馈，但它们不提供强大的质量保证。另一方面，端到端测试是我们能得到的最强质量保证，但它们通常需要花费很多时间来运行，提供通用的反馈，并且编写起来往往很耗时。
- en: Somewhere in between unit tests and end-to-end tests are *integration tests*,
    which can give us the best of both worlds. They provide considerably strong quality
    guarantees, run reasonably fast, and tend to be quick to write. Sometimes, integration
    tests are even quicker to write than more isolated tests, given that we have to
    do less mocking.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 在单元测试和端到端测试之间的是**集成测试**，它可以给我们带来两全其美的效果。它们提供了相当强的质量保证，运行速度合理，并且编写起来通常很快。有时，由于我们不需要进行太多的模拟，集成测试甚至比更孤立的测试编写得更快。
- en: Once again, for your `addItem` function, think about what each kind of test
    would have to do.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，对于你的`addItem`函数，考虑每种测试类型需要做什么。
- en: Listing 3.59 cart.js
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.59 cart.js
- en: '[PRE69]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: A very isolated **unit test** would mock `knex` and check only whether `addItem`
    uses `knex` correctly.
  id: totrans-531
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个非常孤立的**单元测试**将模拟`knex`并仅检查`addItem`是否正确使用`knex`。
- en: An **integration test** would call `addItem` and check the database.
  id: totrans-532
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个**集成测试**将调用`addItem`并检查数据库。
- en: A full-blown **end-to-end test** would spin up the server, open a browser, click
    the button that adds items to a cart, and check the cart listing page.
  id: totrans-533
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个完整的**端到端测试**将启动服务器，打开浏览器，点击添加商品到购物车的按钮，并检查购物车列表页面。
- en: In this case, a unit test would not provide solid guarantees. It would also
    be hard to write due to all the mocking you’d have to do, as I previously mentioned.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，单元测试不会提供稳固的保证。由于你将不得不进行所有这些模拟，因此编写它也会很困难，正如我之前提到的。
- en: An end-to-end test would instill high confidence that the software works. But
    it would be challenging to write and take a lot of time to run.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 端到端测试可以增强对软件工作的信心。但编写它和运行它都会很具挑战性，并且会花费很多时间。
- en: The integration test, on the other hand, is quick to write, because we don’t
    have to use any mocks, and runs way faster than an end-to-end test. Because this
    test touches the database, it creates a secure guarantee that the function will
    work as expected. It is the kind of test that costs less to write and provides
    the most significant benefit.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，集成测试编写起来很快，因为我们不需要使用任何模拟，而且它的运行速度比端到端测试快得多。因为这个测试会触及数据库，它为函数按预期工作提供了一个安全的保证。这是一种编写成本较低且提供最大益处的测试类型。
- en: Integration tests usually balance cost and benefit better, so, whenever in doubt,
    choose integration tests.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试通常在成本和收益之间取得更好的平衡，所以，在不确定的情况下，选择集成测试。
- en: NOTE Ideally, you should try to stick to the pyramid shape, but also having
    a high proportion of integration tests can help you cut costs.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意** 理想情况下，你应该尽量保持金字塔形状，但拥有高比例的集成测试也可以帮助你降低成本。'
- en: 3.5 Code coverage
  id: totrans-539
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.5 代码覆盖率
- en: Code coverage is a metric that indicates how much of your code is executed when
    you run tests.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 代码覆盖率是一个指标，表示当你运行测试时，你的代码执行了多少。
- en: To understand how code coverage works, think about which lines of the `removeFromCart`
    function run depending on which test you execute.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解代码覆盖率是如何工作的，考虑一下根据你执行哪个测试，`removeFromCart`函数的哪些行会被执行。
- en: Listing 3.60 Cart.test.js
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.60 Cart.test.js
- en: '[PRE70]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: If you run a test that passes a `quantity` argument whose type is a `number`,
    for example, none of the lines within the first `if` statement will run.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行一个传递`quantity`参数的测试，且该参数的类型是`number`，例如，第一个`if`语句内的所有行都不会执行。
- en: Listing 3.61 inventoryController.test..js
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.61 inventoryController.test..js
- en: '[PRE71]'
  id: totrans-546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: ❶ Replaces logger with a test double to make sure the test’s output won’t be
    polluted with the logger’s messages
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 用测试替身替换记录器，以确保测试的输出不会被记录器的消息污染
- en: ❷ A test that covers approximately 80% of the lines in the addToInventory function
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 覆盖addToInventory函数中大约80%的行的测试
- en: If you consider this function exclusively, you’ll notice that your test covers
    approximately 80% of the `addToInventory` function’s lines. In case any invalid
    statements are within those lines, your tests will be able to catch them. If,
    however, you have an invalid statement in the 20% of lines that are uncovered,
    your tests won’t detect it.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只考虑这个函数，你会注意到你的测试覆盖了大约80%的`addToInventory`函数的行。如果这些行中有任何无效语句，你的测试将能够捕获它们。然而，如果你在未被覆盖的20%的行中有无效语句，你的测试将无法检测到。
- en: By looking at the parts of your code your tests aren’t reaching, you can detect
    possible blind spots and create tests to cover them.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看你的测试没有触及到的代码部分，你可以检测到可能的盲点并创建测试来覆盖它们。
- en: In this case, for example, you can write a test that passes a string as the
    second argument to `addItemToCart` so that you cover the remaining lines of that
    function, as shown next.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在这种情况下，你可以编写一个测试，将字符串作为`addItemToCart`的第二个参数传递，以便覆盖该函数的剩余行，如下所示。
- en: Listing 3.62 inventoryController.test..js
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 3.62 inventoryController.test..js
- en: '[PRE72]'
  id: totrans-553
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: ❶ A test that covers approximately 75% of the lines in the addToInventory function
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 覆盖addToInventory函数中大约75%的行的测试
- en: ❷ A test that covers the remaining lines in the addToInventory function
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 覆盖addToInventory函数中剩余行的测试
- en: By paying attention to your test’s coverage, you were able to detect a blind
    spot in your test suite and make it more thorough.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 通过关注你的测试覆盖率，你能够检测到测试套件中的盲点并使其更加全面。
- en: Important By measuring which parts of your code are covered and, most importantly,
    which aren’t, you can make sure that all the possible branches of execution run
    during your automated testing process.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要** 通过测量代码的哪些部分被覆盖了，最重要的是，哪些没有被覆盖，你可以确保在自动化测试过程中所有可能的执行分支都运行了。'
- en: 3.5.1 Automated coverage reports
  id: totrans-558
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.5.1 自动化覆盖率报告
- en: To see a report that indicates exactly which parts of the code your tests execute,
    run the project’s Jest executable with the `--coverage` option.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看一个报告，该报告显示你的测试执行了代码的哪些部分，请运行项目的Jest可执行文件并使用`--coverage`选项。
- en: TIP If you’re using NPM scripts to run your tests, as I recommend, you can obtain
    coverage reports with `npm test -- --coverage`.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: '**提示** 如果你使用NPM脚本来运行测试，正如我推荐的那样，你可以使用`npm test -- --coverage`来获取覆盖率报告。'
- en: Once Jest finishes running tests and collecting data about the parts of code
    your tests are executing, it will create a folder named `coverage` in the root
    of your project. This new folder contains a complete coverage report.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦Jest完成测试运行并收集有关你的测试正在执行的代码部分的数据，它将在你的项目根目录下创建一个名为`coverage`的文件夹。这个新文件夹包含完整的覆盖率报告。
- en: Finally, to see which parts of your code are covered, try using your browser
    to open the `index.html` within the `lcov-report` folder that’s inside the `coverage`
    directory. This report will highlight in red any pieces of code not executed by
    your tests.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，要查看哪些代码部分被覆盖，请尝试使用浏览器打开`coverage`目录中`lcov-report`文件夹内的`index.html`。此报告将以红色突出显示任何未由您的测试执行的代码片段。
- en: TIP In addition to using these reports to understand your blind spots, you can
    use the other “machine-friendly” files that Jest generates to keep track of your
    coverage using automated tools.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: TIP 除了使用这些报告来了解您的盲点之外，您还可以使用Jest生成的其他“机器友好”文件来使用自动化工具跟踪您的覆盖率。
- en: You could, for example, upload your coverage reports to a third-party tool that
    allows you to track how your code coverage changed over time.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您可以将覆盖率报告上传到第三方工具，该工具允许您跟踪代码覆盖率随时间的变化。
- en: Furthermore, you could use version-control checks, about which you’ll learn
    in chapter 12, to prevent others from merging code that reduces the amount of
    code covered by tests.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您可以使用版本控制检查（您将在第12章中学习），以防止其他人合并减少测试覆盖代码量的代码。
- en: 3.5.2 Coverage types
  id: totrans-566
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.5.2 覆盖率类型
- en: When automatically generating code coverage reports with Jest, you should have
    seen a table at the bottom of your test’s summary indicating the percentage of
    code covered in the target files.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用Jest自动生成代码覆盖率报告时，您应该在测试摘要的底部看到一个表格，指示目标文件中代码的覆盖率百分比。
- en: 'That table contains four measurements of coverage: statement coverage, branch
    coverage, function coverage, and lines coverage. All of these measurements represent
    which parts of your code your tests execute, but their units of measurement are
    different, as follows:'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 那个表格包含了四个覆盖率度量：语句覆盖率、分支覆盖率、函数覆盖率和行覆盖率。所有这些度量都代表了您的测试执行了代码的哪些部分，但它们的度量单位不同，如下所示：
- en: '**Statement coverage** considers the total number of statements in your code
    and how many of them run.'
  id: totrans-569
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**语句覆盖率**考虑了您代码中的总语句数以及运行了多少条语句。'
- en: '**Branch coverage** considers how many execution paths your tests have gone
    through considering the total number of paths that could’ve been taken.'
  id: totrans-570
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分支覆盖率**考虑了您的测试通过了多少执行路径，考虑到可能采取的总路径数。'
- en: '**Function coverage** considers how many functions run out of the total number
    of functions your code contains.'
  id: totrans-571
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函数覆盖率**考虑了在您的代码中运行的函数数量与代码中包含的总函数数量之间的比例。'
- en: '**Line coverage** considers how many lines of code your tests execute, regardless
    of how many statements they contain or in which execution paths these lines are.'
  id: totrans-572
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**行覆盖率**考虑了您的测试执行了多少行代码，而不管这些行包含多少语句或这些行位于哪些执行路径上。'
- en: All of these types of coverage are important, but the one to which I pay the
    most attention tends to be *branch* coverage.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些类型的覆盖率都很重要，但我最关注的是*分支*覆盖率。
- en: Branch coverage indicates that, during my tests, my code has gone through all
    the possible paths of execution it could’ve gone through. Therefore, it guarantees
    that whenever my code has to “make a choice,” all the possible choices are validated.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 分支覆盖率表明，在我的测试中，我的代码已经通过了它可能通过的所有可能的执行路径。因此，它保证了每当我的代码需要“做出选择”时，所有可能的选择都得到了验证。
- en: 3.5.3 What coverage is good for and what it isn’t
  id: totrans-575
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.5.3 覆盖率的好处和坏处
- en: '**Code coverage does *not* indicate how good your tests are**. It’s perfectly
    possible to cover 100% of your code and still let bugs slip by.'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码覆盖率**并不**表明您的测试有多好**。完全有可能覆盖100%的代码，但仍然让错误溜走。'
- en: Imagine, for example, that you have a function that sums two numbers if they’re
    both even and divides one by the other if at least one is odd, as shown next.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设您有一个函数，如果两个数都是偶数则求和，如果至少一个是奇数则相除，如下所示。
- en: Listing 3.63 math.js
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.63 math.js
- en: '[PRE73]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: If you write tests that run both of this function’s execution branches but don’t
    perform any assertions, you will have 100% coverage, but you won’t catch any bugs
    you may introduce.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您编写的测试同时运行了这个函数的两个执行分支，但没有进行任何断言，那么您将获得100%的覆盖率，但您可能引入的错误将不会被捕获。
- en: Listing 3.64 math.test.js
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 列表3.64 math.test.js
- en: '[PRE74]'
  id: totrans-582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: In case you change this function so that it always returns `"cheesecake"`, for
    example, your coverage will remain at 100%, and your tests will still pass.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您更改此函数，使其始终返回`"cheesecake"`，例如，您的覆盖率将保持100%，并且您的测试仍然会通过。
- en: '**Without making the necessary observations by writing assertions, you may
    have a high coverage but not catch any bugs**.'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: '**如果不通过编写断言进行必要的观察，您可能拥有高覆盖率，但无法捕获任何错误**。'
- en: Additionally, your coverage may indicate your tests run all of your code’s possible
    execution branches but not all the possible faulty inputs.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你的覆盖率可能表明你的测试运行了代码的所有可能的执行分支，但不是所有可能的错误输入。
- en: If you passed `1` as the first argument to this function and `0` as the second,
    for example, your function would return `Infinity`, which may not be the result
    you desire.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你将`1`作为这个函数的第一个参数，将`0`作为第二个参数，那么你的函数将返回`Infinity`，这可能不是你想要的结果。
- en: Coverage represents how much of your code your tests cover, not how many of
    the possible inputs it passes. Therefore, you can’t guarantee you will find bugs
    unless you test *all* possible inputs, which is a pretty difficult task.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖率代表你的测试覆盖了你代码的多少，而不是它通过了多少可能的输入。因此，除非你测试了所有可能的输入，否则你不能保证你会找到错误，而这是一项相当困难的任务。
- en: TIP To understand why testing all possible inputs is difficult, if not impossible,
    think about how many different numbers you can represent in JavaScript.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士：为了理解为什么测试所有可能的输入是困难的，如果不是不可能的，想想JavaScript中你可以表示多少不同的数字。
- en: Another problem with coverage measurements is that they indicate which possible
    execution branches run, but not all the possible combinations of those branches.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖率测量的另一个问题是，它们表明了哪些可能的执行分支运行了，但没有表明所有这些分支的可能组合。
- en: Suppose a specific combination of execution paths throws an error. In that case,
    you may not see it, because even though all branches are covered, the particular
    combination of branches necessary for the bug to occur may not run.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 假设特定的执行路径组合抛出错误。在这种情况下，你可能看不到它，因为尽管所有分支都被覆盖了，但导致错误发生的特定分支组合可能没有运行。
- en: Because of these reasons, **code coverage on its own is a bad metric**. It may
    show which parts of a program’s code are covered, but it doesn’t indicate which
    of its possible *behaviors* are covered, as James O. Coplien explains in his brilliant
    article “Why Most Unit Testing Is Waste” ([https://rbcs-us.com/site/assets/files/1187/why-most-unit-testing-is-waste.pdf](https://rbcs-us.com/site/assets/files/1187/why-most-unit-testing-is-waste.pdf)).
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些原因，**覆盖率本身是一个糟糕的指标**。它可能显示了程序代码的哪些部分被覆盖了，但它并没有表明它的哪些可能的*行为*被覆盖了，正如詹姆斯·O·科普林在他的精彩文章“为什么大多数单元测试都是浪费”中解释的那样（[https://rbcs-us.com/site/assets/files/1187/why-most-unit-testing-is-waste.pdf](https://rbcs-us.com/site/assets/files/1187/why-most-unit-testing-is-waste.pdf))。
- en: 'I define 100% coverage as having examined all possible combinations of all
    possible paths through all methods of a class, having reproduced every possible
    configuration of data bits accessible to those methods, at every machine language
    instruction along the paths of execution. Anything else is a heuristic about which
    absolutely no formal claim of cor-rectness can be made. The number of possible
    execution paths through a function is mode-rate: let’s say 10\. The cross product
    of those paths with the possible state configurations of all global data (including
    instance data which, from a method scope, are global) and formal parameters is
    indeed very large. And the cross product of that number with the pos-sible sequencing
    of methods within a class is countably infinite. If you plug in some typical numbers
    you’ll quickly conclude that you’re lucky if you get better coverage than 1 in
    1012.'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 我将100%覆盖率定义为检查了所有可能的方法路径的所有可能组合，复制了所有方法可访问的数据位的所有可能配置，在执行路径上的每条机器语言指令。其他任何东西都只是关于正确性的非正式断言。一个函数中可能的执行路径数量是有限的：比如说10。这些路径与所有全局数据（包括实例数据，从方法范围来看是全局的）和形式参数的可能状态配置的笛卡尔积确实非常大。而且，这个数字与类内方法可能顺序的笛卡尔积是可数的无限大。如果你输入一些典型的数字，你很快就会得出结论，如果你能获得比10^12更好的覆盖率，那你就很幸运了。
- en: —James O. Coplien
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: —詹姆斯·O·科普林
- en: Important The only guarantee code coverage gives you is that your program *can*
    run, not that it runs correctly.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示：代码覆盖率给你的唯一保证是程序*可以*运行，而不是它运行正确。
- en: Instead of using code coverage as a metric on its own, I use it to understand
    which parts of my program I’ve forgotten to cover and to ensure that my team is
    always progressing toward *more* coverage, not *less*.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 我不单独使用覆盖率作为指标，而是用它来了解我忘记覆盖程序中的哪些部分，并确保我的团队能够始终朝着*更多*覆盖率而不是*更少*覆盖率的方向前进。
- en: Summary
  id: totrans-596
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Organizing test suites
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 组织测试套件
- en: Organize your tests by nesting different groups of tests within `describe` blocks.
  id: totrans-598
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过在`describe`块内嵌套不同的测试组来组织你的测试。
- en: Nesting your tests into multiple blocks enables you to encapsulate variables,
    functions, and even hooks, which become relative to the block of tests in which
    they are placed.
  id: totrans-599
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将测试嵌套到多个块中可以使你封装变量、函数甚至钩子，这些在它们放置的测试块中成为相对的。
- en: When organizing your tests, avoid overlap. Each test should assert on a single
    aspect of the unit under test so that it generates accurate feedback.
  id: totrans-600
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在组织测试时，避免重叠。每个测试都应该断言被测试单元的单一方面，以便生成准确的反馈。
- en: Tests in different files will, by default, run in parallel. Running tests in
    parallel can make tests run faster and, therefore, incentivizes developers to
    run them more often.
  id: totrans-601
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下，不同文件中的测试将并行运行。并行运行测试可以使测试运行得更快，因此鼓励开发者更频繁地运行它们。
- en: Any particular test should not depend on any others. Tests should be atomic
    so that you can easily determine the cause of a bug and whether you have a problem
    in your tests or your application code.
  id: totrans-602
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何特定的测试都不应该依赖于其他测试。测试应该是原子的，这样你就可以轻松地确定错误的起因，以及你是否在测试或应用程序代码中存在问题。
- en: Writing good assertions
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 编写好的断言
- en: Always make sure that your tests run assertions. A test without assertions does
    not check whether the unit under test does what it’s supposed to do. It ensures
    only that the application code can run and nothing else.
  id: totrans-604
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 总是要确保你的测试运行断言。没有断言的测试不会检查被测试单元是否做了它应该做的事情。它只能确保应用程序代码可以运行，而不会做其他事情。
- en: Assertions should allow as few results to pass as possible. Ideally, an assertion
    should allow only a single result to pass.
  id: totrans-605
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 断言应该允许尽可能少的通过结果。理想情况下，断言应该只允许一个结果通过。
- en: Loose assertions—assertions that allow multiple outputs to pass—can be useful
    to deal with nondeterminism, like when dealing with true randomness or dates.
  id: totrans-606
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 松散的断言——允许多个输出通过——可以用来处理非确定性，例如处理真正的随机性或日期。
- en: Circular assertions use parts of your application to test itself. They can cause
    problems because if the part you’re using in your test has a bug, they will also
    produce an incorrect expected output.
  id: totrans-607
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 循环断言使用应用程序的一部分来测试自身。这可能会引起问题，因为如果你在测试中使用的部分有错误，它们也会产生不正确的预期输出。
- en: 'Test doubles: Mocks, stubs, and spies'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 测试双倍：模拟、存根和间谍
- en: Mocks, stubs, and spies are objects used to modify and replace parts of your
    application to ease or enable testing.
  id: totrans-609
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟、存根和间谍是用于修改和替换应用程序部分以简化或启用测试的对象。
- en: Whereas spies just record data related to the usage of a function, stubs allow
    you to modify its behavior by providing alternative results or even alternative
    implementations.
  id: totrans-610
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与间谍只记录与函数使用相关的数据不同，存根允许你通过提供替代结果或甚至替代实现来修改其行为。
- en: Choosing what to test
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 选择要测试的内容
- en: Having a large number of tests is helpful to create reliable quality guarantees,
    but they can be burdensome to update. Therefore, it’s as crucial to determine
    what to test as it is to determine what *not* to.
  id: totrans-612
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拥有大量的测试对于创建可靠的质量保证有帮助，但它们可能难以更新。因此，确定要测试的内容与确定不要测试的内容一样重要。
- en: Avoid testing third-party software. That’s the responsibility of the third-party
    software’s authors. If you want to add tests for it, contribute to the library’s
    repository instead, so that everyone benefits from it, including you, who won’t
    have to maintain those tests on your own.
  id: totrans-613
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免测试第三方软件。这是第三方软件作者的职责。如果你想为它添加测试，请向库的存储库做出贡献，这样每个人都能从中受益，包括你，你不必自己维护这些测试。
- en: More mocking makes tests less similar to reality and, therefore, less valuable.
    If mocking is too difficult, or if it will cause your test not to be valuable
    because it touches very few parts of your application, avoid mocking.
  id: totrans-614
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多的模拟会使测试与现实相差更远，因此价值更低。如果模拟太困难，或者如果它会导致你的测试变得没有价值，因为它只触及应用程序的很少部分，请避免模拟。
- en: Different kinds of tests can generate a significant amount of overlap. If you
    have to choose only one type of test, it’s better to choose an integration test.
    Integration tests run reasonably quickly, tend to be easy to write, and provide
    reliable quality guarantees.
  id: totrans-615
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同的测试类型可以生成大量的重叠。如果你必须只选择一种测试类型，最好选择集成测试。集成测试运行得相对较快，编写起来通常比较容易，并提供可靠的质量保证。
- en: Code coverage
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 代码覆盖率
- en: Code coverage is a metric that indicates how much of your code is executed when
    you run tests.
  id: totrans-617
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码覆盖率是一个指标，表示当你运行测试时，你的代码执行了多少。
- en: By measuring code coverage, you can understand which parts of your code you’ve
    forgotten to test and, therefore, add the necessary validations for them.
  id: totrans-618
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过测量代码覆盖率，您可以了解哪些代码部分您忘记测试，因此，为它们添加必要的验证。
- en: Code coverage can be measure against statements, branches, functions, or lines.
  id: totrans-619
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码覆盖率可以针对语句、分支、函数或行进行测量。
- en: Having a high percentage of code coverage does *not* mean your tests are good.
    It’s possible to have 100% of your code covered and still let bugs slip through
    because code coverage doesn’t take into account all the possible inputs that can
    be passed to your program or all the possible combinations of its execution branches.
  id: totrans-620
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高代码覆盖率*并不*意味着您的测试是好的。即使您的代码100%被覆盖，仍然可能让错误滑过，因为代码覆盖率没有考虑到可以传递给程序的所有可能的输入或其执行分支的所有可能的组合。
- en: You should use code coverage reports to understand which pieces of code you’ve
    forgotten to test and to guarantee your team is committing tests and progressing
    toward *more* coverage, not to determine the quality of your tests.
  id: totrans-621
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您应该使用代码覆盖率报告来了解哪些代码片段您忘记测试，并确保您的团队正在提交测试，并朝着*更多*的覆盖率前进，而不是确定测试的质量。
