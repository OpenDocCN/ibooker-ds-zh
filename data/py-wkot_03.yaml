- en: 3 Lists and tuples
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3 列表和元组
- en: Consider a program that has to work with documents, keep track of users, log
    the IP addresses that have accessed a server, or store the names and birth dates
    of children in a school. In all of these cases, we’re storing many pieces of information.
    We’ll want to display, search through, extend, and modify this information.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个需要处理文档、跟踪用户、记录访问服务器的IP地址或存储学校中孩子的姓名和出生日期的程序。在这些所有情况下，我们都在存储大量的信息。我们希望显示、搜索、扩展和修改这些信息。
- en: These are such common tasks that every programming language supports *collections*,
    data structures designed for handling such cases. Lists and tuples are Python’s
    built-in collections. Technically, they differ in that lists are mutable, whereas
    tuples are immutable. But in practice, lists are meant to be used for sequences
    of the same type, whereas tuples are meant for sequences of different types.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这些任务如此常见，以至于每种编程语言都支持*集合*，这是为处理此类情况而设计的特定数据结构。列表和元组是Python的内置集合。从技术上讲，它们之间的区别在于列表是可变的，而元组是不可变的。但在实践中，列表旨在用于相同类型的序列，而元组旨在用于不同类型的序列。
- en: For example, a series of documents, users, or IP addresses would be best stored
    in a list--because we have many objects of the same type. A record containing
    someone’s name and birth date would be best stored in a tuple, because the name
    and birth date are of different types. A bunch of such name-birth date tuples,
    however, could be stored in a list, because it would contain a sequence of tuples--and
    the tuples all would be of the same type.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一系列文档、用户或IP地址最好存储在列表中——因为我们有许多相同类型的对象。包含某人姓名和出生日期的记录最好存储在元组中，因为姓名和出生日期是不同类型的。然而，这样的一组姓名-出生日期元组可以存储在列表中，因为它将包含元组的序列——并且这些元组都是相同类型的。
- en: Because they’re mutable, lists support many more methods and operators. After
    all, there’s not much you can do with a tuple other than pass it, retrieve its
    elements, and make some queries about its contents. Lists, by contrast, can be
    extended, contracted, and modified, as well as searched, sorted, and replaced.
    So you can’t add a person’s shoe size to the name-birth date tuple you’ve created
    for them. But you can add a bunch of additional name-birth date tuples to the
    list you’ve created, as well as remove elements from that list if they’re no longer
    students in the school.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它们是可变的，列表支持更多的方法和运算符。毕竟，除了传递、检索其元素和对其内容进行一些查询之外，你几乎不能对元组做任何事情。相比之下，列表可以被扩展、收缩和修改，也可以进行搜索、排序和替换。所以你不能将一个人的鞋码添加到你为他们创建的姓名-出生日期元组中。但是，你可以将一些额外的姓名-出生日期元组添加到你创建的列表中，如果他们不再是学校的学生，你也可以从该列表中删除元素。
- en: Learning to distinguish between when you would use lists versus when you would
    use tuples can take some time. If the distinction isn’t totally clear to you just
    yet, it’s not your fault!
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 学习区分何时使用列表与何时使用元组可能需要一些时间。如果你现在对这种区别还不是完全清楚，那不是你的错！
- en: Lists and tuples are both Python *sequences*, which means that we can run `for`
    loops on them, search using the `in` operator, and retrieve from them, both using
    individual indexes and with slices. The third sequence type in Python is the string,
    which we looked at in the previous chapter. I find it useful to think of the sequences
    in this way.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 列表和元组都是Python *序列*，这意味着我们可以对它们运行`for`循环，使用`in`运算符进行搜索，以及通过单个索引或切片从它们中检索数据。Python的第三种序列类型是字符串，我们在上一章中已经讨论过。我发现这样思考序列很有用。
- en: Table 3.1 Sequence comparison
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 表3.1 序列比较
- en: '| Type | Mutable? | Contains | Syntax | Retrieval |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 可变？ | 包含 | 语法 | 获取 |'
- en: '| `str` | No | One-element strings | `s = ''abc''` | `s[0] # returns ''a''`
    |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '| `str` | 否 | 单元素字符串 | `s = ''abc''` | `s[0] # 返回 ''a''` |'
- en: '| `list` | Yes | Any Python type | `mylist = [10, 20, 30, 40, 50]` | `mylist[2]
    # returns 30` |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '| `list` | 是 | 任何Python类型 | `mylist = [10, 20, 30, 40, 50]` | `mylist[2] #
    返回 30` |'
- en: '| `tuple` | No | Any Python type | `t = (100, 200, 300, 400, 500)` | `t[3]
    # returns 400` |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| `tuple` | 否 | 任何Python类型 | `t = (100, 200, 300, 400, 500)` | `t[3] # 返回 400`
    |'
- en: In this chapter, we’ll practice working with lists and tuples. We’ll see how
    to create them, modify them (in the case of lists), and use them to keep track
    of our data. We’ll also use *list comprehensions*, a syntax that’s confusing to
    many but which allows us to take one Python iterable and create a new list based
    on it. We’ll talk about comprehensions quite a bit in this chapter and the following
    ones; if you’re not familiar or comfortable with them, look at the references
    provided in table 3.2.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将练习使用列表和元组。我们将看到如何创建它们，如何修改它们（对于列表而言），以及如何使用它们来跟踪我们的数据。我们还将使用 *列表推导式*，这是一种对许多人来说都令人困惑的语法，但它允许我们基于一个
    Python 可迭代对象创建一个新的列表。在本章和接下来的章节中，我们将大量讨论推导式；如果你不熟悉或不习惯它们，请查看表 3.2 中提供的参考资料。
- en: Table 3.2 What you need to know
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3.2 你需要知道的内容
- en: '| Concept | What is it? | Example | To learn more |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| 概念 | 它是什么？ | 示例 | 了解更多 |'
- en: '| `list` | Ordered, mutable sequence | `[10, 20, 30]` | [http://mng.bz/NKAD](http://mng.bz/NKAD)
    |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| `list` | 有序、可变序列 | `[10, 20, 30]` | [http://mng.bz/NKAD](http://mng.bz/NKAD)
    |'
- en: '| `tuple` | Ordered, immutable sequence | `(3, ''clubs'')` | [http://mng.bz/D2VE](http://mng.bz/D2VE)
    |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| `tuple` | 有序、不可变序列 | `(3, ''clubs'')` | [http://mng.bz/D2VE](http://mng.bz/D2VE)
    |'
- en: '| List comprehensions | Returns a list based on an iterable | `# returns [''10'',
    ''20'', ''30]``[str(x) for x in [10, 20, 30]]` | [http://mng.bz/OMpO](http://mng.bz/OMpO)
    |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| 列表推导式 | 根据可迭代对象返回一个列表 | `# 返回 [''10'', ''20'', ''30'']``[str(x) for x in
    [10, 20, 30]]` | [http://mng.bz/OMpO](http://mng.bz/OMpO) |'
- en: '| `range` | Returns an iterable sequence of integers | `# every 3rd integer,
    from 10 until (and not including) 50``numbers = range(10, 50, 3)` | [http://mng.bz/B2DJ](http://mng.bz/B2DJ)
    |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| `range` | 返回一个整数序列的可迭代对象 | `# 每 3 个整数，从 10 到 (但不包括) 50``numbers = range(10,
    50, 3)` | [http://mng.bz/B2DJ](http://mng.bz/B2DJ) |'
- en: '| `operator``.itemgetter` | Returns a function that operates like square brackets
    | `# final(''abcd'') == ''d''``final = operator``.itemgetter(-1)` | [http://mng.bz/dyPQ](http://mng.bz/dyPQ)
    |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| `operator.itemgetter` | 返回一个像方括号一样操作的函数 | `# final(''abcd'') == ''d''``final
    = operator.itemgetter(-1)` | [http://mng.bz/dyPQ](http://mng.bz/dyPQ) |'
- en: '| `collections``.Counter` | Subclass of dict useful for counting items in an
    iterable | `# roughly the same as {''a'':2, ''b'':2, ''c'':1, ''d'':1}``c = collections``.Counter(''abcdab'')`
    | [http://mng.bz/rrBX](http://mng.bz/rrBX) |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| `collections.Counter` | dict 的子类，用于在可迭代对象中计数项 | `# 大约等同于 {''a'':2, ''b'':2,
    ''c'':1, ''d'':1}``c = collections.Counter(''abcdab'')` | [http://mng.bz/rrBX](http://mng.bz/rrBX)
    |'
- en: '| `max` | Built-in function returning the largest element of an iterable |
    `# returns 30``max([10, 20, 30])` | [http://mng.bz/Vgq5](http://mng.bz/Vgq5) |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| `max` | 返回可迭代对象中最大元素的内建函数 | `# 返回 30``max([10, 20, 30])` | [http://mng.bz/Vgq5](http://mng.bz/Vgq5)
    |'
- en: '| `str.format` | String method returning a new string based on a template (similar
    to f-strings) | `# returns ''x = 100, y = [10, 20, 30]''``''x = {0}, y = {1}''``.format(100,
    [10, 20, 30])` | [http://mng.bz/Z2eZ](http://mng.bz/Z2eZ) |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| `str.format` | 返回基于模板的新字符串的方法（类似于 f-strings） | `# 返回 ''x = 100, y = [10,
    20, 30]''``''x = {0}, y = {1}''``.format(100, [10, 20, 30])` | [http://mng.bz/Z2eZ](http://mng.bz/Z2eZ)
    |'
- en: Exercise 9 ■ First-last
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 9 ■ 首尾
- en: For many programmers coming from a background in Java or C#, the dynamic nature
    of Python is quite strange. How can a programming language fail to police which
    type can be assigned to which variable? Fans of dynamic languages, such as Python,
    respond that this allows us to write generic functions that handle many different
    types.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多来自 Java 或 C# 背景的程序员来说，Python 的动态特性相当奇怪。一种编程语言怎么可能无法监控哪种类型可以分配给哪个变量呢？Python
    等动态语言的支持者回答说，这允许我们编写处理许多不同类型的通用函数。
- en: Indeed, we need to do so. In many languages, you can define a function multiple
    times, as long as each definition has different parameters. In Python, you can
    only define a function once--or, more precisely, defining a function a second
    time will overwrite the first definition--so we need to use other techniques to
    work with different types of inputs.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 确实，我们需要这样做。在许多语言中，你可以定义一个函数多次，只要每个定义有不同的参数即可。在 Python 中，你只能定义一个函数一次——或者，更准确地说，定义函数的第二次将会覆盖第一次的定义——因此我们需要使用其他技术来处理不同类型的输入。
- en: In Python, you can write a single function that works with many types, rather
    than many nearly identical functions, each for a specific type. Such functions
    demonstrate the elegance and power of dynamic typing.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 中，你可以编写一个可以处理许多类型的单个函数，而不是为特定类型编写许多几乎相同的函数。这样的函数展示了动态类型的美感和力量。
- en: The fact that sequences--strings, lists, and tuples--all implement many of the
    same APIs is not an accident. Python encourages us to write generic functions
    that can apply to all of them. For example, all three sequence types can be searched
    with `in`, can return individual elements with an index, and can return multiple
    elements with a slice.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 序列（字符串、列表和元组）都实现了许多相同的API，这并非偶然。Python鼓励我们编写通用的函数，这些函数可以应用于所有这些类型。例如，所有三种序列类型都可以使用`in`进行搜索，可以使用索引返回单个元素，也可以使用切片返回多个元素。
- en: We’ll practice these ideas with this exercise. Write a function, `firstlast`,
    that takes a sequence (string, list, or tuple) and returns the first and last
    elements of that sequence, in a two-element sequence of the same type. So `firstlast('abc')`
    will return the string `ac`, while `firstlast([1,2,3,4])` will return the list
    `[1,4]`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过这个练习来练习这些想法。编写一个函数`firstlast`，它接受一个序列（字符串、列表或元组）并返回该序列的第一个和最后一个元素，以相同类型的两个元素序列返回。所以`firstlast('abc')`将返回字符串`ac`，而`firstlast([1,2,3,4])`将返回列表`[1,4]`。
- en: Working it out
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决问题
- en: This exercise is as tricky as it is short. However, I believe it helps to demonstrate
    the difference between retrieving an individual element from a sequence and a
    slice from that sequence. It also shows the power of a dynamic language; we don’t
    need to define several different versions of `firstlast`, each handling a different
    type. Rather, we can define a single function that handles not only the built-in
    sequences, but also any new types we might define that can handle indexes and
    slices.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习虽然简短，但很棘手。然而，我相信它有助于展示从序列中检索单个元素与从序列中检索切片之间的区别。它还展示了动态语言的力量；我们不需要为处理不同类型的`firstlast`定义几个不同的版本。相反，我们可以定义一个函数，该函数不仅可以处理内置的序列，还可以处理我们可能定义的任何新类型，这些新类型可以处理索引和切片。
- en: One of the first things that Python programmers learn is that they can retrieve
    an element from a sequence--a string, list, or tuple--using square brackets and
    a numeric index. So you can retrieve the first element of `s` with `s[0]` and
    the final element of `s` with `s[-1]`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Python程序员学习的第一件事之一是，他们可以使用方括号和数字索引从序列（字符串、列表或元组）中检索一个元素。所以你可以用`s[0]`检索`s`的第一个元素，用`s[-1]`检索`s`的最后一个元素。
- en: But that’s not all. You can also retrieve a *slice*, or a subset of the elements
    of the sequence, by using a colon inside the square brackets. The easiest and
    most obvious way to do this is something like `s[2:5]`, which means that you want
    a string whose content is from `s`, starting at index 2, up to but not including
    index 5\. (Remember that in a slice, the final number is always “up to but not
    including.”)
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 但不仅如此。你还可以通过在方括号内使用冒号来检索一个切片，即序列元素的子集。最简单、最明显的方法是像`s[2:5]`这样的操作，这意味着你想要一个从`s`开始，从索引2开始，但不包括索引5的内容的字符串。（记住，在切片中，最后的数字总是“直到但不包括”。）
- en: '![](../Images/3-1.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图3-1](../Images/3-1.png)'
- en: Figure 3.1 Individual elements (from the Python Tutor)
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 单个元素（来自Python Tutor）
- en: When you retrieve a single element from a sequence (figure 3.1), you can get
    any type at all. String indexes return one-character strings, but lists and tuples
    can contain anything. By contrast, when you use a slice, you’re guaranteed to
    get the same type back--so a slice of a tuple is a tuple, regardless of the size
    of the slice or the elements it contains. And a slice of a list will return a
    list. In figures 3.2 and 3.3 from the Python Tutor, notice that the data structures
    are different, and thus the results of retrieving from each type will be different.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当你从一个序列（图3.1）中检索单个元素时，你可以得到任何类型。字符串索引返回一个字符的字符串，但列表和元组可以包含任何内容。相比之下，当你使用切片时，你保证会得到相同类型的返回值——所以元组的切片仍然是元组，无论切片的大小或包含的元素如何。列表的切片将返回列表。在Python
    Tutor的图3.2和3.3中，注意数据结构不同，因此从每种类型检索的结果也会不同。
- en: '![](../Images/3-2.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图3-2](../Images/3-2.png)'
- en: Figure 3.2 Retrieving slices from a list (from the Python Tutor)
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 从列表中检索切片（来自Python Tutor）
- en: Staying in bounds
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 保持范围
- en: 'When retrieving a single index, you can’t go beyond the bounds:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当检索单个索引时，你不能超出范围：
- en: '[PRE0]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'However, when retrieving with a slice, Python is more forgiving, ignoring any
    index beyond the data structure’s boundaries:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当使用切片检索时，Python更为宽容，忽略任何超出数据结构边界的索引：
- en: '[PRE1]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In figures 3.2 and 3.3, there is no index 5\. And yet, Python forgives us, showing
    the data all the way to the end. We just as easily could have omitted the final
    number.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在图3.2和3.3中，没有索引5。然而，Python会宽恕我们，显示数据直到最后。我们同样可以省略最后的数字。
- en: '![](../Images/3-3.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/3-3.png)'
- en: Figure 3.3 Retrieving slices from a tuple (from the Python Tutor)
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.3 从元组中检索切片（来自 Python Tutor）
- en: 'Given that we’re trying to retrieve the first and last elements of `sequence`
    and then join them together, it might seem reasonable to grab them both (via indexes)
    and then add them together:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们试图检索 `sequence` 的第一个和最后一个元素并将它们连接起来，那么同时获取它们（通过索引）然后相加似乎是合理的：
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'But this is what really happens (figure 3.4):'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 但这正是实际发生的情况（图 3.4）：
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ Not a real solution!
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 这不是一个真正的解决方案！
- en: ❷ Prints the string 'ac', not ('a', 'c')
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 打印字符串 'ac'，而不是 ('a', 'c')
- en: ❸ Prints the integer 5, not (1, 4)
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 打印整数 5，而不是 (1, 4)
- en: We can’t simply use `+` on the individual elements of our tuples. As we see
    in figure 3.4, if the elements are strings or integers, then using `+` on those
    two elements will give us the wrong answer. We want to be adding tuples--or whatever
    type `sequence` is.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能简单地使用 `+` 对元组的各个元素进行操作。如图 3.4 所示，如果元素是字符串或整数，那么在这两个元素上使用 `+` 将会得到错误的结果。我们想要添加的是元组——或者任何类型的
    `sequence`。
- en: '![](../Images/3-4.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/3-4.png)'
- en: Figure 3.4 Naive, incorrect adding of slices (from the Python Tutor)
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4 天真的、错误的切片添加（来自 Python Tutor）
- en: The easiest way to do that is to use a slice, using `s[:1]` to get the first
    element and `s[-1:]` to get the final element (figure 3.5). Notice that we have
    to say `s[-1:]` so that the sequence will start with the element at -1 and end
    at the end of the sequence itself.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 做这件事最简单的方法是使用切片，使用 `s[:1]` 来获取第一个元素，使用 `s[-1:]` 来获取最后一个元素（图 3.5）。注意，我们必须说 `s[-1:]`，这样序列将从
    -1 位置的元素开始，并结束于序列本身。
- en: The bottom line is that when you retrieve a slice from an object x, you get
    back a new object of the same type as x. But if you retrieve an individual element
    from x, you’ll get whatever was stored in x --which might be the same type as
    x, but you can’t be sure.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，当你从一个对象 x 中检索一个切片时，你会得到一个与 x 类型相同的新对象。但如果你从 x 中检索一个单独的元素，你会得到 x 中存储的内容——这可能与
    x 的类型相同，但你不能确定。
- en: '![](../Images/3-5.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/3-5.png)'
- en: Figure 3.5 Working solution (from the Python Tutor)
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.5 工作解决方案（来自 Python Tutor）
- en: Solution
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ In both cases, we’re using slices, not indexes.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在这两种情况下，我们使用的是切片，而不是索引。
- en: You can work through this code in the Python Tutor at [http://mng.bz/RAPP](http://mng.bz/RAPP).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 Python Tutor 中运行此代码：[http://mng.bz/RAPP](http://mng.bz/RAPP).
- en: Screencast solution
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 屏幕录制解决方案
- en: 'Watch this short video walkthrough of the solution: [https://livebook.manning.com/
    video/python-workout](https://livebook.manning.com/video/python-workout).'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 观看此解决方案的简短视频：[https://livebook.manning.com/video/python-workout](https://livebook.manning.com/video/python-workout).
- en: Beyond the exercise
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 超出练习范围
- en: One of these techniques involves taking advantage of Python’s dynamic typing;
    that is, while data is strongly typed, variables don’t have any types. This means
    that we can write a function that expects to take any indexable type (i.e., one
    that can get either a single index or a slice as an argument) and then return
    something appropriate. This is a common technique in Python, one with which you
    should become familiar and comfortable; for example
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这些技术之一涉及利用 Python 的动态类型；也就是说，虽然数据是强类型的，但变量没有任何类型。这意味着我们可以编写一个函数，该函数期望接受任何可索引类型（即可以作为单个索引或切片作为参数的类型）并返回适当的内容。这在
    Python 中是一种常见的技术，你应该熟悉并感到舒适；例如
- en: Don’t write one function that squares integers, and another that squares floats.
    Write one function that handles all numbers.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要编写一个函数来平方整数，另一个函数来平方浮点数。编写一个处理所有数字的函数。
- en: Don’t write one function that finds the largest element of a string, another
    that does the same for a list, and a third that does the same for a tuple. Write
    just one function that works on all of them.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要编写一个函数来找到字符串中的最大元素，另一个函数用于列表，第三个函数用于元组。只需编写一个适用于所有这些的函数。
- en: Don’t write one function to find the largest word in a file that works on files
    and another that works on the `io.StringIO` ([http://mng.bz/PAOP](http://mng.bz/PAOP))
    file simulator used in testing. Write one function that works on both.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要编写一个函数来找到文件中的最大单词，一个用于文件，另一个用于测试中使用的 `io.StringIO` ([http://mng.bz/PAOP](http://mng.bz/PAOP))
    文件模拟器。编写一个适用于两者的函数。
- en: Slices are a great way to get at just part of a piece of data. Whether it’s
    a substring or part of a list, slices allow you to grab just part of any sequence.
    I’m often asked by students in my courses how they can iterate over just the final
    *n* elements of a list. When I remind them that they can do this with the slice
    `mylist[-3:]` and a `for` loop, they’re somewhat surprised and embarrassed that
    they didn’t think of this first; they were sure that it must be more difficult
    than that.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 切片是获取数据部分的好方法。无论是子字符串还是列表的一部分，切片都允许你获取任何序列的一部分。我经常被我的课程中的学生问及他们如何迭代列表的最后 *n*
    个元素。当我提醒他们可以用切片 `mylist[-3:]` 和一个 `for` 循环来做这件事时，他们有些惊讶和尴尬，因为他们没有首先想到这个；他们确信这一定比那更难。
- en: 'Here are some ideas for other tasks you can try, using indexes and slices:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些你可以尝试的其他任务的思路，使用索引和切片：
- en: Write a function that takes a list or tuple of numbers. Return a two-element
    list, containing (respectively) the sum of the even-indexed numbers and the sum
    of the odd-indexed numbers. So calling the function as `even_odd_sums([10,` `20,`
    `30,` `40,` `50,` `60])`, you’ll get back `[90,` `120]`.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个函数，接受一个数字的列表或元组。返回一个包含两个元素的列表，分别包含偶数索引数字的和以及奇数索引数字的和。所以调用函数为 `even_odd_sums([10,
    20, 30, 40, 50, 60])`，你会得到 `[90, 120]`。
- en: Write a function that takes a list or tuple of numbers. Return the result of
    alternately adding and subtracting numbers from each other. So calling the function
    as `plus_minus([10,` `20,` `30,` `40,` `50,` `60])`, you’ll get back the result
    of `10+20-30+40-50+60`, or `50`.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个函数，接受一个数字的列表或元组。返回交替相加和减去数字的结果。所以调用函数为 `plus_minus([10, 20, 30, 40, 50,
    60])`，你会得到 `10+20-30+40-50+60` 的结果，即 `50`。
- en: Write a function that partly emulates the built-in `zip` function ([http://mng.bz/
    Jyzv](http://mng.bz/Jyzv)), taking any number of iterables and returning a list
    of tuples. Each tuple will contain one element from each of the iterables passed
    to the function. Thus, if I call `myzip([10,` `20,30],` `'abc')`, the result will
    be `[(10,` `'a'),` `(20,` `'b'),` `(30,` `'c')]`. You can return a list (not an
    iterator) and can assume that all of the iterables are of the same length.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个函数，部分模拟内置的 `zip` 函数 ([http://mng.bz/ Jyzv](http://mng.bz/Jyzv))，接受任意数量的可迭代对象，并返回一个元组列表。每个元组将包含传递给函数的每个可迭代对象中的一个元素。因此，如果我调用
    `myzip([10, 20, 30], 'abc')`，结果将是 `[(10, 'a'), (20, 'b'), (30, 'c')]`。你可以返回一个列表（而不是迭代器），并且可以假设所有的可迭代对象长度相同。
- en: Are lists arrays?
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 列表是数组吗？
- en: Newcomers to Python often look for the `array` type. But for Python developers,
    lists are the typical go-to data type for anyone needing an array or array-like
    structure.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Python 新手经常寻找 `array` 类型。但对于 Python 开发者来说，列表是任何需要数组或类似数组结构的人的典型数据类型。
- en: 'Now, lists aren’t arrays: arrays have a fixed length, as well as a type. And
    while you could potentially argue that Python’s lists handle only one type, namely
    anything that inherits from the built-in `object` class, it’s definitely not true
    that lists have a fixed length. Exercise 9 demonstrates that pretty clearly, but
    doesn’t use the `list.append` or `list.remove` methods.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，列表不是数组：数组有固定的长度，以及类型。虽然你可以争辩说 Python 的列表只处理一种类型，即从内置的 `object` 类继承的任何东西，但这绝对不是列表有固定长度的说法。练习
    9 清楚地证明了这一点，但它没有使用 `list.append` 或 `list.remove` 方法。
- en: '*Note* Python does have an `array` type in the standard library ([http://mng
    .bz/wBlQ](http://mng.bz/wBlQ)), and data scientists commonly use NumPy arrays
    ([http://mng.bz/ qMX2](http://mng.bz/qMX2)). For the most part, though, we don’t
    need or use arrays in Python. They don’t align with the language’s dynamic nature.
    Instead, we normally use lists and tuples.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '*注意* Python 在标准库中确实有一个 `array` 类型 ([http://mng .bz/wBlQ](http://mng.bz/wBlQ))，数据科学家通常使用
    NumPy 数组 ([http://mng.bz/ qMX2](http://mng.bz/qMX2))。不过，大部分情况下，我们不需要或使用数组在 Python
    中。它们与语言的动态特性不匹配。相反，我们通常使用列表和元组。'
- en: 'Behind the scenes, Python lists are implemented as arrays of pointers to Python
    objects. But if arrays are of fixed size, how can Python use them to implement
    lists? The answer is that Python allocates some extra space in its list array,
    such that we can add a few items to it. But at a certain point, if we add enough
    items to our list, these spare locations will be used up, thus forcing Python
    to allocate a new array and move all of the pointers to that location. This is
    done for us automatically and behind the scenes, but it shows that adding items
    to a list isn’t completely free of computational overhead. You can see this in
    action using `sys.getsizeof` ([http://mng.bz/7Xzy](http://mng.bz/7Xzy)), which
    shows the number of bytes needed to store a list (or any other data structure):'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，Python 列表作为指向 Python 对象的指针数组实现。但是，如果数组大小固定，Python 如何使用它们来实现列表？答案是 Python
    在其列表数组中分配了一些额外空间，这样我们就可以向其中添加一些项目。但是，在某个点上，如果我们向列表中添加足够的项目，这些额外位置将被用完，从而迫使 Python
    分配一个新的数组并将所有指针移动到该位置。这是自动在幕后完成的，但它表明向列表中添加项目并不完全是无计算开销的。您可以使用 `sys.getsizeof`
    ([http://mng.bz/7Xzy](http://mng.bz/7Xzy)) 来看到这一点，它显示了存储列表（或任何其他数据结构）所需的字节数：
- en: '[PRE5]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Running this code gives us the following output:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码会得到以下输出：
- en: '[PRE6]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see, then, the list grows as necessary but always has some spare
    room, allowing it to avoid growing if you’re just adding a handful of elements.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，因此，列表会根据需要增长，但始终留有一些额外空间，这样它就可以避免在仅添加少量元素时增长。
- en: '*Note* Different versions of Python, as well as different operating systems
    and platforms, may allocate memory differently than what I’ve shown here.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '*注意* 不同版本的 Python，以及不同的操作系统和平台，可能分配的内存与我这里展示的不同。'
- en: How much do you need to care about this in your day-to-day Python development?
    As with all matters of memory allocation and Python language implementation, I
    think of this as useful background knowledge, either for when you’re in a real
    bind when optimizing, or just for a better sense of and appreciation for how Python
    does things.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的日常 Python 开发中，您需要对此关心多少？与所有内存分配和 Python 语言实现的问题一样，我认为这有助于了解背景知识，无论是您在优化时遇到真正困难的时候，还是为了更好地理解和欣赏
    Python 的工作方式。
- en: But if you’re worried on a regular basis about the size of your data structures,
    or the way Python is allocating memory behind the scenes, then I’d argue that
    you’re probably worrying about the wrong things--or you’re using the wrong language
    for the job at hand. Python is a fantastic language for many things, and its garbage
    collector works well enough most of the time. But you don’t have fine-tuned control
    over the garbage collector, and Python largely assumes that you’ll outsource control
    to the language.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果您经常担心数据结构的大小，或者 Python 在幕后如何分配内存，那么我认为您可能担心的是错误的事情——或者您正在使用不适合这项工作的语言。Python
    是许多事情上的优秀语言，其垃圾回收器在大多数时候工作得很好。但是，您无法对垃圾回收器进行精细控制，Python 主要假设您将控制权外包给语言。
- en: Exercise 10 ■ Summing anything
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 10 ■ 计算任何内容
- en: You’ve seen how you can write a function that takes a number of different types.
    You’ve also seen how you can write a function that returns different types, using
    the argument that the function received.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经看到如何编写一个接受多种类型的函数。您也看到了如何编写一个返回不同类型的函数，使用函数接收到的参数。
- en: In this exercise, you’ll see how you can have even more flexibility experimenting
    with types. What happens if you’re running methods not on the argument itself,
    but on elements within the argument? For example, what if you want to sum the
    elements of a list--regardless of whether those elements are integers, floats,
    strings, or even lists?
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将看到如何通过在类型上进行实验来获得更多的灵活性。如果您运行的方法不是针对参数本身，而是针对参数内的元素，会发生什么？例如，如果您想计算列表中元素的总和——无论这些元素是整数、浮点数、字符串，甚至是列表呢？
- en: This challenge asks you to redefine the `mysum` function we defined in chapter
    1, such that it can take any number of arguments. The arguments must all be of
    the same type and know how to respond to the `+` operator. (Thus, the function
    should work with numbers, strings, lists, and tuples, but not with sets and dicts.)
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这个挑战要求您重新定义我们在第 1 章中定义的 `mysum` 函数，使其能够接受任意数量的参数。这些参数必须都是同一类型，并且知道如何响应 `+` 操作符。（因此，该函数应该与数字、字符串、列表和元组一起工作，但不能与集合和字典一起工作。）
- en: '*Note* Python 3.9, which is scheduled for release in the autumn of 2020, will
    apparently include support for `|` on dicts. See PEP 584 ([http://mng.bz/mB42](http://mng.bz/mB42))
    for more details.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*注意* 计划于2020年秋季发布的Python 3.9版本可能将包括对字典中`|`的支持。有关更多详细信息，请参阅PEP 584 ([http://mng.bz/mB42](http://mng.bz/mB42))。'
- en: The result should be a new, longer sequence of the type provided by the parameters.
    Thus, the result of `mysum('abc',` `'def')` will be the string `abcdef`, and the
    result of `mysum([1,2,3],` `[4,5,6])` will be the six-element list `[1,2,3,4,5,6]`.
    Of course, it should also still return the integer `6` if we invoke `mysum(1,2,3)`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 结果应该是一个新的、更长的序列，其类型由参数提供。因此，`mysum('abc', 'def')`的结果将是字符串`abcdef`，而`mysum([1,2,3],
    [4,5,6])`的结果将是包含六个元素的列表`[1,2,3,4,5,6]`。当然，如果我们调用`mysum(1,2,3)`，它也应该仍然返回整数`6`。
- en: Working through this exercise will give you a chance to think about sequences,
    types, and how we can most easily create return values of different types from
    the same function.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个练习，你可以有机会思考序列、类型以及我们如何最容易地从同一个函数中创建不同类型的返回值。
- en: Working it out
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 工作原理
- en: This new version of `mysum` is more complex than the one we saw previously.
    It still accepts any number of arguments, which are put into the `items` tuple
    thanks to the “splat” (`*`) operator.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`mysum`的新版本比我们之前看到的版本更复杂。它仍然接受任意数量的参数，这些参数通过“展开”(`*`)运算符放入`items`元组中。
- en: '*Tip* While we traditionally call the “takes any number of arguments” parameter
    `*args`, you can use any name you want. The important part is the `*`, not the
    name of the parameter; it still works the same way and is always a tuple.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*提示* 虽然我们传统上称“接受任意数量参数”的参数为`*args`，但你可以使用任何你想要的名称。重要的是`*`，而不是参数的名称；它仍然以相同的方式工作，并且始终是一个元组。'
- en: The first thing we do is check to see if we received any arguments. If not,
    we return `items`, an empty tuple. This is necessary because the rest of the function
    requires that we know the type of the passed arguments, and that we have an element
    at index 0\. Without any arguments, neither will work.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先检查是否收到了任何参数。如果没有，我们返回`items`，一个空元组。这是必要的，因为函数的其余部分需要我们知道传递的参数的类型，并且我们在索引0处有一个元素。没有参数，这两者都不会工作。
- en: Notice that we don’t check for an empty tuple by comparing it with `()` or checking
    that its length is 0\. Rather, we can say `if` `not` `items`, which asks for the
    Boolean value of our tuple. Because an empty Python sequence is `False` in a Boolean
    context, we get `False` if `args` is empty and `True` otherwise.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们不是通过将其与`()`比较或检查其长度是否为0来检查空元组。相反，我们可以说`if not items`，这要求我们元组的布尔值。因为在布尔上下文中，空Python序列是`False`，所以如果`args`为空，我们得到`False`，否则得到`True`。
- en: In the next line, we grab the first element of `items` and assign it to `output`
    (figure 3.6). If it’s a number, `output` will be a number; if it’s a string, `output`
    will be a string; and so on. This gives us the base value to which we’ll add (using
    `+`) each of the subsequent values in `items`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一行，我们获取`items`的第一个元素并将其分配给`output`（图3.6）。如果它是一个数字，`output`将是一个数字；如果它是一个字符串，`output`将是一个字符串；依此类推。这为我们提供了要添加（使用`+`）到`items`中后续每个值的基数。
- en: Once that’s in place, we do what the original version of `mysum` did--but instead
    of iterating over all of `items`, we can now iterate over `items[1:]` (figure
    3.7), meaning all of the elements except for the first one. Here, we again see
    the value of Python’s slices and how we can use them to solve problems.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦到位，我们就做原始版本`mysum`所做的事情——但是我们现在可以迭代`items[1:]`（图3.7），这意味着除了第一个元素之外的所有元素。在这里，我们再次看到了Python切片的价值以及我们如何使用它们来解决问题。
- en: You can think of this implementation of `mysum` as the same as our original
    version, except that instead of adding each element to 0, we’re adding each one
    to `items[0]`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将这个`mysum`的实现视为与我们原始版本相同，除了我们不是将每个元素加到0上，而是将每个元素加到`items[0]`上。
- en: But wait, what if the person passed us only a single argument, and thus `args`
    doesn’t contain anything at index 1? Fortunately, slices are forgiving and allow
    us to specify indexes beyond the sequence’s boundaries. In such a case, we’ll
    just get an empty sequence, over which the `for` loop will run zero times. This
    means we’ll just get the value of `items[0]` returned to us as `output`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 但是等等，如果传递给我们的人只有一个参数，因此`args`在索引1处不包含任何内容怎么办？幸运的是，切片是宽容的，允许我们指定超出序列边界的索引。在这种情况下，我们只会得到一个空序列，`for`循环将运行零次。这意味着我们只会得到`items[0]`的值作为`output`返回。
- en: '![](../Images/3-6.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/3-6.png)'
- en: Figure 3.6 After assigning the first element to `output` (from the Python Tutor)
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.6 在将第一个元素分配给 `output` 之后（来自 Python Tutor）
- en: '![](../Images/3-7.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/3-7.png)'
- en: Figure 3.7 After adding elements to `output` (from the Python Tutor)
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.7 在将元素添加到 `output` 之后（来自 Python Tutor）
- en: Solution
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案
- en: '[PRE7]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: ❶ In Python, everything is considered “True” in an “if,” except for “None,”
    “False,” 0, and empty collections. So if the tuple “items” is empty, we’ll just
    return an empty tuple.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 在 Python 中，除了“None”、“False”、0 和空集合外，所有内容在“if”语句中都被认为是“True”。因此，如果元组“items”为空，我们只需返回一个空元组。
- en: ❷ We’re assuming that the elements of “items” can be added together.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 我们假设“items”的元素可以相加。
- en: You can work through this code in the Python Tutor at [http://mng.bz/5aA1](http://mng.bz/5aA1).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 Python Tutor 中运行此代码：[http://mng.bz/5aA1](http://mng.bz/5aA1)。
- en: Screencast solution
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 屏幕录制解决方案
- en: 'Watch this short video walkthrough of the solution: [https://livebook.manning.com/
    video/python-workout](https://livebook.manning.com/video/python-workout).'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 观看此简短视频教程：[https://livebook.manning.com/video/python-workout](https://livebook.manning.com/video/python-workout)。
- en: Beyond the exercise
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 除此之外
- en: 'This exercise demonstrates some of the ways we can take advantage of Python’s
    dynamic typing to create a function that works with many different types of inputs,
    and even produces different types of outputs. Here are a few other problems you
    can try to solve, which have similar goals:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习展示了我们可以利用 Python 的动态类型来创建一个可以处理多种不同类型输入，甚至产生不同类型输出的函数的方法。以下是一些你可以尝试解决的问题，它们具有相似的目标：
- en: Write a function, `mysum_bigger_than`, that works the same as `mysum`, except
    that it takes a first argument that precedes `*args`. That argument indicates
    the threshold for including an argument in the sum. Thus, calling `mysum_bigger
    _than(10,` `5,` `20,` `30,` `6)` would return `50`--because `5` and `6` aren’t
    greater than `10`. This function should similarly work with any type and assumes
    that all of the arguments are of the same type. Note that `>` and `<` work on
    many different types in Python, not just on numbers; with strings, lists, and
    tuples, it refers to their sort order.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个名为 `mysum_bigger_than` 的函数，它的工作方式与 `mysum` 相同，但它接受一个先于 `*args` 的第一个参数。该参数表示包括参数在内的阈值。因此，调用
    `mysum_bigger_than(10, 5, 20, 30, 6)` 将返回 `50`--因为 `5` 和 `6` 不大于 `10`。此函数应类似地适用于任何类型，并假设所有参数都是同一类型。请注意，`>`
    和 `<` 在 Python 中适用于许多不同类型，而不仅仅是数字；对于字符串、列表和元组，它指的是它们的排序顺序。
- en: Write a function, `sum_numeric`, that takes any number of arguments. If the
    argument is or can be turned into an integer, then it should be added to the total.
    Arguments that can’t be handled as integers should be ignored. The result is the
    sum of the numbers. Thus, `sum_numeric(10,` `20,` `'a',` `'30',` `'bcd')` would
    return `60`. Notice that even if the string `30` is an element in the list, it’s
    converted into an integer and added to the total.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个名为 `sum_numeric` 的函数，它接受任意数量的参数。如果参数是或可以转换为整数，则应将其添加到总数中。无法作为整数处理的参数应被忽略。结果是数字的总和。因此，`sum_numeric(10,
    20, 'a', '30', 'bcd')` 将返回 `60`。注意，即使字符串 `30` 是列表中的一个元素，它也会被转换为整数并添加到总数中。
- en: Write a function that takes a list of dicts and returns a single dict that combines
    all of the keys and values. If a key appears in more than one argument, the value
    should be a list containing all of the values from the arguments.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个函数，它接受字典列表并返回一个包含所有键和值的单个字典。如果键在多个参数中出现，则值应是一个包含所有参数值的列表。
- en: Exercise 11 ■ Alphabetizing names
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 11 ■ 名字排序
- en: 'Let’s assume you have phone book data in a list of dicts, as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个包含字典的列表的电话簿数据，如下所示：
- en: '[PRE8]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: First of all, if these are the only people in your phone book, then you should
    rethink whether Python programming is truly the best use of your time and connections.
    Regardless, write a function, `alphabetize_names`, that assumes the existence
    of a `PEOPLE` constant defined as shown in the code. The function should return
    the list of dicts, but sorted by last name and then by first name.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，如果这些是你电话簿中唯一的人，那么你应该重新考虑 Python 编程是否真的是你时间和联系的最佳用途。无论如何，编写一个名为 `alphabetize_names`
    的函数，该函数假设存在一个 `PEOPLE` 常量，其定义如代码所示。该函数应返回字典列表，但按姓氏和名字排序。
- en: '*Note* Python doesn’t really have constants; with the exception of some internal
    types and data structures, every variable, function, and attribute can always
    be modified. That said, variables defined outside of any function are generally
    referred to as “constants” and are defined in ALL CAPS.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '*注意* Python 实际上并没有常量；除了某些内部类型和数据结构之外，每个变量、函数和属性都可以始终修改。话虽如此，定义在函数之外的变量通常被称为“常量”，并且全部大写定义。'
- en: 'You can solve this exercise several ways, but all will require using the `sorted`
    method that you saw in the last chapter, along with a function passed as an argument
    to its `key` parameter. You can read more about `sorted` and how to use it, including
    custom sorts with `key`, at [http://mng.bz/D28E](http://mng.bz/D28E). One of the
    options for solving this exercise involves `operator.itemgetter`, about which
    you can read here: [http://mng.bz/dyPQ](http://mng.bz/dyPQ).'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用几种方法解决这个问题，但所有方法都需要使用你在上一章中看到的 `sorted` 方法，以及作为其 `key` 参数的参数传递的函数。你可以阅读更多关于
    `sorted` 及其使用方法的信息，包括使用 `key` 的自定义排序，请参阅 [http://mng.bz/D28E](http://mng.bz/D28E)。解决这个问题的选项之一涉及
    `operator.itemgetter`，你可以在这里阅读相关信息：[http://mng.bz/dyPQ](http://mng.bz/dyPQ)。
- en: Working it out
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决这个问题
- en: While Python’s data structures are useful by themselves, they become even more
    powerful and useful when combined together. Lists of lists, lists of tuples, lists
    of dicts, and dicts of dicts are all quite common. Learning to work with these
    structures is an important part of being a fluent Python programmer. This exercise
    shows how you can not only store data in such structures, but also retrieve, manipulate,
    sort, and format it.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Python 的数据结构本身很有用，但将它们组合在一起时，它们就变得更加强大和有用。列表中的列表、列表中的元组、列表中的字典和字典中的字典都是相当常见的。学会使用这些结构是成为一名熟练的
    Python 程序员的重要部分。这个练习展示了你不仅可以存储在这些结构中的数据，还可以检索、操作、排序和格式化它。
- en: The solution I propose has two parts. In the first part, we sort our data according
    to the criteria I proposed, namely last name and then first name. The second part
    of the solution addresses how we’ll print output to the end user.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我提出的解决方案有两个部分。第一部分，我们根据我提出的标准对数据进行排序，即姓氏然后是名字。解决方案的第二部分解决的是如何向最终用户打印输出。
- en: 'Let’s take the second problem first. We have a list of dicts. This means that
    when we iterate over our list, `person` is assigned a dict in each iteration.
    The dict has three keys: `first`, `last`, and `email`. We’ll want to use each
    of these keys to display each phone-book entry.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先从第二个问题开始。我们有一个字典列表。这意味着当我们遍历我们的列表时，`person` 在每次迭代中都会被分配一个字典。该字典有三个键：`first`、`last`
    和 `email`。我们将想要使用这些键来显示每个电话簿条目。
- en: 'We could thus say:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以这样说：
- en: '[PRE9]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: So far, so good. But we still haven’t covered the first problem, namely sorting
    the list of dicts by last name and then first name. Basically, we want to tell
    Python’s sort facility that it shouldn’t compare dicts. Rather, it should compare
    the `last` and `first` values from within each dict.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利。但我们还没有涵盖第一个问题，即按姓氏和名字排序字典列表。基本上，我们想要告诉 Python 的排序功能不要比较字典。相反，它应该比较每个字典内的
    `last` 和 `first` 值。
- en: In other words, we want
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，我们希望
- en: '[PRE10]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: to become
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 变得
- en: '[PRE11]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We can do this by taking advantage of the `key` parameter to `sorted`. The value
    passed to that parameter must be a function that takes a single argument. The
    function will be invoked once per element, and the function’s return value will
    be used to sort the values.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过利用 `sorted` 函数的 `key` 参数来实现这一点。传递给该参数的值必须是一个函数，该函数接受单个参数。该函数将为每个元素调用一次，并且函数的返回值将用于排序值。
- en: Thus, we can sort elements of a list by saying
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以通过以下方式对列表的元素进行排序
- en: '[PRE12]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'After executing this code, `mylist` will now be sorted in increasing order
    of length, because the built-in `len` function ([http://mng.bz/oPmr](http://mng.bz/oPmr))
    will be applied to each element before it’s compared with others. In the case
    of our alphabetizing exercise, we could write a function that takes a dict and
    returns the sort of list that’s necessary:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此代码后，`mylist` 将按长度递增的顺序排序，因为内置的 `len` 函数（[http://mng.bz/oPmr](http://mng.bz/oPmr)）将在与其他元素比较之前应用于每个元素。在我们的字母排序练习中，我们可以编写一个函数，该函数接受一个字典并返回必要的排序列表：
- en: '[PRE13]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We could then apply this function when sorting our list:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在排序我们的列表时应用此函数：
- en: '[PRE14]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Following that, we could then iterate over the now-sorted list and display our
    people.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，我们可以遍历现在已排序的列表并显示我们的人员。
- en: 'But wait a second--why should we write a special-purpose function (`person_dict
    _to_list`) that’ll only be used once? Surely there must be a way to create a temporary,
    inline function. And indeed there is, with `lambda` ([http://mng.bz/GVy8](http://mng.bz/GVy8)),
    which returns a new, anonymous function. With `lambda`, we end up with the following
    solution:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 但等等——为什么我们要写一个只使用一次的特殊用途函数（`person_dict_to_list`）？肯定有创建临时内联函数的方法。确实有，使用 `lambda`
    ([http://mng.bz/GVy8](http://mng.bz/GVy8))，它返回一个新的匿名函数。使用 `lambda`，我们得到以下解决方案：
- en: '[PRE15]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Many of the Python developers I meet are less than thrilled to use `lambda`.
    It works but makes the code less readable and more confusing to many. (See the
    sidebar for more thoughts on `lambda`.)
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我遇到的许多 Python 开发者对使用 `lambda` 并不感兴趣。它工作，但使代码的可读性降低，对许多人来说更难以理解。（参见侧边栏中关于 `lambda`
    的更多想法。）
- en: Fortunately, the `operator` module has the `itemgetter` function. `itemgetter`
    takes any number of arguments and returns a function that applies each of those
    arguments in square brackets. For example, if I say
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，`operator` 模块有 `itemgetter` 函数。`itemgetter` 接受任意数量的参数，并返回一个函数，该函数将每个参数应用于方括号中。例如，如果我这么说
- en: '[PRE16]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: ❶ Notice that itemgetter returns a function.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 注意到 itemgetter 返回一个函数。
- en: ❷ Returns the tuple ('c', 'e')
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 返回元组 ('c', 'e')
- en: ❸ Returns the tuple (30, 50)
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 返回元组 (30, 50)
- en: If we invoke `itemgetter('last',` `'first')`, we’ll get a function we can apply
    to each of our person dicts. It’ll return a tuple containing the values associated
    with `last` and `first`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们调用 `itemgetter('last', 'first')`，我们将得到一个可以应用于我们每个人的字典的函数。它将返回一个包含与 `last`
    和 `first` 关联的值的元组。
- en: 'In other words, we can just write:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，我们只需写下：
- en: '[PRE17]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Solution
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案
- en: '[PRE18]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: ❶ The “key” parameter to “sorted” gets a function, whose result indicates how
    we’ll sort.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ “sorted” 函数的“key”参数得到一个函数，其结果指示我们将如何排序。
- en: You can work through this code in the Python Tutor at [http://mng.bz/Yr6Q](http://mng.bz/Yr6Q).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 Python Tutor 中运行这段代码，[http://mng.bz/Yr6Q](http://mng.bz/Yr6Q)。
- en: Screencast solution
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 屏幕录制解决方案
- en: 'Watch this short video walkthrough of the solution: [https://livebook.manning.com/
    video/python-workout](https://livebook.manning.com/video/python-workout).'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 观看这个关于解决方案的简短视频：[https://livebook.manning.com/video/python-workout](https://livebook.manning.com/video/python-workout)。
- en: Beyond the exercise
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 超出练习范围
- en: 'Learning to sort Python data structures, and particularly combinations of Python’s
    built-in data structures, is an important part of working with Python. It’s not
    enough to use the built-in `sorted` function, although that’s a good part of it;
    understanding how sorting works, and how you can use the `key` parameter, is also
    essential. This exercise has introduced this idea, but consider a few more sorting
    opportunities:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 学习如何对 Python 数据结构进行排序，尤其是 Python 内置数据结构的组合，是使用 Python 的重要部分。仅仅使用内置的 `sorted`
    函数是不够的，尽管那是个好方法；理解排序的工作原理以及如何使用 `key` 参数也是至关重要的。这个练习介绍了这个概念，但考虑一些更多的排序机会：
- en: Given a sequence of positive and negative numbers, sort them by absolute value.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给定一系列正数和负数，按绝对值对它们进行排序。
- en: Given a list of strings, sort them according to how many vowels they contain.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给定一个字符串列表，根据它们包含的元音数量对它们进行排序。
- en: Given a list of lists, with each list containing zero or more numbers, sort
    by the sum of each inner list’s numbers.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给定一个包含零个或多个数字的列表的列表，按每个内部列表的数字之和进行排序。
- en: What is lambda?
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是 lambda？
- en: Many Python developers ask me just what `lambda` is, what it does, and where
    they might want to use it.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 Python 开发者问我 `lambda` 是什么，它做什么，以及他们可能在哪些地方想使用它。
- en: The answer is that `lambda` returns a function object, allowing us to create
    an anonymous function. And we can use it wherever we might use a regular function,
    without having to “waste” a variable name.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是 `lambda` 返回一个函数对象，允许我们创建一个匿名函数。我们可以在任何可能使用常规函数的地方使用它，而不必“浪费”一个变量名。
- en: 'Consider the following code:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码：
- en: '[PRE19]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This code prints `a*b*c`, the string returned by calling `glue.join` on `s`.
    But why do you need to define either `glue` or `s`? Can’t you just use strings
    without any variables? Of course you can, as you see here:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码打印 `a*b*c`，即调用 `glue.join` 在 `s` 上返回的字符串。但为什么你需要定义 `glue` 或 `s`？难道你不能直接使用字符串而不使用任何变量吗？当然可以，就像你在这里看到的那样：
- en: '[PRE20]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This code produces the same result as we had before. The difference is that
    instead of using variables, we’re using literal strings. These strings are created
    when we need them here, and go away after our code is run. You could say that
    they’re *anonymous strings*. Anonymous strings, also known as *string literals*,
    are perfectly normal and natural, and we use them all of the time.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码产生的结果与我们之前的结果相同。不同之处在于，我们不是使用变量，而是使用字面字符串。这些字符串在我们需要它们时创建，并在代码运行后消失。你可以说是*匿名字符串*。匿名字符串，也称为*字符串字面量*，是完全正常和自然的，我们经常使用它们。
- en: 'Now consider that when we define a function using `def`, we’re actually doing
    two things: we’re both creating a function object and assigning that function
    object to a variable. We call that variable a function, but it’s no more a function
    than `x` is an integer after we say that `x=5`. Assignment in Python always means
    that a name is referring to an object, and functions are objects just like anything
    else in Python.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑当我们使用`def`定义一个函数时，我们实际上做了两件事：我们既创建了一个函数对象，又把该函数对象赋值给一个变量。我们称这个变量为函数，但这并不比我们说`x=5`后`x`是一个整数更像是函数。Python中的赋值始终意味着一个名称正在引用一个对象，函数在Python中就像其他任何东西一样是对象。
- en: 'For example, consider the following code:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下代码：
- en: '[PRE21]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: If we execute this code in the Python tutor, we can see that we’ve defined two
    variables (figure 3.8). One (`mylist`) points to an object of type `list`. The
    second (`hello`) points to a function object.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在Python导师中执行此代码，我们可以看到我们定义了两个变量（图3.8）。一个（`mylist`）指向类型为`list`的对象。第二个（`hello`）指向一个函数对象。
- en: '![](../Images/3-8.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![图3-8](../Images/3-8.png)'
- en: Figure 3.8 Both `mylist` and `hello` point to objects (from the Python Tutor).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '![图3-8](../Images/3-8.png)'
- en: Because functions are objects, they can be passed as arguments to other functions.
    This seems weird at first, but you quickly get used to the idea of passing around
    all objects, including functions.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 因为函数是对象，它们可以作为参数传递给其他函数。一开始这看起来很奇怪，但你会很快习惯于传递所有对象，包括函数。
- en: 'For example, I’m going to define a function (`run_func_with_world`) that takes
    a function as an argument. It then invokes that function, passing it the string
    `world` as an argument:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我将定义一个接受函数作为参数的函数（`run_func_with_world`）。然后它调用该函数，并将字符串`world`作为参数传递给它：
- en: '[PRE22]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Notice that we’re now passing `hello` as an argument to the function `run_func_with
    _world` (figure 3.9). As far as Python is concerned, this is totally reasonable
    and normal.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们现在正在将`hello`作为参数传递给函数`run_func_with_world`（图3.9）。就Python而言，这是完全合理和正常的。
- en: '![](../Images/3-9.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图3-9](../Images/3-9.png)'
- en: Figure 3.9 Calling `hello` from another function (from the Python Tutor)
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.9 从另一个函数调用`hello`（来自Python Tutor）
- en: In many instances we’ll want to write a function that takes another function
    as an argument. One such example is `sorted`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，我们可能想要编写一个接受另一个函数作为参数的函数。一个这样的例子是`sorted`。
- en: What does this have to do with `lambda`? Well, we can always create a function
    using `def`--but then we find ourselves creating a new variable. And for what?
    So that we can use it once? Ignoring environmental concerns, you probably don’t
    want to buy metal forks, knives, and spoons for a casual picnic; rather, you can
    just buy plasticware. In the same way, if I only need a function once, then why
    would I define it formally and give it a name?
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这与`lambda`有什么关系呢？嗯，我们总是可以使用`def`来创建一个函数--但然后我们发现自己在创建一个新的变量。为了什么？只是为了使用一次吗？忽略环境问题，你可能不想为一次野餐购买金属叉子、刀子和勺子；相反，你只需购买塑料餐具。同样，如果我只需要一个函数一次，那么我为什么要正式定义它并给它命名呢？
- en: This is where `lambda` enters the picture; it lets us create an anonymous function,
    perfect for passing to other functions. It goes away, removed from memory as soon
    as it’s no longer needed.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是`lambda`出现的地方；它让我们能够创建一个匿名函数，非常适合传递给其他函数。它一旦不再需要，就会从内存中移除。
- en: 'If we think of `def` as both (a) creating a function object and then (b) defining
    a variable that refers to that object, then we can think of `lambda` as doing
    just the first of these two tasks. That is, `lambda` creates and returns a function
    object. The code that I wrote in which I called `run_func_with_world` and passed
    it `hello` as an argument could be rewritten using `lambda` as follows:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们把`def`看作是（a）创建一个函数对象然后（b）定义一个指向该对象的变量，那么我们可以把`lambda`看作只是完成这两个任务中的第一个。也就是说，`lambda`创建并返回一个函数对象。我写的调用`run_func_with_world`并传递`hello`作为参数的代码可以用`lambda`重写如下：
- en: '[PRE23]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here (figure 3.10), I’ve removed the definition of `hello`, but I’ve created
    an anonymous function that does the same thing, using `lambda`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里（图3.10），我移除了`hello`的定义，但我创建了一个使用`lambda`执行相同操作的匿名函数。
- en: '![](../Images/3-10.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/3-10.png)'
- en: Figure 3.10 Calling an anonymous function from a function (from the Python Tutor)
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.10 从函数中调用匿名函数（来自Python Tutor）
- en: To create an anonymous function with `lambda`, use the reserved world `lambda`
    and then list any parameters before a colon. Then write the one-line expression
    that the `lambda` returns. And indeed, in a Python `lambda`, you’re restricted
    to a single expression--no assignment is allowed, and everything must be on a
    single line.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`lambda`创建一个匿名函数，请使用保留字`lambda`，然后在冒号之前列出任何参数。然后写下一行表达式，这是`lambda`返回的表达式。确实，在Python的`lambda`中，你只能限制使用单个表达式--不允许赋值，并且所有内容都必须在一行上。
- en: Nowadays, many Python developers prefer not to use `lambda`, partly because
    of its restricted syntax, and partly because more readable options, such as `itemgetter`,
    are available and do the same thing. I’m still a softie when it comes to `lambda`
    and like to use it when I can--but I also realize that for many developers it
    makes the code harder to read and maintain. You’ll have to decide just how much
    `lambda` you want to have in your code.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，许多Python开发者更喜欢不使用`lambda`，部分原因是因为其受限的语法，部分原因是因为有更易读的选项，如`itemgetter`，可以完成相同的事情。当涉及到`lambda`时，我仍然是个软心肠的人，喜欢在可能的情况下使用它--但我也意识到，对于许多开发者来说，它使得代码更难以阅读和维护。你将不得不决定在你的代码中需要多少`lambda`。
- en: Exercise 12 ■ Word with most repeated letters
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习12 ■ 最多重复字母的单词
- en: Write a function, `most_repeating_word`, that takes a sequence of strings as
    input. The function should return the string that contains the greatest number
    of repeated letters. In other words
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个函数，`most_repeating_word`，它接受一个字符串序列作为输入。该函数应返回包含最多重复字母的字符串。换句话说
- en: For each word, find the letter that appears the most times.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于每个单词，找到出现次数最多的字母。
- en: Find the word whose most-repeated letter appears more than any other.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 找到出现次数最多的字母比其他任何字母都多的单词。
- en: That is, if `words` is set to
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 即，如果`words`设置为
- en: '[PRE24]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: then your function should return `elementary`. That’s because
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你的函数应该返回`elementary`。这是因为
- en: '`this` has no repeating letters.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`this`没有重复的字母。'
- en: '`is` has no repeating letters.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`is`没有重复的字母。'
- en: '`an` has no repeating letters.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`an`没有重复的字母。'
- en: '`elementary` has one repeating letter, `e`, which appears three times.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`elementary`有一个重复的字母`e`，它出现了三次。'
- en: '`test` has one repeating letter, `t`, which appears twice.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`test`有一个重复的字母`t`，它出现了两次。'
- en: '`example` has one repeating letter, `e`, which appears twice.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`example`有一个重复的字母`e`，它出现了两次。'
- en: So the most common letter in `elementary` appears more often than the most common
    letters in any of the other words. (If it’s a tie, then any of the appropriate
    words can be returned.)
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，在`elementary`这个词中，最常见的字母出现的次数比其他任何单词中最常见的字母出现的次数都要多。（如果出现平局，则可以返回任何合适的单词。）
- en: 'You’ll probably want to use `Counter`, from the `collections` module, which
    is perfect for counting the number of items in a sequence. More information is
    here: [http:// mng.bz/rrBX](http://mng.bz/rrBX). Pay particular attention to the
    `most_common` method ([http://mng.bz/ vxlJ](http://mng.bz/vxlJ)), which will come
    in handy here.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想使用来自`collections`模块的`Counter`，它非常适合计算序列中项的数量。更多信息请参阅：[http:// mng.bz/rrBX](http://mng.bz/rrBX)。请特别注意`most_common`方法([http://mng.bz/
    vxlJ](http://mng.bz/vxlJ))，这在这里会很有用。
- en: Working it out
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 计算过程
- en: 'This solution combines a few of my favorite Python techniques into a short
    piece of code:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这个解决方案将我的一些最喜欢的Python技术结合到了一小段代码中：
- en: '`Counter`, a subclass of `dict` defined in the `collections` module, which
    makes it easy to count things'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Counter`是定义在`collections`模块中的`dict`的子类，这使得计数变得容易'
- en: Passing a function to the `key` parameter in `max`
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`max`函数中将函数传递给`key`参数
- en: For our solution to work, we’ll need to find a way to determine how many times
    each letter appears in a word. The easiest way to do that is `Counter`. It’s true
    that `Counter` inherits from `dict` and thus can do anything that a `dict` can
    do. But we normally build an instance of `Counter` by initializing it on a sequence;
    for example
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的解决方案生效，我们需要找到一种方法来确定每个字母在一个单词中出现的次数。做到这一点最简单的方法是使用`Counter`。确实，`Counter`是从`dict`继承的，因此可以执行任何`dict`可以执行的操作。但通常我们通过在序列上初始化来构建`Counter`的实例；例如
- en: '[PRE25]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We can thus feed `Counter` a word, and it’ll tell us how many times each letter
    appears in that word. We could, of course, iterate over the resulting `Counter`
    object and grab the letter that appears the most times. But why work so hard when
    we can invoke `Counter.most_common`?
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以将单词传递给`Counter`，它将告诉我们单词中每个字母出现的次数。我们当然可以遍历结果`Counter`对象并获取出现次数最多的字母。但为什么那么辛苦，当我们可以调用`Counter.most_common`呢？
- en: '[PRE26]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: ❶ Shows how often each item appears in the string, from most common to least
    common, in a list of tuples
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 显示每个项目在字符串中出现的频率，从最常见到最少见，以元组列表的形式展示
- en: 'The result of invoking `Counter.most_common` is a list of tuples, with the
    names and values of the counter’s values in descending order. So in the `Counter.most_common`
    example, we see that `b` appears five times in the input, `a` appears three times,
    and `c` also appears three times. If we were to invoke `most_common` with an integer
    argument `n`, we would only see the `n` most common items:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 调用`Counter.most_common`的结果是一个按降序排列的元组列表，包含计数器的值的名字和值。所以在`Counter.most_common`的例子中，我们看到`b`在输入中出现了五次，`a`出现了三次，`c`也出现了三次。如果我们用整数参数`n`调用`most_common`，我们只会看到`n`个最常见的项目：
- en: '[PRE27]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: ❶ Only shows the most common item, and its count
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 只显示最常见的项目及其计数
- en: 'This is perfect for our purposes. Indeed, I think it would be useful to wrap
    this up into a function that’ll return the number of times the most frequently
    appearing letter is in the word:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常适合我们的目的。实际上，我认为将其封装成一个函数，返回最频繁出现的字母在单词中出现的次数将非常有用：
- en: '[PRE28]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `(1)[0][1]` at the end looks a bit confusing. It means the following:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的`(1)[0][1]`看起来有点令人困惑。它的意思是以下内容：
- en: We only want the most commonly appearing letter, returned in a one-element list
    of tuples.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们只想要最常见的字母，以一个包含元组的单元素列表返回。
- en: We then want the first element from that list, a tuple.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们接下来想要从那个列表中获取第一个元素，一个元组。
- en: We then want the count for that most common element, at index 1 in the tuple.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们接下来想要那个最常见元素的计数，在元组中的索引1处。
- en: Remember that we don’t care which letter is repeated. We just care how often
    the most frequently repeated letter is indeed repeated. And yes, I also dislike
    the multiple indexes at the end of this function call, which is part of the reason
    I want to wrap this up into a function so that I don’t have to see it as often.
    But we can call `most_common` with an argument of `1` to say that we’re only interested
    in the highest scoring letter, then that we’re interested in the first (and only)
    element of that list, and then that we want the second element (i.e., the count)
    from the tuple.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们不在乎哪个字母被重复。我们只关心最频繁重复的字母确实重复了多少次。是的，我也讨厌这个函数调用末尾的多个索引，这也是我想将其封装成函数的原因之一，这样我就不必经常看到它。但我们可以用`1`作为参数调用`most_common`，表示我们只对得分最高的字母感兴趣，然后我们感兴趣的是列表中的第一个（也是唯一的）元素，然后我们想要元组的第二个元素（即计数）。
- en: To find the word with the greatest number of matching letters, we’ll want to
    apply `most_repeating_letter_count` to each element of `WORDS`, indicating which
    has the highest score. One way to do this would be to use `sorted`, using `most_repeating
    _letter_count` as the `key` function. That is, we’ll sort the elements of `WORDS`
    by number of repeated letters. Because `sorted` returns a list sorted from lowest
    to highest score, the final element (i.e., at index -1) will be the most repeating
    word.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到具有最多匹配字母的单词，我们将想要将`most_repeating_letter_count`应用于`WORDS`的每个元素，指示哪个具有最高分数。一种方法是将`sorted`与`most_repeating_letter_count`作为`key`函数一起使用。也就是说，我们将按重复字母的数量对`WORDS`的元素进行排序。因为`sorted`返回一个按最低到最高分数排序的列表，所以最后一个元素（即索引-1）将是重复次数最多的单词。
- en: 'But we can do even better than that: The built-in `max` function takes a `key`
    function, just like `sorted`, and returns the element that received the highest
    score. We can thus save ourselves a bit of coding with a one-line version of `most_repeating_word`:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们可以做得更好：内置的`max`函数接受一个`key`函数，就像`sorted`一样，并返回得分最高的元素。因此，我们可以通过`most_repeating_word`的一行版本节省一些代码：
- en: '[PRE29]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Solution
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案
- en: '[PRE30]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: ❶ What letter appears the most times, and how many times does it appear?
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 哪个字母出现次数最多，以及它出现了多少次？
- en: ❷ Counter.most_common returns a list of two-element tuples (value and count)
    in descending order.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ Counter.most_common返回一个包含两个元素的元组列表（值和计数），按降序排列。
- en: ❸ Just as you can pass key to sorted, you can also pass it to max and use a
    different sort method.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 就像你可以将键传递给sorted，你也可以将其传递给max并使用不同的排序方法。
- en: You can work through this code in the Python Tutor at [http://mng.bz/MdjW](http://mng.bz/MdjW).
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在Python Tutor中查看这段代码：[http://mng.bz/MdjW](http://mng.bz/MdjW).
- en: Screencast solution
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 屏幕录制解决方案
- en: 'Watch this short video walkthrough of the solution: [https://livebook.manning.com/
    video/python-workout](https://livebook.manning.com/video/python-workout).'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 观看这个解决方案的简短视频教程：[https://livebook.manning.com/video/python-workout](https://livebook.manning.com/video/python-workout).
- en: Beyond the exercise
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 超越练习
- en: 'Sorting, manipulating complex data structures, and passing functions to other
    functions are all rich topics deserving of your attention and practice. Here are
    a few things you can do to go beyond this exercise and explore these ideas some
    more:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 排序、操作复杂的数据结构以及将函数传递给其他函数都是值得你关注和实践的丰富主题。以下是一些你可以做的事情，以超越这个练习并进一步探索这些想法：
- en: Instead of finding the word with the greatest number of repeated letters, find
    the word with the greatest number of repeated vowels.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 而不是寻找重复字母最多的单词，寻找重复元音最多的单词。
- en: Write a program to read `/etc/passwd` on a Unix computer. The first field contains
    the username, and the final field contains the user’s *shell*, the command interpreter.
    Display the shells in decreasing order of popularity, such that the most popular
    shell is shown first, the second most popular shell second, and so forth.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个程序来读取Unix计算机上的`/etc/passwd`。第一个字段包含用户名，最后一个字段包含用户的*shell*，即命令解释器。按流行度降序显示shell，最流行的shell首先显示，其次是第二流行的shell，依此类推。
- en: For an added challenge, after displaying each shell, also show the usernames
    (sorted alphabetically) who use each of those shells.
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了增加挑战性，在显示每个shell之后，还要显示使用这些shell的用户名（按字母顺序排序）。
- en: Exercise 13 ■ Printing tuple records
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 13 ■ 打印元组记录
- en: A common use for tuples is as records, similar to a `struct` in some other languages.
    And of course, displaying those records in a table is a standard thing for programs
    to do. In this exercise, we’ll do a bit of both--reading from a list of tuples
    and turning them into formatted output for the user.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 元组的一个常见用途是作为记录，类似于某些其他语言中的`struct`。当然，在程序中显示这些记录在表格中是一个标准操作。在这个练习中，我们将做两件事——从元组列表中读取并将它们转换为用户格式化的输出。
- en: 'For example, assume we’re in charge of an international summit in London. We
    know how many hours it’ll take each of several world leaders to arrive:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们负责在伦敦举办一个国际峰会。我们知道几位世界领导人到达需要多少小时：
- en: '[PRE31]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The planner for this summit needs to have a list of the world leaders who are
    coming, along with the time it’ll take for them to arrive. However, this travel
    planner doesn’t need the degree of precision that the computer has provided; it’s
    enough for us to have two digits after the decimal point.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 峰会策划者需要一份即将到来的世界领导人的名单，以及他们到达所需的时间。然而，这个旅行策划者不需要计算机提供的精确度；我们只需要小数点后两位数字就足够了。
- en: 'For this exercise, write a Python function, `format_sort_records`, that takes
    the `PEOPLE` list and returns a formatted string that looks like the following:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个练习，编写一个Python函数`format_sort_records`，它接受`PEOPLE`列表并返回一个格式化的字符串，如下所示：
- en: '[PRE32]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Notice that the last name is printed before the first name (taking into account
    that Chinese names are generally shown that way), followed by a decimal-aligned
    indication of how long it’ll take for each leader to arrive in London. Each name
    should be printed in a 10-character field, and the time should be printed in a
    5-character field, with one space character of padding between each of the columns.
    Travel time should display only two digits after the decimal point, which means
    that even though the input for Xi Jinping’s flight is 10.603 hours, the value
    displayed should be `10.60`.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，姓氏在名字之前打印（考虑到中国名字通常是这样显示的），然后是一个对齐的指示，说明每位领导人到达伦敦需要多长时间。每个名字应打印在10个字符的域中，时间应打印在5个字符的域中，每列之间有一个空格字符的填充。旅行时间应只显示小数点后两位数字，这意味着尽管习近平的航班输入是10.603小时，但显示的值应该是`10.60`。
- en: Working it out
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案
- en: Tuples are often used in the context of structured data and database records.
    In particular, you can expect to receive a tuple when you retrieve one or more
    records from a relational database. You’ll then need to retrieve the individual
    fields using numeric indexes.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 元组通常用于结构化数据和数据库记录的上下文中。特别是，当你从一个关系型数据库检索一个或多个记录时，你可以预期会收到一个元组。然后你需要使用数字索引检索单个字段。
- en: This exercise had several parts. First of all, we needed to sort the people
    in alphabetical order according to last name and first name. I used the built-in
    `sorted` function to sort the tuples, using a similar algorithm to what we used
    with the list of dicts in an earlier exercise. The `for` loop thus iterated over
    each element of our sorted list, getting a tuple (which it called `person`) in
    each iteration. You can often think of a dict as a list of tuples, especially
    when iterating over it using the `items` method (figure 3.11).
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习有几个部分。首先，我们需要根据姓氏和名字按字母顺序对人员进行排序。我使用了内置的 `sorted` 函数来排序元组，使用与我们在早期练习中使用列表字典的类似算法。因此，`for`
    循环遍历了我们排序列表的每个元素，在每次迭代中获取一个元组（它称之为 `person`）。你通常可以将字典视为一个元组的列表，尤其是在使用 `items`
    方法迭代它时（图 3.11）。
- en: '![](../Images/3-11.png)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/3-11.png)'
- en: Figure 3.11 Iterating over our list of tuples (from the Python Tutor)
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.11 迭代我们的元组列表（来自 Python Tutor）
- en: The contents of the tuple then needed to be printed in a strict format. While
    it’s often nice to use f-strings, `str.format` ([http://mng.bz/Z2eZ](http://mng.bz/Z2eZ))
    can still be useful in some circumstances. Here, I take advantage of the fact
    that `person` is a tuple, and that `*person`, when passed to a function, becomes
    not a tuple, but the elements of that tuple. This means that we’re passing three
    separate arguments to `str.format`, which we can access via `{0}`, `{1}`, and
    `{2}`.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 元组的内容需要以严格的格式打印。虽然使用 f-strings 很方便，但在某些情况下 `str.format` ([http://mng.bz/Z2eZ](http://mng.bz/Z2eZ))
    仍然很有用。在这里，我利用了 `person` 是一个元组的事实，以及当 `*person` 传递给一个函数时，它不是一个元组，而是那个元组的元素。这意味着我们向
    `str.format` 传递了三个单独的参数，我们可以通过 `{0}`、`{1}` 和 `{2}` 访问它们。
- en: In the case of the last name and first name, we wanted to use a 10-character
    field, padding with space characters. We can do that in `str.format` by adding
    a colon (`:`) character after the index we wish to display. Thus, `{1:10}` tells
    Python to display the item with index 1, inserting spaces if the data contains
    fewer than 10 characters. Strings are left aligned by default, such that the names
    will be displayed flush left within their columns.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在姓氏和名字的情况下，我们想要使用一个 10 个字符的域，用空格字符填充。我们可以在 `str.format` 中通过在要显示的索引后添加一个冒号（`:`）字符来实现这一点。因此，`{1:10}`
    告诉 Python 显示索引为 1 的项，如果数据包含少于 10 个字符，则插入空格。字符串默认左对齐，因此名字将在它们的列中居左显示。
- en: The third column is a bit trickier, in that we wanted to display only two digits
    after the decimal point, a maximum of five characters, to have the travel-time
    decimal aligned, and (as if that weren’t enough) to pad the column with space
    characters.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 第三列有点棘手，因为我们只想显示小数点后两位数字，最多五位字符，以便使旅行时间的小数对齐，并且（似乎还不够）用空格字符填充列。
- en: In `str.format` (and in f-strings), each type is treated differently. So if
    we simply give `{2:10}` as the formatting option for our floating-point numbers
    (i.e., `person[2]`), the number will be right-aligned. We can force it to be displayed
    as a floating-point number if we put an `f` at the end, as in `{2:10f}`, but that
    will just fill with zeros after the decimal point. The specifier for producing
    two digits after the decimal point, with a maximum of five digits total, would
    be `{5.2f}`, which produces the output we wanted.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `str.format`（以及在 f-strings 中），每种类型都被不同地处理。所以如果我们只是简单地给我们的浮点数（即 `person[2]`）提供一个
    `{2:10}` 的格式化选项，数字将会右对齐。如果我们想在末尾加上一个 `f` 来强制显示为浮点数，就像 `{2:10f}` 一样，但这只会在小数点后填充零。要产生小数点后两位，总共有五位数字的指定符将是
    `{5.2f}`，这将产生我们想要的输出。
- en: Solution
  id: totrans-264
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决方案
- en: '[PRE33]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: ❶ You can use operator.itemgetter with any data structure that takes square
    brackets. You can also pass it more than one argument, as seen here.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 你可以使用 `operator.itemgetter` 与任何使用方括号的数据结构一起使用。你还可以传递多个参数，如这里所示。
- en: You can work through this code in the Python Tutor at [http://mng.bz/04KW](http://mng.bz/04KW).
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 Python Tutor 中运行这段代码：[http://mng.bz/04KW](http://mng.bz/04KW)。
- en: Screencast solution
  id: totrans-268
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 屏幕录制解决方案
- en: 'Watch this short video walkthrough of the solution: [https://livebook.manning.com/
    video/python-workout](https://livebook.manning.com/video/python-workout).'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 观看这个关于解决方案的简短视频：[https://livebook.manning.com/video/python-workout](https://livebook.manning.com/video/python-workout)。
- en: Beyond the exercise
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 除此之外
- en: 'Here are some ideas you can use to extend this exercise and learn more about
    similar data structures:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些你可以用来扩展这个练习并了解更多关于类似数据结构的思想：
- en: If you find tuples annoying because they use numeric indexes, you’re not alone!
    Reimplement this exercise using `namedtuple` objects ([http://mng.bz/gyWl](http://mng.bz/gyWl)),
    defined in the `collections` module. Many people like to use named tuples because
    they give the right balance between readability and efficiency.
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你因为元组使用数字索引而觉得它们很烦人，你并不孤单！使用`collections`模块中定义的`namedtuple`对象（[http://mng.bz/gyWl](http://mng.bz/gyWl)）重新实现这个练习。许多人喜欢使用命名元组，因为它们在可读性和效率之间提供了正确的平衡。
- en: Define a list of tuples, in which each tuple contains the name, length (in minutes),
    and director of the movies nominated for best picture Oscar awards last year.
    Ask the user whether they want to sort the list by title, length, or director’s
    name, and then present the list sorted by the user’s choice of axis.
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义一个包含元组的列表，其中每个元组包含去年奥斯卡最佳影片提名电影的名称、长度（以分钟计）和导演。询问用户是否希望按标题、长度或导演姓名排序列表，然后按用户选择的轴展示排序后的列表。
- en: Extend this exercise by allowing the user to sort by two or three of these fields,
    not just one of them. The user can specify the fields by entering them separated
    by commas; you can use `str.split` to turn them into a list.
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过允许用户按两个或三个这些字段进行排序来扩展这个练习，而不仅仅是其中一个字段。用户可以通过输入以逗号分隔的字段来指定它们；你可以使用`str.split`将它们转换成一个列表。
- en: Summary
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we explored a number of ways we can use lists and tuples and
    manipulate them within our Python programs. It’s hard to exaggerate just how common
    lists and tuples are, and how familiar you should be with them. To summarize,
    here are some of the most important points to remember about them:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了在Python程序中使用列表和元组以及操作它们的多种方法。很难夸张列表和元组有多常见，以及你应该对它们有多熟悉。为了总结，以下是一些关于它们的最重要的要点：
- en: 'Lists are mutable and tuples are immutable, but the real difference between
    them is how they’re used: lists are for sequences of the same type, and tuples
    are for records that contain different types.'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表是可变的，而元组是不可变的，但它们之间的真正区别在于它们的使用方式：列表用于相同类型的序列，而元组用于包含不同类型的记录。
- en: You can use the built-in `sorted` function to sort either lists or tuples. You’ll
    get a list back from your call to `sorted`.
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用内置的`sorted`函数对列表或元组进行排序。从`sorted`的调用中，你会得到一个列表。
- en: You can modify the sort order by passing a function to the `key` parameter.
    This function will be invoked once for each element in the sequence, and the output
    from the function will be used in ordering the elements.
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以通过传递一个函数到`key`参数来修改排序顺序。这个函数将为序列中的每个元素调用一次，并且函数的输出将用于对元素进行排序。
- en: If you want to count the number of items contained in a sequence, try using
    the `Counter` class from the `collections` module. It not only lets us count things
    quickly and easily, and provides us with a `most_common` method, but also inherits
    from `dict`, giving us all of the dict functionality we know and love.
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想要计算序列中包含的项目数量，尝试使用`collections`模块中的`Counter`类。它不仅让我们能够快速轻松地计数，并提供了一个`most_common`方法，而且还继承了`dict`，给我们带来了我们熟悉和喜爱的所有字典功能。
