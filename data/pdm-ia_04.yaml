- en: 3 Volumes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3 卷
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Using volumes to isolate data from the containerized application
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用卷将容器化应用程序的数据隔离开来
- en: Sharing content from your host into containers via volumes
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过卷将主机内容共享到容器中
- en: Using volumes with the user namespace and SELinux
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用用户命名空间和SELinux的卷
- en: Embedding volumes into container images
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将卷嵌入到容器镜像中
- en: Exploring different types of volumes and the volume commands
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索不同类型的卷和卷命令
- en: 'Up until now, the containers you have been working with include all their content
    within the container image. As I described in chapter 1, the only thing required
    to be shared with traditional containers is the Linux kernel. There are several
    reasons you need to isolate application data from the application, including the
    following:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您一直在使用的容器将所有内容都包含在容器镜像中。正如我在第1章中描述的，与传统的容器共享的唯一要求是Linux内核。您需要将应用程序数据与应用程序隔离开来的原因有很多，包括以下内容：
- en: Avoiding embedding actual data for applications such as databases.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免嵌入数据库等应用程序的实际数据。
- en: Using the same container image to run multiple environments.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用相同的容器镜像运行多个环境。
- en: Reducing overhead and improving storage read/write performance, since volumes
    write directly to the filesystem, while containers use the overlay or fuse-overlayfs
    filesystem to mount their layers. *Overlay* is a layered filesystem, meaning the
    kernel needs to copy the previous layer entirely to create a new layer, and fuse-overlayfs
    switches each read and write from kernel space to user space and back. All of
    this creates quite an overhead.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过卷直接写入文件系统，从而减少开销并提高存储读写性能，因为容器使用overlay或fuse-overlayfs文件系统来挂载它们的层。*Overlay*是一种分层文件系统，这意味着内核需要完全复制前一层来创建新层，而fuse-overlayfs将每个读写操作从内核空间切换到用户空间，然后再切换回来。所有这些都造成了相当大的开销。
- en: Sharing content available via network storage.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过网络存储共享内容。
- en: Note `bind` mounts remount parts of the file hierarchy in a different location
    on the filesystem. The files and directories in the `bind` mount are the same
    as the original (see the `mount` command man page for an explanation of `bind`
    mounts). A `bind` mount allows the same content to be accessible in two places,
    without any additional overhead. It is important to understand that `bind` does
    not copy the data or create new data.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`bind`挂载会在文件系统中的不同位置重新挂载文件层次结构的一部分。`bind`挂载中的文件和目录与原始文件相同（有关`bind`挂载的解释，请参阅`mount`命令的手册页）。`bind`挂载允许相同的内容在两个地方可访问，而无需任何额外的开销。重要的是要理解`bind`不会复制数据或创建新数据。
- en: Supporting volumes also adds complexity, especially concerning security. A lot
    of the security features of containers prevent the container processes from gaining
    access to the filesystem outside the container image. In this chapter, you will
    discover the ways Podman allows you to work around these obstacles.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 支持卷也增加了复杂性，尤其是在安全性方面。容器的大多数安全特性都阻止容器进程访问容器镜像之外的文件系统。在本章中，您将了解Podman允许您绕过这些障碍的方法。
- en: 3.1 Using volumes with containers
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 3.1 使用容器卷
- en: 'Let’s go back to your containerized application. Up until now, you have simply
    embedded the web application data into your container filesystem directly. Recall
    that in section 2.1.8, you used the `podman` `exec` command to modify the Hello
    World index.xhtml data within the container:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到您的容器化应用程序。到目前为止，您只是直接将Web应用程序数据嵌入到容器文件系统中。回想一下，在2.1.8节中，您使用了`podman` `exec`命令来修改容器内的Hello
    World index.xhtml数据：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You have made the containerized image more flexible by allowing users to supply
    their own content for the web service or perhaps to update the web service on
    the fly. At the same time, while this method is possible, it is error prone and
    not scalable; it is where volumes come in handy.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 您通过允许用户为网络服务提供自己的内容或可能是在线更新网络服务，使容器化镜像更加灵活。同时，虽然这种方法是可行的，但它容易出错且不可扩展；这就是卷派上用场的地方。
- en: Podman allows you to mount host filesystem content into containers using the
    `podman` `run` command via the `--volume` `(-v)` option.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Podman允许您通过`podman` `run`命令使用`--volume` `(-v)`选项将主机文件系统内容挂载到容器中。
- en: The `--volume` `HOST-DIR:CONTAINER-DIR` option tells Podman to `bind` mount
    `HOST-DIR` in the host to `CONTAINER-DIR` in the container. Podman supports other
    kinds of volumes as well, but in this section, I will focus on `bind` mount volumes.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`--volume` `HOST-DIR:CONTAINER-DIR`选项告诉Podman将主机上的`HOST-DIR`绑定挂载到容器中的`CONTAINER-DIR`。Podman还支持其他类型的卷，但在这个部分，我将专注于`bind`挂载卷。'
- en: It is possible to mount both files or directories in a single option. Changes
    of the content on the host will be seen inside the container. Similarly, if container
    processes change the content inside the container, the changes will be seen on
    the host.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 有可能在一个选项中挂载文件或目录。主机上内容的变化将在容器内看到。同样，如果容器进程更改容器内的内容，这些更改将在主机上看到。
- en: 'Let’s look at an example. Create a directory, html, in your home directory,
    and then create a new html/index.xhtml file in it:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子。在你的主目录中创建一个名为 html 的目录，然后在其中创建一个新的 html/index.xhtml 文件：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now launch a container with the option `-v` `./html:/var/www/html`:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用选项 `-v` `./html:/var/www/html` 启动容器：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Notice the extra `:ro,z` fields in the `--volume` option. The `ro` option tells
    Podman to mount the volume in read-only mode. The read-only mount means processes
    within the container cannot modify any content under /var/www/html, while processes
    on the host are still able to modify the content. Podman defaults all volume mounts
    to read/write mode. The `z` option tells Podman to relabel the content to a shared
    label for use by SELinux (see section 3.1.2).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `--volume` 选项中的额外 `:ro,z` 字段。`ro` 选项告诉 Podman 以只读模式挂载卷。只读挂载意味着容器内的进程不能修改
    /var/www/html 下的任何内容，而主机上的进程仍然可以修改内容。Podman 默认所有卷挂载为读写模式。`z` 选项告诉 Podman 将内容重新标记为共享标签，以便
    SELinux 使用（见 3.1.2 节）。
- en: Now that you have launched the container, open a web browser, and navigate to
    localhost:8080 to make sure the changes have taken place (see figure 3.1).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经启动了容器，打开网页浏览器，导航到 localhost:8080 以确保已发生更改（见图 3.1）。
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '![](../../OEBPS/Images/03-01.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/03-01.png)'
- en: Figure 3.1 Web browser window connecting to the `myimage` Podman container with
    volume mounted L
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1 网页浏览器窗口连接到带有挂载卷的 `myimage` Podman 容器
- en: 'Now you can shut down and remove the container you just created. Removing the
    container does not affect the content at all. The following command removes the
    latest (`--latest`) container, yours. The `--force` option tells Podman to stop
    the container and then remove it:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以关闭并删除你刚刚创建的容器。删除容器不会影响内容。以下命令删除最新的（`--latest`）容器，即你的容器。`--force` 选项告诉
    Podman 停止容器然后删除它：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Finally, remove the content with this command:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用此命令删除内容：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note The `--latest` option is not available on Mac and Windows. You must specify
    the container name or ID. Remote mode is explained in chapter 9, and Podman on
    Mac and Windows is explained in appendixes E and F.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：`--latest` 选项在 Mac 和 Windows 上不可用。你必须指定容器名称或 ID。远程模式在第 9 章中解释，Mac 和 Windows
    上的 Podman 在附录 E 和 F 中解释。
- en: 3.1.1 Named volumes
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.1 命名卷
- en: In the first volume example, you created a directory on disk and then mounted
    it into the container. Similarly, you can take any existing file or directory
    and mount it into a container, as long as you have read access to it.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个卷示例中，你在磁盘上创建了一个目录，然后将其挂载到容器中。同样，只要你对该文件或目录有读取权限，你就可以将其挂载到容器中。
- en: 'Another mechanism for persisting Podman containers data is named `volume`.
    You can create one of these with the `podman` `volume` `create` command. In the
    following example you will create a `volume` named `webdata`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 持久化 Podman 容器数据的另一种机制称为 `volume`。你可以使用 `podman volume create` 命令创建其中一个。在以下示例中，你将创建一个名为
    `webdata` 的 `volume`：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Podman defaults to creating local-named volumes, with storage allocated in
    the container storage directories. You can inspect the volume and look for its
    mount point using the following command:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Podman 默认创建本地命名的卷，存储在容器存储目录中。你可以使用以下命令检查卷并查找其挂载点：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Podman actually creates a directory in your local container storage, /home/dwalsh/
    .local/share/containers/storage/volumes/webdata/_data, to store the content of
    the volume. You can create content from the host in this directory:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Podman 实际上在你的本地容器存储中创建一个目录，/home/dwalsh/ .local/share/containers/storage/volumes/webdata/_data，以存储卷的内容。你可以在该目录中创建来自主机的内容：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now you can run the `myimage` application using this volume:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以使用这个卷来运行 `myimage` 应用程序：
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now refresh the web browser to ensure the file created in the host directory
    is displaying “Goodbye World” (see figure 3.2).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在刷新网页浏览器，以确保在主机目录中创建的文件显示“再见，世界”（见图 3.2）。
- en: '![](../../OEBPS/Images/03-02.png)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](../../OEBPS/Images/03-02.png)'
- en: Figure 3.2 Web browser window connecting to the `myimage` Podman container with
    the named volume mounted
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.2 网页浏览器窗口连接到带有命名卷挂载的 `myimage` Podman 容器
- en: 'Named volumes can be used for more than one container at a time, and they will
    stay around even after the container is removed. If you are done with the named
    volume and container, you can first stop the container without waiting for the
    processes to finish:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 命名卷可以同时用于多个容器，并且即使容器被移除后它们也会保留。如果你完成了命名卷和容器的使用，你可以首先停止容器，无需等待进程完成：
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then remove the volume with the `podman` `volume` `rm` command. Note the `--force`
    option, which tells Podman to remove the volume and all containers that rely on
    the volume:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用`podman volume rm`命令移除卷。注意`--force`选项，它告诉Podman移除卷以及所有依赖该卷的容器：
- en: '[PRE11]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now you can make sure the volume is gone by executing the `volume` `list` command:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以通过执行`volume list`命令来确保卷已被移除：
- en: '[PRE12]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If a named volume doesn''t exist prior to executing the `podman` `run` command,
    it will be created automatically. In the following example, you will specify `webdata1`
    for the name of the named volume, then list the volumes:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在执行`podman run`命令之前不存在命名卷，它将被自动创建。在以下示例中，你将指定`webdata1`作为命名卷的名称，然后列出卷：
- en: '[PRE13]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Of course, this volume is empty. Remove the `webdata1` volume and container:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这个卷是空的。移除`webdata1`卷和容器：
- en: '[PRE14]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Podman also supports other types of volumes. It uses the concept of volume plugins
    so third parties can provide volumes; see the `podman-volume-create` man pages
    for more information.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Podman还支持其他类型的卷。它使用卷插件的概念，以便第三方可以提供卷；有关更多信息，请参阅`podman-volume-create`手册页。
- en: Podman has other interesting volume features. The `podman` `volume` `export`
    command exports all the content of a volume into an external TAR archive. This
    archive can be copied to other machines used to recreate the volume on another
    machine with the `podman` `volume` `import` command. Now that you understand the
    handling of volumes, it is time to dig deeper into volume options.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Podman还有其他有趣的卷功能。`podman volume export`命令将卷的所有内容导出到一个外部的TAR归档中。这个归档可以被复制到其他机器，使用`podman
    volume import`命令在另一台机器上重新创建卷。现在你了解了卷的处理方法，是时候深入了解卷选项了。
- en: 3.1.2 Volume mount options
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.2 卷挂载选项
- en: 'You have been using volume mount options throughout this chapter. The `ro`
    option tells Podman to mount the read-only volume, and the lowercase `z` option
    tells Podman to relabel the content with SELinux labels that will allow multiple
    containers to read and write in the volume:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你在本章中一直在使用卷挂载选项。`ro`选项告诉Podman挂载只读卷，而小写`z`选项告诉Podman使用SELinux标签重新标记内容，这将允许多个容器在卷中读写：
- en: '[PRE15]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Podman supports some other interesting volume options.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Podman支持一些其他有趣的卷选项。
- en: The U volume option
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: U卷选项
- en: Sometimes when you run a rootless container, you need a volume to be owned by
    the user of the container. Imagine your application needs to allow the web server
    to write to the volume. In your container, the Apache Web Server process (`httpd`)
    is run as the `apache` (`UID==60`) user. The html directory in your home directory
    is owned by your UID, meaning it is owned by root inside the container. The kernel
    does not allow a process running as `UID==60` inside the container to make changes
    to a directory owned by root. You must set the ownership of the volume to `UID==60`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 有时当你运行无根容器时，你需要一个由容器用户拥有的卷。想象一下，如果你的应用程序需要允许Web服务器向卷写入。在你的容器中，Apache Web服务器进程（`httpd`）以`apache`（`UID==60`）用户身份运行。你的主目录中的html目录属于你的UID，这意味着在容器内部属于root。内核不允许以`UID==60`运行的容器进程更改属于root的目录。你必须将卷的所有权设置为`UID==60`。
- en: 'In rootless containers, the UIDs of the container are offset by the user namespace.
    My user namespace mapping looks like this:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在无根容器中，容器的UID通过用户命名空间进行偏移。我的用户命名空间映射如下所示：
- en: '[PRE16]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `UID==0` inside the container is my `UID` `3267`, and `UID` `1==100000`,
    `UID` `2==10000` ... `UID60==100059`, meaning I need to set the ownership of the
    html directory to `100059`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 容器内的`UID==0`是我的`UID` `3267`，`UID` `1==100000`，`UID` `2==10000` ... `UID60==100059`，这意味着我需要将html目录的所有权设置为`100059`。
- en: 'I can do this fairly simply, using the `podman` `unshare` command, as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以相当简单地使用`podman unshare`命令来完成这项操作，如下所示：
- en: '[PRE17]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now everything works. One problem with this is that I need to do some mental
    gymnastics to figure out which UID the container will run with.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在一切正常。这个问题的一个问题是，我需要做一些心理体操来弄清楚容器将使用哪个UID。
- en: 'Many container images exist with the default UID defined in them. The `mariadb`
    image is another example of this; it runs with the `mysql` user, `UID=999`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 许多容器镜像都定义了默认的UID。`mariadb`镜像就是这样一个例子；它以`mysql`用户运行，`UID=999`：
- en: '[PRE18]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: If you created a volume to be used for the database, you need to figure out
    what `UID=999` mapped to within the user namespace. On my system this is `UID=100998`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你创建了一个用于数据库的卷，你需要弄清楚`UID=999`在用户命名空间中的映射。在我的系统中这是`UID=100998`。
- en: Podman supplies the `U` command option for this exact situation. The `U` option
    tells Podman to recursively change ownership (`chown`) the source volume to match
    the default UID the container executes with.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Podman为此提供了`U`命令选项。`U`选项告诉Podman递归地更改源卷的所有权（`chown`），使其与容器执行的默认UID相匹配。
- en: 'Try it out by first creating the directory for the database. Notice the directory
    in the home directory is owned by your user:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 通过首先创建数据库目录来尝试一下。注意家目录中的目录是由你的用户拥有的：
- en: '[PRE19]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now run the `mariadb` container with the `--user` `mysql`, and `bind` mount
    the ./mariadb directory to /var/lib/mariadb with the `:U` option. Notice that
    the directory is now owned by the `mysql` user:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行带有`--user mysql`的`mariadb`容器，并使用`:U`选项将./mariadb目录绑定挂载到`/var/lib/mariadb`。注意，现在目录是由`mysql`用户拥有的：
- en: '[PRE20]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If you look at the mariadb directory on the host again, you will see that it
    is now owned by `UID` `100998` or whatever `UID` `999` maps to within your user
    namespace:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你再次查看主机上的mariadb目录，你会看到它现在由`UID` `100998`或`UID` `999`映射到你的用户命名空间中的任何`UID`：
- en: '[PRE21]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: User namespace is not the only security mechanism you need to work around with
    rootless containers. SELinux, while great for container security, can cause some
    problems when working with volumes.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 用户命名空间并不是你需要绕过的唯一安全机制，与无根容器一起使用时，SELinux虽然对容器安全很有帮助，但在处理卷时可能会引起一些问题。
- en: The SELinux volume options
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: SELinux卷选项
- en: In my opinion, SELinux is the best mechanism for protecting the filesystem from
    hostile container processes. Over the years, several container escapes have been
    thwarted by SELinux (see section 10.8 for more information on SELinux).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，SELinux是保护文件系统免受恶意容器进程侵害的最佳机制。多年来，通过SELinux阻止了多次容器逃逸（有关SELinux的更多信息，请参阅第10.8节）。
- en: As I explained previously, volumes leak files from the OS into the container,
    and from an SELinux point of view, these files and directories must be labeled
    correctly, or the kernel will block access.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我之前解释的那样，卷会将文件从操作系统泄露到容器中，从SELinux的角度来看，这些文件和目录必须正确标记，否则内核会阻止访问。
- en: The lowercase `z` command option you have been using in this chapter tells Podman
    to recursively relabel all content in the source directory with a label that can
    be read and written by all containers from an SELinux point of view. If the volume
    will not be used by more than one container, relabeling with the lowercase `z`
    option isn’t what you want. If a different hostile container escapes confinement,
    it might be able to access this data and read/write it. Podman provides an uppercase
    `Z` option that tells Podman to recursively relabel the content in such a way
    that only the processes within the container can read/write the content.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你在本章中一直使用的带下划线的`z`命令选项告诉Podman递归地使用可以由所有容器从SELinux角度读取和写入的标签重新标记源目录中的所有内容。如果卷不会由多个容器使用，使用带下划线的`z`选项并不是你想要的。如果另一个敌对的容器逃逸了限制，它可能能够访问这些数据并对其进行读写。Podman提供了一个大写`Z`选项，告诉Podman以这种方式递归地重新标记内容，这样只有容器内的进程可以读取/写入内容。
- en: In both previous cases, you relabeled the content of the directory. Relabeling
    works great if the directory is specified for use by containers. Sometimes you
    may want to use a container to examine content in a system-specific directory—for
    example, if you want to run a container that examines all the logs in /var/log
    or examines all your home directories (/home/dwalsh).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，你都重新标记了目录的内容。如果目录被指定用于容器使用，重新标记效果很好。有时你可能想使用容器来检查系统特定目录中的内容——例如，如果你想运行一个容器来检查`/var/log`中的所有日志或检查所有家目录（`/home/dwalsh`）。
- en: Note Using this option on a home directory can have disastrous effects on the
    system because it recursively relabels all content in the directory as if the
    data was private to a container. Other confined domains would be prevented from
    using the mislabeled data.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在主目录上使用此选项可能会对系统产生灾难性的影响，因为它会递归地重新标记目录中的所有内容，好像数据是容器私有的。其他受限域将无法使用错误标记的数据。
- en: 'For these cases, you need to disable SELinux enforcement for container separation
    to allow the containers to use the volume. Podman provides the command option
    `--security-opt` `label=disable` to disable SELinux support for a single container,
    basically running the container with an *unconfined* label from an SELinux perspective:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些情况，您需要禁用 SELinux 强制执行以允许容器使用卷。Podman 提供了命令选项 `--security-opt` `label=disable`
    来禁用单个容器的 SELinux 支持，基本上是以 SELinux 视角使用 *未限制* 标签运行容器：
- en: '[PRE22]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Table 3.1 lists and describes all of the mount options available in Podman.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3.1 列出并描述了 Podman 中所有可用的挂载选项。
- en: Table 3.1 Volume mount options
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 表 3.1 卷挂载选项
- en: '| Volume option | Description |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| 卷选项 | 描述 |'
- en: '| `nodev` | Prevent container processes from using character or block devices
    on the volume. |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `nodev` | 防止容器进程在卷上使用字符或块设备。 |'
- en: '| `noexec` | Prevent container processes from direct execution of any binaries
    on the volume. |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `noexec` | 防止容器进程直接在卷上的任何二进制文件上执行。 |'
- en: '| `nosuid` | Prevent SUID applications from changing their privilege on the
    volume. |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `nosuid` | 防止 SUID 应用程序在卷上更改它们的权限。 |'
- en: '| `O` | Mount the directory from the host as a temporary storage using the
    overlay filesystem. Modifications to the mount point are destroyed when the container
    finishes executing. This option is useful for sharing the package cache from the
    host into the container to allow speeding up builds. |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `O` | 使用 overlay 文件系统将主机上的目录作为临时存储挂载。当容器执行完成后，对挂载点的修改将被销毁。此选项对于将主机上的软件包缓存共享到容器中以加快构建速度非常有用。
    |'
- en: '| `[r]shared&#124;``[r]slave&#124;``[r]private&#124;``[r]unbindable` | Specify
    mount propagation mode. Mount propagation controls how changes to mounts are propagated
    across mount boundaries:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '| `[r]shared&#124;``[r]slave&#124;``[r]private&#124;``[r]unbindable` | 指定挂载传播模式。挂载传播控制挂载更改如何在挂载边界之间传播：'
- en: '`private` (default)—Any mounts done inside container will not be visible on
    host and vice versa.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`private`（默认）—在容器内完成的任何挂载在主机上不可见，反之亦然。'
- en: '`shared`—Mounts done under that volume inside container will be visible on
    host and vice versa.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shared`—在该卷内部容器中完成的挂载将在主机上可见，反之亦然。'
- en: '`slave`—Mounts done on host under that volume will be visible inside container
    but not the other way around.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`slave`—在主机上在该卷下完成的挂载将在容器内可见，但反之则不然。'
- en: '`unbindable`—An unbindable version of private mode.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unbindable`—私有模式的非绑定版本。'
- en: The prefix `r` stands for *recursive*, meaning that any mounts underneath the
    mount point will also be treated the same way. |
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 前缀 `r` 代表 *递归的*，意味着挂载点下方的任何挂载也将以相同的方式处理。 |
- en: '| `rw&#124;ro` | Mount a volume in read-only (`ro`) or read-write (`rw`) mode.
    By default, read/write is implied. |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `rw&#124;ro` | 以只读 (`ro`) 或读-写 (`rw`) 模式挂载卷。默认情况下，读/写是隐含的。 |'
- en: '| `U` | Use the correct host UID and GID based on the UID and GID within the
    container. Use with caution because this will modify the host filesystem. |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `U` | 根据容器内的 UID 和 GID 使用正确的主机 UID 和 GID。使用时请谨慎，因为这将修改主机文件系统。 |'
- en: '| `z&#124;Z` | Relabel file objects on the shared volumes. Choose the `z` option
    to label volume content as shared among multiple containers. Choose the `Z` option
    to label content as unshared and private. |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `z&#124;Z` | 在共享卷上重新标记文件对象。选择 `z` 选项将卷内容标记为在多个容器之间共享。选择 `Z` 选项将内容标记为非共享且私有。
    |'
- en: For more information, see the man pages for `mount` and `mount_namespaces(7)`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多信息，请参阅 `mount` 和 `mount_namespaces(7)` 的手册页。
- en: Most of the time, the simple `--volume` option is powerful enough for mounting
    volumes into containers. Over time, the requests for new mount options grew too
    complex, so a new option called `--mount` was added.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数时候，简单的 `--volume` 选项就足以将卷挂载到容器中。随着时间的推移，对新挂载选项的需求变得越来越复杂，因此添加了一个名为 `--mount`
    的新选项。
- en: 3.1.3 podman run - -mount command option
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 3.1.3 podman run - -mount 命令选项
- en: The `podman` `run` `--mount` option is a much closer option to the underlying
    Linux mount command. It allows you to specify all of the mount options that the
    mount command understands; Podman passes them down directly to the kernel.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`podman` `run` `--mount` 选项与底层 Linux 挂载命令非常相似。它允许您指定挂载命令理解的所有挂载选项；Podman 直接将它们传递给内核。'
- en: The only mount types currently supported are `bind`, `volume`, `image`, `tmpfs`,
    and `devpts`. (For more information, see the `podman-mount(1)` man page for more
    information.)
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当前支持的唯一挂载类型是 `bind`、`volume`、`image`、`tmpfs` 和 `devpts`。（有关更多信息，请参阅 `podman-mount(1)`
    手册页。）
- en: Volumes and mounts are excellent ways to keep data separate from the container
    image. In most cases, the container image should be treated as read-only, and
    any data that needs to be written or is not specific to the application should
    be stored outside of the container image via volumes. In a lot of cases, you will
    get much better performance keeping your data separate, because reads and writes
    will not have the overhead of the copy-on-write filesystem. These mounts also
    make it easier to use the same container images with different data (table 3.2).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 卷和挂载是保持数据与容器镜像分离的绝佳方式。在大多数情况下，容器镜像应该被视为只读的，任何需要写入或与应用程序不特定的数据都应该通过卷存储在容器镜像之外。在许多情况下，通过保持数据分离可以获得更好的性能，因为读写不会产生写时复制的文件系统开销。这些挂载还使得使用不同的数据（表3.2）与相同的容器镜像变得更容易。
- en: Table 3.2 Podman volume commands
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 表3.2 Podman卷命令
- en: '| Command | Man page | Description |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| 命令 | 手册页 | 描述 |'
- en: '| `create` | `podman-volume-create(1)` | Create a new volume. |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| `create` | `podman-volume-create(1)` | 创建一个新的卷。|'
- en: '| `exists` | `podman-volume-exists(1)` | Check if a volume exists. |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| `exists` | `podman-volume-exists(1)` | 检查卷是否存在。|'
- en: '| `export` | `podman-volume-export(1)` | Export the contents of a volume into
    a tar ball. |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| `export` | `podman-volume-export(1)` | 将卷的内容导出到一个tar包中。|'
- en: '| `import` | `podman-volume-import(1)` | Untar a tarball into a volume. |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `import` | `podman-volume-import(1)` | 将tar包解压到卷中。|'
- en: '| `inspect` | `podman-volume-inspect(1)` | Display detailed information on
    a volume. |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| `inspect` | `podman-volume-inspect(1)` | 显示卷的详细信息。|'
- en: '| `list` | `podman-volume-list(1)` | List all of the volumes. |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| `list` | `podman-volume-list(1)` | 列出所有卷。|'
- en: '| `prune` | `podman-volume-prune(1)` | Remove all unused volumes. |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| `prune` | `podman-volume-prune(1)` | 删除所有未使用的卷。|'
- en: '| `rm` | `podman-volume-rm(1)` | Remove one or more volumes. |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| `rm` | `podman-volume-rm(1)` | 删除一个或多个卷。|'
- en: Summary
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Volumes are useful for separating the data used by a container from the application
    inside an image.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 卷对于将容器使用的数据与应用程序镜像内的数据分离非常有用。
- en: Volumes mount parts of the filesystem into a container's environment, which
    means security concerns like SELinux and user namespace need to be modified to
    allow access.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 卷将文件系统的部分挂载到容器环境中，这意味着需要修改像SELinux和用户命名空间这样的安全相关设置，以允许访问。
