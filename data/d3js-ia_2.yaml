- en: Part 3\. Advanced techniques
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第三部分。高级技术
- en: The final four chapters are focused on moving beyond small-scale and one-off
    data visualization products toward creating interactive applications and the reusable
    code they require. [Chapter 9](../Text/kindle_split_020.html#ch09) integrates
    React to tie together multiple charts using different layouts with brush-based
    filtering to produce a data dashboard. [Chapter 10](../Text/kindle_split_021.html#ch10)
    focuses on the structure of components and layouts in D3 by walking you through
    the creation of a simple grid layout and legend component. [Chapter 11](../Text/kindle_split_022.html#ch11)
    tackles the problem of representing thousands of datapoints graphically onscreen
    while maintaining performance and interactivity. Overall, [part 3](#part03) gives
    you the skills necessary to build your own framework or application on top of
    D3, with high performance in a big data environment.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 最后四章专注于从小型和一次性数据可视化产品转向创建交互式应用程序及其所需的可重用代码。[第9章](../Text/kindle_split_020.html#ch09)通过集成React，使用基于刷选的过滤和不同的布局将多个图表结合起来，以生成数据仪表板。[第10章](../Text/kindle_split_021.html#ch10)通过引导你创建一个简单的网格布局和图例组件，专注于D3中组件和布局的结构。[第11章](../Text/kindle_split_022.html#ch11)处理在保持性能和交互性的同时，在屏幕上图形化表示数千个数据点的问题。总体而言，[第三部分](#part03)为你提供了在D3之上构建自己的框架或应用程序所需的技能，在大数据环境中具有高性能。
- en: Chapter 9\. Interactive applications with React and D3
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第9章。使用React和D3的交互式应用程序
- en: '*This chapter covers*'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Using D3 with React
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用D3与React
- en: Linking multiple charts
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 链接多个图表
- en: Automatically resizing graphics based on screen size change
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据屏幕尺寸变化自动调整图形大小
- en: Creating and using brush controls
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和使用刷选控件
- en: Throughout this book, you’ve seen how data can be measured and transformed to
    produce charts highlighting one or another aspect of the data. Even though you’ve
    used the same dataset in different layouts and with different methods, you haven’t
    presented different charts simultaneously. In this chapter, you’ll learn how to
    tie multiple views of your data together using React. This type of application
    is typically referred to as a *dashboard* in data visualization terminology (an
    example of which will be built in this chapter, as shown in [figure 9.1](#ch09fig01)).
    You’ll need to create and manage multiple `<svg>` elements as well as implement
    the brush component, which allows you to easily select part of a dataset. You’ll
    also need to more clearly understand how data-binding and D3’s enter/exit/update
    pattern work so that you can effectively integrate D3 with external frameworks.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，你已经看到了数据如何被测量和转换以生成突出显示数据一个或多个方面的图表。尽管你使用了相同的数据库在不同布局和不同方法中，但你没有同时展示不同的图表。在本章中，你将学习如何使用React将你的数据的不同视图结合起来。这种类型的应用程序在数据可视化术语中通常被称为*仪表板*（本章将构建一个示例，如图9.1所示）。你需要创建和管理多个`<svg>`元素，以及实现刷选组件，这允许你轻松选择数据集的一部分。你还需要更清楚地理解数据绑定和D3的进入/退出/更新模式是如何工作的，以便你能够有效地将D3与外部框架集成。
- en: Figure 9.1\. Throughout this chapter, we’ll build toward this fully operational
    data dashboard, first creating the individual chart elements ([section 9.1](#ch09lev1sec1)),
    then adding interactivity ([section 9.2](#ch09lev1sec2)), and finally adding a
    brush to filter the data ([section 9.3](#ch09lev1sec3)).
  id: totrans-9
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.1。在本章中，我们将逐步构建一个完全可操作的数据仪表板，首先创建单个图表元素（[第9.1节](#ch09lev1sec1)），然后添加交互性（[第9.2节](#ch09lev1sec2)），最后添加刷选功能以过滤数据（[第9.3节](#ch09lev1sec3)）。
- en: '![](../Images/09fig01_alt.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/09fig01_alt.jpg)'
- en: '|  |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Infoviz term: dashboard**'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**信息可视化术语：仪表板**'
- en: Multiple charts combined into a single application have been around since the
    1970s and were traditionally associated with decision support systems. Dashboards
    provide the kind of multiple views into a dataset that you’ll see in this chapter
    and are often the selling point of charting libraries like NVD3.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 自1970年代以来，将多个图表组合成单个应用程序就已经存在，并且传统上与决策支持系统相关联。仪表板提供了你在本章中看到的数据集的多种视图，通常是像NVD3这样的图表库的卖点。
- en: Although they’re typically presented as several charts sharing screen space,
    the principles of data dashboards can also be applied to web mapping and text-based
    applications through modal pop-ups or any website that provides several different
    charts simultaneously. In those cases, the act of highlighting datapoints may
    be a response to the scrolling of text or zooming in on a map, rather than mousing
    over a data visualization element.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它们通常以几个图表共享屏幕空间的形式呈现，但数据仪表板的原则也可以通过模态弹出窗口或任何同时提供多个不同图表的网站应用于网络地图和基于文本的应用程序。在这些情况下，突出显示数据点的行为可能是对文本滚动或地图缩放的响应，而不是鼠标悬停在数据可视化元素上。
- en: '|  |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 9.1\. One data source, many perspectives
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.1\. 一个数据源，多个视角
- en: We start with a design for our dashboard. Designs can be rough sketches or detailed
    sets of user requirements. Let’s imagine you work for the leading European online
    seller of table mats, MatFlicks, and you’re in charge of creating a dashboard
    showing their rollout to North America and South America. The genius CEO of MatFlicks,
    Matt Flick, decided the rollout strategy would be alphabetical, so Argentina gets
    access on Day 0, and every day one more country gets access to the amazing MatFlicks
    inventory. They need to see how the rollout is progressing geographically, over
    time and in total per country. [Figure 9.2](#ch09fig02) shows a simple sketch
    to achieve this using several of the charts we’ve explored in previous chapters.
    We’re going to randomly generate MatFlicks data like we’ve done before, with each
    country only generating random data after its rollout and then after that one
    data point representing amount of sales (in billions of euros) per day.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从仪表板的设计开始。设计可以是粗糙的草图或详细的用户需求集。让我们假设你为领先的欧洲在线桌布销售商MatFlicks工作，并且你负责创建一个展示其北美和南美推广情况的仪表板。MatFlicks的杰出CEO，Matt
    Flick，决定推广策略将是按字母顺序进行的，因此阿根廷在第0天获得访问权限，之后每天增加一个国家获得令人惊叹的MatFlicks库存的访问权限。他们需要看到推广在地理上、随时间以及按国家总量的进展情况。[图9.2](#ch09fig02)展示了使用我们在前几章中探讨的几个图表来实现这一目标的简单草图。我们将像之前一样随机生成MatFlicks数据，每个国家在其推广之后以及之后，每天只生成代表每天销售额（以十亿欧元为单位）的一个数据点。
- en: Figure 9.2\. A sketch of a dashboard, showing a map, bar chart, and stacked
    area chart that display our data
  id: totrans-18
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.2\. 一个仪表板的草图，展示了地图、柱状图和堆叠面积图，它们展示了我们的数据
- en: '![](../Images/09fig02.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/09fig02.jpg)'
- en: With a data dashboard like this, we want to provide a user with multiple perspectives
    into the data as well as the ability to drill down into the data and see individual
    datapoints. We’ll use a line chart to see the change over time, a bar chart for
    raw total changes, and a map so that users can see the geographic distribution
    of our data. We also want to let users slice and dice their data, so later we’ll
    add that functionality with a brush.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这样的数据仪表板，我们希望为用户提供对数据的多个视角，以及深入数据并查看单个数据点的功能。我们将使用折线图来查看随时间的变化，柱状图来显示原始总变化，以及地图，以便用户可以看到数据的地理分布。我们还希望让用户能够切割和切块他们的数据，因此稍后我们将通过刷子添加这一功能。
- en: From the sketch, you can easily imagine interaction possibilities and changes
    that you may want to see based on user activity—for instance, highlighting which
    elements in each chart correspond to elements in other charts, or giving more
    detail on a particular element based on a click.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 从草图上，你可以轻松想象基于用户活动的交互可能性以及你可能希望看到的变化——例如，突出显示每个图表中与其他图表中的元素相对应的元素，或者根据点击提供特定元素的更多细节。
- en: By the time you’re done with this chapter, you’ll have created the data dashboard
    shown in [figure 9.1](#ch09fig01), with interactivity and dynamic filtering. The
    CSS for the dashboard is in [listing 9.1](#ch09ex01). It’s simple and necessary
    for the brush component we’ll see later; most of the other styles will be inline.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 到你完成这一章的时候，你将已经创建出[图9.1](#ch09fig01)中展示的数据仪表板，它具有交互性和动态筛选功能。仪表板的CSS代码位于[列表9.1](#ch09ex01)。它很简单，对于后面我们将看到的刷子组件来说是必要的；其他大多数样式都将内联显示。
- en: Listing 9.1\. Dashboard CSS
  id: totrans-23
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.1\. 仪表板CSS
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Any application we design needs to be responsive so that it adjusts how it’s
    drawn based on the size of the screen. We could also use the `viewport` attribute
    of an SVG element to automatically resize the graphics, but we’ll want more fine-grained
    control of our graphics when creating data visualization applications (recall
    the distinction between graphical and semantic zoom discussed in [chapter 7](../Text/kindle_split_017.html#ch07)).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设计的任何应用程序都需要是响应式的，以便根据屏幕大小调整其绘制方式。我们也可以使用 SVG 元素的 `viewport` 属性来自动调整图形的大小，但在创建数据可视化应用程序时，我们可能希望对图形有更精细的控制（回想一下第
    7 章中讨论的图形和语义缩放的区分）。
- en: '|  |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**ES2015**'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**ES2015**'
- en: 'You’ve seen arrow functions and promises up until this point, but in the following
    code you’re going to see more ES2015 than you might have before. I hope by the
    time you read this that the functionality here is familiar to you and common to
    JS development. But if you see something strange, that’s probably ES2015\. I can’t
    highlight every difference, but here are a few new pieces that you’ll see:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了箭头函数和承诺，但在这段代码中，你将看到比之前更多的 ES2015 特性。我希望在你阅读这段内容的时候，这里的特性对你来说已经熟悉，并且是
    JS 开发中常见的。但如果看到什么奇怪的地方，那可能就是 ES2015 的特性。我无法突出显示每一个差异，但这里有一些你将看到的新特性：
- en: '`const` and `let` are new declarations that are cleaner than `var` and that
    make a read-only constant (`const`) or variable (`let`) and are scoped much more
    cleanly than `var`. If you replaced them all with `var`, the code would run the
    same; they make your code more hygienic because they require you to know what
    you’re doing with your identifiers.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`const` 和 `let` 是比 `var` 更干净的声明，它们创建一个只读常量（`const`）或变量（`let`），并且比 `var` 的作用域更清晰。如果你把它们都替换成
    `var`，代码仍然会运行；它们使你的代码更卫生，因为它们要求你知道你在做什么。'
- en: '`[...array], {...object}` are spread operators that allow you to turn arrays
    and objects into sets of variables or properties. You can use it to combine arrays
    or objects without using `Object.assign` or `Array.concat`. Note that the rest
    parameter syntax also looks the same but is used to send an array of variables
    to a function without using `function.apply`.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`[...array], {...object}` 是展开操作符，允许你将数组和对象转换为变量或属性的集合。你可以用它来组合数组或对象，而无需使用 `Object.assign`
    或 `Array.concat`。注意，剩余参数语法看起来相同，但用于将变量数组发送给函数而不使用 `function.apply`。'
- en: 'You can instantiate identifiers from passed objects like this:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以这样实例化从传递的对象中获取的标识符：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ES6 and node lets you include pieces of JavaScript or other code from other
    files using the `import/export` syntax.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: ES6 和 node 允许你使用 `import/export` 语法从其他文件中包含 JavaScript 或其他代码片段。
- en: '`function({ a: 1, b: 2 })`: Functions could always take objects that you could
    destructure on your own, but now you can directly pass the object without any
    intermediate code. You don’t have to think about undefined or null values in your
    list of variables you send to a function; instead, you send an object with those
    properties.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`function({ a: 1, b: 2 })`：函数始终可以接受你可以自己解构的对象，但现在你可以直接传递对象而不需要任何中间代码。你不需要考虑你发送给函数的变量列表中的
    undefined 或 null 值；相反，你发送一个具有这些属性的对象。'
- en: '|  |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 9.2\. Getting started with React
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.2. React 入门
- en: React is a view lifecycle management system that’s part of a popular MVC framework
    and development pattern. React is the view layer and lets you define HTML components
    with custom behavior, which is super useful for composing applications. It uses
    a JavaScript + HTML language called JSX that disgusted me when I first saw it,
    but now I love it. I didn’t like it because I always felt like JavaScript and
    HTML should live in totally separate worlds, but I found out later that writing
    HTML inside JavaScript could be incredibly useful when you’re manipulating the
    DOM like we’ve been with vanilla D3 throughout this book.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: React 是一个视图生命周期管理系统，它是流行 MVC 框架和开发模式的一部分。React 是视图层，允许你定义具有自定义行为的 HTML 组件，这对于组合应用程序非常有用。它使用一种名为
    JSX 的 JavaScript + HTML 语言，当我第一次看到它时，我感到很厌恶，但现在我爱上了它。我不喜欢它，因为我总觉得 JavaScript 和
    HTML 应该生活在完全不同的世界里，但后来我发现，当你像我们在本书中用 vanilla D3 做的那样操作 DOM 时，在 JavaScript 中编写
    HTML 可以非常有用。
- en: Typically when you see examples of React, they pair it with a kind of state
    management system like Flux or Redux. We won’t be doing that in this chapter.
    This is a single chapter, and you can find entire books about React.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 通常当你看到 React 的示例时，它们会与像 Flux 或 Redux 这样的状态管理系统配对。我们在这章中不会这样做。这是一个单独的章节，你可以找到关于
    React 的整本书。
- en: Whereas the rest of this book has focused on core HTML and JavaScript, this
    section is going to rely on new technologies. You’re going to need `node` and
    node package manager (`npm`) that comes with `node` installed on your system as
    well as a slight amount of comfort with the command line. There are great books
    on React, such as *React Quickly*, so this will only scratch the surface, but
    you can create a fully self--contained React data visualization application.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 与本书的其他部分专注于核心HTML和JavaScript不同，本节将依赖于新技术。你需要安装在你系统上的`node`以及随`node`一起安装的节点包管理器（`npm`），以及稍微熟悉一下命令行。关于React有很多优秀的书籍，例如《React快速入门》，所以这里只能触及皮毛，但你仍然可以创建一个完全自包含的React数据可视化应用程序。
- en: 9.2.1\. Why React, why not X?
  id: totrans-40
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.2.1. 为什么选择React，而不是X？
- en: React is obviously the best library ever made, and if you like Angular, you’re
    dumb, bro (and don’t even get me started on Ember). No, not really. That’s horrible,
    and it’s too bad that people get so invested in the righteousness of their particular
    library.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: React显然是制作过的最佳库，如果你喜欢Angular，那你就是傻瓜（而且我不打算开始谈论Ember）。不，不是真的。那很糟糕，很遗憾人们如此投入于他们特定库的正义性。
- en: I wanted to show people how to deal with D3 in a modern MVC environment and
    I know React best. Even if you never use React, you’ll probably see patterns in
    this chapter that apply to other frameworks. And even if you hate MVC frameworks,
    you can use most of the code in this chapter in your own custom, hand-rolled,
    beautifully opaque bespoke dashboard.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我想向大家展示如何在现代MVC环境中处理D3，而我最熟悉的是React。即使你从未使用过React，你在这章中也可能看到适用于其他框架的模式。即使你讨厌MVC框架，你也可以在本章的大部分代码中找到你自己的定制、手工制作、美丽而神秘的仪表板。
- en: Fundamentally, React consists of a component creation framework that lets you
    build self-contained elements (like `div` or `svg:rect`) that have custom rendering
    methods, properties, state, and lifecycle methods.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，React由一个组件创建框架组成，它允许你构建自包含的元素（如`div`或`svg:rect`），这些元素具有自定义的渲染方法、属性、状态和生命周期方法。
- en: Render
  id: totrans-44
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 渲染
- en: One of the major features of React is that it keeps track of a copy of the DOM,
    known as the virtual DOM, which it can use to only render elements that need to
    change based on receiving new data-saving cycles and speeding up your web applications.
    This was React’s big selling point when it first dropped, but it’s become popular
    with other view rendering systems. The `render()` function in each React component
    returns the elements that will be created by React (typically described using
    JSX, which is introduced in this chapter).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: React的一个主要特性是它跟踪DOM的一个副本，称为虚拟DOM，它可以用来仅渲染需要根据接收到的新的数据而改变元素，从而节省周期并加快你的Web应用程序。这是React首次发布时的一个重要卖点，但它已经成为其他视图渲染系统的流行选择。每个React组件中的`render()`函数返回React将创建的元素（通常使用本章中引入的JSX描述）。
- en: Props
  id: totrans-46
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Props
- en: Attributes of a component are sent to it when it’s created—known as props. These
    props of a React component are typically available in the component functions
    via the `this` context as `this.props`. In certain cases, such as stateless components
    or constructors, you won’t use `this` to access them, but we won’t do that in
    this chapter, so you’ll need a book dedicated to React to get to know the other
    patterns. This structure lets you send data down from parent components to child
    components, and you can use that data to modify how the component is rendered.
    You’ll see this in detail when we get into the code.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当组件创建时，其属性会被发送给它——称为props。React组件的这些props通常可以通过`this`上下文在组件函数中访问，作为`this.props`。在某些情况下，例如无状态组件或构造函数，你不会使用`this`来访问它们，但我们在本章中不会这样做，所以你需要一本专门介绍React的书来了解其他模式。这种结构允许你从父组件向下发送数据到子组件，你可以使用这些数据来修改组件的渲染方式。当你进入代码部分时，你将详细了解这一点。
- en: State
  id: totrans-48
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 状态
- en: Whereas props are sent down to a component, the state of a component is stored
    and modified internally within the component. Like `this.props`, there’s a corresponding
    `this.state` that will give you the current state. When you modify state (using
    `this.setState` in a component) it will automatically trigger a re-render unless
    you’ve modified `shouldComponentUpdate` (a lifecycle method dealt with in the
    next section).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 与props向下发送到组件不同，组件的状态是在组件内部存储和修改的。像`this.props`一样，有一个相应的`this.state`会给你当前的州。当你修改状态（在组件中使用`this.setState`）时，它将自动触发重新渲染，除非你修改了`shouldComponentUpdate`（下一节将处理的生命周期方法）。
- en: Lifecycle methods
  id: totrans-50
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 生命周期方法
- en: React components expose lifecycle methods that fire as the component is created
    and updated and receives its props. They are incredibly useful and even necessary
    in certain use cases, as we’ll see later. You have, for instance, `shouldComponentUpdate`,
    which lets you specify the logic for whether or not the component re-renders when
    it receives new props or state. There’s also `willComponentUpdate` and `didComponentUpdate`
    to add functionality to your component before or after it updates, along with
    similar methods for when the component first mounts or exits (and a few more).
    I’ll get into these methods as they apply to our data visualization needs but
    I won’t touch on all of them.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: React组件暴露了在组件创建、更新和接收其属性时触发的生命周期方法。它们在特定用例中非常有用，甚至在某些情况下是必要的，正如我们稍后将要看到的。例如，您有`shouldComponentUpdate`，它允许您指定组件在接收到新属性或状态时是否重新渲染的逻辑。还有`willComponentUpdate`和`didComponentUpdate`，可以在组件更新前后添加功能，以及当组件首次挂载或退出时的类似方法（还有一些其他方法）。我将根据它们与我们的数据可视化需求相关的方法来介绍这些方法，但不会涉及所有这些方法。
- en: '9.2.2\. react-create-app: setting up your application'
  id: totrans-52
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.2.2. react-create-app：设置您的应用程序
- en: 'One of the challenges of modern development is getting your environment set
    up. Fortunately, there’s a command line tool that gets you started, and it’s supported
    by the React team: `create-react-app`'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现代开发的一个挑战是设置您的环境。幸运的是，有一个命令行工具可以帮助您开始，并且它得到了React团队的支持：`create-react-app`
- en: 'In OS X you can open your terminal window and run the following commands:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在OS X上，您可以打开您的终端窗口并运行以下命令：
- en: '[PRE2]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Setting up your React app is that easy. If you navigate to `localhost:3000`,
    you’ll see the boilerplate `create-react-app` page in [figure 9.3](#ch09fig03).
    If you have any issues or need instructions for Windows, see [https://github.com/facebookincubator/create-react-app](https://github.com/facebookincubator/create-react-app).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 设置您的React应用程序非常简单。如果您导航到`localhost:3000`，您将看到[图9.3](#ch09fig03)中的样板`create-react-app`页面。如果您有任何问题或需要Windows的说明，请参阅[https://github.com/facebookincubator/create-react-app](https://github.com/facebookincubator/create-react-app)。
- en: Figure 9.3\. The default page that `create-react-app` deploys with
  id: totrans-57
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.3. `create-react-app` 默认部署的页面
- en: '![](../Images/09fig03.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/09fig03.jpg)'
- en: 'Along with starting your node server running the code, this will create all
    the structure you need to build and deploy a React application that we’re going
    to use to build our dashboard. That structure contains a package.json file that
    references all the modules included in your project and to which we need to add
    a couple more modules to make our dashboard. We add modules using NPM and while
    we could include the entire D3 library and keep coding like we have, you’re better
    off installing the individual modules and understanding how importing those modules
    works. In your project directory run the following to install the `d3-scale` module:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 除了启动运行代码的node服务器外，这还将创建构建和部署我们将用于构建仪表板的React应用程序所需的所有结构。该结构包含一个package.json文件，它引用了项目中包含的所有模块，并且我们需要添加几个更多模块来制作我们的仪表板。我们使用NPM添加模块，虽然我们可以包含整个D3库并继续编码，但您最好安装单个模块并理解如何导入这些模块。在您的项目目录中运行以下命令来安装`d3-scale`模块：
- en: '[PRE3]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This command (`npm i` is short for `npm install`) installs the latest version
    of `d3-scale` (which gives us access to all those wonderful scales we’ve been
    using in the last eight chapters), and the `–SE` tag saves the exact version to
    your package.json so that when you want to deploy this application elsewhere,
    `d3-scale` is installed. Along with `d3-scale`, do the same thing with the following
    modules:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令（`npm i`是`npm install`的缩写）安装了`d3-scale`的最新版本（这为我们提供了访问我们在过去八章中使用过的所有那些美妙的比例尺），并且`–SE`标签将确切版本保存到您的package.json中，以便当您想要在其他地方部署此应用程序时，`d3-scale`会被安装。除了`d3-scale`之外，对以下模块执行相同操作：
- en: '[PRE4]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: By installing modules individually like this, you reduce the amount of code
    you’ll deploy with your application, decreasing load time and improving maintainability.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 通过像这样单独安装模块，您可以减少与您的应用程序一起部署的代码量，从而降低加载时间并提高可维护性。
- en: 9.2.3\. JSX
  id: totrans-64
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.2.3. JSX
- en: '*JSX* refers to JavaScript + XML, an integrated JavaScript and HTML coding
    language that lets you write HTML inline with your JavaScript code. It requires
    that the code be transpiled to plain JavaScript—your browser can’t natively run
    JSX—but as long as you have your transpiling set up (which react-create-app already
    does for you), you can write code like this:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '*JSX*指的是JavaScript + XML，这是一种集成JavaScript和HTML的编码语言，允许你在JavaScript代码中内联编写HTML。它要求代码被转换为纯JavaScript——你的浏览器不能原生运行JSX——但只要你的转换设置好了（react-create-app已经为你做了），你就可以编写这样的代码：'
- en: '[PRE5]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: And you can create an array of three div elements, each of which will have the
    corresponding string from your array as content. Notice a few things going on
    here. One, when we start writing in HTML, we have to use curly braces (bolded
    for emphasis in preceding code) to get out of it if we want to put JavaScript
    there. If I hadn’t put curly braces around the `d`, for instance, then all my
    divs would have had the letter *d* as their content. Another is that style is
    an object passed to an element and that object needs CSS keys that usually are
    snake case (like `margin-left`) turned into camelcase (-`marginLeft`). When we’re
    making an array of elements, each needs a “key” property that gives it a unique
    key (like the optional key when we’re using `.data()` with D3). Finally, when
    you want to set an element’s CSS class, you need to use `className`, because `class`
    is reserved.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以创建一个包含三个div元素的数组，每个元素都将包含你数组中的相应字符串作为内容。注意这里的一些事情。第一，当我们开始编写HTML时，如果我们想在其中放置JavaScript，我们必须使用花括号（在前面代码中用粗体表示强调）来退出它。例如，如果我没在`d`周围放置花括号，那么所有我的div都将包含字母*d*作为其内容。另一个是样式是一个传递给元素的对象，并且该对象需要CSS键，这些键通常是蛇形命名法（如`margin-left`）转换为驼峰命名法（-`marginLeft`）。当我们创建一个元素数组时，每个元素都需要一个“key”属性，以给它一个唯一的键（就像我们使用D3的`.data()`时的可选键）。最后，当你想设置一个元素的CSS类时，你需要使用`className`，因为`class`是保留的。
- en: There’s more to JSX, but that should be enough to let you make sense of the
    code you’re going to see. When I first saw JSX, as I already mentioned, I was
    convinced it was a horrible idea and planned to only use the pure JavaScript rendering
    functions that React has (you don’t need to use JSX to use React), but after a
    couple weeks, I fell in love with JSX. The ability to create elements on the fly
    from data appealed to me because of my experience with D3.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: JSX还有更多内容，但这应该足以让你理解你将要看到的代码。当我第一次看到JSX时，如我之前提到的，我确信这是一个糟糕的想法，并计划只使用React的纯JavaScript渲染函数（你不需要使用JSX来使用React），但几周后，我爱上了JSX。从数据中动态创建元素的能力吸引了我，因为我有D3的经验。
- en: 9.3\. Traditional D3 rendering with React
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.3\. 使用React的传统D3渲染
- en: The challenge of integrating D3 with React is that React and D3 both want to
    control the DOM. The entire select/enter/exit/update pattern with D3 is in direct
    conflict with React and its virtual DOM. If you’re coming to React from D3, giving
    up your grip on the DOM is one of those “cold, dead hands” moments. The way most
    people use D3 with React is to use React to build the structure of the application,
    and to render traditional HTML elements, and then when it comes to the data visualization
    section, they pass a DOM container (typically an `<svg>`) over to D3 and use D3
    to create and destroy and update elements. In a way, it’s similar to the way we
    used to use Java applets or Flash to run a black box in your page while the rest
    of your page is rendered separately. The benefit of this method of integrating
    React and D3 is that you can use all the same kind of code you see in all the
    core D3 examples. The main difficulty is that you need to create functions in
    various React lifecycle events to make sure your viz updates.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 将D3与React集成的挑战在于，React和D3都想要控制DOM。D3的整个select/enter/exit/update模式与React及其虚拟DOM直接冲突。如果你是从D3转向React，放弃对DOM的控制是那些“冰冷、死手”的时刻之一。大多数人使用D3与React的方式是使用React构建应用程序的结构，并渲染传统的HTML元素，然后在数据可视化部分，他们将一个DOM容器（通常是`<svg>`）传递给D3，并使用D3创建、销毁和更新元素。从某种意义上说，这与我们过去使用Java小程序或Flash在页面中运行一个黑盒子的方式类似，而页面的其余部分则是单独渲染的。这种集成React和D3的方法的好处是，你可以使用所有你在核心D3示例中看到的那种类型的代码。主要的困难在于，你需要创建在React生命周期事件中的函数，以确保你的可视化更新。
- en: '[Listing 9.2](#ch09ex02) shows a simple bar chart component built using this
    method. Create this component in your `src/` directory and save it as `BarChart.js`.
    In React, component filenames and function names are typically differentiated
    from other code files and functions by using camelcase and capitalizing the first
    letter.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表9.2](#ch09ex02)展示了使用这种方法构建的一个简单的条形图组件。在你的`src/`目录中创建这个组件，并将其保存为`BarChart.js`。在React中，组件文件名和函数名通常通过使用驼峰式命名法和首字母大写来与其他代码文件和函数区分开来。'
- en: Listing 9.2\. BarChart.js
  id: totrans-72
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.2\. BarChart.js
- en: '[PRE6]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '***1* Because we’re importing these functions from the modules, they will not
    have the d3\. prefix**'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 因为我们从模块中导入这些函数，它们将不会有d3\.前缀**'
- en: '***2* You need to bind the component as the context to any new internal functions—this
    doesn’t need to be done for any existing lifecycle functions**'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 你需要将组件绑定为新内部函数的上下文——这不需要对任何现有的生命周期函数进行操作**'
- en: '***3* Fire your bar chart function whenever the component first mounts or receives
    new props/state**'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 在组件首次挂载或接收到新的props/state时调用你的条形图函数**'
- en: '***4* The element itself is referenced in the component when you render so
    you can use it to hand over to D3**'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 当你渲染时，该元素在组件中被引用，你可以用它来传递给D3**'
- en: '***5* Use the passed size and data to calculate your scale**'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 使用传递的大小和数据来计算你的比例**'
- en: '***6* Render is returning an SVG element waiting for your D3 code**'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* Render返回一个等待你的D3代码的SVG元素**'
- en: '***7* Pass a reference to the node for D3 to use**'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 将节点引用传递给D3使用**'
- en: Making these changes and saving them won’t show any immediate effect because
    you’re not importing and rendering this component in App.js, which is the component
    initially rendered by your app. Change App.js to match the following listing.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 进行这些更改并保存它们不会立即显示任何效果，因为你没有在App.js中导入和渲染这个组件，这是你的应用最初渲染的组件。将App.js修改为以下列表。
- en: Listing 9.3\. Referencing BarChart.js in App.js
  id: totrans-82
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.3\. 在App.js中引用BarChart.js
- en: '[PRE7]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '***1* We need to import our newly created component**'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 我们需要导入我们新创建的组件**'
- en: '***2* This is how we can get those props.data and props.size to use to render
    our bar chart in BarChart.js**'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 这是我们如何在BarChart.js中使用props.data和props.size来渲染条形图**'
- en: 'When you save App.js with these changes, you’ll see something pretty cool if
    you have your server running: it automatically updates the page to show you what’s
    in [figure 9.4](#ch09fig04). That’s one of the magic tricks of Webpack—the module
    bundler included in `create-react-app` that will automatically update your app
    based on changes in your code.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当你保存带有这些更改的App.js时，如果你有服务器运行，你会看到一些很酷的东西：它会自动更新页面以显示[图9.4](#ch09fig04)中的内容。这是Webpack的一个魔法技巧——它是`create-react-app`中包含的模块打包器，会根据你的代码更改自动更新你的应用。
- en: Figure 9.4\. Your first React + D3 app, with a simple bar chart rendered in
    your app
  id: totrans-87
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.4\. 你的第一个React + D3应用，其中包含在应用中渲染的简单条形图
- en: '![](../Images/09fig04.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/09fig04.jpg)'
- en: You can already imagine optimizations of your code, for instance, to scale the
    bars to fit the width, which we’ll see later. But for now let’s move on to the
    other method of rendering data visualization using D3 and React.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经可以想象代码的优化了，例如，将条形图缩放到适合宽度，我们稍后会看到。但就目前而言，让我们继续介绍使用D3和React渲染数据可视化的另一种方法。
- en: 9.4\. React for element creation, D3 as the visualization kernel
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.4\. 使用React创建元素，D3作为可视化内核
- en: Rather than passing your DOM node off to D3, you can use D3 to generate all
    the necessary drawing instructions and use React to create the DOM elements. One
    of the challenges with this approach is animated transitions, which require a
    deeper investment in the React ecosystem, but otherwise this approach is going
    to leave you with code that will be more maintainable by your less D3-inclined
    colleagues.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是将你的DOM节点传递给D3，你可以使用D3生成所有必要的绘图指令，并用React来创建DOM元素。这种方法的挑战之一是动画过渡，这需要更深入地投资React生态系统，但除此之外，这种方法将使你的代码更容易被不那么倾向于使用D3的同事维护。
- en: '[Listing 9.4](#ch09ex04) shows how we can do this to recreate one of our maps
    from the last chapter. It’s mostly the same as our earlier code, but in this case,
    I’m importing world.js here, instead of world.geojson. I’ve transformed it into
    a .js file by adding a little ES6 export syntax to the beginning of the JSON object.
    The code in the following listing is similar to what we’ve seen before, except
    now we’re using it to create JSX elements to represent each country and we’re
    including the geodata rather than using an XHR request (like the `d3.json` function
    we used before).'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '[列表 9.4](#ch09ex04) 展示了如何执行此操作以重新创建上一章中我们的一张地图。它与我们的早期代码大致相同，但在这个例子中，我这里导入的是
    world.js 而不是 world.geojson。我已经通过在 JSON 对象的开始处添加一点 ES6 导出语法将其转换为 .js 文件。以下列表中的代码与我们之前看到的类似，但现在我们使用它来创建代表每个国家的
    JSX 元素，并且包括地理数据而不是使用 XHR 请求（就像我们之前使用的 `d3.json` 函数）。'
- en: Listing 9.4\. WorldMap.js and associated world.js
  id: totrans-93
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.4\. WorldMap.js 和相关 world.js
- en: '[PRE8]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '***1* Rather than fiddling with asynch calls, we can import the map data because
    it won’t be changing**'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 我们不必与异步调用纠缠，因为我们可以导入地图数据，因为它不会改变**'
- en: '***2* Map the arrays to svg:path elements**'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将数组映射到 svg:path 元素**'
- en: '***3* Make sure they each have a unique**'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 确保它们各自具有唯一性**'
- en: '***4* Remember className not class with JSX**'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 记住 className 而不是 class 在 JSX 中**'
- en: '***5* Nest the array of paths within the svg element**'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 将路径数组嵌套在 svg 元素中**'
- en: You can see the first couple lines of world.js in the following listing—the
    rest of it resembles the original world.geojson. You can do this to any JSON file
    if you want to bring it in using import.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下列表中看到 world.js 的前几行——其余部分与原始 world.geojson 相似。如果你想通过导入将其引入，你可以这样做。
- en: Listing 9.5\. world.js
  id: totrans-101
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.5\. world.js
- en: '[PRE9]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: It’s almost exactly the same as the data-binding pattern we see in D3, except
    that we use native Array.map and map the individual data elements to DOM elements
    because of the magic of JSX. The results in [figure 9.5](#ch09fig05) should be
    familiar to you, because it’s the same thing we saw in the last chapter.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 它几乎与我们在 D3 中看到的绑定模式完全相同，只不过我们使用原生的 Array.map 并将单个数据元素映射到 DOM 元素，这是由于 JSX 的魔力。[图
    9.5](#ch09fig05) 中的结果你应该很熟悉，因为它与上一章中我们看到的是同一件事。
- en: Figure 9.5\. The basic map we saw in [chapter 8](../Text/kindle_split_018.html#ch08)
    but now rendered via React and JSX with D3 providing the drawing instructions
  id: totrans-104
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 9.5\. 我们在 [第 8 章](../Text/kindle_split_018.html#ch08) 中看到的地图，但现在是通过 React
    和 JSX 渲染的，D3 提供绘图指令
- en: '![](../Images/09fig05.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/09fig05.jpg)'
- en: In my own practice I prefer to use this method, because I find the lifecycle
    events in React and the way it creates and updates and destroys elements to be
    more comprehensive than dealing with it via D3.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在我自己的实践中，我更喜欢使用这种方法，因为我发现 React 中的生命周期事件以及它创建、更新和销毁元素的方式比通过 D3 处理它更全面。
- en: 9.5\. Data dashboard basics
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.5\. 数据仪表板基础
- en: Before we draw anything, we need to have data to send it to our charts. We’ll
    accomplish that by extending App.js and including in it a function for creating
    randomized data for our countries. As shown in the following listing, we’re going
    to color the countries by launch day—which, remember, is alphabetical because
    it’s made up (or because Matt Flick, rakish billionaire CEO of MatFlicks, thought
    that was a good idea, whichever explanation you prefer).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们绘制任何东西之前，我们需要有数据来发送到我们的图表。我们将通过扩展 App.js 并在其中包含一个用于为我们的国家创建随机数据的函数来完成这项工作。如下所示，我们将按发射日给国家着色——记住，这是按字母顺序排列的，因为它是人为编造的（或者因为
    Matt Flick，MatFlicks 的潇洒亿万富翁首席执行官认为这是个好主意，无论你更喜欢哪种解释）。
- en: Listing 9.6\. Updated App.js with sample data
  id: totrans-109
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.6\. 更新后的 App.js 与示例数据
- en: '[PRE10]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '***1* We’ll need these functions to build our sample data**'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 我们将需要这些函数来构建我们的示例数据**'
- en: '***2* Constrain our map to only North and South America for simplicity’s sake**'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 为了简化，将我们的地图限制在北美洲和南美洲**'
- en: '***3* Generate some fake data with relatively interesting patterns—the “launch
    day” of each country is its array position**'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 生成一些具有相对有趣模式的假数据——每个国家的“发射日”是其数组位置**'
- en: '***4* Color each country by its launch date**'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 按发射日期给每个国家着色**'
- en: We’re sending our color scale down to our `WorldMap` component along with our
    data. Because we’ll want to share colors and data across our dashboard like you
    can see in [Figure 9.6](#ch09fig06), this will make it easier to manage any changes
    and update patterns. But to take advantage of it, we need to modify our WorldMap.js
    file to expect those things to come from its parent, as shown in the following
    listing.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在将颜色比例和数据发送到我们的`WorldMap`组件。因为我们希望像[图9.6](#ch09fig06)中看到的那样，在仪表板中共享颜色和数据，这将使管理任何更改和更新模式变得更加容易。但为了利用这一点，我们需要修改我们的WorldMap.js文件，以便期望从其父组件接收这些内容，如下面的列表所示。
- en: Figure 9.6\. Our rendered WorldMap component, with countries colored by launch
    day
  id: totrans-116
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.6\. 我们渲染的WorldMap组件，国家根据启动日上色
- en: '![](../Images/09fig06.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/09fig06.jpg)'
- en: Listing 9.7\. Updated WorldMap.js getting data and color scale from parent
  id: totrans-118
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.7\. 更新的WorldMap.js从父组件获取数据和颜色比例
- en: '[PRE11]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '***1* Updated translate and scale because we’ve constrained our geodata**'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 更新了翻译和缩放，因为我们已经限制了我们的地理数据**'
- en: '***2* Use the color scale passed via props**'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 使用通过props传递的颜色比例**'
- en: '***3* Base height and width on size prop so that we can make the chart responsive
    later**'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 基于大小属性设置基本高度和宽度，以便我们可以在以后使图表具有响应性**'
- en: Now let’s bring back our bar chart and rewire it so that it deals with the data
    being passed in the form it is and colored according to our scale, as in the following
    listing.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来恢复条形图，并重新连接它，使其能够处理以当前形式传递的数据，并根据我们的比例上色，如下面的列表所示。
- en: Listing 9.8\. App.js updates for adding the bar chart
  id: totrans-124
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.8\. App.js更新，用于添加条形图
- en: '[PRE12]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Our original `barChart` code wasn’t expecting data in this format, and wasn’t
    receiving size and style information from its parent, so [listing 9.9](#ch09ex09)
    shows how we’ll need to update that code to match the changes. Those changes are
    mostly in the `create BarChart()` function but also include new code to change
    the size of the `<svg>` element to match the passed size.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们原始的`barChart`代码没有期望以这种格式接收数据，也没有从其父组件接收大小和样式信息，所以[列表9.9](#ch09ex09)显示了我们需要如何更新代码以匹配这些更改。这些更改主要在`create
    BarChart()`函数中，但也包括新的代码来更改`<svg>`元素的大小以匹配传递的大小。
- en: Listing 9.9\. Updated BarChart.js
  id: totrans-127
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.9\. 更新的BarChart.js
- en: '[PRE13]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '***1* Dynamically calculate bar width to make the chart more responsive in
    the future**'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 动态计算条形宽度，以便在将来使图表更具响应性**'
- en: And now our dashboard gets a little more dashing. We have our countries colored
    by release day, and a bar chart shows the total amount of sales by country, also
    colored (and arranged) by release day. Because the data is randomized, your screenshot
    won’t look exactly like [figure 9.7](#ch09fig07) but it should be close. You can
    already see several cool patterns when a country with a much later release date
    is already showing higher sales than an earlier launched country. Maybe Matt shouldn’t
    have determined release day based on alphabetical order?
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在仪表板变得更加炫酷。我们根据发布日期给国家上色，并通过条形图显示每个国家的总销售额，也根据发布日期上色（并排列）。由于数据是随机的，你的截图可能不会完全像[图9.7](#ch09fig07)那样，但应该很接近。当某个国家的发布日期晚于另一个较早推出的国家，但销售额却更高时，你已经开始看到一些有趣的模式了。也许马特不应该根据字母顺序来确定发布日期？
- en: Figure 9.7\. A rudimentary dashboard with two views into the data. The bars
    are ordered by our fake “Launch Day,” and sometimes the randomized data shows
    interesting patterns like the dark green bar showing a higher total sales than
    countries that launched 10 days earlier.
  id: totrans-131
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.7\. 一个基本的仪表板，包含两个数据视图。条形按我们的假“启动日”排序，有时随机数据会显示出有趣的模式，例如深绿色条形显示的总销售额高于10天前启动的国家。
- en: '![](../Images/09fig07_alt.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/09fig07_alt.jpg)'
- en: We’re almost to the point where we’ve got all the features requested for the
    dashboard. The only thing left is amount of sales per day since launch. Obviously
    it should be a kind of time series chart, so why not that streamgraph you learned
    how to make in that amazing book about D3.js by that brilliant author whom you
    feel great about giving a five-star review for? Showing you how to give this book
    a glowing review would take up too much space, but the following listing shows
    what we’ll need for a StreamGraph component.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎已经完成了仪表板所需的所有功能。唯一剩下的是自启动以来的每日销售额。显然，它应该是一种时间序列图表，为什么不尝试使用你从那本关于D3.js的精彩书籍中学到的流图呢？那位杰出的作者，你对他感到非常满意，并愿意给他五星好评。展示如何给出这本书的精彩评价会占用太多空间，但下面的列表显示了StreamGraph组件所需的元素。
- en: Listing 9.10\. A React streamgraph
  id: totrans-134
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.10\. 一个React streamgraph
- en: '[PRE14]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '***1* This will be our blank array of objects for our reprocessed streamgraph
    data**'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 这将是我们的空白对象数组，用于我们的重新处理流图数据**'
- en: '***2* Transform our original data into a format amenable for stack**'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将我们的原始数据转换成适合堆叠的格式**'
- en: '***3* Each key maps to a country from our data**'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 每个键映射到我们数据中的一个国家**'
- en: '***4* We need to do this offset because our streamgraph runs along the 0 axis—if
    you’re drawing a regular stacked area or line graph, it’s not necessary**'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 我们需要这样做偏移，因为我们的流图沿着0轴运行——如果你在绘制常规堆叠面积图或线图，则不需要**'
- en: 'And after we reference it in our App.js:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们在App.js中引用它之后：
- en: '[PRE15]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We have our initial dashboard, as we see in [figure 9.8](#ch09fig08), satisfying
    our user requirements. We’re not done yet, but we have a dashboard taking our
    data and presenting it geographically, summed up in a bar chart and over time
    on a streamgraph. Now, one of the issues we run into when we’re building any data
    visualization product including when we’re building dashboards is that we can
    get so caught up in delivering what our users request that we don’t think to provide
    them with views into the data that they might not imagine, because they’re not
    as experienced with data visualization as we are.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有了我们的初始仪表板，正如我们在[图9.8](#ch09fig08)中看到的，满足了用户的要求。我们还没有完成，但我们已经有一个仪表板，它将我们的数据地理呈现，并在柱状图中汇总，在流图中随时间展示。现在，当我们构建任何数据可视化产品时遇到的一个问题是，包括当我们构建仪表板时，我们可能会过于专注于满足用户的需求，以至于我们没有考虑到提供他们可能没有想象到的数据视图，因为他们对数据可视化的经验不如我们丰富。
- en: Figure 9.8\. A typical dashboard, with three views into the same dataset. In
    this case, it shows MatFlicks launch waves geographically while summing up sales
    in the bar chart and showing sales over time in the streamgraph.
  id: totrans-143
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.8\. 一个典型的仪表板，有三个视图查看同一数据集。在这种情况下，它显示了MatFlicks的地理发布波次，同时在柱状图中汇总销售额，并在流图中显示随时间变化的销售额。
- en: '![](../Images/09fig08.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/09fig08.jpg)'
- en: There’s no easy way to address this. Remember when you’re building data visualization
    products like this dashboard that your users are constrained in the way they see
    the data, and it’s your job to show them the views they want, but also other views.
    If they’re primarily interested in numerical characteristics of the data, try
    to show it to them in hierarchical ways as well. If they’re focused on a map,
    maybe there’s a network view they could use as contrast.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 没有简单的方法来解决这个问题。记住，当你构建像这样的数据可视化产品（如仪表板）时，你的用户在查看数据的方式上受到限制，而你的任务是向他们展示他们想要的视图，同时也展示其他视图。如果他们主要对数据的数值特征感兴趣，尝试以分层的方式向他们展示。如果他们专注于地图，也许他们可以使用网络视图作为对比。
- en: 9.6\. Dashboard upgrades
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.6\. 仪表板升级
- en: 'You finish your dashboard, check off all the requirements, and demo it to your
    clients. I bet you can guess what their responses might be:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 你完成你的仪表板，检查所有要求，并向你的客户演示。我敢打赌你可以猜到他们的回应可能是什么：
- en: “This looks terrible on the tiny screen on my tablet and on the giant screen
    on my giant TV.”
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: “这在我平板电脑的小屏幕上和在我巨大电视的大屏幕上看起来都很糟糕。”
- en: “I don’t know what the colors mean.”
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: “我不知道这些颜色代表什么。”
- en: “I want to see a bar or trend highlight when I hover over a country and vice
    versa.”
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: “当我悬停在某个国家上时，我想看到条形图或趋势突出显示，反之亦然。”
- en: “I need to narrow it down to countries that launched within a certain period.”
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: “我需要缩小到在一定时期内启动的国家。”
- en: “Show me the numbers.”
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: “给我看数字。”
- en: 'I almost didn’t include the last one, because there’s no reason to write it
    down, because everyone always says that. If you don’t want to hear people say,
    “Show me the numbers” and “Slice and dice the data,” you’re in the wrong field.
    Let’s boil that down to a few more concrete features:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我几乎不包括最后一点，因为没有理由写下来，因为每个人总是这么说。如果你不想听到人们说“给我看数字”和“切片和切块数据”，你就在错误的领域。让我们将其归纳为几个更具体的功能：
- en: Make it responsive.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让它具有响应性。
- en: Add a legend.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加图例。
- en: Cross-highlight on bars, countries, and trends.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在柱状图、国家和趋势上进行交叉突出显示。
- en: Brush based on launch day.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据发布日刷选。
- en: Show numbers.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 显示数字。
- en: More features are available for a dashboard like this, and although there will
    always be more features, this chapter can’t go on forever.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这样的仪表板，还有更多功能可用，尽管总是会有更多功能，但这一章不能永远继续下去。
- en: 9.6.1\. Responsiveness
  id: totrans-160
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.6.1\. 响应性
- en: To make the dashboard respond to changes in the size of the display, we need
    to first listen for when the display changes and then make an update that trickles
    down to all our components, as shown in [listing 9.11](#ch09ex11). The listener
    will be in App.js, which will also store the data in state, which will be used
    to trickle down to its components (remember, React re-renders whenever state changes,
    and because App will be sending new size values down to its children, they’ll
    re-render automatically).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使仪表盘能够响应显示尺寸的变化，我们首先需要监听显示尺寸的变化，然后进行更新，以便所有组件都能得到更新，如[列表9.11](#ch09ex11)所示。监听器将在App.js中，它还将存储数据在状态中，该状态将被用于传递到其组件（记住，React在状态变化时重新渲染，因为App将发送新的尺寸值到其子组件，它们将自动重新渲染）。
- en: Listing 9.11\. App.js state and resize listener
  id: totrans-162
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.11. App.js状态和调整大小监听器
- en: '[PRE16]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '***1* Initialize state with some sensible defaults**'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 使用一些合理的默认值初始化状态**'
- en: '***2* Register a listener for the resize event**'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 为调整大小事件注册监听器**'
- en: '***3* Update state with the new window width and height (minus the size of
    the header)**'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 使用新的窗口宽度和高度（减去标题的大小）更新状态**'
- en: '***4* Send height and width from the component state**'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 从组件状态发送高度和宽度**'
- en: And that’s all it takes to make our dashboard responsive. Remember that the
    code in this book is designed to run on Chrome, so it may be that on other browsers
    you’ll need to use different window attributes. Also, in production you’ll want
    to throttle or debounce your resize event so it doesn’t fire continuously as someone
    drags the window to a new size. Finally, making things larger and smaller to fit
    the screen doesn’t mean you’ve created responsive data visualization. Chapter
    12 gets into how different sizes of screens and different kinds of input are better
    suited to different data visualization methods. That said, in [figure 9.9](#ch09fig09)
    we can see the effects of our new code.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就完成了我们的仪表盘的响应式设计。请记住，这本书中的代码是为Chrome设计的，所以可能在其他浏览器上你需要使用不同的窗口属性。此外，在生产环境中，你可能需要限制或去抖动你的调整大小事件，以防止在拖动窗口到新大小时连续触发。最后，将事物放大或缩小以适应屏幕并不意味着你已经创建了响应式数据可视化。第12章将介绍不同尺寸的屏幕和不同类型的输入更适合不同的数据可视化方法。话虽如此，在[图9.9](#ch09fig09)中，我们可以看到我们新代码的效果。
- en: Figure 9.9\. The same dashboard on a large screen and a small screen
  id: totrans-169
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.9. 大屏幕和小屏幕上的相同仪表盘
- en: '![](../Images/09fig09_alt.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/09fig09_alt.jpg)'
- en: I’m not recalculating the scale and translate on the map because that’s a more
    involved process that I already got into in the last chapter when we explored
    zooming in and out.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我没有在地图上重新计算比例和转换，因为这是一个更复杂的过程，我在上一章中已经介绍过，当时我们探讨了缩放。
- en: 9.6.2\. Legends
  id: totrans-172
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.6.2\. 图例
- en: As we’ve learned, legends are straightforward. Pass your scale over to `d3-svg-legend`
    in your bar chart code, as shown in the following listing.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所学的，图例很简单。在你的条形图代码中将比例传递给`d3-svg-legend`，如下面的列表所示。
- en: Listing 9.12\. Adding a legend
  id: totrans-174
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.12. 添加图例
- en: '[PRE17]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '***1* You need to import transition so that d3-svg-legend can use it**'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 你需要导入过渡，这样d3-svg-legend才能使用它**'
- en: '***2* Although we could use threshold values, it’s better to use semantically
    meaningful names for your categories**'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 尽管我们可以使用阈值值，但最好为你的类别使用语义上有意义的名称**'
- en: '***3* We bind a single value array of data to ensure that we append one <g>
    element only and then during later refreshes we update it**'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 绑定一个单一值数组的数据，以确保我们只添加一个 <g> 元素，然后在后续的刷新中更新它**'
- en: '***4* Make the transform change happen during every refresh, so the legend
    is responsive in its placement**'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 使转换变化在每次刷新时发生，这样图例在位置上就是响应式的**'
- en: And with that, we finally have an explanation for what those colors are, as
    shown in [figure 9.10](#ch09fig10).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们终于解释了那些颜色代表什么，如[图9.10](#ch09fig10)所示。
- en: Figure 9.10\. Our MatFlicks table mat rollout dashboard, now with a legend to
    show your users which countries are in which wave of launches
  id: totrans-181
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.10. 我们的MatFlicks表格滚动仪表盘，现在带有图例以显示哪些国家在哪个发布波次
- en: '![](../Images/09fig10_alt.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/09fig10_alt.jpg)'
- en: 9.6.3\. Cross-highlighting
  id: totrans-183
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.6.3\. 交叉高亮
- en: In each of our three views in this dashboard, we’re showing the same data and
    even coloring it in the same way, so it’s only natural that someone using it would
    like to see which bar associates with which country and which trend associates
    with which bar. To handle that, we need to add a spot in the state of our application
    that knows what we’re hovering over and mouse events on all the elements that
    update that state. After that, we can pass down that new state and if it corresponds
    to an element’s ID in the rendering, we visually highlight it. React refers to
    events a bit differently, but otherwise it’s straightforward. First, in the following
    listing, we’ll update the main app so that we can pass down a function and the
    current state that this function modifies.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在此仪表板中的三个视图中，我们显示相同的数据，甚至以相同的方式着色，因此使用它的人自然希望看到哪个条形与哪个国家相关联，以及哪个趋势与哪个条形相关联。为了处理这个问题，我们需要在应用程序的状态中添加一个位置，知道我们在悬停什么，以及在所有更新该状态的元素上的鼠标事件。之后，我们可以传递这个新的状态，如果它与渲染中的元素ID相对应，我们就可以视觉上突出显示它。React对事件的处理方式略有不同，但除此之外，它很简单。首先，在以下列表中，我们将更新主应用程序，以便我们可以传递一个函数和该函数修改的当前状态。
- en: Listing 9.13\. App.js updates
  id: totrans-185
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.13\. App.js 更新
- en: '[PRE18]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '***1* We’re going to store the currently hovered on element in state so we
    need to initialize our state with a hover property**'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 我们将存储当前悬停的元素在状态中，因此我们需要使用悬停属性初始化我们的状态**'
- en: '***2* The hover function will expect us to send the data object**'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 悬停函数将期望我们发送数据对象**'
- en: '***3* We need to send to the components both the hover function and the current
    hover state for them to interact properly**'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 我们需要将悬停功能和当前悬停状态同时发送给组件，以便它们能够正确交互**'
- en: In the following listing we see how we can reference the passed function by
    tying it to traditional D3 development patterns, like using `.on()` and `.style()`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下列表中，我们看到如何通过将其绑定到传统的D3开发模式（如使用`.on()`和`.style()`）来引用传递的函数。
- en: Listing 9.14\. BarChart.js updates
  id: totrans-191
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.14\. BarChart.js 更新
- en: '[PRE19]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '***1* Bind the hover function we’ve passed down like we would any other function
    in a D3 chart**'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将我们传递的悬停函数绑定，就像在D3图表中绑定任何其他函数一样**'
- en: '***2* Fill with the usual colorScale value unless we’re hovering on this element,
    in this case orange**'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 除非我们悬停在元素上，否则使用常规的colorScale值，在这种情况下为橙色**'
- en: Finally, in [listings 9.15](#ch09ex15) and [9.16](#ch09ex16) we see how to use
    the function with the slightly different JSX React syntax (using `onMouseEnter`
    as the property, which is different than the normal HTML property, which would
    be `onmouseover`). We also pass the check to change the color on through to the
    `style` object instead of using `.style()`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在[列表 9.15](#ch09ex15)和[9.16](#ch09ex16)中，我们看到如何使用略有不同的JSX React语法（使用`onMouseEnter`作为属性，这与正常的HTML属性`onmouseover`不同）。我们还通过`style`对象传递检查以更改颜色，而不是使用`.style()`。
- en: Listing 9.15\. WorldMap.js Updates
  id: totrans-196
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.15\. WorldMap.js 更新
- en: '[PRE20]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '***1* In React, it’s called onMouseEnter and it doesn’t automatically send
    the bound data**'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 在React中，它被称为onMouseEnter，并且它不会自动发送绑定数据**'
- en: '***2* Same as with the D3 method, except in React syntax**'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 与D3方法相同，但语法略有不同**'
- en: Listing 9.16\. StreamGraph.js Updates
  id: totrans-200
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.16\. StreamGraph.js 更新
- en: '[PRE21]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '***1* Because stackData is the transformed data, we need to reference the original
    data to send the right object**'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 因为stackData是转换后的数据，我们需要引用原始数据以发送正确的对象**'
- en: Now that we can cross-highlight, we can easily see which countries correspond
    to which trends and which bars on the bar chart. Here’s Canada in [figure 9.11](#ch09fig11).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以交叉高亮，可以轻松地看到哪些国家对应于哪些趋势，以及条形图上的哪些条形。这里是[图 9.11](#ch09fig11)中的加拿大。
- en: Figure 9.11\. Canada as our cross-highlighting example. It was earlier in the
    alphabet and as a result millions of Canadians were enjoying high quality European
    mats long before citizens of the United States could.
  id: totrans-204
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 9.11\. 加拿大作为我们的交叉高亮示例。它字母表中较早，因此数百万加拿大人在美国公民能够享受高质量欧洲地毯之前就已经在享受了。
- en: '![](../Images/09fig11_alt.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/09fig11_alt.jpg)'
- en: 9.7\. Brushing
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.7\. 刷选
- en: The brush component `d3.brush()` (or `brush()` when we use it from the `d3-brush`
    module) is like the axis component because it creates SVG elements when called
    (typically by a `<g>` element). But it’s also like the zoom behavior because brush
    has interactions that update a data element that you can use for interactivity.
    Brushes are valuable interactive components that allow users to intuitively slice
    up their data. For our dashboard, we’ll add a brush that lets users show countries
    that were launched during particular periods.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 刷子组件 `d3.brush()`（或当我们从 `d3-brush` 模块中使用它时的 `brush()`）就像坐标轴组件一样，因为它在调用时创建 SVG
    元素（通常是通过 `<g>` 元素）。但它也像缩放行为一样，因为刷子有交互，可以更新一个数据元素，你可以用它来进行交互。刷子是有价值的交互式组件，允许用户直观地分割他们的数据。对于我们的仪表板，我们将添加一个允许用户显示在特定时期发射的国家。
- en: 9.7.1\. Creating the brush
  id: totrans-208
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.7.1\. 创建刷子
- en: A brush in D3 creates a region where the user can select by clicking and dragging.
    Because we call the brush from a `<g>` there’s no way to use Brush with the second
    React+D3 method; you’re going to have to hand over a DOM element for brush to
    call. We’ll still be passing the results of our brush interactions to the App
    state for it to distribute to the various other elements. First, let’s get a `Brush.js`
    component up and running. In the following listing is the hopefully by-now familiar
    code for including reference to our new component from App.js. We’re only sending
    it a size to begin with.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: D3 中的刷子创建了一个用户可以通过点击和拖动来选择的区域。因为我们从 `<g>` 中调用刷子，所以无法使用第二种 React+D3 方法中的刷子；你将不得不传递一个
    DOM 元素供刷子调用。我们仍然会将我们的刷子交互的结果传递给 App 状态，以便它分布到各种其他元素。首先，让我们让 `Brush.js` 组件运行起来。在下面的列表中是希望现在熟悉的从
    App.js 中包含对新组件引用的代码。我们一开始只传递一个大小。
- en: Listing 9.17\. App.js updates for a brush
  id: totrans-210
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.17\. App.js 中刷子的更新
- en: '[PRE22]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This is why our CSS has references to a `rect.selection` and `rect.handle`.
    These are the pieces of the brush that afford interactivity, as you can see in
    [figure 9.12](#ch09fig12).
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是为什么我们的 CSS 中有对 `rect.selection` 和 `rect.handle` 的引用。这些是刷子中提供交互性的部分，正如你在 [图
    9.12](#ch09fig12) 中可以看到的。
- en: Figure 9.12\. Components of a brush
  id: totrans-213
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 9.12\. 刷子的组成部分
- en: '![](../Images/09fig12_alt.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.12](../Images/09fig12_alt.jpg)'
- en: A *brush* is an interactive collection of components that allows a user to drag
    one end of the brush to designate an extent or to move that extent to a different
    range. Typical brush aspects are explained in [figure 9.12](#ch09fig12). In this
    chapter we only create a brush that allows selection along the x-axis, but if
    you want to see a brush that selects along the x- and y-axes, you can check out
    [chapter 11](../Text/kindle_split_022.html#ch11), where we use it to select points
    laid out on an xy plane.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '*刷子* 是一组交互式组件的集合，允许用户拖动刷子的一端来指定一个范围，或者将这个范围移动到不同的范围。典型的刷子特性在 [图 9.12](#ch09fig12)
    中解释。在本章中，我们只创建了一个允许沿 x 轴选择的刷子，但如果你想看到一个沿 x 轴和 y 轴选择的刷子，你可以查看 [第 11 章](../Text/kindle_split_022.html#ch11)，在那里我们使用它来选择在
    xy 平面上排列的点。'
- en: It’s also helpful to create an axis to go along with our brush. The brush is
    created as a region of interactivity, and clicking on that region produces a rectangle
    in response. But before any interaction, the area looks blank. By including an
    axis, we inform the user of the range attached to this brush.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个与我们的刷子一起使用的坐标轴也是有帮助的。刷子被创建为一个交互区域，点击该区域会响应地产生一个矩形。但在任何交互之前，该区域看起来是空的。通过包含一个坐标轴，我们向用户告知这个刷子所附带的范围。
- en: The scale you use to drive your axis will likely also be necessary to do any
    translation of the brushed area to a data range that we want to use for filtering.
    Our brush is going to be the width of our dashboard, which is a variable pixel
    size, and the region designated by your brush interaction doesn’t correspond to
    our data (the launch day of each country), so we’ll need that scale to translate
    the brushed extent to a data extent.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 你用来驱动坐标轴的刻度可能也用于将刷子区域转换为我们要用于过滤的数据范围。我们的刷子将是我们的仪表板的宽度，这是一个可变的像素大小，而你通过刷子交互指定的区域并不对应我们的数据（每个国家的发射日），因此我们需要这个刻度来将刷子范围转换为数据范围。
- en: After that, we’ll create a `brushX` brush and assign `this.props.size` of the
    component as the second argument of the brush’s `.extent()` method, which is a
    bounding box like we saw in the last chapter for geo regions (a two-part array
    where the first part is the coordinates of the top-left corner and the second
    part is the coordinates of the bottom-right corner). We can also create brushes
    that are vertical using the `brushY` brush or allow for selecting a region by
    using the `brush` brush (the one we’ll use in [chapter 11](../Text/kindle_split_022.html#ch11)).
    We’ll assign an event listener that listens for the custom event `"brush"` to
    call the function `brushed()`. Code to create the brush is shown in [listing 9.18](#ch09ex18),
    whereas code for the behavior when the brush is used is explained in [listing
    9.19](#ch09ex19). The `brush` event happens any time the user drags the mouse
    along the brush region after clicking the region. As with zoom, a `brushstart`
    and `brushend` event is associated with brushing, which you can use to fire performance-intensive
    functions that you may not want to trigger on every little move of the brush.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将创建一个 `brushX` 刷，并将组件的 `this.props.size` 作为刷的 `.extent()` 方法的第二个参数，这就像我们在上一章中看到的地理区域边界框（一个包含两个部分的数组，第一部分是右上角的坐标，第二部分是左下角的坐标）。我们还可以使用
    `brushY` 刷创建垂直刷，或者使用 `brush` 刷（我们在[第 11 章](../Text/kindle_split_022.html#ch11)中将要使用的刷）来允许选择区域。我们将分配一个事件监听器，监听自定义事件
    `"brush"` 来调用 `brushed()` 函数。创建刷的代码在[列表 9.18](#ch09ex18)中显示，而使用刷时的行为代码在[列表 9.19](#ch09ex19)中解释。刷事件发生在用户在点击区域后沿刷区域拖动鼠标的任何时候。与缩放一样，与刷相关联的还有
    `brushstart` 和 `brushend` 事件，你可以使用这些事件来触发可能不希望在每个小刷移动时触发的性能密集型函数。
- en: Listing 9.18\. Brush.js component
  id: totrans-219
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.18\. Brush.js 组件
- en: '[PRE23]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '***1* Standard stuff for a React component that has D3 handle element creation
    and updating**'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 对于一个具有 D3 处理元素创建和更新的 React 组件的标准内容**'
- en: '***2* For our axis and later for our brushed function**'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 对于我们的轴以及后续的刷功能**'
- en: '***3* Initialize the brush and associate it with our brushed function**'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 初始化刷并关联到我们的刷功能**'
- en: '***4* Nothing new here, only creating an axis**'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 这里没有新内容，只是创建一个轴**'
- en: '***5* Call the brush with our <g> to create it**'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 使用我们的 <g> 调用刷以创建它**'
- en: '***6* We’ll handle this below**'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 我们将在下面处理这个问题**'
- en: Again we see that we’re binding a couple single-item arrays so we can use D3’s
    enter-exit-update syntax in a way that doesn’t recreate the elements every time
    the component fires a render. The results in [figure 9.13](#ch09fig13) are of
    a draggable, adjustable brush and brush region that when we drag and adjust it,
    doesn’t do anything but move around.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次看到，我们绑定了一些单元素数组，这样我们就可以使用 D3 的 enter-exit-update 语法，而无需每次组件渲染时都重新创建元素。图
    9.13（[figure 9.13](#ch09fig13)）中的结果是可拖动的、可调整的刷和刷区域，当我们拖动和调整它时，它不会做任何事情，只是移动。
- en: Figure 9.13\. Here’s our brush, though without any function associated with
    the brush events, so it’s little more than a toy. A boring, boring toy.
  id: totrans-228
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 9.13\. 这是我们刷的示例，尽管它没有与刷事件关联的任何功能，所以它几乎就是一个玩具。一个无聊的，无聊的玩具。
- en: '![](../Images/09fig13_alt.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/09fig13_alt.jpg)'
- en: The `brushed()` function that we previously defined in the `createBrush` function
    gets the current extent of the brush using `event` from `d3-selection` and sends
    it back up to App, where it’s used to filter the base dataset, which automatically
    changes the displayed data for the other views, as in the following listing.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `createBrush` 函数中之前定义的 `brushed()` 函数使用 `d3-selection` 中的 `event` 获取刷的当前范围，并将其发送回
    App，在那里它被用来过滤基础数据集，这会自动更改其他视图显示的数据，如下面的列表所示。
- en: Listing 9.19\. The brushed function in Brush.js
  id: totrans-231
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.19\. Brush.js 中的刷功能
- en: '[PRE24]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '***1* We need to bind this function to a variable since the context of brushed
    will be different (we could also use function.bind or function.apply but that’s
    more cumbersome in this case)**'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 我们需要将这个函数绑定到一个变量上，因为刷的上下文将不同（我们也可以使用 function.bind 或 function.apply，但在这个情况下会更繁琐）**'
- en: '***2* Invert will return the domain for the range for a scale**'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* Invert 将返回比例范围的域**'
- en: This means we’ll need to pass a kind of `changeBrush` function from App that,
    as you might guess, will update state which will itself be taken into account
    when we calculate the data we send to our components, as in the following listing.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们需要从 App 传递一种 `changeBrush` 函数，正如你可能猜到的，这个函数将更新状态，当我们在计算发送给组件的数据时，这个状态将被考虑在内，如下面的列表所示。
- en: Listing 9.20\. App.js changes to listen for a brush
  id: totrans-236
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 9.20\. App.js 的更改以监听刷
- en: '[PRE25]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This brush allows users to designate a block of days to see the launch numbers
    for countries that were launched during those. [Figure 9.14](#ch09fig14) shows
    three different brushed regions and the corresponding changes to the dashboard.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这个刷子允许用户指定一个日期块，以查看在这些日期期间启动的国家数量。[图9.14](#ch09fig14)显示了三个不同的刷区域和仪表板相应的变化。
- en: Figure 9.14\. The results of our `brushed()` function showing only wave 1 and
    2, then wave 3, and finally wave 4 countries.
  id: totrans-239
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.14。`brushed()`函数的结果仅显示第1和第2个波，然后是第3个波，最后是第4个波的国家。
- en: '![](../Images/09fig14_alt.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/09fig14_alt.jpg)'
- en: 9.7.2\. Understanding brush events
  id: totrans-241
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 9.7.2。理解刷事件
- en: 'Activity on the brush region fires three separate custom events: `brush`, `brushstart`,
    and `brushend`. You’ve probably figured them out based on their names, but for
    clarity, `brushstart` is fired when you mousedown on the brush region, `brush`
    is fired continuously as you drag your mouse after `brushstart` and before mouseup,
    and `brushend` is fired on mouseup. In most implementations of a brush, it makes
    sense to wire it up so that whatever function you want applied with user activity
    only happens on the `brush` event. But you may have functions that are more expensive,
    such as redrawing an entire map or querying a database. In that case you could
    use `brushstart` to cause a visual change in your map (turning elements gray or
    transparent) and wait until `brushend` to run more heavy-duty activity.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 刷区域的活动会触发三个不同的自定义事件：`brush`、`brushstart`和`brushend`。你可能已经根据它们的名称猜出来了，但为了清晰起见，`brushstart`是在你鼠标按下刷区域时触发的，`brush`是在`brushstart`之后和鼠标抬起之前连续触发的，而`brushend`是在鼠标抬起时触发的。在大多数刷的实现中，将它们连接起来，以便你想要在用户活动上应用的功能仅在`brush`事件上发生是有意义的。但你可能有一些更昂贵的函数，比如重新绘制整个地图或查询数据库。在这种情况下，你可以使用`brushstart`来在你的地图上引起视觉变化（将元素变为灰色或透明），然后等待`brushend`来运行更重的活动。
- en: We’ll stop there. You could replace any of the charts with one of the charts
    we looked at earlier, such as a pie chart, network visualization, or circle pack.
    Controls like the brush can be powerful, but it’s also important to make such
    controls accessible to your users.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们就到这里吧。你可以用我们之前看过的任何图表替换这些图表，比如饼图、网络可视化或圆形打包。像刷子这样的控件可能很强大，但也很重要让用户能够访问这些控件。
- en: 9.8\. Show me the numbers
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.8。展示数字
- en: Maybe you haven’t noticed my thinly disguised dislike of that phrase. It’s pernicious,
    and it’s all over the field. Clients will often assume that there’s only one view
    of the information they want and it’s your job to give it to them and if you produce
    a chart that doesn’t highlight numerical differences precisely, they consider
    it a failure. It’s a challenge, one I discussed a bit in [chapter 6](../Text/kindle_split_016.html#ch06),
    and one you’ll have to wrestle with in your work.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 可能你没有注意到我对那个词的轻微反感。它是恶意的，而且无处不在。客户通常会假设他们想要的信息只有一个视图，而你的工作是提供给他们，如果你制作的图表没有精确突出数值差异，他们会认为这是失败。这是一个挑战，我在[第6章](../Text/kindle_split_016.html#ch06)中讨论过，你将在工作中与之抗争。
- en: 'But with that said, there is a place for literally showing numbers. Sometimes
    numbers are the best way to visualize data. In the case of dashboards, there should
    almost always be a statline: a single readable line of the overall statistics
    of your data, to give them some context and allow them to reason about whether
    an individual piece of data is unusual or not. It’s not the sexiest way to visualize
    data but it’s useful. I’m not going to get into the weeds of how to format the
    data, because this chapter has already gotten long; instead, I’m going to use
    this as an opportunity to introduce you to one more React concept: the *pure render
    component*. If you have a component that takes props and returns a render function,
    then your entire component can be one function, as in the following listing.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 但话虽如此，确实有地方可以展示数字。有时数字是可视化数据的最佳方式。在仪表板的情况下，几乎总是应该有一个统计行：一行可读的整体统计数据，以提供一些上下文，并允许他们判断单个数据点是否异常。这不是最吸引人的数据可视化方式，但很有用。我不会深入探讨如何格式化数据，因为这一章已经很长了；相反，我将利用这个机会向你介绍一个额外的React概念：*纯渲染组件*。如果你有一个接受props并返回渲染函数的组件，那么你的整个组件可以是一个函数，如下面的列表所示。
- en: Listing 9.21\. Pure Render StatLine.js
  id: totrans-247
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表9.21。纯渲染StatLine.js
- en: '[PRE26]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '***1* We’re exporting a function that takes props**'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 我们导出一个接受props的函数**'
- en: '***2* Notice we’re using props, not this.props, because there is no this, and
    props is being passed to the function when it’s a pure render function**'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 注意我们使用的是props，而不是this.props，因为没有this，并且当它是一个纯渲染函数时，props会被传递给函数**'
- en: '***3* This is a simple way to round to two decimal places**'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 这是一种将数值四舍五入到两位小数的方法**'
- en: '***4* Pure render components return a DOM elements**'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 纯渲染组件返回DOM元素**'
- en: One thing that may jump out at you is that I rolled my own formatter to round
    my average sales to two decimal places, rather than using `d3-format` as you might
    expect. That’s because I didn’t want to include `d3-format`. When I first started
    with D3, I used it for everything, but since then I’ve come to rely on other libraries
    that I find better designed for the functionality I need, and in the case of formatting
    that means numeral.js for numbers and moment.js for dates (moment is also great
    for time functionality more generally). That shouldn’t be too surprising, because
    the whole point of this chapter is to leverage React instead of D3.js for creating,
    updating, and destroying elements, because it’s a better technology for that purpose.
    Our final version of our dashboard is in [figure 9.15](#ch09fig15).
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 可能让您感到惊讶的一件事是，我编写了自己的格式化程序来将平均销售额四舍五入到两位小数，而不是像您可能预期的那样使用`d3-format`。这是因为我不想包含`d3-format`。当我最初开始使用D3时，我把它用于一切，但自从那时起，我开始依赖其他我认为更适合我所需功能的库，在格式化方面，这意味着使用
    numeral.js 处理数字，使用 moment.js 处理日期（moment在处理时间功能方面也非常出色）。这不应该太令人惊讶，因为本章的整个目的就是利用React而不是D3.js来创建、更新和销毁元素，因为它是为此目的更好的技术。我们的仪表板最终版本在[图9.15](#ch09fig15)中。
- en: Figure 9.15\. Our final dashboard, showing a statline at the top indicating
    the number of countries we’ve selected out of the total number of countries in
    the data as well as the average sales of the selected countries compared to the
    average sales overall. Here it’s resized to be smaller and because we don’t resize
    the map, we only see North America.
  id: totrans-254
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图9.15。我们的最终仪表板，顶部显示一条状态线，指示我们从数据中的总国家数中选出的国家数量以及所选国家的平均销售额与整体平均销售额的对比。这里已调整大小以缩小，因为我们没有调整地图的大小，所以我们只能看到北美。
- en: '![](../Images/09fig15_alt.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/09fig15_alt.jpg)'
- en: 9.9\. Summary
  id: totrans-256
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 9.9. 摘要
- en: Integrating D3 with MVC frameworks or view rendering libraries like React means
    you need to only use the parts of D3 that don’t overlap with your other libraries.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将D3与MVC框架或视图渲染库（如React）集成意味着您只需使用D3中不与其他库重叠的部分。
- en: 'You have two fundamentally different ways to integrate D3: pass the DOM node
    to D3 and work on it separately from the rest of your application using traditional
    D3 select/enter/exit/update, or only use D3 to generate data and drawing instructions
    to pass to your other libraries.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您有两种基本不同的方式来集成D3：将DOM节点传递给D3并在应用程序的其他部分之外单独对其工作，使用传统的D3 select/enter/exit/update，或者仅使用D3生成数据绘制指令传递给您的其他库。
- en: NPM-based projects are better served by using individual D3 modules.
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于NPM的项目更适合使用单个D3模块。
- en: The `brush()` component lets you select a range of data in an intuitive way.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`brush()`组件让您以直观的方式选择数据范围。'
- en: Cross-highlighting behavior is useful and expected when creating dashboards.
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在创建仪表板时，交叉高亮行为是有用且预期的。
- en: D3 in the real world
  id: totrans-262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 真实世界中的D3
- en: Elijah Meeks Senior Data Visualization Engineer
  id: totrans-263
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Elijah Meeks 高级数据可视化工程师
- en: '*Netflix Algorithm and New Member Dashboards*'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '*Netflix算法和新会员仪表板*'
- en: Netflix needs to understand billions of events from tens of millions of users
    watching thousands of unique titles. To do this, Netflix uses dashboards. The
    more complex ones are custom applications made with D3, React, and Redux.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: Netflix需要理解数百万用户观看成千上万独特标题产生的数十亿个事件。为此，Netflix使用仪表板。更复杂的一些是使用D3、React和Redux制作的定制应用程序。
- en: To build a dashboard like the one in the next figure, which tracks algorithm
    performance, or the one in the previous figure, which looks at the membership
    funnel, we use the techniques you see in this chapter.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建如图所示的仪表板，该仪表板跟踪算法性能，或如图所示的仪表板，该仪表板查看会员漏斗，我们使用本章中展示的技术。
- en: '![](../Images/309fig01_alt.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/309fig01_alt.jpg)'
- en: Along with those, we get animation and performance tuning using the React lifecycle
    events. The custom D3 charts built in these dashboards are often the only way
    we can leverage high-powered big data backends to surface the billions of events
    that Netflix deals with.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些，我们还通过使用React的生命周期事件获得动画和性能调整。这些仪表板中构建的定制D3图表通常是唯一一种方式，我们可以利用强大的大数据后端来展示Netflix处理的数十亿个事件。
- en: '![](../Images/310fig01_alt.jpg)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/310fig01_alt.jpg)'
- en: Chapter 10\. Writing layouts and components
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第10章\. 编写布局和组件
- en: '*This chapter covers*'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Writing a custom legend component
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写自定义图例组件
- en: Writing a custom grid layout
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写自定义网格布局
- en: Adding functionality to make layout and component settings customizable
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加功能以使布局和组件设置可定制
- en: Adding interactivity to components
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向组件添加交互性
- en: Throughout this book, we’ve dealt with D3 components and layouts. In this chapter
    we’ll write them. After you’ve created your own layout and your own component,
    you’ll better understand the structure and function of layouts. You’ll be able
    to use that layout, and other layouts that you create in the same fashion, in
    the charts and applications that you build with D3 later on.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们处理了D3组件和布局。在本章中，我们将编写它们。在您创建了自己的布局和组件之后，您将更好地理解布局的结构和功能。您将能够使用该布局，以及您在以后使用D3构建的图表和应用程序中创建的其他布局。
- en: In this chapter we’ll create a custom layout that places a dataset on a grid.
    For most of the chapter, we’ll use our people analytics dataset, but the advantage
    of a layout is that the dataset doesn’t matter. The purpose of this chapter isn’t
    to create a grid, but rather to help you understand how layouts work. We’ll create
    a grid layout because it’s simple and allows us to focus on layout structure rather
    than on the particulars of any data visualization layout. We’ll follow that up
    by extending the layout so it can have a set size that we can change. You’ll also
    see how the layout annotates the dataset we send so that individual datapoints
    can be drawn as circles or rectangles. A grid isn’t the sexiest or most useful
    layout, but it can teach you the basics of layouts. After that, we’ll build a
    legend component that tells users the meaning of the color of our elements. We’ll
    do this by basing the graphical components of the legend on the scale we’ve used
    to color our chart elements.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将创建一个自定义布局，将数据集放置在网格上。在本章的大部分内容中，我们将使用我们的人事分析数据集，但布局的优势在于数据集并不重要。本章的目的不是创建一个网格，而是帮助您理解布局是如何工作的。我们将创建一个网格布局，因为它简单，使我们能够专注于布局结构而不是任何数据可视化布局的细节。我们将通过扩展布局，使其具有可更改的固定大小来继续这个过程。您还将看到布局如何注释我们发送的数据集，以便可以将单个数据点绘制为圆圈或矩形。网格不是最性感或最有用的布局，但它可以教会您布局的基础。之后，我们将构建一个图例组件，告诉用户我们元素颜色的含义。我们将通过将图例的图形组件基于我们用于着色图表元素的刻度来实现这一点。
- en: 10.1\. Creating a layout
  id: totrans-278
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1\. 创建布局
- en: Recall from [chapter 5](../Text/kindle_split_014.html#ch05) that a layout is
    a function that modifies a dataset for graphical representation. Here, we’ll build
    that function. Later, we’ll give it the capacity to modify the settings of the
    layout in the same manner that built-in D3 layouts operate. This layout will allow
    us to place discrete datapoints on a grid, allowing for easy comparison. You could
    use this to show a single circle or rectangle, as we have, or you could use these
    grids to hold individual charts to generate small multiples charts, as some D3
    users have since the first edition of this book was released.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下[第5章](../Text/kindle_split_014.html#ch05)，布局是一个修改数据集以进行图形表示的函数。在这里，我们将构建这个函数。稍后，我们将赋予它以与内置D3布局相同的方式修改布局设置的能力。这个布局将使我们能够将离散数据点放置在网格上，从而便于比较。您可以使用它来显示单个圆圈或矩形，就像我们做的那样，或者您可以使用这些网格来容纳单个图表以生成小倍数图表，就像自本书第一版发布以来的一些D3用户所做的那样。
- en: You’ll see this in more detail later, but first we need to create a function
    that processes our data. After we create this function, we’ll use it to implement
    the calls that a layout needs. In the following listing, you can see the function
    and a test where we instantiate it and pass it data.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在稍后详细了解这一点，但首先我们需要创建一个处理我们数据的函数。在创建此函数之后，我们将使用它来实现布局所需的调用。在下面的列表中，您可以看到该函数和一个实例化它并传递数据的测试。
- en: Listing 10.1\. d3.gridLayout.js
  id: totrans-281
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.1\. d3.gridLayout.js
- en: '[PRE27]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '***1* Prints [1,2,3,4,5] to the console**'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将 [1,2,3,4,5] 打印到控制台**'
- en: That’s not an exciting layout, but it works. We don’t need to name our layout
    `d3.-layoutX` or any other particular name, but using a thoughtful name will make
    it more readable in the future (and you don’t want to be heckled in a book on
    the subject in coming years, where you’re asked how your treemap is neither a
    tree nor a map).
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一个令人兴奋的布局，但它有效。我们不需要将我们的布局命名为 `d3.-layoutX` 或任何其他特定名称，但使用一个深思熟虑的名称将在未来使其更具可读性（而且您不希望在未来的书籍中受到嘲笑，在那里您会被问到为什么您的树状图既不是树也不是地图）。
- en: 10.1.1\. Designing your layout
  id: totrans-285
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.1.1\. 设计你的布局
- en: 'Before we start working on the functions that will create our grid, we have
    to define what this layout does. We know we want to put the data on a grid, but
    what else do we want? Here’s a simple spec:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编写创建网格的函数之前，我们必须定义这个布局的作用。我们知道我们想在网格上放置数据，但我们还想做什么？这里有一个简单的规范：
- en: We want to have a default arrangement of that grid—say, equal numbers of rows
    and columns.
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们希望有一个默认的网格排列——比如说，行数和列数相等。
- en: We also want to let the user define the number of rows or columns.
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还希望让用户定义行数或列数。
- en: We want the grid to be laid out over a certain size.
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们希望网格跨越一定的尺寸。
- en: We also need to allow the user to define the size of the grid.
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还需要允许用户定义网格的大小。
- en: That’s a good start.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 这是个不错的开始。
- en: 10.1.2\. Implementing your layout
  id: totrans-292
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.1.2\. 实现你的布局
- en: First, we need to initialize all the variables that this grid needs to access
    to make it happen. We also need to define getter and setter functions to let the
    user access those variables, because we want to keep them scoped to the `d3.gridLayout`
    function. The first thing we can do is update the `processGrid` function to look
    like it does in [listing 10.2](#ch10ex02). It takes an array of objects and updates
    them with x and y data based on grid positions. We derive the size of the grid
    from the number of data objects sent to `processGrid`. It turns out this isn’t
    a difficult mathematical problem. We take the square root of the number of datapoints
    and round it up to the nearest whole number to get the right number of rows and
    columns for our grid. This makes sense when you think about how a grid is a set
    of rows and columns that allows you to place a cell on one of those rows and columns
    for each datapoint. The number of rows times columns needs to be at least the
    number of cells (the number of datapoints). If we decide to have the same number
    of rows as columns, then it’s that number squared.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要初始化所有这个网格需要访问的变量，以便使其发生。我们还需要定义getter和setter函数，以便用户可以访问这些变量，因为我们希望将它们限制在`d3.gridLayout`函数的作用域内。我们可以做的第一件事是更新`processGrid`函数，使其看起来像[列表10.2](#ch10ex02)中的那样。它接受一个对象数组，并根据网格位置更新它们的数据。我们从发送到`processGrid`的数据对象数量中推导出网格的大小。实际上，这并不是一个困难的数学问题。我们取数据点的平方根，并将其四舍五入到最接近的整数，以获得网格的正确行数和列数。当你想到网格是一组行和列，允许你为每个数据点在这些行和列之一放置一个单元格时，这就有意义了。行数乘以列数至少需要等于单元格数（数据点的数量）。如果我们决定行数和列数相同，那么就是那个数的平方。
- en: Listing 10.2\. Updated processGrid function
  id: totrans-294
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.2\. 更新的processGrid函数
- en: '[PRE28]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '***1* Calculates the number of rows/columns**'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 计算行数/列数**'
- en: '***2* Initializes a variable to walk through the dataset**'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 初始化一个变量来遍历数据集**'
- en: '***3* Loops through the rows and columns**'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 遍历行和列**'
- en: '***4* This assumes the data consists of an array of objects**'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 这假设数据由一个对象数组组成**'
- en: '***5* Sets the current datapoint to corresponding row and column**'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 将当前数据点设置为相应的行和列**'
- en: '***6* Increments the datapoint variable**'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 增加数据点变量**'
- en: To test our nascent grid layout, we can load our people analytics team using
    nodelist .csv from [chapter 7](../Text/kindle_split_017.html#ch07) and then pass
    that data to the grid. The `grid` function displays the graphical elements onscreen
    based on their computed grid position. In the following listing, you can see how
    we’d pass data from nodelist.csv to our grid layout and size each person by their
    salary.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试我们初生的网格布局，我们可以使用来自[第7章](../Text/kindle_split_017.html#ch07)的nodelist .csv文件加载我们的人员分析团队，然后将这些数据传递给网格。`grid`函数根据计算出的网格位置在屏幕上显示图形元素。在下面的列表中，你可以看到我们如何将nodelist.csv中的数据传递到我们的网格布局中，并根据每个人的薪水来调整每个人的大小。
- en: Listing 10.3\. Using our grid layout
  id: totrans-303
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.3\. 使用我们的网格布局
- en: '[PRE29]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '***1* A scale to fit our grid onto our SVG canvas**'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 一个缩放比例，以适应我们的SVG画布上的网格**'
- en: '***2* Sets circles to a scaled position based on the layout’s calculated x
    and y values**'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 根据布局计算出的x和y值将圆圈设置为缩放位置**'
- en: The results in [figure 10.1](#ch10fig01) show how the grid function has correctly
    appended x and y coordinates to draw the employees as circles on a grid.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '[图10.1](#ch10fig01)中的结果显示了网格函数如何正确地将x和y坐标附加到绘制员工为网格上的圆圈。'
- en: Figure 10.1\. The results of our `makeAGrid` function that uses our new `d3.gridLayout`
    to arrange the data in a grid. In this case, our data consists of employees that
    are each represented as a green circle laid out on a grid and size by salary.
  id: totrans-308
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 10.1\. 使用我们新的 `d3.gridLayout` 对数据进行网格排列的 `makeAGrid` 函数的结果。在这种情况下，我们的数据由代表员工的绿色圆圈组成，这些圆圈在网格上排列，并按薪水大小进行排列。
- en: '![](../Images/10fig01.jpg)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/10fig01.jpg)'
- en: 10.1.3\. Testing your layout
  id: totrans-310
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.1.3\. 测试你的布局
- en: The benefit of building this as a layout is that if we add more data to it,
    it automatically adjusts and allows us to use transitions to animate that adjustment.
    To do that, we need more data. [Listing 10.4](#ch10ex04) includes a few lines
    to create a raft of new employees. We also use the `.concat()` function of an
    array in native JavaScript that, when given the state shown in [figure 10.1](#ch10fig01),
    should produce the results in [figure 10.2](#ch10fig02).
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 将其构建为布局的好处是，如果我们向其中添加更多数据，它将自动调整，并允许我们使用过渡来动画化这种调整。为此，我们需要更多数据。[列表 10.4](#ch10ex04)
    包含了一些创建大量新员工的代码行。我们还使用了原生 JavaScript 中数组的 `.concat()` 函数，当给定 [图 10.1](#ch10fig01)
    中显示的状态时，应该产生 [图 10.2](#ch10fig02) 中的结果。
- en: Figure 10.2\. The grid layout has automatically adjusted to the size of our
    new dataset. Notice that our new elements are above the old elements, but our
    layout has changed in size from a 4 x 4 grid to a 5 x 5 grid, causing the old
    elements to move to their newly calculated position.
  id: totrans-312
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 10.2\. 网格布局已自动调整到我们新数据集的大小。请注意，我们的新元素位于旧元素之上，但我们的布局大小已从 4x4 网格变为 5x5 网格，导致旧元素移动到它们新计算的位置。
- en: '![](../Images/10fig02.jpg)'
  id: totrans-313
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/10fig02.jpg)'
- en: Listing 10.4\. Update the grid with more elements
  id: totrans-314
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.4\. 更新网格以包含更多元素
- en: '[PRE30]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '***1* Creates 14 new employees with increasing salaries**'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 创建 14 名具有递增薪水的员工**'
- en: '***2* Combines the original dataset with our new dataset**'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将原始数据集与我们的新数据集合并**'
- en: '***3* Adds any new employees at 0,0**'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 在 0,0 处添加任何新员工**'
- en: '***4* Moves all employees (old and new) to their newly computed positions**'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 将所有员工（新旧）移动到它们新计算的位置**'
- en: The results in [figure 10.2](#ch10fig02) show snapshots of the animation from
    the old position to the new position of the circles.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 10.2](#ch10fig02) 中的结果显示了从旧位置到新位置的圆圈动画快照。'
- en: 10.1.4\. Extending your layout
  id: totrans-321
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 10.1.4\. 扩展你的布局
- en: Calculating a scale based on what you know to be the grid size results in an
    inefficient piece of code. That wouldn’t be useful if someone put in a different
    dataset. Instead, when designing layouts, you’ll want to provide functionality
    so that the layout size can be declared, and then any adjustments necessary happen
    within the code of the layout that processes data. To do this, we need to add
    a scoped size variable and then add a function to our `processGrid` function to
    allow the user to change that size variable. Sending a variable sets the value,
    and sending no variable returns the value. We achieve this by checking for the
    presence of arguments using the `arguments` object in native JavaScript. The updated
    function is shown in the following listing.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 基于你所知道的网格大小来计算比例会导致代码效率低下。如果有人输入了不同的数据集，这就不会很有用。相反，在设计布局时，你将希望提供功能，以便可以声明布局大小，然后任何必要的调整都发生在处理数据的布局代码中。为此，我们需要添加一个作用域大小变量，然后向我们的
    `processGrid` 函数添加一个函数，允许用户更改该大小变量。发送变量设置值，不发送变量则返回值。我们通过使用原生 JavaScript 中的 `arguments`
    对象检查参数的存在来实现这一点。更新的函数如下所示。
- en: Listing 10.5\. `d3.gridLayout` with size functionality
  id: totrans-323
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.5\. 带有大小功能的 `d3.gridLayout`
- en: '[PRE31]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '***1* Initializes the variable with a default value**'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 使用默认值初始化变量**'
- en: '***2* Creates two scales but doesn’t define their range or domain**'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 创建两个比例，但没有定义它们的范围或域**'
- en: '***3* Defines the range and domain each time the layout is called**'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 每次调用布局时定义范围和域**'
- en: '***4* Applies the scaled values as x and y**'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 将缩放值作为 x 和 y 应用**'
- en: '***5* Getter/setter function for layout size**'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 布局大小的获取/设置函数**'
- en: You can see the updated grid layout in action by slightly changing our code
    for calling the layout, as shown in the following listing. We set the size, and
    when we create our circles, we use the x and y values directly instead of using
    scaled values.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过稍微更改调用布局的代码来查看更新的网格布局效果，如下所示。我们设置了大小，并在创建圆圈时直接使用 x 和 y 值，而不是使用缩放值。
- en: Listing 10.6\. Calling the new grid layout
  id: totrans-331
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.6\. 调用新的网格布局
- en: '[PRE32]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '***1* Sets layout size**'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 设置布局大小**'
- en: '***2* Position circles with their x/y values**'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 使用 x/y 值定位圆圈**'
- en: '***3* At the end of the transition, calls resizeGrid1**'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 在过渡结束时调用resizeGrid1**'
- en: This code refers to a `resizeGrid1()` function, shown in the following listing,
    that’s chained to a `resizeGrid2()` function. These functions use the ability
    to update the size setting on our layout to update the graphical display of the
    elements created by the layout.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码引用了一个`resizeGrid1()`函数，如下面的列表所示，该函数链接到一个`resizeGrid2()`函数。这些函数使用我们在布局上更新大小设置的能力来更新布局创建的元素图形显示。
- en: Listing 10.7\. The `resizeGrid1()` func
  id: totrans-337
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.7\. `resizeGrid1()` 函数
- en: '[PRE33]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '***1* Changes the size, reapplies the layout, and updates the display**'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 更改大小，重新应用布局并更新显示**'
- en: '***2* Again, with a different size**'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 再次，使用不同的尺寸**'
- en: This creates a grid that fits our defined space perfectly, as shown in [figure
    10.3](#ch10fig03), and with no need to create a scale to place the elements.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 这创建了一个完美适应我们定义空间的网格，如图10.3所示，并且不需要创建一个比例来放置元素。
- en: Figure 10.3\. The grid layout run with a 400 x 400 size setting
  id: totrans-342
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.3\. 以400 x 400大小设置运行的网格布局
- en: '![](../Images/10fig03.jpg)'
  id: totrans-343
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/10fig03.jpg)'
- en: '[Figure 10.4](#ch10fig04) shows a pair of animations where the grid changes
    in size as we adjust the size setting. The grid changes to fit a smaller or an
    elongated area. This is done using the transition’s `end` event. It calls a new
    function that uses our original grid layout but updates its size and reapplies
    it to our dataset.'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '[图10.4](#ch10fig04) 显示了一对动画，其中网格的大小随着我们调整大小设置而变化。网格调整大小以适应较小的或拉长的区域。这是使用过渡的`end`事件完成的。它调用一个新的函数，该函数使用我们的原始网格布局，但更新其大小并将其重新应用于我们的数据集。'
- en: Figure 10.4\. The grid layout run in a 200 x 200 size (left) and a 400 x 200
    size (center), and a 200 x 400 size (right)
  id: totrans-345
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.4\. 在200 x 200大小（左）和400 x 200大小（中心）以及200 x 400大小（右）下运行的网格布局
- en: '![](../Images/10fig04.jpg)'
  id: totrans-346
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/10fig04.jpg)'
- en: Before we move on, it’s important that we extend our layout a bit more so that
    you can better understand how layouts work. In D3 a layout isn’t meant to create
    something as specific as a grid full of circles. Rather, *it’s supposed to annotate
    a dataset so you can represent it using different graphical methods.*
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，我们扩展我们的布局很重要，这样你可以更好地理解布局是如何工作的。在D3中，布局并不是用来创建像充满圆形的网格这样具体的东西。相反，*它应该注释数据集，以便你可以使用不同的图形方法来表示它。*
- en: Let’s say we want our layout to also handle squares, which would be a desired
    feature when dealing with grids. To handle squares, or more specifically rectangles
    (because we want them to stretch out if someone uses our layout and sets the height
    and width to different values), we need the capacity to calculate `height` and
    `width` values. That’s easy to add to our existing layout function, as shown in
    the following listing.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们希望我们的布局也能处理正方形，这在处理网格时是一个期望的特性。为了处理正方形，或者更具体地说，处理矩形（因为我们希望如果有人使用我们的布局并设置不同的宽度和高度值时，它们可以拉伸），我们需要计算`高度`和`宽度`值的容量。这很容易添加到我们现有的布局函数中，如下面的列表所示。
- en: Listing 10.8\. Layout code for calculating height and width of grid cells
  id: totrans-349
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.8\. 计算网格单元高度和宽度的布局代码
- en: '[PRE34]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '***1* New code to set the height and width of the grid cells so we can use
    rectangles instead of circles**'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 新代码用于设置网格单元的高度和宽度，以便我们可以使用矩形而不是圆形**'
- en: With that in place, we can call our layout and append `<rect>` elements instead
    of circle elements. We can update our code, as in the following listing, to offset
    the `x` and `y` attributes (because `<rect>` elements are drawn from the top left
    and not from the center like `<circle>` elements) and also apply the width and
    height values that our layout computes.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在此设置到位后，我们可以调用我们的布局并添加`<rect>`元素而不是圆形元素。我们可以更新我们的代码，如下面的列表所示，以偏移`x`和`y`属性（因为`<rect>`元素是从左上角绘制的，而不是像`<circle>`元素那样从中心绘制）并应用布局计算出的宽度和高度值。
- en: Listing 10.9\. Appending rectangles with our layout
  id: totrans-353
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.9\. 使用我们的布局添加矩形
- en: '[PRE35]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '***1* The updated grid layout calculates the space each grid cell takes up**'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 更新网格布局计算每个网格单元占用的空间**'
- en: '***2* Height and width are used to set the rectangle size and position with
    an animated transition**'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 使用高度和宽度设置矩形大小和位置，并使用动画过渡**'
- en: '***3* At the end of the animation, trigger another animation to show how the
    updated settings of the grid size can be used to dynamically update display of
    the grid**'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 在动画结束时，触发另一个动画以显示如何使用更新的网格大小设置动态更新网格的显示**'
- en: '***4* Each of these gives new rectangle sizes based on the new grid.size settings**'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 这些都基于新的grid.size设置提供了新的矩形尺寸**'
- en: If we update the rest of our code accordingly, the result is the same animated
    transition of our layout between different sizes, but now with rectangles that
    grow and distort based on those sizes, as shown in [figure 10.5](#ch10fig05).
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们相应地更新其余代码，结果将是我们的布局在不同大小之间的相同动画过渡，但现在矩形的大小和形状会根据这些大小变化，如图[图10.5](#ch10fig05)所示。
- en: Figure 10.5\. The three states of the grid layout using rectangles for the grid
    cells
  id: totrans-360
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.5. 使用矩形作为网格单元的网格布局的三种状态
- en: '![](../Images/10fig05.jpg)'
  id: totrans-361
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/10fig05.jpg)'
- en: This is a simple example of a layout and doesn’t do nearly as much as the kinds
    of layouts we’ve used throughout this book, but even a simple layout like this
    provides reusable, animatable content. Now we’ll look at another reusable pattern
    in D3—the component—which creates graphical elements automatically.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的布局示例，它所做的远不如本书中使用的各种布局那么复杂，但即使是这样的简单布局也能提供可重用、可动画的内容。现在我们将看看D3中的另一个可重用模式——组件，它能够自动创建图形元素。
- en: 10.2\. Writing your own components
  id: totrans-363
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2. 编写自己的组件
- en: You’ve seen components in action, particularly the `axis` component. You can
    also think of the brush as a component, because it creates graphical elements.
    But it tends to be described as a “control” because it also loads with built-in
    interactivity.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经看到了组件的实际应用，特别是`axis`组件。您也可以将画笔视为一个组件，因为它也创建图形元素。但它通常被描述为“控件”，因为它还带有内置的交互性。
- en: The component that we’ll build is a simple legend. Legends are a necessity when
    working with data visualization, and they all share some things in common. First,
    we’ll need a more interesting dataset to consider, though we’ll continue to use
    our grid layout. The legend component that we’ll create will consist eventually
    of labeled rectangles, each with a color corresponding to the color assigned to
    our datapoints by a D3 scale. This way our users can tell at a glance which colors
    correspond to which values in our data visualization.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建的组件是一个简单的图例。在数据可视化工作中，图例是必不可少的，它们有一些共同之处。首先，我们需要考虑一个更有趣的数据集，尽管我们将继续使用我们的网格布局。我们将创建的图例组件最终将包括带有标签的矩形，每个矩形都有一个颜色，对应于D3比例分配给我们的数据点的颜色。这样，我们的用户可以一眼看出哪些颜色对应于我们的数据可视化中的哪些值。
- en: 10.3\. Loading sample data
  id: totrans-366
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3. 加载样本数据
- en: Instead of the nodelist.csv data, we’ll use world.geojson, except we’ll use
    the features as datapoints on our custom grid layout from [section 10.1](#ch10lev1sec1)
    without putting them on a map. [Listing 10.10](#ch10ex10) shows the corresponding
    code, which produces [figure 10.6](#ch10fig06). You may find it strange to load
    geodata and represent it not as geographic shapes but in an entirely different
    way. Presenting data in an untraditional manner can often be a useful technique
    to draw a user’s attention to the patterns in that data.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用world.geojson文件，而不是nodelist.csv数据，但我们将使用特征作为数据点放置在我们的自定义网格布局中，从[第10.1节](#ch10lev1sec1)中获取，而不是将它们放在地图上。[列表10.10](#ch10ex10)显示了相应的代码，它生成了[图10.6](#ch10fig06)。您可能会觉得将地理数据加载并以其完全不同的方式表示是奇怪的。以非传统方式呈现数据通常是一种有用的技术，可以吸引用户的注意力，关注数据中的模式。
- en: Figure 10.6\. The countries of the world as a grid
  id: totrans-368
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.6. 作为网格的世界各国
- en: '![](../Images/10fig06.jpg)'
  id: totrans-369
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/10fig06.jpg)'
- en: Listing 10.10\. Loading the countries of the world into a grid
  id: totrans-370
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.10. 将世界各国的数据加载到网格中
- en: '[PRE36]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '***1* Calculates the area of each country and appends that to the datapoint**'
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 计算每个国家的面积并将其附加到数据点**'
- en: '***2* Appends a circle for each country**'
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 为每个国家附加一个圆圈**'
- en: 'We’ll focus on only one attribute of our data: the size of each country. We’ll
    color the circles according to that size using a quantize scale that puts each
    country into one of several discrete categories. In our case, we’ll use the `colorbrewer.Reds[7]`
    (remember, this means you’ll need to include a link to the colorbrewer.js file)
    array of light-to-dark reds as our bins. The quantize scale will split the countries
    into seven different groups. In [listing 10.11](#ch10ex11), you can see how to
    set that up, and [figure 10.7](#ch10fig07) shows the result of our new color scale.'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将只关注我们数据的一个属性：每个国家的大小。我们将根据该大小使用量化比例来着色圆圈，将每个国家放入几个离散类别之一。在我们的例子中，我们将使用`colorbrewer.Reds[7]`（记住，这意味着您需要包含对colorbrewer.js文件的链接）的浅到深红色数组作为我们的桶。量化比例将国家分成七个不同的组。在[列表10.11](#ch10ex11)中，您可以看到如何设置它，[图10.7](#ch10fig07)显示了我们的新颜色比例的结果。
- en: Figure 10.7\. Circles representing countries colored by area
  id: totrans-375
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.7. 代表国家的圆圈，按面积着色
- en: '![](../Images/10fig07.jpg)'
  id: totrans-376
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/10fig07.jpg)'
- en: Listing 10.11\. Changing the color of our grid
  id: totrans-377
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.11. 更改网格的颜色
- en: '[PRE37]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '***1* Gets the data array bound to our circles**'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 获取绑定到我们的圆圈的数据数组**'
- en: For a more complete data visualization, we’d want to add labels for the countries
    or other elements to identify the continent or region of the country. But we’ll
    focus on explaining what the color indicates. We don’t want to get bogged down
    with other details from the data that could be explained, for example, using modal
    windows, as we did for our World Cup example in [chapter 4](../Text/kindle_split_013.html#ch04),
    or using other labeling methods discussed throughout this book. For our legend
    to be useful, it needs to account for the different categories of coloration and
    indicate which color is associated with which band of values. But before we get
    to that, let’s build a component that creates graphical elements when we call
    it. Remember that the `d3.select(#something).call (someFunction)` function of
    a selection is the equivalent of `someFunction(d3.select (#something))`. With
    that in mind, we’ll create a function that expects a selection and operates on
    it, as in the following listing.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更完整的数据可视化，我们可能想要添加标签来标识国家或其他元素，以识别大陆或国家所在的地区。但我们将专注于解释颜色表示什么。我们不希望被数据中的其他可能解释的细节所困扰，例如，使用模态窗口，就像我们在第
    4 章的 World Cup 示例中所做的那样，或者使用本书中讨论的其他标签方法。为了使图例有用，它需要考虑不同的着色类别，并指示哪种颜色与哪种值带相关。但在我们到达那里之前，让我们构建一个组件，当我们调用它时，它会创建图形元素。记住，选择集的
    `d3.select(#something).call(someFunction)` 函数与 `someFunction(d3.select(#something))`
    等效。考虑到这一点，我们将创建一个期望一个选择集并对其操作的函数，如下所示。
- en: Listing 10.12\. A simple component
  id: totrans-381
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.12. 一个简单的组件
- en: '[PRE38]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '***1* A component is sent a selection with .call()**'
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 组件通过 .call() 接收一个选择集**'
- en: '***2* Appends to that selection a set of rectangles**'
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将一组矩形添加到该选择集中**'
- en: 'We can then append a `<g>` element to our chart and call this component, with
    the results shown in [figure 10.8](#ch10fig08):'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在我们的图表中添加一个 `<g>` 元素，并称这个组件，结果如图 [10.8](#ch10fig08) 所示：
- en: Figure 10.8\. The new legend component, when called by a `<g>` element placed
    below our grid, creates five red rectangles.
  id: totrans-386
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 10.8. 当通过放置在我们网格下方的 `<g>` 元素调用时，新的图例组件创建了五个红色矩形。
- en: '![](../Images/10fig08.jpg)'
  id: totrans-387
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/10fig08.jpg)'
- en: '[PRE39]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: And now that we have the structure of our component, we can add functionality
    to it, such as allowing the user to define a custom size, as we did with our grid
    layout. We also need to think about where this legend is going to get its data.
    Following the pattern of the axis component, it would make the most sense for
    the legend to refer directly to the scale we’re using and derive, from that scale,
    the color and values associated with the color of each band in the scale.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了组件的结构，我们可以向它添加功能，例如允许用户定义一个自定义大小，就像我们在网格布局中所做的那样。我们还需要考虑这个图例将从哪里获取其数据。遵循轴组件的模式，图例直接引用我们使用的刻度并从中推导出与刻度中每个带颜色相关的颜色和值似乎是合理的。
- en: 10.4\. Linking components to scales
  id: totrans-390
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.4. 将组件链接到刻度
- en: To do that, we have to write a new function for our legend that takes a scale
    and derives the necessary range bands to be useful. The scale we send it will
    be the same `countryColor` scale that we use to color our grid circles. Because
    this is a quantize scale, we’ll make our legend component hardcoded to handle
    only quantize scales. If we wanted to make this a more robust component, we’d
    need to make it identify and handle the various scales that D3 uses.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们必须为我们的图例编写一个新的函数，该函数接受一个刻度并推导出必要的范围带以便使用。我们发送给它的刻度将是我们用来为网格圆圈着色的相同的
    `countryColor` 刻度。因为这是一个量化刻度，所以我们将使我们的图例组件硬编码以仅处理量化刻度。如果我们想使这个组件更健壮，我们需要使其能够识别和处理
    D3 使用的各种刻度。
- en: 'The way all scales have an invert function, they also have the ability to tell
    you what domain values are mapped to what range values. First, we need to know
    the range of values of our quantize scale as they appear to the scale. We can
    easily get that range by using `scaleQuantize.range()`:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 所有刻度都有一个逆函数，它们也有能力告诉你哪些域值映射到哪些范围值。首先，我们需要知道我们的量化刻度的值范围，因为它们在刻度中看起来是这样的。我们可以通过使用
    `scaleQuantize.range()` 轻松地得到这个范围：
- en: '[PRE40]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '***1* [“#fee5d9”, “#fcbba1”, “#fc9272”, “#fb6a4a”, “#ef3b2c”, “#cb181d”, “#99000d”]**'
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* [“#fee5d9”， “#fcbba1”， “#fc9272”， “#fb6a4a”， “#ef3b2c”， “#cb181d”， “#99000d”]**'
- en: 'We can pass those values to `scaleQuantize.invertExtent` to get the numerical
    domain mapped to each color value:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这些值传递给 `scaleQuantize.invertExtent` 以获取映射到每个颜色值的数值域：
- en: '[PRE41]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '***1* [0.000006746501002759535, 0.05946855349777645]**'
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* [0.000006746501002759535, 0.05946855349777645]**'
- en: Armed with these two functions, all we need to do now is give our legend component
    the capacity to have a scale assigned to it and then update the legend function
    itself to derive from that scale the dataset necessary for our legend. [Listing
    10.13](#ch10ex13) shows both the new `d3.simpleLegend.scale()` function that uses
    a quantize scale to create the necessary dataset, and the updated `legend()` function
    that uses that data to draw a more meaningful set of `<rect>` elements.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有这两个函数，我们现在需要做的是给我们的图例组件赋予分配刻度的能力，然后更新图例函数本身，从该刻度中推导出我们图例所需的dataset。[列表 10.13](#ch10ex13)
    显示了使用量化刻度创建所需dataset的新 `d3.simpleLegend.scale()` 函数，以及使用该数据绘制更有意义的 `<rect>` 元素集的更新
    `legend()` 函数。
- en: Listing 10.13\. Updated `legend` function
  id: totrans-399
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.13\. 更新的 `legend` 函数
- en: '[PRE42]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '***1* Sets a default size**'
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 设置默认大小**'
- en: '***2* Initializes an x-axis scale but doesn’t set domain or range**'
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 初始化 x 轴刻度，但未设置域或范围**'
- en: '***3* The scale that will be sent to the component**'
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 将发送到组件的刻度**'
- en: '***4* Calls the function to process the scale into a data array**'
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 调用函数将刻度处理成数据数组**'
- en: '***5* Calculates the min/max of the scale data**'
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 计算刻度数据的最大/最小值**'
- en: '***6* Sets the x-axis scale**'
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 设置 x 轴刻度**'
- en: '***7* Draws rectangles based on component settings and scale data**'
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 根据组件设置和刻度数据绘制矩形**'
- en: '***8* Processes the scale into a data array**'
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8* 将刻度处理成数据数组**'
- en: '***9* Setter/getter to set the legend’s scale**'
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***9* 设置器/获取器以设置图例的刻度**'
- en: 'We call this updated `legend` and set it up:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用这个更新的 `legend` 并设置它：
- en: '[PRE43]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This new `legend` now creates a rect for each band in our scale and colors it
    accordingly, as shown in [figure 10.9](#ch10fig09).
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新的 `legend` 现在为我们的刻度中的每个带创建一个矩形，并相应地着色，如图 [图 10.9](#ch10fig09) 所示。
- en: Figure 10.9\. The updated legend component is automatically created, with a
    `<rect>` element for each band in the quantize scale that’s colored according
    to that band’s color.
  id: totrans-413
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 10.9\. 更新的图例组件自动创建，每个量化刻度带都有一个 `<rect>` 元素，其颜色根据该带的颜色进行着色。
- en: '![](../Images/10fig09.jpg)'
  id: totrans-414
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/10fig09.jpg)'
- en: If we want to add interactivity, it’s a simple process because we know that
    each rect in the legend corresponds to a two-piece array of values from our quantize
    scale showing the value of the bands in that cell. The following listing shows
    that function and the call to make the legend interactive.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要添加交互性，这是一个简单的过程，因为我们知道图例中的每个矩形都对应于来自我们的量化刻度的两个值数组的片段，显示了该单元格中带的价值。以下列表显示了该函数和使图例交互的调用。
- en: Listing 10.14\. Legend interactivity
  id: totrans-416
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.14\. 图例交互性
- en: '[PRE44]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Notice that this function isn’t defined inside our legend component. Instead,
    it’s defined and called after the legend is created, because after it’s created
    our legend component is a set of SVG elements with data bound to it like any other
    part of our charts. This interactivity allows us to mouseover the legend and see
    which circles fall in a particular range of values, as shown in [figure 10.10](#ch10fig10).
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，此函数不是在图例组件内部定义的。相反，它在图例创建后定义和调用，因为创建后，我们的图例组件是一组SVG元素，其中绑定了数据，就像我们图表的任何其他部分一样。这种交互性允许我们在图例上悬停鼠标，并查看哪些圆圈落在特定的值范围内，如图
    [图 10.10](#ch10fig10) 所示。
- en: Figure 10.10\. The `legendOver` behavior highlights circles falling in a particular
    band and deemphasizes the circles not in that band by making them transparent.
  id: totrans-419
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 10.10\. `legendOver` 行为突出显示落在特定带中的圆圈，并通过使它们透明来降低不在该带中的圆圈的重要性。
- en: '![](../Images/10fig10.jpg)'
  id: totrans-420
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/10fig10.jpg)'
- en: Finally, before we can call our legend done, we need to add an indication of
    what those colored bands mean. We can call an axis component and allow that to
    label the bands, or we can label the break points by appending text elements for
    each. In our case, because the numbers provided for `d3.geo.area` are so small,
    we’ll also need to rotate and shrink those labels quite a bit for them to fit
    on the page. To do that, we can add the code in the following listing to our legend
    function in `d3.simpleLegend`
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在我们能够完成我们的图例之前，我们需要添加一个指示这些彩色带含义的说明。我们可以调用一个轴组件并允许它标记带，或者我们可以通过为每个断点附加文本元素来标记断点。在我们的情况下，因为提供的
    `d3.geo.area` 的数字非常小，我们还需要旋转和缩小这些标签，以便它们适合页面。为此，我们可以在以下列表中添加代码到 `d3.simpleLegend`
    的图例函数中
- en: Listing 10.15\. Text labels for legend
  id: totrans-422
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 10.15\. 图例的文本标签
- en: '[PRE45]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '***1* The text element needs to be placed in a g so that it can be translated
    and then rotated; otherwise, it’ll be rotated and then translated, which would
    place it at the translation relative to its new rotation (taking the text off
    the page)**'
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 文本元素需要放置在g中，以便它可以被转换并旋转；否则，它将被旋转然后转换，这将使其位于相对于其新旋转的转换位置（将文本移出页面）**'
- en: As shown in [figure 10.11](#ch10fig11), they aren’t the prettiest labels. We
    could adjust their positioning, font, and style to make them more effective. They
    also need functions like the grid layout has to define size or other elements
    of the component.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图10.11](#ch10fig11)所示，这些标签并不美观。我们可以调整它们的定位、字体和样式，使它们更有效。它们还需要像网格布局那样的功能来定义大小或其他组件元素。
- en: Figure 10.11\. Our legend with rudimentary labels
  id: totrans-426
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.11\. 我们带有基本标签的图例
- en: '![](../Images/10fig11.jpg)'
  id: totrans-427
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/10fig11.jpg)'
- en: This is usually the point where I say that the purpose of this chapter is to
    show you that the structure of components and layouts, and that making the most
    effective layout or component is a long and involved process that we won’t get
    into. But this is an ugly legend. The break points are hard to read, and it’s
    missing pieces that the component needs, such as a title and an explanation of
    units.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常是我说明本章目的是向您展示组件和布局的结构，以及制作最有效的布局或组件是一个漫长且复杂的过程，我们不会深入探讨。但这是一个丑陋的图例。断点难以阅读，并且缺少组件需要的部分，例如标题和单位说明。
- en: 10.5\. Adding component labels
  id: totrans-429
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.5\. 添加组件标签
- en: Let’s add those features to the legend and create ways to access them, as shown
    in the following listing. We’re using `d3.format`, which allows us to set a number-formatting
    rule based on the popular Python number-formatting mini-language (found at [https://docs.python.org/release/3.1.3/library/string.html#formatspec](https://docs.python.org/release/3.1.3/library/string.html#formatspec)).
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们向图例添加这些功能，并创建访问它们的方法，如下面的列表所示。我们使用`d3.format`，它允许我们根据流行的Python数字格式化迷你语言（位于[https://docs.python.org/release/3.1.3/library/string.html#formatspec](https://docs.python.org/release/3.1.3/library/string.html#formatspec)）设置一个数字格式化规则。
- en: Listing 10.16\. Title and unit attributes of a legend
  id: totrans-431
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.16\. 图例的标题和单位属性
- en: '[PRE46]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '***1* These are added right after var scale inside the d3.simpleLegend function**'
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 这些是在d3.simpleLegend函数内部的var scale之后添加的**'
- en: '***2* All these functions are added right after legend.scale**'
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 所有这些功能都是在legend.scale之后立即添加的**'
- en: We’ll use these new properties in our updated legend drawing code shown in [listing
    10.17](#ch10ex17). This new code draws SVG `<line>` elements at each breakpoint
    and foregoes the rotated text in favor of more readable, shortened text labels
    at each breakpoint. It also adds two new `<text>` elements, one above the legend
    that corresponds to the value of the `title` variable and one at the far right
    of the legend that corresponds to the `units` variable.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[列表10.17](#ch10ex17)中显示的更新的图例绘制代码中使用这些新属性。新代码在每个断点处绘制SVG `<line>` 元素，并放弃旋转文本，转而使用更易读的、缩短的文本标签。它还添加了两个新的
    `<text>` 元素，一个位于图例上方，对应于`title`变量的值，另一个位于图例的远右侧，对应于`units`变量。
- en: Listing 10.17\. Updated legend drawing code
  id: totrans-436
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.17\. 更新的图例绘制代码
- en: '[PRE47]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '***1* This follows your existing code to draw the legend <rect> elements, and
    updates the text**'
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 这遵循你现有的代码来绘制图例<rect>元素，并更新文本**'
- en: '***2* Each line is drawn at the breakpoint and drawn a little lower to “point”
    at the breakpoint value**'
  id: totrans-439
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 每一行都在断点处绘制，并稍微向下绘制以“指向”断点值**'
- en: '***3* Anchors your unrotated labels at the midpoint and formats the value according
    to the set formatter**'
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 将未旋转的标签锚定在中间，并根据设置的格式化器格式化值**'
- en: '***4* Adds a fixed, user-defined title above the legend rectangles and at the
    minimum value position**'
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 在图例矩形上方添加一个固定、用户定义的标题，位于最小值位置**'
- en: '***5* Adds a fixed, user-defined unit label on the same line as the labels
    but at the maximum value position**'
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 在标签所在行添加一个固定、用户定义的单位标签，但位于最大值位置**'
- en: This requires that we set these new values using the code in the following listing
    before we call the legend.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 这要求我们在调用图例之前使用以下列表中的代码设置这些新值。
- en: Listing 10.18\. Calling the legend with title and unit setting
  id: totrans-444
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表10.18\. 使用标题和单位设置调用图例
- en: '[PRE48]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '***1* Sets the legend title and unit labels and formats to reflect the data
    being visualized**'
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 设置图例标题和单位标签以及格式，以反映正在可视化的数据**'
- en: '***2* This part is unchanged**'
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 这部分没有变化**'
- en: And now, as shown in [figure 10.12](#ch10fig12), we have a label that’s eminently
    more readable, still interactive, and useful in any situation where the data visualization
    uses a similar scale.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如图10.12所示，我们有一个标签，它的可读性大大提高，仍然具有交互性，并且在任何使用类似比例的数据可视化中都很实用。
- en: Figure 10.12\. Our legend with title, unit labels, appropriate number formatting,
    and additional graphical elements to highlight the breakpoints
  id: totrans-449
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图10.12. 我们的图例带有标题、单位标签、适当的数字格式化，以及额外的图形元素来突出显示断点
- en: '![](../Images/10fig12.jpg)'
  id: totrans-450
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/10fig12.jpg)'
- en: 'By building components and layouts, you understand better how D3 works, but
    there’s another reason why they’re so valuable: reusability. You’ve built a chart
    using a layout and component (no matter how simple) that you wrote yourself. You
    could use either in tandem with another layout or component, or on its own, with
    any data visualization charts you use elsewhere.'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 通过构建组件和布局，你更好地理解了D3的工作原理，但它们之所以如此有价值，还有另一个原因：可重用性。你已经使用布局和组件（无论多么简单）构建了一个图表，这些是你自己编写的。你可以将它们与另一个布局或组件一起使用，或者单独使用，在任何其他地方使用的数据可视化图表中。
- en: '|  |'
  id: totrans-452
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Infoviz term: reusable charts**'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: '**信息可视化术语：可重用图表**'
- en: After you’ve worked with components, layouts, and controls in D3, you may start
    to wonder if there’s a higher level of abstraction available that could combine
    layouts and controls in a reusable fashion. That level of abstraction has been
    referred to as a *chart*, and the creation of reusable charts has been of great
    interest to the D3 community.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 在你使用过D3中的组件、布局和控制之后，你可能开始怀疑是否有一个更高层次的抽象可以以可重用的方式结合布局和控制。这个抽象层次被称为*图表*，可重用图表的创建一直是D3社区的热点。
- en: 'This has led to the development of several APIs on top of D3, such as NVD3,
    D4 (for generic charts), and my own `d3.carto.map` (for web mapping, not surprisingly).
    It’s also led The Miso Project to develop `d3.chart`, a framework for reusable
    charts. If you’re interested in using or developing reusable charts, you may want
    to check these out:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致了在D3之上开发出几个API，如NVD3、D4（用于通用图表）以及我自己的`d3.carto.map`（用于网络地图，不出所料）。这也促使Miso项目开发出`d3.chart`，这是一个可重用图表的框架。如果你对使用或开发可重用图表感兴趣，你可能想看看这些：
- en: '`d3.chart`—[http://misoproject.com/d3-chart/](http://misoproject.com/d3-chart/)'
  id: totrans-456
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`d3.chart`—[http://misoproject.com/d3-chart/](http://misoproject.com/d3-chart/)'
- en: '`d3.carto.map`—[https://github.com/emeeks/d3-carto-map](https://github.com/emeeks/d3-carto-map)'
  id: totrans-457
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`d3.carto.map`—[https://github.com/emeeks/d3-carto-map](https://github.com/emeeks/d3-carto-map)'
- en: '*D4*—[http://visible.io](http://visible.io)'
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*D4*—[http://visible.io](http://visible.io)'
- en: '*NVD3*—[http://nvd3.org](http://nvd3.org)'
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*NVD3*—[http://nvd3.org](http://nvd3.org)'
- en: '|  |'
  id: totrans-460
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: You may also try your hand at building more responsive components that automatically
    update when you call them again, like the axis and brushes we dealt with in the
    last chapter. Or you may try creating controls like `d3.brush` and behaviors like
    `d3.behavior.drag`. Regardless of how extensively you follow this pattern, I recommend
    that you look for instances when your information visualization can be abstracted
    into layouts and components and try to create those instead of building another
    one-off visualization. By doing that, you’ll develop a higher level of skill with
    D3 and fill your toolbox with your own pieces for later work.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以尝试构建更响应式的组件，这些组件在你再次调用它们时会自动更新，就像我们在上一章中处理的轴和画笔一样。或者，你可以尝试创建像`d3.brush`这样的控件和像`d3.behavior.drag`这样的行为。无论你如何广泛地遵循这种模式，我都建议你寻找你的信息可视化可以被抽象为布局和组件的实例，并尝试创建这些而不是构建另一个一次性可视化。通过这样做，你将提高D3的技能水平，并在你的工具箱中为以后的工作添加自己的组件。
- en: '|  |'
  id: totrans-462
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Publishing your plugins
  id: totrans-463
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 发布你的插件
- en: When you’re done building your plugin, you probably want to let other people
    use it. Mike Bostock wrote an excellent tutorial on how to publish your D3 plugins
    so that they behave like other D3 plug-ins. You can find the tutorial at [https://bost.ocks.org/mike/d3-plugin/](https://bost.ocks.org/mike/d3-plugin/).
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 当你完成插件构建后，你可能希望让其他人使用它。Mike Bostock写了一篇关于如何发布你的D3插件的优秀教程，以便它们的行为像其他D3插件一样。你可以在这个教程中找到[https://bost.ocks.org/mike/d3-plugin/](https://bost.ocks.org/mike/d3-plugin/)。
- en: '|  |'
  id: totrans-465
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 10.6\. Summary
  id: totrans-466
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.6. 摘要
- en: 'To make your code more reusable, follow the two patterns that already exist
    in D3: layouts and components.'
  id: totrans-467
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了使你的代码更具可重用性，遵循D3中已经存在的两种模式：布局和组件。
- en: Components create graphical elements, like the axis component.
  id: totrans-468
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件创建图形元素，例如轴组件。
- en: Layouts decorate data for the purpose of drawing, like the pie chart layout.
  id: totrans-469
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布局装饰数据以供绘图，例如饼图布局。
- en: Plugins follow a getter/setter pattern popular with D3 that allows people to
    use method-chaining.
  id: totrans-470
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插件遵循D3中流行的getter/setter模式，允许人们使用方法链式调用。
- en: In making our layouts and generators, we learned how to deal with the `.call`
    functionality in D3 by passing a `<g>` element to our simple legend function.
    This includes querying the D3 scale we send to that function to identify the necessary
    bands for our legend.
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在创建布局和生成器时，我们学习了如何通过传递一个`<g>`元素到我们的简单图例函数中来处理D3中的`.call`功能。这包括查询我们发送给该函数的D3比例尺以确定图例所需的部分。
- en: D3.js in the real world
  id: totrans-472
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: D3.js在现实世界中的应用
- en: Susie Lu Senior Data Visualization Engineer
  id: totrans-473
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Susie Lu 高级数据可视化工程师
- en: '*d3-svg-legend*'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: '*d3-svg-legend*'
- en: '[http://d3-legend.susielu.com/](http://d3-legend.susielu.com/)'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://d3-legend.susielu.com/](http://d3-legend.susielu.com/)'
- en: Making legends in D3 was something I had done multiple times and grew tired
    of implementing in a custom way over and over. After enough repetition, I decided
    it would be valuable to create a library to solve the use case.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 在D3中创建图例是我多次做过的事情，并且厌倦了反复以自定义方式实现。经过足够的重复，我决定创建一个库来解决这个用例。
- en: My main priority was to make it as easy to create a legend as possible, something
    that I’d want to use. The biggest factor to meet this requirement was to provide
    full documentation including plenty of examples. Using examples was one of the
    main avenues I used to learn D3 and wanted to also provide those code snippets
    for users of d3-legend.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 我的主要优先级是尽可能简化创建图例的过程，这是我想要使用的。满足这一要求的最重要因素是提供完整的文档，包括大量的示例。使用示例是我学习D3的主要途径之一，我也想为d3-legend的用户提供这些代码片段。
- en: '![](../Images/331fig01_alt.jpg)'
  id: totrans-478
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/331fig01_alt.jpg)'
- en: Chapter 11\. Mixed mode rendering
  id: totrans-479
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第11章. 混合模式渲染
- en: '*This chapter covers*'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Using built-in canvas rendering for D3 shapes
  id: totrans-481
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用内置的canvas渲染D3形状
- en: Creating large random datasets of multiple types
  id: totrans-482
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建多种类型的大型随机数据集
- en: Using canvas drawing in conjunction with SVG to draw large datasets
  id: totrans-483
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用canvas绘图与SVG结合绘制大型数据集
- en: Optimizing geospatial, network, and traditional dataviz
  id: totrans-484
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化地理空间、网络和传统数据可视化
- en: Working with quadtrees to enhance spatial search performance
  id: totrans-485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用四叉树提高空间搜索性能
- en: This chapter focuses on techniques to create data visualization using canvas
    drawing, sometimes paired with SVG, a technique typically used for large amounts
    of data. Because it would be impractical to include a few large datasets, we’ll
    also touch on how to create large amounts of sample data to test your code with.
    You’ll use several layouts that you saw earlier, such as the force-directed network
    layout from [chapter 6](../Text/kindle_split_016.html#ch06) and the geospatial
    map from [chapter 7](../Text/kindle_split_017.html#ch07), as well as the brush
    component from [chapter 9](../Text/kindle_split_020.html#ch09), except this time
    you’ll use the brush component to select regions across the x- and y-axes.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点介绍使用canvas绘图创建数据可视化的技术，有时与SVG结合使用，这是一种通常用于大量数据的技术。由于包含几个大型数据集不太实用，我们还将简要介绍如何创建大量样本数据以测试您的代码。您将使用之前看到的几个布局，例如第6章中的力导向网络布局[第6章](../Text/kindle_split_016.html#ch06)和第7章中的地理空间地图[第7章](../Text/kindle_split_017.html#ch07)，以及第9章中的brush组件[第9章](../Text/kindle_split_020.html#ch09)，但这次您将使用brush组件来选择x轴和y轴上的区域。
- en: 'This chapter touches on an exotic piece of functionality in D3: the quadtree
    (shown in [figure 11.1](#ch11fig01)). The *quadtree* is an advanced technique
    we’ll use to improve interactivity and performance. We’ll also look into the specifics
    of how to use canvas in tandem with SVG to get high performance and maintain the
    interactivity that SVG is so useful for.'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涉及D3中的一个异类功能：四叉树（如图11.1所示）。四叉树是一种高级技术，我们将用它来提高交互性和性能。我们还将探讨如何将canvas与SVG结合使用以获得高性能并保持SVG的交互性，这对于SVG非常有用。
- en: Figure 11.1\. This chapter focuses on optimization techniques such as using
    canvas drawing to render large datasets in tandem with SVG for the interactive
    elements. This is demonstrated with maps ([section 11.1](#ch11lev1sec1)), networks
    ([section 11.2](#ch11lev1sec2)), and traditional xy data ([section 11.3](#ch11lev1sec3)),
    which uses the D3 quadtree function (section 11.3.2).
  id: totrans-488
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图11.1. 本章重点介绍优化技术，例如使用canvas绘图与SVG结合渲染大型数据集，以实现交互式元素的高性能。这通过地图([第11.1节](#ch11lev1sec1))、网络([第11.2节](#ch11lev1sec2))和传统的xy数据([第11.3节](#ch11lev1sec3))来展示，其中使用了D3
    quadtree函数(第11.3.2节)。
- en: '![](../Images/11fig01_alt.jpg)'
  id: totrans-489
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/11fig01_alt.jpg)'
- en: We’ve worked with data throughout this book, but this time we’ll appreciably
    up the ante by trying to represent a thousand or more datapoints using maps, networks,
    and charts, which are significantly more resource-intensive than a circle pack
    chart, bar chart, or spreadsheet.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这本书中一直处理数据，但这次我们将通过尝试使用地图、网络和图表来表示一千或更多的数据点来显著提高难度，这些图表比圆包图、条形图或电子表格资源密集得多。
- en: 11.1\. Built-in canvas rendering with d3-shape generators
  id: totrans-491
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.1\. 使用d3-shape生成器内置的canvas渲染
- en: Fortunately, D3v4 introduced built-in functionality in D3 for drawing complex
    shapes with canvas. For this chapter, we’ll need to include a `<canvas>` element
    in our DOM, as shown in the following listing.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，D3v4在D3中引入了内置功能，用于使用canvas绘制复杂形状。对于本章，我们需要在我们的DOM中包含一个`<canvas>`元素，如下面的列表所示。
- en: Listing 11.1\. bigdata.html
  id: totrans-493
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表11.1\. bigdata.html
- en: '[PRE49]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '***1* Make sure to set the height and width attributes, not only the style
    attributes**'
  id: totrans-495
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 确保设置高度和宽度属性，而不仅仅是样式属性**'
- en: In the following listing we see how to make our `<canvas>` element line up with
    our `<svg>` element so that we can use canvas drawing as a background layer to
    any SVG elements we create.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的列表中，我们可以看到如何使我们的`<canvas>`元素与`<svg>`元素对齐，以便我们可以将画布绘制用作任何创建的SVG元素的背景层。
- en: Listing 11.2\. bigdata.css
  id: totrans-497
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表11.2\. bigdata.css
- en: '[PRE50]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '***1* In this chapter we’ll draw SVG over canvas, so the canvas element needs
    to have the same attributes as the SVG element**'
  id: totrans-499
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 在本章中，我们将将在画布上绘制SVG，因此画布元素需要具有与SVG元素相同的属性**'
- en: '***2* Likewise, identical settings for the SVG element**'
  id: totrans-500
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 同样，SVG元素具有相同的设置**'
- en: Everything that comes out of d3-shape can be used to draw to canvas using the
    generator’s built-in `.context()` method. The way you interface with a `canvas`
    element is to register a context, which can be “`2d`”, “`webgl`”, “`webgl2`”,
    or “`bitmaprenderer`”. We’re only going to use “`2d`” in our examples in this
    chapter. Once you have that context, you can then use it to draw lines with commands
    similar to the SVG `d` attribute drawing instructions. With `d3-shape` generators,
    if you set a `.context()` of a generator, the function will no longer return an
    SVG `d` attribute drawing string, instead it will run commands to draw the shape
    on the `canvas` element. The following listing shows how to use this functionality
    to draw the violin plots from [chapter 5](../Text/kindle_split_014.html#ch05),
    except this time using canvas drawing.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 从d3-shape出来的所有内容都可以使用生成器的内置`.context()`方法绘制到画布上。您与`canvas`元素交互的方式是注册一个上下文，可以是“`2d`”、“`webgl`”、“`webgl2`”或“`bitmaprenderer`”。在本章的示例中，我们只会使用“`2d`”。一旦您有了这个上下文，您就可以使用它来绘制与SVG
    `d`属性绘制指令类似的命令。使用`d3-shape`生成器，如果您设置了一个生成器的`.context()`，该函数将不再返回SVG `d`属性绘制字符串，而是将在`canvas`元素上绘制形状的命令。下面的列表显示了如何使用此功能绘制第5章中的小提琴图，但这次使用的是canvas绘制。
- en: Listing 11.3\. Drawing violin plots on canvas
  id: totrans-502
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表11.3\. 在画布上绘制小提琴图
- en: '[PRE51]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '***1* Up until this point it’s all the same code**'
  id: totrans-504
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 到目前为止，所有的代码都是相同的**'
- en: '***2* You need context to draw on canvas**'
  id: totrans-505
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 您需要在画布上绘制时提供上下文**'
- en: '***3* Register the generator’s .context with your context**'
  id: totrans-506
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 将生成器的.context注册到您的上下文中**'
- en: '***4* This is one way to clear your canvas by blanking a rectangular section**'
  id: totrans-507
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 这是清除画布的一种方法，通过空白矩形区域**'
- en: '***5* Move the drawing start point with each shape**'
  id: totrans-508
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 每个形状移动绘制起点**'
- en: '***6* Start drawing**'
  id: totrans-509
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 开始绘制**'
- en: '***7* Run your generator with the appropriate data**'
  id: totrans-510
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7* 使用适当的数据运行您的生成器**'
- en: '***8* Stroke and fill the shape you drew**'
  id: totrans-511
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8* 线条和填充您所绘制的形状**'
- en: The results, seen in [figure 11.2](#ch11fig02), are similar to what we saw in
    [chapter 5](../Text/kindle_split_014.html#ch05).
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 结果，如图11.2所示，与我们第5章中看到的结果相似。
- en: Figure 11.2\. Violin plots drawn using canvas. You can see that they’re more
    pixelated.
  id: totrans-513
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图11.2\. 使用canvas绘制的小提琴图。您可以看到它们更像素化。
- en: '![](../Images/11fig02.jpg)'
  id: totrans-514
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/11fig02.jpg)'
- en: When we look at canvas rendering there are a couple clear differences from SVG.
    First, you’re going to need to manually perform part of the behavior you’ve grown
    accustomed to having D3 handle for you. For one thing, you need to clear the canvas
    in between rendering if you’re going to do any kind of transitioning or animation.
    The other major difference is that when you draw to canvas, you have no kind of
    object to associate mouse events onto. There are still ways to register mouse
    events using bitmaps, such as using the color of the pixel clicked or translating
    the xy coordinate to back to whatever shape would occupy that space. The final
    difference is highlighted in [figure 11.3](#ch11fig03), the pixelated rendering
    on canvas compared to that of SVG.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看画布渲染时，与 SVG 有几个明显的区别。首先，你可能需要手动执行你习惯由 D3 为你处理的部分行为。例如，如果你要进行任何类型的转换或动画，你需要手动清除画布。另一个主要区别是，当你向画布绘制时，你没有可以关联鼠标事件的对象。仍然有使用位图注册鼠标事件的方法，例如使用点击像素的颜色或将
    xy 坐标转换回占据该空间的任何形状。最后一个区别在 [图 11.3](#ch11fig03) 中突出显示，画布上的像素化渲染与 SVG 的渲染相比。
- en: Figure 11.3\. Two zoomed-in shapes, one rendered in SVG (left) and one rendered
    with canvas (right)
  id: totrans-516
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 11.3\. 两个放大后的形状，一个使用 SVG（左）绘制，另一个使用画布（右）
- en: '![](../Images/11fig03.jpg)'
  id: totrans-517
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/11fig03.jpg)'
- en: You can use this method to render any of your existing code that uses D3 generators
    from d3-shape, such as `d3.arc` for canvas pie charts or `d3.area` for canvas
    streamgraphs. From this point on, we’re going to focus on particular applications
    of canvas rendering, combining it with SVG rendering (known as *mixed mode rendering*)
    for interactivity, and using quadtrees to improve performance for large datasets.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这种方法来渲染任何使用 d3-shape 中的 D3 生成器的现有代码，例如 `d3.arc` 用于画布饼图或 `d3.area` 用于画布流图。从现在开始，我们将专注于画布渲染的特定应用，将其与
    SVG 渲染（称为 *混合模式渲染*）结合，以提高交互性，并使用四叉树来提高大数据集的性能。
- en: 11.2\. Big geodata
  id: totrans-519
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.2\. 大地理数据
- en: 'In [chapter 7](../Text/kindle_split_017.html#ch07), you had only 10 cities
    representing the entire globe. That’s not typical: when you’re working with geodata,
    you’ll often work with large datasets describing many complex shapes. In this
    section we’ll see how to create a map with many features. To get there, we’ll
    first learn how to generate some random geographic features (in this case, simple
    triangles) and then learn how to render those features using canvas. Then we’ll
    wire that all up with a smart implementation of `d3-zoom` to ensure that our users
    get the best mix of performance and functionality.'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 7 章](../Text/kindle_split_017.html#ch07) 中，你只有 10 个城市代表整个地球。这不是典型情况：当你处理地理数据时，你通常会处理描述许多复杂形状的大数据集。在本节中，我们将了解如何创建具有许多特征的地图。为了达到这个目标，我们首先将学习如何生成一些随机地理特征（在这种情况下，简单的三角形），然后学习如何使用画布渲染这些特征。然后我们将使用
    `d3-zoom` 的智能实现将所有这些连接起来，以确保我们的用户获得最佳的性能和功能组合。
- en: 11.2.1\. Creating random geodata
  id: totrans-521
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.2.1\. 创建随机地理数据
- en: The first thing we need is a dataset with a thousand datapoints. Rather than
    using
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先需要一个包含一千个数据点的数据集。而不是使用
- en: data from a pregenerated file, we’ll invent it. One useful function available
    in D3 is `d3.range()`, which allows you to create an array of values. We’ll use
    `d3.range()` to create an array of a thousand values. We’ll then use that array
    to populate an array of objects with enough data to put on a network and on a
    map. Because we’re going to put this data on a map, we need to make sure it’s
    properly formatted geoJSON, as in the following listing, which uses the `randomCoords()`
    function to create triangles.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 从一个预生成的文件中获取数据，我们将自己创建它。D3 中有一个非常有用的函数 `d3.range()`，它允许你创建一个值数组。我们将使用 `d3.range()`
    创建一个包含一千个值的数组。然后我们将使用这个数组来填充一个对象数组，其中包含足够的数据，可以用于网络和地图。因为我们打算将数据放在地图上，所以我们需要确保它是以正确的格式格式化的
    geoJSON，如下面的列表所示，它使用了 `randomCoords()` 函数来创建三角形。
- en: Listing 11.4\. Creating sample data
  id: totrans-524
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 11.4\. 创建示例数据
- en: '[PRE52]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '***1* d3.range creates an array that we immediately map to an object array**'
  id: totrans-526
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* d3.range 创建一个数组，我们立即将其映射到一个对象数组**'
- en: '***2* Each datapoint is an object with the necessary attributes to be placed
    on a map**'
  id: totrans-527
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 每个数据点都是一个对象，具有放置在地图上所需的属性**'
- en: '***3* Draws a triangle around each random lat/long coordinate pair**'
  id: totrans-528
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 在每个随机的经纬度坐标对周围绘制一个三角形**'
- en: After we have this data, we can throw it on a map like the one we first created
    in [chapter 7](../Text/kindle_split_017.html#ch07). In the following listing we
    use the world.geojson file from [chapter 7](../Text/kindle_split_017.html#ch07)
    so that we have context for where the triangles are drawn.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们有了这些数据之后，我们可以把它们扔到一个像我们在[第7章](../Text/kindle_split_017.html#ch07)中第一次创建的地图上。在下面的列表中，我们使用[第7章](../Text/kindle_split_017.html#ch07)中的world.geojson文件，以便我们了解三角形绘制的地方。
- en: Listing 11.5\. Drawing a map with our sample data on it
  id: totrans-530
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表11.5. 在我们的样本数据上绘制地图
- en: '[PRE53]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '***1* Adjusts the projection and translation of the projection rather than
    the <g> so we can use the projection later to draw to canvas**'
  id: totrans-532
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 调整投影和投影的平移，而不是<g>，这样我们就可以稍后使用投影来绘制到画布上**'
- en: Although our random triangles will obviously be in different places, our code
    should still produce something that looks like [figure 11.4](#ch11fig04).
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们的随机三角形显然会位于不同的位置，但我们的代码仍然应该产生类似于[图11.4](#ch11fig04)的视觉效果。
- en: Figure 11.4\. Drawing random triangles on a map entirely with SVG
  id: totrans-534
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图11.4. 完全使用SVG在地图上绘制随机三角形
- en: '![](../Images/11fig04.jpg)'
  id: totrans-535
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/11fig04.jpg)'
- en: '|  |'
  id: totrans-536
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Infoviz term: big data visualization**'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: '**信息可视化术语：大数据可视化**'
- en: By the time you read this book, *big data* will probably sound as dated as *Pentium
    II*, *Rich Internet Application*, or *Buffy Cosplay*. Big data and all the excitement
    surrounding big data resulted from the broad availability of large datasets that
    were previously too large to handle. Often, big data is associated with exotic
    data stores like Hadoop or specialized techniques like GPU supercomputing (along
    with overpriced consultants).
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 到你阅读这本书的时候，*大数据*可能听起来就像*Pentium II*、*富互联网应用*或*Buffy Cosplay*一样过时。大数据以及围绕大数据的所有兴奋情绪，都源于以前太大而无法处理的大数据集的广泛可用性。通常，大数据与像Hadoop这样的异类数据存储或像GPU超级计算这样的专门技术（以及价格昂贵的顾问）相关联。
- en: But what constitutes *big* is in the eye of the beholder. In the domain of data
    visualization, the representation of big data doesn’t typically mean placing thousands
    (or millions or trillions) of individual datapoints onscreen at once. Rather,
    it tends to mean demographic, topological, and other traditional statistical analysis
    of these massive datasets. Counterintuitively, big data visualization often takes
    the form of pie charts and bar charts. But when you look at traditional practice
    with presenting data interactively—natively—in the browser, the size of the datasets
    you’re dealing with in this chapter can be considered *big*.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 但“大”的定义因人而异。在数据可视化的领域，大数据的表示通常并不意味着一次在屏幕上放置成千（或数百万或数十亿）个单独的数据点。相反，它往往意味着对这些大规模数据集进行人口统计、拓扑和其他传统统计分析。出人意料的是，大数据可视化通常以饼图和柱状图的形式出现。但是，当你查看在浏览器中交互式（原生）展示数据的传统实践时，你在这个章节中处理的数据集的大小可以被认为是“大”的。
- en: '|  |'
  id: totrans-540
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: A thousand datapoints isn’t many, even on a small map like this. And in any
    browser that supports SVG, the data should be able to render quickly and provide
    you with the kind of functionality, such as mouseover and click events, that you
    may want from your data display. But if you add zoom controls, like you see in
    [listing 11.6](#ch11ex06) (the same zooming we had in [chapter 7](../Text/kindle_split_017.html#ch07)),
    you might notice that the performance of the zooming and panning of the map isn’t
    so great. If you expect your users to be on mobile, optimization is still a good
    idea.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是在这样一个小地图上，一千个数据点也不算多。在支持SVG的任何浏览器中，数据应该能够快速渲染，并提供你从数据展示中可能想要的诸如鼠标悬停和点击事件等功能。但是，如果你添加了像[列表11.6](#ch11ex06)（我们在[第7章](../Text/kindle_split_017.html#ch07)中拥有的相同缩放）中看到的那种缩放控件，你可能会注意到地图的缩放和滚动性能并不那么出色。如果你预期你的用户将在移动设备上使用，优化仍然是一个好主意。
- en: Listing 11.6\. Adding zoom controls to a map
  id: totrans-542
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表11.6. 向地图添加缩放控件
- en: '[PRE54]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '***1* We use projection zoom in this example because it’ll be easier to draw
    canvas elements later**'
  id: totrans-544
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 我们在这个例子中使用投影缩放，因为这样稍后绘制画布元素会更容易**'
- en: Now we can zoom into our map and pan around, as shown in [figure 11.5](#ch11fig05).
    If you expect your users to be on browsers that handle SVG well, like Chrome or
    Safari, and you don’t expect to put more features on a map, you may not even need
    to worry about optimization.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以缩放我们的地图并四处移动，如图[图11.5](#ch11fig05)所示。如果你预期你的用户将在处理SVG表现良好的浏览器上，如Chrome或Safari，并且你预期不会在地图上添加更多功能，你可能甚至不需要担心优化。
- en: Figure 11.5\. Zooming in on the sample geodata around East Asia and Oceania
  id: totrans-546
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图11.5. 缩放东亚和大洋洲周围的样本地理数据
- en: '![](../Images/11fig05.jpg)'
  id: totrans-547
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/11fig05.jpg)'
- en: Depending on when you execute this code, it might be that 1,000 features like
    this render fine. Change your `d3.range()` setting from 1,000 to 5,000 (or 10,000
    or a billion if you’ve found this in the Classics section of your Earth Empire
    lending library) to see that with enough SVG elements, your browser starts to
    choke. It’s less about rendering the complex shapes than it is about managing
    all those DOM elements.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你执行此代码的时间，可能 1,000 个这样的特征渲染得很好。将你的 `d3.range()` 设置从 1,000 更改为 5,000（或者如果你在地球帝国借阅图书馆的经典部分发现了这个，可以改为
    10,000 或十亿）来查看，随着 SVG 元素的增加，你的浏览器开始变得缓慢。这更多是关于管理所有这些 DOM 元素，而不是渲染复杂的形状。
- en: 11.2.2\. Drawing geodata with canvas
  id: totrans-549
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.2.2\. 使用画布绘制地理数据
- en: One way to optimize the rendering of so many elements is to use canvas instead
    of SVG. Instead of creating SVG elements using D3’s `enter` syntax, we use the
    built-in functionality in `d3.geoPath` to provide a context for canvas drawing.
    In the following listing, you can see how to use that built-in functionality with
    your existing dataset.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 优化如此多元素渲染的一种方法是用画布代替 SVG。而不是使用 D3 的 `enter` 语法创建 SVG 元素，我们使用 `d3.geoPath` 内置功能为画布绘制提供上下文。在下面的列表中，你可以看到如何使用该内置功能与你的现有数据集一起使用。
- en: Listing 11.7\. Drawing the map with canvas
  id: totrans-551
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 11.7\. 使用画布绘制地图
- en: '[PRE55]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '***1* Always clear the canvas before redrawing it if you’re updating it**'
  id: totrans-553
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 如果你在更新画布，请始终在重新绘制之前清除它**'
- en: '***2* Switches geoPath to a context generator with our canvas context**'
  id: totrans-554
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 将 geoPath 转换为具有我们画布上下文的上下文生成器**'
- en: '***3* Styles settings for countries**'
  id: totrans-555
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 国家样式设置**'
- en: '***4* Draws each country feature to canvas**'
  id: totrans-556
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 将每个国家特征绘制到画布上**'
- en: '***5* Draws each triangle to canvas**'
  id: totrans-557
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 将每个三角形绘制到画布上**'
- en: You can see some key differences between [listings 11.5](#ch11ex05) and [11.6](#ch11ex06).
    In contrast with SVG, where you can move elements around as well as redraw them,
    you always have to clear and redraw the canvas to update it. Although it seems
    this would be slower, performance increases on all browsers, particularly those
    that don’t have the best SVG performance, because you don’t need to manage hundreds
    or thousands of DOM elements. The graphical results, as seen in [figure 11.6](#ch11fig06),
    demonstrate that it’s hard to see the difference between SVG and canvas rendering.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [列表 11.5](#ch11ex05) 和 [11.6](#ch11ex06) 之间看到一些关键的区别。与 SVG 不同，在 SVG 中你可以移动元素并重新绘制它们，你总是需要清除并重新绘制画布来更新它。尽管这似乎会慢一些，但在所有浏览器上性能都有所提高，尤其是在那些
    SVG 性能不是最好的浏览器上，因为你不需要管理数百或数千个 DOM 元素。如图 11.6 所示的图形结果表明，SVG 和画布渲染之间的区别很难看出。
- en: Figure 11.6\. Drawing our map with canvas produces higher performance, but slightly
    less crisp graphics. On the left, it may seem like the triangles are as smoothly
    rendered as the earlier SVG triangles, but if you zoom in as we’ve done on the
    right, you can start to see clearly the slightly pixelated canvas rendering.
  id: totrans-559
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 11.6\. 使用画布绘制我们的地图会产生更高的性能，但图形的清晰度略低。在左侧，可能看起来三角形的渲染与早期的 SVG 三角形一样平滑，但如果你像右侧那样放大，就可以清楚地看到画布渲染的像素化。
- en: '![](../Images/11fig06_alt.jpg)'
  id: totrans-560
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/11fig06_alt.jpg)'
- en: 11.2.3\. Mixed mode rendering techniques
  id: totrans-561
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.2.3\. 混合模式渲染技术
- en: The drawback with using canvas is that you can’t easily provide the level of
    interactivity you may want for your data visualization. Typically, you draw your
    interactive elements with SVG and your large datasets with canvas. If we assume
    that the countries we’re drawing aren’t going to provide any interactivity, but
    the triangles will, we can render the triangles as SVG and render the countries
    as canvas using the code in [listing 11.8](#ch11ex08). Combining these two methods
    of drawing means we need to create a layer cake of elements in our DOM, like you
    see in [figure 11.7](#ch11fig07).
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 使用画布的缺点是，你无法轻松提供你可能想要的数据可视化交互级别。通常，你使用 SVG 绘制交互元素，使用画布绘制大量数据集。如果我们假设我们绘制的国家不会提供任何交互性，但三角形会，我们可以将三角形作为
    SVG 渲染，将国家作为画布使用 [列表 11.8](#ch11ex08) 中的代码进行渲染。结合这两种绘图方法意味着我们需要在我们的 DOM 中创建一个元素层蛋糕，就像你在
    [图 11.7](#ch11fig07) 中看到的那样。
- en: Figure 11.7\. Placing interactive SVG elements below a `<canvas>` element requires
    that you set its `pointer-events` style to `none`, even if it has a transparent
    background, in order to register click events on the `<svg>` element underneath
    it.
  id: totrans-563
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 11.7\. 在 `<canvas>` 元素下方放置交互式 SVG 元素需要将它的 `pointer-events` 样式设置为 `none`，即使它有透明背景，以便在下面的
    `<svg>` 元素上注册点击事件。
- en: '![](../Images/11fig07_alt.jpg)'
  id: totrans-564
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/11fig07_alt.jpg)'
- en: This requires that we initialize two versions of `d3.geoPath`—one for drawing
    SVG and one for drawing canvas—and then we use both in our zoomed function. This
    is shown in [listing 11.8](#ch11ex08).
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 这要求我们初始化两个版本的`d3.geoPath`——一个用于绘制SVG，一个用于绘制canvas——然后在我们的缩放函数中使用这两个版本。这如图列表11.8所示。
- en: Listing 11.8\. Rendering SVG and canvas simultaneously
  id: totrans-566
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表11.8\. 同时渲染SVG和canvas
- en: '[PRE56]'
  id: totrans-567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '***1* We need to instantiate a different d3.geoPath for canvas and for SVG**'
  id: totrans-568
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 我们需要为canvas和SVG实例化不同的d3.geoPath**'
- en: '***2* Draws canvas features with canvasPath**'
  id: totrans-569
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 使用canvasPath绘制canvas特性**'
- en: '***3* Draws SVG features with svgPath**'
  id: totrans-570
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 使用svgPath绘制SVG特性**'
- en: This allows us to maintain interactivity, such as the mouseover function on
    our triangles to change any triangle’s color to pink when moused over. This approach
    maximizes performance by rendering any graphics that have no interactivity using
    canvas drawing instead of SVG. As shown in [figure 11.8](#ch11fig08), the appearance
    produced using this method is virtually identical to that using canvas only or
    SVG only.
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许我们保持交互性，例如在三角形上实现鼠标悬停功能，当鼠标悬停时将任何三角形的颜色变为粉色。这种方法通过使用canvas绘制而不是SVG来渲染没有交互性的图形，从而最大化性能。如图11.8所示，使用这种方法产生的外观几乎与仅使用canvas或仅使用SVG的方法相同。
- en: Figure 11.8\. Background countries are drawn with canvas, while foreground triangles
    are drawn with SVG to use interactivity. SVG graphics are individual elements
    in the DOM and are therefore amenable to having click, mouseover, and other event
    listeners attached to them.
  id: totrans-572
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图11.8\. 背景国家使用canvas绘制，而前景三角形使用SVG绘制以实现交互性。SVG图形是DOM中的独立元素，因此可以附加点击、鼠标悬停和其他事件监听器。
- en: '![](../Images/11fig08_alt.jpg)'
  id: totrans-573
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/11fig08_alt.jpg)'
- en: But what if you have massive numbers of elements and you do want interactivity
    on all of them, but you also want to give the user the ability to pan and drag?
    In that case, you have to embrace an extension of this mixed mode rendering. You
    render in canvas whenever users are interacting in such a way that they can’t
    interact with other elements—we need to render the triangles in canvas when the
    map is being zoomed and panned, but render them in SVG when the map isn’t in motion
    and the user is mousing over certain elements.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你有大量的元素，并且你确实希望所有元素都具有交互性，同时你还想给用户提供平移和拖动的功能呢？在这种情况下，你必须接受这种混合模式渲染的扩展。当用户以这种方式交互，以至于他们无法与其他元素交互时，我们在canvas中渲染——当我们缩放和拖动地图时，我们需要在canvas中渲染三角形，但在地图不移动且用户正在悬停在某些元素上时，我们则在SVG中渲染它们。
- en: We can manage this by taking advantage of the `start` and `end` events from
    `d3.zoom`. These fire, as you may guess, when the zoom event begins and ends,
    respectively. The following listing shows how you’d initialize a zoom behavior
    with different functions for these different events.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过利用`d3.zoom`的`start`和`end`事件来管理这一点。正如你可能猜到的，这些事件分别在缩放事件开始和结束时触发。以下列表显示了如何为这些不同的事件初始化具有不同功能的缩放行为。
- en: Listing 11.9\. Mixed rendering based on zoom interaction
  id: totrans-576
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表11.9\. 基于缩放交互的混合渲染
- en: '[PRE57]'
  id: totrans-577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '***1* Assigns separate functions for each zoom state**'
  id: totrans-578
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 为每个缩放状态分配单独的功能**'
- en: This allows us to restore our canvas drawing code for triangles to the `zoomed`
    function and move the SVG rendering code out of the `zoomed` function and into
    a new `zoomFinished` function. We also need to hide the SVG triangles when zooming
    or panning starts by creating a `zoomInitialized` function that itself also fires
    the `zoomed` function (to draw the triangles we hid, but in canvas). Finally,
    our `zoomFinished` function also contains the canvas drawing code necessary to
    only draw the countries. The different drawing strategies based on `zoom` events
    are shown in [table 11.1](#ch11table01).
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许我们将三角形的canvas绘制代码恢复到`zoomed`函数中，并将SVG渲染代码从`zoomed`函数中移出，放入一个新的`zoomFinished`函数中。我们还需要通过创建一个`zoomInitialized`函数来隐藏SVG三角形，该函数本身也会触发`zoomed`函数（绘制我们隐藏的三角形，但在canvas中）。最后，我们的`zoomFinished`函数还包含仅绘制国家的必要的canvas绘制代码。基于`zoom`事件的不同的绘制策略在表11.1中显示。
- en: Table 11.1\. Rendering action based on `zoom` event
  id: totrans-580
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表11.1\. 基于`zoom`事件的渲染动作
- en: '| Zoom event | Countries rendered as | Triangles rendered as |'
  id: totrans-581
  prefs: []
  type: TYPE_TB
  zh: '| 缩放事件 | 绘制的国家 | 绘制的三角形 |'
- en: '| --- | --- | --- |'
  id: totrans-582
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| zoomed | Canvas | Canvas |'
  id: totrans-583
  prefs: []
  type: TYPE_TB
  zh: '| zoomed | Canvas | Canvas |'
- en: '| zoomInitialized | Canvas | Hide SVG |'
  id: totrans-584
  prefs: []
  type: TYPE_TB
  zh: '| zoomInitialized | Canvas | 隐藏SVG |'
- en: '| zoomFinished | Canvas | SVG |'
  id: totrans-585
  prefs: []
  type: TYPE_TB
  zh: '| zoomFinished | Canvas | SVG |'
- en: As you can see in the following listing, this code is inefficient because there’s
    shared functionality between the zoom events that could be put in separate functions.
    But I wanted to be explicit about this functionality, because it’s a bit convoluted.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下列表所示，此代码效率不高，因为缩放事件之间存在共享功能，可以放入单独的函数中。但我希望明确此功能，因为它有点复杂。
- en: Listing 11.10\. Zoom functions for mixed rendering
  id: totrans-587
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 11.10\. 混合渲染的缩放函数
- en: '[PRE58]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '***1* Draws all elements as canvas during zooming**'
  id: totrans-589
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 在缩放期间将所有元素绘制为 canvas**'
- en: '***2* Hides SVG elements when zooming starts**'
  id: totrans-590
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 在缩放开始时隐藏 SVG 元素**'
- en: '***3* Calls zoomed to draw with canvas the SVG triangles we hid**'
  id: totrans-591
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 在缩放时调用以 canvas 绘制我们隐藏的 SVG 三角形**'
- en: '***4* Only draws countries with canvas at the end of the zoom**'
  id: totrans-592
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 只在缩放结束时用 canvas 绘制国家**'
- en: '***5* Shows SVG elements when zoom ends**'
  id: totrans-593
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 显示缩放结束时 SVG 元素**'
- en: '***6* Sets the new position of SVG elements**'
  id: totrans-594
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6* 设置 SVG 元素的新位置**'
- en: As a result of this new code, we have a map that uses canvas rendering when
    users zoom and pan, but SVG rendering when the map is fixed in place and users
    have the ability to click, mouse over, or otherwise interact with the graphical
    elements. It’s the best of both worlds. The only drawback of this approach is
    that we have to invest more time making sure our `<canvas>` element and our `<svg>`
    element line up perfectly, and that our opacity, fill colors, and so on are close
    enough matches that it’s not jarring to the user to see the different modes. I
    haven’t done this in the previous code, so that you can see that the two modes
    are in operation at the same time, and that’s reflected in the difference between
    the two graphical outputs in [figure 11.9](#ch11fig09).
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这段新代码，我们得到了一个地图，当用户缩放和平移时使用 canvas 渲染，但当地图固定在位置且用户能够点击、鼠标悬停或以其他方式与图形元素交互时使用
    SVG 渲染。这是两者的最佳结合。这种方法唯一的缺点是我们必须投入更多时间确保我们的 `<canvas>` 元素和 `<svg>` 元素完美对齐，并且我们的不透明度、填充颜色等足够接近，这样用户看到不同的模式时不会感到震惊。我之前没有这样做，这样你可以看到两种模式同时运行，这在
    [图 11.9](#ch11fig09) 中的两个图形输出差异中得到了反映。
- en: Figure 11.9\. The same randomly generated triangles rendered in SVG while the
    map isn’t being zoomed or panned (left) and in canvas while the map is being zoomed
    or panned (right). Notice that only the SVG triangles have different fill values
    based on user interaction, because that isn’t factored into the canvas drawing
    code for the triangles on the right.
  id: totrans-596
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 11.9\. 当地图未进行缩放或平移时以 SVG 渲染的随机生成的三角形（左）和当地图进行缩放或平移时以 canvas 渲染的三角形（右）。请注意，只有
    SVG 三角形根据用户交互具有不同的填充值，因为这不是右边的三角形绘制代码的考虑因素。
- en: '![](../Images/11fig09_alt.jpg)'
  id: totrans-597
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/11fig09_alt.jpg)'
- en: You’ll need to take the time to make sure it has pixel-perfect alignment—otherwise
    your users will notice and complain. And make sure you test it in every browser
    that you expect to support because there tend to be different assumptions of what
    default behavior should be for `<canvas>` or `<svg>` elements.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要花时间确保它具有像素级的对齐——否则你的用户会注意到并抱怨。并且确保你在你期望支持的每个浏览器中测试它，因为对于 `<canvas>` 或 `<svg>`
    元素的默认行为，往往有不同的假设。
- en: Finally, using canvas and SVG drawing simultaneously may present a difficulty.
    Say we want to draw a canvas layer over an SVG layer because we want the canvas
    layer to appear above *some* of our SVG elements visually but below other SVG
    elements, and we want interactivity on all of them. In that case we’d need to
    sandwich our canvas layer between our SVG layers and set the `pointer-events`
    style of our canvas layer, as shown back in [figure 11.7](#ch11fig07). If you
    add further alternating layers of interactivity but with graphical placement above
    and below, then you can end up making a `<canvas>` and `<svg>` layer cake in your
    DOM that can be as hard to manage as it is to conceptualize.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，同时使用 canvas 和 SVG 绘图可能会遇到困难。比如说，我们想在 SVG 层上绘制 canvas 层，因为我们想让 canvas 层在视觉上位于某些
    SVG 元素之上，但位于其他 SVG 元素之下，并且我们希望所有元素都具有交互性。在这种情况下，我们需要在我们的 SVG 层之间放置我们的 canvas 层，并设置
    canvas 层的 `pointer-events` 样式，如图 11.7 中所示。如果你添加了进一步的交替交互层，但图形位置在上方和下方，那么你最终可能会在你的
    DOM 中制作一个 `<canvas>` 和 `<svg>` 层蛋糕，这可能和概念化一样难以管理。
- en: 11.3\. Big network data
  id: totrans-600
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.3\. 大型网络数据
- en: It’s great that `d3.geoPath` has built-in functionality for drawing geodata
    to canvas, and it’s great that d3-shape generators do, too, but what about types
    of data visualization that use geometric primitives like lines, circles, and rectangles?
    One of the most performance-intensive layouts is the force-directed layout we
    dealt with in [chapter 6](../Text/kindle_split_016.html#ch06). The layout calculates
    new positions for each node in your network at every tick. When I first started
    working with force-directed layouts in D3, I found that any network with more
    than 100 nodes was too slow to prove useful. Since then, browser performance has
    improved, and even thousand-node networks with SVG are performant. But it’s still
    a problem when we have larger networks with structure that would benefit from
    interactivity and animation.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 很棒的是，`d3.geoPath` 为绘制地理数据到画布提供了内置功能，同样，d3-shape 生成器也是如此，但对于使用线条、圆形和矩形等几何原型的数据可视化类型又如何呢？我们处理过的最性能密集的布局之一是第
    6 章中提到的力导向布局。布局会在每次迭代时为网络中的每个节点计算新的位置。当我最初开始使用 D3 中的力导向布局时，我发现任何超过 100 个节点的网络都太慢，无法证明其有用性。从那时起，浏览器的性能得到了提升，即使是拥有千个节点的网络使用
    SVG 也能表现出良好的性能。但当我们的网络更大，且结构能够从交互和动画中受益时，这仍然是一个问题。
- en: In my own work, I’ve looked at how different small D3 applications hosted on
    [gist.github.com](http://gist.github.com) share common D3 functions. D3 coders
    can understand how different information visualization methods use D3 functions
    commonly associated with other types of information visualization. You can explore
    this network along with how D3 Meetup users describe themselves at [http://emeeks.github.io/introspect/block_block.html](http://emeeks.github.io/introspect/block_block.html).
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的工作中，我研究了不同的小型 D3 应用程序如何在 [gist.github.com](http://gist.github.com) 上共享常见的
    D3 函数。D3 编码者可以了解不同的信息可视化方法如何使用与其它类型信息可视化相关联的 D3 函数。您可以通过 [http://emeeks.github.io/introspect/block_block.html](http://emeeks.github.io/introspect/block_block.html)
    探索这个网络，以及 D3 Meetup 用户如何描述自己。
- en: To explore these connections, I needed a method for dealing with over a thousand
    different examples and thousands of connections between them. You can see part
    of this network in [figure 11.10](#ch11fig10). I wanted to show how this network
    changed based on a threshold of shared functions, and I also wanted to provide
    users with the capacity to click each example to get more details, so I couldn’t
    draw the network using canvas. Instead, I needed to draw the network using the
    same mixed-rendering method we looked at to draw all those triangles on a map.
    In this case I used canvas for the network edges and SVG for the network nodes
    because, as I note later, the rendering of the network links as SVG elements is
    the most expensive part of a force-directed network visualization.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 为了探索这些联系，我需要一个方法来处理超过一千个不同的示例以及它们之间成千上万的连接。您可以在 [图 11.10](#ch11fig10) 中看到这个网络的一部分。我想展示这个网络如何根据共享函数的阈值而变化，我还想为用户提供点击每个示例以获取更多细节的能力，因此我无法使用画布来绘制网络。相反，我需要使用我们之前用来在地图上绘制所有那些三角形的相同混合渲染方法来绘制网络。在这种情况下，我使用了画布来绘制网络边，SVG
    来绘制网络节点，因为，正如我稍后所提到的，将网络链接作为 SVG 元素进行渲染是力导向网络可视化中最昂贵的部分。
- en: 'Figure 11.10\. A network of D3 examples hosted on [gist.github.com](http://gist.github.com)
    that connects different examples to each other by shared functions. Here you can
    see that the example “Bivariate Hexbin Map” by Mike Bostock ([http://bl.ocks.org/mbostock/4330486](http://bl.ocks.org/mbostock/4330486))
    shares functions in common with three different examples: Metropolitan Unemployment,
    Marey’s Trains II, and GitHub Users Worldwide. The brush and axis components allow
    you to filter the network by the number of connections from one block to another.'
  id: totrans-604
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 11.10\. 在 [gist.github.com](http://gist.github.com) 上托管的不同示例的网络，通过共享函数将不同的示例连接起来。在这里，您可以看到
    Mike Bostock 的示例“二元六边形地图”([http://bl.ocks.org/mbostock/4330486](http://bl.ocks.org/mbostock/4330486))与三个不同的示例共享了函数：都市失业、Marey
    的火车 II 和全球 GitHub 用户。画笔和坐标轴组件允许您通过从一个区块到另一个区块的连接数量来过滤网络。
- en: '![](../Images/11fig10.jpg)'
  id: totrans-605
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/11fig10.jpg)'
- en: '|  |'
  id: totrans-606
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Using bl.ocks.org**'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用 bl.ocks.org**'
- en: Although D3 is suitable for building large, complex interactive applications,
    you often make a small, single-use interactive data visualization that can live
    on a single page with limited resources. For these small applications, it’s common
    in the D3 community to host the code on [gist.github.com](http://gist.github.com),
    which is the part of GitHub designed for small applications. If you host your
    D3 code as a gist, and it’s formatted to have an index.html, then you can use
    bl.ocks.org to share your work with others.
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然D3适合构建大型、复杂的交互式应用程序，但你通常制作一个小型、单次使用的交互式数据可视化，它可以存在于单个页面上的有限资源中。对于这些小型应用程序，在D3社区中通常在[gist.github.com](http://gist.github.com)上托管代码，这是GitHub为小型应用程序设计的部分。如果你将D3代码作为gist托管，并且格式化为具有index.html，那么你可以使用bl.ocks.org与他人分享你的作品。
- en: To make your gist work on bl.ocks.org, you need to have the data files and libraries
    hosted in the gist or accessible through it. Then you can take the alphanumeric
    identifier of your gist and append it to bl.ocks.org/username/ to serve a working
    copy for sharing. For instance, I have a gist at [https://gist.github.com/emeeks/0a4d7cd56e027023bf78](https://gist.github.com/emeeks/0a4d7cd56e027023bf78)
    that demonstrates how to do the mixed rendering of a force-directed layout like
    I described in this chapter. As a result, I can point people to [http://bl.ocks.org/emeeks/0a4d7cd56e027023bf78](http://bl.ocks.org/emeeks/0a4d7cd56e027023bf78),
    and they can see the code itself as well as the animated network in action.
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 要使你的gist在bl.ocks.org上工作，你需要将数据文件和库托管在gist中或通过它访问。然后你可以将gist的字母数字标识符附加到bl.ocks.org/username/，以提供用于共享的工作副本。例如，我有一个在[https://gist.github.com/emeeks/0a4d7cd56e027023bf78](https://gist.github.com/emeeks/0a4d7cd56e027023bf78)的gist，展示了如何进行像我在这章中描述的力导向布局的混合渲染。因此，我可以将人们指向[http://bl.ocks.org/emeeks/0a4d7cd56e027023bf78](http://bl.ocks.org/emeeks/0a4d7cd56e027023bf78)，他们可以看到代码本身以及动画网络的实际运行情况。
- en: '|  |'
  id: totrans-610
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Doing this kind of mixed rendering with networks isn’t as easy as it is with
    maps. That’s because there’s no built-in method to render regular data to canvas
    as with `d3.geoPath`. If you want to create a similar large network that combines
    canvas and SVG rendering, you have to build the function manually. First, though,
    you need data. This time, instead of sample geodata, we need to create sample
    network data.
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络中进行这种混合渲染并不像在地图中那样简单。这是因为没有内置方法将常规数据渲染到画布上，就像`d3.geoPath`那样。如果你想创建一个结合画布和SVG渲染的类似大型网络，你必须手动构建函数。不过，首先你需要数据。这次，我们不是创建样本地理数据，而是需要创建样本网络数据。
- en: 'Building sample network data is easy: you can create an array of nodes and
    an array of random links between those nodes. But building a sample network that’s
    not an undifferentiated mass is a little harder. In [listing 11.11](#ch11ex11)
    you can see my slightly sophisticated network generator. It operates on the principle
    that a few nodes are popular and most nodes aren’t (we’ve known about this principle
    of networks since grade school). This does a decent job of creating a network
    with 3,000 nodes and 1,000 edges that doesn’t look quite like a giant hairball.'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 构建样本网络数据很容易：你可以创建一个节点数组以及这些节点之间的随机链接数组。但构建一个不是无差别的质量样本网络就有点难了。在[列表11.11](#ch11ex11)中，你可以看到我稍微复杂的网络生成器。它基于这样一个原则：少数节点是热门的，而大多数节点不是（我们从小学开始就知道了这个网络原则）。这可以很好地创建一个包含3,000个节点和1,000条边的网络，看起来并不像一个大型的毛线球。
- en: Listing 11.11\. Generating random network data
  id: totrans-613
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表11.11\. 生成随机网络数据
- en: '[PRE59]'
  id: totrans-614
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '***1* This scale makes 90% of the links to 1% of the nodes**'
  id: totrans-615
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 这个比例使90%的链接指向1%的节点**'
- en: '***2* The source of each link is purely random**'
  id: totrans-616
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 每个链接的源是纯随机的**'
- en: '***3* The target is weighted toward popular nodes**'
  id: totrans-617
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 目标倾向于热门节点**'
- en: '***4* Don’t keep any links that have the same source as target**'
  id: totrans-618
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 不要保留任何具有相同源和目标的链接**'
- en: With this generator in place, we can instantiate our typical force-directed
    layout using the code in the following listing and create a few lines and circles
    with it.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个生成器，我们可以使用以下列表中的代码实例化我们的典型力导向布局，并用它创建一些线条和圆圈。
- en: Listing 11.12\. Force-directed layout
  id: totrans-620
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表11.12\. 力导向布局
- en: '[PRE60]'
  id: totrans-621
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '***1* This is all vanilla force-directed layout code like in [chapter 6](../Text/kindle_split_016.html#ch06)**'
  id: totrans-622
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 这完全是像第6章（[chapter 6](../Text/kindle_split_016.html#ch06)）中的力导向布局代码**'
- en: '***2* For our initial implementation, we render everything in SVG and update
    the SVG on every tick**'
  id: totrans-623
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 对于我们的初始实现，我们在每个tick时在SVG中渲染一切并更新SVG**'
- en: This code should be familiar to you if you’ve read [chapter 6](../Text/kindle_split_016.html#ch06).
    Generation of random networks is a complex and well-described practice. This random
    generator isn’t going to win any awards, but it does produce a recognizable structure.
    Typical results are shown in [figure 11.11](#ch11fig11). What’s lost in the static
    image is the slow and jerky rendering, even on a fast computer using a browser
    that handles SVG well.
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您阅读过[第6章](../Text/kindle_split_016.html#ch06)，这段代码应该对您来说很熟悉。随机网络的生成是一个复杂且描述良好的实践。这个随机生成器可能不会赢得任何奖项，但它确实产生了一个可识别的结构。典型的结果如图[图11.11](#ch11fig11)所示。在静态图像中丢失的是缓慢且不流畅的渲染，即使在快速计算机上使用处理SVG良好的浏览器也是如此。
- en: Figure 11.11\. A randomly generated network with 3,000 nodes and 1,000 edges
  id: totrans-625
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图11.11\. 一个包含3,000个节点和1,000条边的随机生成网络
- en: '![](../Images/11fig11.jpg)'
  id: totrans-626
  prefs: []
  type: TYPE_IMG
  zh: '![图片11fig11](../Images/11fig11.jpg)'
- en: When I first started working with these networks, I thought the main cause of
    slowdown was calculating the myriad positions for each node on every tick. After
    all, node position is based on a simulation of competing forces caused by nodes
    pushing and edges pulling, and something like this, with thousands of components,
    seems heavy duty. That’s not what’s taxing the browser in this case, though. Instead,
    it’s the management of so many DOM elements. You can get rid of many of those
    DOM elements by replacing the SVG lines with canvas lines. Let’s change our code
    as shown in the following listing so that it doesn’t create any SVG `<line>` elements
    for the links and instead modify our `forceTick` function to draw those links
    with canvas.
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 当我开始与这些网络一起工作时，我认为导致减速的主要原因是计算每个节点在每个tick上的无数位置。毕竟，节点位置是基于由节点推力和边拉力引起的竞争力模拟，而且像这样有数千个组件的东西似乎很重。但这并不是在这种情况下消耗浏览器资源的原因。相反，是这么多DOM元素的管理。您可以通过用画布线条替换SVG线条来消除许多这些DOM元素。让我们按照以下列表更改我们的代码，以便它不会为链接创建任何SVG
    `<line>`元素，而是修改我们的`forceTick`函数，用画布绘制这些链接。
- en: Listing 11.13\. Mixed rendering network drawing
  id: totrans-628
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表11.13\. 混合渲染网络绘制
- en: '[PRE61]'
  id: totrans-629
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '***1* Remember, you always need to clear your canvas**'
  id: totrans-630
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 记住，您始终需要清除您的画布**'
- en: '***2* Draws links as 50% transparent black**'
  id: totrans-631
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 以50%透明度的黑色绘制链接**'
- en: '***3* Starts each line at the link source coordinates**'
  id: totrans-632
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 从链接源坐标开始每行**'
- en: '***4* Draws each link to the link target coordinates**'
  id: totrans-633
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 将每条链接绘制到链接目标坐标**'
- en: '***5* Draws nodes as SVG**'
  id: totrans-634
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 以SVG绘制节点**'
- en: The rendering of the network is similar in appearance, as you can see in [figure
    11.12](#ch11fig12), but the performance improves dramatically. Using canvas, I
    can draw 10,000-link networks with performance high enough to have animation and
    interactivity. The canvas drawing code can be a bit cumbersome (it’s like the
    old LOGO drawing code), but the performance makes it more than worth it.
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 网络的渲染在外观上相似，正如您可以在[图11.12](#ch11fig12)中看到的那样，但性能有了显著提升。使用画布，我可以绘制具有足够性能的10,000个链接的网络，足以实现动画和交互性。画布绘制代码可能有点繁琐（就像旧的LOGO绘制代码），但性能使得这一切都值得。
- en: Figure 11.12\. A large network drawn with SVG nodes and canvas links
  id: totrans-636
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图11.12\. 使用SVG节点和画布链接绘制的大型网络
- en: '![](../Images/11fig12.jpg)'
  id: totrans-637
  prefs: []
  type: TYPE_IMG
  zh: '![图片11fig12](../Images/11fig12.jpg)'
- en: 'We could use the same method as with the earlier maps to use canvas during
    animated periods and SVG when the network is fixed. But we’ll move on and look
    at another method for dealing with large amounts of data: quadtrees.'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用与早期地图相同的方法，在动画期间使用画布，在网络固定时使用SVG。但我们将继续前进，看看另一种处理大量数据的方法：四叉树。
- en: 11.4\. Optimizing xy data selection with quadtrees
  id: totrans-639
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.4\. 使用四叉树优化xy数据选择
- en: When you’re working with a large dataset, one issue is optimizing search and
    selection of elements in a region. Let’s say you’re working with a set of data
    with xy coordinates (anything that’s laid out on a plane or screen). You’ve seen
    enough examples in this book to know that this may be a scatterplot, points on
    a map, or any of a number of different graphical representations of data. When
    you have data like this, you often want to know what datapoints fall in a particular
    selected region. This is referred to as *spatial search* (and notice that *spatial*
    in this case doesn’t refer to geographic space but rather space in a more generic
    sense). The quadtree functionality is a spatial version of `d3.nest`, which we
    used in [chapters 5](../Text/kindle_split_014.html#ch05) and [8](../Text/kindle_split_018.html#ch08)
    to create hierarchical data. Following the theme of this chapter, we’ll get started
    by creating a big dataset of random points and render them in SVG.
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 当你处理大量数据集时，一个问题是如何优化区域内元素搜索和选择。假设你正在处理一组具有 xy 坐标的数据（任何在平面上或屏幕上布局的东西）。在这本书中你已经看到了足够的例子，知道这可能是散点图、地图上的点或数据的不同图形表示之一。当你有这种数据时，你通常想知道哪些数据点落在特定的选定区域内。这被称为
    *空间搜索*（注意，这里的 *空间* 并不指地理空间，而是一种更通用的空间）。四叉树功能是 `d3.nest` 的空间版本，我们在 [第 5 章](../Text/kindle_split_014.html#ch05)
    和 [第 8 章](../Text/kindle_split_018.html#ch08) 中使用它来创建层次化数据。遵循本章的主题，我们将从创建一个大量随机点的大数据集并使用
    SVG 渲染它们开始。
- en: 11.4.1\. Generating random xy data
  id: totrans-641
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.4.1\. 生成随机 xy 数据
- en: Our third random data generator doesn’t require nearly as much work as the first
    two did. In the following listing, all we do is create 3,000 points with random
    x and y coordinates.
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第三个随机数据生成器的工作量远不如前两个。在下面的列表中，我们只是创建了具有随机 x 和 y 坐标的 3,000 个点。
- en: Listing 11.14\. xy data generator
  id: totrans-643
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 11.14\. xy 数据生成器
- en: '[PRE62]'
  id: totrans-644
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '***1* Because we know the fixed size of our canvas, we can hardwire this**'
  id: totrans-645
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 因为我们知道画布的固定大小，我们可以直接连接这个**'
- en: As you may expect, the result of this code, shown in [figure 11.13](#ch11fig13),
    is a bunch of orange circles scattered randomly all over our canvas.
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所预期，这段代码的结果，如图 11.13 所示，是一堆橙色圆圈散布在我们的画布上。
- en: Figure 11.13\. 3,000 randomly placed points represented by orange SVG `<circle>`
    elements
  id: totrans-647
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 11.13\. 由橙色 SVG `<circle>` 元素表示的 3,000 个随机放置的点
- en: '![](../Images/11fig13.jpg)'
  id: totrans-648
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/11fig13.jpg)'
- en: 11.4.2\. xy brushing
  id: totrans-649
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.4.2\. xy 刷涂
- en: Now we’ll create a brush to select some of these points. Recall when we used
    a brush in [chapter 9](../Text/kindle_split_020.html#ch09) that we only allowed
    brushing along the x-axis. This time, we allow brushing along both x- and y-axes.
    Then we can drag a rectangle over any part of the canvas. In the following listing,
    you can see how quick and easy it is to add a brush to our canvas. We’ll also
    add a function to highlight any circles in the brushed region.
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将创建一个刷子来选择这些点中的一些。回想一下，在 [第 9 章](../Text/kindle_split_020.html#ch09) 中我们使用刷子时，我们只允许沿
    x 轴刷涂。这次，我们允许沿 x 轴和 y 轴刷涂。然后我们可以拖动一个矩形覆盖画布的任何部分。在下面的列表中，你可以看到将刷子添加到我们的画布是多么快速和简单。我们还将添加一个功能来突出显示刷涂区域中的任何圆圈。
- en: Listing 11.15\. xy brushing
  id: totrans-651
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 11.15\. xy 刷涂
- en: '[PRE63]'
  id: totrans-652
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '***1* This brush gives us XY capability**'
  id: totrans-653
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 这个刷子给我们 XY 功能**'
- en: '***2* Tests to see if the data is in our selected area**'
  id: totrans-654
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 检查数据是否在我们的选定区域内**'
- en: '***3* Colors the points in the selected**'
  id: totrans-655
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 将选定区域内的点着色**'
- en: '***4* Colors the points outside the selected**'
  id: totrans-656
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 将选定区域外的点着色**'
- en: With this brushing code, we can now see the circles in the brushed region, as
    shown in [figure 11.14](#ch11fig14).
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个刷涂代码，我们现在可以看到刷涂区域中的圆圈，如图 11.14 所示。
- en: Figure 11.14\. Highlighting points in a selected region
  id: totrans-658
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 11.14\. 在选定区域中突出显示点
- en: '![](../Images/11fig14.jpg)'
  id: totrans-659
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/11fig14.jpg)'
- en: This works, but it’s terribly inefficient. It checks every point on the canvas
    without using any mechanism to ignore points that might be well outside the selection
    area. Finding points within a prescribed area is an old problem that has been
    well explored. One of the tools available to solve that problem quickly and easily
    is a quadtree. You may ask, what is a quadtree and what should I use it for?
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 这方法可行，但效率极低。它检查画布上的每一个点，而没有使用任何机制来忽略可能完全在选定区域外的点。在指定区域内查找点是老问题，已经被充分研究。解决该问题快速且简单的一种工具是四叉树。你可能想知道，什么是四叉树，我应该用它来做什么？
- en: A *quadtree* is a method for optimizing spatial search by dividing a plane into
    a series of quadrants. You then divide each of those quadrants into quadrants,
    until every point on that plane falls in its own quadrant. By dividing the xy
    plane like this, you nest the points you’ll be searching in such a way that you
    can easily ignore entire quadrants of data without testing the entire dataset.
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: '*四叉树*是一种通过将平面划分为一系列象限来优化空间搜索的方法。然后你将每个象限再划分为象限，直到该平面上的每个点都落在自己的象限中。通过这样划分 xy
    平面，你可以将你将要搜索的点嵌套起来，这样你就可以轻松地忽略整个数据集的整个象限，而无需测试整个数据集。'
- en: Another way to explain a quadtree is to show it. That’s what this information
    visualization stuff is for, right? [Figure 11.15](#ch11fig15) shows the quadrants
    that a quadtree produces based on a set of point data.
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 解释四叉树的另一种方法就是展示它。这正是信息可视化存在的意义，对吧？[图 11.15](#ch11fig15) 展示了基于一组点数据四叉树产生的象限。
- en: Figure 11.15\. A quadtree for points shown in red with quadrant regions stroked
    in black. Notice how clusters of points correspond to subdivision of regions of
    the quadtree. Every point falls in only one region, but each region is nested
    in several levels of parent regions.
  id: totrans-663
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 11.15\. 以红色显示的点四叉树，象限区域以黑色勾勒。注意点簇如何对应四叉树区域的细分。每个点只落在一个区域内，但每个区域都嵌套在多个父区域级别中。
- en: '![](../Images/11fig15.jpg)'
  id: totrans-664
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/11fig15.jpg)'
- en: Creating a quadtree with xy data of the kind we have in our dataset is easy,
    as you can see in the following listing. We set the x and y accessors like we
    do with layouts and other D3 functions.
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 创建具有我们数据集中 xy 数据的四叉树很容易，如下列所示。我们设置 x 和 y 访问器，就像我们在布局和其他 D3 函数中做的那样。
- en: Listing 11.16\. Creating a quadtree from xy data
  id: totrans-666
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 11.16\. 从 xy 数据创建四叉树
- en: '[PRE64]'
  id: totrans-667
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '***1* We need to define the bounding box of a quadtree as an array of upper-left
    and lower-right points**'
  id: totrans-668
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 我们需要定义四叉树的边界框为一个包含上左和下右点的数组**'
- en: '***2* After creating a quadtree, we create the index by passing our dataset
    to it, along with the x and then y accessors**'
  id: totrans-669
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 在创建四叉树后，我们通过传递我们的数据集以及 x 和 y 访问器来创建索引**'
- en: After you create a quadtree and use it to create a quadtree index dataset like
    we did with `quadIndex`, you can use that dataset’s `.visit()` function for quadtree-optimized
    searching. The `.visit()` functionality replaces your test in a new brush function,
    as shown in [listing 11.17](#ch11ex17). First, I’ll show you how to make it work
    in [listing 11.17](#ch11ex17). Then I’ll show you that it *does* work in [figure
    11.16](#ch11fig16), and I’ll explain *how* it works in detail. This isn’t the
    usual order of things, I realize, but with a quadtree, it makes more sense if
    you see the code before analyzing its exact functionality.
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建四叉树并使用它创建四叉树索引数据集，例如我们用 `quadIndex` 做的那样之后，你可以使用该数据集的 `.visit()` 函数进行四叉树优化搜索。`.visit()`
    功能替换了你在新的刷选函数中的测试，如[列表 11.17](#ch11ex17)所示。首先，我会向你展示如何在[列表 11.17](#ch11ex17)中使其工作。然后我会向你展示它在[图
    11.16](#ch11fig16)中*确实*工作，并且我会详细解释它是如何工作的。我明白这不是通常的事情顺序，但就四叉树而言，在分析其确切功能之前先看到代码更有意义。
- en: Figure 11.16\. Quadtree-optimized selection used with a dataset of 10,000 points
  id: totrans-671
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 11.16\. 使用包含 10,000 个点的数据集进行四叉树优化选择
- en: '![](../Images/11fig16.jpg)'
  id: totrans-672
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/11fig16.jpg)'
- en: Listing 11.17\. Quadtree-optimized xy brush selection
  id: totrans-673
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 11.17\. 四叉树优化 xy 刷选
- en: '[PRE65]'
  id: totrans-674
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '***1* Sets all circles to the unselected color and gives each a selected attribute
    to designate that’s in our selection**'
  id: totrans-675
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1* 将所有圆设置为未选择颜色，并给每个圆分配一个选择属性以指定它在我们选择中**'
- en: '***2* Checks each node to see if it’s a point or a container**'
  id: totrans-676
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2* 检查每个节点以确定它是一个点还是一个容器**'
- en: '***3* Checks each point to see if it’s inside our brush extent and sets selected
    to true if it is**'
  id: totrans-677
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3* 检查每个点是否在我们的刷选范围内，如果是，则将选择设置为 true**'
- en: '***4* Checks to see if this area of the quadtree falls outside our selection**'
  id: totrans-678
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4* 检查这个四叉树区域是否超出我们的选择范围**'
- en: '***5* Shows which points were selected**'
  id: totrans-679
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5* 显示了哪些点被选中**'
- en: The results are impressive and much faster. In [figure 11.16](#ch11fig16), I
    increased the number of points to 10,000 and still got good performance. (But
    if you’re dealing with datasets that large, I recommend switching to canvas because
    forcing the browser to manage all those SVG elements is going to slow things down.)
    And even a cursory examination of the code reveals several spots where you could
    improve performance.
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 结果令人印象深刻，速度更快。在[图11.16](#ch11fig16)中，我将点的数量增加到10,000，仍然得到了良好的性能。(但如果你处理的是如此大的数据集，我建议切换到canvas，因为强迫浏览器管理所有这些SVG元素将会减慢速度。)而且，即使粗略地查看代码，也能发现几个可以改进性能的地方。
- en: How does it work? When you run the `visit` function, you get access to each
    node in the quadtree, from the most generalized to the more specific. With each
    node that we access in [listing 11.16](#ch11ex16) as `node`, you also get the
    bounds of that node (`x1`, `y1`, `x2`, `y2`). Because nodes in a quadtree can
    either be the bounding areas or the points that generated the quadtree, you have
    to test whether the node is a point—if it is, you can then test whether it’s in
    your brush bounds like we did in our earlier example. The final piece of the `visit`
    function is where it gets its power, but it’s also the most difficult to follow,
    as you can see in [figure 11.17](#ch11fig17).
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 它是如何工作的？当你运行`visit`函数时，你可以访问四叉树中的每个节点，从最一般化的到更具体的。在[列表11.16](#ch11ex16)中，我们访问的每个节点作为`node`，你也会得到该节点的边界(`x1`,
    `y1`, `x2`, `y2`)。因为四叉树中的节点可以是边界区域或生成四叉树的点，你必须测试节点是否是点——如果是，你可以像我们之前的例子那样测试它是否在你的刷选边界内。`visit`函数的最后一部分是其力量的来源，但也是最难理解的，正如你在[图11.17](#ch11fig17)中看到的。
- en: Figure 11.17\. The test to see whether a quadtree node is outside a brush selection
    involves four tests to see if it’s above, left, right, or below the selection
    area. If it passes `true` for any of these tests, the quadtree will stop searching
    any child nodes.
  id: totrans-682
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图11.17\. 检查四叉树节点是否在刷选区域外的测试涉及四个测试，以查看它是否在选区的上方、左侧、右侧或下方。如果这些测试中的任何一个返回`true`，四叉树将停止搜索任何子节点。
- en: '![](../Images/11fig17_alt.jpg)'
  id: totrans-683
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/11fig17_alt.jpg)'
- en: The `visit` function looks at every node in a quadtree—unless `visit` returns
    `true`, in which case it stops searching that quadrant and all its child nodes.
    Test to see whether the node you’re looking at (represented as the bounds `x1,y1,x2,y2`)
    is entirely outside the bounds of your selection area (represented as the bounds
    `e[0][0]`, `e[0][1]`, `e[1][0]`, `e[1][1]`). You create this test to see whether
    the top of the selection is below the bottom of the node’s bounds, whether the
    bottom of the selection is above the top of the node’s bounds, whether the left
    side of the selection is to the right of the right side of the node’s bounds,
    or whether the right side of the selection is to the left of the left side of
    the node’s bounds. That may seem a bit hard to follow (and sure takes up more
    room as a sentence than it does as a piece of code), but that’s how it works.
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: '`visit`函数检查四叉树中的每个节点——除非`visit`返回`true`，在这种情况下，它将停止搜索该象限及其所有子节点。测试你正在查看的节点（表示为边界`x1,y1,x2,y2`）是否完全在选区边界之外（表示为边界`e[0][0]`,
    `e[0][1]`, `e[1][0]`, `e[1][1]`）。你创建这个测试是为了查看选区的顶部是否在节点的边界底部下方，选区的底部是否在节点的边界顶部上方，选区的左侧是否在节点的边界右侧右边，或者选区的右侧是否在节点的边界左侧左边。这可能有点难以理解（而且作为一个句子比作为代码片段占用的空间要多），但这正是它的工作方式。'
- en: You can use that `visit` function to do more than optimized search. I’ve used
    it to cluster nearby points on a map ([http://bl.ocks.org/emeeks/066e20c1ce5008f884eb](http://bl.ocks.org/emeeks/066e20c1ce5008f884eb))
    and also to draw the bounds of the quadtree in [figure 11.15](#ch11fig15).
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用那个`visit`函数做更多的事情，不仅仅是优化搜索。我曾用它来在地图上聚类附近的点([http://bl.ocks.org/emeeks/066e20c1ce5008f884eb](http://bl.ocks.org/emeeks/066e20c1ce5008f884eb))，以及绘制[图11.15](#ch11fig15)中四叉树的边界。
- en: 11.5\. More optimization techniques
  id: totrans-686
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.5\. 更多优化技术
- en: 'You can improve the performance of the data visualization of large datasets
    in many other ways. Here are three that should give you immediate returns: avoid
    general opacity, avoid general selections, and precalculate positions.'
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过许多其他方式提高大型数据集数据可视化的性能。以下三种方法应该会立即带来回报：避免一般不透明度，避免一般选择，以及预先计算位置。
- en: 11.5.1\. Avoid general opacity
  id: totrans-688
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.5.1\. 避免一般不透明度
- en: 'Whenever possible, use fill-opacity and stroke-opacity or RGBA color references
    rather than the element opacity style. General element opacity—the kind of setting
    you get when you use `style: opacity`—can slow down rendering. When you use specific
    fill or stroke opacity, it forces you to pay more attention to where and how you’re
    using opacity.'
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: '在可能的情况下，使用fill-opacity和stroke-opacity或RGBA颜色引用，而不是元素的透明度样式。一般元素的透明度——当你使用`style:
    opacity`时得到的设置——可能会减慢渲染速度。当你使用特定的填充或描边透明度时，它会迫使你更加关注你使用透明度的位置和方式。'
- en: So instead of
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，而不是
- en: '[PRE66]'
  id: totrans-691
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'do this:'
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做：
- en: '[PRE67]'
  id: totrans-693
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 11.5.2\. Avoid general selections
  id: totrans-694
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.5.2. 避免通用选择
- en: 'Although it’s convenient to select all elements and apply conditional behavior
    across those elements, you should try to use `selection.filter` with your selections
    to reduce the number of calls to the DOM. If you look back at the code in [listing
    11.16](#ch11ex16), you’ll see this general selection that clears the selected
    attribute for all the circles and sets the fill of all the circles to orange:'
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然选择所有元素并在这些元素上应用条件行为很方便，但你应该尝试使用`selection.filter`与你的选择一起使用，以减少对DOM的调用次数。如果你回顾一下[列表11.16](#ch11ex16)中的代码，你会看到这种通用选择，它会清除所有圆的选中属性并将所有圆的填充色设置为橙色：
- en: '[PRE68]'
  id: totrans-696
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Instead, clear the attribute and set the fill color of only those circles that
    are currently set to the selection. This limits the number of costly DOM calls:'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，清除属性并仅设置当前设置为选择的那些圆的填充颜色。这限制了昂贵的DOM调用次数：
- en: '[PRE69]'
  id: totrans-698
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: If you adjust the code in that example, the performance is further improved.
    Remember that manipulating DOM elements, even if it’s changing a setting like
    `fill`, can cause the greatest performance hit.
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你调整那个示例中的代码，性能会进一步改善。记住，操作DOM元素，即使只是改变像`fill`这样的设置，也可能造成最大的性能损失。
- en: 11.5.3\. Precalculate positions
  id: totrans-700
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 11.5.3. 预计算位置
- en: You can also precalculate positions and then apply transitions. If you have
    a complex algorithm that determines an element’s new position, first go through
    the data array and calculate the new position. Then append the new position as
    data to the datapoint of the element. After you’ve done all your calculations,
    select and apply a transition based on the calculated new position. When you’re
    calculating complex new positions and applying those calculated positions to a
    transition of a large selection of elements, you can overwhelm the browser and
    see jerky animations.
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以预先计算位置，然后应用过渡。如果你有一个复杂的算法来确定元素的新位置，首先遍历数据数组并计算新位置。然后，将新位置作为数据附加到元素的data点上。在你完成所有计算后，根据计算的新位置选择并应用过渡。当你计算复杂的新位置并将这些计算位置应用到大量元素过渡时，可能会使浏览器过载并看到卡顿的动画。
- en: So, instead of
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，而不是
- en: '[PRE70]'
  id: totrans-703
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'do this:'
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做：
- en: '[PRE71]'
  id: totrans-705
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 11.6\. Summary
  id: totrans-706
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 11.6. 概述
- en: Generating the appropriate random data can be useful for prototyping and load-testing.
    *Random data* means different things for different types of charts, so geodata
    requires different techniques to produce than xy or network data.
  id: totrans-707
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成适当的随机数据对于原型设计和负载测试非常有用。*随机数据*对不同类型的图表有不同的含义，因此地理数据需要比xy或网络数据不同的技术来生成。
- en: Large datasets often require using canvas to render them to maintain performance.
    But if you want to maintain interactivity, you’ll need to pair an SVG layer with
    your canvas layer and deal with activating and deactivating them in your interaction
    functions.
  id: totrans-708
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大型数据集通常需要使用canvas来渲染以保持性能。但如果你想要保持交互性，你需要将SVG层与canvas层配对，并在你的交互函数中处理它们的激活和去激活。
- en: '`d3-shape` provides built-in canvas rendering functionality to draw your paths
    and arcs on canvas easily.'
  id: totrans-709
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`d3-shape`提供了内置的canvas渲染功能，可以轻松地在canvas上绘制路径和圆弧。'
- en: Extremely large datasets in xy space can be optimized by leveraging `d3-quadtree`.
  id: totrans-710
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在xy空间中，可以通过利用`d3-quadtree`来优化极大规模的数据集。
- en: D3’s `brush` function comes in different flavors depending on whether you want
    to brush vertically, horizontally, or both.
  id: totrans-711
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: D3的`brush`函数有不同的风味，取决于你想要垂直、水平还是两者都刷。
- en: 'If you want to grow your D3 skill set, I’d suggest starting with the D3 Slack
    channel ([d3js.slack.com](http://d3js.slack.com)), which has over a thousand members
    talking about every aspect of the library. I’d also look at bl.ocksplorer ([http://bl.ocksplorer.org](http://bl.ocksplorer.org)),
    which allows you to find examples of D3 code based on specific D3 functions. You
    should also check out the work of Mike Bostock ([http://bl.ocks.org/mbostock](http://bl.ocks.org/mbostock))
    to see examples of the latest D3 functionality. D3 has an active Google Group
    ([https://groups.google.com/forum/#!forum/d3-js](https://groups.google.com/forum/#!forum/d3-js)),
    if you’re interested in discussing the internals of the library, and there are
    many popular Meetup groups, like the Bay Area D3 User Group ([www.meetup.com/Bay-Area-d3-User-Group/](http://www.meetup.com/Bay-Area-d3-User-Group/)).
    I find the best place to keep up with D3 is on Twitter, where you can see examples
    posted with the hashtag #d3js and examples of when things don’t quite go right
    (but are still beautiful) with the hashtag #d3brokeandmadeart.'
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要提升你的D3技能集，我建议从D3 Slack频道（[d3js.slack.com](http://d3js.slack.com)）开始，这个频道有超过一千名成员在讨论库的各个方面。我还建议查看bl.ocksplorer（[http://bl.ocksplorer.org](http://bl.ocksplorer.org)），它允许你根据特定的D3函数找到D3代码的示例。你也应该看看迈克·博斯托克（[http://bl.ocks.org/mbostock](http://bl.ocks.org/mbostock)）的作品，以了解最新的D3功能示例。D3有一个活跃的Google
    Group（[https://groups.google.com/forum/#!forum/d3-js](https://groups.google.com/forum/#!forum/d3-js)），如果你对讨论库的内部感兴趣，还有许多流行的Meetup小组，如湾区D3用户组（[www.meetup.com/Bay-Area-d3-User-Group/](http://www.meetup.com/Bay-Area-d3-User-Group/)）。我发现跟踪D3的最佳地方是Twitter，在那里你可以看到带有#d3js标签的示例，以及带有#d3brokeandmadeart标签的示例，展示了事情并不完全按预期进行（但仍然很美）。
- en: 'As you look around the examples of D3, you’ll see one thing in particular:
    that despite spending so much time and ink on this library, I still haven’t touched
    on everything in its core functionality, much less the numerous plugins people
    have used to build on it. Data visualization is one of the most exciting fields
    right now, and you can be part of pushing that field forward, even if you’re only
    now getting into it. Though there are other ways to approach data visualization,
    D3 is still the most robust and well established. I hope this book has provided
    you with the tools necessary to go out and make impactful data visualization.'
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 当你浏览D3的示例时，你会注意到一个特别之处：尽管我已经在这个库上花费了大量的时间和精力，但我仍未触及到其核心功能的方方面面，更不用说人们用来构建在其之上的众多插件了。数据可视化是目前最激动人心的领域之一，即使你现在才刚刚涉足这个领域，你也可以成为推动该领域向前发展的一部分。尽管有其他方法可以接近数据可视化，但D3仍然是功能最强大且最成熟的。我希望这本书已经为你提供了走出并制作有影响力的数据可视化的必要工具。
- en: D3 in the real world
  id: totrans-714
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: D3在现实世界中的应用
- en: Christophe Viau
  id: totrans-715
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 克里斯托夫·维亚
- en: '*Progressive Rendering*'
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: '*渐进式渲染*'
- en: 'Rendering data on a large canvas can take some time and noticeably freeze the
    UI until it’s done. One trick to free the UI is called *progressive rendering*:
    chunking the rendering in small batches, giving the thread back to the UI between
    each batch. For the streaming charts I developed for Boundary’s Firespray and
    raster maps at Planet OS maps, I use a tool called Render-slicer, which uses `requestAnimationFrame`
    for slicing in a loop as fast as the browser can handle. On a slow network or
    on a large dataset, the browser is still free, but we can see the drawing happening.
    I don’t mind—it even looks like an animation feature.'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 在大画布上渲染数据可能需要一些时间，并且直到完成时都会明显冻结UI。一个让UI释放的方法被称为*渐进式渲染*：将渲染分成小批量，在每个批量之间将线程交还给UI。对于我为Boundary的Firespray和Planet
    OS地图的栅格地图开发的流式图表，我使用了一个名为Render-slicer的工具，它使用`requestAnimationFrame`循环切片，以浏览器能处理的最快速度进行。在慢速网络或大数据集上，浏览器仍然是自由的，但我们仍然可以看到绘图过程。我不介意——这甚至看起来像是一个动画功能。
- en: '![](../Images/360fig01_alt.jpg)'
  id: totrans-718
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/360fig01_alt.jpg)'
- en: '![](../Images/360fig02.jpg)'
  id: totrans-719
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/360fig02.jpg)'
- en: The same effect can be done by chunking data transfer, streaming the data instead
    of locking the UI with a large request, and drawing each chunk on the canvas line
    by line on reception. That way, the chart can start rendering the most important
    data points almost instantly, and the data chunk can be discarded to free up memory
    as soon as it’s graphed. I like Papa Parse for streaming and parsing data, which
    can also use Web Workers for even greater performance.
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 通过分块数据传输，以流式传输数据而不是用大请求锁定UI，并在接收时逐行在画布上绘制每个块，可以实现相同的效果。这样，图表可以几乎立即开始渲染最重要的数据点，并且数据块可以在绘图后立即丢弃以释放内存。我喜欢使用Papa
    Parse进行流式传输和解析数据，它还可以使用Web Workers以获得更好的性能。
