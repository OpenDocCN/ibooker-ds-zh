- en: Chapter 5\. Centrality Algorithms
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章\. 中心性算法
- en: Centrality algorithms are used to understand the roles of particular nodes in
    a graph and their impact on that network. They’re useful because they identify
    the most important nodes and help us understand group dynamics such as credibility,
    accessibility, the speed at which things spread, and bridges between groups. Although
    many of these algorithms were invented for social network analysis, they have
    since found uses in a variety of industries and fields.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 中心性算法用于理解图中特定节点的角色及其对网络的影响。它们非常有用，因为它们能够识别最重要的节点，并帮助我们理解组的动态，如可信度、可访问性、事物传播速度和组之间的桥梁。尽管许多这些算法最初是为社交网络分析而发明的，但它们已经在各种行业和领域中找到了用途。
- en: 'We’ll cover the following algorithms:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论以下算法：
- en: Degree Centrality as a baseline metric of connectedness
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 度中心性作为连接度的基准度量
- en: Closeness Centrality for measuring how central a node is to the group, including
    two variations for disconnected groups
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于测量节点对组的中心性的接近中心性，包括两个断开组的变体
- en: Betweenness Centrality for finding control points, including an alternative
    for approximation
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过查找控制点来寻找介数中心性，包括近似的替代方法
- en: PageRank for understanding the overall influence, including a popular option
    for personalization
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于理解整体影响的PageRank，包括个性化的流行选项
- en: Tip
  id: totrans-7
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Different centrality algorithms can produce significantly different results
    based on what they were created to measure. When you see suboptimal answers, it’s
    best to check the algorithm you’ve used is aligned to its intended purpose.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的中心性算法根据其被创建的目的可以产生显著不同的结果。当您看到次优答案时，最好检查您使用的算法是否与其预期目的一致。
- en: We’ll explain how these algorithms work and show examples in Spark and Neo4j.
    Where an algorithm is unavailable on one platform or where the differences are
    unimportant, we’ll provide just one platform example.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将解释这些算法的工作原理，并在Spark和Neo4j中展示示例。如果一个平台上无法使用某个算法，或者差异不重要，我们将提供一个平台的示例。
- en: '[Figure 5-1](#centrality-overview-image) shows the differences between the
    types of questions centrality algorithms can answer, and [Table 5-1](#centrality-overview-table)
    is a quick reference for what each algorithm calculates with an example use.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5-1](#centrality-overview-image)展示了中心性算法可以回答的问题类型之间的区别，而[表 5-1](#centrality-overview-table)则是每种算法计算及其示例用途的快速参考。'
- en: '![gral 0501](Images/gral_0501.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![gral 0501](Images/gral_0501.png)'
- en: Figure 5-1\. Representative centrality algorithms and the types of questions
    they answer
  id: totrans-12
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5-1\. 代表性中心性算法及其所回答的问题类型
- en: Table 5-1\. Overview of centrality algorithms
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 表5-1\. 中心性算法概述
- en: '| Algorithm type | What it does | Example use | Spark example | Neo4j example
    |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| 算法类型 | 它的作用 | 示例用途 | Spark示例 | Neo4j示例 |'
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- en: '|'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[Degree Centrality](#degree_centrality)'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '[度中心性](#degree_centrality)'
- en: '|'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Measures the number of relationships a node has
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 测量节点具有的关系数量
- en: '|'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Estimating a person’s popularity by looking at their in-degree and using their
    out-degree to estimate gregariousness
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 通过观察其入度来估计一个人的受欢迎程度，并使用其出度来估计社交性
- en: '|'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'Yes'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 是的
- en: '|'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'No'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 不
- en: '|'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[Closeness Centrality](#closeness_centrality)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '[接近中心性](#closeness_centrality)'
- en: 'Variations: [Wasserman and Faust](#wasserman_faust), [Harmonic Centrality](#harmonic)'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 变体：[Wasserman and Faust](#wasserman_faust)，[和谐中心性](#harmonic)
- en: '|'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Calculates which nodes have the shortest paths to all other nodes
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 计算哪些节点到所有其他节点的最短路径
- en: '|'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Finding the optimal location of new public services for maximum accessibility
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 找到新公共服务的最佳位置，以实现最大的可访问性
- en: '|'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'Yes'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 是的
- en: '|'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'Yes'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 是的
- en: '|'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[Betweenness Centrality](#betweenness_centrality)'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '[介数中心性](#betweenness_centrality)'
- en: 'Variation: [Randomized-Approximate Brandes](#betweenness_approx)'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 变体：[随机近似布兰德斯](#betweenness_approx)
- en: '|'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Measures the number of shortest paths that pass through a node
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 测量通过节点的最短路径数
- en: '|'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Improving drug targeting by finding the control genes for specific diseases
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 通过找到特定疾病的控制基因来改善药物靶向
- en: '|'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'No'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 不
- en: '|'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'Yes'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 是的
- en: '|'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PageRank](#pagerank)'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '[页面排名](#pagerank)'
- en: 'Variation: [Personalized PageRank](#personal_pagerank)'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 变体：[个性化页面排名](#personal_pagerank)
- en: '|'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Estimates a current node’s importance from its linked neighbors and their neighbors
    (popularized by Google)
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 从其链接的邻居及其邻居（由Google推广）估计当前节点的重要性
- en: '|'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Finding the most influential features for extraction in machine learning and
    ranking text for entity relevance in natural language processing.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在机器学习中找到最具影响力的特征进行提取，并在自然语言处理中为实体相关性排名文本。
- en: '|'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'Yes'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 是的
- en: '|'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'Yes'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 是的
- en: '|'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Note
  id: totrans-63
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Several of the centrality algorithms calculate shortest paths between every
    pair of nodes. This works well for small- to medium-sized graphs but for large
    graphs can be computationally prohibitive. To avoid long runtimes on larger graphs,
    some algorithms (for example, Betweenness Centrality) have approximating versions.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 一些中心度算法计算每对节点之间的最短路径。这对小型到中型图表效果很好，但对于大型图表可能会造成计算上的限制。为了避免在大型图表上运行时间过长，一些算法（例如介数中心度）有近似版本。
- en: First, we’ll describe the dataset for our examples and walk through importing
    the data into Apache Spark and Neo4j. Each algorithm is covered in the order listed
    in [Table 5-1](#centrality-overview-table). We’ll start with a short description
    of the algorithm and, when warranted, information on how it operates. Variations
    of algorithms already covered will include less detail. Most sections also include
    guidance on when to use the related algorithm. We demonstrate example code using
    a sample dataset at the end of each section.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将描述我们示例数据集，并演示如何将数据导入 Apache Spark 和 Neo4j。每个算法的顺序与[表 5-1](#centrality-overview-table)相同。我们将从算法的简短描述开始，必要时会介绍其运行方式。已覆盖的算法的变体将包括较少的细节。大多数部分还包括何时使用相关算法的指导。我们在每个部分的末尾使用样本数据集演示示例代码。
- en: Let’s get started!
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: 'Example Graph Data: The Social Graph'
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例图数据：社交图
- en: Centrality algorithms are relevant to all graphs, but social networks provide
    a very relatable way to think about dynamic influence and the flow of information.
    The examples in this chapter are run against a small Twitter-like graph. You can
    download the nodes and relationships files we’ll use to create our graph from
    the [book’s GitHub repository](https://bit.ly/2FPgGVV).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 中心度算法与所有图表相关，但社交网络提供了一种非常贴近生活的方式来思考动态影响和信息流动。本章的示例是针对一个类似 Twitter 的小型图表运行的。你可以从[书籍的
    GitHub 仓库](https://bit.ly/2FPgGVV)下载我们用来创建图表的节点和关系文件。
- en: Table 5-2\. *social-nodes.csv*
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 表 5-2\. *social-nodes.csv*
- en: '| id |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| id |'
- en: '| --- |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| --- |'
- en: '| Alice |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| Alice |'
- en: '| Bridget |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| Bridget |'
- en: '| Charles |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| Charles |'
- en: '| Doug |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| Doug |'
- en: '| Mark |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| Mark |'
- en: '| Michael |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| Michael |'
- en: '| David |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| David |'
- en: '| Amy |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| Amy |'
- en: '| James |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| James |'
- en: '|  |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Table 5-3\. *social-relationships.csv*
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 表 5-3\. *social-relationships.csv*
- en: '| src | dst | relationship |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| src | dst | relationship |'
- en: '| --- | --- | --- |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Alice | Bridget | FOLLOWS |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| Alice | Bridget | FOLLOWS |'
- en: '| Alice | Charles | FOLLOWS |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| Alice | Charles | FOLLOWS |'
- en: '| Mark | Doug | FOLLOWS |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| Mark | Doug | FOLLOWS |'
- en: '| Bridget | Michael | FOLLOWS |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| Bridget | Michael | FOLLOWS |'
- en: '| Doug | Mark | FOLLOWS |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| Doug | Mark | FOLLOWS |'
- en: '| Michael | Alice | FOLLOWS |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| Michael | Alice | FOLLOWS |'
- en: '| Alice | Michael | FOLLOWS |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| Alice | Michael | FOLLOWS |'
- en: '| Bridget | Alice | FOLLOWS |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| Bridget | Alice | FOLLOWS |'
- en: '| Michael | Bridget | FOLLOWS |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| Michael | Bridget | FOLLOWS |'
- en: '| Charles | Doug | FOLLOWS |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| Charles | Doug | FOLLOWS |'
- en: '| Bridget | Doug | FOLLOWS |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| Bridget | Doug | FOLLOWS |'
- en: '| Michael | Doug | FOLLOWS |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| Michael | Doug | FOLLOWS |'
- en: '| Alice | Doug | FOLLOWS |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| Alice | Doug | FOLLOWS |'
- en: '| Mark | Alice | FOLLOWS |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| Mark | Alice | FOLLOWS |'
- en: '| David | Amy | FOLLOWS |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| David | Amy | FOLLOWS |'
- en: '| James | David | FOLLOWS |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| James | David | FOLLOWS |'
- en: '[Figure 5-2](#social-graph-image) illustrates the graph that we want to construct.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5-2](#social-graph-image) 展示了我们希望构建的图表。'
- en: '![gral 0502](Images/gral_0502.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![gral 0502](Images/gral_0502.png)'
- en: Figure 5-2\. The graph model
  id: totrans-103
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-2\. 图表模型
- en: We have one larger set of users with connections between them and a smaller
    set with no connections to that larger group.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个更大的用户集合，他们之间有连接，并且一个较小的集合与该较大组没有连接。
- en: Let’s create graphs in Spark and Neo4j based on the contents of those CSV files.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们基于这些 CSV 文件的内容在 Spark 和 Neo4j 中创建图表。
- en: Importing the Data into Apache Spark
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将数据导入 Apache Spark
- en: 'First, we’ll import the required packages from Spark and the GraphFrames package:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们从 Spark 和 GraphFrames 包中导入所需的包：
- en: '[PRE0]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We can write the following code to create a GraphFrame based on the contents
    of the CSV files:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以编写以下代码来创建基于 CSV 文件内容的 GraphFrame：
- en: '[PRE1]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Importing the Data into Neo4j
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将数据导入 Neo4j
- en: 'Next, we’ll load the data for Neo4j. The following query imports nodes:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将为 Neo4j 加载数据。以下查询导入节点：
- en: '[PRE2]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'And this query imports relationships:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 并且这个查询导入了关系：
- en: '[PRE3]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now that our graphs are loaded, it’s on to the algorithms!
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的图表加载完毕，我们开始进行算法的应用！
- en: Degree Centrality
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 度中心度
- en: 'Degree Centrality is the simplest of the algorithms that we’ll cover in this
    book. It counts the number of incoming and outgoing relationships from a node,
    and is used to find popular nodes in a graph. Degree Centrality was proposed by
    Linton C. Freeman in his 1979 paper [“Centrality in Social Networks: Conceptual
    Clarification”](http://bit.ly/2uAGOih).'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 度中心性是我们在本书中介绍的最简单的算法之一。它计算节点的入度和出度的数量，并用于在图中找到流行节点。度中心性是由Linton C. Freeman在他1979年的论文[“社会网络中的中心性：概念澄清”](http://bit.ly/2uAGOih)中提出的。
- en: Reach
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 到达度
- en: Understanding the reach of a node is a fair measure of importance. How many
    other nodes can it touch right now? The *degree* of a node is the number of direct
    relationships it has, calculated for in-degree and out-degree. You can think of
    this as the immediate reach of node. For example, a person with a high degree
    in an active social network would have a lot of immediate contacts and be more
    likely to catch a cold circulating in their network.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 理解节点的到达度是一个衡量重要性的公平指标。它能触及多少其他节点？节点的*度*是它拥有的直接关系数量，计算入度和出度。你可以把它看作节点的即时到达度。例如，在活跃社交网络中，拥有高度的人会有很多即时联系，因此更有可能在他们的网络中流传着流感。
- en: The *average degree* of a network is simply the total number of relationships
    divided by the total number of nodes; it can be heavily skewed by high degree
    nodes. The *degree distribution* is the probability that a randomly selected node
    will have a certain number of relationships.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 网络的*平均度*简单地是总关系数除以总节点数；它可能会被高度节点偏斜。*度分布*是随机选择的节点具有特定数量关系的概率。
- en: '[Figure 5-3](#ch3-degree-distribution) illustrates the difference looking at
    the actual distribution of connections among subreddit topics. If you simply took
    the average, you’d assume most topics have 10 connections, whereas in fact most
    topics only have 2 connections.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '[图5-3](#ch3-degree-distribution)说明了在分析 subreddit 主题之间的实际连接分布时的不同之处。如果仅仅取平均值，你可能会认为大多数主题有10个连接，但实际上大多数主题只有2个连接。'
- en: '![gral 0503](Images/gral_0503.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![gral 0503](Images/gral_0503.png)'
- en: Figure 5-3\. This mapping of subreddit degree distribution by [Jacob Silterrapa](http://bit.ly/2WlNaOc)
    provides an example of how the average does not often reflect the actual distribution
    in networks. CC BY-SA 3.0.
  id: totrans-124
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5-3。这张由[Jacob Silterrapa](http://bit.ly/2WlNaOc)绘制的 subreddit 度分布映射展示了平均值通常不反映网络中实际分布的示例。CC
    BY-SA 3.0。
- en: These measures are used to categorize network types such as the scale-free or
    small-world networks that were discussed in [Chapter 2](ch02.xhtml#graph_theory_and_concepts).
    They also provide a quick measure to help estimate the potential for things to
    spread or ripple throughout a network.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这些度量用于分类网络类型，如在[第2章](ch02.xhtml#graph_theory_and_concepts)中讨论的无标度网络或小世界网络。它们还提供了一个快速测量，帮助估计事物在网络中传播或波及的潜力。
- en: When Should I Use Degree Centrality?
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 何时使用度中心性？
- en: Use Degree Centrality if you’re attempting to analyze influence by looking at
    the number of incoming and outgoing relationships, or find the “popularity” of
    individual nodes. It works well when you’re concerned with immediate connectedness
    or near-term probabilities. However, Degree Centrality is also applied to global
    analysis when you want to evaluate the minimum degree, maximum degree, mean degree,
    and standard deviation across the entire graph.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试通过查看入度和出度的数量来分析影响力，或者找出个体节点的“流行度”，那么可以使用**度中心性（Degree Centrality）**。当你关注即时连接或近期概率时，它表现良好。然而，当你想评估整个图中的最小度、最大度、平均度和标准差时，度中心性也适用于全局分析。
- en: 'Example use cases include:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 示例用途包括：
- en: Identifying powerful individuals though their relationships, such as connections
    of people in a social network. For example, in BrandWatch’s [“Most Influential
    Men and Women on Twitter 2017”](https://bit.ly/2WnB2fK), the top 5 people in each
    category have over 40 million followers each.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别强大个体通过他们的关系，比如社交网络中的人际关系。例如，在BrandWatch的[“2017年Twitter上最有影响力的男性和女性”](https://bit.ly/2WnB2fK)中，每个类别的前5位人物每人拥有超过4000万的追随者。
- en: Separating fraudsters from legitimate users of an online auction site. The weighted
    centrality of fraudsters tends to be significantly higher due to collusion aimed
    at artificially increasing prices. Read more in the paper by P. Bangcharoensap
    et al., [“Two Step Graph-Based Semi-Supervised Learning for Online Auction Fraud
    Detection”](https://bit.ly/2YlaLAq).
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分离在线拍卖网站的欺诈者和合法用户。由于串通目的人为提高价格，欺诈者的加权中心度往往显著较高。在P. Bangcharoensap等人的论文中详细阅读，[“基于两步图的半监督学习用于在线拍卖欺诈检测”](https://bit.ly/2YlaLAq)。
- en: Degree Centrality with Apache Spark
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Apache Spark的度中心度
- en: 'Now we’ll execute the Degree Centrality algorithm with the following code:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将执行使用以下代码的度中心度算法：
- en: '[PRE4]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We first calculate the total, in, and out degrees. Then we join those DataFrames
    together, using a left join to retain any nodes that don’t have incoming or outgoing
    relationships. If nodes don’t have relationships we set that value to `0` using
    the `fillna` function.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先计算总度数、入度和出度。然后我们将这些DataFrame连接在一起，使用左连接以保留没有入度或出度关系的任何节点。如果节点没有关系，我们使用`fillna`函数将该值设置为`0`。
- en: 'Here’s the result of running the code in pyspark:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在pyspark中运行代码的结果：
- en: '| id | degree | inDegree | outDegree |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| id | degree | inDegree | outDegree |'
- en: '| --- | --- | --- | --- |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Doug | 6 | 5 | 1 |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| Doug | 6 | 5 | 1 |'
- en: '| Alice | 7 | 3 | 4 |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| Alice | 7 | 3 | 4 |'
- en: '| Michael | 5 | 2 | 3 |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| Michael | 5 | 2 | 3 |'
- en: '| Bridget | 5 | 2 | 3 |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| Bridget | 5 | 2 | 3 |'
- en: '| Charles | 2 | 1 | 1 |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| Charles | 2 | 1 | 1 |'
- en: '| Mark | 3 | 1 | 2 |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| Mark | 3 | 1 | 2 |'
- en: '| David | 2 | 1 | 1 |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| David | 2 | 1 | 1 |'
- en: '| Amy | 1 | 1 | 0 |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| Amy | 1 | 1 | 0 |'
- en: '| James | 1 | 0 | 1 |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| James | 1 | 0 | 1 |'
- en: We can see in [Figure 5-4](#degree-centrality-result-image) that Doug is the
    most popular user in our Twitter graph, with five followers (in-links). All other
    users in that part of the graph follow him and he only follows one person back.
    In the real Twitter network, celebrities have high follower counts but tend to
    follow few people. We could therefore consider Doug a celebrity!
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在[图5-4](#degree-centrality-result-image)中看到，在我们的Twitter图中Doug是最受欢迎的用户，拥有五个粉丝（入链）。该图中其他用户都在关注他，而他只关注一个人。在真实的Twitter网络中，名人通常有很高的粉丝数量，但他们往往只关注少数人。因此，我们可以考虑Doug是一个名人！
- en: '![gral 0504](Images/gral_0504.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![gral 0504](Images/gral_0504.png)'
- en: Figure 5-4\. Visualization of degree centrality
  id: totrans-149
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5-4\. 度中心度的可视化
- en: If we were creating a page showing the most-followed users or wanted to suggest
    people to follow, we could use this algorithm to identify those people.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们正在创建一个显示最多关注用户或者想要建议关注的人的页面，我们可以使用这个算法来识别这些人。
- en: Tip
  id: totrans-151
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Some data may contain very dense nodes with lots of relationships. These don’t
    add much additional information and can skew some results or add computational
    complexity. You may want to filter out these dense notes by using a subgraph,
    or use a projection to summarize the relationships as weights.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 一些数据可能包含非常密集的节点，具有大量关系。这些节点并不添加额外的信息，并可能使某些结果产生偏差或增加计算复杂性。您可以通过使用子图来过滤这些密集节点，或者使用投影来总结关系作为权重。
- en: Closeness Centrality
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 紧密中心度
- en: Closeness Centrality is a way of detecting nodes that are able to spread information
    efficiently through a subgraph.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 紧密中心度是检测能够通过子图高效传播信息的节点的一种方法。
- en: The measure of a node’s centrality is its average farness (inverse distance)
    to all other nodes. Nodes with a high closeness score have the shortest distances
    from all other nodes.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 一个节点中心度的度量是其到所有其他节点的平均远离度（倒数距离）。具有高紧密度分数的节点与所有其他节点的距离最短。
- en: For each node, the Closeness Centrality algorithm calculates the sum of its
    distances to all other nodes, based on calculating the shortest paths between
    all pairs of nodes. The resulting sum is then *inverted* to determine the closeness
    centrality score for that node.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个节点，紧密中心度算法计算其到所有其他节点的距离的总和，基于计算所有节点对之间的最短路径。然后，将结果总和*倒置*以确定该节点的紧密中心度分数。
- en: 'The closeness centrality of a node is calculated using the formula:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 计算节点的紧密中心度是使用以下公式计算的：
- en: <math display="block"><mrow><mi>C</mi> <mrow><mo>(</mo> <mi>u</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mfrac><mn>1</mn> <mrow><msubsup><mo>∑</mo> <mrow><mi>v</mi><mo>=</mo><mn>1</mn></mrow>
    <mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msubsup> <mi>d</mi><mrow><mo>(</mo><mi>u</mi><mo>,</mo><mi>v</mi><mo>)</mo></mrow></mrow></mfrac></mrow></math>
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: <math display="block"><mrow><mi>C</mi> <mrow><mo>(</mo> <mi>u</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mfrac><mn>1</mn> <mrow><msubsup><mo>∑</mo> <mrow><mi>v</mi><mo>=</mo><mn>1</mn></mrow>
    <mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msubsup> <mi>d</mi><mrow><mo>(</mo><mi>u</mi><mo>,</mo><mi>v</mi><mo>)</mo></mrow></mrow></mfrac></mrow></math>
- en: 'where:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 其中：
- en: '*u* is a node.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*u* 是一个节点。'
- en: '*n* is the number of nodes in the graph.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*n* 是图中的节点数。'
- en: '*d(u,v)* is the shortest-path distance between another node *v* and *u*.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*d(u,v)* 是另一个节点 *v* 到 *u* 的最短路径距离。'
- en: It is more common to normalize this score so that it represents the average
    length of the shortest paths rather than their sum. This adjustment allows comparisons
    of the closeness centrality of nodes of graphs of different sizes.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 更常见的是对此分数进行归一化，以表示最短路径的平均长度，而不是它们的总和。这种调整允许比较不同大小图的节点的紧密中心度。
- en: 'The formula for normalized closeness centrality is as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 标准化接近中心性的公式如下：
- en: <math display="block"><mrow><msub><mi>C</mi> <mrow><mi>n</mi><mi>o</mi><mi>r</mi><mi>m</mi></mrow></msub>
    <mrow><mo>(</mo> <mi>u</mi> <mo>)</mo></mrow> <mo>=</mo> <mfrac><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow>
    <mrow><msubsup><mo>∑</mo> <mrow><mi>v</mi><mo>=</mo><mn>1</mn></mrow> <mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msubsup>
    <mi>d</mi><mrow><mo>(</mo><mi>u</mi><mo>,</mo><mi>v</mi><mo>)</mo></mrow></mrow></mfrac></mrow></math>
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: <math display="block"><mrow><msub><mi>C</mi> <mrow><mi>n</mi><mi>o</mi><mi>r</mi><mi>m</mi></mrow></msub>
    <mrow><mo>(</mo> <mi>u</mi> <mo>)</mo></mrow> <mo>=</mo> <mfrac><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow>
    <mrow><msubsup><mo>∑</mo> <mrow><mi>v</mi><mo>=</mo><mn>1</mn></mrow> <mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msubsup>
    <mi>d</mi><mrow><mo>(</mo><mi>u</mi><mo>,</mo><mi>v</mi><mo>)</mo></mrow></mrow></mfrac></mrow></math>
- en: When Should I Use Closeness Centrality?
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 何时使用接近中心性？
- en: Apply Closeness Centrality when you need to know which nodes disseminate things
    the fastest. Using weighted relationships can be especially helpful in evaluating
    interaction speeds in communication and behavioral analyses.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在需要知道哪些节点最快传播信息时应用接近中心性。使用加权关系在评估交流速度和行为分析中尤为有帮助。
- en: 'Example use cases include:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 示例用例包括：
- en: Uncovering individuals in very favorable positions to control and acquire vital
    information and resources within an organization. One such study is [“Mapping
    Networks of Terrorist Cells”](http://bit.ly/2WjFdsM), by V. E. Krebs.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 揭示在组织内控制和获取关键信息和资源非常有利位置的个体。其中一项研究是由 V. E. Krebs 所作的 [“映射恐怖主义网络”](http://bit.ly/2WjFdsM)。
- en: As a heuristic for estimating arrival time in telecommunications and package
    delivery, where content flows through the shortest paths to a predefined target.
    It is also used to shed light on propagation through all shortest paths simultaneously,
    such as infections spreading through a local community. Find more details in [“Centrality
    and Network Flow”](http://bit.ly/2Op5bbH), by S. P. Borgatti.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于在电信和包裹交付中估计到达时间的启发式方法，其中内容通过最短路径流向预定义目标。它还被用来同时揭示通过所有最短路径的传播，例如在本地社区中传播感染。详细信息请参阅
    S. P. Borgatti 的 [“中心性和网络流”](http://bit.ly/2Op5bbH)。
- en: Evaluating the importance of words in a document, based on a graph-based keyphrase
    extraction process. This process is described by F. Boudin in [“A Comparison of
    Centrality Measures for Graph-Based Keyphrase Extraction”](https://bit.ly/2WkDByX).
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据 F. Boudin 在 [“基于图的关键词提取的中心性度量比较”](https://bit.ly/2WkDByX) 中描述的基于图的关键词提取过程，评估文档中单词的重要性。
- en: Warning
  id: totrans-172
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Closeness Centrality works best on connected graphs. When the original formula
    is applied to an unconnected graph, we end up with an infinite distance between
    two nodes where there is no path between them. This means that we’ll end up with
    an infinite closeness centrality score when we sum up all the distances from that
    node. To avoid this issue, a variation on the original formula will be shown after
    the next example.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 接近中心性在连接的图上效果最好。当应用原始公式到非连接的图时，我们得到两个节点之间没有路径的情况下的无穷距离。这意味着当我们从该节点到所有距离的总和时，我们将得到一个无穷的接近中心性分数。为了避免这个问题，下一个示例后将展示原始公式的变体。
- en: Closeness Centrality with Apache Spark
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Apache Spark 进行接近中心性计算
- en: Apache Spark doesn’t have a built-in algorithm for Closeness Centrality, but
    we can write our own using the `aggregateMessages` framework that we introduced
    in the [“Shortest Path (Weighted) with Apache Spark”](ch04.xhtml#shortest-weighted-path-spark)
    in the previous chapter.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: Apache Spark 没有内置的接近中心性算法，但我们可以使用我们在上一章 [“Apache Spark 中的最短路径（加权）”](ch04.xhtml#shortest-weighted-path-spark)
    中介绍的 `aggregateMessages` 框架编写自己的算法。
- en: 'Before we create our function, we’ll import some libraries that we’ll use:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建函数之前，我们将导入一些后续使用的库：
- en: '[PRE5]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We’ll also create a few user-defined functions that we’ll need later:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将创建几个后面需要用到的用户定义函数：
- en: '[PRE6]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'And now for the main body that calculates the closeness centrality for each
    node:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来计算每个节点的接近中心性的主体部分：
- en: '[PRE7]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If we run that we’ll see the following output:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行它，我们将看到以下输出：
- en: '| id | ids | closeness |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| id | ids | 接近中心性 |'
- en: '| --- | --- | --- |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Doug | [[Charles, 1], [Mark, 1], [Alice, 1], [Bridget, 1], [Michael, 1]]
    | 1.0 |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| Doug | [[查尔斯, 1], [马克, 1], [爱丽丝, 1], [布里奇特, 1], [迈克尔, 1]] | 1.0 |'
- en: '| Alice | [[Charles, 1], [Mark, 1], [Bridget, 1], [Doug, 1], [Michael, 1]]
    | 1.0 |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| Alice | [[查尔斯, 1], [马克, 1], [布里奇特, 1], [道格, 1], [迈克尔, 1]] | 1.0 |'
- en: '| David | [[James, 1], [Amy, 1]] | 1.0 |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| David | [[詹姆斯, 1], [艾米, 1]] | 1.0 |'
- en: '| Bridget | [[Charles, 2], [Mark, 2], [Alice, 1], [Doug, 1], [Michael, 1]]
    | 0.7142857142857143 |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| Bridget | [[查尔斯, 2], [马克, 2], [爱丽丝, 1], [道格, 1], [迈克尔, 1]] | 0.7142857142857143
    |'
- en: '| Michael | [[Charles, 2], [Mark, 2], [Alice, 1], [Doug, 1], [Bridget, 1]]
    | 0.7142857142857143 |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| Michael | [[查尔斯, 2], [马克, 2], [爱丽丝, 1], [道格, 1], [布里奇特, 1]] | 0.7142857142857143
    |'
- en: '| James | [[Amy, 2], [David, 1]] | 0.6666666666666666 |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| James | [[艾米, 2], [大卫, 1]] | 0.6666666666666666 |'
- en: '| Amy | [[James, 2], [David, 1]] | 0.6666666666666666 |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| Amy | [[詹姆斯, 2], [大卫, 1]] | 0.6666666666666666 |'
- en: '| Mark | [[Bridget, 2], [Charles, 2], [Michael, 2], [Doug, 1], [Alice, 1]]
    | 0.625 |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| Mark | [[布里奇特, 2], [查尔斯, 2], [迈克尔, 2], [道格, 1], [爱丽丝, 1]] | 0.625 |'
- en: '| Charles | [[Bridget, 2], [Mark, 2], [Michael, 2], [Doug, 1], [Alice, 1]]
    | 0.625 |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| Charles | [[布里奇特, 2], [马克, 2], [迈克尔, 2], [道格, 1], [爱丽丝, 1]] | 0.625 |'
- en: Alice, Doug, and David are the most closely connected nodes in the graph with
    a 1.0 score, which means each directly connects to all nodes in their part of
    the graph. [Figure 5-5](#closeness-result-image) illustrates that even though
    David has only a few connections, within his group of friends that’s significant.
    In other words, this score represents the closeness of each user to others within
    their subgraph but not the entire graph.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图5-5显示，尽管David只有少数连接，但在他的朋友圈内这很重要。换句话说，这个分数代表每个用户在其子图中与其他节点的接近程度，而不是整个图。
- en: '![gral 0505](Images/gral_0505.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![gral 0505](Images/gral_0505.png)'
- en: Figure 5-5\. Visualization of closeness centrality
  id: totrans-196
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5-5\. 接近中心性的可视化
- en: Closeness Centrality with Neo4j
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Neo4j进行接近中心性
- en: 'Neo4j’s implementation of Closeness Centrality uses the following formula:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Neo4j的接近中心性实现使用以下公式：
- en: <math display="block"><mrow><mi>C</mi> <mrow><mo>(</mo> <mi>u</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mfrac><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow> <mrow><msubsup><mo>∑</mo>
    <mrow><mi>v</mi><mo>=</mo><mn>1</mn></mrow> <mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msubsup>
    <mi>d</mi><mrow><mo>(</mo><mi>u</mi><mo>,</mo><mi>v</mi><mo>)</mo></mrow></mrow></mfrac></mrow></math>
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: <math display="block"><mrow><mi>C</mi> <mrow><mo>(</mo> <mi>u</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mfrac><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow> <mrow><msubsup><mo>∑</mo>
    <mrow><mi>v</mi><mo>=</mo><mn>1</mn></mrow> <mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msubsup>
    <mi>d</mi><mrow><mo>(</mo><mi>u</mi><mo>,</mo><mi>v</mi><mo>)</mo></mrow></mrow></mfrac></mrow></math>
- en: 'where:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 其中：
- en: '*u* is a node.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*u* 是一个节点。'
- en: '*n* is the number of nodes in the same component (subgraph or group) as *u*.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*n* 是与*u*在同一组件（子图或群）中的节点数。'
- en: '*d(u,v)* is the shortest-path distance between another node *v* and *u*.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*d(u,v)* 是另一个节点*v*与*u*之间的最短路径距离。'
- en: 'A call to the following procedure will calculate the closeness centrality for
    each of the nodes in our graph:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用以下过程，我们可以计算图中每个节点的接近中心性：
- en: '[PRE8]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Running this procedure gives the following output:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此过程会得到以下输出：
- en: '| user | centrality |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| 用户 | 中心性 |'
- en: '| --- | --- |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Alice | 1.0 |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| Alice | 1.0 |'
- en: '| Doug | 1.0 |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| Doug | 1.0 |'
- en: '| David | 1.0 |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| David | 1.0 |'
- en: '| Bridget | 0.7142857142857143 |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| Bridget | 0.7142857142857143 |'
- en: '| Michael | 0.7142857142857143 |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| Michael | 0.7142857142857143 |'
- en: '| Amy | 0.6666666666666666 |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| Amy | 0.6666666666666666 |'
- en: '| James | 0.6666666666666666 |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| James | 0.6666666666666666 |'
- en: '| Charles | 0.625 |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| Charles | 0.625 |'
- en: '| Mark | 0.625 |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| Mark | 0.625 |'
- en: We get the same results as with the Spark algorithm, but, as before, the score
    represents their closeness to others within their subgraph but not the entire
    graph.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们获得了与Spark算法相同的结果，但是，与之前一样，得分表示他们在其子图中与其他节点的接近程度，而不是整个图。
- en: Note
  id: totrans-219
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: In the strict interpretation of the Closeness Centrality algorithm, all the
    nodes in our graph would have a score of ∞ because every node has at least one
    other node that it’s unable to reach. However, it’s usually more useful to implement
    the score per component.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在接近中心性算法的严格解释中，我们的图中所有节点的分数都将是∞，因为每个节点至少有一个其他节点是无法到达的。然而，通常更有用的是按组件实现分数。
- en: Ideally we’d like to get an indication of closeness across the whole graph,
    and in the next two sections we’ll learn about a few variations of the Closeness
    Centrality algorithm that do this.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，我们希望得到整个图的接近程度指标，在接下来的两个部分中，我们将学习几种接近中心性算法的变体。
- en: 'Closeness Centrality Variation: Wasserman and Faust'
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接近中心性变体：Wasserman和Faust
- en: 'Stanley Wasserman and Katherine Faust came up with an improved formula for
    calculating closeness for graphs with multiple subgraphs without connections between
    those groups. Details on their formula are in their book, *Social Network Analysis:
    Methods and Applications*. The result of this formula is a ratio of the fraction
    of nodes in the group that are reachable to the average distance from the reachable
    nodes.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: Stanley Wasserman和Katherine Faust提出了一种改进的公式，用于计算具有多个子图且这些组之间没有连接的图的接近程度。有关他们的公式的详细信息在他们的书籍《社会网络分析：方法与应用》中。此公式的结果是可到达节点的分数与可到达节点的平均距离的比率。
- en: 'The formula is as follows:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 公式如下：
- en: <math display="block"><mrow><msub><mi>C</mi> <mrow><mi>W</mi><mi>F</mi></mrow></msub>
    <mrow><mo>(</mo> <mi>u</mi> <mo>)</mo></mrow> <mo>=</mo> <mfrac><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow>
    <mrow><mi>N</mi><mo>-</mo><mn>1</mn></mrow></mfrac> <mfenced separators="" open="("
    close=")"><mfrac><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow> <mrow><msubsup><mo>∑</mo>
    <mrow><mi>v</mi><mo>=</mo><mn>1</mn></mrow> <mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msubsup>
    <mi>d</mi><mrow><mo>(</mo><mi>u</mi><mo>,</mo><mi>v</mi><mo>)</mo></mrow></mrow></mfrac></mfenced></mrow></math>
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: <math display="block"><mrow><msub><mi>C</mi> <mrow><mi>W</mi><mi>F</mi></mrow></msub>
    <mrow><mo>(</mo> <mi>u</mi> <mo>)</mo></mrow> <mo>=</mo> <mfrac><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow>
    <mrow><mi>N</mi><mo>-</mo><mn>1</mn></mrow></mfrac> <mfenced separators="" open="("
    close=")"><mfrac><mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow> <mrow><msubsup><mo>∑</mo>
    <mrow><mi>v</mi><mo>=</mo><mn>1</mn></mrow> <mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msubsup>
    <mi>d</mi><mrow><mo>(</mo><mi>u</mi><mo>,</mo><mi>v</mi><mo>)</mo></mrow></mrow></mfrac></mfenced></mrow></math>
- en: 'where:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 其中：
- en: '*u* is a node.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*u* 是一个节点。'
- en: '*N* is the total node count.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*N* 是总节点数。'
- en: '*n* is the number of nodes in the same component as *u*.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*n* 是与*u*在同一组件中的节点数。'
- en: '*d(u,v)* is the shortest-path distance between another node *v* and *u*.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*d(u,v)* 是另一个节点*v*与*u*之间的最短路径距离。'
- en: 'We can tell the Closeness Centrality procedure to use this formula by passing
    the parameter `improved: true`.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '我们可以通过传递参数`improved: true`来告诉接近中心性过程使用此公式。'
- en: 'The following query executes Closeness Centrality using the Wasserman and Faust
    formula:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 以下查询使用Wasserman和Faust的公式执行接近中心性：
- en: '[PRE9]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The procedure gives the following result:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 该过程给出以下结果：
- en: '| user | centrality |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| 用户 | 中心性 |'
- en: '| --- | --- |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Alice | 0.5 |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| Alice | 0.5 |'
- en: '| Doug | 0.5 |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| Doug | 0.5 |'
- en: '| Bridget | 0.35714285714285715 |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| Bridget | 0.35714285714285715 |'
- en: '| Michael | 0.35714285714285715 |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| Michael | 0.35714285714285715 |'
- en: '| Charles | 0.3125 |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| Charles | 0.3125 |'
- en: '| Mark | 0.3125 |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| Mark | 0.3125 |'
- en: '| David | 0.125 |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| David | 0.125 |'
- en: '| Amy | 0.08333333333333333 |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| Amy | 0.08333333333333333 |'
- en: '| James | 0.08333333333333333 |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| 詹姆斯 | 0.08333333333333333 |'
- en: As [Figure 5-6](#closeness-wasserman-faust-image) shows, the results are now
    more representative of the closeness of nodes to the entire graph. The scores
    for the members of the smaller subgraph (David, Amy, and James) have been dampened,
    and they now have the lowest scores of all users. This makes sense as they are
    the most isolated nodes. This formula is more useful for detecting the importance
    of a node across the entire graph rather than within its own subgraph.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图5-6](#closeness-wasserman-faust-image)所示，现在的结果更能代表节点与整个图的接近程度。较小子图的成员得分（大卫、艾米和詹姆斯）已经减弱，现在他们拥有所有用户中最低的得分。这是合理的，因为他们是最孤立的节点。这个公式更适用于检测节点在整个图中的重要性，而不是在其自己的子图中。
- en: '![gral 0506](Images/gral_0506.png)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![gral 0506](Images/gral_0506.png)'
- en: Figure 5-6\. Visualization of closeness centrality
  id: totrans-248
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5-6\. 接近中心性的可视化
- en: In the next section we’ll learn about the Harmonic Centrality algorithm, which
    achieves similar results using another formula to calculate closeness.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将学习调和中心性算法，该算法使用另一个公式计算接近度并实现类似的结果。
- en: 'Closeness Centrality Variation: Harmonic Centrality'
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接近中心性变化：调和中心性
- en: Harmonic Centrality (also known as Valued Centrality) is a variant of Closeness
    Centrality, invented to solve the original problem with unconnected graphs. In
    [“Harmony in a Small World”](https://bit.ly/2HSkTef), M. Marchiori and V. Latora
    proposed this concept as a practical representation of an average shortest path.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 调和中心性（也称为价值中心性）是接近中心性的一种变体，旨在解决不连通图的原始问题。在[“和谐在一个小世界中”](https://bit.ly/2HSkTef)中，M.
    Marchiori和V. Latora提出了这一概念，作为平均最短路径的实际表示。
- en: When calculating the closeness score for each node, rather than summing the
    distances of a node to all other nodes, it sums the inverse of those distances.
    This means that infinite values become irrelevant.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 当计算每个节点的接近度评分时，不是将节点到所有其他节点的距离相加，而是将这些距离的倒数相加。这意味着无限值变得无关紧要。
- en: 'The raw harmonic centrality for a node is calculated using the following formula:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 节点的原始调和中心性计算公式如下：
- en: <math display="block"><mrow><mi>H</mi> <mrow><mo>(</mo> <mi>u</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mrow><munderover><mo>∑</mo> <mrow><mi>v</mi><mo>=</mo><mn>1</mn></mrow>
    <mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></munderover> <mfrac><mn>1</mn> <mrow><mi>d</mi><mo>(</mo><mi>u</mi><mo>,</mo><mi>v</mi><mo>)</mo></mrow></mfrac></mrow></mrow></math>
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: <math display="block"><mrow><mi>H</mi> <mrow><mo>(</mo> <mi>u</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mrow><munderover><mo>∑</mo> <mrow><mi>v</mi><mo>=</mo><mn>1</mn></mrow>
    <mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></munderover> <mfrac><mn>1</mn> <mrow><mi>d</mi><mo>(</mo><mi>u</mi><mo>,</mo><mi>v</mi><mo>)</mo></mrow></mfrac></mrow></mrow></math>
- en: 'where:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 其中：
- en: '*u* is a node.'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*u* 是一个节点。'
- en: '*n* is the number of nodes in the graph.'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*n* 是图中的节点数。'
- en: '*d(u,v)* is the shortest-path distance between another node *v* and *u*.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*d(u,v)* 是另一个节点 *v* 和 *u* 之间的最短路径距离。'
- en: 'As with closeness centrality, we can also calculate a normalized harmonic centrality
    with the following formula:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 与接近中心性类似，我们还可以使用以下公式计算归一化的调和中心性：
- en: <math display="block"><mrow><msub><mi>H</mi> <mrow><mi>n</mi><mi>o</mi><mi>r</mi><mi>m</mi></mrow></msub>
    <mrow><mo>(</mo> <mi>u</mi> <mo>)</mo></mrow> <mo>=</mo> <mfrac><mrow><msubsup><mo>∑</mo>
    <mrow><mi>v</mi><mo>=</mo><mn>1</mn></mrow> <mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msubsup>
    <mfrac><mn>1</mn> <mrow><mi>d</mi><mo>(</mo><mi>u</mi><mo>,</mo><mi>v</mi><mo>)</mo></mrow></mfrac></mrow>
    <mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></mfrac></mrow></math>
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: <math display="block"><mrow><msub><mi>H</mi> <mrow><mi>n</mi><mi>o</mi><mi>r</mi><mi>m</mi></mrow></msub>
    <mrow><mo>(</mo> <mi>u</mi> <mo>)</mo></mrow> <mo>=</mo> <mfrac><mrow><msubsup><mo>∑</mo>
    <mrow><mi>v</mi><mo>=</mo><mn>1</mn></mrow> <mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></msubsup>
    <mfrac><mn>1</mn> <mrow><mi>d</mi><mo>(</mo><mi>u</mi><mo>,</mo><mi>v</mi><mo>)</mo></mrow></mfrac></mrow>
    <mrow><mi>n</mi><mo>-</mo><mn>1</mn></mrow></mfrac></mrow></math>
- en: In this formula, ∞ values are handled cleanly.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个公式中，∞ 的值被处理得很干净。
- en: Harmonic Centrality with Neo4j
  id: totrans-262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Neo4j进行调和中心性
- en: 'The following query executes the Harmonic Centrality algorithm:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 以下查询执行调和中心性算法：
- en: '[PRE10]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Running this procedure gives the following result:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此过程会得到以下结果：
- en: '| user | centrality |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| 用户 | 中心性 |'
- en: '| --- | --- |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Alice | 0.625 |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| 爱丽丝 | 0.625 |'
- en: '| Doug | 0.625 |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| 道格 | 0.625 |'
- en: '| Bridget | 0.5 |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '| 布里奇特 | 0.5 |'
- en: '| Michael | 0.5 |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '| 迈克尔 | 0.5 |'
- en: '| Charles | 0.4375 |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '| 查尔斯 | 0.4375 |'
- en: '| Mark | 0.4375 |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
  zh: '| 马克 | 0.4375 |'
- en: '| David | 0.25 |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
  zh: '| 大卫 | 0.25 |'
- en: '| Amy | 0.1875 |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '| 艾米 | 0.1875 |'
- en: '| James | 0.1875 |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '| 詹姆斯 | 0.1875 |'
- en: The results from this algorithm differ from those of the original Closeness
    Centrality algorithm but are similar to those from the Wasserman and Faust improvement.
    Either algorithm can be used when working with graphs with more than one connected
    component.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 此算法的结果与原始接近中心性算法的结果不同，但与Wasserman和Faust的改进类似。在处理具有多个连接组件的图形时，可以使用任一算法。
- en: Betweenness Centrality
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 中介中心性
- en: Sometimes the most important cog in the system is not the one with the most
    overt power or the highest status. Sometimes it’s the middlemen that connect groups
    or the brokers who the most control over resources or the flow of information.
    Betweenness Centrality is a way of detecting the amount of influence a node has
    over the flow of information or resources in a graph. It is typically used to
    find nodes that serve as a bridge from one part of a graph to another.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，系统中最重要的齿轮并不是那些具有最明显权力或最高地位的齿轮。有时，是连接组群的中间人或控制资源或信息流动的经纪人。中介中心性是一种检测节点在图中对信息或资源流动影响程度的方法。通常用于查找作为从图的一部分到另一部分的桥梁的节点。
- en: The Betweenness Centrality algorithm first calculates the shortest (weighted)
    path between every pair of nodes in a connected graph. Each node receives a score,
    based on the number of these shortest paths that pass through the node. The more
    shortest paths that a node lies on, the higher its score.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 介数中心性算法首先计算连接图中每对节点的最短（加权）路径。每个节点根据通过该节点的最短路径数量获得分数。一个节点上的最短路径越多，其分数越高。
- en: Betweenness Centrality was considered one of the “three distinct intuitive conceptions
    of centrality” when it was introduced by Linton C. Freeman in his 1971 paper,
    [“A Set of Measures of Centrality Based on Betweenness”](http://moreno.ss.uci.edu/23.pdf).
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 当介数中心性由林顿·C·弗里曼在他的 1971 年论文 [“A Set of Measures of Centrality Based on Betweenness”](http://moreno.ss.uci.edu/23.pdf)
    中介绍时，被认为是“三种独特的中心性概念”之一。
- en: Bridges and control points
  id: totrans-282
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 桥和控制点
- en: A bridge in a network can be a node or a relationship. In a very simple graph,
    you can find them by looking for the node or relationship that, if removed, would
    cause a section of the graph to become disconnected. However, as that’s not practical
    in a typical graph, we use a Betweenness Centrality algorithm. We can also measure
    the betweenness of a cluster by treating the group as a node.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 网络中的桥可能是节点或关系。在一个非常简单的图中，可以通过查找如果删除将导致图的某部分断开连接的节点或关系来找到它们。然而，由于在典型图中这种方法并不实际，我们使用介数中心性算法。我们还可以通过将组视为一个节点来测量集群的介数中心性。
- en: A node is considered *pivotal* for two other nodes if it lies on *every* shortest
    path between those nodes, as shown in [Figure 5-7](#pivotal).
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个节点在另外两个节点之间的每一条最短路径上都位于“关键”的位置，如 [图 5-7](#pivotal) 所示，则该节点被认为是“关键”的。
- en: '![gral 0507](Images/gral_0507.png)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![gral 0507](Images/gral_0507.png)'
- en: Figure 5-7\. Pivotal nodes lie on every shortest path between two nodes. Creating
    more shortest paths can reduce the number of pivotal nodes for uses such as risk
    mitigation.
  id: totrans-286
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-7\. 关键节点位于两个节点之间的每条最短路径上。创建更多的最短路径可以减少关键节点的数量，用于风险缓解等用途。
- en: Pivotal nodes play an important role in connecting other nodes—if you remove
    a pivotal node, the new shortest path for the original node pairs will be longer
    or more costly. This can be a consideration for evaluating single points of vulnerability.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 关键节点在连接其他节点中起重要作用——如果移除一个关键节点，则原始节点对的新最短路径将变得更长或成本更高。这可以用来评估单点脆弱性的考虑因素。
- en: Calculating betweenness centrality
  id: totrans-288
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 计算介数中心性
- en: 'The betweenness centrality of a node is calculated by adding the results of
    the following formula for all shortest paths:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 节点的介数中心性通过对所有最短路径应用以下公式的结果进行累加来计算：
- en: <math display="block"><mrow><mi>B</mi> <mrow><mo>(</mo> <mi>u</mi> <mo>)</mo></mrow>
    <mo>=</mo> <munder><mo>∑</mo> <mrow><mi>s</mi><mo>≠</mo><mi>u</mi><mo>≠</mo><mi>t</mi></mrow></munder>
    <mfrac><mrow><mi>p</mi><mo>(</mo><mi>u</mi><mo>)</mo></mrow> <mi>p</mi></mfrac></mrow></math>
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: <math display="block"><mrow><mi>B</mi> <mrow><mo>(</mo> <mi>u</mi> <mo>)</mo></mrow>
    <mo>=</mo> <munder><mo>∑</mo> <mrow><mi>s</mi><mo>≠</mo><mi>u</mi><mo>≠</mo><mi>t</mi></mrow></munder>
    <mfrac><mrow><mi>p</mi><mo>(</mo><mi>u</mi><mo>)</mo></mrow> <mi>p</mi></mfrac></mrow></math>
- en: 'where:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 'where:'
- en: '*u* is a node.'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*u* 是一个节点。'
- en: '*p* is the total number of shortest paths between nodes *s* and *t*.'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*p* 是节点 *s* 和 *t* 之间的总最短路径数。'
- en: '*p(u)* is the number of shortest paths between nodes *s* and *t* that pass
    through node *u*.'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*p(u)* 是节点 *s* 和 *t* 之间通过节点 *u* 的最短路径数量。'
- en: '[Figure 5-8](#betweenness-concepts-image) illustrates the steps for working
    out betweenness centrality.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5-8](#betweenness-concepts-image) 展示了计算介数中心性的步骤。'
- en: '![gral 0508](Images/gral_0508.png)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
  zh: '![gral 0508](Images/gral_0508.png)'
- en: Figure 5-8\. Basic concepts for calculating betweenness centrality
  id: totrans-297
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-8\. 计算介数中心性的基本概念
- en: 'Here’s the procedure:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 这是步骤：
- en: For each node, find the shortest paths that go through it.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个节点，找出通过它的最短路径。
- en: B, C, E have no shortest paths and are assigned a value of 0.
  id: totrans-300
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: B、C、E 没有最短路径，因此分配值为 0。
- en: For each shortest path in step 1, calculate its percentage of the total possible
    shortest paths for that pair.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于步骤 1 中的每条最短路径，计算它在该对的总可能最短路径中的百分比。
- en: Add together all the values in step 2 to find a node’s betweenness centrality
    score. The table in [Figure 5-8](#betweenness-concepts-image) illustrates steps
    2 and 3 for node D.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将步骤 2 中的所有值相加以找出节点的介数中心性分数。图表在 [图 5-8](#betweenness-concepts-image) 中说明了节点 D
    的步骤 2 和 3。
- en: Repeat the process for each node.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复这个过程直到每个节点。
- en: When Should I Use Betweenness Centrality?
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 何时使用介数中心性？
- en: Betweenness Centrality applies to a wide range of problems in real-world networks.
    We use it to find bottlenecks, control points, and vulnerabilities.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 介数中心性适用于现实世界网络中的广泛问题。我们用它来寻找瓶颈、控制点和漏洞。
- en: 'Example use cases include:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 示例用例包括：
- en: Identifying influencers in various organizations. Powerful individuals are not
    necessarily in management positions, but can be found in “brokerage positions”
    using Betweenness Centrality. Removal of such influencers can seriously destabilize
    the organization. This might be considered a welcome disruption by law enforcement
    if the organization is criminal, or could be a disaster if a business loses key
    staff it underestimated. More details are found in [“Brokerage Qualifications
    in Ringing Operations”](https://bit.ly/2WKKPg0), by C. Morselli and J. Roy.
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别各种组织中的影响者。有力的个人不一定在管理职位上，而是可以通过中介中心性发现“经纪位置”。移除这样的影响者可能会严重动摇组织。如果组织是犯罪的，执法机构可能会认为这是一个受欢迎的干扰，但如果一家企业失去了被低估的关键人员，这可能会是一场灾难。更多细节请参见[“Brokerage
    Qualifications in Ringing Operations”](https://bit.ly/2WKKPg0)，由C. Morselli和J.
    Roy撰写。
- en: Uncovering key transfer points in networks such as electrical grids. Counterintuitively,
    removal of specific bridges can actually *improve* overall robustness by “islanding”
    disturbances. Research details are included in [“Robustness of the European Power
    Grids Under Intentional Attack”](https://bit.ly/2Wtqyvp), by R. Solé, et al.
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 揭示网络中的关键转移点，例如电网。令人意外的是，删除特定的桥梁实际上可以通过“孤立”干扰来改善整体稳健性。研究细节包含在[“Robustness of
    the European Power Grids Under Intentional Attack”](https://bit.ly/2Wtqyvp)，由R.
    Solé等人撰写。
- en: Helping microbloggers spread their reach on Twitter, with a recommendation engine
    for targeting influencers. This approach is described in a paper by S. Wu et al.,
    [“Making Recommendations in a Microblog to Improve the Impact of a Focal User”](https://bit.ly/2Ft58aN).
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 帮助微博客扩展其在Twitter上的影响力，使用推荐引擎来定位影响者。这种方法在S. Wu等人的论文[“Making Recommendations in
    a Microblog to Improve the Impact of a Focal User”](https://bit.ly/2Ft58aN)中有描述。
- en: Tip
  id: totrans-310
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: 'Betweenness Centrality makes the assumption that all communication between
    nodes happens along the shortest path and with the same frequency, which isn’t
    always the case in real life. Therefore, it doesn’t give us a perfect view of
    the most influential nodes in a graph, but rather a good representation. Mark
    Newman explains this in more detail in [*Networks: An Introduction*](http://bit.ly/2UaM9v0)
    (Oxford University Press, p186).'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '中介中心性假设所有节点间的通信都沿着最短路径且频率相同，但实际情况并非总是如此。因此，它不能完美地展示图中最具影响力的节点，而是提供了一个良好的代表性。Mark
    Newman在[*Networks: An Introduction*](http://bit.ly/2UaM9v0)（牛津大学出版社，第186页）中有更详细的解释。'
- en: Betweenness Centrality with Neo4j
  id: totrans-312
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Neo4j进行中介中心性计算
- en: 'Spark doesn’t have a built-in algorithm for Betweenness Centrality, so we’ll
    demonstrate this algorithm using Neo4j. A call to the following procedure will
    calculate the betweenness centrality for each of the nodes in our graph:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: Spark没有内置的中介中心性算法，因此我们将演示如何使用Neo4j来计算这个算法。调用以下过程将计算我们图中每个节点的中介中心性：
- en: '[PRE11]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Running this procedure gives the following result:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此过程将得到以下结果：
- en: '| user | centrality |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
  zh: '| user | centrality |'
- en: '| --- | --- |'
  id: totrans-317
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Alice | 10.0 |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
  zh: '| Alice | 10.0 |'
- en: '| Doug | 7.0 |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
  zh: '| Doug | 7.0 |'
- en: '| Mark | 7.0 |'
  id: totrans-320
  prefs: []
  type: TYPE_TB
  zh: '| Mark | 7.0 |'
- en: '| David | 1.0 |'
  id: totrans-321
  prefs: []
  type: TYPE_TB
  zh: '| David | 1.0 |'
- en: '| Bridget | 0.0 |'
  id: totrans-322
  prefs: []
  type: TYPE_TB
  zh: '| Bridget | 0.0 |'
- en: '| Charles | 0.0 |'
  id: totrans-323
  prefs: []
  type: TYPE_TB
  zh: '| Charles | 0.0 |'
- en: '| Michael | 0.0 |'
  id: totrans-324
  prefs: []
  type: TYPE_TB
  zh: '| Michael | 0.0 |'
- en: '| Amy | 0.0 |'
  id: totrans-325
  prefs: []
  type: TYPE_TB
  zh: '| Amy | 0.0 |'
- en: '| James | 0.0 |'
  id: totrans-326
  prefs: []
  type: TYPE_TB
  zh: '| James | 0.0 |'
- en: As we can see in [Figure 5-9](#betweenness-results-image), Alice is the main
    broker in this network, but Mark and Doug aren’t far behind. In the smaller subgraph
    all shortest paths go through David, so he is important for information flow among
    those nodes.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在[图 5-9](#betweenness-results-image)中所看到的，Alice是这个网络中的主要经纪人，但Mark和Doug也不甚逊色。在较小的子图中，所有最短路径都经过David，因此他在这些节点间的信息流中显得十分重要。
- en: '![gral 0509](Images/gral_0509.png)'
  id: totrans-328
  prefs: []
  type: TYPE_IMG
  zh: '![gral 0509](Images/gral_0509.png)'
- en: Figure 5-9\. Visualization of betweenness centrality
  id: totrans-329
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-9\. 中介中心性可视化
- en: Warning
  id: totrans-330
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: For large graphs, exact centrality computation isn’t practical. The fastest
    known algorithm for exactly computing betweenness of all the nodes has a runtime
    proportional to the product of the number of nodes and the number of relationships.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大型图形，精确计算中心性并不实际。目前已知的最快算法用于精确计算所有节点的中介中心性，其运行时间与节点数和关系数的乘积成正比。
- en: We may want to filter down to a subgraph first or use (described in the next
    section) that works with a subset of nodes.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能希望首先过滤到一个子图，或者使用（在下一节中描述）适用于节点子集的方法。
- en: 'We can join our two disconnected components together by introducing a new user
    called Jason, who follows and is followed by people from both groups of users:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过引入一个名为Jason的新用户，他既关注又被两组用户中的人关注，将我们的两个不相连的组件连接在一起：
- en: '[PRE12]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If we rerun the algorithm we’ll see this output:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们重新运行算法，我们会看到这个输出：
- en: '| user | centrality |'
  id: totrans-336
  prefs: []
  type: TYPE_TB
  zh: '| 用户 | 中心性 |'
- en: '| --- | --- |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Jason | 44.33333333333333 |'
  id: totrans-338
  prefs: []
  type: TYPE_TB
  zh: '| Jason | 44.33333333333333 |'
- en: '| Doug | 18.333333333333332 |'
  id: totrans-339
  prefs: []
  type: TYPE_TB
  zh: '| Doug | 18.333333333333332 |'
- en: '| Alice | 16.666666666666664 |'
  id: totrans-340
  prefs: []
  type: TYPE_TB
  zh: '| Alice | 16.666666666666664 |'
- en: '| Amy | 8.0 |'
  id: totrans-341
  prefs: []
  type: TYPE_TB
  zh: '| Amy | 8.0 |'
- en: '| James | 8.0 |'
  id: totrans-342
  prefs: []
  type: TYPE_TB
  zh: '| James | 8.0 |'
- en: '| Michael | 4.0 |'
  id: totrans-343
  prefs: []
  type: TYPE_TB
  zh: '| Michael | 4.0 |'
- en: '| Mark | 2.1666666666666665 |'
  id: totrans-344
  prefs: []
  type: TYPE_TB
  zh: '| Mark | 2.1666666666666665 |'
- en: '| David | 0.5 |'
  id: totrans-345
  prefs: []
  type: TYPE_TB
  zh: '| David | 0.5 |'
- en: '| Bridget | 0.0 |'
  id: totrans-346
  prefs: []
  type: TYPE_TB
  zh: '| Bridget | 0.0 |'
- en: '| Charles | 0.0 |'
  id: totrans-347
  prefs: []
  type: TYPE_TB
  zh: '| Charles | 0.0 |'
- en: Jason has the highest score because communication between the two sets of users
    will pass through him. Jason can be said to act as a *local bridge* between the
    two sets of users, as illustrated in [Figure 5-10](#betweenness-results2-image).
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 杰森具有最高的分数，因为用户之间的通信将通过他进行。可以说杰森在两组用户之间充当*本地桥梁*，如[图5-10](#betweenness-results2-image)所示。
- en: '![gral 0510](Images/gral_0510.png)'
  id: totrans-349
  prefs: []
  type: TYPE_IMG
  zh: '![gral 0510](Images/gral_0510.png)'
- en: Figure 5-10\. Visualization of betweenness centrality with Jason
  id: totrans-350
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5-10. 介数中心性的可视化，带有杰森
- en: 'Before we move on to the next section, let’s reset our graph by deleting Jason
    and his relationships:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进入下一节之前，让我们通过删除杰森及其关系来重置我们的图：
- en: '[PRE13]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Betweenness Centrality Variation: Randomized-Approximate Brandes'
  id: totrans-353
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介数中心性变化：随机近似Brandes
- en: Recall that calculating the exact betweenness centrality on large graphs can
    be very expensive. We could therefore choose to use an approximation algorithm
    that runs much faster but still provides useful (albeit imprecise) information.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在大型图上计算精确的介数中心性可能非常昂贵。因此，我们可以选择使用运行速度更快但仍提供有用（尽管不精确）信息的近似算法。
- en: 'The Randomized-Approximate Brandes (RA-Brandes for short) algorithm is the
    best-known algorithm for calculating an approximate score for betweenness centrality.
    Rather than calculating the shortest path between every pair of nodes, the RA-Brandes
    algorithm considers only a subset of nodes. Two common strategies for selecting
    the subset of nodes are:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 随机近似Brandes（简称RA-Brandes）算法是计算介数中心性近似分数的最知名算法。与计算每对节点之间的最短路径不同，RA-Brandes算法仅考虑节点的一个子集。选择节点子集的两种常见策略是：
- en: Random
  id: totrans-356
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 随机
- en: 'Nodes are selected uniformly, at random, with a defined probability of selection.
    The default probability is: <math display="inline"><mfrac><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mn>10</mn><mo>(</mo><mi>N</mi><mo>)</mo></mrow>
    <msup><mi>e</mi> <mn>2</mn></msup></mfrac></math> . If the probability is 1, the
    algorithm works the same way as the normal Betweenness Centrality algorithm, where
    all nodes are loaded.'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 节点是均匀地随机选择的，具有定义的选择概率。默认概率为：<math display="inline"><mfrac><mrow><mi>l</mi><mi>o</mi><mi>g</mi><mn>10</mn><mo>(</mo><mi>N</mi><mo>)</mo></mrow>
    <msup><mi>e</mi> <mn>2</mn></msup></mfrac></math> 。如果概率为1，则算法的工作方式与正常介数中心性算法相同，即所有节点都被加载。
- en: Degree
  id: totrans-358
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 度
- en: Nodes are selected randomly, but those whose degree is lower than the mean are
    automatically excluded (i.e., only nodes with a lot of relationships have a chance
    of being visited).
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 节点是随机选择的，但那些度数低于平均值的节点将自动被排除（即，只有具有大量关系的节点才有可能被访问）。
- en: As a further optimization, you could limit the depth used by the Shortest Path
    algorithm, which will then provide a subset of all the shortest paths.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 作为进一步的优化，您可以限制最短路径算法所使用的深度，这将提供所有最短路径的一个子集。
- en: Approximation of Betweenness Centrality with Neo4j
  id: totrans-361
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Neo4j近似介数中心性
- en: 'The following query executes the RA-Brandes algorithm using the random selection
    method:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的查询使用随机选择方法执行RA-Brandes算法：
- en: '[PRE14]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Running this procedure gives the following result:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此过程将得到以下结果：
- en: '| user | centrality |'
  id: totrans-365
  prefs: []
  type: TYPE_TB
  zh: '| 用户 | 中心性 |'
- en: '| --- | --- |'
  id: totrans-366
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Alice | 9.0 |'
  id: totrans-367
  prefs: []
  type: TYPE_TB
  zh: '| Alice | 9.0 |'
- en: '| Mark | 9.0 |'
  id: totrans-368
  prefs: []
  type: TYPE_TB
  zh: '| Mark | 9.0 |'
- en: '| Doug | 4.5 |'
  id: totrans-369
  prefs: []
  type: TYPE_TB
  zh: '| Doug | 4.5 |'
- en: '| David | 2.25 |'
  id: totrans-370
  prefs: []
  type: TYPE_TB
  zh: '| David | 2.25 |'
- en: '| Bridget | 0.0 |'
  id: totrans-371
  prefs: []
  type: TYPE_TB
  zh: '| Bridget | 0.0 |'
- en: '| Charles | 0.0 |'
  id: totrans-372
  prefs: []
  type: TYPE_TB
  zh: '| Charles | 0.0 |'
- en: '| Michael | 0.0 |'
  id: totrans-373
  prefs: []
  type: TYPE_TB
  zh: '| Michael | 0.0 |'
- en: '| Amy | 0.0 |'
  id: totrans-374
  prefs: []
  type: TYPE_TB
  zh: '| Amy | 0.0 |'
- en: '| James | 0.0 |'
  id: totrans-375
  prefs: []
  type: TYPE_TB
  zh: '| James | 0.0 |'
- en: Our top influencers are similar to before, although Mark now has a higher ranking
    than Doug.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的顶级影响者与之前类似，尽管现在马克的排名比道格高。
- en: Due to the random nature of this algorithm, we may see different results each
    time that we run it. On larger graphs this randomness will have less of an impact
    than it does on our small sample graph.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 由于此算法的随机性质，每次运行它时我们可能会看到不同的结果。在更大的图中，这种随机性对我们的小样本图的影响会较小。
- en: PageRank
  id: totrans-378
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: PageRank
- en: PageRank is the best known of the centrality algorithms. It measures the transitive
    (or directional) influence of nodes. All the other centrality algorithms we discuss
    measure the direct influence of a node, whereas PageRank considers the influence
    of a node’s neighbors, and their neighbors. For example, having a few very powerful
    friends can make you more influential than having a lot of less powerful friends.
    PageRank is computed either by iteratively distributing one node’s rank over its
    neighbors or by randomly traversing the graph and counting the frequency with
    which each node is hit during these walks.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: PageRank是最为人所知的中心性算法。它衡量节点的传递（或方向性）影响力。我们讨论的所有其他中心性算法都衡量节点的直接影响力，而PageRank考虑了节点及其邻居的影响力。例如，拥有几个非常强大的朋友可能比拥有许多不那么强大的朋友更有影响力。PageRank的计算方式可以通过将一个节点的排名迭代地分配到其邻居上，或者通过随机遍历图形并计算每个节点在这些遍历中被击中的频率来进行。
- en: PageRank is named after Google cofounder Larry Page, who created it to rank
    websites in Google’s search results. The basic assumption is that a page with
    more incoming and more influential incoming links is more likely a credible source.
    PageRank measures the number and quality of incoming relationships to a node to
    determine an estimation of how important that node is. Nodes with more sway over
    a network are presumed to have more incoming relationships from other influential
    nodes.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: PageRank以Google联合创始人拉里·佩奇命名，他创建了这个算法来排名Google搜索结果中的网页。基本假设是，具有更多且更有影响力的传入链接的页面更可能是可信来源。PageRank通过计算节点的传入关系数量和质量来估计节点的重要性。在网络中具有更多影响力的节点被认为具有更多来自其他有影响力节点的传入关系。
- en: Influence
  id: totrans-381
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 影响力
- en: The intuition behind influence is that relationships to more important nodes
    contribute more to the influence of the node in question than equivalent connections
    to less important nodes. Measuring influence usually involves scoring nodes, often
    with weighted relationships, and then updating the scores over many iterations.
    Sometimes all nodes are scored, and sometimes a random selection is used as a
    representative distribution.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 影响力的直觉在于，与更重要节点的关系比与等价连接到不太重要的节点的关系对节点影响力的贡献更大。衡量影响力通常涉及对节点进行评分，通常使用加权关系，并在许多迭代中更新这些评分。有时对所有节点进行评分，有时则使用随机选择作为代表性分布。
- en: Note
  id: totrans-383
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Keep in mind that centrality measures represent the importance of a node in
    comparison to other nodes. Centrality is a ranking of the potential impact of
    nodes, not a measure of actual impact. For example, you might identify the two
    people with the highest centrality in a network, but perhaps policies or cultural
    norms are in play that actually shift influence to others. Quantifying actual
    impact is an active research area to develop additional influence metrics.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，中心性度量表示节点在与其他节点比较时的重要性。中心性是节点潜在影响力的排名，而不是实际影响力的度量。例如，您可能会识别网络中两个具有最高中心性的人，但也许会因政策或文化规范的影响而将实际影响力转移给其他人。量化实际影响力是一个积极的研究领域，以开发额外的影响力度量指标。
- en: The PageRank Formula
  id: totrans-385
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PageRank公式
- en: 'PageRank is defined in the original Google paper as follows:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: PageRank在原始的Google论文中被定义如下：
- en: <math display="block"><mrow><mi>P</mi> <mi>R</mi> <mrow><mo>(</mo> <mi>u</mi>
    <mo>)</mo></mrow> <mo>=</mo> <mrow><mo>(</mo> <mn>1</mn> <mo>-</mo> <mi>d</mi>
    <mo>)</mo></mrow> <mo>+</mo> <mi>d</mi> <mrow><mo>(</mo> <mfrac><mrow><mi>P</mi><mi>R</mi><mo>(</mo><mi>T</mi><mn>1</mn><mo>)</mo></mrow>
    <mrow><mi>C</mi><mo>(</mo><mi>T</mi><mn>1</mn><mo>)</mo></mrow></mfrac> <mo>+</mo>
    <mo>.</mo> <mo>.</mo> <mo>.</mo> <mo>+</mo> <mfrac><mrow><mi>P</mi><mi>R</mi><mo>(</mo><mi>T</mi><mi>n</mi><mo>)</mo></mrow>
    <mrow><mi>C</mi><mo>(</mo><mi>T</mi><mi>n</mi><mo>)</mo></mrow></mfrac> <mo>)</mo></mrow></mrow></math>
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: <math display="block"><mrow><mi>P</mi> <mi>R</mi> <mrow><mo>(</mo> <mi>u</mi>
    <mo>)</mo></mrow> <mo>=</mo> <mrow><mo>(</mo> <mn>1</mn> <mo>-</mo> <mi>d</mi>
    <mo>)</mo></mrow> <mo>+</mo> <mi>d</mi> <mrow><mo>(</mo> <mfrac><mrow><mi>P</mi><mi>R</mi><mo>(</mo><mi>T</mi><mn>1</mn><mo>)</mo></mrow>
    <mrow><mi>C</mi><mo>(</mo><mi>T</mi><mn>1</mn><mo>)</mo></mrow></mfrac> <mo>+</mo>
    <mo>.</mo> <mo>.</mo> <mo>.</mo> <mo>+</mo> <mfrac><mrow><mi>P</mi><mi>R</mi><mo>(</mo><mi>T</mi><mi>n</mi><mo>)</mo></mrow>
    <mrow><mi>C</mi><mo>(</mo><mi>T</mi><mi>n</mi><mo>)</mo></mrow></mfrac> <mo>)</mo></mrow></mrow></math>
- en: 'where:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 'where:'
- en: We assume that a page *u* has citations from pages *T1* to *Tn*.
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们假设页面 *u* 有来自页面 *T1* 到 *Tn* 的引用。
- en: '*d* is a damping factor which is set between 0 and 1\. It is usually set to
    0.85\. You can think of this as the probability that a user will continue clicking.
    This helps minimize rank sink, explained in the next section.'
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*d* 是一个阻尼因子，其取值范围在0到1之间。通常设为0.85。您可以将其视为用户继续点击的概率。这有助于最小化排名沉降，在下一节中有详细解释。'
- en: '*1-d* is the probability that a node is reached directly without following
    any relationships.'
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*1-d* 是节点直接到达而不遵循任何关系的概率。'
- en: '*C(Tn)* is defined as the out-degree of a node *T*.'
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*C(Tn)* 定义为节点 *T* 的出度。'
- en: '[Figure 5-11](#pagerank-calculation-image) walks through a small example of
    how PageRank will continue to update the rank of a node until it converges or
    meets the set number of iterations.'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 5-11](#pagerank-calculation-image)演示了PageRank如何持续更新节点的排名，直到收敛或达到设定的迭代次数。'
- en: '![gral 0511](Images/gral_0511.png)'
  id: totrans-394
  prefs: []
  type: TYPE_IMG
  zh: '![gral 0511](Images/gral_0511.png)'
- en: 'Figure 5-11\. Each iteration of PageRank has two calculation steps: one to
    update node values and one to update link values.'
  id: totrans-395
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-11。每次PageRank迭代包括两个计算步骤：更新节点值和更新链接值。
- en: Iteration, Random Surfers, and Rank Sinks
  id: totrans-396
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 迭代、随机游客和排名沉降
- en: PageRank is an iterative algorithm that runs either until scores converge or
    until a set number of iterations is reached.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: PageRank 是一种迭代算法，运行直到分数收敛或达到设定的迭代次数为止。
- en: Conceptually, PageRank assumes there is a web surfer visiting pages by following
    links or by using a random URL. A damping factor _d _ defines the probability
    that the next click will be through a link. You can think of it as the probability
    that a surfer will become bored and randomly switch to another page. A PageRank
    score represents the likelihood that a page is visited through an incoming link
    and not randomly.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 在概念上，PageRank 假定有一个网络冲浪者通过跟随链接或使用随机 URL 访问页面。阻尼因子 _d _ 定义了下一次点击将通过链接进行的概率。您可以将其视为冲浪者变得厌倦并随机切换到另一页的概率。PageRank
    分数表示通过入站链接访问页面的可能性，而不是随机访问。
- en: A node, or group of nodes, without outgoing relationships (also called a *dangling
    node*) can monopolize the PageRank score by refusing to share. This is known as
    a *rank sink*. You can imagine this as a surfer that gets stuck on a page, or
    a subset of pages, with no way out. Another difficulty is created by nodes that
    point only to each other in a group. Circular references cause an increase in
    their ranks as the surfer bounces back and forth among the nodes. These situations
    are portrayed in [Figure 5-12](#ranksink-image).
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 没有输出关系的一个或一组节点（也称为*dangling node*）可以通过拒绝分享来垄断 PageRank 分数。这被称为*排名汇聚*。您可以将其想象成一个冲浪者被困在一个或一组没有出口的页面上。还有另一个困难是由指向同一组中其他节点的节点引起的。循环引用导致冲浪者在节点之间来回跳动，这会增加它们的排名。这些情况在
    [图 5-12](#ranksink-image) 中描述。
- en: '![gral 0512](Images/gral_0512.png)'
  id: totrans-400
  prefs: []
  type: TYPE_IMG
  zh: '![gral 0512](Images/gral_0512.png)'
- en: Figure 5-12\. Rank sink is caused by a node, or group of nodes, without outgoing
    relationships.
  id: totrans-401
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-12\. 排名汇聚是由一个或一组没有输出关系的节点引起的。
- en: There are two strategies used to avoid rank sinks. First, when a node is reached
    that has no outgoing relationships, PageRank assumes outgoing relationships to
    all nodes. Traversing these invisible links is sometimes called *teleportation*.
    Second, the damping factor provides another opportunity to avoid sinks by introducing
    a probability for direct link versus random node visitation. When you set *d*
    to 0.85, a completely random node is visited 15% of the time.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种策略用于避免排名汇聚。首先，当到达没有输出关系的节点时，PageRank 假设到所有节点的输出关系。有时称为*传送*这些看不见的链接。其次，阻尼因子提供了另一个机会，通过引入直接链接与随机节点访问的概率来避免汇聚。当您将
    *d* 设置为 0.85 时，完全随机节点被访问的概率为 15%。
- en: Although the original formula recommends a damping factor of 0.85, its initial
    use was on the World Wide Web with a power-law distribution of links (most pages
    have very few links and a few pages have many). Lowering the damping factor decreases
    the likelihood of following long relationship paths before taking a random jump.
    In turn, this increases the contribution of a node’s immediate predecessors to
    its score and rank.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管原始公式建议阻尼因子为 0.85，但最初用于具有幂律分布链接（大多数页面有很少的链接，少数页面有很多）的万维网。降低阻尼因子会减少在进行随机跳转之前遵循长关系路径的可能性。反过来，这增加了节点的直接前驱对其得分和排名的贡献。
- en: If you see unexpected results from PageRank, it is worth doing some exploratory
    analysis of the graph to see if any of these problems are the cause. Read Ian
    Rogers’s article, [“The Google PageRank Algorithm and How It Works”](http://bit.ly/2TYSaeQ)
    to learn more.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 如果从 PageRank 看到意外结果，值得对图进行一些探索性分析，看看是否有这些问题的原因。阅读 Ian Rogers 的文章，[“Google PageRank
    算法及其工作原理”](http://bit.ly/2TYSaeQ) 了解更多信息。
- en: When Should I Use PageRank?
  id: totrans-405
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 何时使用 PageRank？
- en: PageRank is now used in many domains outside web indexing. Use this algorithm
    whenever you’re looking for broad influence over a network. For instance, if you’re
    looking to target a gene that has the highest overall impact to a biological function,
    it may not be the most connected one. It may, in fact, be the gene with the most
    relationships with other, more significant functions.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: PageRank 现在被广泛应用于除网络索引之外的许多领域。每当您需要在网络上获得广泛影响时，请使用这种算法。例如，如果您正在寻找对生物功能具有最高整体影响力的基因，那么这可能不是连接最多的基因。事实上，它可能是与其他更重要功能关系最多的基因。
- en: 'Example use cases include:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 示例用例包括：
- en: 'Presenting users with recommendations of other accounts that they may wish
    to follow (Twitter uses Personalized PageRank for this). The algorithm is run
    over a graph that contains shared interests and common connections. The approach
    is described in more detail in the paper [“WTF: The Who to Follow Service at Twitter”](https://stanford.io/2ux00wZ),
    by P. Gupta et al.'
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '向用户推荐可能感兴趣的其他账户（Twitter使用Personalized PageRank实现此目的）。该算法在包含共同兴趣和共同连接的图上运行。该方法在P.
    Gupta等人的论文[“WTF: The Who to Follow Service at Twitter”](https://stanford.io/2ux00wZ)中有详细描述。'
- en: 'Predicting traffic flow and human movement in public spaces or streets. The
    algorithm is run over a graph of road intersections, where the PageRank score
    reflects the tendency of people to park, or end their journey, on each street.
    This is described in more detail in [“Self-Organized Natural Roads for Predicting
    Traffic Flow: A Sensitivity Study”](https://bit.ly/2usHENZ), a paper by B. Jiang,
    S. Zhao, and J. Yin.'
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预测公共空间或街道中的交通流量和人员移动。该算法在道路交叉口的图上运行，其中PageRank分数反映了人们在每条街道上停车或结束旅程的倾向。详细内容请参阅B.
    Jiang、S. Zhao和J. Yin的论文[“自组织自然道路预测交通流：敏感性研究”](https://bit.ly/2usHENZ)。
- en: As part of anomaly and fraud detection systems in the healthcare and insurance
    industries. PageRank helps reveal doctors or providers that are behaving in an
    unusual manner, and the scores are then fed into a machine learning algorithm.
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在医疗保健和保险行业的异常检测系统中。PageRank有助于揭示行为异常的医生或供应商，并将分数输入到机器学习算法中。
- en: David Gleich describes many more uses for the algorithm in his paper, [“PageRank
    Beyond the Web”](https://bit.ly/2JCYi80).
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 大卫·格莱希在他的论文中描述了算法的更多用途，[“PageRank超越Web”](https://bit.ly/2JCYi80)。
- en: PageRank with Apache Spark
  id: totrans-412
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Apache Spark的PageRank
- en: 'Now we’re ready to execute the PageRank algorithm. GraphFrames supports two
    implementations of PageRank:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备执行PageRank算法。GraphFrames支持两种PageRank的实现：
- en: The first implementation runs PageRank for a fixed number of iterations. This
    can be run by setting the `maxIter` parameter.
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一种实现运行固定次数的PageRank。可以通过设置`maxIter`参数来运行。
- en: The second implementation runs PageRank until convergence. This can be run by
    setting the `tol` parameter.
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二种实现运行PageRank直到收敛。可以通过设置`tol`参数来运行。
- en: PageRank with a fixed number of iterations
  id: totrans-416
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 固定次数迭代的PageRank
- en: 'Let’s see an example of the fixed iterations approach:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个固定迭代方法的例子：
- en: '[PRE15]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Tip
  id: totrans-419
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: Tip
- en: Notice in Spark that the damping factor is more intuitively called the *reset
    probability*, with the inverse value. In other words, `resetProbability=0.15`
    in this example is equivalent to `dampingFactor:0.85` in Neo4j.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 在Spark中请注意，阻尼因子更直观地称为*重置概率*，其值的倒数。换句话说，在本例中`resetProbability=0.15`等效于Neo4j中的`dampingFactor:0.85`。
- en: 'If we run that code in pyspark we’ll see this output:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在pyspark中运行该代码，我们将看到以下输出：
- en: '| id | pageRank |'
  id: totrans-422
  prefs: []
  type: TYPE_TB
  zh: '| id | pageRank |'
- en: '| --- | --- |'
  id: totrans-423
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Doug | 2.2865372087512252 |'
  id: totrans-424
  prefs: []
  type: TYPE_TB
  zh: '| 道格 | 2.2865372087512252 |'
- en: '| Mark | 2.1424484186137263 |'
  id: totrans-425
  prefs: []
  type: TYPE_TB
  zh: '| 马克 | 2.1424484186137263 |'
- en: '| Alice | 1.520330830262095 |'
  id: totrans-426
  prefs: []
  type: TYPE_TB
  zh: '| 爱丽丝 | 1.520330830262095 |'
- en: '| Michael | 0.7274429252585624 |'
  id: totrans-427
  prefs: []
  type: TYPE_TB
  zh: '| 迈克尔 | 0.7274429252585624 |'
- en: '| Bridget | 0.7274429252585624 |'
  id: totrans-428
  prefs: []
  type: TYPE_TB
  zh: '| 布里奇特 | 0.7274429252585624 |'
- en: '| Charles | 0.5213852310709753 |'
  id: totrans-429
  prefs: []
  type: TYPE_TB
  zh: '| 查尔斯 | 0.5213852310709753 |'
- en: '| Amy | 0.5097143486157744 |'
  id: totrans-430
  prefs: []
  type: TYPE_TB
  zh: '| 艾米 | 0.5097143486157744 |'
- en: '| David | 0.36655842368870073 |'
  id: totrans-431
  prefs: []
  type: TYPE_TB
  zh: '| 大卫 | 0.36655842368870073 |'
- en: '| James | 0.1981396884803788 |'
  id: totrans-432
  prefs: []
  type: TYPE_TB
  zh: '| 詹姆斯 | 0.1981396884803788 |'
- en: As we might expect, Doug has the highest PageRank because he is followed by
    all other users in his subgraph. Although Mark only has one follower, that follower
    is Doug, so Mark is also considered important in this graph. It’s not only the
    number of followers that is important, but also the importance of those followers.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所预料的那样，道格的PageRank最高，因为他被其子图中的所有其他用户关注。尽管马克只有一个关注者，但那个关注者是道格，所以在这个图中马克也被认为很重要。重要的不仅仅是关注者的数量，还包括这些关注者的重要性。
- en: Tip
  id: totrans-434
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: Tip
- en: The relationships in the graph on which we ran the PageRank algorithm don’t
    have weights, so each relationship is considered equal. Relationship weights are
    added by specifying a `weight` column in the relationships DataFrame.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 我们运行PageRank算法的图中的关系没有权重，因此每个关系被视为平等。通过在关系DataFrame中指定`weight`列来添加关系权重。
- en: PageRank until convergence
  id: totrans-436
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 直到PageRank收敛为止
- en: 'And now let’s try the convergence implementation that will run PageRank until
    it closes in on a solution within the set tolerance:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们尝试收敛实现，这将在设定的容差范围内运行PageRank算法：
- en: '[PRE16]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If we run that code in pyspark we’ll see this output:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在pyspark中运行该代码，我们将看到以下输出：
- en: '| id | pageRank |'
  id: totrans-440
  prefs: []
  type: TYPE_TB
  zh: '| id | pageRank |'
- en: '| --- | --- |'
  id: totrans-441
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Doug | 2.2233188859989745 |'
  id: totrans-442
  prefs: []
  type: TYPE_TB
  zh: '| Doug | 2.2233188859989745 |'
- en: '| Mark | 2.090451188336932 |'
  id: totrans-443
  prefs: []
  type: TYPE_TB
  zh: '| Mark | 2.090451188336932 |'
- en: '| Alice | 1.5056291439101062 |'
  id: totrans-444
  prefs: []
  type: TYPE_TB
  zh: '| Alice | 1.5056291439101062 |'
- en: '| Michael | 0.733738785109624 |'
  id: totrans-445
  prefs: []
  type: TYPE_TB
  zh: '| Michael | 0.733738785109624 |'
- en: '| Bridget | 0.733738785109624 |'
  id: totrans-446
  prefs: []
  type: TYPE_TB
  zh: '| Bridget | 0.733738785109624 |'
- en: '| Amy | 0.559446807245026 |'
  id: totrans-447
  prefs: []
  type: TYPE_TB
  zh: '| Amy | 0.559446807245026 |'
- en: '| Charles | 0.5338811076334145 |'
  id: totrans-448
  prefs: []
  type: TYPE_TB
  zh: '| Charles | 0.5338811076334145 |'
- en: '| David | 0.40232326274180685 |'
  id: totrans-449
  prefs: []
  type: TYPE_TB
  zh: '| David | 0.40232326274180685 |'
- en: '| James | 0.21747203391449021 |'
  id: totrans-450
  prefs: []
  type: TYPE_TB
  zh: '| James | 0.21747203391449021 |'
- en: The `PageRank` scores for each person are slightly different than with the fixed
    number of iterations variant, but as we would expect, their order remains the
    same.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 每个人的`PageRank`分数与固定迭代次数变体稍有不同，但预期中，它们的排序仍然相同。
- en: Tip
  id: totrans-452
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Although convergence on a perfect solution may sound ideal, in some scenarios
    PageRank cannot mathematically converge. For larger graphs, PageRank execution
    may be prohibitively long. A tolerance limit helps set an acceptable range for
    a converged result, but many choose to use (or combine this approach with) the
    maximum iteration option instead. The maximum iteration setting will generally
    provide more performance consistency. Regardless of which option you choose, you
    may need to test several different limits to find what works for your dataset.
    Larger graphs typcially require more iterations or smaller tolerance than medium-sized
    graphs for better accuracy.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在完美解决方案上的收敛听起来理想，但在某些情况下，PageRank 无法数学上收敛。对于更大的图，PageRank 的执行可能过长。容差限制有助于设定收敛结果的可接受范围，但许多人选择使用（或将其与）最大迭代选项结合使用。通常情况下，最大迭代设置将提供更稳定的性能。无论选择哪种选项，您可能需要测试几种不同的限制以找到适合您数据集的方法。对于更大的图形，为了获得更好的准确性，通常需要更多的迭代或更小的容差。
- en: PageRank with Neo4j
  id: totrans-454
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Neo4j 的 PageRank
- en: 'We can also run PageRank in Neo4j. A call to the following procedure will calculate
    the PageRank for each of the nodes in our graph:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在 Neo4j 中运行 PageRank。调用以下过程将计算图中每个节点的 PageRank：
- en: '[PRE17]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Running this procedure gives the following result:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此过程会得到以下结果：
- en: '| page | score |'
  id: totrans-458
  prefs: []
  type: TYPE_TB
  zh: '| page | score |'
- en: '| --- | --- |'
  id: totrans-459
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Doug | 1.6704119999999998 |'
  id: totrans-460
  prefs: []
  type: TYPE_TB
  zh: '| Doug | 1.6704119999999998 |'
- en: '| Mark | 1.5610085 |'
  id: totrans-461
  prefs: []
  type: TYPE_TB
  zh: '| Mark | 1.5610085 |'
- en: '| Alice | 1.1106700000000003 |'
  id: totrans-462
  prefs: []
  type: TYPE_TB
  zh: '| Alice | 1.1106700000000003 |'
- en: '| Bridget | 0.535373 |'
  id: totrans-463
  prefs: []
  type: TYPE_TB
  zh: '| Bridget | 0.535373 |'
- en: '| Michael | 0.535373 |'
  id: totrans-464
  prefs: []
  type: TYPE_TB
  zh: '| Michael | 0.535373 |'
- en: '| Amy | 0.385875 |'
  id: totrans-465
  prefs: []
  type: TYPE_TB
  zh: '| Amy | 0.385875 |'
- en: '| Charles | 0.3844895 |'
  id: totrans-466
  prefs: []
  type: TYPE_TB
  zh: '| Charles | 0.3844895 |'
- en: '| David | 0.2775 |'
  id: totrans-467
  prefs: []
  type: TYPE_TB
  zh: '| David | 0.2775 |'
- en: '| James | 0.15000000000000002 |'
  id: totrans-468
  prefs: []
  type: TYPE_TB
  zh: '| James | 0.15000000000000002 |'
- en: As with the Spark example, Doug is the most influential user, and Mark follows
    closely after as the only user that Doug follows. We can see the importance of
    the nodes relative to each other in [Figure 5-13](#pagerank-results-image).
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Spark 示例一样，Doug 是最有影响力的用户，而 Mark 紧随其后，作为 Doug 关注的唯一用户。我们可以在 [Figure 5-13](#pagerank-results-image)
    中看到节点的相对重要性。
- en: Note
  id: totrans-470
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: PageRank implementations vary, so they can produce different scoring even when
    the ordering is the same. Neo4j initializes nodes using a value of 1 minus the
    dampening factor whereas Spark uses a value of 1. In this case, the relative rankings
    (the goal of PageRank) are identical but the underlying score values used to reach
    those results are different.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: PageRank 的实现因而会产生不同的分数，即使排序相同。Neo4j 初始化节点时使用的是减去阻尼因子的值为1，而 Spark 则使用值为1。在这种情况下，相对排名（PageRank
    的目标）是相同的，但用于达到这些结果的基础分数值是不同的。
- en: '![gral 0513](Images/gral_0513.png)'
  id: totrans-472
  prefs: []
  type: TYPE_IMG
  zh: '![gral 0513](Images/gral_0513.png)'
- en: Figure 5-13\. Visualization of PageRank
  id: totrans-473
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-13\. PageRank 的可视化
- en: Tip
  id: totrans-474
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: 'As with our Spark example, the relationships in the graph on which we ran the
    PageRank algorithm don’t have weights, so each relationship is considered equal.
    Relationship weights can be considered by including the `weightProperty` property
    in the config passed to the PageRank procedure. For example, if relationships
    have a property `weight` containing weights, we would pass the following config
    to the procedure: `weightProperty: "weight"`.'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: '与我们的 Spark 示例类似，我们在其中运行 PageRank 算法的图中的关系没有权重，因此每个关系被视为平等。通过在传递给 PageRank 过程的配置中包含
    `weightProperty` 属性，可以考虑关系权重。例如，如果关系具有包含权重的属性 `weight`，则我们将以下配置传递给过程：`weightProperty:
    "weight"`。'
- en: 'PageRank Variation: Personalized PageRank'
  id: totrans-476
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PageRank 变种：个性化 PageRank
- en: Personalized PageRank (PPR) is a variant of the PageRank algorithm that calculates
    the importance of nodes in a graph from the perspective of a specific node. For
    PPR, random jumps refer back to a given set of starting nodes. This biases results
    toward, or personalizes for, the start node. This bias and localization make PPR
    useful for highly targeted recommendations.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 个性化PageRank（PPR）是PageRank算法的一种变体，它从特定节点的视角计算图中节点的重要性。对于PPR，随机跳转会回到给定的一组起始节点。这种偏见和本地化使PPR对高度定向的推荐非常有用。
- en: Personalized PageRank with Apache Spark
  id: totrans-478
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Apache Spark的个性化PageRank
- en: 'We can calculate the personalized PageRank score for a given node by passing
    in the `sourceId` parameter. The following code calculates the PPR for Doug:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 通过传递`sourceId`参数，我们可以计算给定节点的个性化PageRank分数。以下代码计算了Doug的PPR：
- en: '[PRE18]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The results of this query could be used to make recommendations for people who
    Doug should follow. Notice that we are also making sure that we exclude people
    who Doug already follows, as well as himself, from our final result.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 此查询的结果可用于为Doug应该关注的人提供建议。请注意，我们还确保从最终结果中排除Doug已经关注的人，以及他自己。
- en: 'If we run that code in pyspark we’ll see this output:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在pyspark中运行该代码，我们会看到以下输出：
- en: '| id | pageRank |'
  id: totrans-483
  prefs: []
  type: TYPE_TB
  zh: '| id | pageRank |'
- en: '| --- | --- |'
  id: totrans-484
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Alice | 0.1650183746272782 |'
  id: totrans-485
  prefs: []
  type: TYPE_TB
  zh: '| 爱丽丝 | 0.1650183746272782 |'
- en: '| Michael | 0.048842467744891996 |'
  id: totrans-486
  prefs: []
  type: TYPE_TB
  zh: '| 迈克尔 | 0.048842467744891996 |'
- en: '| Bridget | 0.048842467744891996 |'
  id: totrans-487
  prefs: []
  type: TYPE_TB
  zh: '| 布里奇特 | 0.048842467744891996 |'
- en: '| Charles | 0.03497796119878669 |'
  id: totrans-488
  prefs: []
  type: TYPE_TB
  zh: '| 查尔斯 | 0.03497796119878669 |'
- en: '| David | 0.0 |'
  id: totrans-489
  prefs: []
  type: TYPE_TB
  zh: '| 大卫 | 0.0 |'
- en: '| James | 0.0 |'
  id: totrans-490
  prefs: []
  type: TYPE_TB
  zh: '| 詹姆斯 | 0.0 |'
- en: '| Amy | 0.0 |'
  id: totrans-491
  prefs: []
  type: TYPE_TB
  zh: '| 艾米 | 0.0 |'
- en: Alice is the best suggestion for somebody that Doug should follow, but we might
    suggest Michael and Bridget as well.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Doug应该关注的人，爱丽丝是最好的建议，但我们也可以建议迈克尔和布里奇特。
- en: Summary
  id: totrans-493
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'Centrality algorithms are an excellent tool for identifying influencers in
    a network. In this chapter we’ve learned about the prototypical centrality algorithms:
    Degree Centrality, Closeness Centrality, Betweenness Centrality, and PageRank.
    We’ve also covered several variations to deal with issues such as long runtimes
    and isolated components, as well as options for alternative uses.'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 中心性算法是识别网络中的影响者的一个优秀工具。在本章中，我们学习了典型的中心性算法：度中心性、接近度中心性、介数中心性和PageRank。我们还涵盖了多种变体，以解决长运行时间和孤立组件的问题，以及替代用途的选项。
- en: There are many wide-ranging uses for centrality algorithms, and we encourage
    their exploration for a variety of analyses. You can apply what we’ve learned
    to locate optimal touch points for disseminating information, find the hidden
    brokers that control the flow of resources, and uncover the indirect power players
    lurking in the shadows.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 中心性算法有许多广泛的用途，我们鼓励对其进行多方面的探索分析。你可以应用我们所学的知识来找到传播信息的最佳接触点，找到控制资源流动的隐藏经纪人，并揭示潜伏在阴影中的间接势力者。
- en: Next, we’ll turn to community detection algorithms that look at groups and partitions.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将转向研究关注组和分区的社区检测算法。
