- en: 4  Middleware
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4 中间件
- en: Without any framework like Express, Node.js gives you a pretty simple API. Create
    a function that handles requests, pass it to `http.createServer`, and call it
    a day. While this API is simple, your request handler function can get unwieldy
    as your app grows.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有像 Express 这样的框架的情况下，Node.js 给你一个相当简单的 API。创建一个处理请求的函数，将其传递给 `http.createServer`，然后就可以使用了。虽然这个
    API 很简单，但随着你的应用程序的增长，你的请求处理函数可能会变得难以控制。
- en: Express helps to mitigate some of these issues. One of the ways it does this
    is through the use of something called middleware. Where framework-free Node has
    you writing a single large request handler function for your entire app, middleware
    allows you to break these request handler functions into smaller bits. These smaller
    functions tend to handle one thing at a time. One might log all of the requests
    that come into your server; another might parse special values of incoming requests;
    another might authenticate users.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Express 通过使用称为中间件的东西来帮助缓解这些问题。它这样做的一种方式是，对于没有框架的 Node，它让你为整个应用程序编写一个单一的大型请求处理函数，而中间件允许你将这些请求处理函数分解成更小的部分。这些较小的函数通常一次处理一件事情。一个可能会记录所有进入服务器的请求；另一个可能会解析传入请求的特殊值；另一个可能会验证用户身份。
- en: 'In this chapter, we''ll learn:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习：
- en: ·  What middleware is
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: ·  中间件是什么
- en: ·  How a request flows through Express middleware; the "middleware stack"
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: ·  请求如何通过 Express 中间件；"中间件栈"
- en: ·  How to use middleware
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: ·  如何使用中间件
- en: ·  How to write your own middleware
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: ·  如何编写你自己的中间件
- en: ·  Helpful third-party Express middleware
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: ·  有用的第三方 Express 中间件
- en: Conceptually, middleware is the biggest part of Express. At the end of the day,
    most of the Express code you write is middleware in one way or another. Hopefully,
    after this chapter, you'll see why!
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 从概念上讲，中间件是 Express 的最大部分。最终，你写的绝大多数 Express 代码都是以某种方式作为中间件。希望在本章之后，你会明白为什么！
- en: 4.1     Middleware and the middleware stack
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.1 中间件和中间件栈
- en: At the end of the day, web servers listen for requests, parse those requests,
    and send responses.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，Web 服务器监听请求，解析这些请求，并发送响应。
- en: 'The Node runtime will get these requests first. It''ll turn those requests
    from raw bytes into two JavaScript objects that you can handle: one object for
    the request and one object for the response. Conventionally, the request object
    is called`req` and the response object is called `res`.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Node 运行时首先获取这些请求。它将那些请求从原始字节转换为你可以处理的两个 JavaScript 对象：一个用于请求，一个用于响应。传统上，请求对象称为
    `req`，响应对象称为 `res`。
- en: '![](../Images/04_01.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/04_01.png)'
- en: 'Figure 4.1: When working with node.js by itself, we have one function that
    gives us a request object representing the incoming request and a response object
    representing the response node should send back to the client.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1：当单独使用 node.js 时，我们有一个函数，它提供了一个表示传入请求的请求对象和一个表示节点应发送回客户端的响应对象的响应对象。
- en: These two objects will be sent to a JavaScript function that you'll write. You'll
    parse `req` to see what the user wants and manipulate `res` to prepare your response.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个对象将被发送到你将编写的 JavaScript 函数。你将解析 `req` 来查看用户想要什么，并通过操作 `res` 来准备你的响应。
- en: After awhile, you're done writing to the response. When that's happened, you'll
    call `res.end`. This signals to Node that the response is all done and ready to
    be sent over the wire. The Node runtime will see what you've done to the response
    object, turn it into another bundle of bytes, and send it over the Internet to
    whoever requested it.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一段时间后，你将完成对响应的写入。当这种情况发生时，你会调用 `res.end`。这向 Node 发出信号，表示响应已经全部完成，准备好通过网络发送。Node
    运行时会查看你对响应对象所做的操作，将其转换为另一组字节，并通过互联网发送给请求者。
- en: In Node, these two objects are passed through just one function. In Express,
    however, these objects are passed through an array of functions, called the middleware
    stack. Express will start at the first function in the stack and continue in order
    down the stack.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Node 中，这两个对象只通过一个函数传递。然而，在 Express 中，这些对象通过一个函数数组传递，称为中间件栈。Express 将从栈中的第一个函数开始，并按顺序向下执行。
- en: '![](../Images/04_02.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/04_02.png)'
- en: Figure 4.2 When working in Express, the one request handler function is replaced
    with a stack of middleware functions instead.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2 在 Express 中工作，一个请求处理函数被替换为中间件函数栈。
- en: Every function in this stack takes three arguments. The first two are the request
    and the response objects from before. They're given to us by Node, although Express
    decorates them with a few extra convenience features that we discussed in the
    previous chapter.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 堆栈中的每个函数都接受三个参数。前两个是之前的请求和响应对象。它们由 Node 提供，尽管 Express 在前一章中讨论的额外便利功能中装饰了它们。
- en: The third argument to each of these functions is itself a function (conventionally
    called `next`). When `next` is called, Express will go on to the next function
    in the stack.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数的第三个参数本身也是一个函数（通常称为 `next`）。当调用 `next` 时，Express 将继续到堆栈中的下一个函数。
- en: '![](../Images/04_03.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/04_03.png)'
- en: 'Figure 4.3: All middleware functions have the same signature with three functions:
    response, request and next.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '图 4.3：所有中间件函数具有相同的签名，包含三个函数：响应、请求和下一个。 '
- en: Eventually, one of these functions in the stack must call `res.end`, which will
    end the request. (In Express, you can also call some other methods like `res.send` or `res.sendFile`,
    but these call `res.end` internally.) You can call `res.end` in any of the functions
    in the middleware stack, but you must only do it once or you'll get an error.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，堆栈中的这些函数之一必须调用 `res.end`，这将结束请求。（在 Express 中，你也可以调用一些其他方法，如 `res.send` 或
    `res.sendFile`，但它们内部调用 `res.end`。）你可以在中间件堆栈中的任何函数中调用 `res.end`，但你只能调用一次，否则你会得到一个错误。
- en: This might be a little abstract and foggy. Let's see an example of how this
    works by building ourselves a static file server.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能有点抽象和模糊。让我们通过构建自己的静态文件服务器来查看这个例子是如何工作的。
- en: '4.2     Example app: a static file server'
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.2 示例应用：静态文件服务器
- en: Let's build ourselves a simple little application that serves files from a folder.
    You can put anything in this folder and it'll be served—HTML files, images, or
    an MP3 of yourself singing "My Heart Will Go On" by Celine Dion.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建一个简单的应用程序，从文件夹中提供文件。你可以在这个文件夹中放置任何东西，它将被提供——HTML 文件、图片，或者你唱的 Celine Dion
    的 "My Heart Will Go On" 的 MP3。
- en: This folder will be called "static" and it will live in our project’s directory.
    If there's a file called `celine.mp3` and a user visits `/celine.mp3`, our server
    should send that MP3 over the internet. If the user requests `/burrito.html` no
    such file exists in the folder, our server should send a 404 error.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件夹将被称为 "static" 并位于我们的项目目录中。如果有一个名为 `celine.mp3` 的文件，并且用户访问 `/celine.mp3`，我们的服务器应该通过互联网发送那个
    MP3 文件。如果用户请求 `/burrito.html`，文件夹中不存在这样的文件，我们的服务器应该发送一个 404 错误。
- en: 'Another requirement: our server should log every request, whether it''s successful
    or not. It should log the URL that the user requested with the time that they
    requested it.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个要求：我们的服务器应该记录每个请求，无论成功与否。它应该记录用户请求的 URL 和请求的时间。
- en: 'This Express application will be made up of three functions on the middleware
    stack:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 Express 应用程序将由中间件堆栈上的三个函数组成：
- en: 1.  The logger. This will output the requested URL and the time it was requested
    to the console. It'll always continue onto the next middleware (in terms of code,
    it'll always call `next`).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 记录器。这将把请求的 URL 和请求的时间输出到控制台。它将始终继续到下一个中间件（从代码的角度来看，它将始终调用 `next`）。
- en: 2.  The static file sender. This will check if the file exists in the folder.
    If it does, it'll send that file over the internet. If the requested file doesn't
    exist, it'll continue onto the final middleware (once again, calling `next`).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 静态文件发送器。这将检查文件是否在文件夹中。如果是，它将通过互联网发送该文件。如果请求的文件不存在，它将继续到最后一个中间件（再次调用 `next`）。
- en: 3.  The 404 handler. If this middleware is hit, it means that the previous one
    didn't find a file, and we should return a 404 message and finish up the request.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 404 处理器。如果这个中间件被触发，这意味着之前的中间件没有找到文件，我们应该返回一个 404 消息并完成请求。
- en: '4.  You could visualize this middleware stack like this:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 4. 你可以将这个中间件堆栈可视化如下：
- en: '![](../Images/04_04.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/04_04.png)'
- en: Figure 4.4 The middleware stack of our static file server application.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.4 我们静态文件服务器应用程序的中间件堆栈。
- en: 5.  Okay, enough talking. Let's build this thing.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 5. 好了，别再说了。让我们开始构建这个。
- en: 4.2.1  Getting set up
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.1 设置环境
- en: Start by making a new directory. You can call it whatever you’d like; let's
    choose `static-file-fun`. Inside of this directory, create a file called `package.json`.
    This file is present in every Node.js project and describes metadata about your
    package, from its title to its third-party dependencies.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 首先创建一个新的目录。你可以随意命名；让我们选择 `static-file-fun`。在这个目录内部，创建一个名为 `package.json` 的文件。这个文件存在于每个
    Node.js 项目中，描述了你的包的元数据，从标题到第三方依赖项。
- en: Listing 4.1 The package.json file for our static file application
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.1 我们静态文件应用程序的 package.json 文件
- en: '`{` `  "name": "static-file-fun",   #A` `  "private": true,             #B`
    `  "scripts": {` `    "start": "node app.js"     #C` `  }``}`'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`{` `  "name": "static-file-fun",   #A` `  "private": true,             #B`
    `  "scripts": {` `    "start": "node app.js"     #C` `  }``}`'
- en: '#A The “name” key defines the name of your package. It’s not required for private
    projects (see #B), but we’ll add it.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '#A “name”键定义了你的包名。对于私有项目（见 #B），这不是必需的，但我们会添加它。'
- en: '#B The “private” key tells Node that this shouldn’t be published in the public
    Node module registry. This should be set to "true" for your own personal projects.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '#B “private”键告诉 Node，这个包不应该发布在公共 Node 模块注册表中。对于你自己的个人项目，这应该设置为 "true"。'
- en: '#C When you run “npm start”, it’ll run “node app.js”.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '#C 当你运行“npm start”时，它将运行“node app.js”。'
- en: 'Once you''ve saved this `package.json`, you''ll want to install the latest
    version of Express. From inside of this directory, run `npm install express --save`.
    This will install Express into a directory called `node_modules` inside of this
    folder. It''ll also add Express as a dependency in `package.json`. `package.json` will
    now look like this:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 保存这个 `package.json` 文件后，你将想要安装 Express 的最新版本。在这个目录内部，运行 `npm install express
    --save`。这将把 Express 安装到这个文件夹内名为 `node_modules` 的目录中。它还会在 `package.json` 中添加 Express
    作为依赖项。`package.json` 现在看起来像这样：
- en: Listing 4.2 The updated package.json file for our static file application
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.2 我们静态文件应用程序更新的 package.json 文件
- en: '`{` `  "name": "static-file-fun",` `  "private": true,` `  "scripts": {` `   
    "start": "node app.js"` `  },` `  "dependencies": {` `    "express": "^4.12.2" 
    #A` `  }``}`'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`{` `  "name": "static-file-fun",` `  "private": true,` `  "scripts": {` `   
    "start": "node app.js"` `  },` `  "dependencies": {` `    "express": "^4.12.2" 
    #A` `  }``}`'
- en: '#A Your dependency versions may vary.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '#A 你的依赖项版本可能不同。'
- en: Next, create a folder called "static" inside of this new project directory (right
    next to `package.json`). Put a few files inside; maybe an HTML file or an image
    or two. It doesn't really matter what you put in here, but put some files that
    your example app will serve.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在这个新项目目录内（紧挨着 `package.json`）创建一个名为 "static" 的文件夹。在里面放一些文件；可能是一个 HTML 文件或一张图片。这里放什么并不重要，但放一些你的示例应用程序将提供的服务文件。
- en: 'Finally, create `app.js` in the root of your project, which will contain all
    of our app''s code. Your folder structure will look something like this:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在项目的根目录中创建 `app.js`，它将包含我们应用程序的所有代码。你的文件夹结构将看起来像这样：
- en: '![](../Images/04_05.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/04_05.png)'
- en: Figure 4.5 The directory structure of Static File Fun.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.5 静态文件乐趣的目录结构。
- en: When you want to run this app, you'll run `npm start`. This command will look
    inside your `package.json` file, see that you've added a script called "start",
    and run that command. In this case, it'll run `node app.js`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想运行这个应用程序时，你会运行 `npm start`。这个命令将查看你的 `package.json` 文件，看到你添加了一个名为 "start"
    的脚本，并运行该命令。在这种情况下，它将运行 `node app.js`。
- en: Running `npm start` won't do anything yet—we haven't written our app yet!—but
    you'll run that whenever you want to run your application.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `npm start` 目前不会做任何事情——我们还没有编写应用程序！——但你会每次想要运行应用程序时都运行它。
- en: Why use npm start?
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么使用 npm start？
- en: You might be wondering why we used `npm start` at all—why didn't we just run `node
    app.js`? There are three reasons we might do this.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道为什么我们甚至使用了 `npm start`——为什么我们不直接运行 `node app.js`？我们可能这样做有三个原因。
- en: First, it's a convention. Most Node web servers can be started with `npm start`,
    regardless of the project's structure. If instead of `app.js` someone had chosen `application.js`,
    you'd have to know about that change. The Node community seems to have settled
    on a common convention here.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，这是一个约定。大多数 Node 网络服务器都可以用 `npm start` 启动，无论项目的结构如何。如果有人选择了 `application.js`
    而不是 `app.js`，你就必须知道这个变化。Node 社区似乎在这里已经达成了一致。
- en: Second, it allows you to run a more complex command (or set of commands) with
    a relatively simple one. Our app is pretty simple now, but starting it could be
    more complex in the future. Perhaps we'll need to start up a database server or
    clear a giant log file. Keeping this complexity under the blanket of a simple
    command helps keep things consistent and more pleasant.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，它允许你用一个相对简单的命令（或一组命令）运行更复杂的命令。我们的应用程序现在很简单，但启动它可能会更复杂。也许我们需要启动一个数据库服务器或清除一个巨大的日志文件。将这种复杂性隐藏在一个简单的命令之下有助于保持事物的一致性和愉悦性。
- en: The third reason is a little more nuanced. npm lets you install packages globally,
    so you can run them just like any other terminal command. Bower is a common one,
    letting you install front-end dependencies from the command line with the newly-installed`bower` command.
    You install things like Bower globally on your system. npm scripts allow you to
    add new commands to your project without installing them globally, so that you
    can keep all of your dependencies inside of your project so that you can have
    unique versions per project. This reason comes in handy for things like testing
    and build scripts, as we'll see down the line.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个原因稍微复杂一些。npm 允许你全局安装包，因此你可以像运行任何其他终端命令一样运行它们。Bower 是一个常见的例子，它允许你使用新安装的`bower`命令从命令行安装前端依赖。你可以在系统上全局安装像Bower这样的东西。npm
    脚本允许你向项目添加新命令而不需要全局安装，这样你就可以将所有依赖项都保留在项目内部，以便每个项目都有独特的版本。这个原因对于测试和构建脚本等用途非常有用，正如我们稍后将会看到的。
- en: At the end of the day, you could just run `node app.js` and never type `npm
    start`, but I find the above reasons compelling enough to do it.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你只需运行`node app.js`就不再需要输入`npm start`，但我发现上面的理由足够有说服力去这样做。
- en: Okay. Let's write the app!
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。让我们编写这个应用！
- en: '4.2.2  Writing our first middleware function: the logger'
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.2 编写我们的第一个中间件函数：记录器
- en: We'll start by making our app log requests, just to get started.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先让我们的应用记录请求，以便开始。
- en: 'Put the following inside of `app.js`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下内容放入`app.js`中：
- en: Listing 4.3 Start app.js for our static file server
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.3 启动用于我们的静态文件服务器的app.js
- en: '`var express = require("express");  #A` `var path = require("path");       
    #A` `var fs = require("fs");            #A`   `var app = express();   #B`   `app.use(function(req,
    res, next) {                     #C` `  console.log("Request IP: " + req.url);              
    #C` `  console.log("Request date: " + new Date());          #C` `});                                                   
    #C`   `app.listen(3000, function() {               #D` `  console.log("App started
    on port 3000");  #D``});                                         #D`'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`var express = require("express");  #A` `var path = require("path");       
    #A` `var fs = require("fs");            #A` `var app = express();   #B` `app.use(function(req,
    res, next) {                     #C` `  console.log("Request IP: " + req.url);              
    #C` `  console.log("Request date: " + new Date());          #C` `});                                                   
    #C` `app.listen(3000, function() {               #D` `  console.log("App started
    on port 3000");  #D``});                                         #D`'
- en: '#A Require the modules we need. We''ll use Express in this example, but we''ll
    use Node''s built-in Path and filesystem ("fs") modules soon.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '#A 需要我们需要的模块。在这个例子中，我们将使用Express，但很快我们将使用Node的内置Path和文件系统（"fs"）模块。'
- en: '#B Create a new Express application and put it inside the "app" variable.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '#B 创建一个新的Express应用并将其放入“app”变量中。'
- en: '#C This middleware logs all incoming requests. It has a bug, though!'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '#C 这个中间件记录了所有传入的请求。但是，它有一个bug！'
- en: '#D Start the app on port 3000 and log out when it''s started!'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '#D 在端口3000上启动应用，并在启动时记录！'
- en: For now, all we have is an application that logs every request that comes into
    the server. Once we've set up our app (the first few lines), we call `app.use` to
    add a function to our application's middleware stack. When a request comes into
    this application, that function will be called.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们只有一个记录服务器接收到的每个请求的应用程序。一旦我们设置了我们的应用（前几行），我们就调用`app.use`来向我们的应用程序的中间件堆栈添加一个函数。当一个请求进入这个应用程序时，该函数将被调用。
- en: Unfortunately, even this simple app has a critical bug. Run `npm start` and
    visit `localhost:3000` in your browser to see it.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，即使这个简单的应用也有一个关键的bug。运行`npm start`并在浏览器中访问`localhost:3000`以查看它。
- en: You'll see the request being logged into the console, and that's great news.
    But your browser will hang—the loading spinner will spin and spin and spin, until
    the request eventually times out and you get an error in your browser. That's
    not good!
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到请求被记录到控制台，这是个好消息。但你的浏览器会卡住——加载指示器会一直旋转，直到请求最终超时，你在浏览器中会得到一个错误。这可不是什么好事！
- en: This is happening because we didn't call `next`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为我们没有调用`next`。
- en: 'When your middleware function is finished, it needs to do one of two things:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的中间件函数完成后，它需要做两件事之一：
- en: 1.  The function needs to finish responding to the request (with `res.end` or
    one of Express's convenience methods like `res.send` or `res.sendFile`).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 函数需要完成对请求的响应（使用`res.end`或Express的便利方法之一，如`res.send`或`res.sendFile`）。
- en: 2.  The function needs to call `next` to continue onto the next function in
    the middleware stack.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 函数需要调用`next`以继续到中间件堆栈中的下一个函数。
- en: If you do one of those two things, your app will work just fine. If you do neither,
    inbound requests will never get a response; their loading spinners will never
    stop spinning (this is what happened above). If you do both, only the first "response
    finisher" will go through and the rest will be ignored, which is almost certainly
    unintentional!
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你做其中之一，你的应用程序将正常工作。如果你两者都不做，入站请求将永远不会收到响应；它们的加载指示器将永远不会停止旋转（这就是上面发生的事情）。如果你两者都做，只有第一个“响应完成器”会通过，其余的将被忽略，这几乎肯定是不故意的！
- en: These bugs are usually pretty easy to catch once you know how to spot them.
    If you're not responding to the request and you're not calling `next`, it'll look
    like your server is super slow.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这些错误一旦你知道如何查找通常很容易捕捉到。如果你没有响应请求，也没有调用`next`，那么你的服务器看起来会非常慢。
- en: Let's fix our middleware by calling `next`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过调用`next`来修复我们的中间件。
- en: Listing 4.4 Fixing our logging middleware
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.4 修复我们的日志中间件
- en: '`// …`   `app.use(function(req, res, next) {` `  console.log("Request IP: "
    + req.url);` `  console.log("Request date: " + new Date());` `  next();   #A`
    `});`  `// …`'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`// …` `app.use(function(req, res, next) {` `  console.log("请求 IP: " + req.url);`
    `  console.log("请求日期: " + new Date());` `  next();   #A` `});` `// …`'
- en: '#A This is the critical new line!'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '#A 这是一条关键的新行！'
- en: Now, if you stop your app, run `npm start` again, and visit [http://localhost:3000](http://localhost:3000) in
    your browser, you should see your server logging all of the requests and immediately
    failing with an error message (something like "Cannot GET /"). Because we're never
    responding to the request ourselves, Express will give an error to the user, and
    it'll happen immediately.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你停止你的应用程序，再次运行`npm start`，并在浏览器中访问[http://localhost:3000](http://localhost:3000)，你应该看到你的服务器正在记录所有请求并立即显示错误消息（例如“Cannot
    GET /”）。因为我们从未自己响应请求，Express将向用户显示错误，并且这会立即发生。
- en: Sick of restarting your server?
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 厌倦了重启服务器？
- en: So far, when you change your code, you have to stop your server and start it
    again. This can get repetitive! You can install a tool called Nodemon. Nodemon
    will watch all of your files for changes and restart if it detects any.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，当你更改代码时，你必须停止服务器并重新启动它。这可能会变得重复！你可以安装一个名为Nodemon的工具。Nodemon会监视你的所有文件以检测更改，并在检测到任何更改时重新启动。
- en: You can install Nodemon by running `npm install nodemon --global`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过运行`npm install nodemon --global`来安装Nodemon。
- en: Once it's installed, you can start a file in watch mode by replacing "node"
    with "nodemon" in your command. For example, if you typed `node app.js` before,
    just change it to `nodemon app.js`, and your app will continuously reload when
    it changes.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，你可以通过在命令中将“node”替换为“nodemon”来以监视模式启动文件。例如，如果你之前输入了`node app.js`，只需将其更改为`nodemon
    app.js`，你的应用程序在更改时将连续重新加载。
- en: Now that we've written our logger, let's write the next part—the static file
    server middleware.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经编写了日志记录器，接下来让我们编写下一部分——静态文件服务器中间件。
- en: 4.2.3  The static file server middleware
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.3 静态文件服务器中间件
- en: 'At a high level, this is what the static file server middleware should do:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 从高层次来看，静态文件服务器中间件应该执行以下操作：
- en: 1.  Check if the requested file exists in the static directory.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 检查请求的文件是否存在于静态目录中。
- en: 2.  If it exists, respond with the file and call it a day. In code terms, this
    is a call to `res.sendFile`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 如果文件存在，响应该文件并结束。在代码中，这相当于调用`res.sendFile`。
- en: 3.  If the file doesn't exist, continue onto the next middleware in the stack.
    In code terms, this is a call to `next`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 如果文件不存在，继续处理堆栈中的下一个中间件。在代码中，这相当于调用`next`。
- en: Let's turn that requirement into code. We'll start by building it ourselves
    to understand how it works, and then we'll shorten it with some helpful third-party
    code.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这个需求转化为代码。我们首先自己构建它以了解其工作原理，然后使用一些有用的第三方代码来简化它。
- en: 'We''ll make use of Node''s built-in `path` module, which will let us determine
    the path that the user requests. To determine whether the file exists, we''ll
    use another Node built-in: the `fs` module.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将利用Node的内置`path`模块，这将使我们能够确定用户请求的路径。为了确定文件是否存在，我们将使用另一个Node内置模块：`fs`模块。
- en: 'Add this to `app.js` after your logging middleware:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在`app.js`中你的日志中间件之后添加以下内容：
- en: Listing 4.5 Adding static file middleware to the middleware stack
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.5 将静态文件中间件添加到中间件堆栈中
- en: '`// …` `app.use(function(req, res, next) {` `  // …` `});`   `app.use(function(req,
    res, next) {` `  var filePath = path.join(__dirname, "static", req.url);  #A`
    `  fs.exists(filePath, function(exists) {                      #B` `    if (exists)
    {                                             #C` `      res.sendFile(filePath);                                
    #C` `    } else {                                                  #D` `     
    next();                                                 #D` `    }` `  });` `});`
      `app.listen(3000, function() {``  // …`'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`// …` `app.use(function(req, res, next) {` `  // …` `});` `app.use(function(req,
    res, next) {` `  var filePath = path.join(__dirname, "static", req.url);  #A`
    `  fs.exists(filePath, function(exists) {                      #B` `    if (exists)
    {       #C` `      res.sendFile(filePath);                           #C` `   
    } else {                                           #D` `      next();                                          
    #D` `    }` `  });` `});` `app.listen(3000, function() {``  // …`'
- en: '#A Use path.join to find the path where the file should be (whether it''s there
    or not).'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`path.join`来找到文件应该存在的路径（无论它是否存在）。
- en: '#B Built-in fs.exists will call your callback when it determines whether your
    file exists.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 使用内置的`fs.exists`将调用你的回调来确定你的文件是否存在。
- en: '#C If the file exists, call res.sendFile.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文件存在，调用`res.sendFile`。
- en: '#D Otherwise, continue onto the next middleware.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，继续到下一个中间件。
- en: The first thing we do in this function is use `path.join` to determine the path
    of the file. If the user visits `/celine.mp3`, `req.url` will be the string `"/celine.mp3"`.
    Therefore, `filePath` will be something like`"/path/to/your/project/static/celine.mp3"`.
    The path will look pretty different depending on where you've stored your project
    and on your operating system, but it'll be the path to the file that was requested.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个函数中，我们首先使用`path.join`来确定文件的路径。如果用户访问`/celine.mp3`，`req.url`将是字符串`"/celine.mp3"`。因此，`filePath`将类似于`"/path/to/your/project/static/celine.mp3"`。路径将根据你存储项目的地方和你的操作系统而有所不同，但它将是请求的文件的路径。
- en: Next, we call `fs.exists`. This is a function that takes two arguments. The
    first is the path to check (the `filePath` we just figured out) and the second
    is a function. When Node has determined whether the file exists, it'll call this
    callback with one argument: `true` (the file exists) or `false` (the file doesn't
    exist).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们调用`fs.exists`。这是一个接受两个参数的函数。第一个是要检查的路径（我们刚刚计算出的`filePath`），第二个是一个函数。当Node确定文件是否存在时，它将使用一个参数调用这个回调：`true`（文件存在）或`false`（文件不存在）。
- en: 'Express applications have asynchronous behavior like this all the time. That''s
    why we have to have `next` in the first place! If everything in were synchronous,
    Express would know exactly where every middleware ended: when the function finished
    (either by calling `return` or hitting the end). We wouldn''t need to have `next` anywhere.
    But because things are asynchronous, we need manually to tell Express when to
    continue onto the next middleware in the stack.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式应用始终具有这种异步行为。这就是我们最初必须要有`next`的原因！如果一切都是同步的，Express将确切知道每个中间件在哪里结束：当函数完成时（无论是通过调用`return`还是遇到末尾）。我们不需要在任何地方有`next`。但是因为事情是异步的，我们需要手动告诉Express何时继续到堆栈中的下一个中间件。
- en: Once the callback has completed, we run through a simple conditional. If the
    file exists, send the file. Otherwise, continue onto the next middleware.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦回调完成，我们运行一个简单的条件判断。如果文件存在，发送文件。否则，继续到下一个中间件。
- en: Now, when you run your app with `npm start`, try visiting some resources you've
    put into the static file directory. If you have a file called `secret_plans.txt` in
    the static file folder, visit `localhost:3000/secret_plans.txt` to see it. You
    should also continue to see the logging, just as before.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你使用`npm start`运行你的应用时，尝试访问你放入静态文件目录中的资源。如果你在静态文件文件夹中有一个名为`secret_plans.txt`的文件，访问`localhost:3000/secret_plans.txt`来查看它。你也应该继续看到日志，就像之前一样。
- en: If you visit a URL that doesn’t have a corresponding file, you should still
    see the error message from before. This is because you're calling `next` and there's
    no more middleware in the stack. Let's add the final one—the 404 handler.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你访问一个没有对应文件的URL，你仍然应该看到之前的错误消息。这是因为你在调用`next`，并且堆栈中没有更多的中间件。让我们添加最后一个——404处理器。
- en: 4.2.4  404 handler middleware
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.4 404处理器中间件
- en: 'The 404 handler is the last function in our middleware stack. It''ll always
    send a 404 error, no matter what. Add this after the previous middleware:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 404处理器是我们中间件堆栈中的最后一个函数。它将始终发送一个404错误，无论什么情况。在之前的中间件之后添加这个：
- en: 'Listing 4.6 Our final middleware: the 404 handler'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.6 我们最终的中间件：404处理器
- en: '`// …`   `app.use(function(req, res) {   #A` `  res.status(404);            
    #B` `  res.send("File not found!"); #C` `});`  `// …`'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`// …`   `app.use(function(req, res) {   #A`   `  res.status(404);            
    #B`   `  res.send("File not found!"); #C`   `});`   `// …`'
- en: '#A We''ve omitted the "next" argument because we won''t use it.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '#A 我们省略了 "next" 参数，因为我们不会使用它。'
- en: '#B Set the status code to 404.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '#B 设置状态码为 404。'
- en: '#C Send the error "File not found!"'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '#C 发送错误 "文件未找到！"'
- en: This is the final piece of the puzzle.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这是拼图的最后一部分。
- en: Now, when you start your server, you'll see the whole thing in action! If you
    visit a file that's in the folder, it'll show up. If not, you'll see your 404
    error. And all the while, you'll see logs in the console.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你启动你的服务器时，你将看到整个过程的实际效果！如果你访问文件夹中的文件，它将显示出来。如果没有，你将看到你的 404 错误。而且在这个过程中，你将在控制台看到日志。
- en: For a moment, try moving the 404 handler. Make the first middleware in the stack
    instead of the last. If you re-run your app, you'll see that you always get a
    404 error no matter what. Your app hits the first middleware and never continues
    on. The order of your middleware stack is important—make sure your requests flow
    through in the proper order.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 暂时尝试移动 404 处理器。将其设置为堆栈中的第一个中间件而不是最后一个。如果你重新运行你的应用程序，你会发现无论什么情况下你都会得到一个 404 错误。你的应用程序触发了第一个中间件并且永远不会继续。中间件堆栈的顺序很重要——确保请求以正确的顺序流动。
- en: 'Our app works! Here''s what it should look like:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序工作！以下是它应该看起来像什么：
- en: Listing 4.7 The first version of our static file app (app.js)
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.7 我们静态文件应用的第一个版本（app.js）
- en: '`var express = require("express");` `var path = require("path");` `var fs =
    require("fs");`   `var app = express();`   `app.use(function(req, res, next) {`
    `  console.log("Request IP: " + req.url);` `  console.log("Request date: " + new
    Date());` `  next();` `});`   `app.use(function(req, res, next) {` `  var filePath
    = path.join(__dirname, "static", req.url);` `  fs.exists(filePath, function(exists)
    {` `    if (exists) {` `      res.sendFile(filePath);` `    } else {` `      next();`
    `    }` `  });` `});`   `app.use(function(req, res) {` `  res.status(404);` ` 
    res.send("File not found!");` `});`   `app.listen(3000, function() {` `  console.log("App
    started on port 3000");``});                                        `'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`var express = require("express");` `var path = require("path");` `var fs =
    require("fs");`   `var app = express();`   `app.use(function(req, res, next) {`   ` 
    console.log("请求 IP: " + req.url);`   `  console.log("请求日期: " + new Date());`   ` 
    next();`   `});`   `app.use(function(req, res, next) {`   `  var filePath = path.join(__dirname,
    "static", req.url);`   `  fs.exists(filePath, function(exists) {`   `    if (exists)
    {`   `      res.sendFile(filePath);`   `    } else {`   `      next();`   `   
    }`   `  });`   `});`   `app.use(function(req, res) {`   `  res.status(404);`   ` 
    res.send("文件未找到！");`   `});`   `app.listen(3000, function() {`   `  console.log("应用程序在端口
    3000 上启动");``});                                        `'
- en: But as always, there's more we can do.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 但就像往常一样，我们还可以做更多。
- en: '4.2.5  Switching our logger to an open-source one: Morgan'
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.5 将我们的日志记录器切换到开源的 Morgan
- en: A common piece of advice in software development is "don't reinvent the wheel".
    If someone else has already solved your problem, you should take their solution
    and move onto better things.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 软件开发中常见的建议是 "不要重复造轮子"。如果别人已经解决了你的问题，你应该采用他们的解决方案，然后去做更好的事情。
- en: That's what we'll do with our logging middleware. We'll remove the hard work
    we put in (all five lines) and use a piece of middleware called Morgan (at [https://github.com/expressjs/morgan](https://github.com/expressjs/morgan)).
    It's not baked into core Express but it's maintained by the Express team.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们将在我们的日志记录中间件中做的事情。我们将移除我们投入的辛勤工作（所有五行），并使用一个名为 Morgan 的中间件（在 [https://github.com/expressjs/morgan](https://github.com/expressjs/morgan)）。它不是
    Express 核心的一部分，但它由 Express 团队维护。
- en: Morgan describes itself as "request logger middleware", which is exactly what
    we want!
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Morgan 自称为 "请求记录中间件"，这正是我们想要的！
- en: To install it, run `npm install morgan --save` to install the latest version
    of the Morgan package. You'll see it inside a new folder inside of `node_modules` and
    it'll also appear in `package.json`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装它，运行 `npm install morgan --save` 以安装 Morgan 包的最新版本。你将在 `node_modules` 中的一个新文件夹中看到它，它也会出现在
    `package.json` 中。
- en: Now, let's change `app.js` to use Morgan instead of our logging middleware.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将 `app.js` 更改为使用 Morgan 而不是我们的日志记录中间件。
- en: Listing 4.8 app.js that now uses Morgan
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.8 使用 Morgan 的 app.js
- en: '`var express = require("express");  #A` `var morgan = require("morgan");   
    #B` `// …`   `var app = express();`   `app.use(morgan("short"));  #C`  `// …`'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`var express = require("express");  #A` `var morgan = require("morgan");   
    #B` `// …`   `var app = express();`   `app.use(morgan("short"));  #C`   `// …`'
- en: '#A Require Express, just like before.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '#A 需要 Express，就像之前一样。'
- en: '#B Require Morgan.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '#B 需要Morgan。'
- en: '#C Use the Morgan middleware instead of the one we used to have.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '#C 使用 Morgan 中间件而不是我们之前使用的中间件。'
- en: Now, when you run this app, you'll see output like Figure 4.6, with the IP address
    and a bunch of other useful information.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你运行这个应用时，你会看到类似于图 4.6 的输出，包括 IP 地址和其他一些有用的信息。
- en: '![](../Images/04_06.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/04_06.png)'
- en: Figure 4.6 Our application's logs after adding Morgan.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.6 添加 Morgan 后我们应用日志。
- en: So…what's happening here?
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这里发生了什么？
- en: '`morgan` is a function that returns a middleware function. When you call it,
    it will return a function like the one you''d written before; it''ll take 3 arguments
    and call `console.log`. Most third-party middleware works this way—you call a
    function which returns the middleware, which you then use. You could have written
    the above like this:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`morgan` 是一个返回中间件函数的函数。当你调用它时，它将返回一个类似于你之前写的函数；它将接受 3 个参数并调用 `console.log`。大多数第三方中间件都是这样工作的——你调用一个函数，该函数返回中间件，然后你使用它。你可以像这样编写上面的代码：'
- en: Listing 4.9 An alternative usage of Morgan
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.9 Morgan 的另一种用法
- en: '`var morganMiddleware = morgan("short");` `app.use(morganMiddleware);`'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`var morganMiddleware = morgan("short");` `app.use(morganMiddleware);`'
- en: 'Notice that we''re calling Morgan with one argument: a string, "short". This
    is a Morgan-specific configuration option that dictates what the output should
    look like. There are other format strings that have more or less information.
    "combined" gives a lot of info—"tiny" gives a very minimal output. When you call
    Morgan with different configuration options, you''re effectively making it return
    a different middleware function.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们调用 Morgan 时传递了一个参数：一个字符串，"short"。这是一个 Morgan 特定的配置选项，它决定了输出应该是什么样子。还有其他格式字符串，包含或多或少的信息。"combined"
    提供了很多信息——“tiny”则提供了非常少的输出。当你用不同的配置选项调用 Morgan 时，实际上是在让它返回一个不同的中间件函数。
- en: 'Morgan is the first example of open-source middleware we''ll use, but we''ll
    use a lot throughout this book. We''ll use another one to replace our second middleware
    function: the static file server.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Morgan 是我们将要使用的第一个开源中间件示例，但在这本书中我们会使用很多。我们将使用另一个中间件来替换我们的第二个中间件函数：静态文件服务器。
- en: 4.2.6  Switching to Express's built-in static file middleware
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.6 切换到 Express 内置的静态文件中间件
- en: There's only one piece of middleware that's bundled with Express, and it replaces
    our second middleware.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Express 打包在一起的中间件只有一个，它替换了我们的第二个中间件。
- en: It's called `express.static`. It works a lot like the middleware we wrote, but
    it's got a bunch of other features. It does a bunch of complicated tricks to achieve
    better security and performance. For example, it adds a caching mechanism. If
    you're interested in more of its benefits, you can read my blog post about the
    middleware at [http://evanhahn.com/express-dot-static-deep-dive/](http://evanhahn.com/express-dot-static-deep-dive/).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 它被称为 `express.static`。它的工作方式与我们所写的中间件非常相似，但它有很多其他功能。它通过一系列复杂的技巧来实现更好的安全性和性能。例如，它添加了一个缓存机制。如果你对其更多好处感兴趣，可以阅读我关于中间件的博客文章，链接为
    [http://evanhahn.com/express-dot-static-deep-dive/](http://evanhahn.com/express-dot-static-deep-dive/)。
- en: 'Like Morgan, `express.static` is a function that returns a middleware function.
    It takes one argument: the path to the folder we''ll be using for static files.
    To get this path, we''ll use `path.join`, like before. Then we''ll pass it to
    the static middleware.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Morgan 一样，`express.static` 是一个返回中间件函数的函数。它接受一个参数：我们将用于静态文件的文件夹的路径。为了获取这个路径，我们将使用
    `path.join`，就像之前一样。然后我们将它传递给静态中间件。
- en: 'Replace your static file middleware with this:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 用这个替换你的静态文件中间件：
- en: Listing 4.10 Replacing our static file middleware with Express's
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.10 使用 Express 替换我们的静态文件中间件
- en: '`// …`   `var staticPath = path.join(__dirname, "static");  #A` `app.use(express.static(staticPath));                
    #B`  `// …`'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`// …` `var staticPath = path.join(__dirname, "static"); #A` `app.use(express.static(staticPath));
    #B` `// …`'
- en: '#A Put the static path in a variable.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '#A 将静态路径放入变量中。'
- en: '#B Use express.static to serve files from the static path.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '#B 使用 express.static 从静态路径提供文件服务。'
- en: It's a bit more complicated because it's got more features, but `express.static` functions
    quite similarly to what we had before. If the file exists at the path, it will
    send it. If not, it'll call `next` and continue on to the next middleware in the
    stack.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 因为它有更多功能，所以稍微复杂一些，但 `express.static` 函数与之前我们所拥有的非常相似。如果文件存在于该路径，它将发送该文件。如果不存在，它将调用
    `next` 并继续到堆栈中的下一个中间件。
- en: If you restart your app, you won't notice much difference in functionality,
    but your code will be much shorter. Because you're using battle-tested middleware
    instead of your own, you'll also be getting a much more reliable set of features.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你重新启动你的应用程序，你不会在功能上注意到太大的差异，但你的代码将会更短。因为你使用的是经过实战检验的中间件而不是你自己的，你也会得到一个更可靠的特性集。
- en: 'Now our app code looks like this:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的应用程序代码看起来是这样的：
- en: Figure 4.11 The next version of our static file app (app.js)
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.11 我们静态文件应用程序的下一个版本（app.js）
- en: '`var express = require("express");` `var morgan = require("morgan");` `var
    path = require("path");`   `var app = express();`   `app.use(morgan("short"));`
      `var staticPath = path.join(__dirname, "static");` `app.use(express.static(staticPath));`
      `app.use(function(req, res) {` `  res.status(404);` `  res.send("File not found!");`
    `});`   `app.listen(3000, function() {` `  console.log("App started on port 3000");``});`'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`var express = require("express");` `var morgan = require("morgan");` `var
    path = require("path");`   '
- en: I think we can call our Express-powered static file server complete for now.
    Well done, hero.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我想我们现在可以称我们的Express驱动的静态文件服务器已经完成了。做得好，英雄。
- en: 4.3     Error handling middleware
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.3 错误处理中间件
- en: Remember when I said that calling `next` would continue onto the next middleware?
    I lied. It was mostly true but I didn't want to confuse you.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我之前说过调用`next`会继续到下一个中间件吗？我撒谎了。这基本上是正确的，但我不想让你困惑。
- en: There are two types of middleware.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件有两种类型。
- en: We've been dealing with the first type so far; these are just regular middleware
    functions that take three arguments (sometimes two when `next` is discarded).
    Most of the time, your app is in "normal mode", which only looks at these middleware
    functions and skips the other.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们到目前为止一直在处理第一种类型；这些只是接受三个参数（有时当`next`被丢弃时为两个）的常规中间件函数。大多数时候，你的应用程序处于“正常模式”，这只会查看这些中间件函数并跳过其他。
- en: 'There''s a second kind that''s much less used: error handling middleware. When
    your app is in "error mode", all regular middleware is ignored and Express will
    only execute error handling middleware functions. To enter "error mode", simply
    call `next` with an argument. It''s convention to call it with an error, like `next(new
    Error("Something bad happened!"))`.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 另有一种类型的使用得较少：错误处理中间件。当你的应用程序处于“错误模式”时，所有常规中间件都被忽略，Express将只执行错误处理中间件函数。要进入“错误模式”，只需带参数调用`next`。通常的做法是带一个错误调用它，例如`next(new
    Error("发生了某些糟糕的事情！"))`。
- en: 'These middleware functions take four arguments instead of two or three. The
    first one is the error (the argument passed into `next`), and the rest are the
    three from before: `req`, `res`, and `next`. You can do anything you want in this
    middleware. When you''re done, it''s just like other middleware: you can call `res.end` or `next`.
    Calling `next` with no arguments will exit "error mode" and move onto the next
    normal middleware; calling it with an argument will continue onto the next error-handling
    middleware if one exists.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这些中间件函数接受四个参数而不是两个或三个。第一个是错误（传递给`next`的参数），其余的是之前的三个：`req`、`res`和`next`。你可以在这个中间件中做任何你想做的事情。当你完成时，它就像其他中间件一样：你可以调用`res.end`或`next`。不带参数调用`next`将退出“错误模式”并移动到下一个正常中间件；带参数调用它将进入下一个错误处理中间件（如果存在）。
- en: 'For example, let''s say you have four middleware functions in a row. The first
    two are normal, the third handles errors, and the fourth is a normal one. If no
    errors happen, the flow will look something like this:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你连续有四个中间件函数。前两个是正常的，第三个处理错误，第四个是正常的。如果没有发生错误，流程将类似于以下这样：
- en: '![](../Images/04_07.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/04_07.png)'
- en: Figure 4.7 If all goes well, error handling middleware will be skipped.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.7 如果一切顺利，错误处理中间件将被跳过。
- en: 'If no errors happen, it''ll be as if the error handling middleware never existed.
    To reiterate more precisely, "no errors" means "`next` was never called with any
    arguments". If an error does happen, then Express will skip over all other middleware
    until the first error-handling middleware in the stack. It might look like this:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有发生错误，它将好像错误处理中间件从未存在过。为了更精确地重申，“没有错误”意味着“`next`从未被带参数调用”。如果确实发生了错误，那么Express将跳过所有其他中间件，直到堆栈中的第一个错误处理中间件。它可能看起来像这样：
- en: '![](../Images/04_08.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/04_08.png)'
- en: Figure 4.8 If there's an error, Express will skip straight to the error-handling
    middleware.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.8 如果发生错误，Express将直接跳转到错误处理中间件。
- en: While not enforced, error handling middleware is conventionally placed at the
    end of your middleware stack, after all the normal middleware has been added.
    This is because you want to catch any errors that come cascading down from earlier
    in the stack.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然没有强制要求，但错误处理中间件通常放在中间件堆栈的末尾，在所有正常中间件添加完毕之后。这是因为你想要捕获从堆栈中早期阶段传下来的任何错误。
- en: No catching here
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有捕获
- en: Express's error handling middleware does not handle errors that are thrown with
    the `throw` keyword, only when you call `next` with an argument.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: Express 的错误处理中间件不处理使用 `throw` 关键字抛出的错误，只有当你用参数调用 `next` 时才会处理。
- en: Express has some protections in place for these exceptions. The app will return
    a 500 error and that request will fail, but the app will keep on running. Some
    errors like syntax errors, however, will crash your server.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: Express 为这些异常提供了一些保护措施。应用将返回一个 500 错误，并且该请求将失败，但应用将继续运行。然而，一些错误，如语法错误，可能会导致服务器崩溃。
- en: 'Let''s say that you''re writing a really simple Express app that just sends
    a picture to the user, no matter what. We''ll use `res.sendFile` just like before.
    Here''s what that simple app might look like:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在编写一个非常简单的 Express 应用，该应用只是向用户发送图片，无论什么情况。我们就像之前一样使用 `res.sendFile`。这个简单应用可能看起来是这样的：
- en: Listing 4.12 A simple app that always sends a file
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.12 一个总是发送文件的简单应用
- en: '`var express = require("express");` `var path = require("path");`   `var app
    = express();`   `var filePath = path.join(__dirname, "celine.jpg"); #A` `app.use(function(req,
    res) {` `  res.sendFile(filePath);` `});`   `app.listen(3000, function() {` ` 
    console.log("App started on port 3000");``});`'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`var express = require("express");` `var path = require("path");` `var app
    = express();` `var filePath = path.join(__dirname, "celine.jpg"); #A` `app.use(function(req,
    res) {` `  res.sendFile(filePath);` `});` `app.listen(3000, function() {` `  console.log("App
    started on port 3000");``});`'
- en: '#A This will point to a file called celine.jpg that''s in the same folder as
    this file.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '#A 这将指向一个与该文件在同一文件夹中的名为 celine.jpg 的文件。'
- en: This code should look like a simplified version of the static file server we
    built up above. It'll unconditionally send `celine.jpg` over the internet.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码应该看起来像是上面构建的静态文件服务器的简化版本。它将无条件地将 `celine.jpg` 发送到互联网上。
- en: But what if that file doesn't exist on your computer for some reason? What if
    it has trouble reading the file because of some other weird issue? We'll want
    to have some way of handling that error. Error-handling middleware to the rescue!
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果由于某种原因，该文件在你的电脑上不存在怎么办？如果由于其他奇怪的问题而难以读取文件怎么办？我们希望有一种方法来处理这种错误。错误处理中间件来拯救！
- en: 'To enter "error mode", we''ll start by using a convenient feature of `res.sendFile`:
    it can take an extra argument which is a callback. This callback is executed after
    the file is sent, and if there''s an error, it''s passed an argument. If you wanted
    to print its success, you might do something like this:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 要进入“错误模式”，我们首先会使用 `res.sendFile` 的一个便利功能：它可以接受一个额外的参数，即回调函数。这个回调函数在文件发送后执行，如果发生错误，它将传递一个参数。如果你想打印其成功，你可能做如下操作：
- en: Listing 4.13 Printing whether a file successfully sent
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.13 打印文件是否成功发送
- en: '`res.sendFile(filePath, function(err) {` `  if (err) {` `    console.error("File
    failed to send.");` `  } else {` `    console.log("File sent!");` `  }``});`'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`res.sendFile(filePath, function(err) {` `  if (err) {` `    console.error("文件发送失败。");`
    `  } else {` `    console.log("文件已发送！");` `  }``});`'
- en: 'Instead of printing the success story to the console, we can enter "error mode"
    by calling `next` with an argument if there''s an error. We can do something like
    this:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以不将成功消息打印到控制台，而是在有错误时通过传递参数调用 `next` 来进入“错误模式”。我们可以这样做：
- en: Listing 4.14 Entering "error mode" if a file fails to send
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.14 如果文件发送失败，进入“错误模式”
- en: '`// …`   `app.use(function(req, res, next) {` `  res.sendFile(filePath, function(err)
    {` `    if (err) {` `      next(new Error("Error sending file!"));` `    }` ` 
    });` `});`  `// …`'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`// …` `app.use(function(req, res, next) {` `  res.sendFile(filePath, function(err)
    {` `    if (err) {` `      next(new Error("文件发送错误！"));` `    }` `  });` `});`
    `// …`'
- en: Now that we're in this error mode, let's handle it.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经进入了错误模式，让我们来处理它。
- en: It's common to have a log of all errors that happen in your app, but we don't
    usually display this to users. For one, a long JavaScript stack trace might be
    a pretty confusing to a non-technical user. It might also expose your code to
    hackers—if a hacker can get a glimpse into how your site works, they can find
    things to exploit.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的应用中记录所有发生的错误是很常见的，但我们通常不会将这些错误显示给用户。一方面，对于非技术用户来说，一个长的 JavaScript 调用栈可能相当令人困惑。它还可能使你的代码暴露给黑客——如果黑客能够窥视到你的网站是如何工作的，他们就能找到可以利用的地方。
- en: 'Let''s write some simple middleware that logs errors but doesn''t actually
    respond to the error. It''ll look a lot like our middleware from before, but instead
    of logging request information, it''ll log the error. You could add the following
    to your file after all the normal middleware:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一些简单的中间件，用于记录错误但不实际响应错误。它看起来很像我们之前的中间件，但不是记录请求信息，而是记录错误。你可以在所有正常中间件之后添加以下内容到你的文件中：
- en: Listing 4.15 Middleware that logs all errors
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.15 记录所有错误的中间件
- en: '`// …`   `app.use(function(err, req, res, next) {  #A` `  console.error(err);                   
    #B` `  next(err);                             #C` `});`  `// …`'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`// …`   `app.use(function(err, req, res, next) {  #A`   `  console.error(err);                   
    #B`   `  next(err);                             #C`   `});`   `// …`'
- en: '#A Notice that this is just like other middleware but with an extra argument.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '#A 注意这与其他中间件类似，但有一个额外的参数。'
- en: '#B Log the error.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '#B 记录错误。'
- en: '#C Continue to the next middleware. Make sure to call it with the error argument
    to stay in "error mode".'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '#C 继续到下一个中间件。确保使用错误参数调用它，以保持“错误模式”。'
- en: Now, when an error comes through, we'll log it to the console so that we can
    investigate it later. But there's more that needs to be done to handle this error.
    This is similar to before—the logger did something, but it didn't respond to the
    request. Let's write that part.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当错误通过时，我们将将其记录到控制台，以便我们稍后进行调查。但还需要做更多的事情来处理这个错误。这与之前类似——记录器做了些事情，但没有响应请求。让我们编写这部分内容。
- en: You can add this after the previous middleware. This will simply respond to
    the error with a 500 status code.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在之前的中间件之后添加这个。这将简单地以 500 状态码响应错误。
- en: Listing 4.16 Actually responding to the error
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.16 实际响应错误
- en: '`// …`   `app.use(function(err, req, res, next) {   #A` `  res.status(500);                       
    #B` `  res.send("Internal server error.");     #C` `});`  `// …`'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`// …`   `app.use(function(err, req, res, next) {   #A`   `  res.status(500);                       
    #B`   `  res.send("Internal server error.");     #C`   `});`   `// …`'
- en: '#A Even though we''re not going to use all four arguments, we have to specify
    them so that Express can recognize that this is error-handling middleware.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '#A 即使我们不打算使用所有四个参数，我们也必须指定它们，这样Express才能识别出这是一个错误处理中间件。'
- en: '#B Set the status code to 500, which means "internal server error".'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '#B 将状态码设置为 500，表示“内部服务器错误”。'
- en: '#C Send the error text.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '#C 发送错误文本。'
- en: Keep in mind that, no matter where this middleware is placed in your stack,
    it won't be called unless you're in "error mode"—in code, this means calling `next` with
    an argument.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，无论这个中间件在你的堆栈中的位置如何，除非你处于“错误模式”——在代码中这意味着使用带有参数的 `next` 调用，否则它不会被调用。
- en: For simple applications, there aren't loads and loads of places where things
    can go wrong. But as your apps grow, you'll want to remember to test errant behavior.
    If a request fails and it shouldn't, make sure you handle that gracefully instead
    of crashing. If an action should perform successfully but fails, make sure your
    server doesn't explode. Error-handling middleware can help this along.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 对于简单的应用程序，错误发生的地方并不多。但随着你的应用程序增长，你将想要记得测试异常行为。如果一个请求失败，它本不应该失败，确保你优雅地处理它而不是崩溃。如果一个动作应该成功执行但失败了，确保你的服务器不会崩溃。错误处理中间件可以帮助你做到这一点。
- en: 4.4     Other useful middleware
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.4 其他有用的中间件
- en: Two different Express applications can have pretty different middleware stacks.
    Our example app’s stack is just one of many possible middleware configurations,
    and there are lots out there that you can use.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的Express应用程序可以拥有相当不同的中间件堆栈。我们的示例应用程序的堆栈只是许多可能的中间件配置之一，而且有很多你可以使用。
- en: There's only one piece of middleware that's bundled with Express, and that's `express.static`.
    We'll be installing and using lots of other middleware throughout this book.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 与Express捆绑的唯一中间件是 `express.static`。我们将在本书的其余部分安装和使用许多其他中间件。
- en: 'While it''s not bundled with Express, the Express team maintains a number of
    middleware modules:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Express没有捆绑这些中间件，但Express团队维护了多个中间件模块：
- en: ·  `body-parser` for parsing request bodies. For example, when a user submits
    a form. See more at [https://github.com/expressjs/body-parser](https://github.com/expressjs/body-parser).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: ·  `body-parser` 用于解析请求体。例如，当用户提交表单时。更多信息请参阅 [https://github.com/expressjs/body-parser](https://github.com/expressjs/body-parser)。
- en: '·  `cookie-parser` does what it says on the tin: parses cookies from users.
    It needs to be paired with another Express-supported middleware like `express-session`.
    Once you''ve done this, you can keep track of users, providing them with user
    accounts and other features. We''ll explore this in greater detail in Chapter
    7. [https://github.com/expressjs/cookie-session](https://github.com/expressjs/cookie-session) has
    more details.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: ·   `cookie-parser` 做的是它所说的：解析用户的 cookies。它需要与另一个 Express 支持的中间件如 `express-session`
    配对。一旦这样做，您就可以跟踪用户，为他们提供用户账户和其他功能。我们将在第 7 章中更详细地探讨这一点。[https://github.com/expressjs/cookie-session](https://github.com/expressjs/cookie-session)
    有更多详细信息。
- en: ·  `compression` will compress responses to save on bytes. See more at [https://github.com/expressjs/compression](https://github.com/expressjs/compression)
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: ·   `compression` 将压缩响应以节省字节。更多信息请参阅 [https://github.com/expressjs/compression](https://github.com/expressjs/compression)
- en: 'You can find the full list on the Express homepage at [http://expressjs.com/resources/middleware.html](http://expressjs.com/resources/middleware.html).
    There are also a huge number of third-party middleware modules that we''ll explore.
    To name a few:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 Express 主页上找到完整的列表 [http://expressjs.com/resources/middleware.html](http://expressjs.com/resources/middleware.html)。还有大量的第三方中间件模块我们将要探讨。以下是一些例子：
- en: ·  Helmet is a bit of middleware that helps to secure your applications. It
    doesn't magically make you more secure, but a small amount of work can protect
    you from a lot of hacks. Read more at [https://github.com/helmetjs/helmet](https://github.com/helmetjs/helmet).
    (I maintain this module, by the way, so I have to promote it!)
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: ·   Helmet 是一种中间件，有助于保护您的应用程序。它并不能神奇地让您更安全，但通过一点工作可以保护您免受许多黑客攻击。更多信息请参阅 [https://github.com/helmetjs/helmet](https://github.com/helmetjs/helmet)。顺便说一句，我维护这个模块，所以我要推广它！
- en: ·  `connect-assets` will compile and minify your CSS and JavaScript assets.
    It'll also work with CSS preprocessors like SASS, SCSS, LESS, and Stylus, should
    you choose to use them. See [https://github.com/adunkman/connect-assets](https://github.com/adunkman/connect-assets).
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: ·   `connect-assets` 将编译和压缩您的 CSS 和 JavaScript 资产。如果您选择使用，它还将与 CSS 预处理器如 SASS、SCSS、LESS
    和 Stylus 一起工作。更多信息请参阅 [https://github.com/adunkman/connect-assets](https://github.com/adunkman/connect-assets)。
- en: ·  Winston is a more powerful alternative to Morgan that does more robust logging
    (to files or databases, for example). See more at https://github.com/flatiron/winston.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: Winston 是 Morgan 的更强大替代品，可以进行更健壮的日志记录（例如到文件或数据库）。更多信息请参阅 https://github.com/flatiron/winston。
- en: This is hardly an exhaustive list. I also recommend a number of helpful modules
    in Appendix B if you're thirsty for even more helpers.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 这几乎不是一个详尽的列表。如果您渴望更多帮助，我还推荐附录 B 中的几个有用的模块。
- en: 4.5     Summary
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.5    摘要
- en: 'Middleware is the core foundation of Express, and we''ve explored it in this
    chapter. We''ve learned:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件是 Express 的核心基础，我们在本章中对其进行了探讨。我们学到了：
- en: ·  Express's middleware stack, and how requests flow through that stack sequentially
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: ·   Express 的中间件栈，以及请求如何顺序通过该栈
- en: '·  How to write our own middleware functions: a function with three arguments'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: ·   如何编写我们自己的中间件函数：一个带有三个参数的函数
- en: '·  How to write and use error handling middleware: a function with four arguments'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: ·   如何编写和使用错误处理中间件：一个带有四个参数的函数
- en: ·  Various open-source middleware functions, like Morgan for logging, `express.static` for
    serving static files, and many more
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: ·   各种开源中间件功能，如用于日志记录的 Morgan，用于服务静态文件的 `express.static` 以及更多
