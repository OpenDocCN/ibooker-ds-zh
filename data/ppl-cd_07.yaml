- en: 4 Baking machine images with Packer
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4 使用 Packer 烘焙机器镜像
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章 涵盖
- en: Overview of immutable infrastructure
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可变基础设施概述
- en: Baking Jenkins machine images with Packer
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Packer 烘焙 Jenkins 机器镜像
- en: Discovering Jenkins essentials plugins
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发现 Jenkins 基础插件
- en: Executing Jenkins Groovy scripts
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行 Jenkins Groovy 脚本
- en: Using Packer provisioners to automate Jenkins settings
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Packer 提供程序自动化 Jenkins 设置
- en: 'In the previous chapter, you learned how Jenkins distributed mode architecture
    works. In this one, we will get our hands dirty and deploy a Jenkins cluster on
    AWS. As a quick reminder, you learned that the Jenkins cluster is divided into
    two main components: master and worker. Before diving into the implementation
    of the distributed builds architecture, we will deploy the standalone mode, shown
    in figure 4.1, to cover some basics.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你学习了 Jenkins 分布式模式架构的工作原理。在这一章中，我们将亲自动手，在 AWS 上部署一个 Jenkins 集群。为了快速回顾，你了解到
    Jenkins 集群分为两个主要组件：主节点和从节点。在深入实施分布式构建架构之前，我们将部署独立模式，如图 4.1 所示，以涵盖一些基础知识。
- en: To deploy this architecture, we need to provision a server (for example, an
    EC2 instance in AWS). Then we’ll install and configure Jenkins on the machine.
    While this manual process works, it’s not efficient when we want to deploy Jenkins
    to scale. Plus, updating or upgrading Jenkins can be lengthy and painful, and
    things can easily go wrong—breaking your CI/CD pipelines and impacting your product
    release as a result.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 要部署此架构，我们需要配置一台服务器（例如，AWS 中的 EC2 实例）。然后，我们将在该机器上安装和配置 Jenkins。虽然这个过程是可行的，但当我们想要扩展
    Jenkins 部署时，它并不高效。此外，更新或升级 Jenkins 可能会耗时且痛苦，事情很容易出错——破坏你的 CI/CD 管道，并影响你的产品发布。
- en: '![](Images/CH04_F01_Labouardy.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH04_F01_Labouardy.png)'
- en: Figure 4.1 Jenkins standalonearchitecture on AWS
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 AWS 上的 Jenkins 独立架构
- en: So instead of installing Jenkins after infrastructure creation (EC2 instance
    deployment) and applying updates on an existing Jenkins instance (in case of upgrades
    or maintenance), all changes must be packaged in a new machine image. A new Jenkins
    instance should be deployed based on the new image, and then the old server will
    be destroyed. This process creates what is known as an *immutable infrastructure*.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们不是在基础设施创建（EC2 实例部署）后安装 Jenkins 并在现有的 Jenkins 实例上应用更新（升级或维护的情况），所有更改都必须打包到一个新的机器镜像中。应该基于新镜像部署一个新的
    Jenkins 实例，然后销毁旧服务器。这个过程创建了一个被称为 *不可变基础设施*的东西。
- en: 4.1 Immutable infrastructure
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.1 不可变基础设施
- en: Immutable infrastructure is all about immutable components that are re-created
    and replaced instead of updated after infrastructure creation. This immutable
    infrastructure reduces the number of places where things can go wrong. This helps
    reduce inconsistency and improves reliability in the deployment process.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变基础设施的核心是那些在基础设施创建后重新创建和替换的不可变组件，而不是更新。这种不可变基础设施减少了出错的地方数量。这有助于减少不一致性并提高部署过程中的可靠性。
- en: When an update is necessary for immutable infrastructure, new servers are provisioned
    with a preconfigured image, and old servers are destroyed. We create a new machine
    image that is built for deployment and use it for creating new servers. In immutable
    infrastructure, we are moving the configuration setup after the server creation
    process to the build process. As all deployments are done by new images, we can
    keep the history of previous releases in case of reverting to an old build. This
    allows us to reduce deployment time and the chance of configuration failure, and
    to scale deployments. Figure 4.2 illustrates the differences between immutable
    and mutable infrastructures.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当不可变基础设施需要更新时，会使用预配置的镜像部署新的服务器，并销毁旧服务器。我们创建一个新的机器镜像，用于部署和使用，以创建新的服务器。在不可变基础设施中，我们将配置设置从服务器创建过程移动到构建过程。由于所有部署都是通过新镜像完成的，因此我们可以保留以前发布的版本历史，以便在需要回滚到旧构建时使用。这使我们能够减少部署时间和配置失败的机会，并扩展部署。图
    4.2 阐述了不可变和可变基础设施之间的差异。
- en: Notice that the new Instance B, generated from a “golden” machine image, is
    provisioned upon the destruction of Instance A in the immutable pattern. Note,
    too, that there is no Jenkins downtime during instance replacement with well-architected
    immutable patterns that have multiple instances in service at a given time. By
    contrast, in the mutable pattern, Instance A isn’t replaced. The same instance
    is modified manually or by using a script or tool, with the Jenkins updated from
    v1.0 to v2.0.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，从“黄金”机器镜像生成的新的实例 B 在不可变模式中实例 A 被销毁时进行配置。此外，请注意，在具有多个实例同时运行的精心设计的不可变模式中替换实例时，没有
    Jenkins 停机时间。相比之下，在可变模式中，实例 A 并没有被替换。相同的实例通过手动或使用脚本或工具进行修改，Jenkins 从 v1.0 更新到
    v2.0。
- en: '![](Images/CH04_F02_Labouardy.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH04_F02_Labouardy.png)'
- en: Figure 4.2 Updating via mutable and immutable infrastructures
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2 通过可变和不可变基础设施进行更新
- en: In this era of cloud computing, many companies are adopting immutable infrastructure
    to simplify configuration management and improve reliability by using infrastructure
    as code. With immutable infrastructure, instead of making changes on a running
    server, we create a new server. Creating immutable infrastructure is hard and
    needs a sophisticated process for building and testing. The best way to implement
    immutable infrastructure is to use a well-tested and tried tool.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在云计算时代，许多公司正在采用不可变基础设施来简化配置管理并通过使用基础设施即代码来提高可靠性。使用不可变基础设施时，我们不是在运行的服务器上进行更改，而是创建一个新的服务器。创建不可变基础设施很困难，需要复杂的构建和测试过程。实现不可变基础设施的最佳方式是使用经过充分测试和验证的工具。
- en: Multiple tools and frameworks allow you to build immutable infrastructure. The
    most famous ones are HashiCorp Packer, HashiCorp Vagrant, and Docker. In this
    book, we will keep our focus on machine images by using Packer. The goal is to
    illustrate the workflow for building immutable infrastructure and show how it
    can be fully automated using Packer. However, the same workflow can be applied
    while using other alternatives.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 多种工具和框架允许您构建不可变基础设施。其中最著名的是 HashiCorp Packer、HashiCorp Vagrant 和 Docker。在这本书中，我们将通过使用
    Packer 来专注于机器镜像。目标是展示构建不可变基础设施的工作流程，并展示如何使用 Packer 实现完全自动化。然而，相同的流程也可以在采用其他替代方案时应用。
- en: 4.2 Introducing Packer
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.2 介绍 Packer
- en: HashiCorp Packer ([www.packer.io](https://www.packer.io)) is a lightweight and
    easy-to-use open source tool that automates the creation of any type of machine
    image for multiple platforms. Packer is not a replacement for configuration management
    tools like Ansible, Puppet, or Chef. Packer works with these tools to install
    and configure software and dependencies while creating images.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: HashiCorp Packer ([www.packer.io](https://www.packer.io)) 是一个轻量级且易于使用的开源工具，可以自动化为多个平台创建任何类型的机器镜像。Packer
    不是配置管理工具（如 Ansible、Puppet 或 Chef）的替代品。Packer 与这些工具协同工作，在创建镜像的同时安装和配置软件及其依赖项。
- en: Packer uses a configuration file to create a machine image. Then it uses builders
    to spin up an instance on the target platform, and runs provisioners to configure
    applications or services. Once setup is done, it shuts down the instance and saves
    the new baked machine instance with any needed post-processing.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Packer 使用配置文件来创建机器镜像。然后它使用构建器在目标平台上启动实例，并运行配置器来配置应用程序或服务。一旦设置完成，它将关闭实例并保存带有任何所需后处理的新的烘焙机器实例。
- en: 'Using Packer has many advantages. Here are a few:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Packer 有许多优点。以下是一些：
- en: '*Fast infrastructure deployment*—Machine images allow us to more quickly launch
    provisioned and configured machines.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*快速基础设施部署*—机器镜像使我们能够更快地启动配置好的机器。'
- en: '*Scalable*—Packer installs and configures all needed software and dependencies
    for a machine during the image-creation process. The same image can be used to
    spawn any number of instances without doing extra configuration. (The same image
    can be used to deploy multiple Jenkins workers, for instance.)'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*可扩展性*—Packer 在镜像创建过程中为机器安装和配置所有需要的软件和依赖项。相同的镜像可以用来生成任意数量的实例，而无需进行额外配置。（例如，可以使用相同的镜像部署多个
    Jenkins 工作节点。）'
- en: '*Multiprovider support*—Packer can be used to create images for multiple cloud
    providers like AWS, GCP, and Microsoft Azure.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*多提供者支持*—Packer 可以用于为多个云提供商（如 AWS、GCP 和 Microsoft Azure）创建镜像。'
- en: Figure 4.3 illustrates a typical machine image build process with Packer.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3 使用 Packer 的典型机器镜像构建过程
- en: '![](Images/CH04_F03_Labouardy.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH04_F03_Labouardy.png)'
- en: Figure 4.3 Building Jenkins machine images with Packer
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3 使用 Packer 构建 Jenkins 机器镜像
- en: 'The drawback of using Packer is managing existing images: you need to manage
    them yourself by using tags or versions and keep deleting old, unused images (in
    AWS, you’re charged for the storage of the bits that make up your machine image,
    or AMI).'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Packer的缺点是管理现有镜像：您需要通过使用标签或版本自行管理它们，并持续删除旧的、未使用的镜像（在AWS中，您需要为构成您的机器镜像或AMI的位存储付费）。
- en: 4.2.1 How does it work?
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.1 它是如何工作的？
- en: Figure 4.4 illustrates the process Packer uses to bake machine images.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4说明了Packer用于烘焙机器镜像的过程。
- en: '![](Images/CH04_F04_Labouardy.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH04_F04_Labouardy.png)'
- en: Figure 4.4 Packer baking workflow
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4 Packer烘焙工作流程
- en: 'Here are the steps in the process:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是过程中的步骤：
- en: Boot a temporary instance using the base image defined in the template file.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用模板文件中定义的基镜像启动临时实例。
- en: Provision the instance by using configuration management tools like Ansible,
    Chef, or Puppet, or with a simple automated script to configure the instance into
    the desired state.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用配置管理工具如Ansible、Chef或Puppet，或者使用简单的自动化脚本来配置实例到所需的状态。
- en: Create a new machine image from the temporary running instance and shut down
    the temporary instance after the image is baked.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从临时运行实例创建新的机器镜像，并在镜像烘焙完成后关闭临时实例。
- en: Once a new machine image is created, booting a new server from this new image
    will give the same configuration that was already done on the temporary instance.
    This helps provide a smooth deployment process. This also helps scale our services
    fast.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新的机器镜像后，从这个新镜像启动新的服务器将提供与临时实例上已完成的相同配置。这有助于提供平滑的部署过程。这也帮助我们快速扩展服务。
- en: 'The Packer configuration, also known as a template file, can be written in
    JSON or YAML format. It consists of the following three main components:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Packer配置，也称为模板文件，可以写成JSON或YAML格式。它由以下三个主要组件组成：
- en: '*User variables*—This section is used to parameterize the Packer template file
    so we can keep secret, environment variables and other parameters out of the template.
    The section helps with the portability of the template file and helps in separating
    out the part that can be modified in our template. Variables can be passed through
    command lines, environment variables, HashiCorp Vault ([www.vaultproject.io](http://www.vaultproject.io/)),
    or files. The section is a key-value mapping with the variable name assigned to
    a default value.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*用户变量*—本节用于参数化Packer模板文件，以便我们可以将秘密、环境变量和其他参数从模板中排除。本节有助于模板文件的便携性，并有助于分离出我们模板中可以修改的部分。变量可以通过命令行、环境变量、HashiCorp
    Vault ([www.vaultproject.io](http://www.vaultproject.io/))或文件传递。本节是一个键值映射，变量名被分配了一个默认值。'
- en: '*Builders*—This section contains a list of builders that Packer uses to generate
    a machine image. Builders are responsible for creating an instance and generating
    machine images from them. A builder maps to a single machine image. This section
    contains information including the type (which is the name of the builder), access
    keys, and credentials required to connect to the platform (AWS, for instance).'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*构建器*—本节包含Packer用于生成机器镜像的构建器列表。构建器负责创建实例并从它们生成机器镜像。构建器映射到单个机器镜像。本节包含包括类型（即构建器的名称）、访问密钥以及连接到平台（例如AWS）所需的凭证等信息。'
- en: '*Provisioners*—This section, which is optional, contains a list of provisioners
    that Packer uses to install and configure software within a running instance before
    creating a machine image. The type specifies the name of a provisioner such as
    Shell, Chef, or Ansible.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*提供者*—本节是可选的，其中包含Packer在创建机器镜像之前，在运行实例中安装和配置软件所使用的提供者列表。类型指定了提供者的名称，例如Shell、Chef或Ansible。'
- en: NOTE For a full list of supported builders, refer to the official documentation
    at [www.packer.io/docs/builders/](http://www.packer.io/docs/builders). For a full
    list of supported provisioners, see [www.packer.io/docs/provisioners/](http://www.packer.io/docs/provisioners/).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：有关支持的构建器的完整列表，请参阅官方文档[www.packer.io/docs/builders/](http://www.packer.io/docs/builders/)。有关支持的提供者的完整列表，请参阅[www.packer.io/docs/provisioners/](http://www.packer.io/docs/provisioners/)。
- en: Packer helps bake configuration into the machine image during image creation
    time. This helps in creating identical servers in case things go wrong.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Packer在创建镜像时将配置烘焙到机器镜像中。这有助于在出现问题时创建相同的服务器。
- en: 4.2.2 Installation and configuration
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.2 安装和配置
- en: Packer is written in Go, which is a compiled language. Hence, installing Packer
    is straightforward; you just need to download the appropriate binary for your
    system and architecture from [www.packer.io/downloads/](http://www.packer.io/downloads/).
    Figure 4.5 shows the download page.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Packer 是用 Go 编写的，它是一种编译型语言。因此，安装 Packer 很简单；您只需从 [www.packer.io/downloads/](http://www.packer.io/downloads/)
    下载适合您的系统和架构的二进制文件即可。图 4.5 显示了下载页面。
- en: '![](Images/CH04_F05_Labouardy.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH04_F05_Labouardy.png)'
- en: Figure 4.5 Packer download page
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.5 Packer 下载页面
- en: NOTE Make sure the directory where you installed the Packer binary is on the `PATH` variable.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：请确保您安装 Packer 二进制文件的目录位于 `PATH` 变量中。
- en: 'After installing Packer, verify that the installation is working by opening
    a new terminal session and checking that Packer is available by issuing the following
    command:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 Packer 后，通过打开新的终端会话并执行以下命令来验证安装是否正常工作：
- en: '![](Images/CH04_F05_UN_code.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH04_F05_UN_code.png)'
- en: NOTE At the time of writing this book, the latest stable version of Packer is
    1.7.2.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在撰写本书时，Packer 的最新稳定版本为 1.7.2。
- en: If you get an error that Packer could not be found, your `PATH` environment
    variable was not set up properly. Otherwise, Packer is installed, and you’re ready
    to go!
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您收到错误信息，表明找不到 Packer，那么您的 `PATH` 环境变量设置不正确。否则，Packer 已安装，您就可以开始了！
- en: 4.2.3 Baking a machine image
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.3 烘焙机器镜像
- en: With Packer installed, let’s dive right into it and build our first image. Our
    first machine image will be an Amazon EC2 AMI with Jenkins pre-installed. To create
    this AMI, we need to write a Packer configuration file.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 Packer 后，让我们直接进入主题并构建我们的第一个镜像。我们的第一个机器镜像将是一个预安装 Jenkins 的 Amazon EC2 AMI。要创建此
    AMI，我们需要编写一个 Packer 配置文件。
- en: 'NOTE The following Packer template file has been cropped for brevity. The full
    template is available in the GitHub repository under the chapter4 folder: [http://mng.bz/GO8q](https://shortener.manning.com/GO8q).'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：为了简洁起见，以下 Packer 模板文件已被裁剪。完整的模板可在 GitHub 仓库的 chapter4 文件夹下找到：[http://mng.bz/GO8q](https://shortener.manning.com/GO8q)。
- en: Create a template.json file and fill it with the following content.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个 template.json 文件，并填充以下内容。
- en: Listing 4.1 Packer template for standalone Jenkins serve.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.1 用于独立 Jenkins 服务的 Packer 模板。
- en: '[PRE0]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This template file consists of three main sections:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 此模板文件由三个主要部分组成：
- en: '`variables`'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`variables`'
- en: '`builders`'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`builders`'
- en: '`provisioners`'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`provisioners`'
- en: Instead of hardcoding values in the template file, we are using variables that
    can be overridden at the Packer runtime. In our example, we have defined the variables
    in table 4.1.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不是在模板文件中硬编码值，而是在 Packer 运行时可以覆盖的变量中使用。在我们的示例中，我们在表 4.1 中定义了变量。
- en: Substitute the value of `source_ami` with the appropriate Amazon Linux AMI ID.
    The Amazon Linux AMI ID can be found by heading to AWS Management Console and
    navigating to the EC2 dashboard. Click Launch EC2 Instance. On the Choose AMI
    tab, type `Amazon Linux AMI` in the search bar, shown in figure 4.6.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `source_ami` 的值替换为适当的 Amazon Linux AMI ID。Amazon Linux AMI ID 可以通过前往 AWS 管理控制台并导航到
    EC2 仪表板找到。点击启动 EC2 实例。在“选择 AMI”选项卡中，在图 4.6 所示的搜索栏中输入“Amazon Linux AMI”。
- en: Table 4.1 Packer variables
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4.1 Packer 变量
- en: '| Variable | Description |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| 变量 | 描述 |'
- en: '| `region` | The name of the AWS region, such as `eu-central-1`, in which to
    launch the EC2 instance to create the AMI. While you can always copy an AMI from
    one region to another, for simplicity the AMI location will be the same as the
    region where the Jenkins EC2 instance will be deployed to. |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `region` | 启动 EC2 实例以创建 AMI 的 AWS 区域名称，例如 `eu-central-1`。虽然您始终可以从一个区域复制 AMI
    到另一个区域，但为了简单起见，AMI 位置将与 Jenkins EC2 实例部署到的区域相同。 |'
- en: '| `aws_profile` | The AWS profile used. Check chapter 3 for details about AWS
    CLI configuration. You can also provide AWS credentials through environment variables
    or with EC2 metadata if you plan to run Packer inside an EC2 instance. If you
    plan to use AWS access and secrets keys, keep them out of the template and provide
    them only during runtime by using the `-var` flag. |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `aws_profile` | 使用的 AWS 配置文件。有关 AWS CLI 配置的详细信息，请参阅第 3 章。如果您计划在 EC2 实例内部运行
    Packer，也可以通过环境变量或使用 EC2 元数据提供 AWS 凭据。如果您计划使用 AWS 访问和秘密密钥，请勿在模板中保留它们，并且仅通过使用 `-var`
    标志在运行时提供。 |'
- en: '| `instance_type` | The EC2 instance type to use while building the AMI, such
    as a `t2.micro`. A list of supported instance types can be found at [https://aws.amazon.com/ec2/instance-types/](https://aws.amazon.com/ec2/instance-types/).
    |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `instance_type` | 在构建AMI时使用的EC2实例类型，例如`t2.micro`。支持的实例类型列表可以在[https://aws.amazon.com/ec2/instance-types/](https://aws.amazon.com/ec2/instance-types/)找到。|'
- en: '| `source_ami` | The base AMI to use to boot the temporary EC2 instance. In
    the previous example, we’re using the official Amazon Linux image. You may need
    to change the source AMI ID based on what images exist when this template is run
    and the AWS region you’re using. |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `source_ami` | 用于启动临时EC2实例的基AMI。在先前的示例中，我们使用的是官方的Amazon Linux镜像。您可能需要根据此模板运行时存在的镜像和您使用的AWS区域更改源AMI
    ID。|'
- en: '![](Images/CH04_F06_Labouardy.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH04_F06_Labouardy.png)'
- en: Figure 4.6 Amazon Linux image identifier
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.6 Amazon Linux镜像标识符
- en: You can also find the ID programmatically with Packer by using the`source_ami_
    filter` attribute in the Packer template file. This attribute will automatically
    populate the `source_ami` attribute based on the defined filters. For instance,
    the following snippet selects the most recent Amazon Linux AMI (the full template
    file can be copied from chapter4/standalone/template-with-filter.json).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以通过在Packer模板文件中使用`source_ami_filter`属性以编程方式找到ID。此属性将根据定义的过滤器自动填充`source_ami`属性。例如，以下片段选择最新的Amazon
    Linux AMI（完整的模板文件可以从chapter4/standalone/template-with-filter.json复制）。
- en: '[PRE1]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If multiple AMIs meet all of the filtering criteria provided in `source_ami_filter`,
    the `most_recent` attribute will select the newest Amazon Linux image.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果多个AMI都满足`source_ami_filter`中提供的所有过滤条件，则`most_recent`属性将选择最新的Amazon Linux镜像。
- en: Because the target machine image is an Amazon Machine Image, we are using the `amazon-ebs` builder.
    This is the Amazon EC2 AMI builder that ships with Packer. This builder builds
    an EBS-backed AMI by launching a source AMI, provisioning on top of that, and
    repackaging it into a new AMI. Multiple builders are available based on the target
    platform. Separate builders are available for EC2, VMware, VirtualBox, and others.
    Packer comes with many builders by default and can also be extended to add new
    builders.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 因为目标机器镜像是一个亚马逊机器镜像，所以我们使用`amazon-ebs`构建器。这是与Packer一起提供的亚马逊EC2 AMI构建器。这个构建器通过启动源AMI，在其上提供配置，并将其重新打包成新的AMI来构建基于EBS的AMI。根据目标平台，有多种构建器可供选择。EC2、VMware、VirtualBox和其他平台都有单独的构建器。Packer默认包含许多构建器，也可以扩展以添加新的构建器。
- en: 'The `ami_name` attribute in the `builder` section is the name of the resulting
    AMI that will appear when managing AMIs in the AWS console. The name must be unique.
    To help make this unique, I have added it as a prefix to the version of the installed
    Jenkins server, but you can also use the current timestamp with the following
    format:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在`builder`部分中的`ami_name`属性是将在AWS控制台中管理AMI时出现的最终AMI的名称。名称必须是唯一的。为了帮助确保唯一性，我已经将其添加为安装的Jenkins服务器版本的名称前缀，但您也可以使用以下格式的当前时间戳：
- en: '[PRE2]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`{{timestamp}}` will be replaced by the Packer template engine to generate
    the current UNIX timestamp in Coordinated Universal Time (UTC).'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`{{timestamp}}`将被Packer模板引擎替换为当前协调通用时间（UTC）的UNIX时间戳。'
- en: The `provisioners` stage is responsible for installing and configuring all needed
    dependencies. Packer fully supports multiple modern configuration management tools
    such as Ansible, Chef, and Puppet. Bash scripts are also supported. To simplify
    the baking process for the Jenkins AMI, we have defined a bash script called setup.sh
    with the following content.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`provisioners`阶段负责安装和配置所有必需的依赖项。Packer完全支持多种现代配置管理工具，如Ansible、Chef和Puppet。Bash脚本也受到支持。为了简化Jenkins
    AMI的烘焙过程，我们定义了一个名为setup.sh的bash脚本，其内容如下。'
- en: Listing 4.2 Bash script to install Jenkins LTS
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.2 安装Jenkins LTS的Bash脚本
- en: '[PRE3]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The script is self-explanatory: it installs the Java Development Kit (JDK),
    which is mandatory to run Jenkins, and then it installs the latest stable version
    of Jenkins. Here we install the Jenkins LTS release. Although it might lag behind
    in terms of new features, it provides more stability than weekly releases. The
    weekly Jenkins releases deliver bug fixes and new features rapidly to users and
    plugin developers who need them. But for more conservative users, it’s preferable
    to stick to a release line that changes less often and receives only important
    bug fixes.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本是自我解释的：它安装了 Java 开发工具包（JDK），这是运行 Jenkins 所必需的，然后安装 Jenkins 的最新稳定版本。在这里，我们安装了
    Jenkins LTS 版本。尽管它在新功能方面可能落后，但它比每周发布版本提供了更多的稳定性。每周的 Jenkins 发布快速向需要它们的问题修复和新功能的用户和插件开发者提供。但对于更保守的用户来说，坚持一个变化较少且只接收重要问题修复的发布线更为可取。
- en: Once the Jenkins package is installed with the Yum package manager, the script
    configures Jenkins to start automatically if the machine has been restarted with
    the `chkconfig` command.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦使用 Yum 软件包管理器安装了 Jenkins 软件包，脚本就会配置 Jenkins 在机器使用 `chkconfig` 命令重启后自动启动。
- en: 'Now that our template file is defined, we can execute the following command
    to verify the syntax of the template file:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经定义了模板文件，我们可以执行以下命令来验证模板文件的语法：
- en: '[PRE4]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The command will return a zero exit status to indicate that the template.json
    syntax is valid.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 命令将返回零退出状态，表示 template.json 语法有效。
- en: Before we take this template and build an image from it, we need to assign the
    AmazonEC2FullAccess policy to the IAM user created in chapter 3 for Packer to
    be able to deploy an EC2 instance and create a machine image out of it.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们将此模板用于构建镜像之前，我们需要将 AmazonEC2FullAccess 策略分配给第 3 章中为 Packer 创建的 IAM 用户，以便
    Packer 能够部署 EC2 实例并从中创建机器镜像。
- en: Head back to AWS Console, navigate to the IAM dashboard, and jump to the Users
    section. Then, select the Packer user and attach the policy in listing 4.3, as
    shown in figure 4.7.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 AWS 控制台，导航到 IAM 仪表板，然后跳转到用户部分。然后，选择 Packer 用户并附加列表 4.3 中的策略，如图 4.7 所示。
- en: '![](Images/CH04_F07_Labouardy.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH04_F07_Labouardy.png)'
- en: Figure 4.7 Attaching the EC2 policy to an IAM user
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.7 将 EC2 策略附加到 IAM 用户
- en: NOTE A preferred approach is to provide the minimal set of permissions necessary
    for Packer to work. The following listing is an IAM policy with the minimal set
    permissions necessary for the Amazon plugin to work.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：推荐的做法是提供 Packer 运行所需的最小权限集。以下列表是一个 IAM 策略，其中包含了 Amazon 插件运行所需的最小权限集。
- en: Listing 4.3 AWS IAM policy for Packer
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.3 Packer 的 AWS IAM 策略
- en: '[PRE5]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'With a properly configured IAM user, it is time to build your first image.
    This is done by calling the `packer build` command with the template file as an
    argument:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 配置了 IAM 用户后，现在是时候构建您的第一个镜像了。这是通过使用模板文件作为参数调用 `packer build` 命令来完成的：
- en: '[PRE6]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Packer will deploy an EC2 instance based on the configuration specified in the
    template file, and then execute the bash script on the deployed instance. The
    output should look similar to the following. Note that this process typically
    takes a few minutes.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Packer 将根据模板文件中指定的配置部署 EC2 实例，然后在部署的实例上执行 bash 脚本。输出应该类似于以下内容。请注意，这个过程通常需要几分钟。
- en: '![](Images/CH04_F07_UN01_Labouardy.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH04_F07_UN01_Labouardy.png)'
- en: 'At the end of running the `packer build` command, Packer outputs the artifacts
    that were created as part of the build. Artifacts are the results of a build and
    typically represent the AMI ID. (Your ID will surely be different from the preceding
    one.) In this example, we have only a single artifact: the AMI was created in
    the Frankfurt region (`eu-central-1`).'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行 `packer build` 命令的末尾，Packer 将输出作为构建部分创建的工件。工件是构建的结果，通常代表 AMI ID。（您的 ID 一定会与前面的不同。）在这个例子中，我们只有一个工件：AMI
    是在法兰克福区域（`eu-central-1`）创建的。
- en: You can use the same template file to create Jenkins machine images for different
    platforms, all from the same specification. This is a nice feature that allows
    you to create machine images of different types of providers without repetitive
    coding. For example, we can modify the template to add Google Compute Cloud and
    Microsoft Azure builders to it, as shown in the following listing. The full template
    is available on the GitHub repository (chapter4/standalone/template-multiple-builders.json).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用相同的模板文件为不同的平台创建Jenkins机器镜像，所有这些镜像都来自相同的规范。这是一个很好的功能，允许您创建不同类型提供商的机器镜像，而无需重复编码。例如，我们可以修改模板以添加Google
    Compute Cloud和Microsoft Azure构建器，如下面的列表所示。完整的模板可在GitHub存储库中找到（chapter4/standalone/template-multiple-builders.json）。
- en: Listing 4.4 Jenkins multiplatform machine image builds
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.4 Jenkins多平台机器镜像构建
- en: '[PRE7]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Packer will create multiple Jenkins images for multiple platforms in parallel,
    all configured from a single template. In this example, Packer can make an Amazon
    Machine Image, Azure image, and Google Compute Engine image in parallel, provisioned
    with the same script, resulting in a near-identical Jenkins image.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Packer将并行创建多个平台的多个Jenkins镜像，所有这些镜像都从单个模板配置。在这个例子中，Packer可以并行创建Amazon Machine
    Image、Azure镜像和Google Compute Engine镜像，使用相同的脚本进行配置，从而产生几乎相同的Jenkins镜像。
- en: NOTE For a step-by-step guide on how to bake machine images for Azure virtual
    machines and Google Compute Engine instances, refer to chapter 6.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：有关如何为Azure虚拟机和Google Compute Engine实例烘焙机器图像的逐步指南，请参阅第6章。
- en: Once the AMI is created, the temporary EC2 instance will be terminated by Packer,
    and the baked AMI will be available in the AMIs section under Images on the EC2
    dashboard, as shown in figure 4.8.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建AMI，Packer将终止临时EC2实例，烘焙好的AMI将在EC2仪表板上的镜像部分下的AMIs部分中可用，如图4.8所示。
- en: '![](Images/CH04_F08_Labouardy.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH04_F08_Labouardy.png)'
- en: Figure 4.8 A new baked image is available on the Images section.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.8 在镜像部分有一个新的烘焙镜像可用。
- en: Now that our Jenkins AMI has been created, let’s test it out and see if Jenkins
    has been properly installed. Jump to Instances and click the Launch Instance button.
    Then, select the AMI built by Packer from the My AMIs section, as shown in figure
    4.9.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了Jenkins AMI，让我们测试一下，看看Jenkins是否已正确安装。跳转到实例，点击启动实例按钮。然后，从我的AMIs部分选择Packer构建的AMI，如图4.9所示。
- en: '![](Images/CH04_F09_Labouardy.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH04_F09_Labouardy.png)'
- en: Figure 4.9 The new AMI can be selected from the My AMIs section.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.9 新AMI可以从我的AMIs部分选择。
- en: For the instance type, select a general-purpose instance such as `t2.micro`,
    which is Free Tier eligible. We will cover Jenkins resource requirements in the
    next chapter.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 对于实例类型，选择一种通用实例，例如`t2.micro`，它是免费层合格的。我们将在下一章中介绍Jenkins资源需求。
- en: For now, leave all the other values at their default settings. Navigate to the
    Add Tags section and type a name for your EC2 instance in the value box. This
    name, more correctly known as a *tag*, will appear in the console when the instance
    launches. This makes it easy to keep track of the running Jenkins instance.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，将所有其他值保留在默认设置。导航到添加标签部分，并在值框中为您的EC2实例输入一个名称。这个名称，更准确地说是*标签*，将在实例启动时出现在控制台中。这使得跟踪正在运行的Jenkins实例变得容易。
- en: Configure the security group (firewall that controls traffic to the instance)
    to allow traffic on port 8080 from anywhere. Port 8080 is the default port to
    which the Jenkins web dashboard is exposed.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 配置安全组（控制实例流量的防火墙）以允许来自任何地方的8080端口的流量。8080端口是Jenkins Web仪表板的默认端口。
- en: NOTE The instance will be deployed inside the default VPC. In chapter 5, we
    will deploy the Jenkins cluster on a custom VPC from scratch and go through advanced
    network configurations.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：实例将在默认VPC内部署。在第5章中，我们将从头开始部署Jenkins集群到自定义VPC，并介绍高级网络配置。
- en: '![](Images/CH04_F10_Labouardy.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH04_F10_Labouardy.png)'
- en: Figure 4.10 Allowing traffic on port 8080
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.10 允许8080端口的流量
- en: The EC2 instance security group rules should look similar to figure 4.10.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: EC2实例的安全组规则应类似于图4.10。
- en: Make sure to allow inbound traffic on port 22 in order to authorize SSH traffic
    from your computer’s public IPv4 address. It’s mandatory; otherwise, you won’t
    be able to unlock the Jenkins dashboard later.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 确保允许来自您计算机的公共IPv4地址的22端口的入站流量，以便授权SSH流量。这是强制性的；否则，您将无法稍后解锁Jenkins仪表板。
- en: Finally, verify the configuration details in the Review section and select an
    SSH key pair, or create a new one if it’s the first time you’re launching an EC2
    instance. This configuration will allow you to connect to your instance via SSH.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在审查部分验证配置细节，并选择一个 SSH 密钥对，或者如果你是第一次启动 EC2 实例，创建一个新的密钥对。这个配置将允许你通过 SSH 连接到你的实例。
- en: Once the instance is running, point your browser to the instance’s public IP
    address and specify port 8080\. The Jenkins setup wizard should pop up on the
    screen, as shown in figure 4.11\. Congrats—you have successfully deployed a Jenkins
    instance from a custom AMI built with Packer.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦实例运行，将你的浏览器指向实例的公共 IP 地址，并指定端口 8080。Jenkins 设置向导应该会出现在屏幕上，如图 4.11 所示。恭喜你——你已经成功从使用
    Packer 构建的定制 AMI 中部署了 Jenkins 实例。
- en: '![](Images/CH04_F11_Labouardy.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH04_F11_Labouardy.png)'
- en: Figure 4.11 Jenkins setup wizard
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.11 Jenkins 设置向导
- en: You will be asked to unlock Jenkins by using an initial password. You can find
    this password inside the file /var/lib/jenkins/secrets/initialAdminPassword. (The
    following sections cover how to create a custom admin account for Jenkins.)
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 你将被要求使用初始密码解锁 Jenkins。你可以在这个文件中找到这个密码：/var/lib/jenkins/secrets/initialAdminPassword。（以下章节将介绍如何为
    Jenkins 创建自定义管理员账户。）
- en: So far, we have deployed Jenkins in standalone mode. Figure 4.12 summarizes
    the currently deployed architecture.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经以独立模式部署了 Jenkins。图 4.12 总结了当前部署的架构。
- en: '![](Images/CH04_F12_Labouardy.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH04_F12_Labouardy.png)'
- en: Figure 4.12 Jenkins standalone mode in AWS
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.12 AWS 中的 Jenkins 独立模式
- en: NOTE Make sure to terminate the instance when you no longer need it, to stop
    incurring charges for that instance.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：确保当你不再需要实例时终止它，以停止为此实例产生费用。
- en: Next, you will learn how to use Groovy scripts to customize and configure Jenkins
    settings while baking the Jenkins master AMI. Furthermore, we will create another
    image for Jenkins workers to deploy Jenkins at scale.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将学习如何使用 Groovy 脚本来定制和配置 Jenkins 设置，同时烘焙 Jenkins 主 AMI。此外，我们还将创建另一个 Jenkins
    工作节点镜像，以实现 Jenkins 的规模部署。
- en: 4.3 Baking the Jenkins master AMI
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.3 烘焙 Jenkins 主 AMI
- en: We can use the AMI built in the previous section, but the ending Jenkins instance
    will still have many settings requiring manual configuration, including Jenkins
    admin credentials, needed plugins to set up CI/CD pipelines, and security checks.
    While you can configure those manually, the purpose of this book is to avoid operational
    overhead as much as possible. We want to automate the tedious tasks while deploying
    a highly available and fault-tolerant Jenkins cluster on your favorite cloud provider
    with few commands by using automation tools like HashiCorp Packer and Terraform.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用上一节中构建的 AMI，但最终的 Jenkins 实例仍然有许多需要手动配置的设置，包括 Jenkins 管理员凭证、设置 CI/CD 管道的所需插件和安全检查。虽然你可以手动配置这些设置，但本书的目的是尽可能避免运营开销。我们希望在部署一个高可用性和容错性强的
    Jenkins 集群时，使用自动化工具如 HashiCorp Packer 和 Terraform，通过少量命令自动化繁琐的任务。
- en: NOTE When I say *high availability*, I am referring to a Jenkins cluster that
    can operate continuously without failure.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：当我提到“高可用性”时，我指的是一个可以持续运行而不会出现故障的 Jenkins 集群。
- en: To fully automate a Jenkins master instance, we will use Jenkins post-initialization
    scripts. We will leverage the power of Groovy scripts and place them in the $JENKINS_HOME/init.groovy.d
    directory. This directory will be consumed by Jenkins upon startup. Therefore,
    it can be used to preconfigure Jenkins to the target desired state.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 要完全自动化 Jenkins 主实例，我们将使用 Jenkins 初始化脚本。我们将利用 Groovy 脚本的力量，并将它们放置在 $JENKINS_HOME/init.groovy.d
    目录中。这个目录将在 Jenkins 启动时被消耗。因此，它可以用来预先配置 Jenkins 到目标所需状态。
- en: 4.3.1 Configuring Jenkins upon startup
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.1 启动时配置 Jenkins
- en: These scripts are written in Groovy and are executed inside the same Java Virtual
    Machine (JVM) as Jenkins, allowing full access to the domain model of Jenkins
    (we can access classes in Jenkins and all its plugins).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这些脚本是用 Groovy 编写的，并在与 Jenkins 相同的 Java 虚拟机（JVM）中执行，允许完全访问 Jenkins 的领域模型（我们可以访问
    Jenkins 及其所有插件中的类）。
- en: 'NOTE Another alternative to Groovy scripts is the Jenkins Configuration as
    Code (JCasC) plugin. For more details, refer to the official guide on GitHub:
    [http://mng.bz/zEJa](http://mng.bz/zEJa).'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：Groovy 脚本的另一种选择是 Jenkins 配置为代码（JCasC）插件。更多详情，请参考 GitHub 上的官方指南：[http://mng.bz/zEJa](http://mng.bz/zEJa)。
- en: The basic-security.groovy script in listing 4.5 creates a Jenkins user with
    full admin access. (You need to replace the `USERNAME` and `PASSWORD` attributes
    with your own values.) Furthermore, by default, the anonymous read access is disabled
    by default, which means Jenkins requires authentication to access the web dashboard.
    However, you can enable anonymous read access by adding the `strategy.setAllowAnonymousRead(true)` instruction before
    the`instance.save()` statement.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.5 中的 basic-security.groovy 脚本创建了一个具有完全管理员访问权限的 Jenkins 用户。（您需要将 `USERNAME`
    和 `PASSWORD` 属性替换为您自己的值。）此外，默认情况下，匿名读取访问被禁用，这意味着 Jenkins 需要身份验证才能访问网页仪表板。但是，您可以在
    `instance.save()` 语句之前添加 `strategy.setAllowAnonymousRead(true)` 指令来启用匿名读取访问。
- en: Listing 4.5 basic-security.groovy script
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.5 basic-security.groovy 脚本
- en: '[PRE8]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ Gets an instance of the Jenkins model
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 获取 Jenkins 模型的一个实例
- en: ❷ Creates a new user account by registering a password to the user
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 通过注册密码为用户创建一个新的账户
- en: ❸ Gives full access to logged-in users
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: ❸   允许已登录用户完全访问
- en: In addition to user management, we will also set some basic configurations for
    hardening Jenkins to protect against CSRF attacks. With CSRF protection enabled,
    all issued tokens should include a web session to prevent external attackers from
    obtaining web sessions. However, if your automation script uses a CSRF token for
    authentication, you can install the Strict Crumb Issuer plugin (available in the
    list of plugins installed while baking the Jenkins image) to exclude the web session
    ID from the validation criteria. We will enable CSRF protection with the csrf-protection.groovy
    script in the following listing.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 除了用户管理之外，我们还将为加强 Jenkins 的安全性设置一些基本配置，以防止 CSRF 攻击。启用 CSRF 保护后，所有发出的令牌都应该包含一个网络会话，以防止外部攻击者获取网络会话。但是，如果您的自动化脚本使用
    CSRF 令牌进行身份验证，您可以通过安装 Strict Crumb Issuer 插件（在构建 Jenkins 图像时安装的插件列表中可用）来排除网络会话
    ID 的验证标准。我们将在以下列表中通过 csrf-protection.groovy 脚本启用 CSRF 保护。
- en: Listing 4.6 csrf-protection.groovy script
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.6 csrf-protection.groovy 脚本
- en: '[PRE9]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ❶ Enables CSRF protection by setting up a crumb issuer
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 通过设置 crumb 发起器启用 CSRF 保护
- en: 'This option is enabled by default in new installations, starting with Jenkins
    2.*x*. You can also enable CSRF by updating `JENKINS_JAVA_OPTIONS`. Add the following
    argument:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 此选项在新安装中默认启用，从 Jenkins 2.*x* 开始。您也可以通过更新 `JENKINS_JAVA_OPTIONS` 来启用 CSRF。添加以下参数：
- en: '[PRE10]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: NOTE If you’re using the Jenkins linter feature to validate Jenkinsfiles against
    a Jenkins server protected from CSRF, you need to use an API token that doesn’t
    require a CSRF token (crumb) since Jenkins 2.96.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：如果您正在使用 Jenkins 代码检查功能来验证 Jenkinsfile 与受 CSRF 保护的 Jenkins 服务器，由于 Jenkins
    2.96，您需要使用不需要 CSRF 令牌（crumb）的 API 令牌。
- en: Jenkins has a built-in CLI that allows users and administrators to access Jenkins
    from a script or a shell environment. The use of the CLI is not recommended for
    security reasons (to prevent remote access). Hence, we will disable it through
    the disable-cli.groovy script in the following listing.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins 内置了一个 CLI，允许用户和管理员从脚本或 shell 环境访问 Jenkins。出于安全原因（防止远程访问），不建议使用 CLI。因此，我们将通过以下列表中的
    disable-cli.groovy 脚本来禁用它。
- en: Listing 4.7 disable-cli.groovy script
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.7 disable-cli.groovy 脚本
- en: '[PRE11]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ❶ Gets an instance of Jenkins and disabled CLI access
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: ❶   获取 Jenkins 实例并禁用 CLI 访问
- en: We will also disable the JNLP and old unencrypted protocols (JNLP-connect, JNLP2-connect,
    JNLP3-connect, and CLI-connect) to get rid of the warning messages in the web
    dashboard. The script disable-jnlp.groovy is in the following listing.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将禁用 JNLP 和旧的未加密协议（JNLP-connect、JNLP2-connect、JNLP3-connect 和 CLI-connect），以消除网页仪表板中的警告信息。禁用-jnlp.groovy
    脚本如下所示。
- en: Listing 4.8 disable-jnlp.groovy script
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.8 disable-jnlp.groovy 脚本
- en: '[PRE12]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: ❶ Sets 0 to indicate random available TCP port, -1 to disable this service
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 设置 0 以指示随机可用的 TCP 端口，-1 以禁用此服务
- en: ❷ Initializes HashSet structure with available agent protocols, removes old
    unencrypted protocols from the structure, and saves the new list
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: ❷   使用可用的代理协议初始化 HashSet 结构，从结构中删除旧的未加密协议，并保存新的列表
- en: Adding credentials to a new, local Jenkins server for development or troubleshooting
    can be a daunting task. However, with Groovy scripts and the right setup, developers
    can automate adding the required credentials into the new Jenkins server.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 为开发或故障排除向新的本地 Jenkins 服务器添加凭据可能是一项艰巨的任务。然而，通过 Groovy 脚本和正确的设置，开发者可以自动化将所需的凭据添加到新的
    Jenkins 服务器中。
- en: The Groovy script in listing 4.9 creates SSH credentials based on the AWS key
    pair we will use to deploy Jenkins worker instances. The SSH credentials object
    is created by using the `BasicSSHUserPrivateKey` constructor, which takes as parameters
    the credentials scope, username, SSH private key, and passphrase. The use of these
    SSH credentials will be illustrated in chapter 5.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.9 中的 Groovy 脚本基于我们将用于部署 Jenkins 工作节点实例的 AWS 密钥对创建 SSH 凭据。SSH 凭据对象是通过使用
    `BasicSSHUserPrivateKey` 构造函数创建的，它接受凭据范围、用户名、SSH 私钥和密码短语作为参数。这些 SSH 凭据的使用将在第 5
    章中说明。
- en: Listing 4.9 node-agent.groovy script
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.9 节点代理 Groovy 脚本
- en: '[PRE13]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ❶ Creates a Jenkins credential of type “SSH Username with private key.” The
    constructor takes the username, private key, passphrase, and description as arguments.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 创建一个类型为“SSH 用户名与私钥”的 Jenkins 凭据。构造函数接受用户名、私钥、密码短语和描述作为参数。
- en: NOTE Now every time the Jenkins server is restarted, the scripts will run and
    apply configuration for you. You don’t need to worry about executing these settings
    manually every time the server restarts.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：现在每次 Jenkins 服务器重启时，脚本都会运行并为你应用配置。你不需要担心每次服务器重启时都要手动执行这些设置。
- en: You can use Groovy init scripts to customize Jenkins and enforce the desired
    state. Although writing Groovy scripts requires knowing Jenkins internals and
    API, you’ve seen how to configure the common tasks and settings with Groovy scripts
    upon Jenkins initialization. We still need to install plugins to extend Jenkins
    functionalities in order to be able to build CI/CD pipelines.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 Groovy 初始化脚本来自定义 Jenkins 并强制执行所需的状态。尽管编写 Groovy 脚本需要了解 Jenkins 内部和 API，但你已经看到了如何在
    Jenkins 初始化时使用 Groovy 脚本配置常见任务和设置。我们仍然需要安装插件以扩展 Jenkins 功能，以便能够构建 CI/CD 管道。
- en: 4.3.2 Discovering Jenkins plugins
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.2 发现 Jenkins 插件
- en: Plugins can be easily installed from the Jenkins dashboard. However, the purpose
    of this section is to build a fully automated Jenkins AMI, because if you want
    to install many plugins, this manual process can be fairly long and boring. Therefore,
    we will use a script provided by the Jenkins community to install plugins, including
    their dependencies. The scripts take, as a parameter, a file containing the list
    of Jenkins plugins to be installed.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 插件可以从 Jenkins 仪表板轻松安装。然而，本节的目的在于构建一个完全自动化的 Jenkins AMI，因为如果你想要安装许多插件，这个手动过程可能会相当长且无聊。因此，我们将使用
    Jenkins 社区提供的脚本安装插件，包括它们的依赖项。这些脚本接受一个包含要安装的 Jenkins 插件列表的文件作为参数。
- en: Table 4.2 lists some of the most useful plugins that help developers save time,
    as well as making their lives easier. The full list is in the GitHub repository
    at chapter4/distributed/master/config/plugins.txt.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4.2 列出了一些最有用的插件，这些插件可以帮助开发者节省时间，并使他们的生活更加轻松。完整的列表可以在 GitHub 仓库的 chapter4/distributed/master/config/plugins.txt
    中找到。
- en: Table 4.2 Essential Jenkins plugins
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4.2 必备的 Jenkins 插件
- en: '| Plugin | Description |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| 插件 | 描述 |'
- en: '| blueocean | Provides the new Jenkins user experience with sophisticated visualizations
    of CI/CD pipelines and a bundled pipeline editor that makes automating CI/CD workflows
    approachable by guiding the user through an intuitive and visual process to create
    a pipeline. Refer to chapter 2 to explore the key features of Blue Ocean mode.
    |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| blueocean | 提供了新的 Jenkins 用户体验，具有复杂的 CI/CD 管道可视化以及一个捆绑的管道编辑器，该编辑器通过引导用户通过直观和可视化的过程创建管道，使自动化
    CI/CD 工作流程变得易于接近。请参阅第 2 章以探索 Blue Ocean 模式的关键特性。|'
- en: '| git | Provides access to any Git server with support for fundamental Git
    operations within Jenkins pipelines. It can pull, fetch, check out, branch, list,
    merge, tag, and push Git repositories. |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| git | 提供对任何 Git 服务器访问权限，并在 Jenkins 管道中支持基本的 Git 操作。它可以拉取、获取、检出、分支、列出、合并、标记和推送
    Git 仓库。|'
- en: '| ssh-agent | Allows you to provide SSH credentials to builds via ssh-agent
    in Jenkins. The ssh-agent is a helper program to hold private keys used for public-key
    authentication. |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| ssh-agent | 允许你通过 Jenkins 中的 ssh-agent 为构建提供 SSH 凭据。ssh-agent 是一个辅助程序，用于保存用于公钥认证的私钥。|'
- en: '| ssh-credentials | Allows you to store SSH credentials in Jenkins. It is used
    to launch Jenkins workers via SSH and execute Docker commands on a Kubernetes
    cluster remotely over SSH. |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| ssh-credentials | 允许你在 Jenkins 中存储 SSH 凭据。它用于通过 SSH 启动 Jenkins 工作节点，并在 Kubernetes
    集群上远程执行 Docker 命令。|'
- en: '| slack | Provides Jenkins notification integration with Slack. It can be used
    to send Slack notifications with Jenkins job build status upon the completion
    of a CI/CD pipeline. This plugin does require some straightforward setup on the
    Slack side in order to connect and post messages. |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| slack | 提供了 Jenkins 与 Slack 的通知集成。它可以在 CI/CD 管道完成后发送 Slack 通知，显示 Jenkins
    作业的构建状态。此插件需要在 Slack 端进行一些简单的设置，以便连接和发布消息。|'
- en: '| credentials-binding | Allows credentials to be bound to environment variables
    for use from miscellaneous build steps. It gives you an easy way to package up
    all of a job’s secret files and passwords, and access them using environment variables
    during the build. |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| credentials-binding | 允许将凭证绑定到环境变量，以便在杂项构建步骤中使用。它为您提供了一个简单的方法来打包所有作业的秘密文件和密码，并在构建期间使用环境变量访问它们。|'
- en: '| github-pullrequest | Fundamental for integrating Jenkins with GitHub repositories,
    it supports GitHub pull requests, branches, and custom webhooks. GitHub will trigger
    a new hook each time a pull request is opened, and once Jenkins receives the hook,
    it will run the associated job. |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| github-pullrequest | 对于将 Jenkins 与 GitHub 仓库集成至关重要，它支持 GitHub 拉取请求、分支和自定义
    webhook。每次打开拉取请求时，GitHub 都会触发一个新的钩子，一旦 Jenkins 收到钩子，它就会运行相关的作业。|'
- en: '| job-dsl | Allows jobs to be defined in a programmatic form in a human-readable
    file. It can be used to create complex pipelines for Jenkins freestyle jobs. |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| job-dsl | 允许以程序化的形式在可读文件中定义作业。它可以用来为 Jenkins freestyle 作业创建复杂的管道。|'
- en: '| jira | Does pretty much what it says on the tin. It allows developers to
    integrate Jira ([www.atlassian.com/software/jira](http://www.atlassian.com/software/jira))
    into Jenkins to update Jira open issues within CI/CD pipelines. It also associates
    build and deployment information with relevant Jira tickets and exposes key information
    about the pipeline across Jira boards. |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| jira | 几乎做了它所说的所有事情。它允许开发者在 Jenkins 中集成 Jira ([www.atlassian.com/software/jira](http://www.atlassian.com/software/jira))，以在
    CI/CD 管道中更新 Jira 开放问题。它还将构建和部署信息与相关的 Jira 票据关联，并在 Jira 板上暴露有关管道的关键信息。|'
- en: '| htmlpublisher | Useful for publishing HTML reports that your builds generate
    at build time. It can be used to generate code coverage HTML reports and track
    the percentage of tests covering your application source code in a user-friendly
    way. |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| htmlpublisher | 在构建时生成 HTML 报告非常有用。它可以用来生成代码覆盖率 HTML 报告，并以用户友好的方式跟踪测试覆盖应用程序源代码的百分比。|'
- en: '| email-ext | Can be used to send email notifications. It’s highly customizable:
    you can configure notifications triggers, content, and recipients. Plus, it supports
    both plaintext and HTML for the email body. |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| email-ext | 可以用来发送电子邮件通知。它高度可定制：您可以配置通知触发器、内容和收件人。此外，它支持电子邮件正文的纯文本和 HTML
    格式。|'
- en: '| sonar | Allows easy integration of SonarQube ([www.sonarqube.org](http://www.sonarqube.org/)),
    the open source platform for continuous inspection of code quality and code security.
    |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| sonar | 允许轻松集成 SonarQube ([www.sonarqube.org](http://www.sonarqube.org/))，这是一个开源平台，用于持续检查代码质量和代码安全性。|'
- en: '| embeddable-build-status | Generates badges for all your Jenkins jobs that
    display, in real time, their build status. You can add these badges to your Git
    repository README.md file. |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| embeddable-build-status | 为您的所有 Jenkins 作业生成徽章，实时显示它们的构建状态。您可以将这些徽章添加到 Git
    仓库的 README.md 文件中。|'
- en: NOTE These are just some of the plugins we will use, and upcoming chapters offer
    dozens more to explore.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：这些只是我们将要使用的一些插件，未来的章节将提供更多插件以供探索。
- en: More than a thousand plugins are available to support almost every solution,
    tool, and process for building, deploying, and automating your projects within
    Jenkins pipelines. The Jenkins Plugins Index, shown in figure 4.13, has over more
    than 1,800 plugins at [https://plugins.jenkins.io/](https://plugins.jenkins.io/),
    free for download and use.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Jenkins 管道中，有超过一千个插件可供使用，几乎支持构建、部署和自动化项目的所有解决方案、工具和流程。如图 4.13 所示的 Jenkins
    插件索引，在 [https://plugins.jenkins.io/](https://plugins.jenkins.io/) 上有超过 1,800 个插件，免费下载和使用。
- en: '![](Images/CH04_F13_Labouardy.png)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH04_F13_Labouardy.png)'
- en: Figure 4.13 Jenkins plugins
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.13 Jenkins 插件
- en: NOTE Before installing a Jenkins plugin, make sure to review the changelog in
    the plugin’s description page, as not all plugins may be safe to use. Also, always
    pick the latest stable version available.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在安装 Jenkins 插件之前，请务必查看插件描述页面中的变更日志，因为并非所有插件都安全使用。此外，始终选择可用的最新稳定版本。
- en: Now you are more familiar with the essential Jenkins plugins. Let’s go ahead
    and install them.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您对基本的 Jenkins 插件更加熟悉了。让我们继续安装它们。
- en: The script in listing 4.10 will go through the file containing a list of Jenkins
    plugins line by line, and then issue a cURL command to download the plugin from
    the Jenkins Plugins Index. Finally, the script will copy the downloaded plugin
    file to the /var/lib/jenkins/plugins folder. The listing illustrates the main
    function, and the full script can be downloaded from the GitHub repository at
    chapter4/distributed/master/ config/install-plugins.sh.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.10 中的脚本将逐行遍历包含 Jenkins 插件列表的文件，然后向 Jenkins 插件索引发出 cURL 命令以下载插件。最后，脚本将下载的插件文件复制到
    /var/lib/jenkins/plugins 文件夹。列表展示了主要功能，完整的脚本可以从 GitHub 仓库 chapter4/distributed/master/config/install-plugins.sh
    下载。
- en: Listing 4.10 install-plugins.sh script
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.10 install-plugins.sh 脚本
- en: '[PRE14]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The .hpi extension stood for *Hudson plugin* (remember, Jenkins was a fork of
    the Hudson project). With the move away from Hudson to Jenkins, this became *Jenkins
    plugin* and hence the .jpi format. Since the Jenkins v1.5 release, all .hpi plugin
    files are renamed automatically to .jpi at boot time.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: .hpi 扩展名代表 *Hudson 插件*（记住，Jenkins 是 Hudson 项目的分支）。随着从 Hudson 转向 Jenkins，这变成了
    *Jenkins 插件*，因此出现了 .jpi 格式。自从 Jenkins v1.5 版本发布以来，所有 .hpi 插件文件在启动时都会自动重命名为 .jpi。
- en: By now, we have configured and automated all tasks needed to set up a running
    Jenkins server out of the box. Therefore, there’s no need for the setup wizard
    at Jenkins startup (see figure 4.11). As a result, we will disable it by writing
    a Groovy init script. Create a skip-jenkins-setup.groovy script with the following
    content.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经配置并自动化了所有设置即插即用 Jenkins 服务器所需的任务。因此，在 Jenkins 启动时无需设置向导（见图 4.11）。因此，我们将通过编写
    Groovy 初始化脚本来禁用它。创建一个包含以下内容的 skip-jenkins-setup.groovy 脚本。
- en: Listing 4.11 skip-jenkins-setup.groovy script
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.11 skip-jenkins-setup.groovy 脚本
- en: '[PRE15]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Finally, we will update the Packer template file used in the first section to
    copy the Groovy scripts described previously to the temporary instance by using
    the file *provisioner* ([www.packer.io/docs/provisioners/file/](https://www.packer.io/docs/provisioners/file/)).
    Next, we use a shell provisioner to move these files to the init.groovy.d folder.
    The template.json file should look similar to the following listing.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将更新第一部分使用的 Packer 模板文件，通过使用文件 *provisioner* ([www.packer.io/docs/provisioners/file/](https://www.packer.io/docs/provisioners/file/))
    将之前描述的 Groovy 脚本复制到临时实例。接下来，我们使用 shell provisioner 将这些文件移动到 init.groovy.d 文件夹。template.json
    文件应类似于以下列表。
- en: Listing 4.12 Jenkins master template file
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.12 Jenkins 主机模板文件
- en: '[PRE16]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '❶ List of variables should be declared here such as: aws_profile, region, instance_type,
    and source_ami'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 应在此处声明变量列表，例如：aws_profile、region、instance_type 和 source_ami
- en: ❷ Name of the baked machine image. The version number (2.204.1) should be replaced
    based on the current version you have installed.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 烘焙机器镜像的名称。版本号（2.204.1）应根据您当前安装的版本进行替换。
- en: ❸ Copies the Groovy scripts folder from the local machine to /tmp in the host
    machine
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将 Groovy 脚本文件夹从本地机器复制到主机机的 /tmp 文件夹
- en: ❹ Copies the configuration files from the local machine to /tmp in the host
    machine
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 将配置文件从本地机器复制到主机机的 /tmp 文件夹
- en: ❺ Copies the user private SSH key to the /tmp folder
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 将用户私有的 SSH 密钥复制到 /tmp 文件夹
- en: ❻ Executes the setup.sh shell script to copy the files from the /tmp folder
    to the right folder and installs Jenkins and its dependencies
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 执行 setup.sh 脚本来将文件从 /tmp 文件夹复制到正确的文件夹，并安装 Jenkins 及其依赖项
- en: NOTE The variables section has been omitted for brevity. The full template file
    can be found on GitHub at chapter4/distributed/master/template.json.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 备注：为了简洁，省略了变量部分。完整的模板文件可以在 GitHub 上找到，位于 chapter4/distributed/master/template.json。
- en: The SSH key can be generated with `ssh-keygen`. The command will provide a series
    of prompts. Feel free to use the defaults. However, from a security perspective,
    it’s a good idea to enter a passphrase. Table 4.3 provides a complete list of
    Packer variables.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: SSH 密钥可以使用 `ssh-keygen` 生成。该命令将提供一系列提示。请随意使用默认值。然而，从安全角度考虑，输入密码短语是个好主意。表 4.3
    提供了 Packer 变量的完整列表。
- en: Table 4.3 Jenkins master Packer variables
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4.3 Jenkins 主机 Packer 变量
- en: '| Variable | Description |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| 变量 | 描述 |'
- en: '| `region` | AWS region where the Jenkins master machine image will be created,
    such as `eu-central-1` (aka Frankfurt). |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| `region` | Jenkins 主机机器镜像将被创建的 AWS 区域，例如 `eu-central-1` （也称为法兰克福）。|'
- en: '| `aws_profile` | The profile to use in the shared credentials file for AWS.
    See Amazon’s documentation on specifying profiles for more details: [https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html](https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html).
    |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| `aws_profile` | 在 AWS 共享凭证文件中使用的配置文件。有关指定配置文件的更多详细信息，请参阅 Amazon 的文档：[https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html](https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html)。|'
- en: '| `instance_type` | The EC2 instance type to use while baking the target AMI,
    such as`t2.micro`, which is Free Tier eligible. |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| `instance_type` | 在烘焙目标 AMI 时使用的 EC2 实例类型，例如 `t2.micro`，它是免费层合格的。|'
- en: '| `source_ami` | The source AMI that the temporary instance will be based on.
    We’re using the official Amazon Linux image. The ID should be updated according
    to the AWS region you’re using. Refer to figure 4.6 for an example. |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| `source_ami` | 将作为临时实例基础的源 AMI。我们使用官方的 Amazon Linux 映像。ID 应根据您使用的 AWS 区域进行更新。请参考图
    4.6 以获取示例。|'
- en: '| `ssh_key` | Private SSH key location (~/.ssh/id_rsa), the same key you will
    use to SSH to Jenkins worker instances. A Groovy script will be executed at boot
    time to add the private key as a credential on the Jenkins master to set up the
    initial connection with Jenkins workers over SSH. |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| `ssh_key` | 私有 SSH 密钥位置 (~/.ssh/id_rsa)，这是您将用于 SSH 到 Jenkins 工作实例的相同密钥。在启动时将执行一个
    Groovy 脚本，将私有密钥作为凭证添加到 Jenkins 主机，以通过 SSH 设置与 Jenkins 工作实例的初始连接。|'
- en: Once files are uploaded to the temporary instance built by Packer, a setup.sh
    script will be executed to install the Jenkins LTS version. Next, the script installs
    the Git client (to clone GitHub repositories in advanced chapters). Then, it copies
    the workers’ private SSH key to the /var/lib/jenkins/.ssh folder and set permissions.
    Finally, it moves Groovy scripts to the initialization folder, installs essentials
    plugins by executing the install-plugins.sh script, and starts the Jenkins server.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦文件上传到由 Packer 构建的临时实例，就会执行 setup.sh 脚本来安装 Jenkins LTS 版本。接下来，脚本安装 Git 客户端（用于在高级章节中克隆
    GitHub 仓库）。然后，它将工作实例的私有 SSH 密钥复制到 /var/lib/jenkins/.ssh 文件夹并设置权限。最后，它将 Groovy
    脚本移动到初始化文件夹，通过执行 install-plugins.sh 脚本来安装基本插件，并启动 Jenkins 服务器。
- en: It’s worth mentioning that scripts files were uploaded to the /tmp folder; Packer
    can upload files only to locations that the provisioning user (`ec2-user`) has
    permission to access. The following listing contains the content of setup.sh.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，脚本文件已上传到 /tmp 文件夹；Packer 只能上传到配置用户 (`ec2-user`) 有权限访问的位置。以下列表包含 setup.sh
    的内容。
- en: Listing 4.13 setup.sh script (install Jenkins)
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.13 setup.sh 脚本（安装 Jenkins）
- en: '[PRE17]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: ❶ Installs JDK (minimum v1.8.0), which is required for Jenkins to be up and
    running
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 安装 JDK（最低版本 v1.8.0），这是 Jenkins 运行所必需的
- en: ❷ Installs Git client, which will be needed to clone project GitHub repositories
    in upcoming chapters
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 安装 Git 客户端，在后续章节中克隆 GitHub 项目仓库时将需要使用
- en: ❸ Copies the private SSH key used to deploy Jenkins workers/agents to JENKINS_HOME
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 将用于部署 Jenkins 工作实例/代理的私有 SSH 密钥复制到 JENKINS_HOME
- en: ❹ Moves the Groovy scripts to init.groovy.d
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 将 Groovy 脚本移动到 init.groovy.d
- en: ❺ Installs needed dependencies by running install-plugins.sh
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 通过运行 install-plugins.sh 安装所需的依赖项
- en: ❻ Starts the Jenkins service
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 启动 Jenkins 服务
- en: 'The template directory structure should look like the following. The scripts
    directory holds initial configuration and seeding scripts. The config folder contains
    the list of essential plugins to install, as well as the shell script to install
    plugins from the Jenkins Plugin Index:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 模板目录结构应如下所示。脚本目录包含初始配置和种子脚本。配置文件夹包含要安装的基本插件的列表，以及从 Jenkins 插件索引安装插件的 shell 脚本：
- en: '[PRE18]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: NOTE Jenkins captures launch configuration parameters in the /etc/sysconfig/jenkins
    file. If you want to add Java arguments, it’s the file you’re looking for.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：Jenkins 在 /etc/sysconfig/jenkins 文件中捕获启动配置参数。如果您想添加 Java 参数，那就是您要找的文件。
- en: Prior to building the AMI, it’s a good idea to validate the syntactical correctness
    of the template file by issuing the `packer` `validate` command.`Template` `validated
    successfully` is the expected output if the template is valid.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建 AMI 之前，通过发出 `packer` 的 `validate` 命令验证模板文件的语法正确性是个好主意。如果模板有效，预期的输出是 `Template
    validated successfully`。
- en: 'Now that the template is validated, we will bake the AMI with the `packer` `build`command:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在模板已验证，我们将使用 `packer` 的 `build` 命令来烘焙 AMI：
- en: '[PRE19]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The process can take several minutes. Output similar to this is expected.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 该过程可能需要几分钟。预期输出类似于以下内容。
- en: '![](Images/CH04_F13_UN02_Labouardy.png)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH04_F13_UN02_Labouardy.png)'
- en: If the script succeeds, Packer should show a message containing the AMI ID,
    and the Jenkins master AMI will be available in the EC2 dashboard, as shown in
    figure 4.14.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如果脚本成功，Packer 应该显示包含 AMI ID 的消息，并且 Jenkins 主节点 AMI 将在 EC2 仪表板中可用，如图 4.14 所示。
- en: '![](Images/CH04_F14_Labouardy.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH04_F14_Labouardy.png)'
- en: Figure 4.14 Jenkins master AMI
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.14 Jenkins 主节点 AMI
- en: NOTE The AMI name should be unique. Therefore, you might need to delete the
    existing image from your AWS account if it exists already.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：AMI 名称应该是唯一的。因此，如果已经存在，您可能需要从您的 AWS 账户中删除现有的镜像。
- en: Finally, we can spin up an EC2 instance based on the baked AMI. Once the instance
    is running, point your browser to the instance’s public IP address on port 8080\.
    After a while, you’ll see the screen in figure 4.15.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以基于烘焙的 AMI 启动一个 EC2 实例。一旦实例运行，将您的浏览器指向实例的公共 IP 地址的 8080 端口。过一会儿，您将看到图
    4.15 中的屏幕。
- en: '![](Images/CH04_F15_Labouardy.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH04_F15_Labouardy.png)'
- en: Figure 4.15 Jenkins web dashboard
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.15 Jenkins 网页仪表板
- en: This time, the setup wizard should disappear and many functionalities should
    be added. Sign in using the admin credentials defined in the basic-security.groovy
    script from listing 4.5\. After login, you can verify that Jenkins credentials
    are created by going to the Credentials item on the left; see figure 4.16\. So
    far, only the Jenkins worker SSH credential has been created (see listing 4.9),
    but you can customize the Groovy script to create additional credentials for external
    services like GitHub, Nexus, or SonarQube.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，设置向导应该会消失，并且应该添加许多功能。使用列表 4.5 中的基本安全.groovy 脚本中定义的管理员凭据登录。登录后，您可以通过转到左侧的凭据项来验证
    Jenkins 凭据是否已创建；请参见图 4.16。到目前为止，只创建了 Jenkins 工作节点 SSH 凭据（请参见列表 4.9），但您可以通过自定义
    Groovy 脚本来创建针对 GitHub、Nexus 或 SonarQube 等外部服务的其他凭据。
- en: '![](Images/CH04_F16_Labouardy.png)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH04_F16_Labouardy.png)'
- en: Figure 4.16 Jenkins credentials
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.16 Jenkins 凭据
- en: Moreover, the essential plugins were also installed. Jump to Manage Jenkins
    from the home page and then navigate to Plugins. You should see a list of plugins
    installed by default on the Installed tab, as shown in figure 4.17.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还安装了基本插件。从主页跳转到管理 Jenkins，然后导航到插件。您应该在已安装选项卡上看到默认安装的插件列表，如图 4.17 所示。
- en: '![](Images/CH04_F17_Labouardy.png)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/CH04_F17_Labouardy.png)'
- en: Figure 4.17 Jenkins installed plugins
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.17 Jenkins 已安装插件
- en: Now that we have defined a Jenkins configuration as code, we can spawn it as
    many times as possible, on different machines, with the same result. And we’ve
    had no tiresome manual walks through the GUI.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将 Jenkins 配置定义为代码，我们可以在不同的机器上尽可能多地启动它，以获得相同的结果。而且我们没有经历任何繁琐的 GUI 手动操作。
- en: 4.4 Baking the Jenkins worker AMI
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.4 烘焙 Jenkins 工作节点 AMI
- en: The Jenkins worker AMI baking process should be straightforward; see the following
    listing. The only requirement for an instance to be a Jenkins worker or build
    agent is to have a JDK. Modern Jenkins versions require a Java 8 runtime environment.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins 工作节点 AMI 烘焙过程应该是直接的；请参见以下列表。一个实例要成为 Jenkins 工作节点或构建代理的唯一要求是拥有 JDK。现代
    Jenkins 版本需要 Java 8 运行环境。
- en: Listing 4.14 Jenkins worker template file
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 4.14 Jenkins 工作节点模板文件
- en: '[PRE20]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The variables in table 4.4 should be provided during build time within the template
    file or with the `-var` flag.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4.4 中的变量应在模板文件构建时间内提供，或使用 `-var` 标志。
- en: Tabe 4.4 Jenkins worker Packer variables
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4.4 Jenkins 工作节点 Packer 变量
- en: '| Variable | Description |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '| 变量 | 描述 |'
- en: '| `region` | AWS region where the Jenkins worker machine image will be created.
    Similar to the Jenkins master AWS region value. |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '| `region` | AWS 区域，其中将创建 Jenkins 工作节点机器镜像。类似于 Jenkins 主节点 AWS 区域值。|'
- en: '| `aws_profile` | The profile to use in the shared credentials file for AWS.
    See Amazon''s documentation on specifying profiles for more details: [http://mng.bz/01Yx](http://mng.bz/01Yx).
    |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '| `aws_profile` | 在 AWS 共享凭据文件中使用的配置文件。有关指定配置文件的更多详细信息，请参阅 Amazon 的文档：[http://mng.bz/01Yx](http://mng.bz/01Yx)。|'
- en: '| `instance_type` | The EC2 instance type to use while baking the target AMI,
    such as`t2.micro`, which is Free Tier eligible. |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| `instance_type` | 在烘焙目标 AMI 时使用的 EC2 实例类型，例如`t2.micro`，它符合免费层资格。|'
- en: '| `source_ami` | The source AMI that the temporary instance will be based on.
    We’re using the official Amazon Linux image. The ID should be updated according
    to the AWS region you’re using. |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '| `source_ami` | 将作为临时实例基础的源 AMI。我们使用官方的 Amazon Linux 镜像。ID 应根据您使用的 AWS 区域进行更新。|'
- en: Packer will use the shell provisioner to install the JDK, as well as any tool
    that you may require to run your builds (Git or Docker, for example). You can
    take this script further and create a user called `jenkins` with a home directory
    to store Jenkins job workspaces, as shown in the following listing.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: Packer将使用shell提供程序来安装JDK，以及您可能需要运行构建的任何工具（例如Git或Docker）。您可以将此脚本进一步扩展，创建一个名为`jenkins`的用户，并为其创建一个主目录以存储Jenkins作业工作空间，如下所示。
- en: Listing 4.15 setup.sh scrip.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 列表4.15 setup.sh脚本。
- en: '[PRE21]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: NOTE Docker is necessary, as we are going to define CI/CD pipelines for Dockerized
    microservices in upcoming chapters.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：Docker是必需的，因为我们将在接下来的章节中为Docker化的微服务定义CI/CD管道。
- en: Issue the `packer build` command to bake the Jenkins worker AMI. Once the image-baking
    process is finished, the worker’s AMI will be available on the EC2 dashboard,
    as shown in figure 4.18.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 输出`packer build`命令以烘焙Jenkins工作节点AMI。一旦图像烘焙过程完成，工作节点的AMI将在EC2仪表板上可用，如图4.18所示。
- en: '![](Images/CH04_F18_Labouardy.png)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH04_F18_Labouardy.png)'
- en: Figure 4.18 Jenkins worker AMI
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.18 Jenkins工作节点AMI
- en: NOTE After running the preceding examples, your AWS account now has an AMI associated
    with it. AMIs are stored in S3 by Amazon, so unless you want to be charged about
    $0.01 per month, you’ll probably want to remove these images if they’re not needed.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在运行前面的示例之后，您的AWS账户现在已关联了一个AMI。这些AMI由Amazon存储在S3中，因此除非您希望每月支付约0.01美元的费用，否则如果您不需要这些镜像，您可能希望删除它们。
- en: Now that our Jenkins cluster AMIs are ready to use, we will use them in the
    next chapter to deploy our cluster on AWS with the IaC tool HashiCorp Terraform.
    Figure 4.19 illustrates how Terraform will be integrated.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了Jenkins集群AMI，我们将在下一章中使用它们，通过HashiCorp Terraform IaC工具在AWS上部署我们的集群。图4.19说明了Terraform的集成方式。
- en: '![](Images/CH04_F19_Labouardy.png)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH04_F19_Labouardy.png)'
- en: Figure 4.19 Packer will provision a temporary instance from a template file,
    and provision the instance with all needed configs and dependencies. From there,
    Terraform will deploy EC2 instances based on the baked image.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.19 Packer将从模板文件中提供一个临时实例，并使用所有需要的配置和依赖项配置该实例。然后，Terraform将基于烘焙的镜像部署EC2实例。
- en: If you plan to embrace the immutable infrastructure approach for upgrading Jenkins
    or installing additional plugins, triggering the provisioning process with Packer
    can get challenging. That’s why you should opt for automation and set up a pipeline
    with Jenkins to automate the baking workflow for AMI. A basic workflow will use
    GitHub to store Packer template files and trigger a build on Jenkins upon the
    push event. The job will validate the template changes, start the baking process
    (1), and create an EC2 instance (2) based on the new baked AMI. Figure 4.20 summarizes
    the entire workflow.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您计划采用不可变基础设施方法来升级Jenkins或安装额外的插件，使用Packer触发配置过程可能会变得具有挑战性。这就是为什么您应该选择自动化，并使用Jenkins设置一个管道来自动化AMI的烘焙工作流程。基本工作流程将使用GitHub存储Packer模板文件，并在推送事件上触发Jenkins上的构建。作业将验证模板更改，启动烘焙过程（1），并基于新的烘焙AMI创建一个EC2实例（2）。图4.20总结了整个工作流程。
- en: '![](Images/CH04_F20_Labouardy.png)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/CH04_F20_Labouardy.png)'
- en: Figure 4.20 Automating the AMIs with Jenkins
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.20 使用Jenkins自动化AMI
- en: NOTE Chapter 7 covers how to set up GitHub webhooks to continuously trigger
    Jenkins build jobs when a push or merge event occurs.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：第7章介绍了如何设置GitHub钩子，以便在发生推送或合并事件时持续触发Jenkins构建作业。
- en: Summary
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: HashiCorp Packer leverages the power of immutable infrastructure to bake custom
    machine images with all needed dependencies.
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HashiCorp Packer利用不可变基础设施的力量来烘焙包含所有所需依赖项的自定义机器镜像。
- en: Setting up Jenkins is a complex process, as both Jenkins and its plugins require
    tuning and configuration, with dozens of parameters to set within the web UI Manage
    Jenkins section.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置Jenkins是一个复杂的过程，因为Jenkins及其插件都需要调整和配置，在“管理Jenkins”部分的Web UI中需要设置数十个参数。
- en: Configuration scripts in the init.groovy directory are executed in alphabetical
    order during Jenkins boot time. This is ideal for setting up seeding and configuration
    job interfaces.
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在init.groovy目录中的配置脚本在Jenkins启动时按字母顺序执行。这对于设置种子和配置作业接口是理想的。
- en: Jenkins provides thousands of plugins to support building, deploying, and automating
    any project.
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jenkins提供了数千个插件来支持构建、部署和自动化任何项目。
- en: The weekly Jenkins releases deliver bug fixes and new features rapidly to users
    and plugin developers who need them. However, the Long-Term Support release is
    preferred for its stability.
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每周发布的 Jenkins 版本迅速为需要它们的用户和插件开发者提供错误修复和新功能。然而，长期支持版本因其稳定性而更受欢迎。
