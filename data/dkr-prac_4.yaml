- en: Part 5\. Docker in production
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 5 部分\. 生产环境中的 Docker
- en: At last we’re ready to contemplate running Docker in production. In [part 5](#part05)
    we’ll address the key operational considerations when running Docker on live environments.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们准备开始考虑在生产环境中运行 Docker。在[第 5 部分](#part05)中，我们将讨论在生产环境中运行 Docker 时需要考虑的关键操作问题。
- en: Security is the focus of [chapter 14](kindle_split_027.xhtml#ch14). Through
    practical techniques you’ll get a real understanding of the security challenges
    Docker brings and how you might want to address them.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 安全性是[第 14 章](kindle_split_027.xhtml#ch14)的重点。通过实际的技术，你将真正理解 Docker 带来的安全挑战以及你可能如何解决这些问题。
- en: Backups, logging, and resource management are considered in [chapter 15](kindle_split_028.xhtml#ch15),
    where we’ll show you how these traditional sysadmin tasks can be managed within
    a Docker context.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 备份、日志记录和资源管理在[第 15 章](kindle_split_028.xhtml#ch15)中进行了讨论，我们将向您展示如何在 Docker 环境中管理这些传统的系统管理员任务。
- en: Finally, in [chapter 16](kindle_split_029.xhtml#ch16) we’ll look at what you
    can do when things go wrong, covering some common areas where Docker can get into
    trouble, as well as how you can debug containers in production.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在[第 16 章](kindle_split_029.xhtml#ch16)中，我们将探讨当事情出错时你可以做什么，涵盖 Docker 可能遇到的一些常见问题区域，以及如何在生产环境中调试容器。
- en: Chapter 14\. Docker and security
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 14 章\. Docker 和安全
- en: '|  |'
  id: totrans-6
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**This chapter covers**'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '**本章涵盖**'
- en: The security Docker offers out of the box
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker 提供的默认安全功能
- en: What Docker has done to help make it more secure
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker 为提高安全性所采取的措施
- en: What other parties are doing about it
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他方面都在做什么
- en: What other steps can be taken to ameliorate security concerns
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以采取哪些其他步骤来缓解安全担忧
- en: How to manage user Docker permissions with an aPaaS, potentially in a multi-tenant
    environment
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 aPaaS 管理用户 Docker 权限，可能在多租户环境中
- en: '|  |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: As Docker makes clear in its documentation, access to the Docker API implies
    access to root privileges, which is why Docker must often be run with sudo, or
    the user must be added to a user group (which might be called “docker”, or “dockerroot”)
    that allows access to the Docker API.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如 Docker 在其文档中明确指出的，对 Docker API 的访问意味着对 root 权限的访问，这就是为什么 Docker 通常需要使用 sudo
    运行，或者用户必须被添加到允许访问 Docker API 的用户组（可能被称为“docker”或“dockerroot”）中。
- en: In this chapter we’re going to look at the issue of security in Docker.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨 Docker 中的安全问题。
- en: 14.1\. Docker access and what it means
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.1\. Docker 访问及其含义
- en: 'You may be wondering what sort of damage a user can do if they can run Docker.
    As a simple example, the following command (don’t run it!) would delete all the
    binaries in /sbin on your host machine (if you took out the bogus `--donotrunme`
    flag):'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道如果用户可以运行 Docker，他们能造成什么样的损害。作为一个简单的例子，以下命令（不要运行它！）将删除你主机机器上 /sbin 中的所有二进制文件（如果你移除了虚假的
    `--donotrunme` 标志）：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: It’s worth pointing out that this is true even if you’re a non-root user.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 值得指出的是，即使你不是 root 用户，这也同样适用。
- en: 'The following command will show you the contents of the secure shadow password
    file from the host system:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 以下命令将显示主机系统安全影子密码文件的内容：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Docker’s insecurity is often misunderstood, partly due to a misunderstanding
    of the benefits of namespaces in the kernel. Linux namespaces provide isolation
    from other parts of the system, but the level of isolation you have in Docker
    is at your discretion (as seen in the preceding `docker run` examples). Furthermore,
    not all parts of the Linux OS have the ability to be namespaced. Devices and kernel
    modules are two examples of core Linux features that aren’t namespaced.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 的不安全性通常被误解，部分原因是由于对内核中命名空间好处的误解。Linux 命名空间提供了对系统其他部分的隔离，但你拥有的隔离程度由你自行决定（如前述
    `docker run` 示例所示）。此外，Linux 操作系统的所有部分并不都具有命名空间的能力。设备和内核模块是两个核心 Linux 功能的例子，它们不是命名空间化的。
- en: '|  |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Tip
  id: totrans-24
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: Linux namespaces were developed to allow processes to have a different view
    of the system than other processes have. For example, *process namespacing* means
    that containers can only see processes associated with that container—other processes
    running on the same host are effectively invisible to them. *Network namespacing*
    means that containers appear to have their own network stack available to them.
    Namespaces have been part of the Linux kernel for a number of years.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 命名空间是为了允许进程拥有与其他进程不同的系统视图而开发的。例如，*进程命名空间*意味着容器只能看到与该容器关联的进程——在相同主机上运行的其它进程对他们来说是不可见的。*网络命名空间*意味着容器似乎有自己的网络堆栈可供使用。命名空间已经成为了
    Linux 内核的多年组成部分。
- en: '|  |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Also, because you have the ability to interact with the kernel as root from
    within the container through syscalls, any kernel vulnerability could be exploited
    by root within the Docker container. Of course, VMs have a similar attack possible
    through access to the hypervisor, because hypervisors also have security vulnerabilities
    reported against them.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，因为你能够通过系统调用从容器内以root身份与内核交互，任何内核漏洞都可能被Docker容器内的root用户利用。当然，虚拟机也有类似的攻击可能，这是通过访问虚拟机管理程序来实现的，因为虚拟机管理程序也有针对它们的安全漏洞报告。
- en: Another way to understand the risks here is to think of running a Docker container
    as being no different (from a security perspective) from being able to install
    any package via a package manager. Your requirement for security when running
    Docker containers should be the same as for installing packages. If you have Docker,
    you can install software as root. This is partly why some argue that Docker is
    best understood as a software packaging system.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 理解这里风险的另一种方式是将运行Docker容器视为（从安全角度来看）与能够通过包管理器安装任何包没有区别。运行Docker容器时的安全需求应该与安装包时的需求相同。如果你有Docker，你可以以root身份安装软件。这也是为什么有些人认为Docker最好被理解为一个软件打包系统的一部分原因。
- en: '|  |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Tip
  id: totrans-30
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: Work is underway to remove this risk through user namespacing, which maps root
    in the container to a non-privileged user on the host.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 正在进行通过用户命名空间来消除这种风险的工作，它将容器中的root映射到主机上的非特权用户。
- en: '|  |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 14.1.1\. Do you care?
  id: totrans-33
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 14.1.1. 你关心吗？
- en: Given that access to the Docker API is equivalent to root access, the next question
    is “do you care?” Although this might seem an odd line to take, security is all
    about trust, and if you trust your users to install software in the environment
    in which they operate, there should be no barrier to them running Docker containers
    there. Security difficulties primarily arise when considering multi-tenant environments.
    Because the root user inside your container is in key respects the same as root
    outside your container, having lots of different users being root on your system
    is potentially worrying.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 由于对Docker API的访问等同于root访问权限，接下来的问题是“你关心吗？”尽管这听起来可能是一条奇怪的论断，但安全就是关于信任的，如果你信任你的用户在他们操作的环境中安装软件，那么他们运行Docker容器时应该没有障碍。安全困难主要出现在考虑多租户环境时。因为容器内的root用户在关键方面与容器外的root用户相同，所以有大量不同的用户在系统中拥有root权限可能会引起担忧。
- en: '|  |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Tip
  id: totrans-36
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: A multi-tenant environment is one in which many different users share the same
    resources. For example, two teams might share the same server with two different
    VMs. Multi-tenancy offers cost savings through sharing hardware rather than provisioning
    hardware for specific applications. But it can bring other challenges related
    to service reliability and security isolation that can offset the cost savings.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 多租户环境是指许多不同的用户共享相同资源的环境。例如，两个团队可能使用两个不同的虚拟机共享同一台服务器。通过共享硬件而不是为特定应用程序配置硬件，多租户提供了成本节约。但它也可能带来与服务可靠性和安全隔离相关的一些挑战，这些挑战可能会抵消成本节约。
- en: '|  |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Some organizations take the approach of running Docker on a dedicated VM for
    each user. The VM can be used for security, operational, or resource isolation.
    Within the VM trust boundary, users run Docker containers for the performance
    and operational benefits they bring. This is the approach taken by Google Compute
    Engine, which places a VM between the user’s container and the underlying infrastructure
    for an added level of security and some operational benefits. Google has more
    than a little compute resources at their disposal, so they don’t mind the overhead
    of doing this.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 一些组织采取为每个用户运行Docker在专用虚拟机上的方法。虚拟机可以用于安全、操作或资源隔离。在虚拟机的信任边界内，用户运行Docker容器以获得它们带来的性能和操作优势。这是Google
    Compute Engine采取的方法，它在用户的容器和底层基础设施之间放置一个虚拟机，以增加一层安全性和一些操作优势。Google拥有大量的计算资源，所以他们并不介意这样做带来的开销。
- en: 14.2\. Security measures in Docker
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.2. Docker中的安全措施
- en: Various measures have already been taken by the Docker maintainers to reduce
    the security risks of running containers. For example,
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Docker维护者已经采取了各种措施来降低运行容器时的安全风险。例如，
- en: Certain core mount points (such as /proc and /sys) are now mounted as read-only.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在将某些核心挂载点（如/proc和/sys）挂载为只读。
- en: Default Linux capabilities have been reduced.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认Linux权限已经降低。
- en: Support for third-party security systems like SELinux and AppArmor now exists.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持第三方安全系统，如SELinux和AppArmor。
- en: In this section, we’ll look more deeply at these and at some of the measures
    you can take to reduce the risks of running containers on your system.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将更深入地探讨这些问题，以及你可以采取的一些措施来降低在系统上运行容器时的风险。
- en: '|  |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Constraining capabilities**'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**限制能力**'
- en: As we’ve already mentioned, the root user on the container is the same user
    as root on the host. But not all root users are created equal. Linux provides
    you with the ability to assign more fine-grained privileges to the root user within
    a process.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经提到的，容器中的root用户与主机上的root用户相同。但并非所有root用户都是平等的。Linux为你提供了在进程内为root用户分配更细粒度权限的能力。
- en: These fine-grained privileges are called *capabilities*, and they allow you
    to limit the damage a user can do, even if they’re root. This technique shows
    you how to manipulate these capabilities when running Docker containers, particularly
    if you don’t fully trust their contents.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这些细粒度权限被称为*能力*，它们允许你限制用户即使作为root用户也能造成的损害。这项技术展示了如何在运行Docker容器时操作这些能力，特别是如果你不完全信任其内容时。
- en: '**PROBLEM**'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: You want to reduce the ability of containers to perform damaging actions on
    your host machine.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望减少容器在主机上执行破坏性操作的能力。
- en: '**SOLUTION**'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: Drop the capabilities available to the container by using the `--drop-cap` flag.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`--drop-cap`标志来降低容器可用的能力。
- en: '**The Unix trust model**'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**Unix信任模型**'
- en: To understand what “dropping capabilities” means and does, a little bit of background
    is required. When the Unix system was designed, the trust model wasn’t sophisticated.
    You had admins who were trusted (root users) and users who weren’t. Root users
    could do anything, whereas standard users could only affect their own files. Because
    the system was typically used in a university lab and was small, this model made
    sense.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解“降低能力”的含义和作用，需要一点背景知识。当Unix系统设计时，信任模型并不复杂。你有一些受信任的管理员（root用户）和不受信任的用户。root用户可以做任何事情，而标准用户只能影响自己的文件。由于系统通常在大学实验室中使用且规模较小，这种模型是合理的。
- en: As the Unix model grew and the internet arrived, this model made less and less
    sense. Programs like web servers needed root permissions to serve content on port
    80, but they were also acting effectively as proxies for running commands on the
    host. Standard patterns were established to handle this, such as binding to port
    80 and dropping the effective user ID to a non-root user. Users performing all
    sorts of roles, from sysadmins to database administrators through to application
    support engineers and developers, could all potentially need fine-grained access
    to different resources on a system. Unix groups alleviated this to some degree,
    but modeling these privilege requirements—as any systems admin will tell you—is
    a nontrivial problem.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 随着Unix模型的发展以及互联网的到来，这种模型变得越来越没有意义。像Web服务器这样的程序需要root权限来在端口80上提供服务内容，但它们也有效地充当了在主机上运行命令的代理。为了处理这种情况，建立了标准模式，例如绑定到端口80并将有效用户ID降低到非root用户。执行各种角色的用户，从系统管理员到数据库管理员，再到应用支持工程师和开发者，都可能需要系统上不同资源的细粒度访问。Unix组在一定程度上缓解了这个问题，但任何系统管理员都会告诉你，建模这些权限需求是一个非平凡的问题。
- en: '**Linux capabilities**'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**Linux能力**'
- en: In an attempt to support a more fine-grained approach to privileged user management,
    the Linux kernel engineers developed *capabilities*. This was an attempt to break
    down the monolithic root privilege into slices of functionality that could be
    granted discretely. You can read about them in more detail by running `man 7 capabilities`
    (assuming you have the man page installed).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持对特权用户管理的更细粒度方法，Linux内核工程师开发了*能力*。这是尝试将单一的root权限分解成可以单独授予的功能片段。你可以通过运行`man
    7 capabilities`（假设你已经安装了man页面）来详细了解它们。
- en: Docker has helpfully switched off certain capabilities by default. This means
    that even if you have root in the container, there are things you won’t be able
    to do. For example, the `CAP_NET_ADMIN` capability, which allows you to affect
    the network stack of the host, is disabled by default.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Docker默认关闭了一些能力。这意味着即使你在容器中有root权限，也有一些事情你无法做到。例如，`CAP_NET_ADMIN`能力，它允许你影响主机的网络堆栈，默认是禁用的。
- en: '[Table 14.1](#ch14table01) lists Linux capabilities, gives a brief description
    of what they allow, and indicates whether they’re permitted by default in Docker
    containers.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '[表14.1](#ch14table01) 列出了Linux能力，简要描述了它们允许做什么，并指出了它们在Docker容器中是否默认允许。'
- en: Table 14.1\. Linux capabilities in Docker containers
  id: totrans-61
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表14.1\. Docker容器中的Linux功能
- en: '| **Capability** | **Description** | **Switched on?** |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| **功能** | **描述** | **已开启？** |'
- en: '| --- | --- | --- |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| CHOWN | Make ownership changes to any files | Y |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| CHOWN | 对任何文件进行所有权更改 | Y |'
- en: '| DAC_OVERRIDE | Override read, write, and execution checks | Y |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| DAC_OVERRIDE | 覆盖读取、写入和执行检查 | Y |'
- en: '| FSETID | Don’t clear suid and guid bits when modifying files | Y |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| FSETID | 修改文件时不清除suid和guid位 | Y |'
- en: '| FOWNER | Override ownership checks when saving files | Y |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| FOWNER | 在保存文件时覆盖所有权检查 | Y |'
- en: '| KILL | Bypass permission checks on signals | Y |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| KILL | 绕过信号上的权限检查 | Y |'
- en: '| MKNOD | Make special files with | Y |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| MKNOD | 使用 | Y |'
- en: '| NET_RAW | Use raw and packet sockets, and bind to ports for transparent proxying
    | Y |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| NET_RAW | 使用原始套接字和数据包套接字，并绑定到端口以进行透明代理 | Y |'
- en: '| SETGID | Make changes to group ownership of processes | Y |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| SETGID | 更改进程的组所有权 | Y |'
- en: '| SETUID | Make changes to user ownership of processes | Y |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| SETUID | 更改进程的用户所有权 | Y |'
- en: '| SETFCAP | Set file capabilities | Y |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| SETFCAP | 设置文件功能 | Y |'
- en: '| SETPCAP | If file capabilities aren’t supported, apply capability limits
    to and from other processes | Y |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| SETPCAP | 如果文件功能不受支持，则将功能限制应用于来自和来自其他进程 | Y |'
- en: '| NET_BIND_SERVICE | Bind sockets to ports under 1024 | Y |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| NET_BIND_SERVICE | 将套接字绑定到小于1024的端口 | Y |'
- en: '| SYS_CHROOT | Use chroot | Y |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| SYS_CHROOT | 使用chroot | Y |'
- en: '| AUDIT_WRITE | Write to kernel logs | Y |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| AUDIT_WRITE | 写入内核日志 | Y |'
- en: '| AUDIT_CONTROL | Enable/disable kernel logging | N |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| AUDIT_CONTROL | 启用/禁用内核日志 | N |'
- en: '| BLOCK_SUSPEND | Employ features that block the ability of the system to suspend
    | N |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| BLOCK_SUSPEND | 使用阻止系统挂起的功能 | N |'
- en: '| DAC_READ_SEARCH | Bypass file permission checks on reading files and directories
    | N |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| DAC_READ_SEARCH | 在读取文件和目录时绕过文件权限检查 | N |'
- en: '| IPC_LOCK | Lock memory | N |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| IPC_LOCK | 锁定内存 | N |'
- en: '| IPC_OWNER | Bypass permissions on interprocess communication objects | N
    |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| IPC_OWNER | 绕过进程间通信对象的权限 | N |'
- en: '| LEASE | Establish leases (watches on attempts to open or truncate) on ordinary
    files | N |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| LEASE | 在普通文件上建立租约（监视尝试打开或截断） | N |'
- en: '| LINUX_IMMUTABLE | Set the FS_APPEND_FL and FS_IMMUTABLE_FL i-node flags |
    N |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| LINUX_IMMUTABLE | 设置FS_APPEND_FL和FS_IMMUTABLE_FL i节点标志 | N |'
- en: '| MAC_ADMIN | Override mandatory access control (related to the Smack Linux
    Security Module (SLM)) | N |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| MAC_ADMIN | 覆盖强制访问控制（与Smack Linux安全模块（SLM）相关） | N |'
- en: '| MAC_OVERRIDE | Mandatory access control changes (related to SLM) | N |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| MAC_OVERRIDE | 强制访问控制更改（与SLM相关） | N |'
- en: '| NET_ADMIN | Various network-related operations, including IP firewall changes
    and interface configuration | N |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| NET_ADMIN | 各种与网络相关的操作，包括IP防火墙更改和接口配置 | N |'
- en: '| NET_BROADCAST | Unused | N |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| NET_BROADCAST | 未使用 | N |'
- en: '| SYS_ADMIN | A range of administrative functions—see man capabilities for
    more information | N |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| SYS_ADMIN | 一系列管理功能——更多信息请参阅man capabilities | N |'
- en: '| SYS_BOOT | Rebooting | N |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| SYS_BOOT | 重启 | N |'
- en: '| SYS_MODULE | Load/unload kernel modules | N |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| SYS_MODULE | 加载/卸载内核模块 | N |'
- en: '| SYS_NICE | Manipulate nice priority of processes | N |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| SYS_NICE | 操作进程的优先级 | N |'
- en: '| SYS_PACCT | Turn on or off process accounting | N |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| SYS_PACCT | 打开或截断尝试的监视（进程会计） | N |'
- en: '| SYS_PTRACE | Trace processes’ system calls and other process manipulation
    capabilities | N |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| SYS_PTRACE | 跟踪进程的系统调用和其他进程操作能力 | N |'
- en: '| SYS_RAWIO | Perform I/O on various core parts of the system, such as memory
    and SCSI device commands | N |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| SYS_RAWIO | 在系统的各个核心部分执行I/O，例如内存和SCSI设备命令 | N |'
- en: '| SYS_RESOURCE | Control and override various resource limits | N |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| SYS_RESOURCE | 控制和覆盖各种资源限制 | N |'
- en: '| SYS_TIME | Set the system clock | N |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| SYS_TIME | 设置系统时钟 | N |'
- en: '| SYS_TTY_CONFIG | Privileged operations on virtual terminals | N |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| SYS_TTY_CONFIG | 在虚拟终端上进行特权操作 | N |'
- en: '|  |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-100
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: If you aren’t using Docker’s default container engine (libcontainer), these
    capabilities may be different on your installation. If you have a sysadmin and
    want to be sure, ask them.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有使用Docker的默认容器引擎（libcontainer），这些功能在你的安装中可能不同。如果你有系统管理员并且想确保，请向他们询问。
- en: '|  |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Unfortunately the kernel maintainers only allocated 32 capabilities within the
    system, so capabilities have grown in scope as more and more fine-grained root
    privileges have been carved out of the kernel. Most notably, the vaguely named
    `CAP_SYS_ADMIN` capability covers actions as varied as changing the host’s domain
    name to exceeding the system-wide limit on the number of open files.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，内核维护者只在该系统中分配了32个功能，因此随着越来越多的细粒度root权限从内核中划分出来，功能范围已经扩大。最值得注意的是，名为`CAP_SYS_ADMIN`的功能涵盖了从更改主机的域名到超出系统范围内打开文件数量限制的各种操作。
- en: 'One extreme approach is to remove all the capabilities that are switched on
    in Docker by default from the container, and see what stops working. Here we start
    up a bash shell with the capabilities that are enabled by default removed:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 一种极端的方法是移除容器中默认启用的所有Docker功能，并查看哪些停止工作。在这里，我们启动一个bash shell，移除了默认启用的功能：
- en: '[PRE2]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If you run your application from this shell, you can see where it fails to
    work as desired, and re-add the required capabilities. For example, you may need
    the capability to change file ownership, so you’ll need to lose the dropping of
    the `FOWNER` capability in the preceding code to run your application:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从这个shell运行你的应用程序，你可以看到它在哪里无法按预期工作，并重新添加所需的功能。例如，你可能需要更改文件所有权的功能，因此你需要取消上一段代码中`FOWNER`功能的删除才能运行你的应用程序：
- en: '[PRE3]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '|  |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-109
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you want to enable or disable all capabilities, you can use `all` instead
    of a specific capability, such as `docker run -ti --cap-drop=all ubuntu bash`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要启用或禁用所有功能，可以使用`all`而不是特定的功能，例如`docker run -ti --cap-drop=all ubuntu bash`。
- en: '|  |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**DISCUSSION**'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**讨论**'
- en: If you run a few basic commands in the bash shell with all capabilities disabled,
    you’ll see that it’s quite usable. Your mileage may vary when running more complex
    applications, though.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用bash shell运行一些基本命令，并且禁用了所有功能，你会发现它相当可用。然而，当运行更复杂的应用程序时，你的体验可能会有所不同。
- en: '|  |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Warning
  id: totrans-115
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 警告
- en: It’s worth making clear that many of these capabilities relate to the root capabilities
    to affect *other* users’ objects on the system, not root’s own objects. A root
    user could still chown root’s files on the host if they were host in the container
    and had access to the host’s files through a volume mount, for example. Therefore,
    it’s still worth ensuring that applications drop to a non-root user as soon as
    possible to protect the system, even if all these capabilities are switched off.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 值得明确的是，许多这些功能与影响系统上其他用户对象的root功能相关，而不是root自己的对象。例如，如果root用户在容器中，并且通过卷挂载访问主机的文件，他们仍然可以更改主机上root的文件的所有权。因此，仍然值得确保应用程序尽快降级为非root用户，以保护系统，即使所有这些功能都已关闭。
- en: '|  |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: This ability to fine-tune the capabilities of your container means that using
    the `--privileged` flag to `docker run` should be unnecessary. Processes that
    require capabilities will be auditable and under the control of the administrator
    of the host.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这种微调容器功能的能力意味着使用`--privileged`标志来运行`docker run`应该是多余的。需要功能的过程将是可审计的，并且受主机管理员控制。
- en: '|  |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**A “bad” Docker image to scan**'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**一个“不良”的Docker镜像用于扫描**'
- en: One issue quickly recognized in the Docker ecosystem was that of vulnerabilities—if
    you have an unchanging image, you also won’t get any security fixes. This may
    not be a problem if you’re following the Docker best practices of image minimalism,
    but it can be hard to tell.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在Docker生态系统中，一个迅速认识到的问题是漏洞——如果你有一个不变的镜像，你也不会得到任何安全修复。如果你遵循Docker最佳实践中的镜像最小化，这可能不是问题，但很难判断。
- en: Image scanners were created as a solution to this problem—a way to identify
    issues with an image—but that still leaves open the question of how to evaluate
    them.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图像扫描器是为了解决这个问题而创建的——一种识别镜像问题的方法，但这仍然留下了如何评估它们的问题。
- en: '**PROBLEM**'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: You want to determine how effective an image scanner is.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要确定图像扫描仪的有效性。
- en: '**SOLUTION**'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: Create a “known-bad” image to test your scanners on.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个“已知不良”的镜像来测试你的扫描器。
- en: We were faced with this problem while at work. Plenty of Docker image scanners
    exist (such as Clair), but commercial offerings claim to go deeper into the image
    to determine any potential issues lurking within it.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在工作中遇到了这个问题。存在许多Docker镜像扫描器（如Clair），但商业产品声称可以更深入地检查镜像，以确定其中可能存在的任何潜在问题。
- en: But no image existed that contained known and documented vulnerabilities that
    we could use to test the efficacy of these scanners. Hardly surprising, as most
    images don’t advertise their own insecurity!
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 但没有包含已知和记录的漏洞的图像，我们可以用它来测试这些扫描器的有效性。这几乎不出所料，因为大多数图像不会宣传它们自己的不安全性！
- en: 'We therefore invented a known bad image. The image is available to download:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们发明了一个已知不良的图像。该图像可供下载：
- en: '[PRE4]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The principle is simple: create a Dockerfile to build an image riddled with
    documented vulnerabilities, and point that image at your candidate scanner.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 原则很简单：创建一个Dockerfile来构建一个充满记录漏洞的图像，并将该图像指向您的候选扫描器。
- en: 'The latest version of the Dockerfile is available at [https://github.com/ianmiell/bad-dock](https://github.com/ianmiell/bad-dock)
    erfile. It’s still in flux, so it’s not printed here. The form of it is, however,
    quite simple:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile的最新版本可在[https://github.com/ianmiell/bad-dock](https://github.com/ianmiell/bad-dock)找到。它仍在变化中，所以这里没有打印出来。然而，它的形式非常简单：
- en: '[PRE5]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '***1*** **The reference bad-dockerfile repository uses a centos image, but
    you might want to replace this with one closer to your base image.**'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **参考bad-dockerfile存储库使用centos图像，但您可能希望将其替换为与您的基图像更接近的一个。**'
- en: '***2*** **Various RUN/COPY/ADD commands install software to the image that
    are known to be vulnerable.**'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **各种RUN/COPY/ADD命令会将已知漏洞的软件安装到图像中。**'
- en: '***3*** **The CMD directive for the image tries its best never to allow itself
    to be run, for obvious reasons.**'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **图像的CMD指令出于明显的原因，尽可能避免自己被运行。**'
- en: The image contains a spectrum of vulnerabilities designed to exercise a scanner
    to its limits.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图像包含一系列漏洞，旨在将扫描器推到极限。
- en: At its simplest, the image installs software known to be vulnerable using the
    package manager. Within each category, the Docker image attempts to contain vulnerabilities
    of varying degrees of severity.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在最简单的情况下，图像使用包管理器安装已知漏洞的软件。在每个类别中，Docker图像试图包含不同严重程度的漏洞。
- en: More sophisticated placement of vulnerabilities is performed by (for example)
    `COPY`ing vulnerable JavaScript, using language-specific package managers (such
    as npm for JavaScript, gem for Ruby, and pip for Python) to install vulnerable
    code, and even compiling a specific version of bash (one with the infamous Shellshock
    bug) and placing it in an unexpected location to avoid many scanning techniques.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 通过（例如）`COPY`受漏洞影响的JavaScript、使用特定语言的包管理器（例如npm用于JavaScript、gem用于Ruby和pip用于Python）安装受漏洞影响的代码，甚至编译特定版本的bash（一个带有臭名昭著的Shellshock漏洞的版本）并将其放置在意外位置以避免许多扫描技术，进行更复杂的漏洞放置。
- en: '**DISCUSSION**'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '**讨论**'
- en: You might think that the best scanning solution is one that catches the most
    CVEs. But this isn’t necessarily the case. Obviously, it’s good if a scanner can
    spot that an image has a vulnerability within it. Beyond this, however, scanning
    for vulnerabilities can become more of an art than a science.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能认为最好的扫描解决方案是能够捕获最多CVE的解决方案。但这并不一定是事实。显然，如果扫描器能够发现图像中存在漏洞，这是很好的。然而，除了这一点之外，漏洞扫描可能更多地成为一门艺术而不是一门科学。
- en: '|  |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Tip
  id: totrans-144
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**提示**'
- en: A Common Vulnerability Exposure (CVE) is an identifier for a specific vulnerability
    discovered in generally available software. An example of a CVE might be CVE-2001-0067,
    where the first four-digit number is the year of discovery, and the second is
    the count of the identified vulnerability for that year.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 常见漏洞披露（CVE）是一般可用软件中发现的具体漏洞的标识符。CVE的一个例子可能是CVE-2001-0067，其中前四位数字是发现年份，后四位是该年的已识别漏洞数量。
- en: '|  |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: For example, a vulnerability might be very severe (such as gaining root on your
    host server), but extremely difficult to exploit (such as requiring the resources
    of a nation-state). You (or the organization you’re responsible for) might be
    less worried about this than about a vulnerability that’s less severe, but easy
    to exploit. If, for example, there’s a DoS attack on your system, there’s no risk
    of data leakage or infiltration, but you could be put out of business by it, so
    you’d be more concerned about patching that than some obscure cipher attack requiring
    tens of thousands of dollars’ worth of computing power.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个漏洞可能非常严重（例如在您的宿主服务器上获得root权限），但非常难以利用（例如需要国家层面的资源）。您（或您负责的组织）可能对此比一个不那么严重但容易利用的漏洞更不担心。例如，如果您的系统遭到DoS攻击，没有数据泄露或渗透的风险，但您可能会因此失去业务，所以您会更关注修补这个问题，而不是需要数万美元计算能力的某些晦涩的加密攻击。
- en: '|  |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: What is a Dos Attack?
  id: totrans-149
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 什么是DoS攻击？
- en: DoS stands for “denial of service.” This means an attack that results in a reduction
    in the ability of your system to cope with demand. A denial of service attack
    could overwhelm your web server to the point where it can’t respond to legitimate
    users.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: DoS代表“服务拒绝”。这意味着一种攻击，会导致你的系统应对需求的能力降低。服务拒绝攻击可能会使你的Web服务器超负荷，以至于无法响应用户的合法请求。
- en: '|  |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: It’s also worth considering whether the vulnerability is actually available
    on the running container. An old version of the Apache web server may exist on
    the image, but if it’s never actually run by the container, the vulnerability
    is effectively ignorable. This happens often. Package managers regularly bring
    in dependencies that aren’t really needed just because it makes managing dependencies
    simpler.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 还值得考虑的是，漏洞实际上是否存在于正在运行的容器中。Apache Web服务器的旧版本可能存在于镜像中，但如果容器从未实际运行过，那么漏洞实际上是可以忽略的。这种情况经常发生。包管理器通常会引入一些不必要的依赖项，仅仅是因为它使依赖项的管理变得简单。
- en: If security is a big concern, this can be another reason to have small images
    (see [chapter 7](kindle_split_017.xhtml#ch07))—even if a piece of software is
    unused, it can still show up on a security scan, wasting time as your organization
    tries to work out whether it needs patching.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果安全性是一个很大的担忧，那么拥有小图像（参见[第7章](kindle_split_017.xhtml#ch07)）可以成为另一个原因——即使某个软件未被使用，它仍然可能出现在安全扫描中，浪费你的组织在确定是否需要打补丁时的时间。
- en: This technique hopefully gave you food for thought when considering which scanner
    is right for you. As always, it’s a balance between cost, what you need, and how
    much you’re willing to work to get the right solution.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 希望这项技术在你考虑哪种扫描器适合你时能给你一些思考。一如既往，这是成本、你需要什么以及你愿意为获得正确解决方案付出多少努力之间的平衡。
- en: '|  |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 14.3\. Securing access to Docker
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.3\. 保护Docker的访问
- en: The best way to prevent insecure use of a Docker daemon is to prevent any use
    at all.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 防止Docker守护进程的不安全使用最好的方法是完全防止任何使用。
- en: You probably first encountered restricted access when you installed Docker and
    needed to use `sudo` to run Docker itself. [Technique 41](kindle_split_016.xhtml#ch06sb02)
    describes how to selectively permit users on the local machine to use Docker without
    this restriction.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能第一次遇到受限访问是在安装Docker并需要使用`sudo`运行Docker本身时。[技术41](kindle_split_016.xhtml#ch06sb02)描述了如何选择性地允许本地机器上的用户使用Docker而不受此限制。
- en: But this doesn’t help you if you have users connecting to a Docker daemon from
    another machine. We’ll look at a couple of ways to provide a bit more security
    in those situations.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果你有用户从另一台机器连接到Docker守护进程，这并没有帮助。我们将探讨在那些情况下提供更多安全性的几种方法。
- en: '|  |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**HTTP auth on your Docker instance**'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '**Docker实例上的HTTP身份验证**'
- en: In [technique 1](kindle_split_011.xhtml#ch02sb02) you saw how to open up access
    to your daemon to the network, and in [technique 4](kindle_split_011.xhtml#ch02sb05)
    you saw how to snoop the Docker API using socat.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在[技术1](kindle_split_011.xhtml#ch02sb02)中，你看到了如何打开对守护进程的网络访问，而在[技术4](kindle_split_011.xhtml#ch02sb05)中，你看到了如何使用socat窃听Docker
    API。
- en: 'This technique combines those two: you’ll be able to access your daemon remotely
    and view the responses. Access is restricted to those with a username/password
    combination, so it’s slightly safer. As a bonus, you don’t have to restart your
    Docker daemon to achieve it—start up a container daemon.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术结合了这两者：你将能够远程访问你的守护进程并查看响应。访问权限仅限于具有用户名/密码组合的用户，因此它稍微安全一些。作为额外的好处，你不需要重新启动Docker守护进程就能实现它——启动一个容器守护进程。
- en: '**PROBLEM**'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: You’d like basic authentication with network access available on your Docker
    daemon.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望你的Docker守护进程上提供基本身份验证和网络访问。
- en: '**SOLUTION**'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: Use HTTP authentication to share your Docker daemon with others temporarily.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 使用HTTP身份验证暂时与他人共享你的Docker守护进程。
- en: '[Figure 14.1](#ch14fig01) lays out the final architecture of this technique.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '[图14.1](#ch14fig01) 展示了该技术的最终架构。'
- en: Figure 14.1\. The architecture of a Docker daemon with basic authentication
  id: totrans-169
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图14.1\. 基本身份验证的Docker守护进程架构
- en: '![](Images/14fig01_alt.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/14fig01_alt.jpg)'
- en: '|  |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-172
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**注意**'
- en: This discussion assumes your Docker daemon is using Docker’s default Unix socket
    method of access in /var/run/docker.sock.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 本讨论假设你的Docker守护进程正在使用Docker默认的Unix套接字访问方法，位于/var/run/docker.sock。
- en: '|  |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: The code in this technique is available at [https://github.com/docker-in-practice/docker-authenticate](https://github.com/docker-in-practice/docker-authenticate).
    The following listing shows the contents of the Dockerfile in this repository,
    used to create the image for this technique.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 本技术中的代码可在[https://github.com/docker-in-practice/docker-authenticate](https://github.com/docker-in-practice/docker-authenticate)找到。以下列出的是该存储库中Dockerfile的内容，用于创建本技术的镜像。
- en: Listing 14.1\. Dockerfile
  id: totrans-176
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表14.1\. Dockerfile
- en: '[PRE6]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '***1*** **Ensures the required software is updated and installed**'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **确保所需的软件已更新并安装**'
- en: '***2*** **Creates a password file for the user called username**'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **为名为username的用户创建密码文件**'
- en: '***3*** **Sets the password for the user called username to “password”**'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **将名为username的用户的密码设置为“password”**'
- en: '***4*** **Nginx will need to run as root to access the Docker Unix socket,
    so you replace the user line with the “root” user details.**'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **Nginx需要以root用户身份运行以访问Docker Unix套接字，因此您需要将用户行替换为“root”用户详情。**'
- en: '***5*** **Copies in Docker’s nginx site file ([listing 14.8](#ch14ex08))**'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** **复制Docker的nginx站点文件（[列表14.8](#ch14ex08)）**'
- en: '***6*** **By default, starts the nginx service and waits indefinitely**'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6*** **默认情况下，启动nginx服务并无限期等待**'
- en: The .htpasswd file set up with the `htpasswd` command contains the credentials
    to be checked before allowing (or rejecting) access to the Docker socket. If you’re
    building this image yourself, you’ll probably want to alter `username` and `password`
    in those two steps to customize the credentials with access to the Docker socket.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`htpasswd`命令设置的`.htpasswd`文件包含在允许（或拒绝）访问Docker套接字之前需要检查的凭据。如果您自己构建此镜像，您可能希望在这两个步骤中更改`username`和`password`以自定义访问Docker套接字的凭据。
- en: '|  |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Warning
  id: totrans-186
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 警告
- en: Be careful not to share this image, as it will contain the password you’ve set!
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 请务必不要分享这张图片，因为它将包含您设置的密码！
- en: '|  |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: The nginx site file for Docker is shown in the following listing.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列出的是Docker的nginx站点文件。
- en: Listing 14.2\. /etc/nginx/sites-enabled/docker
  id: totrans-190
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表14.2\. /etc/nginx/sites-enabled/docker
- en: '[PRE7]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '***1*** **Defines the docker location in nginx as pointing to Docker’s domain
    socket**'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **在nginx中将docker位置定义为指向Docker的域套接字**'
- en: '***2*** **Listens on port 2375 (the standard Docker port)**'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **监听端口2375（Docker的标准端口）**'
- en: '***3*** **Proxies these requests to and from the docker location defined earlier**'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **将这些请求代理到之前定义的docker位置**'
- en: '***4*** **Defines the password file to use**'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **定义要使用的密码文件**'
- en: '***5*** **Restricts access by password**'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** **通过密码限制访问**'
- en: 'Now run the image as a daemon container, mapping the required resources from
    the host machine:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在以守护进程容器的形式运行镜像，映射主机机器所需资源：
- en: '[PRE8]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This will run the container in the background with the name `docker-authenticate`
    so you can refer to it later. Port 2375 of the container is exposed on the host,
    and the container is given access to the Docker daemon by mounting the default
    directory containing the Docker socket as a volume. If you’re using a custom-built
    image with your own username and password, you’ll need to replace the image name
    here with your own.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这将以`docker-authenticate`的名称在后台运行容器，以便您可以稍后引用。容器的主机端口2375被暴露，并且容器通过挂载包含Docker套接字的默认目录作为卷来获得对Docker守护进程的访问权限。如果您使用的是带有您自己的username和password的自定义构建镜像，您需要在此处将镜像名称替换为您自己的。
- en: 'The web service will now be up and running. If you `curl` the service with
    the username and password you set, you should see an API response:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 网络服务现在将启动并运行。如果您使用您设置的username和password `curl`该服务，您应该看到API响应：
- en: '[PRE9]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '***1*** **Puts the username: password in the URL to curl, and the address after
    the @ sign. This request is to the /info endpoint of the Docker daemon’s API.**'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **将username:password放入curl的URL中，以及@符号后面的地址。此请求是Docker守护进程API的/info端点。**'
- en: '***2*** **The JSON response from the Docker daemon**'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **Docker守护进程的JSON响应**'
- en: 'When you’re done, remove the container with this command:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，使用以下命令删除容器：
- en: '[PRE10]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Access is now revoked.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在访问已被撤销。
- en: '**Using the docker command?**'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用docker命令？**'
- en: 'Readers may be wondering whether other users will be able to connect with the
    `docker` command—for example, with something like this:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 读者可能会想知道其他用户是否能够使用`docker`命令连接——例如，如下所示：
- en: '[PRE11]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'At the time of writing, authentication functionality isn’t built into Docker
    itself. But we have created an image that will handle the authentication and allow
    Docker to connect to a daemon. Simply use the image as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，认证功能并未内置到Docker本身。但我们创建了一个可以处理认证并允许Docker连接到守护进程的镜像。只需按以下方式使用镜像：
- en: '[PRE12]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '***1*** **Runs the client container in the background and gives it a name**'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **在后台运行客户端容器并给它命名**'
- en: '***2*** **Exposes a port to connect a Docker daemon to, but only for connections
    from the local machine**'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **公开一个端口以连接Docker守护进程，但仅限于来自本地机的连接**'
- en: '***3*** **The image we’ve made to allow authenticated connections with Docker**'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **我们制作的允许与Docker进行认证连接的镜像**'
- en: '***4*** **The two arguments to the image: a specification of where the other
    end of the authenticated connection should be, and the username and password (both
    of these should be replaced as appropriate for your setup)**'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **图像的两个参数：指定认证连接另一端的位置，以及用户名和密码（这两个都应该根据您的设置适当替换）**'
- en: Note that `localhost` or `127.0.0.1` won’t work for specifying the other end
    of the authenticated connection—if you want to try it out on one host, you must
    use `ip addr` to identify an external IP address for your machine.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`localhost`或`127.0.0.1`不适用于指定认证连接的另一端——如果您想在单个主机上尝试，您必须使用`ip addr`来识别您的机器的外部IP地址。
- en: 'You can now use the authenticated connection with the following command:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以使用以下命令使用认证连接：
- en: '[PRE13]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Be aware that interactive Docker commands (`run` and `exec` with the `-i` argument)
    won’t work over this connection due to some implementation limitations.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，由于某些实现限制，交互式Docker命令（带有`-i`参数的`run`和`exec`）无法通过此连接工作。
- en: '**DISCUSSION**'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '**讨论**'
- en: In this technique we showed you how to set up basic authentication for your
    Docker server in a trusted network. In the next technique we’ll look at encrypting
    the traffic so snoopers can’t take a peek at what you’re up to, or even inject
    evil data or code.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在这项技术中，我们向您展示了如何在受信任的网络中为您的Docker服务器设置基本认证。在下一项技术中，我们将探讨加密流量，这样窃听者就不能窥探您在做什么，甚至注入恶意数据或代码。
- en: '|  |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Warning
  id: totrans-223
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 警告
- en: This technique gives you a basic level of *authentication*, but it doesn’t give
    you a serious level of *security* (in particular, someone able to listen to your
    network traffic could intercept your username and password). Setting up a server
    secured with TLS is rather more involved and is covered in the next technique.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术为您提供了基本的*认证*，但它并不提供严重的*安全性*（特别是，能够监听您网络流量的人可以拦截您的用户名和密码）。设置使用TLS加密的服务器要复杂得多，将在下一技术中介绍。
- en: '|  |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Securing your Docker API**'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '**保护您的Docker API**'
- en: In this technique we’ll show how you can open up your Docker server to others
    over a TCP port while at the same time ensuring that only trusted clients can
    connect. This is achieved by creating a secret key that only trusted hosts will
    be given. As long as that trusted key remains a secret between the server and
    client machines, the Docker server should remain secure.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在这项技术中，我们将展示如何通过TCP端口将您的Docker服务器向他人开放，同时确保只有受信任的客户端可以连接。这是通过创建一个只有受信任的主机才会获得的秘密密钥来实现的。只要这个受信任的密钥在服务器和客户端机器之间保持秘密，Docker服务器应该保持安全。
- en: '**PROBLEM**'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: You want your Docker API to be served securely over a port.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望您的Docker API通过端口安全地提供服务。
- en: '**SOLUTION**'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: Create a self-signed certificate, and run the Docker daemon with the `--tls-verify`
    flag.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个自签名证书，并使用`--tls-verify`标志运行Docker守护进程。
- en: This method of security depends on so-called *key files* being created on the
    server. These files are created using special tools that ensure they’re difficult
    to copy if you don’t have the *server key*. [Figure 14.2](#ch14fig02) gives an
    overview of this how this works.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这种安全方法依赖于在服务器上创建所谓的*密钥文件*。这些文件是通过特殊工具创建的，确保在没有*服务器密钥*的情况下难以复制。[图14.2](#ch14fig02)概述了这是如何工作的。
- en: Figure 14.2\. Key setup and distribution
  id: totrans-235
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图14.2\. 关键设置和分发
- en: '![](Images/14fig02_alt.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/14fig02_alt.jpg)'
- en: '|  |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-238
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: The *server key* is a file that holds a secret number known only to the server,
    and which is required to read messages encrypted with the secret key files given
    out by the owner of the server (the so-called *client keys*). Once the keys have
    been created and distributed, they can be used to make the connection between
    client and server secure.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '*服务器密钥*是一个文件，它包含一个只有服务器知道的秘密数字，并且需要读取使用服务器（所谓的*客户端密钥*）提供的秘密密钥文件加密的消息。一旦密钥被创建并分发，它们就可以用来确保客户端和服务器之间的连接安全。'
- en: '|  |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Setting up the Docker server certificate**'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '**设置Docker服务器证书**'
- en: First you create the certificates and keys.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您创建证书和密钥。
- en: Generating keys requires the OpenSSL package, and you can check whether it’s
    installed by running `openssl` in a terminal. If it’s not installed, you’ll need
    to install it before generating the certificates and keys with the following code.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 生成密钥需要OpenSSL包，您可以通过在终端中运行`openssl`来检查它是否已安装。如果没有安装，您需要先安装它，然后才能使用以下代码生成证书和密钥。
- en: Listing 14.3\. Creating certificates and keys with OpenSSL
  id: totrans-244
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表14.3\. 使用OpenSSL创建证书和密钥
- en: '[PRE14]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '***1*** **Ensure you are root.**'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **确保您是root用户。**'
- en: '***2*** **Type in your certificate password and the server name you’ll use
    to connect to the Docker server.**'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **输入您的证书密码和您将用于连接Docker服务器的服务器名。**'
- en: '***3*** **Create the docker configuration directory if it doesn’t exist, and
    move into it.**'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **如果不存在，则创建docker配置目录，并进入该目录。**'
- en: '***4*** **Generate certificate authority (CA) .pem file with 2048-bit security.**'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **使用2048位安全性生成证书颁发机构(CA) .pem文件。**'
- en: '***5*** **Sign the CA key with your password and address for a period of one
    year.**'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** **使用您的密码和地址为CA密钥签名，有效期为一年。**'
- en: '***6*** **Generate a server key with 2048-bit security.**'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6*** **生成一个2048位安全性的服务器密钥。**'
- en: '***7*** **Process the server key with the name of your host.**'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7*** **使用您的主机名处理服务器密钥。**'
- en: '***8*** **Sign the key with your password for a period of one year.**'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8*** **使用您的密码为密钥签名，有效期为一年。**'
- en: '***9*** **Generate a client key with 2048-bit security.**'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***9*** **生成一个2048位安全性的客户端密钥。**'
- en: '***10*** **Process the key as a client key.**'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***10*** **将密钥作为客户端密钥处理。**'
- en: '***11*** **Sign the key with your password for a period of one year.**'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***11*** **使用您的密码为密钥签名，有效期为一年。**'
- en: '***12*** **Change the permissions to read-only by root for the server files.**'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***12*** **将服务器文件的权限更改为root只读。**'
- en: '***13*** **Change the permissions of the client files to read-only by everyone.**'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***13*** **将客户端文件的权限更改为所有人只读。**'
- en: '***14*** **Remove leftover files.**'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***14*** **删除遗留文件。**'
- en: '|  |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-261
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**提示**'
- en: A script called CA.pl may be installed on your system that makes this process
    simpler. Here we’ve exposed the raw `openssl` commands because they’re more instructive.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 可能有一个名为CA.pl的脚本已安装在您的系统上，它可以简化此过程。在这里，我们展示了原始的`openssl`命令，因为它们更具指导性。
- en: '|  |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Setting up the Docker server**'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '**设置Docker服务器**'
- en: Next you need to set the Docker opts in your Docker daemon config file to specify
    which keys are used to encrypt the communications (see [appendix B](kindle_split_035.xhtml#app02)
    for advice on how to configure and restart your Docker daemon).
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您需要在您的Docker守护进程配置文件中设置Docker opts，以指定用于加密通信的密钥（有关如何配置和重启Docker守护进程的说明，请参阅[附录B](kindle_split_035.xhtml#app02)）。
- en: Listing 14.4\. Docker options for using the new keys and certificates
  id: totrans-266
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表14.4\. 使用新密钥和证书的Docker选项
- en: '[PRE15]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '***1*** **Tells the Docker daemon that you want to use TLS security to secure
    connections to it**'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **告诉Docker守护进程您想使用TLS安全来保护与其的连接**'
- en: '***2*** **Specifies the CA file for the Docker server**'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **指定Docker服务器的CA文件**'
- en: '***3*** **Specifies the certificate for the server**'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **指定服务器的证书**'
- en: '***4*** **Specifies the private key used by the server**'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **指定服务器使用的私钥**'
- en: '***5*** **Opens the Docker daemon to external clients over TCP on port 2376**'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** **通过TCP端口2376将Docker守护进程对外部客户端开放。**'
- en: '***6*** **Opens the Docker daemon locally via a Unix socket in the normal way**'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6*** **以正常方式通过Unix套接字在本地打开Docker守护进程。**'
- en: '**Distributing client keys**'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '**分发客户端密钥**'
- en: Next you need to send the keys to the client host so it can connect to the server
    and exchange information. You don’t want to reveal your secret keys to anyone
    else, so these need to be passed to the client securely. A relatively safe way
    to do this is to SCP (secure copy) them direct from the server to the client.
    The SCP utility uses essentially the same technique to secure the transmission
    of data that we’re demonstrating here, only with different keys that will have
    already been set up.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您需要将密钥发送到客户端主机，以便它可以连接到服务器并交换信息。您不希望将您的秘密密钥透露给任何人，因此这些密钥需要安全地传递给客户端。一种相对安全的方法是从服务器直接使用SCP（安全复制）将它们复制到客户端。SCP实用程序使用与我们在下面展示的相同技术来确保数据传输的安全性，只是使用了已经设置好的不同密钥。
- en: 'On the client host, create the Docker configuration folder in /etc as you did
    earlier:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端主机上，创建Docker配置文件夹在`/etc`中，就像您之前做的那样：
- en: '[PRE16]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Then SCP the files from the server to the client. Make sure you replace “client”
    in the following commands with the hostname of your client machine. Also make
    sure that all the files are readable by the user that will run the `docker` command
    on the client.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，从服务器将文件SCP复制到客户端。确保在以下命令中将“客户端”替换为您的客户端机器的主机名。还要确保所有文件都可以由将在客户端上运行`docker`命令的用户读取。
- en: '[PRE17]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '**Testing**'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试**'
- en: 'To test your setup, first try making a request to the Docker server without
    any credentials. You should be rejected:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试您的设置，首先尝试在没有凭证的情况下向Docker服务器发出请求。您应该被拒绝：
- en: '[PRE18]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then connect with the credentials, which should return useful output:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用凭证连接，应该返回有用的输出：
- en: '[PRE19]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '**DISCUSSION**'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '**讨论**'
- en: This technique gives you the best of both worlds—a Docker daemon open to others
    to use, and one that’s only accessible to trusted users. Make sure you keep those
    keys safe!
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术为您提供了两全其美的解决方案——一个对其他人开放的Docker守护进程，以及一个仅对受信任用户可访问的守护进程。确保您保管好这些密钥！
- en: Key management is a critical aspect of most larger organizations’ IT management
    processes. It’s definitely a cost, so when it comes to implementing a Docker platform,
    it can become one that’s brought into sharp focus. Deploying keys safely to containers
    is a challenge that may well need to be considered in most Docker platform designs.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 密钥管理是大多数大型组织IT管理流程中的一个关键方面。这肯定是一个成本，因此在实施Docker平台时，它可能会变得非常突出。安全地将密钥部署到容器中是一个挑战，这在大多数Docker平台设计中可能需要考虑。
- en: '|  |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 14.4\. Security from outside Docker
  id: totrans-289
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 14.4. Docker外部的安全性
- en: Security on your host doesn’t stop with the `docker` command. In this section
    you’re going to see some other approaches to securing your Docker containers,
    this time from outside Docker.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的宿主机上，安全性并不随着`docker`命令的结束而停止。在本节中，您将看到一些其他方法来保护您的Docker容器，这次是从Docker外部进行。
- en: We’ll start off with a couple of techniques that modify your image to reduce
    the surface area for external attack once they’re up and running. The subsequent
    two techniques consider how to run containers in a restricted way.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先介绍一些技术，这些技术可以修改您的图像，以减少外部攻击的表面积，一旦它们启动并运行。接下来的两种技术考虑了以受限方式运行容器的方法。
- en: Of these latter two techniques, the first demonstrates the application platform
    as a service (aPaaS) approach, which ensures Docker runs within a straightjacket
    set up and controlled by the administrator. As an example, we’ll run an OpenShift
    Origin server (an aPaaS that deploys Docker containers in a managed way) using
    Docker commands. You’ll see that the end user’s powers can be limited and managed
    by the administrator, and access to the Docker runtime can be removed.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些后两种技术中，第一种演示了应用平台即服务（aPaaS）方法，这确保Docker在管理员设置和控制下的紧身衣中运行。作为一个例子，我们将使用Docker命令运行一个OpenShift
    Origin服务器（一种以管理方式部署Docker容器的aPaaS）。您将看到最终用户的权限可以被管理员限制和管理，并且可以移除对Docker运行时的访问。
- en: The second approach goes beyond this level of security to further limit the
    freedoms available within running containers using SELinux, a security technology
    that gives you fine-grained control over who can do what.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法超越了这一级别的安全性，进一步限制运行容器内可用的自由度，使用SELinux，这是一种提供细粒度控制谁可以做什么的安全技术。
- en: '|  |'
  id: totrans-294
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-295
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**提示**'
- en: SELinux is a tool built and open-sourced by the United States’ National Security
    Agency (NSA) that fulfills their need for strong access control. It has been a
    security standard for some time now, and it’s very powerful. Unfortunately, many
    people simply switch it off when they encounter problems with it, rather than
    take the time to understand it. We hope the technique shown here will help make
    that approach less tempting.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: SELinux 是由美国国家安全局（NSA）构建并开源的一个工具，它满足了他们对强大访问控制的需求。它已经是一段时间以来的安全标准，并且非常强大。不幸的是，当许多人遇到问题时，他们只是简单地将其关闭，而不是花时间去理解它。我们希望这里展示的技术能帮助使这种方法不那么诱人。
- en: '|  |'
  id: totrans-297
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-298
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Reducing a container’s attack surface with DockerSlim**'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用 DockerSlim 减小容器的攻击面**'
- en: In section 7.3 we discussed a few different ways to create a small image in
    response to reasonable concern about the amount of data being moved around a network.
    But there’s another reason to do this—if your image has less in it, there’s less
    for an attacker to exploit. As one concrete example, there’s no way to get a shell
    in the container if there’s no shell installed.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在第7.3节中，我们讨论了几种创建小镜像的不同方法，以应对对在网络中移动的数据量的合理担忧。但还有另一个原因要做这件事——如果你的镜像内容更少，攻击者可以利用的东西也就更少。作为一个具体的例子，如果没有安装shell，就无法在容器中获得shell。
- en: Building up an “expected behavior” profile for your container and then enforcing
    that at runtime means that unexpected actions have a realistic chance of being
    detected and prevented.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 为你的容器建立一个“预期行为”配置文件，并在运行时强制执行，这意味着意外行为有被检测和阻止的合理机会。
- en: '**PROBLEM**'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: You want to reduce an image to the bare essentials to reduce its attack surface.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望将镜像减小到最基本，以减少其攻击面。
- en: '**SOLUTION**'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: Use the DockerSlim tool to analyze your image and modify it for a reduced attack
    surface.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 DockerSlim 工具分析你的镜像并修改它以减小攻击面。
- en: This tool is intended to take a Docker image and reduce it to its barest essentials.
    It’s available at [https://github.com/docker-slim/docker-slim](https://github.com/docker-slim/docker-slim).
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 这个工具旨在将Docker镜像减小到最基本。它可在[https://github.com/docker-slim/docker-slim](https://github.com/docker-slim/docker-slim)找到。
- en: DockerSlim reduces your Docker image in at least two distinct ways. First, it
    reduces your image to only the required files and places these files in a single
    layer. The end result is an image that’s significantly smaller than its original,
    fat counterpart.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: DockerSlim 至少以两种不同的方式减小你的Docker镜像。首先，它将你的镜像减小到仅包含所需文件，并将这些文件放置在单个层中。最终结果是，这个镜像比其原始的胖镜像小得多。
- en: Second, it provides you with a seccomp profile. This is achieved through dynamic
    analysis of your running image. In lay terms, this means that it runs up your
    image and tracks which files and system calls are used. While DockerSlim is analyzing
    your running container, you need to use the app as it would be by all typical
    users, to ensure that the necessary files and system calls are picked up.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，它为你提供了一个 seccomp 配置文件。这是通过对你运行镜像的动态分析实现的。用通俗易懂的话说，这意味着它会运行你的镜像并跟踪使用哪些文件和系统调用。当
    DockerSlim 分析你的运行容器时，你需要像所有典型用户一样使用该应用程序，以确保必要的文件和系统调用被捕获。
- en: '|  |'
  id: totrans-309
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Warning
  id: totrans-310
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 警告
- en: If you reduce your image using a dynamic analysis tool like this, be absolutely
    sure you’ve exercised it enough in the analysis stage. This walkthrough uses a
    trivial image, but you may have a more complex image that’s harder to exhaustively
    profile.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用这种动态分析工具来减小你的镜像，请务必确保你在分析阶段已经充分测试。这个指南使用了一个简单的镜像，但你可能有一个更复杂的镜像，更难以完全分析。
- en: '|  |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: This technique will use a simple web example application to demonstrate the
    technique. You will
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术将使用一个简单的Web示例应用程序来展示技术。你将
- en: Set up DockerSlim
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置 DockerSlim
- en: Build an image
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建镜像
- en: Run the image as a container with the DockerSlim tool
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 DockerSlim 工具将镜像作为容器运行
- en: Hit an endpoint of the application
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打击应用程序的端点
- en: Run the slimmed image using the created seccomp profile
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用创建的 seccomp 配置文件运行精简后的镜像
- en: '|  |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-320
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: A seccomp profile is essentially a whitelist of which system calls can be made
    from a container. When running the container, you can specify a seccomp profile
    with either reduced or raised permissions, depending on what your application
    needs. The default seccomp profile disables around 45 system calls out of over
    300\. Most applications need far fewer than this.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 系统调用配置文件（seccomp profile）本质上是一个白名单，列出了容器可以从其中调用的系统调用。当运行容器时，你可以根据应用程序的需求，指定具有降低或提升权限的seccomp配置文件。默认的seccomp配置文件禁用了300多个系统调用中的大约45个。大多数应用程序需要的系统调用远少于这个数量。
- en: '|  |'
  id: totrans-322
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Setting up DockerSlim**'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '**设置DockerSlim**'
- en: Run these commands to get the docker-slim binary downloaded and set up.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令以下载并设置docker-slim二进制文件。
- en: Listing 14.5\. Downloading docker-slim and installing it to a directory
  id: totrans-325
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表14.5. 下载docker-slim并将其安装到目录中
- en: '[PRE20]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '***1*** **Makes the docker-slim folder and a bin subfolder**'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **创建docker-slim文件夹和bin子文件夹**'
- en: '***2*** **Gets the docker-slim zip file from its release folder**'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **从其发布文件夹获取docker-slim zip文件**'
- en: '***3*** **Unzips the retrieved zip file**'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **解压获取的zip文件**'
- en: '***4*** **Moves to the parent directory, docker-slim**'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **移动到父目录，docker-slim**'
- en: '|  |'
  id: totrans-331
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-332
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: This technique was tested against the preceding docker-slim version. You may
    want to visit GitHub at [https://github.com/docker-slim/docker-slim/](https://github.com/docker-slim/docker-slim/)
    releases to see whether there have been any updates. This isn’t a fast-moving
    project, so the updates shouldn’t be too important.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术已在先前的docker-slim版本上进行了测试。你可能想访问GitHub上的[https://github.com/docker-slim/docker-slim/](https://github.com/docker-slim/docker-slim/)
    releases，看看是否有任何更新。这不是一个快速发展的项目，所以更新可能不会太重要。
- en: '|  |'
  id: totrans-334
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Now you have the docker-slim binary in a bin subfolder.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经将docker-slim二进制文件放在了一个bin子文件夹中。
- en: '**Building the fat image**'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '**构建胖镜像**'
- en: Next you’ll build a sample application that uses NodeJS. This is a trivial application
    that simply serves a string of JSON on port 8000\. The following command clones
    the docker-slim repository, moves to the sample application code, and builds its
    Dockerfile into an image with the name sample-node-app.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将构建一个使用NodeJS的示例应用程序。这是一个简单的应用程序，它简单地在一个端口8000上提供JSON字符串。以下命令克隆了docker-slim仓库，移动到示例应用程序代码，并将其Dockerfile构建成一个名为sample-node-app的镜像。
- en: Listing 14.6\. Building an example docker-slim application
  id: totrans-338
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表14.6. 构建示例docker-slim应用程序
- en: '[PRE21]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '***1*** **Clones the docker-slim repository, which contains the sample application**'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **克隆docker-slim仓库，其中包含示例应用程序**'
- en: '***2*** **Checks out a known-working version of the docker-slim repository**'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **检出docker-slim仓库的一个已知工作版本**'
- en: '***3*** **Moves to the NodeJS sample application folder**'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **移动到NodeJS示例应用程序文件夹**'
- en: '***4*** **Builds the image, giving it the name sample-node-app**'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **构建镜像，将其命名为sample-node-app**'
- en: '***5*** **Returns to the previous directory, where the docker-slim binary is
    located**'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** **返回到包含docker-slim二进制文件的上一目录**'
- en: '**Running the fat image**'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '**运行胖镜像**'
- en: Now that you’ve created your fat image, the next step involves running it as
    a container with the docker-slim wrapper. Once the application has initialized,
    you then hit the application endpoint to exercise its code. Finally, bring the
    backgrounded docker-slim application to the foreground and wait for it to terminate.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经创建了胖镜像，下一步是将它作为带有docker-slim包装器的容器运行。一旦应用程序初始化，你就可以通过访问应用程序端点来测试其代码。最后，将后台的docker-slim应用程序带到前台并等待其终止。
- en: '[PRE22]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '***1*** **Runs the docker-slim binary against the sample-node-app image. Backgrounds
    the process. http-probe will call the application on all exposed ports.**'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **运行docker-slim二进制文件针对sample-node-app镜像。将进程置于后台。http-probe将在所有公开的端口上调用应用程序**'
- en: '***2*** **Sleeps for 10 seconds to allow the sample-node-app process to start,
    and then hits the port the application runs on**'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **暂停10秒以允许sample-node-app进程启动，然后点击应用程序运行的端口**'
- en: '***3*** **Sends the application’s JSON response to the terminal**'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **将应用程序的JSON响应发送到终端**'
- en: '***4*** **Foregrounds the docker-slim process and waits until it completes**'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **将docker-slim进程置于前台并等待其完成**'
- en: '***5*** **The first section of output from docker-slim shows its working logs.**'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** **docker-slim的输出第一部分显示了其工作日志。**'
- en: '***6*** **Docker-slim builds the “slim” container.**'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6*** **Docker-slim构建“瘦”容器。**'
- en: '***7*** **When it completes, you may need to press Return to get a prompt.**'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7*** **完成时，你可能需要按Return键以获取提示。**'
- en: In this case “exercising the code” just involves hitting one URL and getting
    a response. More sophisticated apps will need more varied and diverse types of
    poking and prodding to ensure they’ve been completely exercised.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，“锻炼代码”只是涉及点击一个 URL 并获取响应。更复杂的应用程序将需要更多样化和多样化的探测和检查，以确保它们已被完全锻炼。
- en: Note that according to the documents, we don’t need to hit the app on port 32770
    ourselves because we’ve used the http-probe argument. If you enable the HTTP probe,
    it will default to running an HTTP and HTTPS GET request on the root URL (“/”)
    on every exposed port. We do the `curl` by hand simply for demonstration purposes.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，根据文档，我们不需要自己击打端口 32770 的应用程序，因为我们使用了 http-probe 参数。如果您启用 HTTP 探针，它将默认在所有暴露的端口上运行
    HTTP 和 HTTPS GET 请求到根 URL（“/”）。我们手动进行 `curl` 操作只是为了演示目的。
- en: At this point, you’ve created the sample-node-app.slim version of your image.
    If you examine the output of `docker images`, you can see that its size has been
    drastically reduced.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经创建了 sample-node-app.slim 版本的镜像。如果您检查 `docker images` 的输出，您会看到其大小已经大幅减少。
- en: '[PRE23]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '***1*** **The sample-node-app.slim image is just over 14 MB in size.**'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **sample-node-app.slim 镜像的大小仅为 14 MB 左右。**'
- en: '***2*** **The original sample-node-app image was over 400 MB in size.**'
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **原始的 sample-node-app 镜像大小超过 400 MB。**'
- en: If you compare the `docker history` output of the fat sample app with its slim
    counterpart, you’ll see that they’re quite different in structure.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您比较胖样本应用程序的 `docker history` 输出与其精简版本，您会发现它们的结构相当不同。
- en: '[PRE24]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '***1*** **The docker history command is run on the sample-node-app image.**'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **在 sample-node-app 镜像上运行 docker history 命令。**'
- en: '***2*** **The history of this image shows each command as it was originally
    created.**'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **此镜像的历史记录显示了创建时每个命令的情况。**'
- en: '***3*** **The docker history command is run on the sample-node-app.slim image.**'
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **在 sample-node-app.slim 镜像上运行 docker history 命令。**'
- en: '***4*** **The history of the slim container consists of fewer commands, including
    a COPY command not in the original fat image.**'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **slim 容器的历史记录包含更少的命令，包括原始胖镜像中不存在的 COPY 命令。**'
- en: The preceding output gives a clue about part of what DockerSlim does. It manages
    to reduce the image size to (effectively) a single 14 MB layer by taking the final
    filesystem state, and copying that directory as the final layer of the image.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 上述输出提供了 DockerSlim 所做部分工作的线索。它通过获取最终的文件系统状态，并将该目录作为镜像的最后一层来复制，成功将镜像大小减少到（实际上）单个
    14 MB 层。
- en: The other artifact produced by DockerSlim relates to its second purpose as described
    at the beginning of this technique. A seccomp.json file is produced (in this case,
    sample-node-app-seccomp.json), which can be used to limit the actions of the running
    container.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: DockerSlim 生成的其他工件与其最初描述的第二目的相关。它生成一个 seccomp.json 文件（在本例中为 sample-node-app-seccomp.json），该文件可用于限制运行容器的操作。
- en: Let’s take a look at this file’s contents (edited here, as it’s rather long).
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这个文件的详细内容（此处已编辑，因为它相当长）。
- en: Listing 14.7\. A seccomp profile
  id: totrans-370
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 14.7\. 一个 seccomp 配置文件
- en: '[PRE25]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '***1*** **Captures the location of the seccomp file in the variable SECCOMPFILE**'
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **将 seccomp 文件的位置捕获到变量 SECCOMPFILE 中**'
- en: '***2*** **Cats this file to view it**'
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **将此文件内容输出到查看**'
- en: '***3*** **Specifies the exit code for the process that tries to call any forbidden
    syscall**'
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **指定尝试调用任何禁止的系统调用的进程的退出代码**'
- en: '***4*** **Specifies the hardware architectures this profile should be applied
    on**'
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **指定此配置文件应应用其上的硬件架构**'
- en: '***5*** **The syscalls controlled are whitelisted here by specifying the SCMP_ACT_ALLOW
    action against them.**'
  id: totrans-376
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** **在此处通过指定 SCMP_ACT_ALLOW 动作对它们进行白名单管理，以控制受控的系统调用。**'
- en: 'Finally, you’re going to run up the slim image again with the seccomp profile
    and check that it works as expected:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您将再次运行带有 seccomp 配置文件的 slim 镜像，并检查它是否按预期工作：
- en: '[PRE26]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '***1*** **Runs the slim image as a daemon, exposing the same port that DockerSlim
    exposed in its analysis phase, and applies the seccomp profile to it**'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **以守护进程运行 slim 镜像，暴露 DockerSlim 在分析阶段暴露的相同端口，并应用 seccomp 配置文件**'
- en: '***2*** **Outputs the container ID to the terminal**'
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **将容器 ID 输出到终端**'
- en: '***3*** **Reruns the curl command to confirm the application still works as
    before**'
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **重新运行 curl 命令以确认应用程序仍然像以前一样工作**'
- en: '***4*** **The output is identical to the fat image you’ve slimmed.**'
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **输出与您精简的胖镜像相同。**'
- en: '**DISCUSSION**'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '**讨论**'
- en: This simple example has shown how an image can be reduced not just in size,
    but also in the scope of the actions it can perform. This is achieved by removing
    inessential files (also discussed in [technique 59](kindle_split_017.xhtml#ch07sb12)),
    and reducing the syscalls available to it to only those that are needed to run
    the application.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的例子展示了如何不仅减小镜像的大小，还可以缩小其可以执行的操作范围。这是通过删除非必要文件（也在[技术 59](kindle_split_017.xhtml#ch07sb12)中讨论过）以及将其可用的系统调用减少到仅运行应用程序所需的那些来实现的。
- en: The means of “exercising” the application here was simple (one `curl` request
    to the default endpoint). For a real application, there are a number of approaches
    you can take to ensure you’ve covered all the possibilities. One way is to develop
    a set of tests against known endpoints, and another is to use a “fuzzer” to throw
    lots of inputs at the application in an automated way (this is one way to find
    bugs and security flaws in your software). The simplest way is to leave your application
    running for a longer period of time in the expectation that all the needed files
    and system calls will be referenced.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里“锻炼”应用程序的方法很简单（一个对默认端点的 `curl` 请求）。对于真实的应用程序，你可以采取多种方法来确保你已经覆盖了所有可能性。一种方法是对已知的端点开发一系列测试，另一种方法是使用“模糊器”以自动化的方式向应用程序抛出大量输入（这是找到你的软件中的错误和安全漏洞的一种方法）。最简单的方法是让应用程序运行更长的时间，期望所有需要的文件和系统调用都会被引用。
- en: Many enterprise Docker security tools work on this principle, but in a more
    automated way. Typically they allow an application to run for some time, and track
    which syscalls are made, which files are accessed, and also (possibly) which operating
    system capabilities are used. Based on this—and a configurable learning period—they
    can determine what the expected behavior of an application is, and report any
    behavior that seems to be out of line. For example, if an attacker gains access
    to a running container and starts up the bash binary or opens unexpected ports,
    this might raise an alarm on the system. DockerSlim allows you to take control
    over this process up-front, reducing what an attacker might be capable of doing
    even if they got access.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 许多企业级 Docker 安全工具基于这个原则工作，但以更自动化的方式进行。通常，它们允许应用程序运行一段时间，并跟踪哪些系统调用被使用，哪些文件被访问，以及（可能）使用了哪些操作系统功能。基于这些信息——以及可配置的学习期——它们可以确定应用程序的预期行为，并报告任何看似异常的行为。例如，如果攻击者获得了正在运行的容器的访问权限并启动了
    bash 二进制文件或打开了意外的端口，这可能会在系统中引发警报。DockerSlim 允许您从一开始就控制这个过程，即使攻击者获得了访问权限，也能减少他们可能能够执行的操作。
- en: Another way to consider slimming your application’s attack surface is to constrain
    its capabilities. This is covered in [technique 93](#ch14sb02).
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种考虑缩小应用程序攻击面的方法是限制其功能。这将在[技术 93](#ch14sb02)中介绍。
- en: '|  |'
  id: totrans-388
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-389
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Removing secrets added during a build**'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '**删除构建过程中添加的秘密**'
- en: When you’re building images in a corporate environment, it’s often necessary
    to use keys and credentials to retrieve data. If you’re using a Dockerfile to
    build an application, these secrets will generally be present in the history,
    even if you delete it after use.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在企业环境中构建镜像时，通常需要使用密钥和凭证来检索数据。如果你使用 Dockerfile 构建应用程序，即使在使用后删除，这些秘密通常也会出现在历史记录中。
- en: 'This can be a security problem: if someone got hold of the image, they might
    also get hold of the secret in the earlier layers.'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是一个安全问题：如果有人获得了镜像，他们也可能获得早期层中的秘密。
- en: '**PROBLEM**'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: You want to remove a file from an image’s history.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 你想从镜像的历史记录中删除一个文件。
- en: '**SOLUTION**'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: Use `docker-squash` to remove layers from the image.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `docker-squash` 从镜像中移除层。
- en: There are simple ways to solve this problem that work in theory. For example,
    you might delete the secret while it’s being used, as follows.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些简单的方法可以解决这个问题，从理论上来说是可行的。例如，你可以在使用秘密时将其删除，如下所示。
- en: Listing 14.8\. Crude method of not leaving a secret within a layer
  id: totrans-398
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 14.8\. 在层内不留下秘密的粗略方法
- en: '[PRE27]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This approach suffers from a number of disadvantages. It requires the secret
    to be put into code in the Dockerfile, so it may be in plain text in your source
    control.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法存在一些缺点。它需要将秘密放入 Dockerfile 中的代码，因此它可能以纯文本的形式存储在你的源代码控制中。
- en: To avoid this problem, you might add the file to your .gitignore (or similar)
    file in your source control, and `ADD` it to the image while it’s being built.
    This adds the file in a separate layer, which can’t easily be removed from the
    resulting image.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这个问题，您可能需要在源控制中的 .gitignore（或类似）文件中添加该文件，并在构建镜像时将其 `ADD` 到镜像中。这将在一个单独的层中添加文件，无法轻易从生成的镜像中移除。
- en: Finally, you could use environment variables to store secrets, but this also
    creates security risks, with these variables being easily set in non-secure persistent
    stores like Jenkins jobs. In any case, you may be presented with an image by a
    user and asked to scrub the secret from it. First we’re going to demonstrate the
    problem with a simple example, and then we’ll show you a way to remove the secret
    from the base layer.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可以使用环境变量来存储秘密，但这也会带来安全风险，因为这些变量很容易在非安全的持久存储中设置，例如 Jenkins 作业。在任何情况下，您可能会收到一个用户提供的镜像，并要求您从其中清除秘密。首先，我们将通过一个简单的示例演示这个问题，然后我们将向您展示一种从基础层中删除秘密的方法。
- en: '**An image with a secret**'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '**带有秘密的图像**'
- en: The following Dockerfile will create an image using the file called secret_file
    as a placeholder for some secret data you’ve put in your image.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 Dockerfile 将创建一个镜像，使用名为 secret_file 的文件作为您放入镜像中的某些秘密数据的占位符。
- en: Listing 14.9\. Simple Dockerfile with a secret
  id: totrans-405
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 14.9\. 带有秘密的简单 Dockerfile
- en: '[PRE28]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '***1*** **To save a bit of time, we override the default command with a file
    listing command. This will demonstrate whether the file is in the history.**'
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **为了节省一点时间，我们用文件列表命令覆盖了默认命令。这将演示文件是否在历史记录中。**'
- en: '***2*** **Adds the secret file to the image build (this must exist in your
    current working directory along with the Dockerfile)**'
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **将秘密文件添加到镜像构建中（此文件必须存在于您的当前工作目录中，与 Dockerfile 一起）**'
- en: '***3*** **Uses the secret file as part of the build. In this case, we use the
    trivial cat command to output the file, but this could be a git clone or other
    more useful command.**'
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **将秘密文件作为构建的一部分使用。在这种情况下，我们使用简单的 cat 命令输出文件，但这可以是 git clone 或其他更有用的命令。**'
- en: '***4*** **Removes the secret file**'
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **删除秘密文件**'
- en: Now you can build this image, calling the resulting image secret_build.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您可以构建这个镜像，将生成的镜像命名为 secret_build。
- en: Listing 14.10\. Building the simple Docker image with a secret
  id: totrans-412
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 14.10\. 构建带有秘密的简单 Docker 镜像
- en: '[PRE29]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Once the image is built, you can demonstrate that it has the secret file by
    using [technique 27](kindle_split_014.xhtml#ch04sb09).
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 镜像构建完成后，您可以通过使用[技术 27](kindle_split_014.xhtml#ch04sb09)来演示它包含秘密文件。
- en: Listing 14.11\. Tagging each step and demonstrating the layer with the secret
  id: totrans-415
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 14.11\. 为每个步骤添加标签并展示带有秘密的层
- en: '[PRE30]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '***1*** **Demonstrates that the secret file is in this tag of the image]**'
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **演示秘密文件存在于这个镜像标签中**]'
- en: '***2*** **Tags each step of the build in numerical order**'
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **按数字顺序标记构建的每个步骤**'
- en: '**Squashing images to remove secrets**'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '**压缩镜像以删除秘密**'
- en: You’ve seen that secrets can remain in the history of images even if they’re
    not in the final one. This is where `docker-squash` comes in—it removes the intervening
    layers but retains the Dockerfile commands (such as `CMD`, `PORT`, `ENV`, and
    so on) and the original base layer in your history.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经看到，即使秘密不在最终的镜像中，秘密也可以保留在镜像的历史记录中。这就是 docker-squash 发挥作用的地方——它移除了中间层，但保留了
    Dockerfile 命令（如 `CMD`、`PORT`、`ENV` 等）以及您历史记录中的原始基础层。
- en: The following listing downloads, installs, and uses `docker-squash` to compare
    the pre- and post-squashed images.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表下载、安装并使用 `docker-squash` 来比较压缩前后的镜像。
- en: Listing 14.12\. Using `docker_squash` to reduce layers of an image
  id: totrans-422
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 14.12\. 使用 `docker_squash` 减少镜像的层
- en: '[PRE31]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '***1*** **Installs docker-squash. (You may need to refer to [https://github.com/jwilder/docker-squash](https://github.com/jwilder/docker-squash)
    for the latest installation instructions.)**'
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **安装 docker-squash. (您可能需要参考[https://github.com/jwilder/docker-squash](https://github.com/jwilder/docker-squash)以获取最新的安装说明。)**'
- en: '***2*** **Saves the image to a TAR file that docker-squash operates on, and
    then loads the resulting image in, tagging it as “secret_build_squashed”**'
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **将镜像保存到 TAR 文件中，然后加载结果镜像，将其标记为“secret_build_squashed”**'
- en: '***3*** **The history of the squashed image has no record of secret_file.**'
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **压缩后的镜像的历史记录中没有 secret_file 的记录。**'
- en: '***4*** **The origin image has the secret_file still in it.**'
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **原始镜像中仍然包含 secret_file。**'
- en: '***5*** **Demonstrates that the secret_file is not in the squashed image**'
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** **演示 secret_file 不在压缩后的镜像中**'
- en: '***6*** **Demonstrates that the secret_file is not in the squashed image’s
    “squashed” layer**'
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6*** **演示了 secret_file 不在压缩镜像的“压缩”层中**'
- en: '**A note on “missing” image layers**'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: '**关于“缺失”镜像层的说明**'
- en: Docker changed the nature of layering in Docker 1.10\. From that point on, images
    downloaded show up as “<missing>” in the history. This is expected and is because
    of changes made by Docker to improve the security of images’ histories.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 在 1.10 版本中改变了层的基本性质。从那时起，下载的镜像在历史中显示为“<missing>”。这是预期的，这是由于 Docker 对镜像历史所做的更改，以提高镜像的安全性。
- en: You can still get the contents of layers you’ve downloaded by `docker save`ing
    the image and then extracting the TAR files from within that TAR file. Here’s
    an example session that does that for the already-downloaded Ubuntu image.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 你仍然可以通过 `docker save` 镜像并从该 TAR 文件中提取 TAR 文件来获取你已下载的层的内容。以下是一个示例会话，它为已下载的 Ubuntu
    镜像执行了此操作。
- en: Listing 14.13\. “Missing” layers in downloaded images
  id: totrans-433
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 14.13\. “缺失”的层在下载的镜像中
- en: '[PRE32]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '***1*** **Uses the docker history command to show the layer history of the
    Ubuntu image**'
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **使用 docker history 命令显示 Ubuntu 镜像的层历史**'
- en: '***2*** **Uses the docker save command to output a TAR file of the image layers,
    which is piped straight to tar and extracted**'
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **使用 docker save 命令输出镜像层的 TAR 文件，该文件直接通过管道传输到 tar 并提取**'
- en: '***3*** **Demonstrates that the TAR files contain only file changes within
    that layer**'
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **演示了 TAR 文件只包含该层内的文件更改**'
- en: '**DISCUSSION**'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: '**讨论**'
- en: Although somewhat similar in intent to [technique 52](kindle_split_017.xhtml#ch07sb05),
    the use of a specialized tool has some notable differences in the end result.
    In the preceding solution, you can see that metadata layers like `CMD` have been
    preserved, whereas the previous technique on this subject would discard them entirely,
    so you’d need to manually recreate those metadata layers through another Dockerfile.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在意图上与 [技术 52](kindle_split_017.xhtml#ch07sb05) 有一定相似性，但使用专用工具在最终结果上存在一些显著差异。在前面的解决方案中，你可以看到像
    `CMD` 这样的元数据层已经被保留，而之前关于这个主题的技术会完全丢弃它们，因此你需要通过另一个 Dockerfile 手动重新创建这些元数据层。
- en: This behavior means the docker-squash utility could be used to automatically
    clean up images as they arrive in a registry, if you’re inclined not to trust
    your users to use secret data correctly within image builds—they should all work
    normally.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为意味着 docker-squash 工具可以在镜像到达注册表时自动清理镜像，如果你不信任用户在镜像构建中使用秘密数据——它们都应该正常工作。
- en: That said, you should be wary of your users putting secrets in any metadata
    layers—environment variables in particular are a threat and may well be preserved
    in the final image.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，你应该警惕你的用户将秘密信息放入任何元数据层中——特别是环境变量是一个威胁，并且可能会在最终镜像中被保留。
- en: '|  |'
  id: totrans-442
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-443
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**OpenShift: An application platform as a service**'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: '**OpenShift：一个应用程序平台即服务**'
- en: OpenShift is a product managed by Red Hat that allows an organization to run
    an application platform as a service (aPaas). It offers application development
    teams a platform on which to run code without needing to be concerned about hardware
    details. Version 3 of the product was a ground-up rewrite in Go, with Docker as
    the container technology and Kubernetes and etcd for orchestration. On top of
    this, Red Hat has added enterprise features that enable it to be more easily deployed
    in a corporate and security-focused environment.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: OpenShift 是由 Red Hat 管理的一个产品，它允许组织以服务的形式运行应用程序平台（aPaas）。它为应用程序开发团队提供了一个平台，可以在其中运行代码，而无需关心硬件细节。该产品的第
    3 版是在 Go 语言中从头开始重写的，使用 Docker 作为容器技术，Kubernetes 和 etcd 进行编排。在此基础上，Red Hat 还添加了企业功能，使其更容易在企业和安全重点环境中部署。
- en: Although OpenShift has many features we could cover, we’ll use it here as a
    means of managing security by taking away the user’s ability to run Docker directly,
    but retaining the benefits of using Docker.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 OpenShift 有许多我们可以讨论的功能，但在这里我们将使用它作为管理安全性的手段，通过剥夺用户直接运行 Docker 的能力，但保留使用 Docker
    的好处。
- en: OpenShift is available both as an enterprise-supported product, and as an open
    source project called Origin, maintained at [https://github.com/openshift/origin](https://github.com/openshift/origin).
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: OpenShift 既可以作为企业支持的产品提供，也可以作为一个名为 Origin 的开源项目提供，该项目由 [https://github.com/openshift/origin](https://github.com/openshift/origin)
    维护。
- en: '**PROBLEM**'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: You want to manage the security risk of untrusted users invoking `docker run`.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望管理不受信任的用户调用 `docker run` 的安全风险。
- en: '**SOLUTION**'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: Use an aPaaS tool to manage and mediate the interaction with Docker via a proxying
    interface.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 aPaaS 工具通过代理接口管理和调解与 Docker 的交互。
- en: An aPaaS has many benefits, but the one we’ll focus on here is its ability to
    manage user permissions and run Docker containers on the user’s behalf, providing
    a secure audit point for users running Docker containers.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: aPaaS 有许多好处，但在这里我们将关注其管理用户权限并在用户代表下运行 Docker 容器的能力，为运行 Docker 容器的用户提供一个安全的审计点。
- en: Why is this important? The users using this aPaaS have no direct access to the
    `docker` command, so they can’t do any damage without subverting the security
    that OpenShift provides. For example, containers are deployed by non-root users
    by default, and overcoming this requires permission to be granted by an administrator.
    If you can’t trust your users, using an aPaaS is a effective way of giving them
    access to Docker.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 这为什么很重要？使用这个 aPaaS 的用户没有直接访问 `docker` 命令的权限，因此他们不能在不绕过 OpenShift 提供的安全性的情况下造成任何损害。例如，容器默认由非
    root 用户部署，克服这一点需要管理员授予的权限。如果你不信任你的用户，使用 aPaaS 是一种有效的方式，让他们能够访问 Docker。
- en: '|  |'
  id: totrans-454
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-455
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: An aPaaS provides users with the ability to spin up applications on demand for
    development, testing, or production. Docker is a natural fit for these services,
    as it provides a reliable and isolated application delivery format, allowing an
    operations team to take care of the details of deployment.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: aPaaS 为用户提供按需启动应用以进行开发、测试或生产的能力。Docker 是这些服务的自然选择，因为它提供了一种可靠且隔离的应用交付格式，允许运维团队处理部署的细节。
- en: '|  |'
  id: totrans-457
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: In short, OpenShift builds on Kubernetes (see [technique 88](kindle_split_024.xhtml#ch12sb03))
    but adds features to deliver a full-fledged aPaaS. These additional features include
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，OpenShift 基于 Kubernetes（见[技术 88](kindle_split_024.xhtml#ch12sb03)），但增加了功能，以提供完整的
    aPaaS。这些附加功能包括
- en: User management
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户管理
- en: Permissioning
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 权限管理
- en: Quotas
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配额
- en: Security contexts
  id: totrans-462
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全上下文
- en: Routing
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由
- en: '**Installing OpenShift**'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: '**安装 OpenShift**'
- en: A complete overview of OpenShift installation is beyond the scope of this book.
    If you’d like an automated install, using Vagrant, that we maintain, see [https://github.com/docker-in-practice/shutit-openshift-origin](https://github.com/docker-in-practice/shutit-openshift-origin).
    If you need help installing Vagrant, see [appendix C](kindle_split_038.xhtml#app03).
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: OpenShift 安装的完整概述超出了本书的范围。如果您想使用我们维护的 Vagrant 进行自动化安装，请参阅[https://github.com/docker-in-practice/shutit-openshift-origin](https://github.com/docker-in-practice/shutit-openshift-origin)。如果您需要安装
    Vagrant 的帮助，请参阅[附录 C](kindle_split_038.xhtml#app03)。
- en: Other options, such as a Docker-only installation (single-node only), or a full
    manual build are available and documented on the OpenShift Origin codebase at
    [https://github.com/openshift/origin.git](https://github.com/openshift/origin.git).
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 其他选项，如仅 Docker 安装（单节点）或完整的手动构建，都是可用的，并在 OpenShift Origin 代码库中有文档说明[https://github.com/openshift/origin.git](https://github.com/openshift/origin.git)。
- en: '|  |'
  id: totrans-467
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-468
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: OpenShift Origin is the upstream version of OpenShift. *Upstream* means that
    it’s the codebase from which Red Hat takes changes for OpenShift, its supported
    offering. Origin is open source and can be used and contributed to by anyone,
    but Red Hat’s curated version of it is sold and supported as OpenShift. An upstream
    version is usually more cutting edge but less stable.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: OpenShift Origin 是 OpenShift 的上游版本。*上游*意味着它是 Red Hat 为 OpenShift 取得变更的代码库，它是
    Red Hat 的支持产品。Origin 是开源的，任何人都可以使用和贡献，但 Red Hat 精选的版本作为 OpenShift 出售和支持。上游版本通常更前沿但更不稳定。
- en: '|  |'
  id: totrans-470
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**An** OpenShift application'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: '**一个 OpenShift 应用**'
- en: In this technique we’re going to show a simple example of creating, building,
    running, and accessing an application using the OpenShift web interface. The application
    will be a basic NodeJS application that serves a simple web page.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个技术中，我们将通过 OpenShift 网页界面展示一个创建、构建、运行和访问应用的简单示例。该应用将是一个基本的 NodeJS 应用，它提供了一个简单的网页。
- en: The application will use Docker, Kubernetes, and S2I under the hood. Docker
    is used to encapsulate the build and deployment environments. The Source to Image
    (S2I) build method is a technique used by Red Hat in OpenShift to build the Docker
    container, and Kubernetes is used to run the application on the OpenShift cluster.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 应用将使用 Docker、Kubernetes 和 S2I。Docker 用于封装构建和部署环境。源到镜像（S2I）构建方法是由 Red Hat 在 OpenShift
    中用于构建 Docker 容器的一种技术，而 Kubernetes 用于在 OpenShift 集群上运行应用。
- en: '**Logging in**'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: '**登录**'
- en: To get started, run `./run.sh` from the shutit-openshift-origin folder, and
    then navigate to https://localhost:8443, bypassing all the security warnings.
    You’ll see the login page shown in [figure 14.3](#ch14fig03). Note that if you’re
    using the Vagrant install, you’ll need to start up a web browser in your VM. (See
    [appendix C](kindle_split_038.xhtml#app03) for help on getting a GUI with your
    VM.)
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，从 shutit-openshift-origin 文件夹运行 `./run.sh`，然后导航到 https://localhost:8443，绕过所有安全警告。你会看到如图
    [图 14.3](#ch14fig03) 所示的登录页面。注意，如果你使用 Vagrant 安装，你需要在你的虚拟机中启动一个网络浏览器。（有关在虚拟机中获得
    GUI 的帮助，请参阅 [附录 C](kindle_split_038.xhtml#app03)）。
- en: Figure 14.3\. The OpenShift login page
  id: totrans-476
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 14.3\. OpenShift 登录页面
- en: '![](Images/14fig03_alt.jpg)'
  id: totrans-477
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.03](Images/14fig03_alt.jpg)'
- en: Log in as `hal-1` with any password.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 使用任何密码登录为 `hal-1`。
- en: '**Building a NodeJS app**'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: '**构建 NodeJS 应用**'
- en: You’re now logged into OpenShift as a developer (see [figure 14.4](#ch14fig04)).
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已以开发者的身份登录到 OpenShift（见图 [图 14.4](#ch14fig04)）。
- en: Figure 14.4\. The OpenShift Projects page
  id: totrans-481
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 14.4\. OpenShift 项目页面
- en: '![](Images/14fig04_alt.jpg)'
  id: totrans-482
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.04](Images/14fig04_alt.jpg)'
- en: Create a project by clicking Create. Fill out the form, as shown in [figure
    14.5](#ch14fig05). Then click Create again.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 通过点击创建来创建一个项目。填写表格，如图 [图 14.5](#ch14fig05) 所示。然后再次点击创建。
- en: Figure 14.5\. The OpenShift project-creation page
  id: totrans-484
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 14.5\. OpenShift 项目创建页面
- en: '![](Images/14fig05_alt.jpg)'
  id: totrans-485
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.05](Images/14fig05_alt.jpg)'
- en: Once the project is set up, click Create again and input the suggested GitHub
    repo ([https://github.com/openshift/nodejs-ex](https://github.com/openshift/nodejs-ex)),
    as shown in [figure 14.6](#ch14fig06).
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦项目设置完成，再次点击创建，并输入建议的 GitHub 仓库 ([https://github.com/openshift/nodejs-ex](https://github.com/openshift/nodejs-ex))，如图
    [图 14.6](#ch14fig06) 所示。
- en: Figure 14.6\. The OpenShift project source page
  id: totrans-487
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 14.6\. OpenShift 项目源页面
- en: '![](Images/14fig06_alt.jpg)'
  id: totrans-488
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.06](Images/14fig06_alt.jpg)'
- en: Click Next, and you’ll be given a choice of builder images, as shown in [figure
    14.7](#ch14fig07). The build image defines the context in which the code will
    be built. Choose the NodeJS builder image.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 点击下一步，你将看到一系列构建器镜像的选择，如图 [图 14.7](#ch14fig07) 所示。构建镜像定义了代码将构建的上下文。选择 NodeJS
    构建器镜像。
- en: Figure 14.7\. The OpenShift builder-image selection page
  id: totrans-490
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 14.7\. OpenShift 构建器镜像选择页面
- en: '![](Images/14fig07_alt.jpg)'
  id: totrans-491
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.07](Images/14fig07_alt.jpg)'
- en: Now fill out the form, as shown in [figure 14.8](#ch14fig08). Click Create on
    NodeJS at the bottom of the page as you scroll down the form.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 现在填写表格，如图 [图 14.8](#ch14fig08) 所示。在滚动表格时，在页面底部点击 NodeJS 的创建。
- en: Figure 14.8\. The OpenShift NodeJS template form
  id: totrans-493
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 14.8\. OpenShift NodeJS 模板表单
- en: '![](Images/14fig08_alt.jpg)'
  id: totrans-494
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.08](Images/14fig08_alt.jpg)'
- en: After a few minutes, you should see a screen like the one in [figure 14.9](#ch14fig09).
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 几分钟后，你应该会看到一个类似于 [图 14.9](#ch14fig09) 的屏幕。
- en: Figure 14.9\. The OpenShift build-started page
  id: totrans-496
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 14.9\. OpenShift 构建开始页面
- en: '![](Images/14fig09_alt.jpg)'
  id: totrans-497
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.09](Images/14fig09_alt.jpg)'
- en: In a few moments, if you scroll down, you’ll see that the build has started,
    as shown in [figure 14.10](#ch14fig10).
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 几分钟后，如果你向下滚动，你会看到构建已经开始，如图 [图 14.10](#ch14fig10) 所示。
- en: Figure 14.10\. The OpenShift build-information window
  id: totrans-499
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 14.10\. OpenShift 构建信息窗口
- en: '![](Images/14fig10_alt.jpg)'
  id: totrans-500
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.10](Images/14fig10_alt.jpg)'
- en: '|  |'
  id: totrans-501
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Tip
  id: totrans-502
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: In early versions of OpenShift, the build would sometimes not begin automatically.
    If this is the case, click the Start Build button after a few minutes.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 在 OpenShift 的早期版本中，构建有时不会自动开始。如果这种情况发生，几分钟后点击开始构建按钮。
- en: '|  |'
  id: totrans-504
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: After some time you’ll see that the app is running, as in [figure 14.11](#ch14fig11).
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 一段时间后，你会看到应用正在运行，如图 [图 14.11](#ch14fig11) 所示。
- en: Figure 14.11\. Application-running page
  id: totrans-506
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 14.11\. 应用运行页面
- en: '![](Images/14fig11_alt.jpg)'
  id: totrans-507
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.11](Images/14fig11_alt.jpg)'
- en: By clicking Browse and Pods, you can see that the pod has been deployed, as
    in [figure 14.12](#ch14fig12).
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 通过点击浏览和 Pods，你可以看到 pod 已经部署，如 [图 14.12](#ch14fig12) 所示。
- en: Figure 14.12\. List of OpenShift pods
  id: totrans-509
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 14.12\. OpenShift pods 列表
- en: '![](Images/14fig12_alt.jpg)'
  id: totrans-510
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.12](Images/14fig12_alt.jpg)'
- en: '|  |'
  id: totrans-511
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Tip
  id: totrans-512
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: See [technique 88](kindle_split_024.xhtml#ch12sb03) for an explanation of what
    a pod is.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 查看 [技术 88](kindle_split_024.xhtml#ch12sb03) 了解 pod 的解释。
- en: '|  |'
  id: totrans-514
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: How do you access your pod? If you look at the Services tab (see [figure 14.13](#ch14fig13)),
    you’ll see an IP address and port number to access.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 如何访问你的 pod？如果你查看服务标签（见图 [图 14.13](#ch14fig13)），你会看到一个 IP 地址和端口号来访问。
- en: Figure 14.13\. The OpenShift NodeJS application service details
  id: totrans-516
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 14.13\. OpenShift NodeJS 应用服务详情
- en: '![](Images/14fig13_alt.jpg)'
  id: totrans-517
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.13](Images/14fig13_alt.jpg)'
- en: Point your browser at that address, and voila, you’ll have your NodeJS app,
    as in [figure 14.14](#ch14fig14).
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 将你的浏览器指向该地址，哇，你将拥有你的 NodeJS 应用，如图 [图 14.14](#ch14fig14) 所示。
- en: Figure 14.14\. The NodeJS application landing page
  id: totrans-519
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 14.14\. NodeJS 应用程序登录页面
- en: '![](Images/14fig14_alt.jpg)'
  id: totrans-520
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/14fig14_alt.jpg)'
- en: '**DISCUSSION**'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: '**讨论**'
- en: Let’s recap what we’ve achieved here, and why it’s important for security.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下我们在这里所取得的成果，以及为什么这对安全性很重要。
- en: From the point of view of the user, they logged into a web application and deployed
    an application using Docker-based technologies without going near a Dockerfile
    or the `docker run` command.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 从用户的角度来看，他们登录了一个 Web 应用程序，并使用基于 Docker 的技术部署了一个应用程序，而没有接近 Dockerfile 或 `docker
    run` 命令。
- en: The administrator of OpenShift can
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: OpenShift 的管理员可以
- en: Control user access
  id: totrans-525
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制用户访问
- en: Limit resource use by project
  id: totrans-526
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按项目限制资源使用
- en: Provision resources centrally
  id: totrans-527
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集中提供资源
- en: Ensure code is run with non-privileged status by default
  id: totrans-528
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认确保代码以非特权状态运行
- en: This is far more secure than giving users direct access to `docker run`.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 这比直接给用户 `docker run` 访问权限要安全得多。
- en: 'If you want to build on this application and see how an aPaaS facilitates an
    iterative approach, you can fork the Git repository, change the code in that forked
    repository, and then create a new application. We’ve done that here: [https://github.com/docker-in-practice/nodejs-ex](https://github.com/docker-in-practice/nodejs-ex).'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想在此基础上构建应用程序并了解一个 aPaaS 如何促进迭代方法，您可以分叉 Git 仓库，更改该分叉仓库中的代码，然后创建一个新的应用程序。我们在这里就是这样做的：[https://github.com/docker-in-practice/nodejs-ex](https://github.com/docker-in-practice/nodejs-ex)。
- en: To read more about OpenShift, go to [http://www.openshift.org](http://www.openshift.org).
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于 OpenShift 的信息，请访问 [http://www.openshift.org](http://www.openshift.org)。
- en: '|  |'
  id: totrans-532
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-533
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Using security options**'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用安全选项**'
- en: You’ve already seen in previous techniques how, by default, you’re given root
    in the Docker container, and that this user is the same root as the root user
    on the host. To alleviate this, we’ve shown you how this user can have its capabilities
    as root reduced, so that even if it escapes the container, there are still actions
    the kernel won’t allow this user to perform.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经在前面的技术中看到，默认情况下，您在 Docker 容器中拥有 root 权限，并且这个用户与宿主机的 root 用户相同。为了减轻这一点，我们向您展示了如何降低此用户的
    root 能力，即使它逃出了容器，内核也不会允许此用户执行某些操作。
- en: But you can go further than this. By using Docker’s security-options flag you
    can protect resources on the host from being affected by actions performed within
    a container. This constrains the container to only affecting resources it has
    been given permission to by the host.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 但您可以更进一步。通过使用 Docker 的安全选项标志，您可以保护宿主机的资源免受容器内执行的操作的影响。这限制了容器只能影响宿主机授予其权限的资源。
- en: '**PROBLEM**'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: You want to secure your host against the actions of containers.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望保护您的宿主免受容器操作的影响。
- en: '**SOLUTION**'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: Use SELinux to impose constraints on your containers.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 SELinux 对您的容器施加约束。
- en: Here we’re going to use SELinux as our kernel-supported mandatory access control
    (MAC) tool. SELinux is more or less the industry standard and is most likely to
    be used by organizations that particularly care about security. It was originally
    developed by the NSA to protect their systems and was subsequently open-sourced.
    It’s used in Red Hat–based systems as a standard.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将使用 SELinux 作为我们的内核支持的强制访问控制（MAC）工具。SELinux 大约是行业标准，最有可能被特别关注安全的组织使用。它最初由
    NSA 开发，用于保护他们的系统，后来开源。它在基于 Red Hat 的系统中作为标准使用。
- en: SELinux is a big subject, so we can’t cover it in depth in this book. We’re
    going to show you how to write and enforce a simple policy so that you can get
    a feel for how it works. You can take things further and experiment if you need
    to.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: SELinux 是一个很大的主题，所以我们不能在这本书中深入探讨。我们将向您展示如何编写和执行一个简单的策略，以便您可以了解它是如何工作的。如果您需要，您可以进一步探索并进行实验。
- en: '|  |'
  id: totrans-543
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-544
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: Mandatory access control (MAC) tools in Linux enforce security rules beyond
    the standard ones you may be used to. Put briefly, they ensure that not only are
    the *normal* rules of read-write-execute on files and processes enforced, but
    more fine-grained rules can be applied to processes at the kernel level. For example,
    a MySQL process may only be allowed to write files under specific directories,
    such as /var/lib/mysql. The equivalent standard for Debian-based systems is AppArmor.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 中的强制访问控制（MAC）工具强制执行超出您可能习惯的标准安全规则。简而言之，它们不仅确保了文件和进程的读写执行等常规规则得到执行，而且还可以在内核级别应用更细粒度的规则。例如，MySQL
    进程可能仅被允许在特定目录下写入文件，例如 /var/lib/mysql。基于 Debian 的系统的等效标准是 AppArmor。
- en: '|  |'
  id: totrans-546
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: This technique assumes you have a SELinux-enabled host. This means you must
    first install SELinux (assuming it’s not already installed). If you’re running
    Fedora or some other Red Hat–based system, you likely have it already.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术假设你有一个启用了 SELinux 的主机。这意味着你必须首先安装 SELinux（假设它尚未安装）。如果你正在运行 Fedora 或其他基于
    Red Hat 的系统，你很可能已经安装了它。
- en: 'To determine whether you have SELinux enabled, run the command `sestatus`:'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定你是否启用了 SELinux，运行命令 `sestatus`：
- en: '[PRE33]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The first line of the output will tell you whether SELinux is enabled. If the
    command isn’t available, you don’t have SELinux installed on your host.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的第一行将告诉你 SELinux 是否已启用。如果该命令不可用，则表示你的主机上未安装 SELinux。
- en: You’ll also need to have the relevant SELinux policy-creation tools available.
    On a yum-capable machine, for example, you’ll need to run `yum -y install selinux-policy
    -devel`.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要有相关的 SELinux 政策创建工具可用。例如，在支持 yum 的机器上，你需要运行 `yum -y install selinux-policy
    -devel`。
- en: '**SELinux on a Vagrant machine**'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: '**Vagrant 机器上的 SELinux**'
- en: If you don’t have SELinux and want it to be built for you, you can use a ShutIt
    script to build a VM inside your host machine, with Docker and SELinux preinstalled.
    What it does is explained at a high level in [figure 14.15](#ch14fig15).
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有 SELinux 并且希望它为你构建，你可以使用 ShutIt 脚本在你的主机机器内部构建一个带有 Docker 和 SELinux 预安装的虚拟机。它所做的工作在[图
    14.15](#ch14fig15)中进行了高层次解释。
- en: Figure 14.15\. Script to provision a SELinux VM
  id: totrans-554
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 14.15\. 配置 SELinux 虚拟机的脚本
- en: '![](Images/14fig15_alt.jpg)'
  id: totrans-555
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/14fig15_alt.jpg)'
- en: '|  |'
  id: totrans-556
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-557
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: 'ShutIt is a generic shell automation tool that we created to overcome some
    limitations of Dockerfiles. If you want to read more about it, see the GitHub
    page: [http://ianmiell.github.io/shutit](http://ianmiell.github.io/shutit).'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: ShutIt 是一个通用的 shell 自动化工具，我们创建它是为了克服 Dockerfile 的一些限制。如果你想了解更多关于它的信息，请参阅 GitHub
    页面：[http://ianmiell.github.io/shutit](http://ianmiell.github.io/shutit)。
- en: '|  |'
  id: totrans-559
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '[Figure 14.5](#ch14fig05) identifies the steps required to get a policy set
    up. The script will do the following:'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 14.5](#ch14fig05) 识别了设置策略所需的步骤。该脚本将执行以下操作：'
- en: Set up VirtualBox
  id: totrans-561
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置 VirtualBox
- en: Start an appropriate Vagrant image
  id: totrans-562
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动合适的 Vagrant 镜像
- en: Log into the VM
  id: totrans-563
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录到虚拟机
- en: Ensure the state of SELinux is correct
  id: totrans-564
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保 SELinux 的状态正确
- en: Install the latest version of Docker
  id: totrans-565
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 Docker 的最新版本
- en: Install the SELinux policy development tools
  id: totrans-566
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 SELinux 政策开发工具
- en: Give you a shell
  id: totrans-567
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给你一个 shell
- en: 'Here are the commands to set up and run it (tested on Debian and Red Hat–based
    distributions):'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是设置和运行它的命令（已在 Debian 和基于 Red Hat 的发行版上测试）：
- en: Listing 14.14\. Installing ShutIt
  id: totrans-569
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 14.14\. 安装 ShutIt
- en: '[PRE34]'
  id: totrans-570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '***1*** **Ensures you are root before starting the run**'
  id: totrans-571
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **确保在开始运行之前你是 root 用户**'
- en: '***2*** **Ensures the required packages are installed on the host**'
  id: totrans-572
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **确保主机上安装了所需的软件包**'
- en: '***3*** **Installs ShutIt**'
  id: totrans-573
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **安装 ShutIt**'
- en: '***4*** **Clones the SELinux ShutIt script and enters its directory**'
  id: totrans-574
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **克隆 SELinux ShutIt 脚本并进入其目录**'
- en: '***5*** **Runs the ShutIt script. “--delivery bash” means commands are executed
    in bash rather than via SSH or in a Docker container.**'
  id: totrans-575
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** **运行 ShutIt 脚本。“--delivery bash”表示命令在 bash 中执行，而不是通过 SSH 或 Docker 容器执行。**'
- en: '***6*** **Configures the script to not compile a SELinux policy, as we’ll do
    this by hand**'
  id: totrans-576
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6*** **配置脚本不编译 SELinux 政策，因为我们将会手动完成**'
- en: 'After running this script, you should eventually see output like this:'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此脚本后，你应该最终看到如下输出：
- en: '[PRE35]'
  id: totrans-578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: You now have a shell running inside a VM with SELinux on it. If you type `sestatus`,
    you’ll see that SELinux is enabled in permissive mode (as shown in [listing 14.14](#ch14ex014)).
    To return to your host’s shell, press Ctrl-].
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你有一个运行在带有 SELinux 的虚拟机内部的 shell。如果你输入 `sestatus`，你会看到 SELinux 以许可模式启用（如[列表
    14.14](#ch14ex014)所示）。要返回到主机的 shell，请按 Ctrl-]。
- en: '**Compiling an SELinux policy**'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: '**编译 SELinux 政策**'
- en: Whether you used the ShutIt script or not, we assume you now have a host with
    SELinux enabled. Type `sestatus` to get a status summary.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你是否使用了 ShutIt 脚本，我们假设你现在有一个启用了 SELinux 的主机。输入 `sestatus` 以获取状态摘要。
- en: Listing 14.15\. SELinux status once installed and enabled
  id: totrans-582
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 14.15\. 安装并启用后 SELinux 的状态
- en: '[PRE36]'
  id: totrans-583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In this case, we’re in permissive mode, which means that SELinux is recording
    violations of security in logs, but isn’t enforcing them. This is good for safely
    testing new policies without rendering your system unusable. To move your SELinux
    status to permissive, type `setenforce Permissive` as root. If you can’t do this
    on your host for security reasons, don’t worry; there’s an option to set the policy
    as permissive outlined in [listing 14.15](#ch14ex015).
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们处于允许模式，这意味着SELinux正在记录日志中的安全违规，但不会强制执行它们。这对于安全测试新策略而不会使系统不可用是有益的。要将SELinux状态更改为允许模式，请以root身份输入`setenforce
    Permissive`。如果您由于安全原因无法在主机上执行此操作，请不要担心；有一个选项可以将策略设置为允许模式，如[列表14.15](#ch14ex015)中概述。
- en: '|  |'
  id: totrans-585
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-586
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: If you’re installing SELinux and Docker yourself on a host, ensure that the
    Docker daemon has `--selinux-enabled` set as a flag. You can check this with `ps
    -ef | grep 'docker -d.*--selinux-enabled`, which should return a matching process
    on the output.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在主机上自行安装SELinux和Docker，请确保Docker守护进程已将`--selinux-enabled`设置为标志。您可以使用`ps -ef
    | grep 'docker -d.*--selinux-enabled'`来检查此设置，它应该在输出中返回一个匹配的进程。
- en: '|  |'
  id: totrans-588
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Create a folder for your policy and move to it. Then create a policy file with
    the following content as root, named docker_apache.te. This policy file contains
    a policy we’ll try to apply.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 为您的策略创建一个文件夹并进入它。然后以root身份创建一个策略文件，内容如下，命名为docker_apache.te。此策略文件包含我们将尝试应用的策略。
- en: Listing 14.16\. Creating a SELinux policy
  id: totrans-590
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表14.16\. 创建SELinux策略
- en: '[PRE37]'
  id: totrans-591
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '***1*** **Creates a folder to store the policy files, and moves into it**'
  id: totrans-592
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **创建一个文件夹来存储策略文件，并进入该文件夹**'
- en: '***2*** **Creates the policy file that will be compiled as a “here” document**'
  id: totrans-593
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **创建将作为“here”文档编译的策略文件**'
- en: '***3*** **Creates the SELinux policy module docker_apache with the policy_module
    directive**'
  id: totrans-594
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **使用policy_module指令创建名为docker_apache的SELinux策略模块**'
- en: '***4*** **Uses the provided template to create the docker_apache_t SELinux
    type, which can be run as a Docker container. This template gives the docker_apache
    SELinux domain the fewest privileges required to run. We’ll add to these privileges
    to make a useful container environment.**'
  id: totrans-595
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **使用提供的模板创建docker_apache_t SELinux类型，该类型可以作为Docker容器运行。此模板为docker_apache
    SELinux域提供了运行所需的最少权限。我们将添加这些权限以创建一个有用的容器环境。**'
- en: '***5*** **The Apache web server requires these capabilities to run; adds them
    here with the allow directive.**'
  id: totrans-596
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** **Apache网络服务器需要这些功能才能运行；使用allow指令在此处添加它们。**'
- en: '***6*** **These allow and corenet rules give permission for the container to
    listen to Apache ports on the network.**'
  id: totrans-597
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6*** **这些allow和corenet规则允许容器在网络中监听Apache端口。**'
- en: '***7*** **Allows DNS server resolution with the sysnet directive**'
  id: totrans-598
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7*** **使用sysnet指令允许DNS服务器解析**'
- en: '***8*** **Optionally makes the docker_apache_t type permissive so this policy
    isn’t enforced even if the host is enforcing SELinux. Use this if you can’t set
    the SELinux mode of the host.**'
  id: totrans-599
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8*** **可选地使docker_apache_t类型为允许模式，即使主机正在执行SELinux策略，此策略也不会被强制执行。如果你无法设置主机的SELinux模式，请使用此选项。**'
- en: '***9*** **Terminates the “here” document, which writes it out to disk**'
  id: totrans-600
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***9*** **终止“here”文档，将其写入磁盘**'
- en: '|  |'
  id: totrans-601
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-602
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: For more information about the preceding permissions, and to explore others,
    you can install the selinux-policy-doc package and use a browser to browse the
    documentation on file:///usr/share/doc-base/selinux-policy-doc/ html/index.html.
    The docs are also available online at [http://oss.tresys.com/docs/refpolicy/api/](http://oss.tresys.com/docs/refpolicy/api/).
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 关于前面的权限的更多信息，以及探索其他权限，您可以安装selinux-policy-doc包，并使用浏览器浏览位于file:///usr/share/doc-base/selinux-policy-doc/html/index.html的文档。文档也在线上可用，网址为[http://oss.tresys.com/docs/refpolicy/api/](http://oss.tresys.com/docs/refpolicy/api/)。
- en: '|  |'
  id: totrans-604
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'Now you’re going to compile this policy and see your application fail to start
    against this policy in enforcing mode. Then you’ll restart it in permissive mode
    to check the violations and correct it later:'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您将编译此策略，并看到您的应用程序在强制模式下无法启动。然后您将重新启动它以检查违规行为并在稍后进行纠正：
- en: '[PRE38]'
  id: totrans-606
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '***1*** **Compiles the docker_apache.te file to a binary SELinux module with
    a .pp suffix**'
  id: totrans-607
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **将docker_apache.te文件编译为具有.pps后缀的二进制SELinux模块**'
- en: '***2*** **Installs the module**'
  id: totrans-608
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **安装模块**'
- en: '***3*** **Sets the SELinux mode to “enforcing”**'
  id: totrans-609
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **将SELinux模式设置为“enforcing”**'
- en: '***4*** **Runs the httpd image as a daemon, applying the security label type
    of docker_apache_t you defined in the SELinux module. This command should fail
    because it violates the SELinux security configuration.**'
  id: totrans-610
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **以守护进程方式运行httpd镜像，应用你在SELinux模块中定义的docker_apache_t安全标签类型。此命令应失败，因为它违反了SELinux安全配置。**'
- en: '***5*** **Removes the newly created container**'
  id: totrans-611
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** **删除新创建的容器**'
- en: '***6*** **Sets the SELinux mode to “permissive” to allow the application to
    start up**'
  id: totrans-612
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6*** **将SELinux模式设置为“permissive”以允许应用程序启动**'
- en: '***7*** **Runs the httpd image as a daemon, applying the security label type
    of docker_apache_t you defined in the SELinux module. This command should run
    successfully.**'
  id: totrans-613
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7*** **以守护进程方式运行httpd镜像，应用你在SELinux模块中定义的docker_apache_t安全标签类型。此命令应成功运行。**'
- en: '**Checking for violations**'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: '**检查违规**'
- en: 'Up to this point you’ve created a SELinux module and applied it to your host.
    Because the enforcement mode of SELinux is set to permissive on this host, actions
    that would be disallowed in enforcing mode are allowed with a log line in the
    audit log. You can check these messages by running the following command:'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经创建了一个SELinux模块并将其应用到你的主机上。因为在这个主机上SELinux的强制模式设置为permissive，所以那些在强制模式下会被禁止的操作允许在审计日志中记录下来。你可以通过运行以下命令来检查这些消息：
- en: '[PRE39]'
  id: totrans-616
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '***1*** **The type of message in the audit log is always AVC for SELinux violations,
    and timestamps are given as the number of seconds since the epoch (which is defined
    as 1st Jan 1970).**'
  id: totrans-617
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **审计日志中的消息类型始终为AVC，表示SELinux违规，时间戳以自纪元（定义为1970年1月1日）以来的秒数给出。**'
- en: '***2*** **The type of action denied is shown in the curly brackets.**'
  id: totrans-618
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **拒绝的操作类型显示在花括号中。**'
- en: '***3*** **The process ID and name of the command that triggered the violation**'
  id: totrans-619
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **触发违规的命令的进程ID和名称**'
- en: '***4*** **The path, device, and inode of the target file**'
  id: totrans-620
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **目标文件的路径、设备和inode**'
- en: '***5*** **The SELinux context of the target**'
  id: totrans-621
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** **目标的安全上下文**'
- en: '***6*** **The class of the target object**'
  id: totrans-622
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6*** **目标对象的类别**'
- en: 'Phew! There’s a lot of jargon there, and we don’t have time to teach you everything
    you might need to know about SELinux. If you want to find out more, a good place
    to start is with Red Hat’s SELinux documentation: [https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/5/html/Deployment_Guide/ch-selinux.html](https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/5/html/Deployment_Guide/ch-selinux.html).'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 呼吁！这里有太多的术语，我们没有时间教你可能需要知道的所有关于SELinux的知识。如果你想了解更多，一个好的开始是查看Red Hat的SELinux文档：[https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/5/html/Deployment_Guide/ch-selinux.html](https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/5/html/Deployment_Guide/ch-selinux.html)。
- en: 'For now, you need to check that the violations are nothing untoward. What might
    look untoward? If an application tries to open a port or a file you didn’t expect,
    you might think twice about doing what we’ll show you next: patch these violations
    with a new SELinux module.'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，你需要检查违规是否没有不寻常之处。什么可能看起来不寻常？如果一个应用程序尝试打开你未预期的端口或文件，你可能会三思而后行：使用新的SELinux模块修补这些违规。
- en: In this case, we’re happy that the httpd can write pipes. We’ve worked out that
    this is what SELinux was preventing because the “denied” actions mentioned are
    `append`, `write`, and `open` for pipefs files on the VM.
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们很高兴httpd可以写入管道。我们已经确定这是SELinux阻止的原因，因为提到的“拒绝”操作是对于VM上pipefs文件的`append`、`write`和`open`。
- en: '**Patching SELinux violations**'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: '**修补SELinux违规**'
- en: Once you’ve decided that the violations you’ve seen are acceptable, there are
    tools that can automatically generate the policy file you need to apply, so you
    don’t need to go through the pain and risk of writing one yourself. The following
    example uses the audit2allow tool to achieve this.
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你确定你看到的违规是可以接受的，有一些工具可以自动生成你需要应用的政策文件，因此你不需要自己编写一个，避免痛苦和风险。以下示例使用audit2allow工具来实现这一点。
- en: Listing 14.17\. Creating a new SELinux policy
  id: totrans-628
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表14.17. 创建新的SELinux策略
- en: '[PRE40]'
  id: totrans-629
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '***1*** **Creates a fresh folder to store the new SELinux module**'
  id: totrans-630
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **创建一个新的文件夹来存储新的SELinux模块**'
- en: '***2*** **Uses the audit2allow tool to display the policy that would be generated
    from reading the audit logs. Review this again to make sure it looks sensible.**'
  id: totrans-631
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **使用audit2allow工具显示从读取审计日志生成的策略。再次审查以确保其合理。**'
- en: '***3*** **Creates your module with the -M flag and a name for the module you’ve
    chosen**'
  id: totrans-632
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **使用-M标志和所选模块的名称创建你的模块**'
- en: '***4*** **Installs the module from the newly created .pp file**'
  id: totrans-633
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **从新创建的 .pp 文件中安装模块**'
- en: It’s important to understand that this new SELinux module we’ve created “includes”
    (or “requires”) and alters the one we created before by referencing and adding
    permissions to the docker_apache_t type. You can combine the two into a complete
    and discrete policy in a single .te file if you choose.
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解我们创建的这个新的 SELinux 模块“包含”（或“需要”）并修改了我们之前创建的模块，通过引用并添加权限到 docker_apache_t
    类型。如果你选择，你可以将这两个合并成一个完整且独立的策略，在单个 .te 文件中。
- en: '**Testing your new module**'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: '**测试你的新模块**'
- en: Now that you have your new module installed, you can try re-enabling SELinux
    and restarting the container.
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经安装了新模块，你可以尝试重新启用 SELinux 并重新启动容器。
- en: '|  |'
  id: totrans-637
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Tip
  id: totrans-638
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you couldn’t set your host to permissive earlier (and you added the hashed-out
    line to your original docker_apache.te file), then recompile and reinstall the
    original docker_apache.te file (with the permissive line hashed-out) before continuing.
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前无法将主机设置为宽容模式（并且你已将已删除的行添加到原始 docker_apache.te 文件中），则在继续之前重新编译并重新安装原始 docker_apache.te
    文件（已删除宽容行）。
- en: '|  |'
  id: totrans-640
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Listing 14.18\. Starting a container with SELinux restrictions
  id: totrans-641
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 14.18. 以 SELinux 限制启动容器
- en: '[PRE41]'
  id: totrans-642
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: There should be no new errors in the audit log. Your application has started
    within the context of this SELinux regime.
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 审计日志中不应出现新的错误。你的应用程序已在这个 SELinux 环境的上下文中启动。
- en: '**DISCUSSION**'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: '**讨论**'
- en: SELinux has a reputation for being complex and hard to manage, with the most
    frequently heard complaint being that it’s more often switched off than debugged.
    That’s hardly secure at all. Although the finer points of SELinux do require serious
    effort to master, we hope this technique has shown you how to create something
    that a security expert can review—and ideally sign off on—if Docker isn’t acceptable
    out of the box.
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: SELinux 以其复杂和难以管理而闻名，最常听到的抱怨是它更常被关闭而不是调试。这几乎不安全。尽管 SELinux 的细微之处确实需要付出极大的努力才能掌握，但我们希望这项技术已经向你展示了如何创建一个安全专家可以审查——如果
    Docker 不符合出厂设置，则理想情况下可以批准——的东西。
- en: '|  |'
  id: totrans-646
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Summary
  id: totrans-647
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: You can granularly control the power of root within your containers with capabilities.
  id: totrans-648
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用功能来细粒度地控制容器内 root 的权限。
- en: You can authenticate people using your Docker API via HTTP.
  id: totrans-649
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用 HTTP 通过 Docker API 对人员进行身份验证。
- en: Docker has built-in support for API encryption using certificates.
  id: totrans-650
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker 内置了对使用证书进行 API 加密的支撑。
- en: SELinux is a well-tested way to reduce the danger of containers running as root.
  id: totrans-651
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SELinux 是一种经过良好测试的方法，可以降低容器以 root 身份运行的风险。
- en: An application platform as a service (aPaaS) can be used to control access to
    the Docker runtime.
  id: totrans-652
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为一种服务（aPaaS）的应用程序平台可以用来控制对 Docker 运行时的访问。
- en: 'Chapter 15\. Plain sailing: Running Docker in production'
  id: totrans-653
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第 15 章. 一帆风顺：在生产环境中运行 Docker
- en: '|  |'
  id: totrans-654
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**This chapter covers**'
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: '**本章涵盖**'
- en: Your options for logging container output
  id: totrans-656
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的日志容器输出的选项
- en: Monitoring your running containers
  id: totrans-657
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控运行中的容器
- en: Managing your containers’ resource usage
  id: totrans-658
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理你的容器资源使用
- en: Using Docker’s capabilities to help manage traditional sysadmin tasks
  id: totrans-659
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Docker 的功能来帮助管理传统的系统管理员任务
- en: '|  |'
  id: totrans-660
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: In this chapter we’re going to cover some of the subjects that come up when
    running in production. Running Docker in production is a big subject, and production
    use of Docker is still an evolving area. Many major tools are in the early stages
    of development and were changing as we wrote this book’s first and second editions.
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖在生产环境中运行时出现的一些主题。在生产环境中运行 Docker 是一个很大的主题，Docker 的生产使用仍然是一个不断发展的领域。许多主要工具都处于早期开发阶段，并且在我们撰写本书的第一版和第二版时正在发生变化。
- en: In this chapter we’ll focus on showing you some of the key things you should
    consider when going from volatile environments to stable ones.
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将专注于向你展示一些当你从易变环境过渡到稳定环境时应考虑的关键事项。
- en: 15.1\. Monitoring
  id: totrans-663
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.1. 监控
- en: When you run Docker in production, one of the first things you’ll want to consider
    is how to track and measure what your containers are up to. In this section you’re
    going to learn how you can get an operational view of both your live containers’
    logging activity and their performance.
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在生产环境中运行 Docker 时，你首先想要考虑的一件事是如何跟踪和衡量你的容器正在做什么。在本节中，你将学习如何获取你运行中的容器日志活动和性能的操作视图。
- en: This is still a developing aspect of the Docker ecosystem, but some tools and
    techniques are emerging as more mainstream than others. We’ll look at redirecting
    application logs to the host’s syslog, at redirecting the output of the `docker
    logs` command to a single place, and at Google’s container-oriented performance
    monitoring tool, cAdvisor.
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 这仍然是Docker生态系统的一个发展中的方面，但一些工具和技术正在成为比其他更主流的选择。我们将探讨将应用程序日志重定向到主机的syslog，将`docker
    logs`命令的输出重定向到单个位置，以及Google的面向容器的性能监控工具cAdvisor。
- en: '|  |'
  id: totrans-666
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Logging your containers to the host’s syslog**'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: '**将容器的日志记录到主机的syslog**'
- en: Linux distributions typically run a syslog daemon. This daemon is the server
    part of the system-logging functionality—applications send messages to this daemon,
    along with metadata like the importance of the message, and the daemon will decide
    where to save the message (if at all). This functionality is used by a range of
    applications, from network connection managers to the kernel itself dumping information
    if it encounters an error.
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: Linux发行版通常运行一个syslog守护进程。这个守护进程是系统日志功能的客户端部分——应用程序将消息发送到这个守护进程，以及元数据，如消息的重要性，守护进程将决定将消息保存到何处（如果有的话）。这个功能被各种应用程序使用，从网络连接管理器到内核本身在遇到错误时输出信息。
- en: Because it’s so reliable and widely used, it’s reasonable for applications you
    write yourself to log to syslog. Unfortunately, this will stop working once you
    containerize your application (because there’s no syslog daemon in containers,
    by default). If you do decide to start a syslog daemon in all of your containers,
    you’ll need to go to each individual container to retrieve the logs.
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它非常可靠且广泛使用，因此您自己编写的应用程序记录到syslog是合理的。不幸的是，一旦您将应用程序容器化（因为默认情况下容器中没有syslog守护进程），这将停止工作。如果您决定在所有容器中启动syslog守护进程，您需要访问每个单独的容器来检索日志。
- en: '**PROBLEM**'
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: You want to capture syslogs centrally on your Docker host.
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望在您的Docker主机上集中捕获syslogs。
- en: '**SOLUTION**'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: Run a service container that acts as the syslog daemon for Docker containers.
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: 运行一个充当Docker容器syslog守护进程的服务容器。
- en: The basic idea of this technique is to run a service container that runs a syslog
    daemon, and share the logging touchpoint (/dev/log) via the host’s filesystem.
    The log itself can be retrieved by querying the syslog Docker container, and it’s
    stored in a volume.
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术的基本思想是运行一个服务容器，该容器运行syslog守护进程，并通过主机的文件系统共享日志接触点(/dev/log)。日志本身可以通过查询syslog
    Docker容器来检索，并存储在卷中。
- en: '[Figure 15.1](#ch15fig01) illustrates how /tmp/syslogdev on the host’s filesystem
    can be used as a touchpoint for all syslogging taking place on containers on the
    host. The logging containers mount and write their syslog to that location, and
    the syslogger container collates all those inputs.'
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: '[图15.1](#ch15fig01)说明了主机文件系统上的/tmp/syslogdev如何用作主机上所有syslog操作的接触点。日志容器挂载并写入其syslog到该位置，而syslogger容器汇总所有这些输入。'
- en: Figure 15.1\. Overview of centralized syslogging of Docker containers
  id: totrans-676
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图15.1\. Docker容器的集中syslog概述
- en: '![](Images/15fig01_alt.jpg)'
  id: totrans-677
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/15fig01_alt.jpg)'
- en: '|  |'
  id: totrans-678
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-679
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: The syslog daemon is a process that runs on a server, collecting and managing
    messages sent to a central file, which is normally a Unix domain socket. It generally
    uses /dev/log as a file to receive log messages, and it logs out to /var/log/syslog.
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: syslog守护进程是在服务器上运行的一个进程，它收集和管理发送到中央文件的消息，这通常是一个Unix域套接字。它通常使用/dev/log作为接收日志消息的文件，并将日志输出到/var/log/syslog。
- en: '|  |'
  id: totrans-681
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The syslogger container can be created with this straightforward Dockerfile.
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个简单的Dockerfile可以创建syslogger容器。
- en: Listing 15.1\. Building a syslogger container
  id: totrans-683
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表15.1\. 构建syslogger容器
- en: '[PRE42]'
  id: totrans-684
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '***1*** **Installs the rsyslog package, which makes the rsyslogd daemon program
    available. The “r” stands for “reliable.”**'
  id: totrans-685
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **安装rsyslog包，这使得rsyslogd守护进程程序可用。“r”代表“可靠”。**'
- en: '***2*** **Creates the /dev volume to share with other containers**'
  id: totrans-686
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **创建一个用于与其他容器共享的 /dev 卷**'
- en: '***3*** **Creates the /var/log volume to allow the syslog file to persist**'
  id: totrans-687
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **创建一个 /var/log 卷，以便syslog文件可以持久化**'
- en: '***4*** **Runs the rsyslogd process on startup**'
  id: totrans-688
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **在启动时运行rsyslogd进程**'
- en: 'Next, you build the container, tagging it with the syslogger tag, and run it:'
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您构建容器，使用syslogger标签标记它，并运行它：
- en: '[PRE43]'
  id: totrans-690
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: You bind-mounted the container’s /dev folder to the host’s /tmp/syslogdev folder
    so you can mount a /dev/log socket into each container as a volume, as you’ll
    see shortly. The container will continue running in the background, reading any
    messages from the /dev/log file and handling them.
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 你将容器的/dev文件夹绑定挂载到主机的/tmp/syslogdev文件夹，这样你就可以将/dev/log套接字作为卷挂载到每个容器中，正如你很快就会看到的。容器将继续在后台运行，读取任何来自/dev/log文件的消息并处理它们。
- en: 'On the host, you’ll now see that the /dev folder of the syslog container has
    been mounted to the host’s /tmp/syslogdev folder:'
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 在主机上，你现在会看到syslog容器的/dev文件夹已经挂载到主机的/tmp/syslogdev文件夹：
- en: '[PRE44]'
  id: totrans-693
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: For this demonstration, we’re going to start up 100 daemon containers that log
    their own starting order from 0 to 100 to the syslog, using the `logger` command.
    Then you’ll be able to see those messages by running a `docker exec` on the host
    to look at the syslogger container’s syslog file.
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个演示，我们将启动100个守护进程容器，它们将从0到100记录自己的启动顺序到syslog，使用`logger`命令。然后，你可以通过在主机上运行`docker
    exec`来查看syslogger容器的syslog文件，从而看到这些消息。
- en: First, start up the containers.
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，启动容器。
- en: Listing 15.2\. Starting up the logger containers
  id: totrans-696
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表15.2\. 启动日志容器
- en: '[PRE45]'
  id: totrans-697
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The preceding volume mount links the container’s syslog endpoint (/dev/log)
    to the host’s /tmp/syslogdev/log file, which in turn is mapped to the syslogger
    container’s /dev/log file. With this wiring, all syslog outputs are sent to the
    same file.
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的卷挂载将容器的syslog端点(/dev/log)链接到主机上的/tmp/syslogdev/log文件，该文件反过来映射到syslogger容器的/dev/log文件。通过这种连接，所有syslog输出都发送到同一个文件。
- en: 'When that’s complete, you’ll see something similar to this (edited) output:'
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 当完成时，你会看到类似以下（编辑后）的输出：
- en: '[PRE46]'
  id: totrans-700
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'You can use a modified `exec` command to archive these syslogs if you wish.
    For example, you could run the following command to get all logs for hour 11 on
    May 25th archived to a compressed file:'
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意，可以使用修改后的`exec`命令来存档这些syslogs。例如，你可以运行以下命令来获取5月25日第11小时的所有日志存档到一个压缩文件中：
- en: '[PRE47]'
  id: totrans-702
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '|  |'
  id: totrans-703
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-704
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: For the messages to show up in the central syslog container, your programs need
    to log to syslog. We ensure this here by running the `logger` command, but your
    applications should do the same for this to work. Most modern logging methods
    have a means to write to the locally visible syslog.
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让消息显示在中央syslog容器中，你的程序需要记录到syslog。我们通过运行`logger`命令来确保这一点，但你的应用程序也应该这样做才能正常工作。大多数现代日志方法都有一种写入本地可见syslog的方法。
- en: '|  |'
  id: totrans-706
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**DISCUSSION**'
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: '**讨论**'
- en: You may be wondering how you can distinguish between different containers’ log
    messages with this technique. Here you have a couple of options. You can change
    the application’s logging to output the hostname of the container, or you can
    see the next technique to have Docker do this heavy lifting for you.
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道如何使用这种技术区分不同容器的日志消息。这里有几个选项。你可以更改应用程序的日志输出以输出容器的主机名，或者你可以查看下一个技术，让Docker为你做这项繁重的工作。
- en: '|  |'
  id: totrans-709
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-710
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: This technique looks similar to the next one, which uses a Docker syslog driver,
    but it’s different. This technique keeps the output of containers’ running processes
    as the output of the `docker logs` command, whereas the next one takes over the
    `logs` command, rendering this technique redundant.
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术与下一个使用Docker syslog驱动的技术看起来很相似，但它不同。这种技术将容器运行进程的输出作为`docker logs`命令的输出，而下一个技术接管了`logs`命令，使得这种技术变得冗余。
- en: '|  |'
  id: totrans-712
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-713
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-714
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Logging your Docker logs output**'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: '**记录Docker日志输出**'
- en: As you’ve seen, Docker offers a basic logging system that captures the output
    of your container’s start command. If you’re a system administrator running many
    services off one host, it can be operationally tiresome to manually track and
    capture logs using the `docker logs` command on each container in turn.
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，Docker提供了一个基本的日志系统，它捕获了容器启动命令的输出。如果你是一个在单个主机上运行许多服务的系统管理员，手动使用`docker
    logs`命令逐个容器跟踪和捕获日志可能会在操作上感到疲惫。
- en: In this technique, we’re going to cover Docker’s log driver feature. This lets
    you use the standard logging systems to track many services on a single host,
    or even across multiple hosts.
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个技术中，我们将介绍Docker的日志驱动功能。这让你可以使用标准的日志系统来跟踪单个主机上的多个服务，甚至跨多个主机。
- en: '**PROBLEM**'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: You want to capture `docker logs` output centrally on your Docker host.
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 你想在Docker主机上集中捕获`docker logs`输出。
- en: '**SOLUTION**'
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: Use the `--log-driver` flag to redirect logs to the desired location.
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`--log-driver`标志将日志重定向到所需的位置。
- en: By default, Docker logs are captured within the Docker daemon, and you can access
    these with the `docker logs` command. As you’re probably aware, this shows you
    the output of the container’s main process.
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Docker日志被捕获在Docker守护进程中，您可以使用`docker logs`命令访问这些日志。如您所知，这显示了容器主进程的输出。
- en: At the time of writing, Docker gives you several choices for redirecting this
    output to multiple `log drivers`, including
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，Docker提供了多个选项来将此输出重定向到多个`log drivers`，包括
- en: syslog
  id: totrans-724
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: syslog
- en: journald
  id: totrans-725
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: journald
- en: json-file
  id: totrans-726
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: json-file
- en: The default is json-file, but others can be chosen with the `--log-driver` flag.
    The syslog and journald options send the log output to their respective daemons
    of the same name. You can find the official documentation on all available log
    drivers at [https://docs.docker.com/engine/reference/logging/](https://docs.docker.com/engine/reference/logging/).
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 默认为json-file，但可以使用`--log-driver`标志选择其他选项。syslog和journald选项将日志输出发送到同名守护进程。您可以在[https://docs.docker.com/engine/reference/logging/](https://docs.docker.com/engine/reference/logging/)找到所有可用日志驱动程序的官方文档。
- en: '|  |'
  id: totrans-728
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Warning
  id: totrans-729
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 警告
- en: This technique requires Docker version 1.6.1 or higher.
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 此技术需要Docker版本1.6.1或更高版本。
- en: '|  |'
  id: totrans-731
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The syslog daemon is a process that runs on a server, collecting and managing
    messages sent to a central file (normally a Unix domain socket). It generally
    uses /dev/log as a file to receive log messages on, and logs out to /var/log/syslog.
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: syslog守护进程是在服务器上运行的过程，它收集和管理发送到中央文件（通常是Unix域套接字）的消息。它通常使用`/dev/log`作为接收日志消息的文件，并将日志输出到`/var/log/syslog`。
- en: Journald is a system service that collects and stores logging data. It creates
    and maintains a structured index of logs received from a variety of sources. The
    logs can be queried with the `journalctl` command.
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: Journald是一个系统服务，用于收集和存储日志数据。它创建并维护一个结构化索引，记录来自各种来源的日志。可以使用`journalctl`命令查询日志。
- en: '**Logging to syslog**'
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: '**将日志记录到syslog**'
- en: 'To direct your output to the syslog, use the `--log-driver` flag:'
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 要将输出定向到syslog，请使用`--log-driver`标志：
- en: '[PRE48]'
  id: totrans-736
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'This will record the output in the syslog file. If you have permission to access
    the file, you can examine the logs using standard Unix tools:'
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 这将记录syslog文件中的输出。如果您有权限访问该文件，可以使用标准Unix工具检查日志：
- en: '[PRE49]'
  id: totrans-738
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '**Logging to journald**'
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: '**将日志记录到journald**'
- en: 'Outputting to a journal daemon looks similar:'
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: 输出到日志守护进程看起来类似：
- en: '[PRE50]'
  id: totrans-741
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '|  |'
  id: totrans-742
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Warning
  id: totrans-743
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 警告
- en: Ensure you have a journal daemon running on your host before running the preceding
    command.
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行前面的命令之前，请确保您的宿主机上运行着日志守护进程。
- en: '|  |'
  id: totrans-745
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Applying across all containers**'
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: '**应用于所有容器**'
- en: It can be laborious to apply this argument to all containers on your host, so
    you can change your Docker daemon to log by default to these supported mechanisms.
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: 将此参数应用于您主机上的所有容器可能很费力，因此您可以将Docker守护进程更改为默认使用这些支持的机制进行日志记录。
- en: Change the daemon /etc/default/docker, or /etc/sysconfig/docker, or whichever
    Docker config file your distribution has set up, such that the `DOCKER_OPTS=""`
    line is activated and includes the log-driver flag. For example, if the line was
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 修改守护进程`/etc/default/docker`、`/etc/sysconfig/docker`或您的发行版设置的任何Docker配置文件，以便激活`DOCKER_OPTS=""`行并包含日志驱动程序标志。例如，如果该行是
- en: '[PRE51]'
  id: totrans-749
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'change it to this:'
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: 更改为：
- en: '[PRE52]'
  id: totrans-751
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '|  |'
  id: totrans-752
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-753
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: See [appendix B](kindle_split_035.xhtml#app02) for details on how to change
    the Docker daemon’s configuration on your host.
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: 有关如何在您的宿主机上更改Docker守护进程配置的详细信息，请参阅[附录B](kindle_split_035.xhtml#app02)。
- en: '|  |'
  id: totrans-755
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: If you restart your Docker daemon, containers should then log to the relevant
    service.
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您重新启动Docker守护进程，容器应将日志记录到相关服务。
- en: '**DISCUSSION**'
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: '**讨论**'
- en: Another common choice worth mentioning in this context (but not covered here)
    is that you can use containers to implement an ELK (Elasticsearch, Logstash, Kibana)
    logging infrastructure.
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: 在此上下文中值得提及的另一个常见选择（但在此处未涵盖）是，您可以使用容器来实现ELK（Elasticsearch、Logstash、Kibana）日志基础设施。
- en: '|  |'
  id: totrans-759
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Warning
  id: totrans-760
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 警告
- en: Changing this daemon setting to anything other than `json-file` or `journald`
    will mean that the standard `docker logs` command will no longer work by default.
    Users of this Docker daemon may not appreciate this change, especially because
    the /var/log/syslog file (used by the `syslog` driver) is typically not accessible
    to non-root users.
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: 将此守护进程设置更改为`json-file`或`journald`以外的任何内容，将意味着默认情况下标准`docker logs`命令将不再工作。此Docker守护进程的用户可能不会欣赏这种变化，尤其是因为`/var/log/syslog`文件（由`syslog`驱动程序使用）通常对非root用户不可访问。
- en: '|  |'
  id: totrans-762
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-763
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-764
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Monitoring containers with cAdvisor**'
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用cAdvisor监控容器**'
- en: Once you have a serious number of containers running in production, you’ll want
    to monitor their resource usage and performance exactly as you do when you have
    multiple processes running on a host.
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦在生产环境中运行了大量容器，你将希望像在主机上运行多个进程时那样，精确地监控它们的资源使用情况和性能。
- en: The sphere of monitoring (both generally, and with respect to Docker) is a wide
    field with many candidates. cAdvisor has been chosen here as it’s a popular choice.
    Open-sourced by Google, it has quickly gained in popularity. If you already use
    a traditional host-monitoring tool such as Zabbix or Sysdig, then it’s worth seeing
    whether it already offers the functionality you need—many tools are adding container-aware
    functionality as we write.
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: 监控领域（无论是普遍的，还是针对 Docker）是一个广泛的领域，有许多候选者。在这里选择了 cAdvisor，因为它是一个流行的选择。由 Google
    开源，它迅速获得了人气。如果你已经使用 Zabbix 或 Sysdig 等传统主机监控工具，那么值得看看它是否已经提供了你需要的功能——许多工具正在添加容器感知功能，正如我们编写时一样。
- en: '**PROBLEM**'
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: You want to monitor the performance of your containers.
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: 你想监控你容器的性能。
- en: '**SOLUTION**'
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: Use cAdvisor as a monitoring tool.
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 cAdvisor 作为监控工具。
- en: cAdvisor is a tool developed by Google for monitoring containers. It’s open-sourced
    on GitHub at [https://github.com/google/cadvisor](https://github.com/google/cadvisor).
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: cAdvisor 是由 Google 开发的一款用于监控容器的工具。它在 GitHub 上开源，网址为 [https://github.com/google/cadvisor](https://github.com/google/cadvisor)。
- en: cAdvisor runs as a daemon that collects performance data on running containers.
    Among other things, it tracks
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: cAdvisor 以守护进程的形式运行，收集正在运行的容器的性能数据。其中之一，它跟踪
- en: Resource isolation parameters
  id: totrans-774
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源隔离参数
- en: Historical resource usage
  id: totrans-775
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 历史资源使用情况
- en: Network statistics
  id: totrans-776
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络统计信息
- en: cAdvisor can be installed natively on the host or run as a Docker container.
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: cAdvisor 可以在主机上本地安装或作为 Docker 容器运行。
- en: Listing 15.3\. Running cAdvisor
  id: totrans-778
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 15.3\. 运行 cAdvisor
- en: '[PRE53]'
  id: totrans-779
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '***1*** **Gives cAdvisor read-only access to the root filesystem so it can
    track information about the host**'
  id: totrans-780
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **允许 cAdvisor 以只读方式访问根文件系统，以便它可以跟踪有关主机的信息**'
- en: '***2*** **Mounts the /var/run folder with read-write access. At most, one instance
    of cAdvisor is expected to run per host.**'
  id: totrans-781
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **以读写访问权限挂载 /var/run 文件夹。预计每个主机上最多运行一个 cAdvisor 实例。**'
- en: '***3*** **Gives cAdvisor read-only access to the host’s /sys folder, which
    contains information about the kernel subsystems and devices attached to the host**'
  id: totrans-782
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **允许 cAdvisor 以只读方式访问主机的 /sys 文件夹，其中包含有关内核子系统和连接到主机的设备的信息**'
- en: '***4*** **Gives cAdvisor read-only access to Docker’s host directory**'
  id: totrans-783
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **允许 cAdvisor 以只读方式访问 Docker 的主机目录**'
- en: '***5*** **cAdvisor’s web interface is served on port 8080 of the container,
    so we publish it to the host on the same port. The standard Docker arguments to
    run the container in the background and give the container a name are also used.**'
  id: totrans-784
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** **cAdvisor 的 Web 界面在容器的 8080 端口上提供服务，因此我们在同一端口上将其发布到主机。运行容器的标准 Docker
    参数也被用于在后台运行容器并给容器命名。**'
- en: '***6*** **Restarts the container on failure, up to a maximum of 10 times. The
    image is stored on the Docker Hub within Google’s account.**'
  id: totrans-785
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6*** **在失败时重启容器，最多重启 10 次。镜像存储在 Docker Hub 上，属于 Google 的账户。**'
- en: Once you’ve started the image, you can visit http://localhost:8080 with your
    browser to start examining the data output. There’s information about the host,
    but by clicking on the Docker Containers link at the top of the homepage, you’ll
    be able to examine graphs of CPU, memory, and other historical data. Just click
    on the running containers listed under the Subcontainers heading.
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦启动了镜像，你可以使用浏览器访问 http://localhost:8080 来开始检查数据输出。这里有关于主机的信息，但通过点击主页顶部的 Docker
    容器链接，你可以检查 CPU、内存和其他历史数据的图表。只需点击“子容器”标题下列出的运行容器即可。
- en: The data is collected and retained in memory while the container runs. There
    is documentation for persisting the data to an InfluxDB instance on the GitHub
    page. The GitHub repository also has details about the REST API and a sample client
    written in Go.
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器运行期间，数据被收集并保存在内存中。GitHub 页面上有关于将数据持久化到 InfluxDB 实例的文档。GitHub 仓库还提供了关于 REST
    API 和用 Go 编写的示例客户端的详细信息。
- en: '|  |'
  id: totrans-788
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-789
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: InfluxDB is an open source database designed to handle the tracking of time-series
    data. It’s therefore ideal for recording and analyzing monitoring information
    that’s provided in real time.
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: InfluxDB 是一个开源数据库，旨在处理时间序列数据的跟踪。因此，它非常适合记录和分析实时提供的监控信息。
- en: '|  |'
  id: totrans-791
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**DISCUSSION**'
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: '**讨论**'
- en: Monitoring is a fast-evolving and splintering space, and cAdvisor is just one
    component among many now. For example, Prometheus, the fast-emerging standard
    for Docker, can receive and store data produced by cAdvisor rather than placing
    it directly in InfluxDB.
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: 监控是一个快速发展和分化的领域，cAdvisor只是众多组件之一。例如，Prometheus，作为Docker的快速崛起的标准，可以接收和存储由cAdvisor产生而不是直接放入InfluxDB的数据。
- en: Monitoring is also a subject that developers can get very passionate about.
    It can pay to develop a strategy for monitoring that can be flexible to meet changing
    fashions.
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: 监控也是开发者可能非常热衷的一个主题。制定一个灵活的监控策略，以适应不断变化的潮流是有益的。
- en: '|  |'
  id: totrans-795
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 15.2\. Resource control
  id: totrans-796
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.2. 资源控制
- en: One of the central concerns of running services in production is the fair and
    functional allocation of resources. Under the hood, Docker uses the core operating
    system concept of cgroups to manage containers’ resource usage. By default, a
    simple and equal-share algorithm is used when containers contend for resources,
    but sometimes this isn’t enough. You might want to reserve or limit resources
    for a container, or class of containers, for operational or service reasons.
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: 运行生产环境中的服务时，一个核心的担忧是资源的公平和有效分配。在底层，Docker使用核心操作系统概念cgroups来管理容器的资源使用。默认情况下，当容器争夺资源时，使用的是简单且均等份额的算法，但有时这还不够。您可能希望出于运营或服务原因，为容器或容器类别预留或限制资源。
- en: In this section you’ll learn how to tune containers’ usage of CPU and memory.
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将学习如何调整容器的CPU和内存使用。
- en: '|  |'
  id: totrans-799
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Restricting the cores a container can execute on**'
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: '**限制容器可以执行的CPU核心**'
- en: By default, Docker allows containers to execute on any cores on your machine.
    Containers with a single process and thread will obviously only be able to max
    out one core, but multithreaded programs in a container (or multiple single-threaded
    programs) will be able to use all your CPU cores. You might want to change this
    behavior if you have a container that’s more important than others—it’s not ideal
    for customer-facing applications to have to fight for the CPU every time your
    internal daily reports run. You could also use this technique to prevent runaway
    containers from locking you out of SSH to a server.
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Docker允许容器在您的机器上的任何核心上执行。具有单个进程和线程的容器显然只能使用一个核心，但容器中的多线程程序（或多个单线程程序）将能够使用所有CPU核心。如果您有一个比其他容器更重要的容器，您可能想要改变这种行为——对于面向客户的应用程序来说，每次内部日常报告运行时都要争夺CPU并不理想。您还可以使用这种技术来防止失控的容器阻止您通过SSH访问服务器。
- en: '**PROBLEM**'
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: You want a container to have a minimum CPU allocation, have a hard limit on
    CPU consumption, or otherwise want to restrict the cores a container can run on.
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望容器拥有最低的CPU分配，对CPU消耗有硬性限制，或者想要限制容器可以运行的CPU核心数。
- en: '**SOLUTION**'
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: Use the `--cpuset-cpus` option to reserve CPU cores for your container.
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`--cpuset-cpus`选项为您的容器预留CPU核心。
- en: To properly explore the `--cpuset-cpus` option, you’ll need to follow this technique
    on a computer with multiple cores. This may not be the case if you’re using a
    cloud machine.
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: 要正确探索`--cpuset-cpus`选项，您需要在具有多个核心的计算机上执行此技术。如果您使用的是云机器，可能不是这种情况。
- en: '|  |'
  id: totrans-807
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Tip
  id: totrans-808
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**提示**'
- en: Older versions of Docker used the flag `--cpuset`, which is now deprecated.
    If you can’t get `--cpuset-cpus` to work, try using `--cpuset` instead.
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: 旧版本的Docker使用`--cpuset`标志，现在已弃用。如果您无法使`--cpuset-cpus`工作，请尝试使用`--cpuset`代替。
- en: '|  |'
  id: totrans-810
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: To look at the effects of the `--cpuset-cpus` option, we’re going to use the
    `htop` command, which gives a useful graphical view of the core usage of your
    computer. Make sure this is installed before continuing—it’s typically available
    as the `htop` package from your system package manager. Alternatively, you can
    install it inside an Ubuntu container started with the `--pid=host` option to
    expose process information from the host to the container.
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看`--cpuset-cpus`选项的效果，我们将使用`htop`命令，它提供了计算机核心使用情况的直观图形视图。在继续之前，请确保已安装此命令——它通常作为系统包管理器中的`htop`包提供。或者，您可以在使用`--pid=host`选项启动的Ubuntu容器内安装它，以便将主机进程信息暴露给容器。
- en: 'If you now run `htop`, you’ll probably see that none of your cores are busy.
    To simulate some load inside a couple of containers, run the following command
    in two different terminals:'
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您现在运行`htop`，您可能会看到没有任何核心在使用。为了在几个容器内模拟一些负载，请在两个不同的终端中运行以下命令：
- en: '[PRE54]'
  id: totrans-813
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Looking back at `htop`, you should see that two of your cores now show 100%
    use. To restrict this to one core, `docker kill` the previous containers and then
    run the following command in two terminals:'
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾`htop`，你应该会看到现在有两个核心显示100%的使用率。要将其限制在一个核心上，使用`docker kill`终止之前的容器，然后在两个终端中运行以下命令：
- en: '[PRE55]'
  id: totrans-815
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Now `htop` will show that only your first core is being used by these containers.
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: 现在`htop`将显示这些容器只使用了你的第一个核心。
- en: The `--cpuset-cpus` option permits multiple core specification as a comma-separated
    list (`0,1,2`), a range (`0-2`), or a combination of the two (`0-1,3`). Reserving
    a CPU for the host is therefore a matter of choosing a range for your containers
    that excludes a core.
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: '`--cpuset-cpus`选项允许以逗号分隔的列表（`0,1,2`）、范围（`0-2`）或两者的组合（`0-1,3`）指定多个核心。因此，为宿主机保留CPU是一个选择范围的问题，这个范围不包括任何核心。'
- en: '**DISCUSSION**'
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: '**讨论**'
- en: You can use this functionality in numerous ways. For example, you can reserve
    specific CPUs for the host processes by consistently allocating the remaining
    CPUs to running containers. Or you could restrict specific containers to run on
    their own dedicated CPUs so they don’t interfere with the compute used by other
    containers.
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用多种方式使用这个功能。例如，你可以通过持续将剩余的CPU分配给运行中的容器来为宿主进程保留特定的CPU。或者，你也可以将特定的容器限制在它们自己的专用CPU上运行，这样它们就不会干扰其他容器的计算。
- en: In a multi-tenant environment, this can be a godsend for ensuring that workloads
    don’t interfere with each other.
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: 在多租户环境中，这可以确保工作负载不会相互干扰，真是一个天赐之物。
- en: '|  |'
  id: totrans-821
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-822
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Giving important containers more CPU**'
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: '**为重要容器分配更多CPU**'
- en: Containers on a host will normally share CPU usage equally when they compete
    for it. You’ve seen how to make absolute guarantees or restrictions, but these
    can be a little inflexible. If you want a process to be able to use more CPU than
    others, it’s a waste to constantly reserve an entire core for it, and doing so
    can be limiting if you have a small number of cores.
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: 当容器在宿主机上竞争CPU时，它们通常会平均共享CPU使用率。你已经看到了如何做出绝对的保证或限制，但这些可能有点不灵活。如果你想让一个进程能够比其他进程使用更多的CPU，那么不断为它保留整个核心是浪费的，如果你有很少的核心，这样做可能会有限制。
- en: Docker facilitates multi-tenancy for users who want to bring their applications
    to a shared server. This can result in the *noisy neighbor* problem well known
    to those experienced with VMs, where one user eats up resources and affects another
    user’s VM that happens to be running on the same hardware.
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: Docker为希望将应用程序带到共享服务器的用户提供了多租户支持。这可能导致那些有虚拟机经验的人所熟知的*嘈杂邻居*问题，其中一个用户消耗了资源并影响了另一个用户在相同硬件上运行的虚拟机。
- en: As a concrete example, while writing this book we had to use this functionality
    to reduce the resource use of a particularly hungry Postgres application that
    ate CPU cycles, robbing a web server on the machine of the ability to serve end
    users.
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: 作为具体例子，当我们编写这本书时，我们必须使用这个功能来减少一个特别贪婪的Postgres应用程序的资源使用，该应用程序消耗了CPU周期，剥夺了机器上Web服务器为最终用户提供服务的能力。
- en: '**PROBLEM**'
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: You want to be able to give more important containers a bigger share of CPU
    or mark some containers as less important.
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望能够给更重要的一些容器分配更多的CPU份额，或者将某些容器标记为不太重要。
- en: '**SOLUTION**'
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: Use the `-c/--cpu-shares` argument to the `docker run` command to define the
    relative share of CPU usage.
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`docker run`命令的`-c/--cpu-shares`参数来定义CPU使用的相对份额。
- en: When a container is started up, it’s given a number (1024 by default) of *CPU
    shares*. When only one process is running, it will have access to 100% of the
    CPU if necessary, no matter how many CPU shares it has access to. It’s only when
    competing with other containers for CPU that the number is used.
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: 当容器启动时，它会被分配一个数字（默认为1024）的*CPU份额*。当只有一个进程运行时，如果需要，它将能够访问100%的CPU，无论它有多少CPU份额。只有在与其他容器竞争CPU时，这个数字才会被使用。
- en: 'Imagine we have three containers (A, B, and C) all trying to use all available
    CPU resources:'
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有三个容器（A、B和C）都在尝试使用所有可用的CPU资源：
- en: If they’ve all been given equal CPU shares, they will each be allocated one
    third of the CPU.
  id: totrans-833
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果它们都被分配了相同的CPU份额，那么每个容器将分配到CPU的三分之一。
- en: If A and B are given 512 and C is given 1024, C will get half of the CPU, and
    A and B will get a quarter each.
  id: totrans-834
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果A和B被分配了512，C被分配了1024，那么C将获得一半的CPU，A和B各自获得四分之一。
- en: If A is given 10, B is given 100, and C is given 1000, A will get under 1% of
    the available CPU resources and will only be able to do anything resource-hungry
    if B and C are idle.
  id: totrans-835
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果A被分配10，B被分配100，C被分配1000，A将只能获得可用CPU资源的不到1%，并且只有在B和C空闲时才能执行资源密集型操作。
- en: All of this assumes that your containers can use all cores on your machine (or
    that you only have one core). Docker will spread the load from containers across
    all cores where possible. If you have two containers running single-threaded applications
    on a two-core machine, there’s obviously no way to apply relative weighting while
    maximally using the available resources. Each container will be given a core to
    execute on, regardless of its weight.
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都假设你的容器可以使用你机器上的所有核心（或者你只有一个核心）。Docker将在可能的情况下将容器的负载分散到所有核心。如果你在一个双核心机器上运行两个单线程应用程序，显然没有方法可以在最大化使用可用资源的同时应用相对权重。每个容器都将被分配一个核心来执行，而不管它的权重如何。
- en: 'If you want to try this out, run the following:'
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想尝试一下，运行以下命令：
- en: Listing 15.4\. Starving a Docker shell of CPU
  id: totrans-838
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表15.4\. 使Docker shell缺乏CPU
- en: '[PRE56]'
  id: totrans-839
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Now see how doing anything in the bash prompt is sluggish. Note that these numbers
    are relative—you can multiply them all by 10 (for example) and they would mean
    exactly the same thing. But the default granted is still 1024, so once you start
    changing these numbers, it’s worth considering what will happen to processes that
    start without a CPU share specified in the command and that run on the same CPU
    set.
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看看在bash提示符下做任何事情都多么缓慢。请注意，这些数字是相对的——你可以将它们都乘以10（例如），它们将意味着完全相同的事情。但是默认的授予值仍然是1024，所以一旦你开始更改这些数字，考虑一下没有在命令中指定CPU份额且在相同CPU集上运行的过程会发生什么就很有价值了。
- en: '|  |'
  id: totrans-841
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Tip
  id: totrans-842
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: Finding the right CPU share levels for your use case is something of an art.
    It’s worth looking at the output of programs such as top and vmstat to determine
    what’s using CPU time. When using top, it’s particularly useful to hit the “1”
    key to display what each CPU core is doing separately.
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: 为您的用例找到正确的CPU份额级别是一种艺术。查看top和vmstat等程序的输出以确定什么在消耗CPU时间很有价值。当使用top时，特别有用的是按“1”键来显示每个CPU核心分别在做些什么。
- en: '|  |'
  id: totrans-844
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**DISCUSSION**'
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: '**讨论**'
- en: Although we haven’t seen this technique directly used in the real world very
    often, and its use is generally seen on the underlying platform, it’s good to
    understand and play with the underlying mechanism to know how it works when tenants
    are complaining about lack of access (or apparent lack of access) to resources.
    This happens often in real-world environments, especially if the tenants’ workloads
    are sensitive to fluctuations in infrastructure availability.
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们在现实世界中很少直接看到这种技术的使用，而且它的使用通常在底层平台上看到，但了解并玩转底层机制以了解当租户抱怨缺乏（或明显的缺乏）资源访问时它是如何工作的，这很好。这在现实世界环境中很常见，尤其是如果租户的工作负载对基础设施可用性的波动敏感。
- en: '|  |'
  id: totrans-847
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-848
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Limiting the memory usage of a container**'
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: '**限制容器内存使用**'
- en: When you run a container, Docker will allow it to allocate as much memory from
    the host as possible. Usually this is desirable (and a big advantage over virtual
    machines, which have an inflexible way of allocating memory). But sometimes applications
    can go out of control, allocate too much memory, and bring a machine grinding
    to a halt as it starts swapping. It’s annoying, and it’s happened to us many times
    in the past. We want a way of limiting a container’s memory consumption to prevent
    this.
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行一个容器时，Docker将允许它从主机分配尽可能多的内存。通常这是可取的（并且与虚拟机相比有一个很大的优势，虚拟机有固定的内存分配方式）。但有时应用程序可能会失控，分配过多的内存，并在开始交换时使机器缓慢下来。这很烦人，我们过去曾多次遇到过这种情况。我们想要一种限制容器内存消耗的方法来防止这种情况。
- en: '**PROBLEM**'
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: You want to be able to limit the memory consumption of a container.
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要能够限制容器的内存消耗。
- en: '**SOLUTION**'
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: Use the `-m/--memory` parameter to `docker run`.
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`docker run`的`-m/--memory`参数。
- en: If you’re running Ubuntu, chances are that you don’t have the memory-limiting
    capability enabled by default. To check, run `docker info`. If one of the lines
    in the output is a warning about `No swap limit support`, there’s unfortunately
    some setup work you need to do. Be aware that making these changes can have performance
    implications on your machine for all applications—see the Ubuntu installation
    documentation for more information ([http://docs.docker.com/engine/installation/ubuntulinux/#adjust-memory-and-swap-accounting](http://docs.docker.com/engine/installation/ubuntulinux/#adjust-memory-and-swap-accounting)).
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在运行 Ubuntu，那么你很可能默认没有启用内存限制功能。要检查，请运行 `docker info`。如果输出中的某一行是关于 `No swap
    limit support` 的警告，那么不幸的是，你需要做一些设置工作。请注意，进行这些更改可能会对你的机器上所有应用程序的性能产生影响——有关更多信息，请参阅
    Ubuntu 安装文档 ([http://docs.docker.com/engine/installation/ubuntulinux/#adjust-memory-and-swap-accounting](http://docs.docker.com/engine/installation/ubuntulinux/#adjust-memory-and-swap-accounting))。
- en: 'In short, you need to indicate to the kernel at boot that you want these limits
    to be available. To do this, you’ll need to alter /etc/default/grub as follows.
    If `GRUB_CMDLINE _LINUX` already has values in it, add the new ones at the end:'
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，你需要在启动时向内核指示你想要这些限制可用。为此，你需要按照以下方式修改 /etc/default/grub。如果 `GRUB_CMDLINE_LINUX`
    已经有值，请将新值添加到末尾：
- en: '[PRE57]'
  id: totrans-857
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: You now need to run `sudo update-grub` and restart your computer. Running `docker
    info` should no longer give you the warning, and you’re now ready to proceed with
    the main attraction.
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你需要运行 `sudo update-grub` 并重新启动你的计算机。运行 `docker info` 应该不再显示警告，你现在可以继续进行主要活动了。
- en: First, let’s crudely demonstrate that the memory limit does work by using a
    limit of 4 MB, the lowest possible.
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们通过使用最低可能的限制 4 MB 来粗略地演示内存限制确实起作用。
- en: Listing 15.5\. Setting the lowest-possible memory limit for a container
  id: totrans-860
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 15.5\. 为容器设置最低可能的内存限制
- en: '[PRE58]'
  id: totrans-861
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '***1*** **Runs the container with a limit of 4 MB memory**'
  id: totrans-862
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **以 4 MB 的内存限制运行容器**'
- en: '***2*** **Tries to load about 10 MB into memory**'
  id: totrans-863
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **尝试将大约 10 MB 的内容加载到内存中**'
- en: '***3*** **The process consumed too much memory and so was killed.**'
  id: totrans-864
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **进程消耗了过多的内存，因此被终止。**'
- en: '***4*** **Tries to load 10 MB of memory directly into bash**'
  id: totrans-865
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **尝试将 10 MB 的内存直接加载到 bash 中**'
- en: '***5*** **Bash was killed, so the container exited.**'
  id: totrans-866
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** **Bash 被终止，因此容器退出了。**'
- en: '***6*** **Checks the exit code**'
  id: totrans-867
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6*** **检查退出代码**'
- en: '***7*** **The exit code is non-zero, indicating the container exited with an
    error.**'
  id: totrans-868
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7*** **退出代码非零，表示容器因错误而退出。**'
- en: There’s a gotcha with this kind of constraint. To demonstrate this, we’ll use
    the jess/ stress image, which contains `stress`, a tool designed for testing the
    limits of a system.
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的约束有一个需要注意的地方。为了演示这一点，我们将使用 jess/stress 镜像，它包含 `stress` 工具，这是一个用于测试系统极限的工具。
- en: '|  |'
  id: totrans-870
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-871
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: Jess/stress is a helpful image for testing any resource limits you impose on
    your container. Try out the previous techniques with this image if you want to
    experiment more.
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: Jess/stress 是一个用于测试你对容器施加的任何资源限制的有用镜像。如果你想进行更多实验，请尝试使用此镜像之前的技巧。
- en: '|  |'
  id: totrans-873
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'If you run the following command, you might be surprised to see that it doesn’t
    exit immediately:'
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行以下命令，你可能会惊讶地发现它并没有立即退出：
- en: '[PRE59]'
  id: totrans-875
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'You’ve asked Docker to limit the container to 100 MB, and you’ve instructed
    `stress` to take up 150 MB. You can verify that `stress` is operating as expected
    by running this command:'
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: 你已要求 Docker 将容器限制在 100 MB，并且你已指示 `stress` 使用 150 MB。你可以通过运行此命令来验证 `stress` 是否按预期运行：
- en: '[PRE60]'
  id: totrans-877
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The size column is in KB and shows that your container is indeed taking about
    150 MB of memory, raising the question of why it hasn’t been killed. It turns
    out that Docker double-reserves memory—half for physical memory and half to swap.
    If you try the following command, the container will terminate immediately:'
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
  zh: 大小列以 KB 为单位，显示你的容器确实使用了大约 150 MB 的内存，这引发了为什么它没有被终止的问题。实际上，Docker 对内存进行了双重预留——一半用于物理内存，另一半用于交换空间。如果你尝试以下命令，容器将立即终止：
- en: '[PRE61]'
  id: totrans-879
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: This double reservation is just a default and can be controlled with the `--memory-swap`
    argument, which specifies the total virtual memory size (memory + swap). For example,
    to completely eliminate swap usage, you should set `--memory` and `--memory-swap`
    to be the same size. You can see more examples in the Docker `run` reference at
    [https://docs.docker.com/engine/reference/run/#user-memory-constraints](https://docs.docker.com/engine/reference/run/#user-memory-constraints).
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
  zh: 这种双重预留只是一个默认设置，可以通过 `--memory-swap` 参数来控制，该参数指定了总虚拟内存大小（内存 + 交换空间）。例如，要完全消除交换空间的使用，应将
    `--memory` 和 `--memory-swap` 设置为相同的大小。您可以在 Docker `run` 参考文档中查看更多示例：[https://docs.docker.com/engine/reference/run/#user-memory-constraints](https://docs.docker.com/engine/reference/run/#user-memory-constraints)。
- en: '**DISCUSSION**'
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: '**讨论**'
- en: Memory limits are one of the hottest topics of any operations (or DevOps) team
    running a Docker platform. Misconfigured or poorly configured containers run out
    of assigned (or reserved) memory all the time (I’m looking at *you* Java developers!),
    requiring the writing of FAQs and runbooks to direct users to when they cry foul.
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
  zh: 内存限制是任何运行 Docker 平台的运营（或 DevOps）团队的热门话题之一。配置不当或配置不佳的容器经常耗尽分配（或预留）的内存（我看着你，Java
    开发者！），需要编写常见问题解答和操作手册来指导用户在遇到问题时如何操作。
- en: Being aware of what’s going on here is a great help to supporting such platforms
    and giving users the context of what’s going on.
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: 了解这里发生的事情对于支持此类平台并向用户提供正在发生的事情的背景非常有帮助。
- en: '|  |'
  id: totrans-884
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 15.3\. Sysadmin use cases for Docker
  id: totrans-885
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 15.3. Docker 的系统管理员用例
- en: In this section we’re going to take a look at some of the surprising uses to
    which Docker can be put. Although it may seem strange at first glance, Docker
    can be used to make your cron job management easier and can be used as a form
    of backup tool.
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨 Docker 可以用于的一些令人惊讶的用途。尽管乍一看可能觉得奇怪，但 Docker 可以使您的计划任务管理更加容易，并且可以用作备份工具的一种形式。
- en: '|  |'
  id: totrans-887
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-888
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: A cron job is a timed, regular command that’s run by a daemon included as a
    service with almost all Linux systems. Each user can specify their own schedule
    of commands to be run. It’s heavily used by sysadmins to run periodic tasks, such
    as cleaning up log files or running backups.
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
  zh: 计划任务（cron job）是一种定时、定期的命令，由几乎所有 Linux 系统中作为服务包含的守护进程运行。每个用户都可以指定自己的命令运行计划。系统管理员广泛使用它来运行周期性任务，例如清理日志文件或运行备份。
- en: '|  |'
  id: totrans-890
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: This is by no means an exhaustive list of potential uses, but it should give
    you a taste of Docker’s flexibility and some insight into how its features can
    be used in unexpected ways.
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: 这绝不是潜在用途的详尽列表，但它应该让您尝到 Docker 的灵活性，并对其功能如何以意想不到的方式使用有一些了解。
- en: '|  |'
  id: totrans-892
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Using Docker to run cron jobs**'
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用 Docker 运行计划任务**'
- en: If you’ve ever had to manage cron jobs across multiple hosts, you may have come
    across the operational headache of having to deploy the same software to multiple
    places and ensuring the crontab itself has the correct invocation of the program
    you want to run.
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您曾经需要在多个主机上管理计划任务，您可能已经遇到过必须将相同的软件部署到多个位置并确保 crontab 本身具有您想要运行的程序的正确调用的操作难题。
- en: Although there are other solutions to this problem (such as using Chef, Puppet,
    Ansible, or some other configuration management tool to manage the deployment
    of software across hosts), one option can be to use a Docker registry to store
    the correct invocation.
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管有其他解决方案可以解决这个问题（例如使用 Chef、Puppet、Ansible 或其他配置管理工具来管理跨主机的软件部署），但一个选项是使用 Docker
    仓库来存储正确的调用。
- en: This isn’t always the best solution to the problem outlined, but it’s a striking
    illustration of the benefits of having an isolated and portable store of your
    applications’ runtime configurations, and one that comes for free if you already
    use Docker.
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是解决上述问题的最佳方案，但它是一个引人注目的例子，说明了拥有一个隔离和可移植的应用程序运行时配置存储库的好处，如果您已经使用 Docker，这将免费获得。
- en: '**PROBLEM**'
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: You want your cron jobs to be centrally managed and auto-updated.
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望您的计划任务能够集中管理和自动更新。
- en: '**SOLUTION**'
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: Pull and run your cron job scripts as Docker containers.
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
  zh: 将您的计划任务脚本作为 Docker 容器拉取并运行。
- en: If you have a large estate of machines that need to run jobs regularly, you
    typically will use crontabs and configure them by hand (yes, that still happens),
    or you’ll use a configuration management tool such as Puppet or Chef. Updating
    their recipes will ensure that when a machine’s config management controller next
    runs, the changes are applied to the crontab, ready for the run following that.
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有一大批需要定期运行作业的机器，您通常会使用 crontabs 并手动配置它们（是的，这仍然会发生），或者您会使用 Puppet 或 Chef 等配置管理工具。更新它们的食谱将确保当机器的配置管理控制器下次运行时，更改将应用到
    crontab 中，以便在之后的运行中执行。
- en: '|  |'
  id: totrans-902
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-903
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: A *crontab* file is a special file maintained by a user that specifies the times
    scripts should be run. Typically these will be maintenance tasks, like compressing
    and archiving log files, but they could be business-critical applications, such
    as a credit card payment settler.
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 *crontab* 文件是由用户维护的特定文件，它指定了脚本应该运行的时间。通常这些会是维护任务，比如压缩和存档日志文件，但它们也可能是业务关键应用程序，例如信用卡支付结算器。
- en: '|  |'
  id: totrans-905
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: In this technique, we’ll show you how to replace this scheme with Docker images
    delivered from a registry with ‘docker pull’.
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个技术中，我们将向您展示如何使用来自注册表的 Docker 镜像替换此方案，并通过 'docker pull' 来交付。
- en: In the normal case, shown in [figure 15.2](#ch15fig02), the maintainer updates
    the configuration management tool, which is then delivered to the servers when
    the agent is run. Meanwhile, the cron jobs are running with the old and new code
    while the systems update.
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
  zh: 在正常情况下，如图 15.2 所示，维护者更新配置管理工具，然后在代理运行时将其交付到服务器。同时，cron 作业在旧代码和新代码之间运行，而系统在更新。
- en: Figure 15.2\. Each server updates cron scripts during a CM agent-scheduled run
  id: totrans-908
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 15.2\. 每个服务器在 CM 代理计划运行期间更新 cron 脚本
- en: '![](Images/15fig02.jpg)'
  id: totrans-909
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/15fig02.jpg)'
- en: In the Docker scenario, illustrated in [figure 15.3](#ch15fig03), the servers
    pull the latest version of the code before the cron jobs run.
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Docker 场景中，如图 15.3 所示，服务器在 cron 作业运行之前会拉取代码的最新版本。
- en: Figure 15.3\. Each server pulls the latest image on every cron job run
  id: totrans-911
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图 15.3\. 每个服务器在每次 cron 作业运行时都会拉取最新镜像
- en: '![](Images/15fig03.jpg)'
  id: totrans-912
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/15fig03.jpg)'
- en: 'At this point you may be wondering why it’s worth bothering with this, if you
    already have a solution that works. Here are some advantages of using Docker as
    the delivery mechanism:'
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，您可能想知道，如果您已经有了可行的解决方案，为什么还要费心去做这件事。以下是使用 Docker 作为交付机制的一些优点：
- en: Whenever a job is run, the job will update itself to the latest version from
    the central location.
  id: totrans-914
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次运行一个作业时，作业将从中央位置更新到最新版本。
- en: Your crontab files become much simpler, because the script and the code are
    encapsulated in a Docker image.
  id: totrans-915
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您的 crontab 文件变得更加简单，因为脚本和代码都封装在 Docker 镜像中。
- en: For larger or more complex changes, only the deltas of the Docker image need
    be pulled, speeding up delivery and updates.
  id: totrans-916
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于更大或更复杂的更改，只需要拉取 Docker 镜像的增量，从而加快交付和更新速度。
- en: You don’t have to maintain the code or binaries on the machine itself.
  id: totrans-917
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您不需要在机器本身上维护代码或二进制文件。
- en: You can combine Docker with other techniques, such as logging output to the
    syslog, to simplify and centralize the management of these administration services.
  id: totrans-918
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以将 Docker 与其他技术结合使用，例如将日志输出到 syslog，以简化并集中管理这些管理服务。
- en: For this example we’re going to use the log_cleaner image we created in [technique
    49](kindle_split_017.xhtml#ch07sb02). You’ll no doubt recall that this image encapsulated
    a script that cleaned up log files on a server and took a parameter for the number
    of days of log files to clean up. A crontab that uses Docker as a delivery mechanism
    would look something like the following listing.
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将使用我们在 [技术 49](kindle_split_017.xhtml#ch07sb02) 中创建的 log_cleaner 镜像。您无疑会记得这个镜像封装了一个清理服务器上日志文件的脚本，并接受一个参数来指定要清理的日志文件的天数。使用
    Docker 作为交付机制的 crontab 将类似于以下列表。
- en: Listing 15.6\. Log cleaner crontab entry
  id: totrans-920
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 15.6\. 日志清理器 crontab 条目
- en: '[PRE62]'
  id: totrans-921
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '***1*** **Runs this at midnight every day**'
  id: totrans-922
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **每天午夜运行此操作**'
- en: '***2*** **First pulls the latest version of the image**'
  id: totrans-923
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **首先拉取镜像的最新版本**'
- en: '***3*** **Runs the log cleaner over a day’s worth of log files**'
  id: totrans-924
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **运行日志清理器处理一天的日志文件**'
- en: '|  |'
  id: totrans-925
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-926
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you’re not familiar with cron, you may want to know that to edit your crontab
    you can run `crontab -e`. Each line specifies a command to be run at a time specified
    by the five items at the start of the line. Find out more by looking at the crontab
    man page.
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不太熟悉cron，你可能想知道要编辑你的crontab，你可以运行`crontab -e`。每一行指定一行开始处的五个项目所指定的时间运行的命令。通过查看crontab
    man页面了解更多信息。
- en: '|  |'
  id: totrans-928
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: If there’s a failure, the standard cron mechanism of sending an email should
    kick into effect. If you don’t rely on this, add a command with an `or` operator.
    In the following example, we assume your bespoke alerting command is `my_alert_command`.
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
  zh: 如果出现故障，标准的cron发送电子邮件机制应该启动。如果你不依赖这个，添加一个带有`or`操作符的命令。在以下示例中，我们假设你的定制警报命令是`my_alert_command`。
- en: Listing 15.7\. Log cleaner crontab entry with alerting on error
  id: totrans-930
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表15.7\. 在错误时带有警报的日志清理crontab条目
- en: '[PRE63]'
  id: totrans-931
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '|  |'
  id: totrans-932
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Tip
  id: totrans-933
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: 'An `or` operator (in this case, the double pipe: `||`) ensures that one of
    the commands on either side will be run. If the first command fails (in this case,
    either of the two commands within the parentheses after the cron specification
    `0 0 * * *` joined by the `and` operator, `&&`), then the second will be run.'
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`or`操作符（在这种情况下，双竖线：`||`）确保运行任一侧的命令。如果第一个命令失败（在这种情况下，cron指定`0 0 * * *`后面的括号内的两个命令之一，由`and`操作符`&&`连接），则将运行第二个命令。
- en: '|  |'
  id: totrans-935
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: The `||` operator ensures that if any part of the log-cleaning job run failed,
    the alert command gets run.
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
  zh: '`||`操作符确保如果日志清理作业的任何部分运行失败，则将运行警报命令。'
- en: '**DISCUSSION**'
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
  zh: '**讨论**'
- en: We really like this technique for its simplicity and use of battle-tested technologies
    to solve a problem in an original way.
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
  zh: 我们真的很喜欢这种技术，因为它简单，并且使用经过实战检验的技术以独特的方式解决问题。
- en: Cron has been around for decades (since the late 1970s, according to Wikipedia)
    and its augmentation by Docker image is a technique we use at home to manage regular
    jobs in a simple way.
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
  zh: Cron已经存在了几十年（根据维基百科，自1970年代末以来）并且通过Docker镜像的增强是我们在家以简单方式管理常规任务所使用的技术。
- en: '|  |'
  id: totrans-940
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-941
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**The “save game” approach to backups**'
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
  zh: '**备份的“保存游戏”方法**'
- en: If you’ve ever run a transactional system, you’ll know that when things go wrong,
    the ability to infer the state of the system at the time of the problem is essential
    for a root-cause analysis.
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经运行过事务性系统，你会知道当事情出错时，推断出问题发生时系统状态的能力对于根本原因分析是至关重要的。
- en: 'Usually this is done through a combination of means:'
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
  zh: 通常这是通过多种手段的组合来完成的：
- en: Analysis of application logs
  id: totrans-945
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序日志分析
- en: Database forensics (determining the state of data at a given point in time)
  id: totrans-946
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库取证（确定在特定时间点数据的状态）
- en: Build history analysis (working out what code and config was running on the
    service at a given point in time)
  id: totrans-947
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建历史分析（确定在特定时间点上服务上运行了哪些代码和配置）
- en: Live system analysis (for example, did anyone log onto the box and change something?)
  id: totrans-948
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实时系统分析（例如，是否有人登录到该设备并更改了某些内容？）
- en: For such critical systems, it can pay to take the simple but effective approach
    of backing up the Docker service containers. Although your database is likely
    to be separate from your Docker infrastructure, the state of config, code, and
    logs can be stored in a registry with a couple of simple commands.
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
  zh: 对于如此关键的系统，采取简单但有效的方法备份Docker服务容器可能是有益的。尽管你的数据库可能与你 Docker 基础设施分开，但配置、代码和日志的状态可以通过几个简单的命令存储在注册表中。
- en: '**PROBLEM**'
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: You want to keep backups of Docker containers.
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望保留Docker容器的备份。
- en: '**SOLUTION**'
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: Commit the containers while running, and push the resulting image as a dedicated
    Docker repository.
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时提交容器，并将生成的镜像推送到专门的Docker仓库。
- en: Following Docker best practices and taking advantage of some Docker features
    can help you avoid the need to store container backups. As one example, using
    a logging driver as described in [technique 102](#ch15sb03) instead of logging
    to the container filesystem means logs don’t need to be retrieved from the container
    backups.
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循Docker最佳实践并利用一些Docker功能可以帮助你避免需要存储容器备份的需求。例如，使用[技术102](#ch15sb03)中描述的日志驱动程序而不是将日志记录到容器文件系统中，这意味着不需要从容器备份中检索日志。
- en: But sometimes reality dictates that you can’t do everything the way you’d like,
    and you really need to see what a container looked like. The following commands
    show the entire process of committing and pushing a backup container.
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
  zh: 但有时现实迫使你不能按照你希望的方式做所有事情，你真的需要看到容器的外观。以下命令显示了提交和推送备份容器的整个过程。
- en: Listing 15.8\. Committing and pushing a backup container
  id: totrans-956
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表15.8\. 提交和推送备份容器
- en: '[PRE64]'
  id: totrans-957
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '***1*** **Generates a timestamp to the granularity of a second**'
  id: totrans-958
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **生成一个精确到秒的时间戳**'
- en: '***2*** **Generates a tag that points to your registry URL with a tag that
    includes the hostname and date**'
  id: totrans-959
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **生成一个指向您的注册表URL的标签，该标签包含主机名和日期**'
- en: '***3*** **Commits the container with the date as a message and “Backup Admin”
    as the author**'
  id: totrans-960
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **以日期作为消息，并以“备份管理员”作为作者提交容器**'
- en: '***4*** **Pushes the container to a registry**'
  id: totrans-961
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **将容器推送到注册表**'
- en: '|  |'
  id: totrans-962
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Warning
  id: totrans-963
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 警告
- en: This technique will pause the container while it runs, effectively taking it
    out of service. Your service should either tolerate outages, or you should have
    other nodes running at the time that can service requests in a load-balanced fashion.
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
  zh: 此技术将在容器运行时暂停它，有效地将其从服务中移除。您的服务应该能够容忍中断，或者您应该有其他节点在此时运行，以负载均衡的方式处理请求。
- en: '|  |'
  id: totrans-965
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: If this is done in a staggered rotation across all your hosts, you’ll have an
    effective backup system and a means to restore the state for support engineers
    with as little ambiguity as possible. [Figure 15.4](#ch15fig04) illustrates a
    simplified view of such a setup.
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在所有主机上以交错轮换的方式执行此操作，您将拥有一个有效的备份系统，以及尽可能减少歧义地恢复支持工程师状态的手段。[图15.4](#ch15fig04)展示了这种设置的简化视图。
- en: Figure 15.4\. Two-host backup of a service
  id: totrans-967
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图15.4\. 两个主机备份的服务
- en: '![](Images/15fig04_alt.jpg)'
  id: totrans-968
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/15fig04_alt.jpg)'
- en: The backups only push the differences between the base image and the state of
    the container at the time it’s backed up, and the backups are staggered to ensure
    that the service stays up on at least one host. The registry server only stores
    one copy of the base image and the diffs at each commit point, saving disk space.
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
  zh: 备份仅推送基本镜像和备份时容器状态的差异，并且备份是交错进行的，以确保至少在一个主机上服务保持运行。注册服务器只存储每个提交点的基镜像和差异，节省磁盘空间。
- en: '**DISCUSSION**'
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
  zh: '**讨论**'
- en: You can take this technique one step further by combining this technique with
    a so-called “Phoenix deployment” model. Phoenix deployment is a model for deployment
    that emphasizes replacing as much of the system as possible rather than upgrading
    a deployment in-place. It’s a central principle of many Docker tools.
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过结合所谓的“凤凰部署”模型将此技术进一步发展。凤凰部署是一种强调尽可能多地替换系统而不是就地升级部署的部署模型。这是许多Docker工具的核心原则。
- en: 'In this case, rather than committing the container and letting it continue
    on afterward, you can do the following:'
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，而不是提交容器并在之后继续，您可以执行以下操作：
- en: Pull a fresh copy of the latest image from your registry
  id: totrans-973
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从您的注册表中拉取最新镜像的副本
- en: Stop the running container
  id: totrans-974
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 停止正在运行的容器
- en: Start up a new container
  id: totrans-975
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动一个新的容器
- en: Commit, tag, and push the old container to the registry
  id: totrans-976
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提交、标记并推送旧容器到注册表
- en: Combining these approaches gives you even more certainty that the live system
    hasn’t drifted from the source image. One of us uses this approach to manage a
    live system on a home server.
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
  zh: 结合这些方法可以提供更多确定性，即实时系统没有从源镜像中漂移。我们中的一人使用这种方法来管理家庭服务器上的实时系统。
- en: '|  |'
  id: totrans-978
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Summary
  id: totrans-979
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: You can direct logging from your containers to your host’s syslog daemon.
  id: totrans-980
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以将容器的日志直接定向到主机上的syslog守护进程。
- en: Docker log output can be captured to a host-level service.
  id: totrans-981
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker日志输出可以捕获到主机级别的服务。
- en: cAdvisor can be used to monitor the performance of your containers.
  id: totrans-982
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: cAdvisor可用于监控容器性能。
- en: Container usage of CPU, core, and memory can be limited and controlled.
  id: totrans-983
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器对CPU、核心和内存的使用可以受到限制和控制。
- en: Docker has some surprising uses, such as being a cron delivery tool and a backup
    system.
  id: totrans-984
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker有一些令人惊讶的使用方式，例如作为cron交付工具和备份系统。
- en: 'Chapter 16\. Docker in production: Dealing with challenges'
  id: totrans-985
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第16章。在生产中处理Docker的挑战
- en: '|  |'
  id: totrans-986
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**This chapter covers**'
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
  zh: '**本章涵盖**'
- en: Bypassing Docker’s namespace functionality and using the host’s resources directly
  id: totrans-988
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绕过Docker的命名空间功能并直接使用宿主机的资源
- en: Making sure your host OS doesn’t kill processes in containers due to low memory
  id: totrans-989
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保主机操作系统不会因为内存不足而杀死容器中的进程
- en: Debugging a container’s network directly, using your host’s tooling
  id: totrans-990
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直接使用宿主机的工具调试容器的网络
- en: Tracing system calls to determine why a container isn’t working on your host
  id: totrans-991
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪系统调用以确定为什么容器在您的宿主机上无法工作
- en: '|  |'
  id: totrans-992
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: In this chapter we’ll discuss what you can do when Docker’s abstractions aren’t
    working for you. These topics necessarily involve getting under the hood of Docker
    to understand why such solutions can be needed, and in the process we aim to provide
    you with a deeper awareness of what can go wrong when using Docker and how to
    go about fixing it.
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论当Docker的抽象不适合你时你可以做什么。这些主题必然涉及到深入了解Docker，以了解为什么需要这样的解决方案，在这个过程中，我们旨在让你对使用Docker时可能出错的情况有更深入的了解，以及如何着手修复这些问题。
- en: '16.1\. Performance: You can’t ignore the tin'
  id: totrans-994
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.1. 性能：你不能忽视细节
- en: Although Docker seeks to abstract the application from the host it’s running
    on, one can never completely ignore the host. In order to provide its abstractions,
    Docker must add layers of indirection. These layers can have implications for
    your running system, and they sometimes need to be understood in order for operational
    challenges to be fixed or worked around.
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Docker试图将应用程序从其运行的主机抽象出来，但人们永远不能完全忽视主机。为了提供其抽象，Docker必须添加间接层。这些层可能对你的运行系统有影响，有时为了解决操作挑战或绕过它们，需要理解这些层。
- en: In this section we’ll look at how you can bypass some of these abstractions,
    ending up with a Docker container that has little of Docker left in it. We’ll
    also show that although Docker appears to abstract away the details of the storage
    you use, this can sometimes come back to bite you.
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨如何绕过这些抽象之一，最终得到一个几乎不含Docker剩余部分的Docker容器。我们还将展示，尽管Docker似乎抽象掉了你使用的存储细节，但有时这可能会对你造成伤害。
- en: '|  |'
  id: totrans-997
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Accessing host resources from the container**'
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
  zh: '**从容器访问主机资源**'
- en: We covered volumes, the most commonly used Docker abstraction bypass, in [technique
    34](kindle_split_015.xhtml#ch05sb07). They’re convenient for sharing files from
    the host and for keeping larger files out of image layers. They can also be significantly
    faster for filesystem access than the container filesystem, as some storage backends
    impose significant overheads for certain workloads—this isn’t useful for all applications,
    but it’s crucial in some cases.
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[技术34](kindle_split_015.xhtml#ch05sb07)中介绍了最常用的Docker抽象绕过方法——卷。它们便于从主机共享文件，并防止大文件进入镜像层。与容器文件系统相比，它们在文件系统访问方面也可能显著更快，因为某些存储后端对某些工作负载施加了显著的开销——这并不是所有应用程序都需要的，但在某些情况下是至关重要的。
- en: In addition to the overhead imposed by some storage backends, another performance
    hit comes about as a result of the network interfaces Docker sets up to give each
    container its own network. As with filesystem performance, network performance
    is definitely not a bottleneck for everyone, but it’s something you may wish to
    benchmark for yourself (although the fine details of network tuning are very much
    outside the scope of this book). Alternatively, you may have other reasons to
    want to bypass Docker networking entirely—a server that opens random ports to
    listen on may not be well served by listening on port ranges with Docker, especially
    because exposing a range of ports will allocate them on the host whether they’re
    in use or not.
  id: totrans-1000
  prefs: []
  type: TYPE_NORMAL
  zh: 除了某些存储后端强加的开销之外，由于Docker设置的用于给每个容器提供其自己的网络的网络接口，还会产生另一个性能损失。与文件系统性能一样，网络性能绝对不是每个人的瓶颈，但可能是你希望自行基准测试的东西（尽管网络调优的详细内容远远超出了本书的范围）。或者，你可能有自己的原因想要完全绕过Docker网络——一个打开随机端口以监听的服务器可能不会在Docker上监听端口范围得到很好的服务，特别是由于暴露的端口范围将在主机上分配，无论它们是否在使用中。
- en: Regardless of your reason, sometimes Docker abstractions get in the way, and
    Docker does offer the ability to opt out if you need to.
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你的原因是什么，有时Docker的抽象会阻碍你的工作，而Docker确实提供了退出选项，如果你需要的话。
- en: '**PROBLEM**'
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: You want to allow access to the host’s resources from the container.
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望允许从容器访问主机的资源。
- en: '**SOLUTION**'
  id: totrans-1004
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: Use the flags Docker offers for `docker run` to bypass the kernel namespace
    functionality that Docker uses.
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Docker提供的`docker run`标志来绕过Docker使用的内核命名空间功能。
- en: '|  |'
  id: totrans-1006
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-1007
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**提示**'
- en: Kernel namespaces are a service the kernel offers to programs, allowing them
    to get views of global resources in such a way that they appear to have their
    own separate instances of that resource. For example, a program can request a
    network namespace that will give you what appears to be a complete network stack.
    Docker uses and manages these namespaces to create its containers.
  id: totrans-1008
  prefs: []
  type: TYPE_NORMAL
  zh: 内核命名空间是内核提供给程序的服务，允许程序以这种方式获取全局资源的视图，即它们似乎有自己的独立实例。例如，一个程序可以请求一个网络命名空间，这将给你一个看似完整的网络堆栈。Docker使用并管理这些命名空间来创建其容器。
- en: '|  |'
  id: totrans-1009
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '[Table 16.1](#ch16table01) summarizes how Docker uses namespaces, and how you
    can effectively switch them off.'
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
  zh: '[表16.1](#ch16table01) 总结了Docker如何使用命名空间，以及如何有效地关闭它们。'
- en: Table 16.1\. Namespaces and Docker
  id: totrans-1011
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 表16.1\. 命名空间和Docker
- en: '| **Kernel namespace** | **Description** | **Used in Docker?** | “**Switch
    off” option** |'
  id: totrans-1012
  prefs: []
  type: TYPE_TB
  zh: '| **内核命名空间** | **描述** | **在Docker中使用？** | “**关闭选项**”'
- en: '| --- | --- | --- | --- |'
  id: totrans-1013
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| Network | The network subsystem | Yes | --net=host |'
  id: totrans-1014
  prefs: []
  type: TYPE_TB
  zh: '| 网络 | 网络子系统 | 是 | --net=host |'
- en: '| IPC | Inter-process communication: shared memory, semaphores, and so on |
    Yes | --ipc=host |'
  id: totrans-1015
  prefs: []
  type: TYPE_TB
  zh: '| IPC | 进程间通信：共享内存、信号量等 | 是 | --ipc=host |'
- en: '| UTS | Hostname and NIS domain | Yes | --uts=host |'
  id: totrans-1016
  prefs: []
  type: TYPE_TB
  zh: '| UTS | 主机名和NIS域 | 是 | --uts=host |'
- en: '| PID | Process IDs | Yes | --pid=host |'
  id: totrans-1017
  prefs: []
  type: TYPE_TB
  zh: '| PID | 进程ID | 是 | --pid=host |'
- en: '| Mount | Mount points | Yes | --volume, --device |'
  id: totrans-1018
  prefs: []
  type: TYPE_TB
  zh: '| 挂载 | 挂载点 | 是 | --volume, --device |'
- en: '| User | User and group IDs | No | N/A |'
  id: totrans-1019
  prefs: []
  type: TYPE_TB
  zh: '| 用户 | 用户和组ID | 否 | N/A |'
- en: '|  |'
  id: totrans-1020
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-1021
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**注意**'
- en: If any of these flags aren’t available, it will likely be due to your version
    of Docker being out of date.
  id: totrans-1022
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些标志中的任何一个不可用，那很可能是由于你的Docker版本过旧。
- en: '|  |'
  id: totrans-1023
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: If your application is a heavy user of shared memory, for example, and you want
    to have your containers share this space with the host, you can use the `--ipc=host`
    flag to achieve this. This use is relatively advanced, so we’ll focus on the other
    more common ones.
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的应用程序是共享内存的重度使用者，例如，并且你希望容器与宿主机共享这个空间，你可以使用`--ipc=host`标志来实现这一点。这种用法相对高级，所以我们将会关注其他更常见的用法。
- en: '**N**etwork and hostname****'
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
  zh: '**网络和主机名**'
- en: 'To use the host’s network, you run your container with the `--net` flag set
    to `host`, like this:'
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用宿主机的网络，你需要使用`--net`标志将容器设置为`host`，如下所示：
- en: '[PRE65]'
  id: totrans-1027
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: You’ll notice that this immediately differs from a network-namespaced container
    in that the hostname within the container is the same as the host’s. On a practical
    level, this can cause confusion, as it’s not obvious that you’re in a container.
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，这与网络命名空间容器立即不同，因为容器内的主机名与宿主机相同。在实用层面上，这可能会导致混淆，因为不明显知道自己在容器中。
- en: 'In a network-isolated container, a quick `netstat` will show that there are
    no connections on startup:'
  id: totrans-1029
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个网络隔离的容器中，快速执行`netstat`命令将显示启动时没有连接：
- en: '[PRE66]'
  id: totrans-1030
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'A similar run using the host’s network shows the usual network-busy host of
    a similarly busy technical author:'
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
  zh: 使用宿主机的网络运行类似操作将显示一个忙碌的技术作者通常的网络繁忙的主机：
- en: '[PRE67]'
  id: totrans-1032
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '|  |'
  id: totrans-1033
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-1034
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**注意**'
- en: '`netstat` is a command that allows you to see information about networking
    on your local network stack. It’s used most commonly to determine the state of
    network sockets.'
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
  zh: '`netstat`是一个命令，允许你查看本地网络堆栈上的网络信息。它最常用于确定网络套接字的状态。'
- en: '|  |'
  id: totrans-1036
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: The `net=host` flag is the most often used for a couple of reasons. First, it
    can make connecting containers much easier. But you lose the benefits of port
    mapping for your containers. If you have two containers that listen on port 80,
    for example, you can’t run them on the same host in this way. The second reason
    is that network performance is significantly improved over Docker’s when using
    this flag.
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`net=host`标志的原因有很多。首先，它可以使连接容器变得更容易。但你会失去容器端口映射的好处。例如，如果你有两个监听80端口的容器，你不能以这种方式在同一个主机上运行它们。第二个原因是，使用此标志时，网络性能比Docker本身有显著提升。
- en: '[Figure 16.1](#ch16fig01) shows at a high level the layers of overhead a network
    packet must go through in Docker versus a native network. Whereas the native network
    need only go through the TCP/IP stack of the host to the network interface card
    (NIC), Docker has to additionally maintain a virtual Ethernet pair (a “veth pair”—a
    virtual representation of a physical connection via an Ethernet cable), a network
    bridge between this veth pair and the host network, and a layer of network address
    translation (NAT). This overhead can cause the Docker network to be half the speed
    of a native host network in normal use cases.'
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
  zh: '[图16.1](#ch16fig01)从高层次展示了在Docker与原生网络中，网络数据包必须经过的额外层。原生网络只需要通过主机的TCP/IP堆栈到网络接口卡（NIC），而Docker还需要维护一个虚拟以太对（一个“veth
    pair”——通过以太网电缆的物理连接的虚拟表示），一个在此veth对和主机网络之间的网络桥，以及一层网络地址转换（NAT）。这种开销可能导致Docker网络在正常使用情况下速度仅为原生主机网络的一半。'
- en: Figure 16.1\. Docker networking vs. native networking
  id: totrans-1039
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图16.1\. Docker网络与原生网络
- en: '![](Images/16fig01.jpg)'
  id: totrans-1040
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/16fig01.jpg)'
- en: '**PID**'
  id: totrans-1041
  prefs: []
  type: TYPE_NORMAL
  zh: '**PID**'
- en: 'The PID namespace flag is similar to the others:'
  id: totrans-1042
  prefs: []
  type: TYPE_NORMAL
  zh: PID命名空间标志与其他标志类似：
- en: '[PRE68]'
  id: totrans-1043
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '***1*** **Runs the ps command in a containerized environment, showing only
    the process that has a PID of 1**'
  id: totrans-1044
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **在容器化环境中运行ps命令，只显示具有PID 1的进程**'
- en: '***2*** **The ps we’re running is the only process in this container and is
    given the PID of 1.**'
  id: totrans-1045
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **我们运行的ps是这个容器中唯一的进程，并赋予它PID 1。**'
- en: '***3*** **Runs the same ps command with the PID namespace removed, giving us
    a view of the host’s processes**'
  id: totrans-1046
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **运行不带PID命名空间的相同ps命令，从而让我们看到主机进程**'
- en: '***4*** **This time the PID of 1 is the systemd command, which is the startup
    process of the host’s operating system. This may differ for you, depending on
    your distribution.**'
  id: totrans-1047
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **这次PID 1是systemd命令，它是主机操作系统的启动进程。这可能会因你的发行版而异。**'
- en: The preceding example demonstrates that the systemd process of the host has
    process ID 1 in the container that has a view of the host PIDs, whereas without
    that view the only process seen is the `ps` command itself.
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例演示了主机上的systemd进程在具有主机PID视图的容器中的进程ID为1，而没有这种视图时，唯一看到的进程就是`ps`命令本身。
- en: '**Mount**'
  id: totrans-1049
  prefs: []
  type: TYPE_NORMAL
  zh: '**挂载**'
- en: 'If you want access to the host’s devices, use the `--device` flag to use a
    specific device, or mount the entire host’s filesystem with the `--volume` flag:'
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想访问主机的设备，使用`--device`标志使用特定设备，或者使用`--volume`标志挂载整个主机的文件系统：
- en: '[PRE69]'
  id: totrans-1051
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The preceding command mounts the host’s `/` directory to the container’s `/host`
    directory. You may be wondering why you can’t mount the host’s `/` directory to
    the container’s `/` directory. This is explicitly disallowed by the `docker` command.
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将主机的`/`目录挂载到容器的`/host`目录。你可能想知道为什么不能将主机的`/`目录挂载到容器的`/`目录。这是由`docker`命令明确禁止的。
- en: You may also be wondering whether you can use these flags to create a container
    that’s virtually indistinguishable from the host. That leads us to the next section...
  id: totrans-1053
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还在想是否可以使用这些标志创建一个几乎与主机无法区分的容器。这引出了下一个部分...
- en: '**A host-like container**'
  id: totrans-1054
  prefs: []
  type: TYPE_NORMAL
  zh: '**类似主机的容器**'
- en: 'You can use the following flags to create a container that has an almost transparent
    view of the host:'
  id: totrans-1055
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下标志来创建一个具有几乎透明主机视图的容器：
- en: '[PRE70]'
  id: totrans-1056
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '***1*** **Runs a container with three host arguments (net, pid, ipc)**'
  id: totrans-1057
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **运行具有三个主机参数（net、pid、ipc）的容器**'
- en: '***2*** **Mounts the root filesystem of the host to a directory /host on the
    container. Docker disallows the mounting of volumes to the “/” folder, so you
    must specify the /host subfolder volume.**'
  id: totrans-1058
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **将主机根文件系统挂载到容器的`/host`目录。Docker不允许将卷挂载到“/”文件夹，因此你必须指定`/host`子文件夹卷。**'
- en: '***3*** **Starts up a BusyBox container. All you need is the chroot command,
    and this is a small image that contains that. Chroot is executed to make the mounted
    filesystem appear as the root to you.**'
  id: totrans-1059
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **启动一个BusyBox容器。你只需要chroot命令，这是一个包含该命令的小镜像。Chroot被执行，使得挂载的文件系统看起来像是你的根目录。**'
- en: It’s ironic that Docker has been characterized as “`chroot` on steroids,” and
    here we’re using something characterized as a framework to run `chroot` in a way
    that subverts one of the principal purposes of `chroot`, which is to protect a
    host filesystem. It’s usually at this point that we try not to think about it
    too hard.
  id: totrans-1060
  prefs: []
  type: TYPE_NORMAL
  zh: 令人讽刺的是，Docker被描述为“强化版的`chroot`”，而在这里我们使用的是一个被描述为框架的东西来以颠覆`chroot`主要目的的方式运行`chroot`，即保护主机文件系统。通常在这个时候，我们尽量不去深入思考。
- en: In any case, it’s hard to imagine a real-world use of that command (instructive
    as it is). If you think of one, please drop us a line.
  id: totrans-1061
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，很难想象这个命令（尽管有教育意义）在现实世界中有实际用途。如果你想到了一个，请给我们发邮件。
- en: 'That said, you might want to use it as a basis for more useful commands like
    this:'
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，你可能想将其用作以下更有用命令的基础：
- en: '[PRE71]'
  id: totrans-1063
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: In this example, `--workdir /host` sets the working directory on container startup
    to be the root of the host’s filesystem, as mounted with the `--volume` argument.
    The `:ro` part of the volume specification means the host filesystem will be mounted
    as read-only.
  id: totrans-1064
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`--workdir /host`将容器启动时的工作目录设置为宿主文件系统的根目录，正如使用`--volume`参数挂载的那样。卷规范中的`:ro`部分表示宿主文件系统将以只读方式挂载。
- en: With this command, you can give yourself a read-only view of the filesystem
    while having an environment where you can install tools (with the standard Ubuntu
    package manager) to inspect it. For example, you could use an image that runs
    a nifty tool that reports security problems on your host’s filesystem, without
    having to install it on your host.
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个命令，你可以在具有安装工具（使用标准的Ubuntu包管理器）以检查文件系统的环境中获得文件系统的只读视图。例如，你可以使用一个运行一个报告主机文件系统安全问题的巧妙工具的镜像，而无需在主机上安装它。
- en: '|  |'
  id: totrans-1066
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Warning
  id: totrans-1067
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 警告
- en: As the preceding discussion implies, using these flags opens you up to more
    security risks. In security terms, using them should be considered equivalent
    to running with the `--privileged` flag.
  id: totrans-1068
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述的讨论所暗示的，使用这些标志会使你面临更多的安全风险。在安全术语中，使用它们应被视为与使用`--privileged`标志运行等效。
- en: '|  |'
  id: totrans-1069
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**DISCUSSION**'
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
  zh: '**讨论**'
- en: In this technique you’ve learned how to bypass Docker’s abstractions within
    the container. Disabling these can give you speedups or other conveniences to
    make Docker better serve your needs. One variant we’ve used in the past is to
    install networking tools (perhaps like tcpflow, mentioned in [technique 112](#ch16sb05))
    inside a container and expose host network interfaces. This lets you experiment
    with different tools on a temporary basis without having to install them.
  id: totrans-1071
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个技术中，你已经学会了如何在容器内绕过Docker的抽象。禁用这些功能可以给你带来速度提升或其他便利，使Docker更好地满足你的需求。我们过去使用的一个变体是在容器内安装网络工具（例如，像在技术112中提到的tcpflow）并暴露主机网络接口。这让你可以临时尝试不同的工具，而无需安装它们。
- en: The next technique looks at how you can bypass a restriction of Docker’s underlying
    disk storage.
  id: totrans-1072
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个技术将探讨如何绕过Docker底层磁盘存储的限制。
- en: '|  |'
  id: totrans-1073
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-1074
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Disabling the OOM killer**'
  id: totrans-1075
  prefs: []
  type: TYPE_NORMAL
  zh: '**禁用OOM杀手**'
- en: The “OOM killer” sounds like a bad horror film or severe disease, but it is
    in fact a thread within the Linux operating system kernel that decides what to
    do when the host is running out of memory. After the operating system has run
    out of hardware memory, used up any available swap space, and removed any cached
    files out of memory, it invokes the OOM killer to decide which processes should
    be killed off.
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
  zh: “OOM杀手”听起来像一部糟糕的恐怖电影或严重的疾病，但实际上它是Linux操作系统内核中的一个线程，当宿主机内存不足时，它决定要做什么。在操作系统耗尽硬件内存、用尽所有可用的交换空间以及从内存中移除所有缓存文件后，它将调用OOM杀手来决定哪些进程应该被终止。
- en: '**PROBLEM**'
  id: totrans-1077
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: You want to prevent containers from being killed by the OOM killer.
  id: totrans-1078
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要防止容器被OOM杀手杀死。
- en: '**SOLUTION**'
  id: totrans-1079
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: Use the `--oom-kill-disable` flag when starting your container.
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
  zh: 在启动容器时使用`--oom-kill-disable`标志。
- en: Solving this challenge is as simple as adding a flag to your Docker container.
    But as is often the case, the full story isn’t that simple.
  id: totrans-1081
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个挑战就像给你的Docker容器添加一个标志一样简单。但正如通常情况那样，整个故事并不那么简单。
- en: 'The following listing shows how you disable the OOM killer for a container:'
  id: totrans-1082
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的列表显示了如何禁用容器的OOM杀手：
- en: Listing 16.1\. `--oom-kill-disable` shows a Warning
  id: totrans-1083
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表16.1. `--oom-kill-disable`显示警告
- en: '[PRE72]'
  id: totrans-1084
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '***1*** **The --oom-kill-disable flag is added to a normal docker run command.**'
  id: totrans-1085
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **将--oom-kill-disable标志添加到正常的docker run命令中。**'
- en: '***2*** **A warning is output regarding another flag that might be set.**'
  id: totrans-1086
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **输出有关可能设置的另一个标志的警告。**'
- en: The warning you see is important. It tells you that running with this setting
    is dangerous, but it doesn’t tell you why. It’s dangerous to set this option because
    if your host runs out of memory, the operating system will kill all other user
    processes before yours.
  id: totrans-1087
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到的警告很重要。它告诉你使用此设置是危险的，但它没有告诉你原因。设置此选项是危险的，因为如果宿主机的内存耗尽，操作系统将在你的进程之前杀死所有其他用户进程。
- en: Sometimes that’s desirable, such as if you have a critical piece of infrastructure
    you want to protect from failure—maybe an audit or logging process that runs across
    (or for) all containers on the host. Even then, you’ll want to think twice about
    how disruptive this will be to your environment. For example, your container might
    depend on other running infrastructure on the same host. If you’re running on
    a container platform like OpenShift, your container will survive even as key platform
    processes are killed off. You’d likely want that key infrastructure to stay up
    before that container.
  id: totrans-1088
  prefs: []
  type: TYPE_NORMAL
  zh: 有时这是可取的，例如，如果您有一项关键的基础设施需要保护免受故障的影响——可能是一个跨（或为）主机上所有容器运行的审计或日志记录过程。即使如此，您也可能会想两次考虑这将对您的环境造成多大的干扰。例如，您的容器可能依赖于同一主机上运行的其他基础设施。如果您在
    OpenShift 这样的容器平台上运行，即使关键平台进程被杀死，您的容器也能幸存。您可能希望在该容器之前让关键基础设施保持运行。
- en: Listing 16.2\. `--oom-kill-disable` without a Warning
  id: totrans-1089
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 16.2\. `--oom-kill-disable` 没有警告
- en: '[PRE73]'
  id: totrans-1090
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '***1*** **The --memory flag is added to a normal docker run command.**'
  id: totrans-1091
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **将 --memory 标志添加到正常的 docker run 命令中。**'
- en: '***2*** **This time, no warning is seen.**'
  id: totrans-1092
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **这次，没有看到警告。**'
- en: '|  |'
  id: totrans-1093
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Note
  id: totrans-1094
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: The minimum amount of memory you can allocate is 4M, where the “M” stands for
    megabytes. You can also allocate by “G” for gigabytes.
  id: totrans-1095
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以分配的最小内存量是 4M，其中“M”代表兆字节。您也可以按“G”分配千兆字节。
- en: '|  |'
  id: totrans-1096
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 'You may be wondering how to tell whether your container was killed by the OOM
    killer. This is easily done by using the `docker inspect` command:'
  id: totrans-1097
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想知道如何判断您的容器是否被 OOM 杀手杀死。这可以通过使用 `docker inspect` 命令轻松完成：
- en: Listing 16.3\. Determining whether your container was “OOM-killed”
  id: totrans-1098
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表 16.3\. 判断您的容器是否被“OOM-killed”
- en: '[PRE74]'
  id: totrans-1099
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: This command outputs information about why the container was killed, including
    whether the OOM killer killed it.
  id: totrans-1100
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令输出容器被杀死的详细信息，包括是否由 OOM 杀手将其杀死。
- en: '**DISCUSSION**'
  id: totrans-1101
  prefs: []
  type: TYPE_NORMAL
  zh: '**讨论**'
- en: The OOM killer doesn’t require extended privileges to be set in a container,
    nor does it require you to be the root user—all you need is access to the `docker`
    command. This is yet another reason to be wary of giving unprivileged users access
    to the `docker` command without trusting them with root (see [chapter 14](kindle_split_027.xhtml#ch14)
    on security).
  id: totrans-1102
  prefs: []
  type: TYPE_NORMAL
  zh: OOM 杀手不需要在容器中设置扩展权限，也不需要您是 root 用户——您只需要访问 `docker` 命令。这是又一个要小心不要在不信任用户拥有 root
    权限的情况下给予他们 `docker` 命令访问权限的理由（参见第 14 章[关于安全](kindle_split_027.xhtml#ch14)）。
- en: This is not only a security risk, but a stability risk too. If a user can run
    `docker`, they could run a process that gradually leaks memory (common in many
    production environments). If no boundaries are put on that memory, the operating
    system will step in once its options are exhausted and kill off the user process
    with the largest memory usage first (this is a simplification of the Linux OOM-killer
    algorithm, which has been battle-tested and grown over years). If the container
    has been started with the OOM killer disabled, however, it could trample over
    all containers on the host, causing far more destruction and instability for its
    users.
  id: totrans-1103
  prefs: []
  type: TYPE_NORMAL
  zh: 这不仅是一个安全风险，也是一个稳定性风险。如果用户可以运行 `docker`，他们可以运行一个逐渐泄漏内存的过程（这在许多生产环境中很常见）。如果没有对内存设置边界，操作系统将在选项耗尽后介入，并首先杀死内存使用量最大的用户进程（这是对
    Linux OOM-killer 算法的简化，该算法经过多年的实战检验并不断完善）。然而，如果容器是以禁用 OOM 杀手的方式启动的，它可能会破坏主机上的所有容器，给用户造成更大的破坏和不稳定。
- en: For a more fine-grained approach to memory management, you can adjust the container’s
    “OOM score” with the `--oom-score-adj` flag. Another approach that may suit your
    purposes is to disable memory overcommit in the kernel. This has the effect of
    switching off the OOM killer globally, as memory is only granted if it’s definitely
    available. However, this could limit the number of containers that can run on
    your hosts, which could also be undesirable.
  id: totrans-1104
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更精细的内存管理方法，您可以使用 `--oom-score-adj` 标志调整容器的“OOM 分数”。另一种可能适合您的方法是在内核中禁用内存过载提交。这将全局关闭
    OOM 杀手，因为只有当内存确实可用时才会分配内存。然而，这可能会限制您主机上可以运行的容器数量，这也可能是不希望的。
- en: As always, performance management is an art!
  id: totrans-1105
  prefs: []
  type: TYPE_NORMAL
  zh: 正如往常一样，性能管理是一门艺术！
- en: '|  |'
  id: totrans-1106
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: 16.2\. When containers leak—debugging Docker
  id: totrans-1107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 16.2\. 当容器泄漏时——调试 Docker
- en: In this section we’ll cover some techniques that will help you understand and
    fix issues with applications running in Docker containers. We’ll cover how to
    jump into a container’s network while using tools from your host to debug issues,
    and we’ll look at an alternative that avoids container manipulation by monitoring
    network interfaces directly.
  id: totrans-1108
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍一些技术，帮助你理解和修复在Docker容器中运行的应用程序的问题。我们将介绍如何在使用主机工具调试问题时跳入容器的网络，并查看一个直接监控网络接口以避免容器操作的选择方案。
- en: Finally, we’ll demonstrate how the Docker abstraction can break down, leading
    to containers working on one host and not another, and how to debug this on live
    systems.
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将演示Docker抽象如何崩溃，导致容器在一个主机上工作而在另一个主机上不工作，以及如何在实时系统上调试这个问题。
- en: '|  |'
  id: totrans-1110
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Debugging a container’s network with nsenter**'
  id: totrans-1111
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用nsenter调试容器的网络**'
- en: In an ideal world, you’d be able to use socat (see [technique 4](kindle_split_011.xhtml#ch02sb05))
    in an *ambassador container* to diagnose issues with container communication.
    You’d start the extra container and make sure connections go to this new container,
    which acts as a proxy. The proxy allows you to diagnose and monitor the connections,
    and it then forwards them to the right place. Unfortunately it’s not always convenient
    (or possible) to set up a container like this only for debugging purposes.
  id: totrans-1112
  prefs: []
  type: TYPE_NORMAL
  zh: 在理想的世界里，你可以在*大使容器*中使用socat（见[技术4](kindle_split_011.xhtml#ch02sb05)）来诊断容器通信的问题。你会启动额外的容器，并确保连接到这个新的容器，它充当代理。代理允许你诊断和监控连接，然后将它们转发到正确的位置。不幸的是，仅为了调试目的设置这样的容器并不总是方便（或可能）。
- en: '|  |'
  id: totrans-1113
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-1114
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: See [technique 74](kindle_split_020.xhtml#ch09sb06) for a description of the
    ambassador pattern.
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
  zh: 有关大使模式的描述，请参阅[技术74](kindle_split_020.xhtml#ch09sb06)。
- en: '|  |'
  id: totrans-1116
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: You’ve already read about `docker exec` in [techniques 15](kindle_split_013.xhtml#ch03sb06)
    and [19](kindle_split_013.xhtml#ch03sb10). This technique discusses *nsenter*,
    a tool that looks similar but allows you to use tools from your machine inside
    the container, rather than being limited to what the container has installed.
  id: totrans-1117
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经在[技术15](kindle_split_013.xhtml#ch03sb06)和[19](kindle_split_013.xhtml#ch03sb10)中阅读了关于`docker
    exec`的内容。这项技术讨论了*nsenter*，这是一个看起来相似的工具，但它允许你在容器内部使用来自你机器的工具，而不是仅限于容器安装的工具。
- en: '**PROBLEM**'
  id: totrans-1118
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: You want to debug a network problem in a container, but the tools aren’t in
    the container.
  id: totrans-1119
  prefs: []
  type: TYPE_NORMAL
  zh: 你想在容器中调试一个网络问题，但工具不在容器中。
- en: '**SOLUTION**'
  id: totrans-1120
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: Use nsenter to jump into the container’s network but retain your host’s tooling.
  id: totrans-1121
  prefs: []
  type: TYPE_NORMAL
  zh: 使用nsenter跳入容器的网络，但保留主机的工具。
- en: 'If you don’t already have nsenter available on your Docker host, you can build
    it with the following command:'
  id: totrans-1122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经在你的Docker主机上安装了nsenter，你可以使用以下命令构建它：
- en: '[PRE75]'
  id: totrans-1123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: This will install nsenter in /usr/local/bin, and you’ll be able to use it immediately.
    nsenter might also be available in your distro (in the util-linux package).
  id: totrans-1124
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在/usr/local/bin中安装nsenter，你将能够立即使用它。nsenter也可能在你的发行版（util-linux包）中可用。
- en: 'You may have noticed by now that the generally useful BusyBox image doesn’t
    come with bash by default. As a demo of nsenter, we’re going to show how you can
    enter a BusyBox container with your host’s bash program:'
  id: totrans-1125
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你可能已经注意到，通常有用的BusyBox镜像默认不包含bash。作为nsenter的演示，我们将展示如何使用主机的bash程序进入BusyBox容器：
- en: '[PRE76]'
  id: totrans-1126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '***1*** **Starts up a BusyBox container and saves the container ID (CID)**'
  id: totrans-1127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **启动BusyBox容器并保存容器ID (CID)**'
- en: '***2*** **Inspects the container, extracting the process ID (PID) (see [technique
    30](kindle_split_015.xhtml#ch05sb03))**'
  id: totrans-1128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **检查容器，提取进程ID (PID)（见[技术30](kindle_split_015.xhtml#ch05sb03)）**'
- en: '***3*** **Runs nsenter, specifying the container to enter with the --target
    flag. The “sudo” may not be required.**'
  id: totrans-1129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **运行nsenter，使用--target标志指定要进入的容器。可能不需要“sudo”。**'
- en: '***4*** **Specifies the namespaces of the container to enter with the remaining
    flags**'
  id: totrans-1130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **使用剩余的标志指定要进入的容器的命名空间**'
- en: See [technique 109](#ch16sb02) for more detail on namespaces that nsenter understands.
    The critical point in the selection of namespaces is that you don’t use the `--mount`
    flag, which would use the container’s filesystem, because bash wouldn’t be available.
    /bin/bash is specified as the executable to start.
  id: totrans-1131
  prefs: []
  type: TYPE_NORMAL
  zh: 有关nsenter理解的命名空间的更多详细信息，请参阅[技术109](#ch16sb02)。在命名空间选择的关键点是不要使用`--mount`标志，因为这会使用容器的文件系统，因为bash将不可用。/bin/bash被指定为要启动的可执行文件。
- en: It should be pointed out that you don’t get direct access to the container’s
    filesystem, but you do get all the tools your host has.
  id: totrans-1132
  prefs: []
  type: TYPE_NORMAL
  zh: 应该指出的是，你无法直接访问容器的文件系统，但你确实拥有主机上的所有工具。
- en: Something that we’ve needed before is a way to find out which veth interface
    device on the host corresponds to which container. For example, sometimes it’s
    desirable to quickly knock a container off the network. An unprivileged container
    can’t bring a network interface down, so you need to do it from the host by finding
    out the veth interface name.
  id: totrans-1133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前需要的是一种方法来找出主机上的哪个 veth 接口设备对应于哪个容器。例如，有时快速将容器从网络上移除是有用的。无权限的容器无法关闭网络接口，因此你需要从主机通过找出
    veth 接口名称来完成此操作。
- en: '[PRE77]'
  id: totrans-1134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '***1*** **Verifies that attempting to ping from inside a new container succeeds**'
  id: totrans-1135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **验证从新容器内部尝试 ping 是否成功**'
- en: '***2*** **We’re unable to bring an interface in the container down. Note that
    your interface may not be eth0, so if this doesn’t work, you may wish to use ip
    addr to find out your principal interface name.**'
  id: totrans-1136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **无法将容器中的接口关闭。请注意，你的接口可能不是 eth0，如果这不起作用，你可能希望使用 ip addr 来找出你的主要接口名称。**'
- en: '***3*** **Enters into the network space of the container, using the ethtool
    command from the host to look up the peer interface index—the other end of the
    virtual interface**'
  id: totrans-1137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **进入容器的网络空间，使用主机上的 ethtool 命令查找对端接口索引——虚拟接口的另一端**'
- en: '***4*** **Looks through the list of interfaces on the host to find the appropriate
    veth interface for the container**'
  id: totrans-1138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **在主机上的接口列表中查找适合容器的适当 veth 接口**'
- en: '***5*** **Brings down the virtual interface**'
  id: totrans-1139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** **关闭虚拟接口**'
- en: '***6*** **Verifies that attempting to ping from inside the container fails**'
  id: totrans-1140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6*** **验证从容器内部尝试 ping 是否失败**'
- en: One final example of a program you might want to use from within a container
    is tcpdump, a tool that records all TCP packets on a network interface. To use
    it, you need to run `nsenter` with the `--net` command, allowing you to “see”
    the container’s network from the host and therefore monitor the packets with tcpdump.
  id: totrans-1141
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还想在容器内部使用的一个程序示例是 tcpdump，这是一个记录网络接口上所有 TCP 数据包的工具。要使用它，你需要运行带有 `--net` 命令的
    `nsenter`，这样你就可以从主机“看到”容器的网络，因此可以使用 tcpdump 监控数据包。
- en: 'For example, the `tcpdump` command in the following code records all packets
    to the /tmp/google.tcpdump file (we assume you’re still in the nsenter session
    you started previously). Some network traffic is then triggered by retrieving
    a web page:'
  id: totrans-1142
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下代码中的 `tcpdump` 命令将所有数据包记录到 `/tmp/google.tcpdump` 文件中（我们假设你仍然处于之前启动的 nsenter
    会话中）。然后通过检索网页来触发一些网络流量：
- en: '[PRE78]'
  id: totrans-1143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '|  |'
  id: totrans-1144
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-1145
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: Depending on your network setup, you may need to temporarily change your resolv.conf
    file to allow the DNS lookup to work. If you get a “Temporary failure in name
    resolution” error, try adding the line `nameserver 8.8.8.8` to the top of your
    /etc/resolv.conf file. Don’t forget to revert it when you’re finished.
  id: totrans-1146
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的网络设置，你可能需要暂时更改你的 resolv.conf 文件以允许 DNS 查询工作。如果你收到“名称解析临时失败”错误，请尝试将 `nameserver
    8.8.8.8` 行添加到你的 /etc/resolv.conf 文件顶部。完成操作后，别忘了恢复。
- en: '|  |'
  id: totrans-1147
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**DISCUSSION**'
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
  zh: '**讨论**'
- en: This technique gives you a way to quickly alter the network behavior of containers
    without having to settle down with any of the tools from [chapter 10](kindle_split_021.xhtml#ch10)
    ([techniques 78](kindle_split_021.xhtml#ch10sb04) and [79](kindle_split_021.xhtml#ch10sb05))
    to simulate network breakage.
  id: totrans-1149
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术为你提供了一种快速更改容器网络行为的方法，而无需使用第 10 章中提到的任何工具（技术 78 和 79）来模拟网络故障。
- en: You’ve also seen a compelling use case for Docker—it’s much easier to debug
    network issues in the isolated network environment Docker provides than to do
    it in an uncontrolled environment. Trying to remember the correct arguments for
    tcpdump to appropriately filter out irrelevant packets in the middle of the night
    is an error-prone process. Using nsenter, you can forget about that and capture
    everything within the container, without tcpdump being installed (or having to
    install it) on the image.
  id: totrans-1150
  prefs: []
  type: TYPE_NORMAL
  zh: 你也看到了 Docker 的一个令人信服的使用案例——在 Docker 提供的隔离网络环境中调试网络问题比在不受控制的环境中更容易。在深夜试图记住 tcpdump
    的正确参数以适当过滤掉无关数据包是一个容易出错的过程。使用 nsenter，你可以忘记这一点，并捕获容器内的所有内容，而无需在镜像上安装（或必须安装）tcpdump。
- en: '|  |'
  id: totrans-1151
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-1152
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Using tcpflow to debug in flight without reconfiguring**'
  id: totrans-1153
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用 tcpflow 在不重新配置的情况下进行调试**'
- en: tcpdump is the de facto standard in network investigation, and it’s likely the
    first tool most people reach for if asked to dive into debugging a network issue.
  id: totrans-1154
  prefs: []
  type: TYPE_NORMAL
  zh: tcpdump 是网络调查的事实标准，并且很可能是当被要求深入调试网络问题时，大多数人首先会使用的工具。
- en: But tcpdump is typically used for displaying packet summaries and examining
    packet headers and protocol information—it’s not quite as full featured for displaying
    the application-level data flow between two programs. This can be quite important
    when investigating issues with two applications communicating.
  id: totrans-1155
  prefs: []
  type: TYPE_NORMAL
  zh: 但 tcpdump 通常用于显示数据包摘要和检查数据包头部和协议信息——它并不是特别适合显示两个程序之间的应用程序级数据流。当调查两个应用程序通信的问题时，这可能会非常重要。
- en: '**PROBLEM**'
  id: totrans-1156
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: You need to monitor the communication data of a containerized application.
  id: totrans-1157
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要监控容器化应用程序的通信数据。
- en: '**SOLUTION**'
  id: totrans-1158
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: Use tcpflow to capture traffic crossing an interface.
  id: totrans-1159
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 tcpflow 捕获跨越接口的流量。
- en: 'tcpflow is similar to tcpdump (accepting the same pattern-matching expressions)
    but it’s designed to give you better insight into application data flows. tcpflow
    may be available from your system package manager, but, if not, we’ve prepared
    a Docker image you can use which should be virtually identical in functionality
    to an equivalent package manager install:'
  id: totrans-1160
  prefs: []
  type: TYPE_NORMAL
  zh: tcpflow 与 tcpdump 类似（接受相同的模式匹配表达式），但它旨在让你更好地了解应用程序数据流。tcpflow 可能可以从你的系统包管理器中获取，如果没有，我们已准备了一个你可以使用的
    Docker 镜像，其功能应与等效包管理器安装几乎相同：
- en: '[PRE79]'
  id: totrans-1161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'There are two ways you can use tcpflow with Docker: point it at the `docker0`
    interface and use a packet-filtering expression to retrieve only the packets you
    want, or use the trick from the previous technique to find the veth interface
    for the container you’re interested in, and capture on that.'
  id: totrans-1162
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用两种方式与 Docker 一起使用 tcpflow：将其指向 `docker0` 接口，并使用数据包过滤表达式仅检索你想要的包，或者使用前一种技术中的技巧来找到你感兴趣的容器的
    veth 接口，并在该接口上捕获。
- en: '|  |'
  id: totrans-1163
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Tip
  id: totrans-1164
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 提示
- en: You may wish to refer to [figure 10.2](kindle_split_021.xhtml#ch10fig02) in
    [chapter 10](kindle_split_021.xhtml#ch10) to refresh your memory on how network
    traffic flows inside Docker and see why capturing on `docker0` will capture container
    traffic.
  id: totrans-1165
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望参考 [第 10 章 10.2 图](kindle_split_021.xhtml#ch10fig02) 来刷新你对 Docker 内部网络流量流动的记忆，并了解为什么在
    `docker0` 上捕获会捕获容器流量。
- en: '|  |'
  id: totrans-1166
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Expression filtering is a powerful feature of tcpflow to use after attaching
    to an interface, letting you drill down to the traffic you’re interested in. We’ll
    show a simple example to get you started:'
  id: totrans-1167
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式过滤是 tcpflow 在连接到接口后使用的一个强大功能，让你可以深入到你感兴趣的流量。我们将展示一个简单的示例来帮助你入门：
- en: '[PRE80]'
  id: totrans-1168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'In the preceding example, you ask tcpflow to print a colorized stream of any
    traffic going to or from your container with a source or destination port of 80
    (generally used for HTTP traffic). You can now try this by retrieving a web page
    in the container in a new terminal:'
  id: totrans-1169
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，你要求 tcpflow 打印任何流向或来自你的容器且源或目标端口为 80（通常用于 HTTP 流量）的彩色流。你现在可以通过在新终端中检索容器中的网页来尝试这个操作：
- en: '[PRE81]'
  id: totrans-1170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'You’ll see colorized output in the tcpflow terminal. The cumulative output
    of the command so far will look something like this:'
  id: totrans-1171
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在 tcpflow 终端中看到彩色输出。到目前为止命令的累积输出将类似于以下内容：
- en: '[PRE82]'
  id: totrans-1172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '***1*** **Blue coloring starts**'
  id: totrans-1173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **蓝色着色开始**'
- en: '***2*** **Red coloring starts**'
  id: totrans-1174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **红色着色开始**'
- en: '**DISCUSSION**'
  id: totrans-1175
  prefs: []
  type: TYPE_NORMAL
  zh: '**讨论**'
- en: tcpflow is an excellent addition to your toolbox, given how unobtrusive it is.
    You can start it against long-running containers to get a bit of insight into
    what they’re transferring right now, or use it alongside tcpdump (the previous
    technique) to get a more complete picture of the kind of requests your application
    makes and what information is transferred.
  id: totrans-1176
  prefs: []
  type: TYPE_NORMAL
  zh: tcpflow 是你工具箱的一个很好的补充，因为它非常不引人注目。你可以针对长时间运行的容器启动它，以获得它们现在正在传输的内容的一些洞察，或者与 tcpdump（前一种技术）一起使用，以获得你应用程序发出的请求类型和传输的信息的更完整视图。
- en: As well as tcpdump, the previous technique also covers using nsenter to monitor
    traffic on just one container rather than all of them (which is what monitoring
    docker0 will do).
  id: totrans-1177
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 tcpdump，前一种技术还涵盖了使用 nsenter 来监控单个容器上的流量，而不是所有容器（这是监控 docker0 会做的事情）。
- en: '|  |'
  id: totrans-1178
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-1179
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Debugging containers that fail on specific hosts**'
  id: totrans-1180
  prefs: []
  type: TYPE_NORMAL
  zh: '**调试特定主机上失败的容器**'
- en: The previous two techniques have shown how you can start investigating issues
    caused by the interaction between your containers and other locations (whether
    those “other locations” are more containers, or third parties on the internet).
  id: totrans-1181
  prefs: []
  type: TYPE_NORMAL
  zh: 前两种技术已经展示了你可以如何开始调查由你的容器与其他位置（无论是更多容器还是互联网上的第三方）之间的交互引起的问题。
- en: If you’ve isolated a problem to one host, and you’re sure that external interaction
    isn’t the cause, the next step should be to try reducing the number of moving
    parts (removing volumes and ports) and to check the details of the host itself
    (free disk space, number of open file descriptors, and so on). It’s probably also
    worth checking that each host is on the latest version of Docker.
  id: totrans-1182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经将问题隔离到一个主机上，并且确信外部交互不是原因，下一步应该尝试减少可移动部件的数量（移除卷和端口）并检查主机本身的详细信息（可用磁盘空间、打开的文件描述符数量等）。也许还值得检查每个主机是否运行了Docker的最新版本。
- en: In some cases, none of the above will help—you’ve got an image you can run with
    no arguments (such as `docker run imagename`) which should be perfectly contained,
    yet it runs differently on different hosts.
  id: totrans-1183
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，上述方法都无济于事——你有一个可以不带参数运行（例如 `docker run imagename`）的镜像，它应该被完美地隔离，但在不同的主机上运行时却有所不同。
- en: '**PROBLEM**'
  id: totrans-1184
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: You want to determine why a particular action within a container isn’t working
    on a particular host.
  id: totrans-1185
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要确定为什么容器内的特定操作在特定主机上不起作用。
- en: '**SOLUTION**'
  id: totrans-1186
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: Strace the process to see what system calls it’s making, and compare that to
    a working system.
  id: totrans-1187
  prefs: []
  type: TYPE_NORMAL
  zh: 使用strace跟踪进程以查看它正在执行哪些系统调用，并将其与正常工作的系统进行比较。
- en: Although Docker’s stated aim is to allow users to “run any app anywhere,” the
    means by which it tries to achieve this aren’t always foolproof.
  id: totrans-1188
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Docker声明的目标是让用户“在任何地方运行任何应用”，但它试图实现这一目标的手段并不总是万无一失。
- en: Docker treats the Linux kernel API as its *host* (the environment in which it
    can run). When they first learn how Docker works, many people ask how Docker handles
    changes to the Linux API. As far as we’re aware, it doesn’t yet. Fortunately,
    the Linux API is backwards-compatible, but it’s not difficult to imagine a scenario
    in the future where a *new* Linux API call is created and used by a Dockerized
    application, and for that app to then be deployed to a kernel recent enough to
    run Docker but old enough to not support that particular API call.
  id: totrans-1189
  prefs: []
  type: TYPE_NORMAL
  zh: Docker将Linux内核API视为其*宿主*（它可以在其中运行的环境）。当人们刚开始学习Docker的工作原理时，很多人会问Docker如何处理Linux
    API的变化。据我们所知，它还没有这样做。幸运的是，Linux API是向后兼容的，但可以想象，在未来某个时候，可能会创建一个新的Linux API调用，并被Docker化的应用程序使用，然后该应用程序被部署到一个足够新以运行Docker但旧到不支持该特定API调用的内核上。
- en: '|  |'
  id: totrans-1190
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-1191
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: You may think that the Linux kernel API changing is something of a theoretical
    problem, but we came across this scenario while writing the first edition of this
    book. A project we were working on used the `memfd_create` Linux system call,
    which only exists on kernels versioned 3.17 and above. Because some hosts we were
    working on had older kernels, our containers failed on some systems and worked
    on others.
  id: totrans-1192
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为Linux内核API的变化是一个理论上的问题，但我们在编写这本书的第一版时遇到了这种情况。我们正在开发的一个项目使用了`memfd_create`
    Linux系统调用，它只存在于版本3.17及以上的内核中。因为一些我们正在工作的主机有较旧的内核，我们的容器在一些系统上失败，而在其他系统上则工作正常。
- en: '|  |'
  id: totrans-1193
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: That scenario is not the only way in which the Docker abstraction can fail.
    Containers can fail on particular kernels because assumptions may be made by the
    application about files on the host. Although rare, it does happen, and it’s important
    to be alert to that risk.
  id: totrans-1194
  prefs: []
  type: TYPE_NORMAL
  zh: 那种场景并不是Docker抽象失败的唯一方式。容器可能会因为应用程序对主机上的文件所做的假设而失败。虽然这种情况很少见，但它确实会发生，因此重要的是要警惕这种风险。
- en: '**SELinux interference with containers**'
  id: totrans-1195
  prefs: []
  type: TYPE_NORMAL
  zh: '**SELinux对容器的干扰**'
- en: An example of where the Docker abstraction can break down is with anything that
    interacts with SELinux. As discussed in [chapter 14](kindle_split_027.xhtml#ch14),
    SELinux is a layer of security implemented in the kernel that works outside the
    normal user permissions.
  id: totrans-1196
  prefs: []
  type: TYPE_NORMAL
  zh: Docker抽象可能崩溃的一个例子是与SELinux交互的任何内容。如第14章[讨论](kindle_split_027.xhtml#ch14)所述，SELinux是在内核中实现的一层安全机制，它工作在正常用户权限之外。
- en: Docker uses this layer to allow container security to be tightened up by managing
    what actions can be performed from within a container. For example, if you’re
    root within a container, you’re the same user as root on the host. Although it’s
    hard to break out of the container so you obtain root on the host, it’s not impossible;
    exploits have been found, and others may exist that the community is unaware of.
    What SELinux can do is provide another layer of protection so that even if a root
    user breaks out of the container to the host, there are limits on what actions
    they can perform on the host.
  id: totrans-1197
  prefs: []
  type: TYPE_NORMAL
  zh: Docker使用这一层来允许通过管理容器内可以执行的操作来加强容器安全性。例如，如果您在容器内是root用户，您与主机上的root用户是相同的用户。尽管很难突破容器以获得主机上的root权限，但这并非不可能；已经发现了漏洞，可能还有社区尚未知晓的其他漏洞。SELinux可以做到的是提供另一层保护，即使root用户从容器突破到主机，他们可以在主机上执行的操作也有限制。
- en: So far so good, but the problem for Docker is that SELinux is implemented on
    the host, and not within the container. This means that programs running in containers
    that query the status of SELinux and find it enabled might make certain assumptions
    about the environment in which they run, and fail in unexpected ways if these
    expectations aren’t met.
  id: totrans-1198
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止一切顺利，但Docker的问题在于SELinux是在主机上实现的，而不是在容器内。这意味着在容器中运行的程序查询SELinux的状态并发现它已启用时，可能会对其运行的环境做出某些假设，如果这些期望没有得到满足，可能会以意想不到的方式失败。
- en: 'In the following example, we’re running a CentOS 7 Vagrant machine with Docker
    installed, and within that an Ubuntu 12.04 container. If we run a fairly straightforward
    command to add a user, the exit code is 12, indicating an error, and indeed the
    user has not been created:'
  id: totrans-1199
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们正在运行一个安装了Docker的CentOS 7 Vagrant虚拟机，并在其中运行一个Ubuntu 12.04容器。如果我们运行一个相当直接的命令来添加用户，退出代码是12，表示错误，并且确实用户没有被创建：
- en: '[PRE83]'
  id: totrans-1200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: The same command run on an ubuntu:14.04 container works just fine. If you want
    to try to reproduce this result, you’ll need a CentOS 7 machine (or similar).
    But for learning purposes, following the rest of the technique with any command
    and container will be sufficient.
  id: totrans-1201
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ubuntu:14.04`容器上运行的相同命令工作正常。如果您想尝试重现此结果，您需要一个CentOS 7机器（或类似）。但为了学习目的，使用任何命令和容器遵循其余的技术将足够。
- en: '|  |'
  id: totrans-1202
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Tip
  id: totrans-1203
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 小贴士
- en: In bash, `$?` gives you the exit code of the last-run command. The meaning of
    the exit code varies from command to command, but typically an exit code of 0
    means the call was successful, and a nonzero code indicates an error or exceptional
    condition of some kind.
  id: totrans-1204
  prefs: []
  type: TYPE_NORMAL
  zh: 在bash中，`$?`会给你上一个运行的命令的退出代码。退出代码的含义因命令而异，但通常退出代码为0表示调用成功，非零代码表示错误或某种异常情况。
- en: '|  |'
  id: totrans-1205
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '**Debugging Linux API calls**'
  id: totrans-1206
  prefs: []
  type: TYPE_NORMAL
  zh: '**调试Linux API调用**'
- en: Because we know that the likely difference between the containers is due to
    differences between the kernel APIs running on the hosts, strace can help you
    determine the differences between calls to the kernel API.
  id: totrans-1207
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们知道容器之间可能存在的差异是由于主机上运行的内核API之间的差异，strace可以帮助您确定对内核API的调用之间的差异。
- en: strace is a tool that allows you to snoop on the calls made to the Linux API
    by a process (a.k.a. system calls). It’s an extremely useful debugging and educational
    tool. You can see how it works in [figure 16.2](#ch16fig02).
  id: totrans-1208
  prefs: []
  type: TYPE_NORMAL
  zh: strace是一个允许您监视进程（即系统调用）对Linux API进行的调用的工具。它是一个极其有用的调试和教育工具。您可以在[图16.2](#ch16fig02)中看到它是如何工作的。
- en: Figure 16.2\. How strace works
  id: totrans-1209
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图16.2\. strace的工作原理
- en: '![](Images/16fig02.jpg)'
  id: totrans-1210
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/16fig02.jpg)'
- en: 'First, you need to install strace on your container using the appropriate package
    manager, and then run the command that differs, with the `strace` command prepended.
    Here’s some example output for the failed `useradd` call:'
  id: totrans-1211
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要使用适当的包管理器在容器上安装strace，然后运行不同的命令，并在前面加上`strace`命令。以下是失败的`useradd`调用的示例输出：
- en: '[PRE84]'
  id: totrans-1212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '***1*** **Runs strace on the command with the -f flag, which ensures that any
    process spawned by your command and any of its descendants are “followed” by strace**'
  id: totrans-1213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** **使用-f标志运行strace，这确保了您的命令所产生的过程及其任何后代都会被strace“跟随”**'
- en: '***2*** **Appends the command you want to debug to the strace invocation**'
  id: totrans-1214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** **将您要调试的命令附加到strace调用中**'
- en: '***3*** **Each line of the strace output starts with the Linux API call. The
    execve call here executes the command you gave strace. The 0 at the end is the
    return value from the call (successful).**'
  id: totrans-1215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** **strace输出的每一行都以Linux API调用开始。这里的execve调用执行您给strace的命令。最后的0是调用的返回值（成功）。**'
- en: '***4*** **The “open” system call opens a file for reading. The return value
    (9) is the file handle number used in subsequent calls to work on the file. In
    this case, the SELinux information is retrieved from the /proc filesystem, which
    holds information about running processes.**'
  id: totrans-1216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** **“open”系统调用打开一个文件以供读取。返回值（9）是后续调用中用于操作文件的文件句柄号。在这种情况下，SELinux信息是从/proc文件系统中检索的，该文件系统包含有关运行进程的信息。**'
- en: '***5*** **The “read” system call works on the previously opened file (with
    file descriptor 9) and returns the number of bytes read (46).**'
  id: totrans-1217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** **“read”系统调用作用于之前打开的文件（文件描述符为9），并返回读取的字节数（46）。**'
- en: '***6*** **The “close” system call closes the file referenced with the file
    descriptor number.**'
  id: totrans-1218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6*** **“close”系统调用关闭了由文件描述符引用的文件。**'
- en: '***7*** **The program attempts to open the SELinux files it expects to be there,
    but in each case fails. strace helpfully tells you what the return value means:
    “No such file or directory.”**'
  id: totrans-1219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7*** **程序尝试打开它期望存在的SELinux文件，但在每种情况下都失败了。strace有用地告诉你返回值的含义：“没有这样的文件或目录。”**'
- en: '***8*** **The process exits with the value 12, which for useradd means that
    the directory couldn’t be created.**'
  id: totrans-1220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8*** **进程以值12退出，对于useradd来说，这意味着目录无法创建。**'
- en: The preceding output may seem confusing at first, but after a few times it becomes
    relatively easy to read. Each line represents a call to the Linux kernel to perform
    some action in what’s known as *kernel space* (as opposed to *user space*, where
    actions are performed by programs without handing over responsibility to the kernel).
  id: totrans-1221
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，前面的输出可能看起来很令人困惑，但经过几次之后，它就变得相对容易阅读了。每一行代表对Linux内核的调用，以在所谓的*内核空间*（与*用户空间*相对，在用户空间中，操作由程序执行，而不将责任交给内核）执行某些操作。
- en: '|  |'
  id: totrans-1222
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-1223
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**提示**'
- en: If you want to learn more about a specific system call, you can run `man 2 callname`.
    You may need to install the man pages with `apt-get install manpages-dev` or a
    similar command for your packaging system. Alternatively, Googling “man 2 callname”
    will likely get you what you need.
  id: totrans-1224
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于特定系统调用的信息，你可以运行`man 2 callname`。你可能需要使用`apt-get install manpages-dev`或类似命令为你的包装系统安装man页面。或者，通过Google搜索“man
    2 callname”可能会得到你需要的信息。
- en: '|  |'
  id: totrans-1225
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: This is an example of where Docker’s abstractions break down. In this case,
    the action fails because the program expects SELinux files to be present, because
    SELinux appears to be enabled on the container, but the details of enforcement
    are kept on the host.
  id: totrans-1226
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是Docker的抽象崩溃的例子。在这种情况下，操作失败是因为程序期望SELinux文件存在，因为SELinux似乎在容器上被启用，但执行细节保留在宿主机上。
- en: '|  |'
  id: totrans-1227
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Tip
  id: totrans-1228
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: '**提示**'
- en: It’s incredibly useful to read over the `man 2` pages for all the system calls
    if you’re serious about being a developer. At first they might seem full of jargon
    you don’t understand, but as you read around the various subjects, you’ll learn
    a great deal about fundamental Linux concepts. At some point, you’ll start to
    see how most languages derive from this root, and some of their quirks and oddities
    will make more sense. Be patient, though, as you won’t understand it all immediately.
  id: totrans-1229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你认真对待成为一名开发者，阅读所有系统调用的`man 2`页面非常有用。一开始它们可能看起来充满了你不理解的术语，但随着你对各种主题的阅读，你会学到很多关于Linux基本概念的知识。在某个时候，你将开始了解大多数语言是如何从这个根源衍生出来的，它们的一些怪癖和奇怪之处将更有意义。但是要有耐心，因为你不会立即理解所有内容。
- en: '|  |'
  id: totrans-1230
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**DISCUSSION**'
  id: totrans-1231
  prefs: []
  type: TYPE_NORMAL
  zh: '**讨论**'
- en: Although such situations are rare, the ability to debug and understand how your
    program is interacting by using strace is an invaluable technique, not only with
    Docker but for more general development.
  id: totrans-1232
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种情况很少见，但使用strace进行调试和理解程序如何交互的能力是一种非常有价值的技巧，不仅适用于Docker，也适用于更广泛的开发生态。
- en: If you have very minimal Docker images, perhaps created by leveraging [technique
    57](kindle_split_017.xhtml#ch07sb10), and would prefer not to install strace on
    your container, it’s possible to use strace from your host. You’ll want to use
    `docker top <container_id>` to find the PID of the process in the container, and
    the `-p` argument to strace to attach to a specific running process. Don’t forget
    to use sudo. Attaching to a process potentially allows you to read its secrets,
    so it requires extra permissions.
  id: totrans-1233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你拥有非常小的Docker镜像，可能通过利用[技术57](kindle_split_017.xhtml#ch07sb10)创建，并且你不想在容器上安装strace，那么你可以使用宿主机的strace。你需要使用`docker
    top <container_id>`来找到容器中进程的PID，并使用strace的`-p`参数来附加到特定的运行进程。别忘了使用sudo。附加到进程可能允许你读取其秘密，因此需要额外的权限。
- en: '|  |'
  id: totrans-1234
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '|  |'
  id: totrans-1235
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: '**Extracting a file from an image**'
  id: totrans-1236
  prefs: []
  type: TYPE_NORMAL
  zh: '**从镜像中提取文件**'
- en: Copying a file from a container is easily achieved using the `docker cp` command.
    Not infrequently, you’ll want to extract a file from an image, but you don’t have
    a clean container running to copy from. In these cases, you can artificially run
    a container of the image, run `docker cp`, and then remove the container. This
    is already three commands, and you may run into trouble if, for example, the image
    has a default entrypoint that demands a meaningful argument.
  id: totrans-1237
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`docker cp`命令从容器中复制文件很容易实现。不经常地，你可能想要从一个镜像中提取文件，但你没有干净运行的容器来复制。在这些情况下，你可以人为地运行一个镜像的容器，运行`docker
    cp`，然后删除容器。这已经是三个命令了，如果你，例如，镜像有一个默认的entrypoint，它需要有效的参数，你可能会遇到麻烦。
- en: This technique gives you a single command alias that you can put into your shell
    startup scripts to do all this with one command and two arguments.
  id: totrans-1238
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术给你一个单一的命令别名，你可以将其放入你的shell启动脚本中，通过一个命令和两个参数完成所有这些操作。
- en: '**PROBLEM**'
  id: totrans-1239
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: You want to copy a file from an image to your host.
  id: totrans-1240
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要从镜像复制文件到你的主机。
- en: '**SOLUTION**'
  id: totrans-1241
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决方案**'
- en: Use an alias to run a container from the image with an entrypoint to `cat` the
    file’s contents to a file on the host.
  id: totrans-1242
  prefs: []
  type: TYPE_NORMAL
  zh: 使用别名从镜像中运行一个容器，并将entrypoint设置为将文件内容输出到主机上的文件。
- en: First we’ll show you how to construct a `docker run` command to extract a file
    from an image, and then you’ll see how to turn this into an alias for convenience.
  id: totrans-1243
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将向你展示如何构建一个`docker run`命令来从镜像中提取文件，然后你会看到如何将其转换为方便的别名。
- en: Listing 16.4\. Extracting a file from an image using `docker run`
  id: totrans-1244
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表16.4\. 使用`docker run`从镜像中提取文件
- en: '[PRE85]'
  id: totrans-1245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '***1*** **Uses the --rm flag to delete the container immediately on running
    this command**'
  id: totrans-1246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** 使用--rm标志在运行此命令后立即删除容器'
- en: '***2*** **Uses the -i flag to make the container interactive**'
  id: totrans-1247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** 使用-i标志使容器交互式'
- en: '***3*** **Uses the -t flag to give the container a virtual terminal to write
    to**'
  id: totrans-1248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***3*** 使用-t标志给容器提供一个虚拟终端来写入'
- en: '***4*** **Sets the entrypoint for the container to ‘cat’**'
  id: totrans-1249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***4*** 将容器的entrypoint设置为‘cat’'
- en: '***5*** **The name of the image you want to extract the file from**'
  id: totrans-1250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***5*** 你想要从其中提取文件的镜像名称'
- en: '***6*** **The filename to output**'
  id: totrans-1251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***6*** 输出的文件名'
- en: '***7*** **Redirects the contents of the file to a local file on the host**'
  id: totrans-1252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***7*** 将文件内容重定向到主机上的本地文件'
- en: '***8*** **To emphasize the point, we show that the /etc/os-release doesn’t
    exist on the host.**'
  id: totrans-1253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***8*** 为了强调这一点，我们展示了在主机上不存在`/etc/os-release`。'
- en: You might be wondering why we use `entrypoint` here, and don’t simply run the
    `cat` command to output the file. This is because some images will have set an
    entrypoint already. When this happens, docker would treat `cat` as the argument
    to the `entrypoint` command, resulting in behavior you wouldn’t want.
  id: totrans-1254
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道为什么在这里使用`entrypoint`，而不是简单地运行`cat`命令来输出文件。这是因为某些镜像已经设置了一个entrypoint。当这种情况发生时，Docker会将`cat`视为`entrypoint`命令的参数，从而导致你不希望的行为。
- en: For convenience, you might want to put this command into an alias.
  id: totrans-1255
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便，你可能想将此命令放入别名中。
- en: Listing 16.5\. Using an alias to extract a file from an image
  id: totrans-1256
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表16.5\. 使用别名从镜像中提取文件
- en: '[PRE86]'
  id: totrans-1257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '***1*** **Aliases the command to the name “imagecat”, containing everything
    in the command from [listing 16.4](#ch16ex04) up to the image and file arguments**'
  id: totrans-1258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***1*** 将命令别名设置为“imagecat”，包含从[列表16.4](#ch16ex04)到图像和文件参数的所有命令内容'
- en: '***2*** **Calls “imagecat” with the two arguments (image and filename)**'
  id: totrans-1259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***2*** 使用两个参数（图像和文件名）调用“imagecat”'
- en: This technique assumes the presence of `cat` in your containers. If you’ve been
    building minimal containers with [technique 58](kindle_split_017.xhtml#ch07sb11),
    this may not be the case, as only your binary is present in the container—there
    are no standard Linux tools.
  id: totrans-1260
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术假设你的容器中存在`cat`。如果你使用[技术58](kindle_split_017.xhtml#ch07sb11)构建了最小化容器，这可能不是情况，因为容器中只有你的二进制文件——没有标准Linux工具。
- en: If that’s the case, you’ll want to consider using `docker export` from [technique
    73](kindle_split_020.xhtml#ch09sb05), but rather than sending them to another
    machine, you can just extract the file you want from them. Bear in mind that a
    container doesn’t need to successfully start for you to export it—you can attempt
    to run it with a command that doesn’t exist inside the container and then export
    the stopped container (or just use `docker create`, which prepares a container
    for execution without starting it).
  id: totrans-1261
  prefs: []
  type: TYPE_NORMAL
  zh: '如果是这样的话，你可能想考虑使用[技术73](kindle_split_020.xhtml#ch09sb05)中的`docker export`，但不是将它们发送到另一台机器，而是可以直接从它们中提取你想要的文件。记住，容器不需要成功启动你才能导出它——你可以尝试使用容器内不存在的命令来运行它，然后导出停止的容器（或者直接使用`docker
    create`，它为执行准备容器而不启动它）。 '
- en: '|  |'
  id: totrans-1262
  prefs: []
  type: TYPE_TB
  zh: '|  |'
- en: Summary
  id: totrans-1263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: You can pass arguments to Docker to disable different kinds of isolation, either
    for greater flexibility of containers or for performance.
  id: totrans-1264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以向Docker传递参数来禁用不同类型的隔离，要么是为了提高容器的灵活性，要么是为了性能。
- en: You can disable the Linux OOM killer for individual containers to indicate that
    Linux should never try to reclaim limited memory by killing this process.
  id: totrans-1265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以禁用单个容器的Linux OOM杀手，以指示Linux永远不会通过杀死此进程来尝试回收有限的内存。
- en: nsenter can be used to get access to the network context of a container from
    the host.
  id: totrans-1266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: nsenter可以用来从主机获取容器的网络上下文。
- en: tcpflow allows you to monitor all traffic in and out of your containers without
    needing to reconfigure or restart anything.
  id: totrans-1267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: tcpflow允许你监控容器内外所有流量，而无需重新配置或重启任何东西。
- en: strace is a vital tool for identifying why a Docker container isn’t working
    on a specific host.
  id: totrans-1268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: strace是识别为什么Docker容器在特定主机上不起作用的一个关键工具。
- en: This concludes the book! We hope we’ve opened your eyes to some of the uses
    of Docker and given you some ideas for integrating it in your company or personal
    projects. If you’d like to get in touch with us or give us some feedback, please
    create a thread in the Manning *Docker in Practice* forum ([https://forums.manning.com/forums/docker-in-practice-second-edition](https://forums.manning.com/forums/docker-in-practice-second-edition))
    or raise an issue against one of the “docker-in-practice” GitHub repositories.
  id: totrans-1269
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书到此结束！我们希望我们已经打开了你的眼界，让你看到了Docker的一些用途，并给你提供了一些将其整合到你的公司或个人项目中的想法。如果你想与我们联系或给我们一些反馈，请在Manning
    *Docker in Practice* 论坛([https://forums.manning.com/forums/docker-in-practice-second-edition](https://forums.manning.com/forums/docker-in-practice-second-edition))中创建一个帖子，或者针对“docker-in-practice”GitHub仓库中的一个创建一个问题。
