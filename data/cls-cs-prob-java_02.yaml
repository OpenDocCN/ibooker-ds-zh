- en: 1 Small problems
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1 小问题
- en: To get started, we will explore some simple problems that can be solved with
    no more than a few relatively short functions. Although these problems are small,
    they will still allow us to explore some interesting problem-solving techniques.
    Think of them as a good warm-up.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始，我们将探索一些可以用几个相对简短的功能解决的问题。尽管这些问题很小，但它们仍然允许我们探索一些有趣的解决问题的技术。把它们看作是一个良好的热身。
- en: 1.1 The Fibonacci sequence
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.1 斐波那契数列
- en: 'The Fibonacci sequence is a sequence of numbers such that any number, except
    for the first and second, is the sum of the previous two:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 斐波那契数列是一个数列，其中除了第一个和第二个数之外，任何数都是前两个数的和：
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The value of the first Fibonacci number in the sequence is 0. The value of the
    fourth Fibonacci number is 2. It follows that to get the value of any Fibonacci
    number, n, in the sequence, one can use the formula
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 序列中第一个斐波那契数的值是 0。第四个斐波那契数的值是 2。因此，要得到序列中任何斐波那契数 n 的值，可以使用以下公式
- en: '[PRE1]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 1.1.1 A first recursive attempt
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.1.1 第一次递归尝试
- en: The preceding formula for computing a number in the Fibonacci sequence (illustrated
    in figure 1.1) is a form of pseudocode that can be trivially translated into a
    recursive Java method. (A recursive method is a method that calls itself.) This
    mechanical translation will serve as our first attempt at writing a method to
    return a given value of the Fibonacci sequence.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 计算斐波那契数列中一个数的公式（如图 1.1 所示）是一种伪代码，可以轻易地转换成递归的 Java 方法。（递归方法是一种调用自身的方法。）这种机械的转换将作为我们编写一个返回斐波那契数列给定值的第一个方法的尝试。
- en: '![1-1](../Images/1-1.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![1-1](../Images/1-1.png)'
- en: Figure 1.1 The height of each stickman is the previous two stickmen’s heights
    added together.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.1 每个小人的身高是前两个小人的身高之和。
- en: Listing 1.1 Fib1.java
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1.1 Fib1.java
- en: '[PRE2]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Let’s try to run this method by calling it with a value.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试通过传递一个值来调用这个方法来运行它。
- en: Listing 1.2 Fib1.java continued
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1.2 Fib1.java 继续显示
- en: '[PRE3]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Uh-oh! If we try to run Fib1.java, we generate an exception:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 哎呀！如果我们尝试运行 Fib1.java，我们会生成一个异常：
- en: '[PRE4]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The issue is that fib1() will run forever without returning a final result.
    Every call to fib1() results in another two calls of fib1() with no end in sight.
    We call such a circumstance infinite recursion (see figure 1.2), and it is analogous
    to an infinite loop.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于 fib1() 将无限期地运行而不会返回最终结果。每次调用 fib1() 都会导致另外两个没有终点的 fib1() 调用。我们称这种情形为无限递归（见图
    1.2），它类似于无限循环。
- en: '![1-2](../Images/1-2.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![1-2](../Images/1-2.png)'
- en: Figure 1.2 The recursive function fib(n) calls itself with the arguments n-1
    and n-2.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.2 递归函数 fib(n) 使用参数 n-1 和 n-2 调用自身。
- en: 1.1.2 Utilizing base cases
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.1.2 利用基本案例
- en: Notice that until you run fib1(), there is no indication from your Java environment
    that there is anything wrong with it. It is the duty of the programmer to avoid
    infinite recursion, not the compiler. The reason for the infinite recursion is
    that we never specified a base case. In a recursive function, a base case serves
    as a stopping point.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，直到你运行 fib1()，你的 Java 环境都没有任何错误的指示。避免无限递归是程序员的职责，而不是编译器的职责。无限递归的原因是我们从未指定一个基本案例。在递归函数中，基本案例充当一个停止点。
- en: In the case of the Fibonacci sequence, we have natural base cases in the form
    of the special first two sequence values, 0 and 1. Neither 0 nor 1 is the sum
    of the previous two numbers in the sequence. Instead, they are the special first
    two values. Let’s try specifying them as base cases.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在斐波那契数列的情况下，我们有自然的基本案例，形式为特殊的前两个序列值，0 和 1。0 和 1 都不是序列中前两个数的和。相反，它们是特殊的前两个值。让我们尝试将它们指定为基本案例。
- en: Listing 1.3 Fib2.java
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1.3 Fib2.java
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note The fib2() version of the Fibonacci method returns 0 as the zeroth number
    (fib2(0)), rather than the first number, as in our original proposition. In a
    programming context, this kind of makes sense because we are used to sequences
    starting with a zeroth element.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：斐波那契方法的 fib2() 版本将 0 作为零阶数（fib2(0)）返回，而不是我们原始命题中的第一个数。在编程环境中，这种做法是有意义的，因为我们习惯于以零阶元素开始的序列。
- en: fib2() can be called successfully and will return correct results. Try calling
    it with some small values.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: fib2() 可以成功调用并返回正确的结果。尝试用一些小的值调用它。
- en: Listing 1.4 Fib2.java continued
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1.4 Fib2.java 继续显示
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Do not try calling fib2(40). It may take a very long time to finish executing!
    Why? Every call to fib2() results in two more calls to fib2() by way of the recursive
    calls fib2(n - 1) and fib2(n - 2) (see figure 1.3). In other words, the call tree
    grows exponentially. For example, a call of fib2(4) results in this entire set
    of calls:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 不要尝试调用 fib2(40)。它可能需要非常长的时间才能完成执行！为什么？每次对 fib2() 的调用都会通过递归调用 fib2(n - 1) 和 fib2(n
    - 2) 导致对 fib2() 的两次额外调用（见图1.3）。换句话说，调用树呈指数增长。例如，对 fib2(4) 的调用会导致以下整个调用集：
- en: '[PRE7]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '![1-3](../Images/1-3.png)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![1-3](../Images/1-3.png)'
- en: Figure 1.3 Every non-base-case call of fib2() results in two more calls of fib2().
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.3 每个非基础情况的 fib2() 调用都会导致对 fib2() 的两次额外调用。
- en: If you count them (and as you will see if you add some print calls), there are
    9 calls to fib2() just to compute the 4th element! It gets worse. There are 15
    calls required to compute element 5, 177 calls to compute element 10, and 21,891
    calls to compute element 20\. We can do better.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你数一数（并且正如你将看到的，如果你添加一些打印调用），仅为了计算第 4 个元素就需要对 fib2() 进行 9 次调用！情况变得更糟。计算第 5
    个元素需要 15 次调用，计算第 10 个元素需要 177 次调用，计算第 20 个元素需要 21,891 次调用。我们可以做得更好。
- en: 1.1.3 Memoization to the rescue
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.1.3 缓存技术救命
- en: Memoization is a technique in which you store the results of computational tasks
    when they are completed so that when you need them again, you can look them up
    instead of needing to compute them a second (or millionth) time (see figure 1.4).[1](#pgfId-1144796)
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存技术是一种在计算任务完成后存储其结果的技术，这样当再次需要这些结果时，你可以查找它们而不是需要再次计算（或第百万次计算）（见图1.4）。[1](#pgfId-1144796)
- en: '![1-4](../Images/1-4.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![1-4](../Images/1-4.png)'
- en: Figure 1.4 The human memoization machine
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.4 人类缓存机制
- en: Let’s create a new version of the Fibonacci method that utilizes a Java map
    for memoization purposes.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新的斐波那契方法版本，该方法利用 Java 映射进行缓存。
- en: Listing 1.5 Fib3.java
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 列表1.5 Fib3.java
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You can now safely call fib3(40).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以安全地调用 fib3(40)。
- en: Listing 1.6 Fib3.java continued
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 列表1.6 Fib3.java 续
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: A call to fib3(20) will result in just 39 calls of fib3() as opposed to the
    21,891 of fib2() resulting from the call fib2(20). memo is prefilled with the
    earlier base cases of 0 and 1, saving fib3() from the complexity of another if
    statement.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 对 fib3(20) 的调用将仅产生 39 次对 fib3() 的调用，而 fib2(20) 的调用将产生 21,891 次对 fib2() 的调用。memo
    已经预先填充了早期的基础情况 0 和 1，从而避免了 fib3() 的另一个 if 语句的复杂性。
- en: 1.1.4 Keep it simple, Fibonacci
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.1.4 简单的斐波那契
- en: There is an even more performant option. We can solve Fibonacci with an old-fashioned
    iterative approach.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个性能更高的选项。我们可以用传统的迭代方法解决斐波那契问题。
- en: Listing 1.7 Fib4.java
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 列表1.7 Fib4.java
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The gist is, last is being set to the previous value of next, and next is being
    set to the previous value of last plus the previous value of next. A temporary
    variable, oldLast, facilitates the exchange.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 核心思想是，last 被设置为 next 的前一个值，而 next 被设置为 last 的前一个值加上 next 的前一个值。一个临时变量 oldLast
    促进了这种交换。
- en: With this approach, the body of the for loop will run n - 1 times. In other
    words, this is the most efficient version yet. Compare 19 runs of the for loop
    body to 21,891 recursive calls of fib2() for the 20th Fibonacci number. That could
    make a serious difference in a real-world application!
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 采用这种方法，for 循环的主体将运行 n - 1 次。换句话说，这是迄今为止最有效的一个版本。比较 for 循环主体的 19 次运行与计算第 20 个斐波那契数的
    fib2() 的 21,891 次递归调用。这在实际应用中可能造成重大差异！
- en: In the recursive solutions, we worked backward. In this iterative solution,
    we work forward. Sometimes recursion is the most intuitive way to solve a problem.
    For example, the meat of fib1() and fib2() is pretty much a mechanical translation
    of the original Fibonacci formula. However, naive recursive solutions can also
    come with significant performance costs. Remember, any problem that can be solved
    recursively can also be solved iteratively.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在递归解决方案中，我们向回工作。在这个迭代解决方案中，我们向前工作。有时递归是解决问题的最直观方式。例如，fib1() 和 fib2() 的核心几乎是对原始斐波那契公式的机械翻译。然而，简单的递归解决方案也可能带来显著的性能成本。记住，任何可以用递归解决的问题也可以用迭代解决。
- en: 1.1.5 Generating Fibonacci numbers with a stream
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.1.5 使用流生成斐波那契数
- en: So far, we have written methods that output a single value in the Fibonacci
    sequence. What if we want to output the entire sequence up to some value instead?
    It is easy to convert fib4() into a Java stream using the generator pattern. When
    the generator is iterated, each iteration will spew a value from the Fibonacci
    sequence using a lambda function that returns the next number.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经编写了输出斐波那契数列中单个值的函数。如果我们想输出到某个值的整个序列呢？将fib4()转换为Java流使用生成器模式很容易。当生成器被迭代时，每次迭代都会使用一个返回下一个数字的lambda函数从斐波那契数列中输出一个值。
- en: Listing 1.8 Fib5.java
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1.8 Fib5.java
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If you run Fib5.java, you will see 41 numbers in the Fibonacci sequence printed.
    For each number in the sequence, Fib5 runs the generate() lambda once, which manipulates
    the last and next instance variables that maintain state. The limit() call ensures
    that the potentially infinite stream stops spewing numbers when it reaches its
    41st item.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行Fib5.java，你将看到斐波那契数列中打印出41个数字。对于序列中的每个数字，Fib5都会运行一次generate() lambda，这会操作维护状态的最后一个和下一个实例变量。limit()调用确保在达到第41项时，可能无限长的流停止输出数字。
- en: 1.2 Trivial compression
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.2 简单压缩
- en: Saving space (virtual or real) is often important. It is more efficient to use
    less space, and it can save money. If you are renting an apartment that is bigger
    than you need for your things and family, you could “downsize” to a smaller place
    that is less expensive. If you are paying by the byte to store your data on a
    server, you may want to compress it so that its storage costs you less. Compression
    is the act of taking data and encoding it (changing its form) in such a way that
    it takes up less space. Decompression is reversing the process, returning the
    data to its original form.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 节省空间（虚拟或实际）通常很重要。使用更少的空间更有效率，并且可以节省金钱。如果你租的公寓比你存放物品和家庭所需的大，你可以“缩小规模”到一个更小的、更便宜的地方。如果你按字节支付在服务器上存储数据，你可能想压缩它，这样它的存储成本就会更低。压缩是将数据编码（改变其形式）以使其占用更少空间的行为。解压缩是逆过程，将数据恢复到其原始形式。
- en: If it is more storage-efficient to compress data, then why is all data not compressed?
    There is a trade-off between time and space. It takes time to compress a piece
    of data and to decompress it back into its original form. Therefore, data compression
    only makes sense in situations where small size is prioritized over fast execution.
    Think of large files being transmitted over the internet. Compressing them makes
    sense because it will take longer to transfer the files than it will to decompress
    them once received. Further, the time taken to compress the files for their storage
    on the original server only needs to be accounted for once.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果压缩数据更节省存储空间，那么为什么所有数据都没有被压缩呢？时间和空间之间存在权衡。压缩一块数据并将其解压缩回原始形式需要时间。因此，只有在小尺寸比快速执行更受重视的情况下，数据压缩才有意义。想想在互联网上传输的大文件。压缩它们是有意义的，因为传输文件需要的时间比解压缩文件接收后需要的时间更长。此外，为在原始服务器上存储文件而压缩文件所需的时间只需要计算一次。
- en: The easiest data compression wins come about when you realize that data storage
    types use more bits than are strictly required for their contents. For instance,
    thinking low-level, if a signed integer that will never exceed 32,767 is being
    stored as a 64-bit long in memory, it is being stored inefficiently. It could
    instead be stored as a 16-bit short. This would reduce the space consumption for
    the actual number by 75% (16 bits instead of 64 bits). If millions of such numbers
    are being stored inefficiently, it can add up to megabytes of wasted space.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当你意识到数据存储类型使用的位数比其内容严格所需的位数更多时，最简单的数据压缩效果就会出现。例如，从底层思考，如果一个永远不会超过32,767的整数被存储为内存中的64位长整型，那么它的存储是不高效的。它可以改为存储为16位短整型。这将实际数字的空间消耗减少75%（16位而不是64位）。如果数百万这样的数字被不高效地存储，它可能会累积到兆字节的浪费空间。
- en: In Java programming, sometimes for the sake of simplicity (which is a legitimate
    goal, of course), the developer is shielded from thinking in bits. The vast majority
    of Java code in the wild uses the 32-bit int type for storing integers. There
    is really nothing wrong with that for the vast majority of applications. However,
    if you are storing millions of integers, or you need integers of a certain precision,
    then it may be worth considering what the appropriate type for them is.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java编程中，有时为了简单起见（这当然是一个合法的目标），开发者被屏蔽了在位级别思考的需要。野外的大多数Java代码使用32位的int类型来存储整数。对于绝大多数应用程序来说，这实际上并没有什么问题。然而，如果你正在存储数百万个整数，或者你需要具有特定精度的整数，那么考虑它们适当的类型可能是有价值的。
- en: Note If you are a little rusty regarding binary, recall that a bit is a single
    value that is either a 1 or a 0\. A sequence of 1s and 0s is read in base 2 to
    represent a number. For the purposes of this section, you do not need to do any
    math in base 2, but you do need to understand that the number of bits that a type
    stores determines how many different values it can represent. For example, 1 bit
    can represent two values (0 or 1), 2 bits can represent four values (00, 01, 10,
    11), 3 bits can represent eight values, and so on.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：如果你对二进制有些生疏，请回忆一下，位是一个单一的值，要么是1要么是0。一串1和0以二进制为基础读取来表示一个数字。在本节的目的上，你不需要进行二进制数学运算，但你确实需要理解一个类型存储的位数决定了它可以表示的不同值的数量。例如，1位可以表示两个值（0或1），2位可以表示四个值（00、01、10、11），3位可以表示八个值，依此类推。
- en: 'If the number of possible different values that a type can represent is less
    than the number of values that the bits being used to store it can represent,
    it can likely be more efficiently stored. Consider the nucleotides that form a
    gene in DNA. Each nucleotide can only be one of four values: A, C, G, or T. Yet,
    if the gene is stored as a Java String, which can be thought of as a collection
    of Unicode characters, each nucleotide will be represented by a character, which
    generally requires 16 bits of storage in Java (Java uses the UTF-16 encoding by
    default). In binary, just 2 bits are needed to store a type with four possible
    values: 00, 01, 10, and 11 are the four different values that can be represented
    by 2 bits. If A is assigned 00, C is assigned 01, G is assigned 10, and T is assigned
    11, the storage required for a string of nucleotides can be reduced by 87.5% (from
    16 bits to 2 bits per nucleotide).'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个类型可以表示的不同值的数量小于存储它的位可以表示的值的数量，那么它可能可以更有效地存储。考虑构成DNA中基因的核苷酸。每个核苷酸只能有四种值之一：A、C、G或T。然而，如果基因以Java
    String的形式存储，这可以被视为Unicode字符的集合，每个核苷酸将由一个字符表示，这通常在Java中需要16位的存储空间（Java默认使用UTF-16编码）。在二进制中，只需要2位来存储具有四种可能值的类型：00、01、10和11是2位可以表示的四种不同值。如果A被分配为00，C被分配为01，G被分配为10，T被分配为11，那么核苷酸字符串所需的存储空间可以减少87.5%（从16位减少到每核苷酸2位）。
- en: '![1-5](../Images/1-5.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![1-5](../Images/1-5.png)'
- en: Figure 1.5 Compressing a String representing a gene into a 2-bit-per-nucleotide
    bit string
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.5 将表示基因的字符串压缩成每核苷酸2位的位字符串
- en: 'Instead of storing our nucleotides as a String, we can store them as a bit
    string (see figure 1.5). A bit string is exactly what it sounds like: an arbitrary-length
    sequence of 1s and 0s. Fortunately, the Java standard library contains an off-the-shelf
    construct for working with bit strings of arbitrary length called BitSet. The
    following code converts a String composed of As, Cs, Gs, and Ts into a string
    of bits and back again. The string of bits is stored within a BitSet via the compress()
    method. We will also implement a decompress() method to convert back into a String.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将我们的核苷酸存储为位字符串，而不是存储为字符串（见图1.5）。位字符串正是其名称的含义：任意长度的1和0的序列。幸运的是，Java标准库包含了一个现成的结构，用于处理任意长度的位字符串，称为BitSet。以下代码将由A、C、G和T组成的字符串转换为位字符串，然后再转换回来。位字符串通过compress()方法存储在BitSet中。我们还将实现一个decompress()方法，以将其转换回字符串。
- en: Listing 1.9 CompressedGene.java
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 列表1.9 CompressedGene.java
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: A CompressedGene is provided a String of characters representing the nucleotides
    in a gene, and it internally stores the sequence of nucleotides as a BitSet. The
    constructor’s main responsibility is to initialize the BitSet construct with the
    appropriate data. The constructor calls compress() to do the dirty work of actually
    converting the provided String of nucleotides into a BitSet.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 压缩基因（CompressedGene）提供了一个表示基因中核苷酸的字符序列的字符串，并且它内部以BitSet的形式存储核苷酸序列。构造函数的主要责任是用适当的数据初始化BitSet构造。构造函数调用compress()来完成将提供的核苷酸字符串实际转换为BitSet的脏活。
- en: Next, let’s look at how we can actually perform the compression.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看我们如何实际执行压缩。
- en: Listing 1.10 CompressedGene.java continued
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 列表1.10 CompressedGene.java继续
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The compress() method looks at each character in the String of nucleotides sequentially.
    When it sees an A, it adds 00 to the bit string. When it sees a C, it adds 01,
    and so on. For the BitSet class, the Boolean values true and false serve as markers
    for 1 and 0, respectively.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: compress()方法按顺序查看核苷酸字符串中的每个字符。当它看到A时，就在位字符串中添加00。当它看到C时，就添加01，依此类推。对于BitSet类，布尔值true和false分别作为1和0的标记。
- en: Every nucleotide is added using two calls of the set() method. In other words,
    we continually add two new bits to the end of the bit string. The two bits that
    are added are determined by the type of the nucleotide.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 每个核苷酸都是通过两次调用set()方法添加的。换句话说，我们不断地在位字符串的末尾添加两个新位。添加的两个位由核苷酸的类型决定。
- en: Finally, we will implement decompression.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将实现解压缩。
- en: Listing 1.11 CompressedGene.java continued
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 列表1.11 CompressedGene.java继续
- en: '[PRE14]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: decompress() reads two bits from the bit string at a time, and it uses those
    two bits to determine which character to add to the end of the String representation
    of the gene, which is built using a StringBuilder. The two bits are composed together
    in the variable lastBits. lastBits is made by shifting the first bit back one
    place, and then ORing (| operator) the result with the second bit. When a value
    is shifted, using the << operator, the space left behind is replaced with 0s.
    An OR says, “If either of these bits are a 1, put a 1.” Therefor ORing secondBit
    with a 0 will always just result in the value of secondBit. Let’s test it out.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: decompress()一次从位字符串中读取两个位，并使用这两个位来确定要将哪个字符添加到基因的字符串表示的末尾，该表示是通过StringBuilder构建的。这两个位组合在一起在变量lastBits中。lastBits是通过将第一个位向后移动一位，然后使用OR操作符（|运算符）将结果与第二个位进行或操作来创建的。当使用<<运算符移动值时，留下的空间被0s替换。OR操作表示，“如果这两个位中的任何一个为1，则放置一个1。”因此，将secondBit与0进行OR操作将始终只产生secondBit的值。让我们来测试一下。
- en: Listing 1.12 CompressedGene.java continued
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 列表1.12 CompressedGene.java继续
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The main() method does a compression and a decompression. It checks whether
    the final result is the same as the original String using equalsIgnoreCase().
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: main()方法执行压缩和解压缩。它使用equalsIgnoreCase()检查最终结果是否与原始字符串相同。
- en: Listing 1.13 CompressedGene.java output
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 列表1.13 CompressedGene.java输出
- en: '[PRE16]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 1.3 Unbreakable encryption
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.3 不可破译的加密
- en: A one-time pad is a way of encrypting a piece of data by combining it with meaningless
    random dummy data in such a way that the original cannot be reconstituted without
    access to both the product and the dummy data. In essence, this leaves the encrypter
    with a key pair. One key is the product, and the other is the random dummy data.
    One key on its own is useless; only the combination of both keys can unlock the
    original data. When performed correctly, a one-time pad is a form of unbreakable
    encryption. Figure 1.6 shows the process.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 一次性密码是一种通过将数据与无意义的随机虚拟数据结合来加密数据的方法，这样原始数据在没有访问产品和虚拟数据的情况下无法重新构成。本质上，这给加密者留下了一对密钥。一个密钥是产品，另一个是随机虚拟数据。单独的密钥是无用的；只有两个密钥的组合才能解锁原始数据。当正确执行时，一次性密码是一种不可破译的加密形式。图1.6显示了该过程。
- en: '![1-6](../Images/1-6.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![1-6](../Images/1-6.png)'
- en: Figure 1.6 A one-time pad results in two keys that can be separated and then
    recombined to re-create the original data.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.6 一次性密码产生两个可以分离并重新组合以重新创建原始数据的密钥。
- en: 1.3.1 Getting the data in order
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.3.1 按顺序获取数据
- en: In this example, we will encrypt a String using a one-time pad. One way of thinking
    about a Java String is as a sequence of UTF-16 characters (with UTF-16 being a
    Unicode character encoding). Every UTF-16 character is 16 bits (hence the 16)
    and can be further subdivided into 2 bytes (8 bits each). A String can be converted
    into an array of bytes, represented as an array of the byte type, through the
    getBytes() method. Likewise, an array of bytes can be converted back into a String
    using one of the built-in constructors on the String type. We will need an intermediary
    form to store the key pair, which will consist of two arrays of byte. That is
    the purpose of the KeyPair class.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将使用一次密码加密一个字符串。一种思考 Java 字符串的方式是将其视为一系列 UTF-16 字符（UTF-16 是一种 Unicode
    字符编码）。每个 UTF-16 字符都是 16 位（因此是 16），可以进一步细分为 2 个字节（每个 8 位）。可以通过 getBytes() 方法将字符串转换为字节数组，表示为字节数组。同样，可以使用
    String 类型内置的构造函数之一将字节数组转换回字符串。我们需要一个中间形式来存储密钥对，它将包含两个字节数组。这就是 KeyPair 类的目的。
- en: Listing 1.14 KeyPair.java
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1.14 KeyPair.java
- en: '[PRE17]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'There are three criteria that the dummy data used in a one-time-pad encryption
    operation must meet for the resulting product to be unbreakable. The dummy data
    must be the same length as the original data, truly random, and completely secret.
    The first and third criteria are common sense. If the dummy data repeats because
    it is too short, there could be an observed pattern. If one of the keys is not
    truly secret (perhaps it is reused elsewhere or partially revealed), then an attacker
    has a clue. The second criterion poses a question all its own: can we produce
    truly random data? The answer for most computers is no.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在一次密码加密操作中，用于加密操作的虚拟数据必须满足三个标准，以确保结果产品是不可破译的。虚拟数据必须与原始数据长度相同，真正随机，并且完全保密。第一个和第三个标准是常识。如果虚拟数据因为太短而重复，可能会观察到某种模式。如果其中一个密钥不是真正保密的（可能它在其他地方被重复使用或部分泄露），那么攻击者就有线索了。第二个标准本身就是一个问题：我们能否生成真正随机的数据？对于大多数计算机来说，答案是不了。
- en: In this example we will use the pseudo-random data-generating function nextBytes()
    from the standard library’s Random class. Our data will not be truly random, in
    the sense that the Random class is using a pseudo-random number generator behind
    the scenes, but it will be close enough for our purposes. Let’s generate a random
    key for use as dummy data.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将使用标准库中的 Random 类的伪随机数据生成函数 nextBytes()。我们的数据不会是真正随机的，因为 Random 类在幕后使用伪随机数生成器，但对我们来说已经足够接近了。让我们生成一个随机密钥作为虚拟数据使用。
- en: Listing 1.15 UnbreakableEncryption.java
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1.15 UnbreakableEncryption.java
- en: '[PRE18]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This method creates a byte array filled with length random bytes. Ultimately,
    the bytes will serve as the “dummy” key in our key pair.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法创建了一个填充了随机字节的字节数组。最终，这些字节将作为我们的密钥对中的“虚拟”密钥。
- en: 1.3.2 Encrypting and decrypting
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.3.2 加密和解密
- en: How will the dummy data be combined with the original data that we want to encrypt?
    The XOR operation will serve this purpose. XOR is a logical bitwise (operates
    at the bit level) operation that returns true when one of its operands is true
    but returns false when both are true or neither is true. As you may have guessed,
    XOR stands for exclusive or.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将如何将虚拟数据与我们要加密的原始数据结合？XOR 运算将完成这个任务。XOR 是一种逻辑位运算（在位级别上操作），当其中一个操作数为真时返回真，当两个都为真或都不是真时返回假。正如你可能猜到的，XOR
    代表的是“异或”。
- en: 'In Java, the XOR operator is ^. In the context of the bits of binary numbers,
    XOR returns 1 for 0 ^ 1 and 1 ^ 0, but 0 for 0 ^ 0 and 1 ^ 1. If the bits of two
    numbers are combined using XOR, a helpful property is that the product can be
    recombined with either of the operands to produce the other operand:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 中，XOR 运算符是 `^`。在二进制数的位上下文中，XOR 对于 0 ^ 1 和 1 ^ 0 返回 1，但对于 0 ^ 0 和 1 ^
    1 返回 0。如果使用 XOR 将两个数的位组合起来，一个有用的性质是，结果可以与任一操作数重新组合以产生另一个操作数：
- en: '[PRE19]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This key insight forms the basis of one-time-pad encryption. To form our product,
    we will simply XOR bytes from our original String with the randomly generated
    bytes of the same length (as produced by randomKey()). Our returned key pair will
    be the dummy key and the product key, as depicted in figure 1.6.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这个关键洞察构成了一次密码加密的基础。为了形成我们的产品，我们将简单地使用 XOR 运算将原始字符串中的字节与随机生成的相同长度的字节（由 randomKey()
    生成）进行异或。我们的返回密钥对将是虚拟密钥和产品密钥，如图 1.6 所示。
- en: Listing 1.16 UnbreakableEncryption.java continued
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1.16 UnbreakableEncryption.java 继续阅读
- en: '[PRE20]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Decryption is simply a matter of recombining the key pair we generated with
    encrypt(). This is achieved once again by doing an XOR operation between each
    and every bit in the two keys. The ultimate output must be converted back to a
    String. This is accomplished using a constructor from the String class that takes
    a byte array as its lone argument.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 解密只是重新组合我们用encrypt()生成的密钥对。这再次通过在两个密钥的每个和每个位之间进行XOR操作来实现。最终输出必须转换回String。这是通过String类的构造函数完成的，该构造函数以字节数组作为其唯一的参数。
- en: Listing 1.17 UnbreakableEncryption.java continued
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1.17 UnbreakableEncryption.java 继续阅读
- en: '[PRE21]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: If our one-time-pad encryption truly works, we should be able to encrypt and
    decrypt the same Unicode string without issue.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的一次性密码加密真正有效，我们应该能够无问题地加密和解密相同的Unicode字符串。
- en: Listing 1.18 UnbreakableEncryption.java continued
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1.18 UnbreakableEncryption.java 继续阅读
- en: '[PRE22]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: If your console outputs One Time Pad! then everything worked. Try it out with
    your own sentences.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的控制台输出 One Time Pad!，则一切正常。用你自己的句子试一试。
- en: 1.4 Calculating pi
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.4 计算π
- en: 'The mathematically significant number pi (π or 3.14159...) can be derived using
    many formulas. One of the simplest is the Leibniz formula. It posits that the
    convergence of the following infinite series is equal to pi:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 数学上有意义的数字π（π或3.14159...）可以通过许多公式推导出来。其中最简单的一个是莱布尼茨公式。它提出以下无穷级数的收敛等于π：
- en: '[PRE23]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: You will notice that the infinite series’ numerator remains 4 while the denominator
    increases by 2, and the operation on the terms alternates between addition and
    subtraction.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到无穷级数的分子保持为4，而分母每次增加2，并且项的操作在加法和减法之间交替。
- en: We can model the series in a straightforward way by translating pieces of the
    formula into variables in a function. The numerator can be a constant 4\. The
    denominator can be a variable that begins at 1 and is incremented by 2\. The operation
    can be represented as either -1 or 1 based on whether we are adding or subtracting.
    Finally, the variable pi is used in listing 1.19 to collect the sum of the series
    as the for loop proceeds.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将公式的部分转换为函数中的变量来直接建模这个级数。分子可以是一个常数4。分母可以是一个变量，从1开始，每次增加2。操作可以根据我们是加法还是减法表示为-1或1。最后，变量π在列表1.19中用于收集级数的和，随着for循环的进行。
- en: Listing 1.19 PiCalculator.java
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1.19 PiCalculator.java
- en: '[PRE24]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Tip Java doubles are 64-bit floating-point numbers, and they offer more precision
    than the 32-bit type float.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 提示 Java的double是64位浮点数，它们比32位类型float提供更多的精度。
- en: This function is an example of how rote conversion between formula and programmatic
    code can be both simple and effective in modeling or simulating an interesting
    concept. Rote conversion is a useful tool, but we must keep in mind that it is
    not necessarily the most efficient solution. Certainly, the Leibniz formula for
    pi can be implemented with more efficient or compact code.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数是公式和程序代码之间机械转换的一个例子，这种转换在建模或模拟有趣的概念时既简单又有效。机械转换是一个有用的工具，但我们必须记住，它不一定是最有效的解决方案。当然，π的莱布尼茨公式可以用更高效或更紧凑的代码实现。
- en: Note The more terms in the infinite series (the higher the value of nTerms when
    calculatePi() is called), the more accurate the ultimate calculation of pi will
    be.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 无穷级数的项数越多（当调用calculatePi()时nTerms的值越高），π的最终计算将越准确。
- en: 1.5 The Towers of Hanoi
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.5 汉诺塔
- en: 'Three vertical pegs (henceforth “towers”) stand tall. We will label them A,
    B, and C. Doughnut-shaped discs are around tower A. The widest disc is at the
    bottom, and we will call it disc 1\. The rest of the discs above disc 1 are labeled
    with increasing numerals and get progressively narrower. For instance, if we were
    to work with three discs, the widest disc, the one on the bottom, would be 1\.
    The next widest disc, disc 2, would sit on top of disc 1\. And finally, the narrowest
    disc, disc 3, would sit on top of disc 2\. Our goal is to move all of the discs
    from tower A to tower C given the following constraints:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 三根垂直的柱子（以下称为“塔”）高高矗立。我们将它们标记为A、B和C。环形圆盘围绕塔A。最宽的圆盘在底部，我们将其称为圆盘1。圆盘1以上的其他圆盘用递增的数字标记，并逐渐变窄。例如，如果我们处理三个圆盘，最宽的圆盘，底部的圆盘，将是1。下一个最宽的圆盘，圆盘2，将坐在圆盘1的顶部。最后，最窄的圆盘，圆盘3，将坐在圆盘2的顶部。我们的目标是根据以下约束条件将所有圆盘从塔A移动到塔C：
- en: Only one disc can be moved at a time.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一次只能移动一个圆盘。
- en: The topmost disc of any tower is the only one available for moving.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何塔顶的圆盘是唯一可以移动的。
- en: A wider disc can never be atop a narrower disc.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 较大的圆盘永远不会放在较小的圆盘之上。
- en: Figure 1.7 summarizes the problem.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.7 总结了这个问题。
- en: 1.5.1 Modeling the towers
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.5.1 建模塔
- en: A stack is a data structure that is modeled on the concept of Last-In-First-Out
    (LIFO). The last thing put into it is the first thing that comes out of it. Think
    of a teacher grading a stack of papers. The last paper put on top of the stack
    is the first paper that the teacher will remove from the stack to grade. The two
    most basic operations on a stack are push and pop. A push puts a new item into
    a stack, whereas a pop removes and returns the last item put in. The Java standard
    library includes a built-in class, Stack, that includes methods for push() and
    pop().
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 栈是一种基于后进先出（LIFO）概念的数据结构。最后放入的是第一个出来的。想象一下老师批改一摞试卷。放在堆顶的最后一张纸是老师首先从堆中取出批改的第一张纸。栈上最基本的两项操作是
    push 和 pop。Java 标准库包括一个内置的 Stack 类，它包含 push() 和 pop() 方法。
- en: Stacks are perfect stand-ins for the towers in The Towers of Hanoi. When we
    want to put a disc onto a tower, we can just push it. When we want to move a disc
    from one tower to another, we can pop it from the first and push it onto the second.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 栈是汉诺塔中的塔的完美替代品。当我们想要将一个圆盘放到一个塔上时，我们只需将其推入。当我们想要将一个圆盘从一个塔移动到另一个塔时，我们可以从第一个塔中弹出并推入第二个塔。
- en: Let’s define our towers as Stacks and fill the first tower with discs.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义我们的塔为栈，并将第一个塔填充上圆盘。
- en: Listing 1.20 Hanoi.java
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 1.20 Hanoi.java
- en: '[PRE25]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 1.5.2 Solving The Towers of Hanoi
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 1.5.2 解决汉诺塔
- en: 'How can The Towers of Hanoi be solved? Imagine we were only trying to move
    one disc. We would know how to do that, right? In fact, moving one disc is our
    base case for a recursive solution to The Towers of Hanoi. The recursive case
    is moving more than one disc. Therefore, the key insight is that we essentially
    have two scenarios we need to codify: moving one disc (the base case) and moving
    more than one disc (the recursive case).'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如何解决汉诺塔问题？想象我们只是在尝试移动一个圆盘。我们会知道如何做，对吧？实际上，移动一个圆盘是解决汉诺塔递归解决方案的基例。递归情况是移动多个圆盘。因此，关键洞察是我们本质上需要编码两个场景：移动一个圆盘（基例）和移动多个圆盘（递归情况）。
- en: '![1-7](../Images/1-7.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![1-7](../Images/1-7.png)'
- en: Figure 1.7 The challenge is to move the three discs, one at a time, from tower
    A to tower C. A larger disc may never be on top of a smaller disc.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.7 挑战是将三个圆盘一个接一个地从塔 A 移动到塔 C。较大的圆盘不能放在较小的圆盘之上。
- en: Let’s look at a specific example to understand the recursive case. Say we have
    three discs (top, middle, and bottom) on tower A that we want to move to tower
    C. (It may help to sketch out the problem as you follow along.) We could first
    move the top disc to tower C. Then we could move the middle disc to tower B. Then
    we could move the top disc from tower C to tower B. Now we have the bottom disc
    still on tower A and the upper two discs on tower B. Essentially, we have now
    successfully moved two discs from one tower (A) to another tower (B). Moving the
    bottom disc from A to C is our base case (moving a single disc). Now we can move
    the two upper discs from B to C with the same procedure that we did from A to
    B. We move the top disc to A, the middle disc to C, and finally the top disc from
    A to C.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个具体的例子来理解递归情况。假设我们有三个圆盘（顶部、中间和底部）在塔 A 上，我们想要将其移动到塔 C 上。（在跟随时画出问题可能有助于。）我们首先可以将顶部圆盘移动到塔
    C 上。然后我们可以将中间圆盘移动到塔 B 上。然后我们可以将顶部圆盘从塔 C 移动到塔 B 上。现在底部圆盘仍然在塔 A 上，上面的两个圆盘在塔 B 上。本质上，我们现在已经成功地将两个圆盘从一个塔（A）移动到另一个塔（B）。将底部圆盘从
    A 移动到 C 是我们的基例（移动单个圆盘）。现在我们可以使用与从 A 到 B 相同的程序将上面的两个圆盘从 B 移动到 C。我们将顶部圆盘移动到 A，中间圆盘移动到
    C，最后将顶部圆盘从 A 移动到 C。
- en: Tip In a computer science classroom, it is not uncommon to see a little model
    of the towers built using dowels and plastic doughnuts. You can build your own
    model using three pencils and three pieces of paper. It may help you visualize
    the solution.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士 在计算机科学课堂上，用木棒和塑料甜甜圈搭建的塔的小模型并不少见。你可以用三支铅笔和三张纸来搭建自己的模型。这可能有助于你可视化解决方案。
- en: 'In our three-disc example, we had a simple base case of moving a single disc
    and a recursive case of moving all of the other discs (two in this case), using
    the third tower temporarily. We could break the recursive case into three steps:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的三个圆盘示例中，我们有一个简单的基例，即移动单个圆盘，以及一个递归情况，即移动所有其他圆盘（在这种情况下是两个），暂时使用第三个塔。我们可以将递归情况分解为三个步骤：
- en: Move the upper n-1 discs from tower A to B (the temporary tower), using C as
    the step in between.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将塔A上的上n-1个圆盘移动到B（临时塔），使用C作为中间步骤。
- en: Move the single lowest disc from A to C.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将A塔上单个最低的圆盘移动到C。
- en: Move the n-1 discs from tower B to C, using A as the step in between.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将塔B上的n-1个圆盘移动到C，使用A作为中间步骤。
- en: The amazing thing is that this recursive algorithm works not only for three
    discs, but for any number of discs. We will codify it as a method called move()
    that is responsible for moving discs from one tower to another, given a third
    temporary tower.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 令人惊讶的是，这个递归算法不仅适用于三个圆盘，而且适用于任意数量的圆盘。我们将将其编码为一个名为move()的方法，该方法负责在给定第三个临时塔的情况下，将圆盘从一个塔移动到另一个塔。
- en: Listing 1.21 Hanoi.java continued
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 列表1.21 Hanoi.java继续
- en: '[PRE26]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Finally, a helper method, solve(), will call move() for all of the discs from
    tower A to tower C. After calling solve(), you should examine towers A, B, and
    C to verify that the discs were moved successfully.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，辅助方法solve()将调用move()来移动塔A上的所有圆盘到塔C。在调用solve()之后，你应该检查塔A、B和C，以验证圆盘是否成功移动。
- en: Listing 1.22 Hanoi.java continued
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 列表1.22 Hanoi.java继续
- en: '[PRE27]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'You will find that they were. In codifying the solution to The Towers of Hanoi,
    we did not necessarily need to understand every step required to move multiple
    discs from tower A to tower C. But we came to understand the general recursive
    algorithm for moving any number of discs, and we codified it, letting the computer
    do the rest. This is the power of formulating recursive solutions to problems:
    we often can think of solutions in an abstract manner without the drudgery of
    negotiating every individual action in our minds.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现它们确实移动了。在将汉诺塔问题的解决方案编码化时，我们并不一定需要理解将多个圆盘从塔A移动到塔C所需的每一个步骤。但我们理解了移动任意数量圆盘的一般递归算法，并将其编码化，让计算机完成剩余的工作。这就是将问题的递归解决方案公式化的力量：我们常常可以以抽象的方式思考解决方案，而无需在脑海中逐一考虑每一个具体行动。
- en: Incidentally, the move() method will execute an exponential number of times
    as a function of the number of discs, which makes solving the problem for even
    64 discs untenable. You can try it with various other numbers of discs by passing
    a different number of discs to the constructor for Hanoi. The exponentially increasing
    number of steps required as the number of discs increases is where the legend
    of The Towers of Hanoi comes from; you can read more about it in any number of
    sources. You may also be interested in reading more about the mathematics behind
    its recursive solution; see Carl Burch’s explanation in “About the Towers of Hanoi,”
    [http://mng.bz/c1i2](http://mng.bz/c1i2).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便提一下，move()方法将根据圆盘的数量以指数级执行，这使得解决64个圆盘的问题变得不可行。你可以通过将不同数量的圆盘传递给Hanoi构造函数来尝试使用其他数量的圆盘。随着圆盘数量的增加，所需步骤数量的指数级增加是汉诺塔传说的来源；你可以在任何数量的来源中了解更多关于它的信息。你可能还对了解其递归解决方案背后的数学感兴趣；请参阅Carl
    Burch在“关于汉诺塔”中的解释[http://mng.bz/c1i2](http://mng.bz/c1i2)。
- en: 1.6 Real-world applications
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.6 现实世界应用
- en: The various techniques presented in this chapter (recursion, memoization, compression,
    and manipulation at the bit level) are so common in modern software development
    that it is impossible to imagine the world of computing without them. Although
    problems can be solved without them, it is often more logical or performant to
    solve problems with them.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中介绍的各种技术（递归、记忆化、压缩和位级操作）在现代软件开发中如此普遍，以至于无法想象没有它们计算的世界。尽管没有它们也可以解决问题，但通常使用它们解决问题更合理或更高效。
- en: Recursion, in particular, is at the heart of not just many algorithms, but even
    whole programming languages. In some functional programming languages, like Scheme
    and Haskell, recursion takes the place of the loops used in imperative languages.
    It is worth remembering, though, that anything doable with a recursive technique
    is also doable with an iterative technique.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 递归，特别是，不仅是许多算法的核心，甚至是整个编程语言的核心。在一些函数式编程语言中，如Scheme和Haskell，递归取代了命令式语言中使用的循环。然而，值得注意的是，任何可以用递归技术完成的事情也可以用迭代技术完成。
- en: Memoization has been applied successfully to speed up the work of parsers (programs
    that interpret languages). It is useful in all problems where the result of a
    recent calculation will likely be asked for again. Another application of memoization
    is in language runtimes. Some language runtimes (versions of Prolog, for instance)
    will store the results of function calls automatically (auto-memoization), so
    that the function need not execute the next time the same call is made.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存（memoization）已被成功应用于加速解析器（解释语言程序的程序）的工作。它在所有可能需要再次询问最近计算结果的问题中都有用。缓存的一个应用是在语言运行时中。一些语言运行时（例如Prolog的版本）会自动存储函数调用的结果（自动缓存），这样函数就不必在下次调用相同的调用时执行。
- en: Compression has made an internet-connected world constrained by bandwidth more
    tolerable. The bit-string technique examined in section 1.2 is usable for real-world
    simple data types that have a limited number of possible values, for which even
    a byte is overkill. The majority of compression algorithms, however, operate by
    finding patterns or structures within a data set that allow for repeated information
    to be eliminated. They are significantly more complicated than what is covered
    in section 1.2.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 压缩技术使得带宽受限的互联网连接世界变得更加可忍受。在第1.2节中考察的位串技术适用于现实世界中具有有限可能值的简单数据类型，对于这些类型来说，即使是字节也显得过于冗余。然而，大多数压缩算法通过在数据集中寻找模式或结构来工作，这些模式或结构允许消除重复信息。它们比第1.2节中介绍的内容要复杂得多。
- en: One-time pads are not practical for general encryption. They require both the
    encrypter and the decrypter to have possession of one of the keys (the dummy data
    in our example) for the original data to be reconstructed, which is cumbersome
    and defeats the goal of most encryption schemes (keeping keys secret). But you
    may be interested to know that the name “one-time pad” comes from spies using
    real paper pads with dummy data on them to create encrypted communications during
    the Cold War.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 一次性密码对于通用加密来说并不实用。它们要求加密者和解密者都拥有原始数据的其中一个密钥（在我们例子中的虚拟数据），以便重建原始数据，这既繁琐又违背了大多数加密方案的目标（保持密钥的秘密性）。但你可能感兴趣的是，一次性密码这个名字来源于间谍在冷战期间使用带有虚拟数据的真实纸张垫来创建加密通信。
- en: These techniques are programmatic building blocks that other algorithms are
    built on top of. In future chapters you will see them applied liberally.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这些技术是程序性构建块，其他算法都是建立在它们之上的。在未来的章节中，你将看到它们被广泛地应用。
- en: 1.7 Exercises
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 1.7 练习
- en: Write yet another function that solves for element n of the Fibonacci sequence,
    using a technique of your own design. Write unit tests that evaluate its correctness
    and performance relative to the other versions in this chapter.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写另一个函数，使用你自己的设计技术求解斐波那契数列的第n个元素。编写单元测试来评估其正确性和相对于本章其他版本的性能。
- en: 'The BitSet class in the Java standard library has a flaw: while it keeps track
    of how many total bits have been set true, it does not keep track of how many
    bits have been set in total, including bits that have been set false (that’s why
    we needed the length instance variable). Write an ergonomic subclass of BitSet
    that keeps track of exactly how many bits have been set either true or false.
    Reimplement CompressedGene using the subclass.'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Java标准库中的BitSet类存在一个缺陷：虽然它跟踪了多少位被设置为true，但它并没有跟踪总共设置了多少位，包括被设置为false的位（这就是为什么我们需要长度实例变量）。编写一个符合人体工程学的BitSet子类，该子类可以精确跟踪被设置为true或false的位的数量。使用这个子类重新实现CompressedGene。
- en: Write a solver for The Towers of Hanoi that works for any number of towers.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个适用于任何数量塔的汉诺塔求解器。
- en: Use a one-time pad to encrypt and decrypt images.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用一次性密码来加密和解密图像。
- en: '* * *'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '1. Donald Michie, a famous British computer scientist, coined the term memoization.
    Donald Michie, Memo Functions: A Language Feature with “rote-learning” Properties
    (Edinburgh University, Department of Machine Intelligence and Perception, 1967).'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '1. 英国著名计算机科学家唐纳德·米契（Donald Michie）提出了memoization这个术语。唐纳德·米契，《Memo Functions:
    A Language Feature with “rote-learning” Properties》（爱丁堡大学，机器智能与感知系，1967年）。'
