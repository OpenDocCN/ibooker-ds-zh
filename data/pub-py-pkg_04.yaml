- en: 4 Handling package dependencies, entry points, and extensions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4 处理包依赖项、入口点和扩展
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖
- en: Defining dependencies for your package
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义你的包的依赖关系
- en: Making functionality available as command-line tools
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将功能作为命令行工具提供
- en: Packaging extensions written in C
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用C编写的扩展包
- en: You’re just getting ready to start adding your groundbreaking functionality
    into your Python package for CarCorp when they call with a few last-minute requests.
    They want you to make sure it’s *really fast* and that it can be run as a standalone
    command because their developers aren’t as well-versed in Python as you are. You
    haven’t even delivered the first version of your package yet, and already the
    requirements are growing! Before you panic, take a deep breath and read this chapter
    to learn more.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 当你正准备开始将你的开创性功能添加到为CarCorp的Python包中时，他们提出了几个最后时刻的要求。他们想要确保它真的*很快*，并且可以作为独立命令运行，因为他们的开发者对Python的了解不如你。你甚至还没有交付包的第一个版本，需求就已经在增长！在你恐慌之前，深呼吸并阅读本章以了解更多信息。
- en: Important You can use the code companion ([http://mng.bz/Xa0M](http://mng.bz/Xa0M))
    to check your work for the exercises in this chapter.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示：你可以使用代码伴侣（[http://mng.bz/Xa0M](http://mng.bz/Xa0M)）来检查本章练习的工作。
- en: 4.1 A package for calculating vehicle drift
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.1 用于计算车辆漂移的包
- en: Imagine that the software you’ve been working on for CarCorp will help them
    guide their vehicles on the road. During their testing they’ve observed that the
    vehicles tend to drift around the road more than they’d like, and they’ve started
    measuring the drift. Although they have the raw data, they don’t have a great
    way of measuring the impact of any potential improvements they make.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你为CarCorp开发的软件将帮助他们引导车辆在道路上行驶。在他们的测试中，他们观察到车辆在道路上漂移比他们希望的要多，他们已经开始测量漂移。尽管他们有原始数据，但他们没有很好的方法来衡量他们所做的任何潜在改进的影响。
- en: The package you’re building will provide utilities for CarCorp to gain visibility
    into this issue. The first thing you’ll do is provide a way to calculate the average
    drift in millimeters per second over a given distance. The vehicles measure their
    drift rate about one million times during each run through the five-kilometer
    testing course. Your package will consume these measurements as a list of floating-point
    numbers and calculate their *harmonic mean*.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你正在构建的包将为CarCorp提供工具，以便他们能够了解这个问题。你将要做的第一件事是提供一个计算给定距离内平均漂移（以毫米/秒为单位）的方法。车辆在每次通过五公里测试课程时大约测量漂移率一百万次。你的包将消耗这些测量值作为浮点数列表，并计算它们的*调和平均值*。
- en: Harmonic mean
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 调和平均值
- en: The *harmonic mean* is different from the more common arithmetic mean and is
    the correct calculation to use when you want the average rate instead of the average
    *of* rates. Peter A. Lindstrom shows some examples in *The Average of Rates and
    the Average Rate* ([http://mng.bz/19n1](http://mng.bz/19n1)).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '*调和平均值*与更常见的算术平均值不同，当你想要平均速率而不是速率的平均值时，这是正确的计算方法。Peter A. Lindstrom在*《速率的平均值和平均速率》*中提供了一些例子（[http://mng.bz/19n1](http://mng.bz/19n1)）。'
- en: 'You can calculate the harmonic mean of the drift by dividing the total number
    of measurements by the sum of reciprocals of the measurements:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过将测量值的总数除以测量值的倒数之和来计算漂移的调和平均值：
- en: '![](../../OEBPS/Images/04-00-equation_4-1.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![方程式 4-1](../../OEBPS/Images/04-00-equation_4-1.png)'
- en: With one million inputs, this calculation might take some time. You can see
    why CarCorp emphasized that they want speed. When examining code performance,
    it’s best to profile the code instead of speculating about the impact of improvements
    (see Dane Hillard, “Designing for High Performance,” *Practices of the Python
    Pro*, Manning Publications, 2020, pp. 72–76, [http://mng.bz/m2N0](http://mng.bz/m2N0)).
    Before you go too much further, you must first observe how the Python version
    fares.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当有百万个输入时，这个计算可能需要一些时间。你可以看到为什么CarCorp强调他们想要速度。在检查代码性能时，最好是分析代码而不是猜测改进的影响（参见Dane
    Hillard的“为高性能设计”，《Python Pro实践》，Manning Publications，2020年，第72-76页，[http://mng.bz/m2N0](http://mng.bz/m2N0)）。在你走得太远之前，你必须首先观察Python版本的表现。
- en: Exercise 4.1
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 4.1
- en: In the root directory of your project, create a `harmonic_mean.py` module. In
    this module, write a `harmonic_mean` function that accepts an arbitrarily long
    list of floating-point numbers and returns their harmonic mean.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的项目根目录中创建一个`harmonic_mean.py`模块。在这个模块中，编写一个`harmonic_mean`函数，该函数接受任意长度的浮点数列表，并返回它们的调和平均值。
- en: 'Now that you’ve written a Python implementation of the harmonic mean calculation,
    you can use the built-in `timeit` module ([https://docs.python.org/3/library/timeit.xhtml](https://docs.python.org/3/library/timeit.xhtml))
    to measure its performance. When you profile code, you should reduce it to the
    minimal portion for which you want to measure the performance to ensure an accurate
    picture when comparing solutions. The `timeit` module enables you to separate
    setup code from the code you want to measure by passing the setup code as a string
    to the `--setup` option. The setup code will run only once and will not be counted
    toward the measurement of your code. You can invoke the module directly with `py
    -m timeit` and any arguments you want to pass. You can use the `--setup` option
    multiple times to separate multiple expressions, or use it a single time by separating
    expressions with a semicolon, as shown in the following snippet:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经编写了谐波平均计算的Python实现，你可以使用内置的`timeit`模块（[https://docs.python.org/3/library/timeit.xhtml](https://docs.python.org/3/library/timeit.xhtml)）来测量其性能。当你分析代码时，你应该将其减少到最小部分，以便在比较解决方案时获得准确的图像。`timeit`模块允许你通过将设置代码作为字符串传递给`--setup`选项来将设置代码与你要测量的代码分开。设置代码将只运行一次，并且不会计入你的代码测量中。你可以直接使用`py
    -m timeit`和任何你想要传递的参数来调用模块。你可以多次使用`--setup`选项来分隔多个表达式，或者使用分号将表达式分隔开，如以下代码片段所示：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ❶ Multiple setup expressions can be separated into multiple arguments.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 多个设置表达式可以被分成多个参数。
- en: ❷ Setup expressions can also be separated by a semicolon in a single argument.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 设置表达式也可以在单个参数中通过分号分隔。
- en: 'To avoid setup overhead in your profile measurement, you should perform any
    imports and create data inputs in the setup step. Because you need the `harmonic_
    mean` function and the `random.randint` function, those should be imported as
    setup steps. You also want to measure the performance of `harmonic_mean` against
    a true-to-life set of data. You can create a list of random integers as a setup
    step as well and pass that list to the `harmonic_mean` function in the execution
    step. Your command should look something like the following snippet:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免在分析测量中的设置开销，你应该在设置步骤中执行任何导入和创建数据输入。因为你需要`harmonic_mean`函数和`random.randint`函数，所以这些应该作为设置步骤导入。你还需要测量`harmonic_mean`对一组真实数据的性能。你可以在设置步骤中创建一个随机整数的列表，并在执行步骤中将该列表传递给`harmonic_mean`函数。你的命令应该类似于以下代码片段：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: ❶ Imports the function you want to measure
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 导入你想要测量的函数
- en: ❷ Imports helper functions needed for setup
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 导入设置所需的辅助函数
- en: ❸ Creates data inputs ahead of time
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 提前创建数据输入
- en: ❹ Uses only the function you want to measure in the execution
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 只在执行中使用你想要测量的函数
- en: Run the command now. The `timeit` module will print out the statistics of the
    profile, including
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行命令。`timeit`模块将打印出分析统计信息，包括
- en: How many times it ran the code to get an average execution time (the measurement
    loops)
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行代码以获取平均执行时间的次数（测量循环）
- en: How many sets of measurement loops it ran
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行了多少组测量循环
- en: The best execution time of all the sets of measurements loops
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有测量循环组中的最佳执行时间
- en: 'The following snippet shows the statistics of how the `harmonic_mean` function
    performed on my MacBook Pro with 16 GB of memory and a 2.2 GHz 6-core processor:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了`harmonic_mean`函数在我的16 GB内存和2.2 GHz 6核心处理器的MacBook Pro上的性能统计：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `timeit` module ran five sets of five-measurement loops and ultimately found
    that the call to `harmonic_mean` could run in as short a time as 52.8 milliseconds
    on average. You may see similar results, but they can vary based on what hardware
    you have and what else your computer is using it for at the time of measurement.
    The `timeit` module tries to account for some of these factors using the measurement
    loops. At the end of the day, it’s important to remember that profiling should
    be used to compare one solution to another in a relative manner.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`timeit`模块运行了五组五次测量的循环，最终发现`harmonic_mean`的调用平均可以在52.8毫秒内完成。你可能看到类似的结果，但它们可能根据你的硬件以及测量时的计算机使用情况而有所不同。`timeit`模块试图通过测量循环来考虑这些因素。最终，重要的是要记住，分析应该用于以相对方式比较一个解决方案与另一个解决方案。'
- en: Save the results of your profiling somewhere for later reference, because now
    you’re going to see how you can speed up this calculation to the level CarCorp
    is hoping for.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 将你的分析结果保存到某个地方以供以后参考，因为现在你将看到如何将这个计算速度提升到CarCorp所期望的水平。
- en: 4.2 Creating a C extension for Python
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.2 为 Python 创建 C 扩展
- en: When you write code or install third-party packages, you’re extending the functionality
    of your software beyond what Python alone can provide. Typically, though, you’re
    still using Python to achieve that extension. Just as you can use packages to
    extend functionality, you can also create and use extensions written in other
    languages to improve performance. Because the reference Python interpreter is
    written in the C programming language, C is a common choice for these extensions,
    but people also write extensions in C++ ([http://mng.bz/M0om](http://mng.bz/M0om)),
    Rust ([http://mng.bz/aPwY](http://mng.bz/aPwY)), and even Fortran ([http://mng.bz/gRgn](http://mng.bz/gRgn)).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写代码或安装第三方包时，你正在扩展你的软件功能，使其超越 Python 单独所能提供的功能。通常，尽管如此，你仍然使用 Python 来实现这种扩展。就像你可以使用包来扩展功能一样，你也可以创建和使用用其他语言编写的扩展来提高性能。因为参考
    Python 解释器是用 C 编程语言编写的，C 是这些扩展的常见选择，但人们也用 C++ ([http://mng.bz/M0om](http://mng.bz/M0om))、Rust
    ([http://mng.bz/aPwY](http://mng.bz/aPwY))，甚至 Fortran ([http://mng.bz/gRgn](http://mng.bz/gRgn))
    编写扩展。
- en: You learned about Python build backends in chapter 3, and you used Setuptools
    to start building the skeleton of your package. Setuptools has strong capabilities
    for building extensions from other languages. Other build backends may offer differing
    levels of support for extensions. Any time you’re considering switching your build
    backend, consider any candidate backend’s ability to meet your needs in this area.
    For now, you’ll continue using Setuptools to integrate a C extension into your
    package.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你在第三章学习了 Python 构建后端，并使用 Setuptools 开始构建你的包的骨架。Setuptools 在构建来自其他语言的扩展方面具有强大的功能。其他构建后端可能对扩展的支持程度不同。每次考虑切换构建后端时，都要考虑候选后端在此领域满足你需求的能力。现在，你将继续使用
    Setuptools 将 C 扩展集成到你的包中。
- en: 4.2.1 Creating C extension source code
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.1 创建 C 扩展源代码
- en: Covering in depth the writing of C-level code for use in Python is beyond the
    scope of this book, but because extensions are a common need for numerical programming,
    it’s important to learn how you can integrate them into a Python package. As with
    Python build backends and frontends, extensions and the tools to build them can
    be swapped in and out of your project as needed, and the details are left up to
    whichever tools you decide to invest in.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 深入介绍 C 级代码的编写以供 Python 使用超出了本书的范围，但鉴于扩展在数值编程中是一个常见需求，了解如何将它们集成到 Python 包中是很重要的。与
    Python 构建后端和前端一样，扩展及其构建工具可以根据需要替换到你的项目中，具体细节取决于你决定投资的工具。
- en: To expose you to one available option that also has a low barrier to entry,
    you’ll convert your `harmonic_mean` function into a C extension using *Cython*
    ([https://cython.org/](https://cython.org/)). Not to be confused with CPython,
    the reference implementation of Python, Cython is a compiler and language for
    creating Python C extensions. The Cython language is a superset of Python and,
    at its most basic, can be used to speed up some Python code without requiring
    sweeping changes. The Cython compiler converts Cython source code to optimized
    C code, which will then be compiled during a package’s build process (see figure
    4.1).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让你接触到一个既有低门槛又可用的选项，你将使用 *Cython* ([https://cython.org/](https://cython.org/))
    将你的 `harmonic_mean` 函数转换为一个 C 扩展。不要与 CPython 混淆，它是 Python 的参考实现，Cython 是一个用于创建
    Python C 扩展的编译器和语言。Cython 语言是 Python 的超集，在最基本的情况下，可以用来加速一些 Python 代码，而不需要做出大的改动。Cython
    编译器将 Cython 源代码转换为优化的 C 代码，这些代码将在包构建过程中进行编译（见图 4.1）。
- en: '![](../../OEBPS/Images/04-01.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/04-01.png)'
- en: Figure 4.1 Extensions are compiled into shared libraries that are included in
    binary wheel distributions.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 扩展被编译成共享库，这些库包含在二进制 wheel 分发中。
- en: Cython source files end with .pyx and can contain Python or Cython code. Because
    the Cython language is a superset of Python, a valid Python program is also a
    valid Cython program. Rename your `harmonic_mean.py` module to `harmonic_mean.pyx`
    and move it into the src/imppkg/ directory. Now that you have a Cython source
    code file, you need to integrate Cython into your package’s build process.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Cython 源文件以 .pyx 结尾，可以包含 Python 或 Cython 代码。因为 Cython 语言是 Python 的超集，一个有效的 Python
    程序也是一个有效的 Cython 程序。将你的 `harmonic_mean.py` 模块重命名为 `harmonic_mean.pyx` 并将其移动到 src/imppkg/
    目录下。现在你已经有了一个 Cython 源代码文件，你需要将 Cython 集成到你的包构建过程中。
- en: 4.2.2 Integrating Cython into a Python package build
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.2 将 Cython 集成到 Python 包构建中
- en: You learned in chapter 3 that you can specify dependencies for a Python package’s
    build process in the pyproject.toml file. Cython is a Python package itself, so
    you can add it to the list of build dependencies. This will ensure that Cython
    is installed before the build starts and is available to convert your Cython file
    to C code for compilation. Update the `requires` value in the `build-system` section
    of the pyproject.toml file to include `"cython"` now.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你在第 3 章中学到，你可以在 pyproject.toml 文件中指定 Python 包构建过程的依赖项。Cython 本身就是一个 Python 包，因此你可以将其添加到构建依赖项列表中。这将确保在构建开始之前安装
    Cython，并在编译过程中可用以将你的 Cython 文件转换为 C 代码。现在更新 pyproject.toml 文件中 `build-system`
    部分的 `requires` 值，以包含 `"cython"`。
- en: Next, you’ll need to ensure that your Cython source files are included in your
    package. You also learned in chapter 3 that, when using Setuptools, you can include
    non-Python files in your package using the MANIFEST.in file. You used the `graft`
    directive to include all non-Python source files from the src/ directory. That
    expression also includes all .pyx files. Run the build process using the `pyproject-build`
    command, and confirm that your Cython file ends up in the package as expected.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要确保你的 Cython 源文件包含在你的包中。你也在第 3 章中学到，当使用 Setuptools 时，你可以使用 MANIFEST.in
    文件将非 Python 文件包含在你的包中。你使用了 `graft` 指令来包含来自 src/ 目录的所有非 Python 源文件。该表达式也包括所有 .pyx
    文件。使用 `pyproject-build` 命令运行构建过程，并确认你的 Cython 文件如预期那样包含在包中。
- en: Now that you’ve created and included your Cython code in the package, you need
    to tell Cython to convert it to C code so that it will be compiled. Without this
    step, your friends at CarCorp would only receive the raw .pyx file, which might
    leave them scratching their heads. To run Cython, you’ll need to create one more
    file called setup.py.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经创建并将你的 Cython 代码包含在包中，你需要告诉 Cython 将其转换为 C 代码，以便进行编译。如果不执行此步骤，CarCorp 的朋友们只会收到原始的
    .pyx 文件，这可能会让他们感到困惑。要运行 Cython，你需要创建一个名为 setup.py 的另一个文件。
- en: Why do I see the setup.py file used so widely?
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我看到 `setup.py` 文件被如此广泛地使用？
- en: The setup.py file has been a part of the Python packaging ecosystem for ages—it
    even predates Setuptools. Introduced in PEP 229 ([https://www.python.org/dev/peps/pep-0229/](https://www.python.org/dev/peps/pep-0229/))
    in 2000, its goal was to centralize where packaging configuration happens. You’ll
    likely see that a wide variety of packages still use it, and although it’s still
    necessary for some use cases, the new build workflow and tools you learned in
    chapters 2 and 3 are intended to replace setup.py in the long term. For pure-Python
    packages that don’t need to determine any dynamic information at build time, you
    can use pyproject.toml to define your build and setup.cfg for configuration when
    using Setuptools as your build backend.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`setup.py` 文件已经一直是 Python 打包生态系统的一部分——它甚至早于 Setuptools。它在 2000 年的 PEP 229 ([https://www.python.org/dev/peps/pep-0229/](https://www.python.org/dev/peps/pep-0229/))
    中被引入，其目标是集中化打包配置发生的地方。你可能会看到许多不同的包仍在使用它，尽管它对于某些用例仍然是必要的，但你在第 2 章和第 3 章中学到的新的构建工作流程和工具旨在长期替代
    `setup.py`。对于不需要在构建时确定任何动态信息的纯 Python 包，你可以使用 pyproject.toml 来定义你的构建，并使用 setup.cfg
    作为使用 Setuptools 作为构建后端时的配置。'
- en: Exercise 4.2
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 4.2
- en: 'Create the `setup.py` module in the root directory of your project. The module
    must do the following:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的项目根目录中创建 `setup.py` 模块。该模块必须执行以下操作：
- en: Import the `setuptools.setup` function for hooking into the build process
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入 `setuptools.setup` 函数以挂钩到构建过程
- en: Import the `Cython.Build.cythonize` function for identifying which Cython files
    need to be converted
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入 `Cython.Build.cythonize` 函数以识别哪些 Cython 文件需要被转换
- en: Call `cythonize` with the path to your Cython file, relative to the root directory
    of the project
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `cythonize` 命令并指定你的 Cython 文件路径，该路径相对于项目的根目录
- en: Call the `setup` function with the `ext_modules` keyword argument set to the
    result of the `cythonize` call
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `cythonize` 调用的结果将 `ext_modules` 关键字参数设置给 `setup` 函数
- en: 'Now that you’ve created the `setup.py` module, you have a configuration that
    will convert your Cython files to C code and then compile it during the package
    build process. Run the build now. You should see the following new lines in the
    output that can help verify things are working as you expect:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经创建了 `setup.py` 模块，你有一个配置，它将在包构建过程中将你的 Cython 文件转换为 C 代码，然后进行编译。现在运行构建。你应该在输出中看到以下新行，这有助于验证一切是否按预期工作：
- en: Cython is installed as a build dependency.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cython 作为构建依赖项已安装。
- en: Your Cython file is pulled into the source distribution.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的 Cython 文件被拉入源分布。
- en: The `build_ext` process is triggered by your call to `setuptools.setup`.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`build_ext` 过程是由你调用 `setuptools.setup` 触发的。'
- en: The extension is compiled to a binary file (.so for macOS and Linux, or .pyd
    for Windows) and added to the binary wheel distribution.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展被编译为二进制文件（macOS 和 Linux 上的 .so，或 Windows 上的 .pyd）并添加到二进制轮分布中。
- en: '[PRE3]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ❶ Cython is installed as a build dependency.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ Cython 被安装为一个构建依赖项。
- en: ❷ Your Cython file is copied into the source distribution.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 你的 Cython 文件被复制到源分布中。
- en: ❸ Setuptools builds your extension.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ Setuptools 构建你的扩展。
- en: ❹ The created binary file is copied into the binary wheel distribution.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 创建的二进制文件被复制到二进制轮分布中。
- en: Additionally, you should see in the dist/ directory that your binary wheel distribution
    file has changed names. Before, it was first_python_package-0.0.1-py3-none-any.whl.
    Now, its name will depend on the system you’re using and the Python version you
    used. On my MacBook Pro with Python 3.10, the file is named first_python_package-0.0.1-cp310-cp310-macosx_11_0_x86_64.whl.
    You’ll learn more about why this is so later in this chapter. For now, continue
    to the next section where you’ll install and profile the C extension version of
    your `harmonic_mean` function.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你应在 dist/ 目录中看到你的二进制轮分布文件已更改名称。之前，它名为 first_python_package-0.0.1-py3-none-any.whl。现在，其名称将取决于你使用的系统和
    Python 版本。在我的 MacBook Pro 上，使用 Python 3.10，文件名为 first_python_package-0.0.1-cp310-cp310-macosx_11_0_x86_64.whl。你将在本章后面了解更多关于为什么是这样的原因。现在，继续到下一节，你将在那里安装和配置你的
    `harmonic_mean` 函数的 C 扩展版本。
- en: 4.2.3 Installing and profiling your C extension
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.3 安装和配置你的 C 扩展
- en: 'You’ve gone to all the work of building your package several times now, but
    you have yet to install it. In chapter 2, you created a virtual environment in
    the .venv/ directory, located in the root of your package directory. You can use
    this environment to test the installation of your package. Use the `pip` module
    to install it using the following command from the root directory of your project.
    The `.` indicates that pip should install the current directory as a package:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经多次投入了构建你的包的工作，但你还没有安装它。在第2章中，你在你的包目录的根目录下创建了一个名为 .venv/ 的虚拟环境。你可以使用这个环境来测试你的包的安装。使用以下命令从你的项目的根目录使用
    `pip` 模块来安装它：The `.` 表示 pip 应该将当前目录作为包安装：
- en: '[PRE4]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ Installs the current directory as a package
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 将当前目录安装为包
- en: 'After the command completes, your `first-python-package` package will be installed
    just as if it had been installed from PyPI! You should still be able to import
    your `harmonic_mean` module and use the `harmonic_mean` function, but this time,
    it will resolve to the installed package instead of directly from the source code.
    Try it in the Python interpreter, as shown in the following snippet:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 命令完成后，你的 `first-python-package` 包将像从 PyPI 安装一样安装！你应该仍然能够导入你的 `harmonic_mean`
    模块并使用 `harmonic_mean` 函数，但这次，它将解析为已安装的包而不是直接从源代码中。在 Python 解释器中尝试，如下面的代码片段所示：
- en: '[PRE5]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Because your pure-Python version was importable as `harmonic_mean.harmonic_mean`
    but the C extension is imported from `imppkg.harmonic_mean.harmonic_mean`, you
    need to update the setup step to profile this new implementation.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 因为你的纯 Python 版本可以作为 `harmonic_mean.harmonic_mean` 导入，但 C 扩展是从 `imppkg.harmonic_mean.harmonic_mean`
    导入的，所以你需要更新设置步骤来配置这个新的实现。
- en: Exercise 4.3
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 4.3
- en: 'Run the command to measure the performance of the C extension version of your
    `harmonic_mean` function. As before, your setup step should do the following:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 运行命令来测量你的 `harmonic_mean` 函数的 C 扩展版本的性能。和之前一样，你的设置步骤应该执行以下操作：
- en: Import the `harmonic_mean` function
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入 `harmonic_mean` 函数
- en: Import `random.randint`
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入 `random.randint`
- en: Create a list of one million random numbers with values between 1 and 1,000
    using the built-in `random.randint` function
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用内置的 `random.randint` 函数创建一个包含一百万个介于 1 和 1,000 之间的随机数的列表
- en: The code you measure should only be the call to your `harmonic_mean` function
    with the list of random numbers as input.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你要测量的代码应该是调用你的 `harmonic_mean` 函数，并使用随机数列表作为输入。
- en: 'What do you see? Compare the results to your earlier measurement of the pure-Python
    implementation. Remember that you haven’t changed the code you had to write—you
    changed only the filename and told Cython how to handle it. On my system, this
    change alone resulted in the following statistics:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到了什么？将结果与你的早期对纯 Python 实现的测量结果进行比较。记住，你没有改变你必须写的代码——你只改变了文件名，并告诉 Cython 如何处理它。在我的系统中，这个改变单独导致了以下统计结果：
- en: '[PRE6]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You read that correctly—the C extension version of the code can run as quickly
    as 18.5 milliseconds, nearly *three times* faster than the pure-Python implementation.
    And Cython did all the heavy lifting! Now, what about that binary wheel distribution
    file?
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 你读得对——代码的C扩展版本可以运行得像18.5毫秒一样快，几乎比纯Python实现快三倍。而Cython做了所有繁重的工作！现在，关于那个二进制轮分布文件呢？
- en: 4.2.4 Build targets for binary wheel distributions
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.4 二进制轮分布的构建目标
- en: Although the performance you gained using Cython could be considered an easy
    win, it isn’t without its trade-offs. When you write packages using Python alone,
    they’re extremely portable—any system running a compatible Python version can
    run your code. As soon as you introduce code that must be compiled, everything
    changes.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然使用Cython获得的成绩可能被认为是一个容易的胜利，但它并非没有代价。当你仅使用Python编写包时，它们极其便携——任何运行兼容Python版本的系统都可以运行你的代码。一旦引入必须编译的代码，一切都会改变。
- en: Some of the most performant programming languages are able to achieve their
    speed through static typing, predefined memory allocation, and a compilation step
    prior to runtime. These features are valuable in computation-heavy contexts. Unfortunately,
    many of these same features also rely on knowledge of the computer architecture
    and operating system on which they’re running. Performance is often gained by
    exploiting features and behavior of these systems, so what works in one place
    won’t necessarily work in another. In the worst cases, it can actually cause memory
    corruption and failed execution if run in the wrong context.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 一些性能最优秀的编程语言能够通过静态类型、预定义内存分配以及在运行前进行的编译步骤来达到它们的速度。这些特性在计算密集型环境中非常有价值。不幸的是，许多这些相同的特性也依赖于它们运行的计算机架构和操作系统的知识。性能通常是通过利用这些系统的特性和行为来获得的，所以在一个地方有效的方法不一定在另一个地方也有效。在最坏的情况下，如果在错误的环境中运行，这实际上可能导致内存损坏和执行失败。
- en: 'Because of the nuances of execution, source code for these languages must typically
    be compiled separately for each of the architectures and operating systems where
    it will be used. Take another look at the binary wheel distribution file in the
    dist/ directory. Its filename is divided into several important sections (see
    figure 4.2). The first two are the normalized package name and version. These
    may be followed by an optional build number. The last three parts are tags that
    identify the compatibility of the binary wheel as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 由于执行细节，这些语言的源代码通常必须为它将使用的每个架构和操作系统分别编译。再次看看dist/目录中的二进制轮分布文件。其文件名分为几个重要部分（见图4.2）。前两部分是标准化包名和版本。这些可能后面跟着一个可选的构建号。最后三部分是标识二进制轮兼容性的标签，如下所示：
- en: '*Python version*—Which implementation of Python the code must execute on'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Python版本*—代码必须执行的Python实现'
- en: '*Application binary interface (ABI)*—How the binary of the compiled code is
    organized'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*应用程序二进制接口（ABI）*—编译代码的二进制组织方式'
- en: '*Platform*—Which operating system and CPU architecture the code must execute
    on'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*平台*—代码必须执行的操作系统和CPU架构'
- en: '![](../../OEBPS/Images/04-02.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../../OEBPS/Images/04-02.png)'
- en: Figure 4.2 The anatomy of a binary wheel distribution filename
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2 二进制轮分布文件的结构
- en: When you install packages, your package manager will determine which binary
    wheel distributions are available and use these tags to identify which of those
    it should download for your system. As an example, the binary wheel distribution
    file first_python _package-0.0.1-cp310-cp310-macosx_11_0_x86_64.whl is compatible
    with the CPython 3.10 implementation, the CPython 3.10 API, and the macOS 11 operating
    system running on an x86 64-bit CPU architecture.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当你安装包时，你的包管理器将确定哪些二进制轮分布可用，并使用这些标签来识别它应该为你的系统下载哪些。例如，二进制轮分布文件first_python_package-0.0.1-cp310-cp310-macosx_11_0_x86_64.whl与CPython
    3.10实现、CPython 3.10 API以及运行在x86 64位CPU架构上的macOS 11操作系统兼容。
- en: 'You might notice that three of these filename segments relate to the number
    of binary wheel distributions you would need to build to cover all possible targets.
    Fortunately, the first two segments—the Python implementation and ABI version—are
    usually identical. On the other hand, some operating systems can run on different
    CPU architectures, so that single tag is really two pieces of information. This
    all boils down to the Python implementations, operating systems, and CPU architectures
    you want to support. That means the number of binary wheel distributions you need
    to build is roughly the following:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到这三个文件名部分与构建覆盖所有可能目标所需的二进制wheel分布数量有关。幸运的是，前两个部分——Python实现和ABI版本——通常是相同的。另一方面，一些操作系统可以在不同的CPU架构上运行，所以这个单一标签实际上是两块信息。这一切都归结为你想要支持的Python实现、操作系统和CPU架构。这意味着你需要构建的二进制wheel分布的数量大致如下：
- en: '*N*[Python implementations] ∙ *N*[Operating systems] ∙ *N*[CPU architectures]'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '*N*[Python实现] ∙ *N*[操作系统] ∙ *N*[CPU架构]'
- en: As an example, at the time of this writing, the NumPy project ([https://numpy.org/](https://numpy.org/))
    supports CPython 3.7, 3.8, and 3.9 as well as PyPy 3.7\. It supports these across
    different architectures for each of macOS, Linux, and Windows. In all, each release
    of NumPy makes twenty-seven wheels available. This sounds like a lot of work,
    and as a lone maintainer, that’s probably true. But because NumPy is so central
    to the scientific community for building performant numerical software, the project
    maintainers are willing to put in this effort on an infrequent basis to deliver
    the performance their users need all the time.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 以一个例子来说，在撰写本文时，NumPy项目([https://numpy.org/](https://numpy.org/))支持CPython 3.7、3.8和3.9，以及PyPy
    3.7。它支持这些在不同架构上针对macOS、Linux和Windows的每个版本。总的来说，每个NumPy发布版本提供了二十七个wheel。这听起来像是一项大量工作，作为一个单独的维护者，这可能确实是正确的。但是，由于NumPy对于构建高性能数值软件对科学社区来说如此关键，项目维护者愿意不定期地投入这份努力，以提供用户始终需要的性能。
- en: 4.2.5 Specifying required Python versions
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.2.5 指定所需的Python版本
- en: You may build packages that are only compatible with features or syntax available
    since a specific Python version. When this is the case, it’s best to specify this
    in your setup.cfg file because when you eventually publish your package, it will
    only be available when users try to install it using a compatible Python version.
    This reduces confusion and surprise.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能构建的包只与特定Python版本中可用的功能或语法兼容。在这种情况下，最好在setup.cfg文件中指定这一点，因为当你最终发布你的包时，它只有在用户尝试使用兼容的Python版本安装它时才会可用。这减少了混淆和惊喜。
- en: 'You can specify the required Python version or range of versions with the `python
    _requires` keyword in the `[options]` section of the setup.cfg file, using the
    same PEP 440 ([https://peps.python.org/pep-0440/](https://peps.python.org/pep-0440/))
    version specifiers that you use to specify package versions. Add this to your
    setup.cfg file now. It should look like the following:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用setup.cfg文件中[options]部分的`python _requires`关键字来指定所需的Python版本或版本范围，使用与指定包版本相同的PEP
    440 ([https://peps.python.org/pep-0440/](https://peps.python.org/pep-0440/))版本规范符。现在就将这个添加到你的setup.cfg文件中。它应该看起来像以下这样：
- en: '[PRE7]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: When users try to install your package using Python 3.8 or earlier, they’ll
    see a message that no compatible versions of the package are available.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户尝试使用Python 3.8或更早版本安装你的包时，他们会看到一个消息，表明没有可用的兼容版本。
- en: So far, you’ve built one pure-Python wheel and one wheel specific to your Python
    implementation and platform. This might seem like a far cry from the scale at
    which projects like NumPy are operating. Fortunately, some tools have emerged
    that can ease the burden of building these wheels, and you’ll learn more about
    them in chapter 7\. For the moment, rejoice that you’ve built a working Python
    package and get ready to handle that second request from CarCorp.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经构建了一个纯Python wheel和一个针对你的Python实现和平台的特定wheel。这可能与像NumPy这样的项目所运作的规模相去甚远。幸运的是，一些工具已经出现，可以减轻构建这些wheel的负担，你将在第7章中了解更多关于它们的信息。现在，庆祝你已经构建了一个工作的Python包，并准备好处理CarCorp的第二项请求。
- en: 4.3 Offering command-line tools from a Python package
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.3 从Python包提供命令行工具
- en: CarCorp wants to be able to run a standalone command to quickly calculate harmonic
    means. They’re familiar with using a shell to run commands, but not as familiar
    with using Python to write and run scripts. Fortunately, most Python build systems
    also support this. You can tell these systems that, as part of the installation
    process, some part of the code should be exposed as a runnable command. In the
    following sections, you’ll learn how Setuptools handles this use case.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: CarCorp 希望能够运行一个独立的命令来快速计算调和平均值。他们熟悉使用 shell 运行命令，但不太熟悉使用 Python 编写和运行脚本。幸运的是，大多数
    Python 构建系统也支持这一点。你可以告诉这些系统，作为安装过程的一部分，代码的一部分应该作为可运行的命令公开。在接下来的章节中，你将了解 Setuptools
    如何处理这种用例。
- en: 4.3.1 Creating commands with Setuptools entry points
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 4.3.1 使用 Setuptools 入口点创建命令
- en: Setuptools enables you to provide commands to users through what it calls *entry
    points*. An entry point is like a door—a way in and out of a place. Setuptools
    entry points provide a way into a package’s functionality in a discoverable way.
    Named commands are one such way of exposing those entry points.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Setuptools 允许你通过它所说的 *入口点* 向用户提供命令。入口点就像一扇门——进入和离开的地方。Setuptools 入口点提供了一种以可发现的方式进入包功能的方法。命名命令是暴露这些入口点的一种方式。
- en: You’re likely familiar with the `if __name__ == "__main__":` syntax used in
    many Python scripts intended for command-line use. When you run `python some.py`,
    the `__name__` for `some.py` will be `"__main__"`, and the code in the conditional
    will run. Commands are a more generalized and flexible version of this concept.
    At a high level, you create a command in Setuptools by mapping a name for the
    command to the dotted module path of a function. As an example, imagine you want
    a command named `harmony` that supplies the calculation behavior from the `imppkg.harmonic_mean
    .harmonic_mean` function. Instead of requiring you to run `python harmonic_mean.py`
    and respond with `if __name__ == "__main__"` in your code, an entry point enables
    you to run the `harmony` command and point to a function that calls `imppkg.harmonic_
    mean.harmonic_mean` with the arguments from the command (see table 4.1).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能熟悉在许多用于命令行使用的 Python 脚本中使用的 `if __name__ == "__main__":` 语法。当你运行 `python
    some.py` 时，`some.py` 的 `__name__` 将是 `"__main__"`，条件语句中的代码将运行。命令是这种概念的更通用和更灵活的版本。从高层次来看，你通过将命令的名称映射到函数的点分模块路径来在
    Setuptools 中创建一个命令。例如，假设你想要一个名为 `harmony` 的命令，它从 `imppkg.harmonic_mean .harmonic_mean`
    函数提供计算行为。而不是要求你运行 `python harmonic_mean.py` 并在代码中响应 `if __name__ == "__main__"`，入口点允许你运行
    `harmony` 命令并指向一个调用 `imppkg.harmonic_ mean.harmonic_mean` 并带有命令参数的函数（见表 4.1）。
- en: Table 4.1 The different ways to execute code from a Python module
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4.1 从 Python 模块执行代码的不同方式
- en: '| Approach | Command | Requires installation | Pros | Cons |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| 方法 | 命令 | 是否需要安装 | 优点 | 缺点 |'
- en: '| Execute module directly | `$ py /path/to/package/src/imppkg/harmony.py [args]`
    | No |  | Imports within code may not work |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| 直接执行模块 | `$ py /path/to/package/src/imppkg/harmony.py [args]` | 否 |  | 代码内部的导入可能无法工作
    |'
- en: '| Execute as importable module | `$ py -m imppkg.harmony [args]` | No (works
    for any importable code) | Imports within code work | Long command, requires knowledge
    of package structure |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| 作为可导入模块执行 | `$ py -m imppkg.harmony [args]` | 否（适用于任何可导入的代码） | 代码内部的导入可以工作
    | 命令行较长，需要了解包结构 |'
- en: '| Execute as entry point | `$ harmony [args]` | Yes | Short command, no knowledge
    of package structure required |  |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| 作为入口点执行 | `$ harmony [args]` | 是 | 命令简短，不需要了解包结构 |  |'
- en: To create a command entry point, you first need to create the handler function.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个命令入口点，首先需要创建处理函数。
- en: Exercise 4.4
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 4.4
- en: Add a new Python module in your src/imppkg/ directory called `harmony.py`. Inside
    that module, create a `main` function that
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的 src/imppkg/ 目录中添加一个新的 Python 模块，名为 `harmony.py`。在该模块内部，创建一个 `main` 函数，
- en: Uses `sys.argv` to get the arguments from the command line
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `sys.argv` 从命令行获取参数
- en: Converts the arguments to a list of floating-point numbers
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将参数转换为浮点数列表
- en: Calls `imppkg.harmonic_mean.harmonic_mean`, passing in the list of numbers
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用 `imppkg.harmonic_mean.harmonic_mean`，传入数字列表
- en: Prints the calculated mean of the numbers
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印计算出的数值平均值
- en: Remember to import `sys` and `imppkg.harmonic_mean.harmonic_mean`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 记得导入 `sys` 和 `imppkg.harmonic_mean.harmonic_mean`。
- en: 'With your handling function in place, you can now configure Setuptools to make
    it available as a command. You tell Setuptools where to look for the command using
    the `[options.entry_points]` section in the setup.cfg file. This section is a
    table mapping the entry point group to (command name, handler function) pairs.
    For commands, the entry point group is `console_scripts`. You’ve already used
    one console script in your packaging adventure so far: the `build` tool provides
    the `pyproject-build` command as a console script ([http://mng.bz/2nBX](http://mng.bz/2nBX)).'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的处理函数就位后，你现在可以配置 Setuptools 使其作为一个命令可用。你告诉 Setuptools 在 setup.cfg 文件的 `[options.entry_points]`
    部分查找命令。这个部分是一个将入口点组映射到（命令名称，处理函数）对的表格。对于命令，入口点组是 `console_scripts`。你已经在你的打包冒险中使用了其中一个控制台脚本：`build`
    工具提供了一个控制台脚本 `pyproject-build` 命令（[http://mng.bz/2nBX](http://mng.bz/2nBX)）。
- en: What other entry point types are there?
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 有哪些其他的入口点类型？
- en: The entry points system in Setuptools is quite flexible. The `console_scripts`
    group is the convention used for creating command-line tools, but a group can
    be any other valid string. This can be used to coordinate functionality *across*
    packages if they agree on a convention for an entry point, making plugin-based
    architectures possible. pytest, a popular testing package that you’ll learn more
    about in chapter 5, uses this approach so others can write testing plugins ([http://mng.bz/R4jP](http://mng.bz/R4jP)).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Setuptools 的入口点系统非常灵活。`console_scripts` 组是创建命令行工具的惯例，但组可以是任何其他有效的字符串。如果它们同意一个入口点的约定，这可以用来协调跨包的功能，使得基于插件的架构成为可能。pytest，你将在第
    5 章中了解更多信息，使用这种方法，其他人可以编写测试插件（[http://mng.bz/R4jP](http://mng.bz/R4jP)）。
- en: Different packages can find each other’s software without knowing specifics
    about it ahead of time, which is a powerful offering for extensibility (see Dane
    Hillard, “Extensibility and Flexibility,” *Practices of the Python Pro*, Manning
    Publications, 2020, pp. 147–142, [http://mng.bz/m2N0](http://mng.bz/m2N0)). If
    you want to build a package that others can extend without you needing to be involved,
    this is an area to look further into on your own.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的包可以在不知道具体信息的情况下找到彼此的软件，这是扩展性的强大功能（参见 Dane Hillard，“扩展性和灵活性”，《Python 高手实践》，Manning
    出版公司，2020 年，第 147-142 页，[http://mng.bz/m2N0](http://mng.bz/m2N0)）。如果你想构建一个其他人可以扩展而无需你参与的包，这是你需要进一步探索的领域。
- en: 'Write the entry points section now. It should look like the following snippet:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 现在编写入口点部分。它应该看起来像以下片段：
- en: '[PRE8]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: ❶ Where Setuptools looks for entry points
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ Setuptools 查找入口点的位置
- en: ❷ The group for creating runnable commands
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 创建可运行命令的组
- en: ❸ A map of command names to handler functions
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 命令名称到处理函数的映射
- en: 'Now that you have a handler function and Setuptools knows to make it available
    through the `harmony` command, it’s time to verify that it works. Reinstall your
    package into your virtual environment now. Once that completes, run the following
    command from the root directory of your project:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经有一个处理函数，并且 Setuptools 知道通过 `harmony` 命令使其可用，现在是时候验证它是否正常工作了。现在将你的包重新安装到你的虚拟环境中。一旦完成，从你项目的根目录运行以下命令：
- en: '[PRE9]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You should see the following output:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到以下输出：
- en: '[PRE10]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Tip Notice that you had to include the `.venv/bin/` prefix for the command.
    When a user installs your package into their active virtual environment or a base
    Python version, the installed command will automatically be added to their PATH,
    and the prefix won’t be necessary.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士 注意，你必须包含 `.venv/bin/` 前缀来执行命令。当用户将你的包安装到他们的活动虚拟环境或基础 Python 版本中时，安装的命令将自动添加到他们的
    PATH 中，前缀将不再必要。
- en: You now have a buildable, installable Python package that delivers a fast calculation
    for harmonic means. Confident you’ve satisfied the functionality CarCorp asked
    for, you decide you want to wow them with something they didn’t know they needed.
    Because working in a console often means finding lines of interest in a wall of
    text, you want the `harmony` output to really pop. You decide you want to add
    colorized text, but you don’t have the time to learn ANSI escape sequences. You
    decide to install another package to handle this for you.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在有一个可构建、可安装的 Python 包，它可以快速计算调和平均值。自信你已经满足了 CarCorp 所要求的功能，你决定想要用一些他们不知道需要的东西来让他们印象深刻。因为通常在控制台中工作意味着在文本墙中找到感兴趣的行，你希望
    `harmony` 的输出非常突出。你决定想要添加彩色文本，但你没有时间学习 ANSI 转义序列。你决定安装另一个包来为你处理这个问题。
- en: 4.4 Specifying dependencies for Python packages
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 4.4 指定 Python 包的依赖关系
- en: Up to now, your package has not depended on any third-party Python packages.
    Now that you want to add one, it might be tempting to install it directly into
    your virtual environment using pip. Unfortunately, this won’t work for your users
    because they would also need to install the package themselves. Remember from
    chapter 1 that a major part of the value of package management systems is dependency
    resolution and installation. What you really want to do is specify to the Python
    package management tools that your package has a dependency and let them manage
    installation for you. This will help you get the dependency, but it will also
    help your users get it. A win all around!
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您的包尚未依赖于任何第三方Python包。现在您想添加一个，可能会诱使您直接使用pip将其安装到您的虚拟环境中。不幸的是，这对您的用户来说是不行的，因为他们也需要自己安装该包。记住第1章中提到的，包管理系统的价值之一就是依赖项解析和安装。您真正想要做的是指定给Python包管理工具，您的包有一个依赖项，并让他们为您管理安装。这将帮助您获取依赖项，但也会帮助您的用户获取它。这是一个全赢的局面！
- en: 'Specifying dependencies for packages is similar to the familiar route of using
    something like a requirements.txt file to list your dependencies, but with the
    following two key differences:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 为包指定依赖项类似于使用类似requirements.txt文件列出依赖项的熟悉方法，但有以下两个关键区别：
- en: Dependencies need to be specified where your build system will see them so that
    the dependencies can be incorporated into the metadata package managers use to
    resolve and install dependencies.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖项需要指定在您的构建系统可以看到它们的地方，这样依赖项就可以被纳入包管理器使用的元数据中，以解析和安装依赖项。
- en: Dependencies should be specified as loosely as they can be to maximize compatibility
    for users.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖项应尽可能宽松地指定，以最大化用户的兼容性。
- en: 'Important To emphasize that last point: packages should avoid being pinned
    to an exact package version when they don’t need to be. Imagine that you and I
    each create a package and they both depend on the `requests` package. Now imagine
    someone wants to use them both in their project. They install yours, but when
    they try to install mine, they get an error saying that my package depends on
    `requests==2.1.1`, but your package depends on `requests==2.1.2`. There’s no way
    forward through this issue because solving the problem for one package creates
    a problem for the other.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 重要：强调最后一点：当包不需要时，应避免将其锁定到确切版本。想象一下，我和你各自创建了一个包，它们都依赖于`requests`包。现在想象一下，有人想在他们的项目中使用它们。他们安装了您的包，但当尝试安装我的包时，他们收到一个错误，说我的包依赖于`requests==2.1.1`，而您的包依赖于`requests==2.1.2`。这个问题没有前进的道路，因为解决一个包的问题会为另一个包创造问题。
- en: If instead we both make our packages depend on `requests>=2.1.1,<3`, any version
    of requests greater than 2.1.0 and less than 3.X will work for the user. As the
    user installs more packages with more dependency specifications, this ensures
    that we don’t unnecessarily narrow the space of valid dependency combinations
    for them.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们双方都将我们的包依赖于`requests>=2.1.1,<3`，那么对于用户来说，任何大于2.1.0且小于3.X版本的requests都将适用。随着用户安装更多具有更多依赖项指定的包，这确保了我们不会不必要地缩小他们有效依赖项组合的空间。
- en: Another benefit to using looser dependency definitions for packages is that
    you can find issues caused by upstream packages sooner. If you pin to an exact
    version for six months and then try to upgrade later, you may find a cascade of
    issues and have to spend a whole day getting back up to speed. If you loosely
    define dependencies, you’ll uncover those issues any time you reinstall dependencies
    for the package during development and testing. Dealing with new issues so frequently
    can feel daunting at first, but you’ll appreciate iterating on these comparatively
    smaller changes regularly rather than having to put out a proverbial fire every
    few months.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 使用更宽松的依赖定义对包的另一个好处是，您可以更快地发现由上游包引起的问题。如果您将版本锁定在确切版本上六个月，然后稍后尝试升级，您可能会发现一系列问题，并需要花费整整一天的时间来恢复速度。如果您宽松地定义依赖项，您将在开发测试过程中重新安装包的依赖项时发现这些问题。最初处理这些问题可能会感到令人畏惧，但您会欣赏定期对这些相对较小的更改进行迭代，而不是每隔几个月就要扑灭一场所谓的“大火”。
- en: Setuptools looks for package dependencies in the `install_requires` key of the
    `[options]` section in the setup.cfg file. The `install_requires` value is a list
    of dependencies specified using the same syntax you would use in a requirements.txt
    file. To add some color to the output of the `harmony` command, you’ll use the
    `termcolor` package. As of this writing, the latest release of termcolor is 1.1.0\.
    Because you aren’t going to test earlier versions and you trust them to maintain
    existing features until at least the 2.0.0 release, you can specify `termcolor>=1.1.0,<2`
    as the version.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Setuptools 在 setup.cfg 文件的 `[options]` 部分的 `install_requires` 键中查找包依赖项。`install_requires`
    的值是一个使用与 requirements.txt 文件中相同的语法指定的依赖项列表。为了给 `harmony` 命令的输出添加一些颜色，你将使用 `termcolor`
    包。截至本文撰写时，termcolor 的最新版本是 1.1.0。因为你不会测试早期版本，并且你信任它们至少在 2.0.0 版本发布之前维护现有功能，你可以指定
    `termcolor>=1.1.0,<2` 作为版本。
- en: 'Add the `install_requires` key now. It should look like the following snippet:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在添加 `install_requires` 键。它应该看起来像以下片段：
- en: '[PRE11]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, when your package is installed, pip will also download and install the
    latest 1.X version of `termcolor`. With this in place, you can make use of `termcolor`
    in your `harmony.py` module. Instead of using the built-in `print` function to
    print the result of the harmonic mean calculation, import and use the `termcolor.cprint`
    function. This function accepts additional arguments compared to `print`, described
    here:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你的包安装后，pip 也会下载并安装 `termcolor` 的最新 1.X 版本。有了这个，你就可以在你的 `harmony.py` 模块中使用
    `termcolor`。不要使用内置的 `print` 函数来打印调和平均值的计算结果，而是导入并使用 `termcolor.cprint` 函数。这个函数比
    `print` 函数接受更多的参数，如下所述：
- en: An optional foreground color specifier, like `'red'` or `'green'`
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选的前景色指定符，例如 `'red'` 或 `'green'`
- en: An optional background color specifier, like `'on_cyan'` or `'on_red'`
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选的背景颜色指定符，例如 `'on_cyan'` 或 `'on_red'`
- en: An `attrs` list for styles, like `['bold', 'italic']`
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 样式列表的 `attrs`，例如 `['bold', 'italic']`
- en: Exercise 4.5
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 练习4.5
- en: Replace the `print` call in the `harmony.py` module with a call to `termcolor.cprint`.
    The text should be bold and red on a cyan background. Reinstall your package and
    rerun the `harmony` command to confirm that the output looks as you expect.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `harmony.py` 模块中的 `print` 调用替换为对 `termcolor.cprint` 的调用。文本应该是粗体红色，背景为青色。重新安装你的包并重新运行
    `harmony` 命令以确认输出看起来如你所预期。
- en: Looking spectacular? If not, play around with the values for `termcolor` and
    find a color scheme that you like.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来很壮观吗？如果不是，请尝试调整 `termcolor` 的值，找到你喜欢的配色方案。
- en: You now have something fairly polished that you can think about shipping to
    CarCorp. But you have a nagging feeling they’ll be asking for more functionality
    soon. When you’re ready, continue on to chapter 5 to see how you can integrate
    your test suite to verify your changes as your package grows.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在有一个相当完善的版本，可以考虑将其发送给 CarCorp。但你有一种不安的感觉，他们很快就会要求更多功能。当你准备好时，继续阅读第5章，了解如何将你的测试套件集成以验证你的更改，随着你的包的增长。
- en: Answer to exercises
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习答案
- en: '**4.1**'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '**4.1**'
- en: '[PRE12]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '**4.2**'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '**4.2**'
- en: '[PRE13]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '**4.3**'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '**4.3**'
- en: '[PRE14]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '**4.4**'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '**4.4**'
- en: '[PRE15]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '**4.5**'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '**4.5**'
- en: '[PRE16]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Summary
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Explore non-Python extensions by first using a high-level translation layer
    like Cython.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过首先使用像 Cython 这样的高级翻译层来探索非Python扩展。
- en: Providing a non-Python extension gains runtime performance but adds build time
    complexity, either for you or your consumer.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供非Python扩展可以获得运行时性能，但会增加构建时间复杂度，无论是对你还是对你的消费者。
- en: Entry points into your package offer more ways of interacting with its behavior
    than just importing the code.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的包的入口点提供了比仅仅导入代码更多与它的行为交互的方式。
- en: Leverage the power of package management systems to handle dependency resolution
    for you.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用包管理系统的力量来为你处理依赖项解析。
