- en: 10 Link prediction
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 10 链接预测
- en: This chapter covers
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章节涵盖
- en: Discussing the link prediction workflow
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨论链接预测工作流程
- en: Introducing link prediction dataset split
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍链接预测数据集划分
- en: Constructing link prediction features based on node pairs
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于节点对构建链接预测特征
- en: Training and evaluating a supervised link prediction classification model
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 训练和评估监督链接预测分类模型
- en: Most real-world networks are dynamic and evolve through time. Take, for example,
    a friendship network of people. People’s friends change over time. They might
    meet new people or cease to associate with others. You might assume new connections
    form randomly in a friendship network; however, it turns out that most real-world
    networks have a profound organizing principle. The studies around link prediction
    are focused on identifying and understanding various network-evolving mechanisms
    and applying them to predict future links.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数现实世界的网络都是动态的，并且随时间演变。以人们的友谊网络为例。人们的朋友会随时间变化。他们可能会遇到新的人或停止与某些人交往。你可能会认为在友谊网络中新的连接是随机形成的；然而，事实证明，大多数现实世界的网络都有一个深刻的组织原则。围绕链接预测的研究集中在识别和理解各种网络演变机制，并将它们应用于预测未来链接。
- en: Figure 10.1 shows a small network of people, where the relationships represent
    friendships. Solid lines represent existing connections. As mentioned, friendship
    networks evolve over time, and people form new connections. Intuitively, you might
    assume that Luke and Rajiv in figure 10.1 are more likely to form a future connection,
    visualized with a dotted line, than Jose and Alice, due to being closer in the
    network. Unsurprisingly, the number of common friends between a pair of individuals
    is a good indicator of whether they are likely to meet in the future. Simply put,
    the closer two individuals are in the network, the higher the probability of forming
    future links. Predicting future links within a network is the main objective of
    the link prediction field. Accurately predicting future links can be used in recommender
    systems, or it can be used to better understand the network organizing principles.
    Imagine a bipartite network composed of users and products in which the connections
    represent the products they purchased. In this example, link prediction techniques
    could be instrumental in predicting future user-product relations, allowing you
    to implement personalized product recommendations.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1展示了一个小规模的人际网络，其中关系代表友谊。实线表示现有连接。正如之前提到的，友谊网络会随时间演变，人们会形成新的连接。直观地，你可能会认为图10.1中的Luke和Rajiv比Jose和Alice更有可能形成未来的连接，用虚线表示，因为他们在网络中更接近。不出所料，一对个体之间的共同朋友数量是他们未来是否可能相遇的好指标。简单来说，两个个体在网络中越接近，形成未来链接的概率就越高。预测网络中的未来链接是链接预测领域的主要目标。准确预测未来链接可以用于推荐系统，或者可以用来更好地理解网络的组织原则。想象一个由用户和产品组成的二分网络，其中连接代表他们购买的产品。在这个例子中，链接预测技术对于预测未来的用户-产品关系至关重要，这允许你实施个性化的产品推荐。
- en: '![10-01](../../OEBPS/Images/10-01.png)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![10-01](../../OEBPS/Images/10-01.png)'
- en: Figure 10.1 Link prediction
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.1 链接预测
- en: On the other hand, there are networks that do not necessarily evolve over time,
    but we have a limited understanding of their connections. One such example is
    a biological network of drugs and diseases. A drug often has a narrow variety
    of diseases it can treat. A clinical trial must be conducted to determine whether
    a drug can treat any new disease; however, clinical trials are very costly. The
    other problem with drug repurposing is that there is a vast number of combinations
    of drugs and diseases on which one could conduct clinical trials. Link prediction
    techniques can be used to identify missing links in the network. The process of
    predicting missing links in the network can be thought of as *link completion*.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，有些网络不一定随时间演变，但我们对其连接的了解有限。一个这样的例子是药物和疾病的生物网络。一种药物通常只能治疗有限种类的疾病。必须进行临床试验以确定药物是否可以治疗任何新的疾病；然而，临床试验成本非常高。药物再利用的另一个问题是，可以进行的药物和疾病组合临床试验数量庞大。链接预测技术可用于识别网络中的缺失链接。预测网络中缺失链接的过程可以被视为*链接完成*。
- en: The biomedical network visualized in figure 10.2 consists of drugs and diseases.
    The solid lines indicate for which diseases a drug can be used. For example, aspirin
    can be used to treat headaches, Kawasaki disease, and coronary artery disease.
    On the other hand, ramipril is known to treat coronary artery disease and hypertension.
    Since both aspirin and ramipril can be used to treat coronary artery disease,
    it might make sense to explore if ramipril can treat other diseases than aspirin
    can. Again, you are simply looking at the number of common neighbors between drugs
    to base your predictions. Note that this is a simplified version of a drug repurposing
    scenario. In the real world, much more information about human genes, pathways,
    and other biological processes is considered. Additionally, you would need to
    include biomedical domain experts in the process to help construct the graph,
    evaluate the results, and more.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2中可视化的生物医学网络由药物和疾病组成。实线表示哪些疾病可以使用药物。例如，阿司匹林可以用来治疗头痛、川崎病和冠状动脉疾病。另一方面，赖诺普利被用来治疗冠状动脉疾病和高血压。由于阿司匹林和赖诺普利都可以用来治疗冠状动脉疾病，因此探索赖诺普利是否可以治疗阿司匹林不能治疗的疾病是有意义的。再次强调，你只是在观察药物之间共同邻居的数量来基于预测。请注意，这是一个药物再利用场景的简化版本。在现实世界中，会考虑关于人类基因、通路和其他生物过程的大量信息。此外，你还需要在过程中包括生物医学领域的专家，以帮助构建图、评估结果等。
- en: '![10-02](../../OEBPS/Images/10-02.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![10-02](../../OEBPS/Images/10-02.png)'
- en: Figure 10.2 Link completion
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2 链接补全
- en: 10.1 Link prediction workflow
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.1 链接预测工作流程
- en: As mentioned, most networks follow various organizing principles, intentionally
    or unintentionally, which you can use in your analysis to predict the probability
    of a new link between a pair of nodes. For example, in a social network, you might
    assume people are more likely to become friends if they are of similar age. However,
    looking only at personal characteristics might be unsatisfactory, as this approach
    might lose a lot of information about a relationship between two persons. Two
    people might be of similar age, but they don’t mingle in the same social groups,
    so the probability of them becoming friends is lower. On the other hand, if two
    people have many common friends, it is more likely they will meet and become friends.
    It also turns out that if a person has a lot of friends, they are more likely
    to form new connections than if they have fewer friends.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，大多数网络都遵循各种组织原则，无论是故意还是无意，你都可以在分析中使用这些原则来预测一对节点之间新链接的概率。例如，在一个社交网络中，你可能会假设如果两个人的年龄相似，他们更有可能成为朋友。然而，仅仅关注个人特征可能是不满意的，因为这种方法可能会丢失关于两个人之间关系的大量信息。两个人可能年龄相似，但他们并不在同一个社交群体中混，所以他们成为朋友的可能性较低。另一方面，如果两个人有很多共同的朋友，他们更有可能相遇并成为朋友。此外，如果一个人有很多朋友，他们形成新连接的可能性比朋友少的人要高。
- en: When predicting whether a new connection will be established, you are never
    examining a single node in isolation but, rather, a pair of nodes in the graph.
    Therefore, the crucial step in link prediction is to design features that encode
    a pair of nodes.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当预测是否将建立新的连接时，你永远不会孤立地检查单个节点，而是检查图中的节点对。因此，链接预测的关键步骤是设计能够编码节点对的特征。
- en: There are several approaches you could take to encode a pair of nodes. I have
    grouped them into three categories, presented in figure 10.3\. First, you can
    combine any node properties. For instance, I have used the age difference in the
    social network example. You could also take the product of node degrees or the
    cosine similarity of node embeddings. However, you can also simply concatenate
    embeddings or any other property if that might perform better. Distance-based
    metrics are another group of features you could use in link prediction. A typical
    representative of this group is the length of the shortest path between the pair
    of nodes. Essentially, you calculate the number of hops you need to traverse to
    get from one node to another and use that as a feature. The underlying idea is
    that the closer the nodes are in the network, the more likely it is that a link
    will form between them in the future. The third group of features focuses on evaluating
    the neighborhood overlap between two nodes. For example, the higher the number
    of common friends is, the greater the likelihood is that the pair will meet sometime
    in the future. You could also calculate the Jaccard similarity index, which would
    simply be a normalized version of the common friends count. There are also other
    metrics that encode the overlap of the local neighborhood, which you will learn
    later in the chapter.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以采取几种方法来编码一对节点。我将它们分为三类，如图10.3所示。首先，你可以组合任何节点属性。例如，我在社交网络示例中使用了年龄差异。你也可以取节点度数的乘积或节点嵌入的余弦相似度。然而，你也可以简单地连接嵌入或任何其他属性，如果这可能会表现得更好。基于距离的度量标准是你在链接预测中可以使用的另一组特征。这一组的典型代表是节点对之间最短路径的长度。本质上，你计算从一个节点到另一个节点所需的跳数，并将其用作特征。其基本思想是，节点在网络中越接近，未来它们之间形成链接的可能性就越大。第三组特征专注于评估两个节点之间的邻域重叠。例如，共同朋友的数量越高，这对在未来某时相遇的可能性就越大。你也可以计算Jaccard相似度指数，它将简单地是共同朋友计数的归一化版本。还有其他度量标准，它们编码了局部邻域的重叠，你将在本章后面学到。
- en: '![10-03](../../OEBPS/Images/10-03.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![10-03](../../OEBPS/Images/10-03.png)'
- en: Figure 10.3 Encoding pairs of nodes
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3 编码节点对
- en: The three categories and their examples presented in figure 10.3 do not offer
    an exhaustive list of possible features. There are other ways of combining metrics
    into link prediction features. However, the groups presented in figure 10.3 cover
    most of the methods to generate features you will encounter in your link prediction
    tasks.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3中展示的三种类别及其示例并不提供可能特征的完整列表。还有其他方法可以将度量标准组合成链接预测特征。然而，图10.3中展示的组别涵盖了你在链接预测任务中会遇到的大多数生成特征的方法。
- en: One simple way to predict links is calculating the link prediction metrics between
    pairs of nodes and simply taking the arbitrary top number of them as links probable
    to happen in the future. On the other hand, you could also decide to train the
    classification model using those link prediction metrics. An added value of training
    a classification model is that it can learn to identify patterns that you might
    miss when taking an unsupervised approach. For instance, the model could identify
    that certain link prediction metrics carry more weight than others. Additionally,
    a particular combination of metrics may significantly forecast the outcome. These
    details might be overlooked if one only considers the top scores of a single similarity
    metric. In this chapter, you will learn how to calculate several link prediction
    metrics and train and evaluate a classification model based on those metrics.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 预测链接的一种简单方法是在节点对之间计算链接预测度量，并简单地选取任意数量的它们作为未来可能发生的链接。另一方面，你也可以决定使用这些链接预测度量来训练分类模型。训练分类模型的一个附加价值是它可以学会识别你在采用无监督方法时可能错过的模式。例如，模型可以识别某些链接预测度量比其他度量更重要。此外，特定的度量组合可能对结果有显著的预测能力。如果只考虑单个相似度度量的最高分数，这些细节可能会被忽视。在本章中，你将学习如何计算几个链接预测度量，并基于这些度量训练和评估分类模型。
- en: Now, imagine you are still working at Twitch as a data scientist. You have been
    tasked with finding ways to improve channel recommendations. So far, you are already
    using the recommendation system based on shared audiences between different channels.
    If there is a significant audience overlap between two channels, you can use that
    information to provide recommendations to users. As a user, you will see those
    recommendations in the Users of This Channel Also Watch section. What could you
    do to try to improve these recommendations? One idea is to predict which channels
    will share audiences in the future. Then, you could provide these predictions
    as recommendations to users. This approach might improve the overall recommendations,
    as you would recommend channels with existing audience overlap as well as channels
    with a high probability of future audience overlap.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设你仍然在Twitch担任数据科学家。你被分配了寻找改进频道推荐方法的任务。到目前为止，你已经使用了基于不同频道之间共享观众群体的推荐系统。如果两个频道之间存在显著的观众重叠，你可以使用这些信息向用户提供推荐。作为用户，你将在“此频道用户也观看”部分看到这些推荐。你该如何尝试改进这些推荐呢？一个想法是预测哪些频道将在未来共享观众。然后，你可以将这些预测作为推荐提供给用户。这种方法可能会提高整体推荐的准确性，因为你会推荐既有观众重叠的频道，也有未来观众重叠概率高的频道。
- en: Figure 10.4 shows the network of Twitch channels or streams, where the relationships
    represent the audience overlap. The solid lines represent existing shared audience
    overlap and could be used to populate one section of recommendations. As a data
    scientist, you could use the information about the existing relationships to predict
    future audience overlap. The future audience overlap predictions can then be used
    to power your recommendation engine.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4显示了Twitch频道或流量的网络，其中关系表示观众重叠。实线代表现有的共享观众重叠，可以用来填充推荐系统的一部分。作为数据科学家，你可以使用现有关系的信息来预测未来的观众重叠。然后，可以使用未来的观众重叠预测来驱动你的推荐引擎。
- en: '![10-04](../../OEBPS/Images/10-04.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![10-04](../../OEBPS/Images/10-04.png)'
- en: Figure 10.4 Link prediction flow
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.4 链接预测流程
- en: Interestingly, using future link predictions as recommendations could, in turn,
    be thought of as self-fulfilling projections. Similar approaches have been used
    to recommend movies (Lakshmi & Bhavani, 2021), products (Darke et al., 2017),
    and even links between medical concepts (Kastrin et al., 2014). Link prediction
    can also be used with other techniques to construct a hybrid recommendation engine
    (Çano & Morisio, 2017). How would you go about training a classification model
    that could be used to predict future overlap of audiences between channels?
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，使用未来链接预测作为推荐，反过来可以被视为自我实现的预测。类似的方法已经被用来推荐电影（Lakshmi & Bhavani, 2021）、产品（Darke
    et al., 2017），甚至医学概念之间的链接（Kastrin et al., 2014）。链接预测还可以与其他技术结合使用，构建混合推荐引擎（Çano
    & Morisio, 2017）。你将如何着手训练一个分类模型，用于预测频道之间未来观众的重叠？
- en: The high-level overview of the process of training a link prediction classification
    model is presented in figure 10.5\. The first step is to split the relationships
    into three distinct sets. One set is used to generate network features, while
    the other two are used to train and evaluate the classification model. You might
    run into data leakage problems if you used the same relationships to both generate
    the network features and train the classification model. *Data leakage* occurs
    when your training data contains information about the output but similar data
    will not be available when the model is used for predictions. Leakage frequently
    leads to high performance during training and possibly evaluation of the model,
    but unfortunately, it doesn’t perform well for new predictions. If you are using
    any graph features with the link prediction model, you must take extra care to
    prevent any feature leakage. *Feature leakage* refers to when a feature contains
    the same or comparable information as the output. For example, imagine you are
    using the distance-based shortest path feature between two nodes. By using the
    same relationships to generate features and train the model, the model would simply
    learn to classify or predict a connection between all pairs of nodes with a network
    distance of 1\. In other words, when the network distance between a pair of nodes
    is 1, there is a relationship between the pair of nodes. Therefore, the network
    distance feature and the classification output would contain the same information,
    introducing feature leakage. Essentially, you can think of feature leakage as
    cheating on your model evaluation by peeking at the results during training. To
    avoid feature and data leakage, you need to use one relationship set to calculate
    the network features and another relationship set to provide supervised classification
    examples for training and evaluating the model.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 链接预测分类模型的训练过程的高级概述在图10.5中展示。第一步是将关系分为三个不同的集合。一个集合用于生成网络特征，而其他两个集合用于训练和评估分类模型。如果你使用相同的关系来同时生成网络特征和训练分类模型，可能会遇到数据泄露问题。*数据泄露*发生在你的训练数据包含关于输出的信息，但在模型用于预测时，类似的数据将不可用。数据泄露通常会导致模型在训练和可能评估期间表现良好，但不幸的是，它对新预测的表现不佳。如果你在使用任何图特征与链接预测模型，你必须格外小心，以防止任何特征泄露。*特征泄露*指的是一个特征包含与输出相同或可比较的信息。例如，想象你正在使用两个节点之间的基于距离的最短路径特征。通过使用相同的关系来生成特征和训练模型，模型会简单地学会根据网络距离为1的所有节点对进行分类或预测连接。换句话说，当一对节点的网络距离为1时，这对节点之间存在关系。因此，网络距离特征和分类输出将包含相同的信息，导致特征泄露。本质上，你可以将特征泄露视为在训练期间偷看结果而对模型评估作弊。为了避免特征和数据泄露，你需要使用一个关系集合来计算网络特征，并使用另一个关系集合为训练和评估模型提供监督分类示例。
- en: '![10-05](../../OEBPS/Images/10-05.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![10-05](../../OEBPS/Images/10-05.png)'
- en: Figure 10.5 Building a link prediction model to recommend Twitch channels
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.5 构建链接预测模型以推荐Twitch频道
- en: Once the dataset split is done, you need to calculate the link prediction metrics
    that will be used to train a model. As previously mentioned, you could calculate
    network distance, calculate the number of common neighbors, or simply aggregate
    node properties. You need to calculate the features for both the positive and
    negative examples of links in the network. Finally, use these link prediction
    features to train a classification model to predict whether a link is probable
    to happen in the future or not. Given that the dataset was split into training
    and test relationship sets, you can evaluate your model on the test set of the
    dataset. Once you determine that the classification model performs well enough,
    you can use it in production to generate recommendations for users of your platform.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成数据集的拆分，你需要计算用于训练模型的链接预测指标。如前所述，你可以计算网络距离，计算共同邻居的数量，或者简单地聚合节点属性。你需要计算网络中链接的正例和负例的特征。最后，使用这些链接预测特征来训练一个分类模型，以预测链接在未来是否可能发生。鉴于数据集被拆分为训练和测试关系集，你可以在数据集的测试集上评估你的模型。一旦确定分类模型的表现足够好，你就可以在生产中使用它为平台用户生成推荐。
- en: 'To follow the exercises in this chapter, you need to have the Twitch network
    imported into the Neo4j database, as described in chapter 9\. The Jupyter notebook
    with all the code examples in this chapter is available on the following GitHub
    web page: [http://mng.bz/Y1JA](http://mng.bz/Y1JA).'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成本章的练习，你需要将Twitch网络导入到第9章中描述的Neo4j数据库中。本章中所有代码示例的Jupyter笔记本可在以下GitHub网页上找到：[http://mng.bz/Y1JA](http://mng.bz/Y1JA)。
- en: 10.2 Dataset split
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2 数据集分割
- en: You need to split the dataset accordingly to evaluate the trained classification
    model. If your model used no graph-based features, like distance-based or neighborhood-based
    metrics, then you could follow the traditional test/train data split. Assume you
    are trying to predict new links between people based on their age and education.
    Since both of those features are node properties that are not graph-based, you
    could simply take 80% of existing relationships as the training set and evaluate
    your model on the remaining 20% of relationships. Obviously, you need to add some
    negative examples, as the model otherwise cannot learn to differentiate between
    the two outputs and might produce inaccurate predictions. Producing negative examples
    is not a problem, as there are many pairs of nodes that are not connected. In
    practice, positive link examples scale linearly with the number of nodes in the
    graph, while negative examples scale quadratically. This could lead to a considerable
    class imbalance problem; however, it is a frequent step in the link prediction
    process to subsample the negative classification samples to around the same number
    as the positive ones. You will learn more about negative example subsampling in
    the next section.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要相应地分割数据集以评估训练好的分类模型。如果你的模型没有使用基于图的特征，如基于距离或基于邻居的度量，那么你可以遵循传统的测试/训练数据分割。假设你正在尝试根据人们的年龄和教育程度预测他们之间新的链接。由于这两个特征都是节点属性，而不是基于图的特征，你可以简单地取现有关系的80%作为训练集，并在剩余的20%的关系上评估你的模型。显然，你需要添加一些负例，因为否则模型无法学会区分两种输出，并可能产生不准确的预测。生成负例不是问题，因为有许多节点对没有连接。在实践中，正链接示例的规模与图中节点的数量成线性关系，而负例的规模成二次关系。这可能导致相当大的类别不平衡问题；然而，在链接预测过程中，通常需要从负分类样本中子采样到与正样本大致相同的数量。你将在下一节中了解更多关于负例子采样的内容。
- en: 'As soon as you add any graph-based features that capture the similarity or
    closeness of nodes in the graph, you need to be very mindful of data leakage.
    Remember, when a feature contains the same or comparable information as the output
    variable but is unavailable when making predictions, you have introduced data
    leakage into the workflow. The most obvious example is the network distance between
    nodes in the graph. If the network features and training examples are calculated
    on the same set of relationships, then the model will simply learn that relationships
    exist between nodes that are only one hop away. However, none of the pairs of
    nodes without a link in the network will be classified as probable to form a connection,
    as none are one hop away. Even node embeddings based on the homophily principle,
    introduced in chapter 9, could be problematic if you didn’t perform a proper dataset
    split. Overall, most of the graph-based features might introduce some data leakage
    issues. It is common to split relationships into three sets to avoid data leakage
    problems:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你添加了任何基于图的特征来捕捉图中节点之间的相似性或接近度，你就需要非常注意数据泄露问题。记住，当一个特征包含与输出变量相同或可比较的信息，但在进行预测时不可用，你就已经将数据泄露引入了工作流程。最明显的例子是图中节点之间的网络距离。如果网络特征和训练示例是在同一组关系上计算的，那么模型将简单地学习到只有一步之遥的节点之间存在关系。然而，网络中没有任何链接的节点对将不会被分类为可能形成连接，因为它们都不是一步之遥。即使基于第9章中介绍的亲社会性原则的节点嵌入也可能存在问题，如果你没有进行适当的数据集分割。总的来说，大多数基于图的特征可能会引入一些数据泄露问题。通常将关系分为三组以避免数据泄露问题：
- en: Relationship set used to generate features
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于生成特征的关联集
- en: Relationship set used to train the model
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于训练模型的关联集
- en: Relationship set used to evaluate the model
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于评估模型的关联集
- en: Using separate sets of relationships to generate network features and then train
    and evaluate the classification, you can avoid feature leakage issues with graph-based
    features. Therefore, none of the calculated network features will have identical
    or very comparable information as the output variable. With the network distance
    example, supervised classification examples will have a minimum network distance
    of 2\. Both negative and positive classification examples can have a network distance
    of 2\. In turn, the network distance feature is not identical to the output variable,
    and you prevent any feature leakage.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 使用单独的关系集来生成网络特征，然后进行分类训练和评估，你可以避免基于图的特征泄漏问题。因此，计算出的网络特征将不会与输出变量有相同或非常相似的信息。以网络距离为例，监督分类示例将具有至少2的最小网络距离。正负分类示例都可以有2的网络距离。反过来，网络距离特征与输出变量不相同，你也就防止了任何特征泄漏。
- en: There are many options for going about performing the dataset split. In this
    section, you will learn about the *time-based* and *random* dataset split techniques.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行数据集分割方面有许多选择。在本节中，你将了解基于**时间**和**随机**的数据集分割技术。
- en: 10.2.1 Time-based split
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.1 基于时间的分割
- en: In theory, link prediction is a technique used to predict future connections
    based on past ones. You could produce a dataset split based on the time component
    if you know when the links were created.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，链接预测是一种基于过去连接来预测未来连接的技术。如果你知道链接的创建时间，你可以根据时间成分产生数据集分割。
- en: The original network in figure 10.6 has relationships created between 2020 and
    2021\. In this simple graph example, you can use the relationships from 2020 to
    generate network features. There should be a significant number of relationships
    in the feature set, as you don’t want the network to be too disconnected or have
    too many isolated nodes. Having too few relationships in the feature set might
    produce poor network features, which might, in turn, not be predictive of future
    links. Relationships created in 2021 in figure 10.6 are then used to construct
    the test and train sets. For example, you could use 80% of the newer relationships
    as the training set and the remaining 20% to evaluate the model. Remember that
    the relationships used to generate network features should not be used in either
    the train or the test sets. Optionally, you could also introduce a validation
    set from the newer relationships created in 2021 if you plan to perform any hyperparameter
    optimization of the classification model.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.6中的原始网络在2020年至2021年之间创建了关系。在这个简单的图示例中，你可以使用2020年的关系来生成网络特征。特征集中应该有相当数量的关系，因为你不希望网络过于分散或节点过于孤立。特征集中关系太少可能会产生较差的网络特征，这反过来可能无法预测未来的链接。图10.6中2021年创建的关系用于构建测试集和训练集。例如，你可以使用80%的新关系作为训练集，剩余的20%用于评估模型。记住，用于生成网络特征的关系不应用于训练集或测试集。如果你计划对分类模型进行任何超参数优化，你也可以选择从2021年创建的新关系中引入一个验证集。
- en: '![10-06](../../OEBPS/Images/10-06.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![10-06](../../OEBPS/Images/10-06.png)'
- en: Figure 10.6 Time-based approach to relationship split for a link prediction
    task
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.6 链接预测任务中关系分割的基于时间方法
- en: Use the time-based split, if possible, as it accurately mimics the scenario
    of predicting future links. In the example in figure 10.6, you take existing knowledge
    about relationships (from 2020) and try to predict the future (in 2021). The additional
    benefit is that the model should learn to capture the underlying organizing mechanism
    of the network as the time-based split follows network evolution, which should,
    in turn, provide better predictions. Unfortunately, the Twitch dataset of shared
    audiences doesn’t have the time component of relationships available, so you will
    have to resort to another method.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可能的话，使用基于时间的分割，因为它准确地模拟了预测未来链接的场景。在图10.6的示例中，你使用2020年的现有关系知识来预测未来（2021年）。额外的优势是，模型应该学会捕捉网络的潜在组织机制，因为基于时间的分割遵循网络演变，这反过来应该提供更好的预测。不幸的是，共享观众数据的Twitch数据集没有关系的时间成分，所以你将不得不求助于另一种方法。
- en: 10.2.2 Random split
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.2 随机分割
- en: Random split is similar to time-based split, in that you need to produce train
    and test sets as well as the feature set of relationships. You can’t differentiate
    between past and future relationships, since no time information is available.
    Instead, you randomly take a subset of relationships in the graph as the train
    and test sets you will use to train and evaluate the classification model. Random
    split is also useful for link completion tasks, where you predict missing links
    in the network and have no time component available.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 随机分割类似于基于时间分割，因为你需要生成训练集和测试集以及关系的特征集。由于没有时间信息可用，你无法区分过去和未来的关系。相反，你随机从图中选取关系子集作为训练集和测试集，用于训练和评估分类模型。随机分割对于链接补全任务也很有用，在这种任务中，你预测网络中的缺失链接，且没有时间组件可用。
- en: You can see that figure 10.7 is almost identical to figure 10.6\. The only difference
    is how to select which relationships belong to which set. With the time-based
    approach, you can choose the set the relationship belongs to based on the time
    property. However, since you don’t have the time information available, you need
    to take the random approach. Therefore, you select to which set a relationship
    belongs at random.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到图 10.7 几乎与图 10.6 完全相同。唯一的区别在于如何选择哪些关系属于哪个集合。基于时间的方法，你可以根据时间属性选择关系所属的集合。然而，由于没有时间信息可用，你需要采取随机方法。因此，你随机选择关系属于哪个集合。
- en: '![10-07](../../OEBPS/Images/10-07.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![10-07](../../OEBPS/Images/10-07.png)'
- en: Figure 10.7 Random approach to relationship split for the link prediction task
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.7 链接预测任务的关系分割随机方法
- en: Note The key concept with the link prediction dataset split is that to avoid
    data leakage, the links used to calculate network features should differ from
    the supervised link samples used for training and evaluating a classification
    model. *Feature leakage* occurs when a feature contains the same or comparable
    information as the output variable. For example, if you were to avoid introducing
    a separate feature set to calculate network features like the network distance,
    the classification model would learn that pairs of nodes that are one hop or traversal
    away have 100% probability of forming or having a link. In turn, the model accuracy
    on the training and test sets would be 100%, as the network distance contains
    the same information as the output variable. However, the model would be terrible
    at predicting missing or future links. Optionally, you can introduce a validation
    set if you plan to perform any hyperparameter optimization.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：在链接预测数据集分割中的关键概念是，为了避免数据泄露，用于计算网络特征所使用的链接应与用于训练和评估分类模型的监督链接样本不同。*特征泄露*发生在特征包含与输出变量相同或可比较信息的情况下。例如，如果你避免引入一个单独的特征集来计算网络特征，如网络距离，分类模型会学习到一对节点在一跳或遍历距离内形成或拥有链接的概率为100%。因此，训练集和测试集上的模型准确率会达到100%，因为网络距离包含与输出变量相同的信息。然而，模型在预测缺失或未来链接方面会非常糟糕。如果你计划进行任何超参数优化，可以选择引入验证集。
- en: Now, you will perform the random split for link prediction on the Twitch shared
    audience network. You need to have the Neo4j environment up and running with the
    Twitch dataset defined in chapter 9 loaded. Next, you need to open a Jupyter notebook
    to define the connection to the Neo4j database.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你将对 Twitch 共享观众网络进行链接预测的随机分割。你需要确保 Neo4j 环境运行正常，并在第 9 章中定义的 Twitch 数据集已加载。接下来，你需要打开一个
    Jupyter 笔记本来定义与 Neo4j 数据库的连接。
- en: Listing 10.1 Defining the connection to Neo4j
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.1 定义与 Neo4j 的连接
- en: '[PRE0]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The code in listing 10.1 defines the connections with the Neo4j database and
    the `run_query` function used to execute any Cypher statement. Make any necessary
    changes to the `url`, `username`, and `password` variables.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.1 中的代码定义了与 Neo4j 数据库的连接以及用于执行任何 Cypher 语句的 `run_query` 函数。根据需要更改 `url`、`username`
    和 `password` 变量。
- en: Exercise 10.1
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 10.1
- en: Count the number of relationships in the Twitch shared audience network.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 计算 Twitch 共享观众网络中的关系数量。
- en: There are 131,427 relationships in the dataset. You will begin by constructing
    the feature set of relationships. Remember, the feature set needs to be the largest,
    as you want to retain as connected a network as possible without too many isolated
    nodes or disconnected components. In this instance, you can use 90% of all relationships
    in the feature set, leaving you with around 13,000 positive examples for the train
    and test sets. To construct the feature set, you will create new relationships
    with a `FEATURE_REL` type. Cypher offers a `rand()` that returns a random floating-point
    number in the range from 0 to 1 and follows an approximate uniform distribution.
    To select a random subset of relationships for the feature set, you will use the
    `rand()` function in the Cypher statement. The following Cypher statement takes
    approximately 90% of existing `SHARED_AUDIENCE` relationships and creates a new
    connection with the `FEATURE_REL` between those pairs of nodes.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 数据集中有131,427个关系。你将首先构建关系特征集。记住，特征集需要尽可能大，因为你希望保留尽可能多的连接网络，而不至于有太多孤立节点或断开的部分。在这种情况下，你可以在特征集中使用90%的所有关系，为你留下大约13,000个正样本用于训练集和测试集。为了构建特征集，你将创建具有`FEATURE_REL`类型的新关系。Cypher提供了一个`rand()`函数，它返回一个介于0到1之间的随机浮点数，并遵循近似均匀分布。为了选择关系特征集的随机子集，你将在Cypher语句中使用`rand()`函数。以下Cypher语句大约选取了90%的现有`SHARED_AUDIENCE`关系，并在这些节点对之间创建了一个新的`FEATURE_REL`连接。
- en: Listing 10.2 Constructing a relationship feature set
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.2 构建关系特征集
- en: '[PRE1]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The code in listing 10.2 selects and creates a random, nondeterministic set
    of relationships. Make sure to run it only once, as the relationship split would
    not be acceptable otherwise. If you have run the query multiple times for any
    reason, simply delete the `FEATURE_REL` relationships and rerun the Cypher statement
    in listing 10.2\. Note that you might get a slightly different count of `FEATURE_REL`
    relationships when rerunning the query, due to using the `rand()` function.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.2中的代码选择并创建了一个随机、非确定性的关系集。请确保只运行一次，因为否则关系分割将不可接受。如果你出于任何原因多次运行了查询，只需删除`FEATURE_REL`关系并重新运行列表10.2中的Cypher语句。请注意，由于使用了`rand()`函数，在重新运行查询时，你可能会得到`FEATURE_REL`关系的不同计数。
- en: Exercise 10.2
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 练习10.2
- en: Now, you will select the relationships for the train and test set. You will
    start by producing positive samples for the classification model. The positive
    samples are relationships between the pairs of nodes between which the `SHARED_AUDIENCE`
    relationships exist but not the `FEATURE_REL` ones.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你将选择训练集和测试集中的关系。你将首先为分类模型生成正样本。正样本是在存在`SHARED_AUDIENCE`关系但不存在`FEATURE_REL`关系的节点对之间的关系。
- en: Match the pairs of nodes between which the `SHARED_AUDIENCE` exists but not
    the `FEATURE_REL` ones. Next, use the `MERGE` clause to create new relationships
    between those pairs of nodes with the `TEST_TRAIN` type. Finally, return the count
    of newly created relationships.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配存在`SHARED_AUDIENCE`但不存在`FEATURE_REL`关系的节点对。接下来，使用`MERGE`子句在这些节点对之间创建具有`TEST_TRAIN`类型的新关系。最后，返回新创建的关系数。
- en: I got the result of 13,082 created relationships. You will probably get a different
    number, but it should be in the same ballpark, around 13,000\. You have prepared
    the positive samples for the classification model. Now, it is time to select some
    negative examples where the relationship does not exist.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我得到了13,082个创建的关系的结果。你可能得到一个不同的数字，但应该在大约13,000的同一范围内。你已经为分类模型准备好了正样本。现在，是时候选择一些不存在关系的负样本了。
- en: 10.2.3 Negative samples
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.2.3 负样本
- en: When training a binary classifier like the link prediction model, you should
    include both positive and negative examples in the training and test sets. Without
    negative examples, the model cannot learn to differentiate between the two outputs
    and might produce inaccurate predictions.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当训练一个像链接预测模型这样的二元分类器时，你应该在训练集和测试集中包含正例和负例。没有负例，模型无法学会区分两种输出，可能会产生不准确的预测。
- en: A common characteristic of real-world graphs is that they are sparse. Imagine
    any large social platform on the internet. You might have hundreds or thousands
    of friends on the platform; however, there are millions or, in some cases, billions
    of users on the platform. That means you have only a thousand out of a billion
    relationships possible. In the machine learning context, every user has up to
    a few thousand positive examples and, possibly, around a billion negative examples.
    If you used all the negative examples, you would have to deal with a considerable
    class imbalance, as the positive examples of relationships scale linearly with
    the number of nodes, while the negative examples scale quadratically. Most machine
    learning models perform best when the number of samples in each class is about
    the same. However, if the dataset is heavily imbalanced, then you might get a
    high accuracy by just predicting the majority class every time. With link prediction,
    if you would predict that no link exists between any pair of nodes, you would
    probably get around 99% accuracy in most cases. Thus, there would be a high probability
    of misclassification of the minority class and, consequently, poor classification
    model performance. Therefore, it is common to subsample the negative examples
    and use about the same number of positive and negative samples in most link prediction
    workflows.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现实世界图的一个共同特征是它们是稀疏的。想象一下互联网上的任何大型社交平台。你可能在平台上拥有数百或数千个朋友；然而，平台上可能有数百万甚至数十亿用户。这意味着你只有十亿中可能的关系中的一千种。在机器学习环境中，每个用户可能有几千个正面示例，以及可能大约有十亿的负面示例。如果你使用了所有的负面示例，你将不得不处理相当大的类别不平衡，因为关系的正面示例与节点的数量成线性关系，而负面示例与节点的数量成平方关系。大多数机器学习模型在每一类样本数量大致相同的情况下表现最佳。然而，如果数据集严重不平衡，那么你可能会通过每次都预测多数类来获得很高的准确率。在链接预测中，如果你预测任何一对节点之间不存在链接，你可能会在大多数情况下获得大约
    99% 的准确率。因此，对少数类进行错误分类的可能性很高，从而导致分类模型性能不佳。因此，在大多数链接预测工作流程中，通常会子采样负面示例，并使用大约相同数量的正面和负面样本。
- en: Exercise 10.3
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 10.3
- en: In this exercise, you will select pairs of nodes to construct the negative examples
    for the classification model. You must select about the same number of negative
    samples as the positive ones produced in exercise 10.2\. You can use the count
    of 13,082 positive examples, or the count you got in exercise 10.2\. The negative
    examples should be produced in a way that ensures no relationship exists between
    the pair of nodes in feature, train, or test sets.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '在这个练习中，你将选择节点对来构建分类模型的负面示例。你必须选择与练习 10.2 中产生的正面样本数量大致相同的负面样本。你可以使用 13,082 个正面示例的数量，或者你在练习
    10.2 中得到的数量。负面示例应该以确保在特征、训练或测试集中节点对之间不存在关系的方式产生。 '
- en: Start by matching a pair of nodes where the `SHARED_AUDIENCE` relationship does
    not exist between them. Next, ensure you have matched two different nodes and
    will avoid running into situations in which both the source and target node are
    the same. Filter pairs of nodes where the randomly generated value is higher than
    0.9 (`rand()` `>` `0.9`) to guarantee that the negative examples are somewhat
    random and representative of the graph as a whole. Once the pairs of nodes are
    correctly matched, use the `LIMIT` clause to limit the number of negative examples
    to around 13,000\. Finally, create a relationship between the selected pairs of
    nodes with the `NEGATIVE_TEST _TRAIN` type.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，匹配一对节点，其中它们之间不存在 `SHARED_AUDIENCE` 关系。接下来，确保你匹配了两个不同的节点，并将避免遇到源节点和目标节点都相同的情况。过滤掉随机生成的值高于
    0.9 (`rand()` `>` `0.9`) 的节点对，以保证负面示例在一定程度上是随机的，并且代表整个图。一旦正确匹配了节点对，使用 `LIMIT`
    子句将负面示例的数量限制在大约 13,000 个左右。最后，使用 `NEGATIVE_TEST _TRAIN` 类型在选定的节点对之间创建关系。
- en: 10.3 Network feature engineering
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3 网络特征工程
- en: Now, you will produce network features that capture the closeness or similarity
    of pairs of nodes in the network. The idea is that the closer or more similar
    a pair of nodes are given the network metrics, the more likely they are to form
    a future connection. The future connections will then be used to provide better
    recommendations to Twitch users.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你将生成网络特征，以捕捉网络中节点对之间的接近度或相似度。想法是，给定网络度量，节点对越接近或越相似，它们形成未来连接的可能性就越大。然后，将使用未来的连接为
    Twitch 用户提供更好的推荐。
- en: You might have noticed that the train and test sets are lumped together under
    the `TEST_TRAIN` and `NEGATIVE_TEST_TRAIN` relationship types. As you need to
    calculate the link prediction features for both the train and test sets, there
    is no need to differentiate between the two just yet. Remember, all the graph-based
    features for the train and test sets will be calculated strictly on the feature
    set of relationships, to prevent any data leakage.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，训练集和测试集在`TEST_TRAIN`和`NEGATIVE_TEST_TRAIN`关系类型下被合并在一起。由于您需要为训练集和测试集都计算链接预测特征，目前没有必要区分这两者。记住，训练集和测试集的所有基于图的特征都将严格基于关系特征集进行计算，以防止任何数据泄露。
- en: Again, you have the option to choose between learned or manually defined features.
    For example, you could use the node2vec algorithm to calculate node embeddings
    and then use the cosine similarity of embeddings between pairs of nodes as a feature
    of the classification model. However, since you would be using transductive node
    embeddings to calculate link prediction features, you would need to retrain the
    classification model every time a new node is added to the graph. While that might
    be satisfactory in some scenarios, you probably don’t want to retrain a model
    every time a new streamer shows up on the platform. Luckily, a lot of research
    has been done about link prediction features from which you can borrow some ideas
    for feature engineering. It makes sense to start by selecting straightforward
    and uncomplicated features and evaluating their performance. If there is a need,
    you can always later use more complex techniques, like inductive node embeddings.
    You must finish exercises 10.2 and 10.3 before continuing with the code examples
    to generate features.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，您可以选择使用学习到的或手动定义的特征。例如，您可以使用node2vec算法计算节点嵌入，然后使用节点对之间的嵌入余弦相似度作为分类模型的特征。然而，由于您将使用归纳节点嵌入来计算链接预测特征，因此每当图中新添加一个节点时，您都需要重新训练分类模型。虽然这在某些场景中可能是令人满意的，但您可能不希望每次新流媒体主播出现在平台上时都重新训练模型。幸运的是，关于链接预测特征的研究已经做了很多，您可以从中借鉴一些关于特征工程的想法。从简单且不复杂的特征开始选择并评估其性能是合理的。如果需要，您以后总是可以使用更复杂的技术，比如归纳节点嵌入。在继续生成特征的代码示例之前，您必须完成10.2和10.3的练习。
- en: 10.3.1 Network distance
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.1 网络距离
- en: The first feature you will calculate is the *network distance*. The network
    distance is calculated by finding the shortest path between a pair of nodes and
    then counting the number of relationships in the shortest path.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 您将计算的第一个特征是*网络距离*。网络距离是通过找到一对节点之间的最短路径，然后计算最短路径中的关系数量来计算的。
- en: Figure 10.8 shows the process of finding the network distance between nodes
    A and E. In the first step, you need to calculate the shortest path between the
    pair of nodes. When dealing with an unweighted network, the shortest path represents
    the path that traverses the fewest relationships to get from one node to another.
    In the example in figure 10.8, you must traverse two relationships to get from
    node A to node E. In other words, the network distance between nodes A and E is
    2.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.8展示了计算节点A和E之间网络距离的过程。在第一步，您需要计算这对节点之间的最短路径。在处理无权网络时，最短路径表示穿越最少关系从一节点到另一节点的路径。在图10.8的例子中，您必须穿越两个关系才能从节点A到达节点E。换句话说，节点A和E之间的网络距离是2。
- en: '![10-08](../../OEBPS/Images/10-08.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![10-08](../../OEBPS/Images/10-08.png)'
- en: Figure 10.8 Calculating network distance between a pair of nodes A and E
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.8 计算节点A和E之间的网络距离
- en: The idea behind the network distance is that the closer the two nodes are in
    the network, the more likely they are to form future connections. For example,
    imagine you are dealing with a link prediction in a social network. The network
    distance between a pair of persons in the train or test set should never be 1,
    as this would mean you haven’t performed the relationship split correctly. However,
    if the network distance is 2, that would mean the pair of persons have at least
    one common friend. If the distance is greater than 2, the two persons don’t have
    any common friends and are less likely to form future connections. In theory,
    the higher the network distance is, the less likely a future connection is. In
    your use case, the closer the two streams are in the network, the more likely
    it is there will be a significant audience overlap in the future.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 网络距离背后的思想是，网络中两个节点越接近，它们形成未来连接的可能性就越大。例如，想象你正在处理社交网络中的链接预测。训练集或测试集中一对人员的网络距离永远不会是1，因为这意味着你没有正确执行关系分割。然而，如果网络距离是2，这意味着这对人员至少有一个共同的朋友。如果距离大于2，那么这两个人没有共同的朋友，并且不太可能形成未来的连接。理论上，网络距离越高，未来连接的可能性就越小。在你的用例中，两个流在网络中越接近，未来出现显著观众重叠的可能性就越大。
- en: Using Cypher query language, you can find the shortest unweighted path with
    the `shortestPath()` function. In an unweighted path, the traversal of each relationship
    has an identical cost, so the shortest path between two nodes will always be the
    count of the total relationships in a path between them. The `shortestPath()`
    function expects as input a Cypher pattern that defines the source and target
    nodes as well as the optional allowed relationship types in the path. For more
    advanced use cases, you can also define the minimum or the maximum number of traversals
    or relationships in the path. The following Cypher statement finds the shortest
    path between Surya and Jim.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Cypher查询语言，您可以使用`shortestPath()`函数找到最短无权路径。在无权路径中，每个关系的遍历具有相同的成本，因此两个节点之间的最短路径将始终是它们之间路径中总关系的数量。`shortestPath()`函数期望输入一个Cypher模式，该模式定义了源节点和目标节点以及路径中可选的允许关系类型。对于更高级的用例，您还可以定义路径中遍历的最小或最大次数或关系数。以下Cypher语句查找Surya和Jim之间的最短路径。
- en: Listing 10.3 Finding shortest unweighted paths with Cypher
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.3 使用Cypher查找最短无权路径
- en: '[PRE2]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: ❶ Defines the source and target nodes of the shortest path
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 定义最短路径的源节点和目标节点
- en: ❷ Identifies the shortest path between the source and target nodes under the
    p reference variable
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在p参考变量下确定源节点和目标节点之间的最短路径
- en: The first part of listing 10.3 is a simple `MATCH` clause used to identify the
    source and target nodes. Next, you need to define the shortest path constraints
    using Cypher syntax. The defined graph pattern that defines the shortest path
    constrains in listing 10.3 is shown in the following listing.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.3的第一部分是一个简单的`MATCH`子句，用于确定源节点和目标节点。接下来，您需要使用Cypher语法定义最短路径约束。列表10.3中定义的最短路径约束的图模式如下所示。
- en: Listing 10.4 Graph pattern used to define the shortest path constraints
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.4 定义最短路径约束的图模式
- en: '[PRE3]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The Cypher syntax in listing 10.4 defines the shortest path between the `source`
    and `target` nodes. One constraint of the shortest path is that it can only traverse
    `FRIEND` or `COWORKER` relationships. The function ignores all the other relationship
    types. Note that the relationship direction is also essential. In the example
    in listing 10.4, the shortest path algorithm can only traverse outgoing relationships
    throughout the path. Finally, you need to add the `*` symbol to allow the algorithm
    to traverse multiple relationships. If the `*` symbol were missing, one of the
    shortest path constraints would be that the algorithm can only traverse a single
    relationship.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.4中的Cypher语法定义了`source`和`target`节点之间的最短路径。最短路径的一个约束是它只能遍历`FRIEND`或`COWORKER`关系。该函数忽略所有其他关系类型。请注意，关系方向也是至关重要的。在列表10.4的示例中，最短路径算法只能遍历路径中的出向关系。最后，您需要添加`*`符号以允许算法遍历多个关系。如果缺少`*`符号，最短路径约束之一将是算法只能遍历单个关系。
- en: Now, you will calculate the network distance for all pairs of nodes in the train
    and test sets of relationships (listing 10.5). The test and train sets of pairs
    of nodes are tagged with the `TEST_TRAIN` and `NEGATIVE_TEST_TRAIN` relationship
    types. Then, you must find the shortest path between all pairs of nodes in the
    two sets. In the last step, you will calculate the length of the shortest path,
    which is equivalent to the number of relationships, with the `length()` function.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你将为关系（列表10.5）的训练集和测试集中的所有节点对计算网络距离。节点对的测试和训练集被标记为`TEST_TRAIN`和`NEGATIVE_TEST_TRAIN`关系类型。然后，你必须找到两个集合中所有节点对之间的最短路径。在最后一步，你将使用`length()`函数计算最短路径的长度，这相当于关系的数量。
- en: Listing 10.5 Calculating the network distance between pairs of nodes in the
    train and test sets
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.5 计算训练集和测试集中节点对之间的网络距离
- en: '[PRE4]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ Matches all the pairs of nodes connected with the TEST_TRAIN or NEGATIVE_TEST_TRAIN
    relationships
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 匹配所有通过TEST_TRAIN或NEGATIVE_TEST_TRAIN关系连接的节点对
- en: ❷ Identifies the shortest path between the pairs of nodes. The shortest path
    is constrained to be only allowed to traverse the FEATURE_REL relationships to
    prevent data leakage.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 识别节点对之间的最短路径。最短路径仅限于允许通过FEATURE_REL关系进行遍历，以防止数据泄露。
- en: ❸ Calculates the length of the shortest paths using the length() function
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 使用length()函数计算最短路径的长度
- en: ❹ Stores the network distance result as the relationship property
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 将网络距离结果存储为关系属性
- en: You may notice that there is no direction indicator in the shortest path graph
    pattern definition in listing 10.5\. Therefore, the shortest path algorithm can
    traverse the relationship in the opposite direction as well, effectively treating
    the relationships as undirected.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到，列表10.5中最短路径图模式定义中没有方向指示符。因此，最短路径算法也可以沿着相反的方向遍历关系，有效地将关系视为无向的。
- en: 10.3.2 Preferential attachment
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.2 优先连接
- en: Another popular metric used in link prediction is preferential attachment. *Preferential
    attachment* is an underlying organizing principle occurring in real-world networks,
    where nodes with a higher number of relationships are more likely to make new
    relationships. In the social network example, people with more friends are more
    likely to make new connections. They might be invited to more social events or
    be introduced more, due to having many friends. The preferential attachment model
    was first described by Barabási and Albert (1999).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在链接预测中使用的另一个流行指标是优先连接。*优先连接*是现实世界中网络的一个基本组织原则，其中具有更多关系的节点更有可能建立新的关系。在社会网络示例中，朋友更多的人更有可能建立新的联系。他们可能会被邀请参加更多的社交活动或被介绍给更多的人，因为他们的朋友众多。优先连接模型最初由巴拉巴西和艾伯特（1999年）描述。
- en: Figure 10.9 shows two `Stream` nodes in the center with a relatively large node
    degree. The preferential attachment mechanism assumes streams that already share
    a significant audience with many other streams are more likely to form future
    connections. So following the preferential attachment principle, you could assume
    that the two central `Stream` nodes are likely to have a shared audience overlap,
    as indicated by the dotted line in figure 10.9.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.9显示了两个位于中心的`Stream`节点，它们的节点度数相对较大。优先连接机制假设已经与许多其他流共享大量受众的流更有可能形成未来的连接。因此，根据图10.9中的虚线，可以假设这两个中心的`Stream`节点很可能有共享的受众重叠。
- en: '![10-09](../../OEBPS/Images/10-09.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![10-09](../../OEBPS/Images/10-09.png)'
- en: Figure 10.9 Nodes with higher degrees are more likely to form new connections.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.9 节点度数较高的节点更有可能形成新的连接。
- en: To calculate the preferential attachment metric between the pair of nodes, you
    need to multiply their node degrees. Essentially, you take the node degree of
    the first node and multiply it by the node degree of the second node. When a pair
    of nodes has a high preferential attachment metric, the nodes are more likely
    to form a connection in the future.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算节点对之间的优先连接指标，你需要将它们的节点度数相乘。本质上，你取第一个节点的节点度数并乘以第二个节点的节点度数。当节点对具有高优先连接指标时，节点更有可能在将来形成连接。
- en: Exercise 10.4
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 练习10.4
- en: Calculate the preferential attachment metric for pairs of nodes in the train
    and test sets. Similar to network distance metric calculation, you start by matching
    the pairs of nodes connected with the `TEST_TRAIN` or `NEGATIVE_TEST_TRAIN` relationships.
    Next, you calculate the node degrees for both nodes. Make sure to count both incoming
    and outgoing relationships as the node degree and to only count the `FEATURE_REL`
    relationships. Finally, multiply the two node degrees and store the results under
    the `preferentialAttachment` property of relationships.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 计算训练集和测试集中节点对的优先连接度指标。类似于网络距离度量的计算，你首先通过匹配与`TEST_TRAIN`或`NEGATIVE_TEST_TRAIN`关系连接的节点对。接下来，计算两个节点的节点度。确保将传入和传出的关系都计入节点度，并且只计算`FEATURE_REL`关系。最后，将两个节点度相乘，并将结果存储在关系的`preferentialAttachment`属性下。
- en: 10.3.3 Common neighbors
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.3 常见邻居
- en: The next metric you will calculate as a link prediction feature is the *common
    neighbors* metric. The intuition behind the common neighbors metric is simple.
    The more common neighbors two nodes have, the higher the chance is of a link forming
    in the future. In the context of social networks, the more mutual friends two
    people have, the greater the chance they will meet or be introduced in the future.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 你接下来要计算的链接预测特征指标是*共同邻居*指标。共同邻居指标背后的直觉很简单。两个节点共有的邻居越多，未来形成链接的可能性就越高。在社会网络的背景下，两个人共有的朋友越多，他们未来相遇或被介绍的可能性就越大。
- en: Remember, due to the relationship split, none of the pairs of nodes in the train
    or test set has a direct connection. However, many nodes might have several common
    friends, as shown in figure 10.10\. Imagine that all the nodes in figure 10.10
    represent Twitch streams. If stream A has an audience overlap with stream B and
    stream B overlaps with stream C, then there will likely be an audience overlap
    between stream A and C in the future. Additionally, the higher the number of common
    neighbors between two streams is, the higher the probability is of a future link.
    To use the common neighbor metric in the link prediction model, you need to calculate
    the number of common neighbors between all pairs of nodes in the train and test
    sets.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，由于关系分割，训练集或测试集中的节点对之间没有直接连接。然而，许多节点可能有几个共同的朋友，如图 10.10 所示。想象一下，图 10.10 中的所有节点代表
    Twitch 直播。如果直播 A 与直播 B 的观众有重叠，而直播 B 与直播 C 有重叠，那么未来直播 A 和 C 之间很可能有观众重叠。此外，两个直播之间的共同邻居数量越多，未来建立链接的概率就越高。为了在链接预测模型中使用共同邻居度量，你需要计算训练集和测试集中所有节点对的共同邻居数量。
- en: '![10-10](../../OEBPS/Images/10-10.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![10-10](../../OEBPS/Images/10-10.png)'
- en: Figure 10.10 Common neighbors between a pair of nodes
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.10 节点对之间的共同邻居
- en: Exercise 10.5
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 10.5
- en: Calculate the common neighbor metric for pairs of nodes in the train and test
    sets. You start similarly to before by matching the pairs of nodes connected with
    the `TEST_TRAIN` or `NEGATIVE_TEST_TRAIN` relationships. Then, you need to count
    the distinct number of common neighbors between the matched pairs of nodes. Make
    sure to also include the results for pairs of nodes with no common neighbors by
    using the `OPTIONAL` `MATCH` clause. Finally, store the number of common neighbors
    between pairs of nodes under the `commonNeighbor` property of relationships.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 计算训练集和测试集中节点对的共同邻居度指标。你与前一次类似，通过匹配与`TEST_TRAIN`或`NEGATIVE_TEST_TRAIN`关系连接的节点对。然后，你需要计算匹配节点对之间的不同共同邻居数量。确保使用`OPTIONAL`
    `MATCH`子句包括没有共同邻居的节点对的结果。最后，将节点对之间的共同邻居数量存储在关系的`commonNeighbor`属性下。
- en: 10.3.4 Adamic-Adar index
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.4 Adamic-Adar 指数
- en: The *Adamic-Adar index* is a link prediction metric first described by Adamic
    and Adar (2003). The idea behind the Adamic-Adar index is that the smaller the
    node degree common neighbors between a pair of nodes have, the more likely it
    is that they will form a connection in the future. Again, imagine you are dealing
    with a social network. A pair of people have one friend in common. If that common
    friend has 1,000 other friends, it is less likely they will introduce the particular
    pair of people than if they only had two friends in total.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '*Adamic-Adar 指数*是 Adamic 和 Adar（2003）首次描述的链接预测指标。Adamic-Adar 指数背后的想法是，一对节点之间共有的节点度越小，它们未来形成连接的可能性就越大。再次想象你正在处理一个社交网络。一对人有共同的一个朋友。如果这个共同朋友有
    1,000 个其他朋友，他们不太可能介绍这对特定的人，如果他们总共只有两个朋友的话。'
- en: In example A in figure 10.11, nodes A and B have two common neighbors or friends.
    The common friends are nodes C and D. Both nodes C and D have 1,000 friends in
    total. Since common friends of nodes A and B have a broad group of friends themselves,
    it is less likely that either of the common friends will introduce nodes A and
    B. On the other hand, in example B in figure 10.11, common friends of nodes A
    and B have only two friends in total. Essentially, nodes C and D are only friends
    with nodes A and B. Therefore, since the friend circle of common friends is much
    smaller, it is more likely that, for example, nodes A and B are both invited to
    social events that nodes C or D might host. Similar logic could be applied to
    the Twitch overlap network.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在图10.11的示例A中，节点A和B有两个共同邻居或朋友。共同的邻居是节点C和D。节点C和D总共各有1,000个朋友。由于节点A和B的共同邻居本身有一个广泛的社交圈，因此共同邻居中的任何一个不太可能将节点A和B介绍给对方。另一方面，在图10.11的示例B中，节点A和B的共同邻居总共只有两个朋友。本质上，节点C和D只与节点A和B是朋友。因此，由于共同朋友的社交圈较小，例如，节点A和B更有可能被邀请参加节点C或D可能举办的社交活动。类似的逻辑也可以应用于Twitch重叠网络。
- en: '![10-11](../../OEBPS/Images/10-11.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![10-11](../../OEBPS/Images/10-11.png)'
- en: Figure 10.11 Intuition behind the Adamic-Adar index
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.11 Adamic-Adar指数的直觉
- en: The Adamic-Adar index is calculated using the equation shown in figure 10.12.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Adamic-Adar指数是使用图10.12中所示的方程计算的。
- en: '![10-12](../../OEBPS/Images/10-12.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![10-12](../../OEBPS/Images/10-12.png)'
- en: Figure 10.12 Adamic-Adar index equation
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.12 Adamic-Adar指数公式
- en: 'Don’t worry if you don’t understand all the symbols in figure 10.12\. The Adamic-Adar
    index is defined as the sum of the inverse logarithmic node degree of common neighbors
    shared by a pair of nodes. The following are the main steps of the Adamic-Adar
    index calculation:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不理解图10.12中的所有符号，请不要担心。Adamic-Adar指数定义为节点对共享的共同邻居的逆对数节点度数之和。以下是Adamic-Adar指数计算的主要步骤：
- en: Start by finding all the common neighbors of nodes `x` and `y`.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先找出节点`x`和`y`的所有共同邻居。
- en: Calculate the node degree of all common neighbors.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算所有共同邻居的节点度数。
- en: Sum the inverse logarithm of node degrees of all common neighbors.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 求所有共同邻居节点度数逆对数的总和。
- en: The following Cypher statement calculates the Adamic-Adar index between pairs
    of nodes in the train and test sets.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 以下Cypher语句计算训练集和测试集中节点对的Adamic-Adar指数。
- en: Listing 10.6 Calculating the Adamic-Adar index between pairs of nodes in the
    train and test sets
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.6 计算训练集和测试集中节点对的Adamic-Adar指数
- en: '[PRE5]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ❶ Identifies all the common neighbors of nodes s1 and s2
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 识别节点s1和s2的所有共同邻居
- en: ❷ Calculates the node degree for each common neighbor, including both incoming
    and outgoing relationships
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 计算每个共同邻居的节点度数，包括传入和传出关系
- en: ❸ Calculates the sum of the inverse logarithmic degree
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 计算逆对数度数的总和
- en: ❹ Stores the results as the relationship property
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 将结果存储为关系属性
- en: 10.3.5 Clustering coefficient of common neighbors
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.3.5 共同邻居的聚类系数
- en: The last link prediction you will calculate is the *clustering coefficient of
    common neighbors*. A clustering coefficient measures the connectedness of the
    neighbors of a particular node, with the values ranging from 0 to 1\. A value
    of 0 indicates the neighboring nodes have no connections with each other. On the
    other hand, a value of 1 indicates the network of neighbors forms a complete graph,
    where all the neighbors are connected.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 你将要计算的最后一个链接预测是**共同邻居的聚类系数**。聚类系数衡量特定节点的邻居的连通性，其值介于0到1之间。0的值表示相邻节点之间没有连接。另一方面，1的值表示邻居的网络形成一个完全图，其中所有邻居都是连接的。
- en: The clustering coefficient of common neighbors is a link prediction variant,
    where you only calculate how connected the common neighbors of a particular pair
    of nodes are. Researchers have shown (Wu et al., 2015) that the clustering coefficient
    of common neighbors can improve the accuracy of link prediction models.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 共同邻居的聚类系数是链接预测的一种变体，其中你只计算特定节点对共同邻居的连通性。研究人员已经证明（Wu等，2015年），共同邻居的聚类系数可以提高链接预测模型的准确性。
- en: To calculate the local clustering coefficient of common neighbors between a
    pair of nodes, you need to identify the number of common neighbors as well as
    the number of links between common neighbors. Once you have those numbers, you
    only need to divide the number of existing links between neighbors by the potential
    number of connections. The number of potential connections between neighbors equals
    the number of links if all neighbors are connected. The following Cypher statement
    calculates the clustering coefficient of common neighbors and stores the results
    as a relationship property.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算一对节点之间共同邻居的局部聚类系数，你需要确定共同邻居的数量以及共同邻居之间的链接数量。一旦你有了这些数字，你只需要将邻居之间现有链接的数量除以潜在连接的数量。如果所有邻居都连接在一起，邻居之间的潜在连接数量等于链接数量。以下
    Cypher 语句计算共同邻居的聚类系数并将结果存储为关系属性。
- en: Listing 10.7 Calculating the clustering coefficient of common neighbors between
    pairs of nodes in the train and test sets
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.7 计算训练和测试集中节点对之间共同邻居的聚类系数
- en: '[PRE6]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ Identifies and counts the number of common neighbors between a pair of nodes
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 识别并计算一对节点之间共同邻居的数量
- en: ❷ Identifies all existing relationships between common neighbors
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 识别共同邻居之间所有现有关系
- en: ❸ Calculates the clustering coefficient by dividing the number of existing relationships
    by the number of potential relationships
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 通过将现有关系数量除以潜在关系数量来计算聚类系数
- en: ❹ Stores the results as a relationship property
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 将结果存储为关系属性
- en: You might have noticed that you treat relationships in the feature set as undirected
    at query time throughout the example in this section. The Cypher statement in
    listing 10.7 is no different. At first, you ignore the relationship direction
    when identifying common neighbors. Since the relationships are treated as undirected,
    the number of potential connections is also 50% fewer than if you had a directed
    network. Therefore, the number of potential relationships in the Cypher statement
    is divided by 2 in the second-last line of listing 10.7\.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，在本节的示例中，你在查询时将特征集中的关系视为无向的。列表 10.7 中的 Cypher 语句也不例外。最初，你在识别共同邻居时忽略关系方向。由于关系被视为无向的，潜在连接的数量也比有向网络少
    50%。因此，列表 10.7 的第二行最后将潜在关系数量除以 2。
- en: 10.4 Link prediction classification model
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.4 链接预测分类模型
- en: The only thing left to do is to train and evaluate a link prediction model.
    *Link prediction* is a binary classification problem where you predict whether
    a link is likely to form in the future. You will train a random forest classification
    model to solve the link prediction task based on the features you calculated for
    the train and test sets of relationships. The random forest classification model
    is used here because it is relatively robust to feature scaling and collinearity
    issues. However, you could have chosen other classification models, like the logistic
    regression or support vector machine.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的唯一任务是训练和评估链接预测模型。*链接预测* 是一个二元分类问题，其中你预测一个链接是否可能在将来形成。你将基于你为关系训练和测试集计算的特征来训练一个随机森林分类模型以解决链接预测任务。在这里使用随机森林分类模型是因为它对特征缩放和共线性问题相对稳健。然而，你也可以选择其他分类模型，如逻辑回归或支持向量机。
- en: Use the following Cypher statement to retrieve link prediction features and
    output from the database.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下 Cypher 语句从数据库中检索链接预测特征和输出。
- en: Listing 10.8 Retrieving link prediction features and class output
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.8 检索链接预测特征和分类输出
- en: '[PRE7]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The Cypher statement in listing 10.8 retrieves the features stored on the `TEST_TRAIN`
    and `NEGATIVE_TEST_TRAIN` relationships. The last column in the results of listing
    10.8 is the `output` column, which differentiates between positive and negative
    classification examples. Positive examples are tagged with the `TEST_TRAIN` relationship
    type and are represented with a value of 1, while the negative examples are marked
    with `NEGATIVE_TEST_TRAIN` and are represented as 0.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.8 中的 Cypher 语句检索存储在 `TEST_TRAIN` 和 `NEGATIVE_TEST_TRAIN` 关系上的特征。列表 10.8
    的结果中的最后一列是 `output` 列，用于区分正负分类示例。正例用 `TEST_TRAIN` 关系类型标记，表示为 1，而负例用 `NEGATIVE_TEST_TRAIN`
    标记，表示为 0。
- en: Examining the distribution of relevant features is advisable, as with any other
    machine learning task. The pandas dataframe has a `describe()` method that calculates
    the distributions of values in columns.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 检查相关特征的分布是建议的，就像任何其他机器学习任务一样。pandas 数据框有一个 `describe()` 方法，用于计算列中值的分布。
- en: Listing 10.9 Defining the connection to Neo4j
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.9 定义与 Neo4j 的连接
- en: '[PRE8]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Figure 10.13 shows the distribution of link prediction features. Interestingly,
    the network distance feature ranges from 2 to 4; however, it is mainly 2, as the
    mean network distance is barely 2.055\. Moreover, it might not be the most predictable
    feature in this example, due to its low variance. The preferential attachment
    has a wide range, from 0 to nearly 3,000,000\. Remember, the preferential attachment
    is calculated by multiplying the degrees of both nodes in the pair. The only way
    a preferential attachment can be 0 is if some nodes have zero connections. While
    all nodes have relationships in the original network, that might not be so in
    the feature set, where some connections are missing, due to the data split. Interestingly,
    the clustering coefficient is relatively high, on average.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.13 展示了链接预测特征的分布。有趣的是，网络距离特征的范围从 2 到 4；然而，它主要是 2，因为平均网络距离仅为 2.055。此外，由于它的方差较低，它可能不是这个例子中最可预测的特征。优先连接的范围很广，从
    0 到近 3,000,000。记住，优先连接是通过乘以一对节点中两个节点的度数来计算的。优先连接为 0 的唯一方式是某些节点没有连接。虽然所有节点在原始网络中都有关系，但在特征集中，由于数据拆分，某些连接可能缺失。有趣的是，聚类系数相对较高，平均来看。
- en: '![10-13](../../OEBPS/Images/10-13.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![10-13](../../OEBPS/Images/10-13.png)'
- en: Figure 10.13 Distribution of link prediction features
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.13 链接预测特征分布
- en: 10.4.1 Missing values
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.4.1 缺失值
- en: In total, there are 26,164 training and test samples. However, figure 10.13
    also indicates that some values are missing in the `networkDistance` and `adamicAdar`
    columns. For example, there are only 26,102 non-null values under the `networkDistance`
    feature. The network distance is undefined because the two nodes are not in the
    same component. Therefore, no path exists between the two. As mentioned, isolated
    nodes in the network might be the leading cause of missing network distance values.
    You can fill in the missing values with a maximum distance value of 4\. Remember,
    the higher the network distance is between a pair of nodes, the less likely a
    link will be formed between them, at least in theory. So if a pair of nodes is
    not in the same component, which is a null network distance in this example, you
    want to choose a value representing a significant network distance to fill in
    missing values. Therefore, you may decide to pick the maximum value of the network
    distance (4) in the dataset to fill in the missing values.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 总共有 26,164 个训练和测试样本。然而，图 10.13 也表明 `networkDistance` 和 `adamicAdar` 列中存在一些缺失值。例如，在
    `networkDistance` 特征下只有 26,102 个非空值。网络距离未定义，因为这两个节点不在同一个组件中。因此，它们之间不存在路径。正如之前提到的，网络中的孤立节点可能是导致网络距离值缺失的主要原因。你可以用最大距离值
    4 来填充缺失值。记住，节点对之间的网络距离越高，它们之间形成链接的可能性就越小，至少在理论上是这样的。所以，如果一对节点不在同一个组件中，在这个例子中就是网络距离为空，你想要选择一个表示显著网络距离的值来填充缺失值。因此，你可能会决定选择数据集中网络距离的最大值（4）来填充缺失值。
- en: Another column with missing values is `adamicAdar`, which might happen when
    a pair of nodes have no common neighbors. You can fill in the missing values of
    the `adamicAdar` column with a mean Adamic-Adar value of about 8.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 另一列存在缺失值的列是 `adamicAdar`，这种情况可能发生在一对节点没有共同邻居时。你可以用大约 8 的平均 Adamic-Adar 值来填充
    `adamicAdar` 列的缺失值。
- en: Listing 10.10 Filling in the missing values
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.10 填充缺失值
- en: '[PRE9]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 10.4.2 Training the model
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.4.2 训练模型
- en: With all the preprocessing steps done, you can go ahead and train the link prediction
    model. The `data` dataframe contains both the train and test sets of relationships.
    Therefore, you will first use the `train_test_split` from the scikit-learn library
    to split the test and train sets. You will use 80% of the samples as training
    examples and the remaining 20% to evaluate the model. If you were planning to
    perform any hyperparameter optimization of the classification model, you could
    also produce a validation set. However, optimizing the classification model itself
    is beyond the scope of this book, so you will skip creating a validation set.
    After the dataset split, you will feed the training samples into the random forest
    model, which will learn to predict whether a link is probable in the future.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成所有预处理步骤后，你可以继续训练链接预测模型。`data` 数据框包含关系训练集和测试集。因此，你将首先使用 scikit-learn 库中的 `train_test_split`
    函数来分割测试集和训练集。你将使用 80% 的样本作为训练示例，剩余的 20% 用于评估模型。如果你计划对分类模型进行超参数优化，你也可以生成一个验证集。然而，优化分类模型本身超出了本书的范围，所以你将跳过创建验证集。在数据集分割后，你将训练样本输入到随机森林模型中，该模型将学习预测未来是否存在链接的可能性。
- en: Listing 10.11 Splitting the train and test sets and training the link prediction
    model
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.11 分割训练集和测试集并训练链接预测模型
- en: '[PRE10]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The code in listing 10.11 starts by defining the feature and target columns.
    The `output` column is used as the target, while all the other columns are used
    as model features. Next, you perform a test/train split with the `train_test_split`
    function. Finally, you instantiate a random forest model and learn it based on
    the training samples.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.11 中的代码首先定义了特征和目标列。`output` 列用作目标，而所有其他列都用作模型特征。接下来，你使用 `train_test_split`
    函数进行测试/训练分割。最后，你实例化一个随机森林模型，并基于训练样本进行学习。
- en: 10.4.3 Evaluating the model
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.4.3 评估模型
- en: As with all machine learning tasks, you should evaluate the performance of your
    link prediction model using the test set. In the following listing, you will generate
    a classification report using a built-in scikit-learn function.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有机器学习任务一样，你应该使用测试集来评估你的链接预测模型的表现。在以下列表中，你将使用内置的 scikit-learn 函数生成一个分类报告。
- en: Listing 10.12 Generating the classification report
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.12 生成分类报告
- en: '[PRE11]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The code in listing 10.12 produces the classification report shown in figure
    10.14, which can be used to evaluate the model.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.12 中的代码生成了图 10.14 所示的分类报告，可以用来评估模型。
- en: '![10-14](../../OEBPS/Images/10-14.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![10-14](../../OEBPS/Images/10-14.png)'
- en: Figure 10.14 Classification report of the link prediction model
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.14 链接预测模型的分类报告
- en: Congratulations! You have trained a link prediction model with an accuracy of
    92%. The accuracy is a good metric, as the ratio between negative and positive
    samples is even.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你已经训练了一个准确率为 92% 的链接预测模型。准确率是一个很好的指标，因为负样本和正样本的比例是均衡的。
- en: Finally, you can evaluate the feature importance of the trained link prediction
    model. The following code will produce an ordered dataframe with the features
    ordered by their importance, descending.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以评估训练好的链接预测模型的特征重要性。以下代码将生成一个按特征重要性降序排列的有序数据框。
- en: Listing 10.13 Evaluating feature importance
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.13 评估特征重要性
- en: '[PRE12]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Table figure 10.15 shows that the network distance is the least important feature,
    by a wide margin. That was somewhat expected, due to the low variance of the network
    distance feature. Interestingly, the most relevant feature is the Adamic-Adar
    index, followed by the common neighbor and preferential attachment features. Note
    that you might get slightly different results due to the random dataset split
    used at the beginning of this chapter.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 表 10.15 显示，网络距离是最不重要的特征，差距很大。这在某种程度上是可以预料的，因为网络距离特征的方差较低。有趣的是，最相关的特征是 Adamic-Adar
    指数，其次是共同邻居和优先连接特征。请注意，由于本章开头使用随机数据集分割，你可能会得到略微不同的结果。
- en: '![10-15](../../OEBPS/Images/10-15.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![10-15](../../OEBPS/Images/10-15.png)'
- en: Figure 10.15 Feature importance
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.15 特征重要性
- en: 10.5 Solutions to exercises
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 10.5 练习题解答
- en: The solution to exercise 10.1 is as follows.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 10.1 的解答如下。
- en: Listing 10.14 Counting the number of relationships
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.14 计算关系数量
- en: '[PRE13]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The solution to exercise 10.2 is as follows.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 10.2 的解答如下。
- en: Listing 10.15 Constructing the positive example for the test and train sets
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 10.15 构建测试集和训练集的正例
- en: '[PRE14]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The solution to exercise 10.3 is as follows.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 10.3 的解答如下。
- en: Listing 10.16 Constructing the negative example for the test and train sets
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.16 构建测试集和训练集的负例
- en: '[PRE15]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The solution to exercise 10.4 is as follows.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 练习10.4的解决方案如下。
- en: Listing 10.17 Calculating the preferential attachment feature for pairs of nodes
    in the train and test sets
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.17 计算训练集和测试集中节点对的偏好连接特征
- en: '[PRE16]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The solution to exercise 10.5 is as follows.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 练习10.5的解决方案如下。
- en: Listing 10.18 Calculating the common neighbors feature for pairs of nodes in
    the train and test sets
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 列表10.18 计算训练集和测试集中节点对的共同邻居特征
- en: '[PRE17]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Summary
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: Link prediction is a task of predicting future or missing links in the network.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 链接预测是预测网络中未来或缺失链接的任务。
- en: Link prediction models are frequently used in recommender systems.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 链接预测模型常用于推荐系统中。
- en: Link prediction features are designed to encode similarity or distance between
    pairs of nodes.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 链接预测特征旨在编码节点对之间的相似性或距离。
- en: Link prediction features can be constructed by aggregating node properties,
    evaluating network distance, or examining local or global neighborhood overlap.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 链接预测特征可以通过聚合节点属性、评估网络距离或检查局部或全局邻域重叠来构建。
- en: If you use transductive node embeddings in link prediction workflows, you cannot
    generate node embeddings for new unseen nodes during training and, therefore,
    cannot predict future links for nodes that weren’t present during the training.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你使用归纳节点嵌入在链接预测工作流程中，你无法在训练期间为新的未见节点生成节点嵌入，因此无法预测训练期间未出现的节点的未来链接。
- en: Feature leakage occurs when a feature contains the same or comparable information
    as the output variable. You could run into leakage problems if you used the same
    relationships to generate network features as well as train and evaluate a classification
    model. Therefore, it is necessary to split the dataset into feature, train, and
    test sets. Optionally, you can introduce a validation set if you plan to perform
    any hyperparameter optimization.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一个特征包含与输出变量相同或可比较的信息时，就会发生特征泄漏。如果你使用相同的关系来生成网络特征以及训练和评估分类模型，可能会遇到泄漏问题。因此，有必要将数据集分为特征、训练和测试集。如果你计划执行任何超参数优化，也可以引入验证集。
- en: The feature set is used to calculate network features, while the test and train
    sets provide classification samples to train and evaluate a model. Optionally,
    you can also introduce a validation set if you plan to implement any hyperparameter
    optimization techniques.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特征集用于计算网络特征，而测试集和训练集提供分类样本以训练和评估模型。如果你计划实现任何超参数优化技术，你也可以引入验证集。
- en: Using all the negative examples during training would lead to a considerable
    class imbalance. Therefore, it is common to subsample the negative examples and
    use about the same number of positive and negative samples.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在训练期间使用所有负例会导致相当大的类别不平衡。因此，通常会对负例进行子采样，并使用大约相同数量的正例和负例。
- en: The network distance encodes how close a pair of nodes are in the network. The
    theory states that the closer a pair of nodes is, the more likely it is they will
    form a future link.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络距离编码了节点对在网络中的接近程度。理论表明，节点对越接近，它们形成未来链接的可能性就越大。
- en: The preferential attachment principle nicely captures how most real-world networks
    evolve. The underlying idea is that the rich get richer. Therefore, nodes with
    a higher number of existing links are more likely to form new links in the future.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 偏好连接原则很好地捕捉了大多数现实世界网络如何演变。其基本思想是“富者愈富”。因此，具有更多现有链接的节点在未来更有可能形成新的链接。
- en: Local neighborhood overlap features can be as simple as the number of common
    neighbors two nodes have or as advanced as the Adamic-Adar index, which assumes
    the smaller degree the common neighbors between a pair of nodes have, the more
    likely the pair is to form a connection in the future.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地邻域重叠特征可以简单到两个节点共有的邻居数量，也可以高级到Adamic-Adar指数，该指数假设一对节点之间共有邻居的度数越小，这对节点未来形成连接的可能性就越大。
