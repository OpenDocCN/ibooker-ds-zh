- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Routing
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 路由
- en: '**This chapter covers**'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**本章涵盖**'
- en: What routes are and demonstrates how to create them
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由是什么以及如何创建它们的示例
- en: Different patterns for navigation and their merits
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同的导航模式及其优点
- en: How to protect pages from access without authorization
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何保护页面不被未经授权的访问
- en: Organizing code into modules
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将代码组织成模块
- en: Using secondary routes for multiple routes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用二级路由进行多路由
- en: Most applications require the ability to navigate between different pages during
    the lifecycle of the application. Typically, an application has at least a few
    basic pages, such as a login page, home page, user’s account page, and so forth.
    *Routing* is the term used to describe the capability for the application to change
    the content on the page as the user navigates around. Our previous chapter examples
    haven’t used routing; they’ve been limited to displaying all the content at once.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数应用程序在应用程序的生命周期中都需要能够在不同的页面之间导航的能力。通常，一个应用程序至少有几个基本页面，例如登录页面、主页、用户账户页面等等。“路由”这个术语用来描述应用程序在用户导航时更改页面内容的能力。我们之前的章节示例没有使用路由；它们被限制为一次性显示所有内容。
- en: The web has a well-established pattern of using URLs to maintain the current
    location of a user. This has traditionally happened (and often still does today)
    by the browser requesting a page from a server and the server responding with
    the necessary HTML, CSS, and JavaScript assets. When single page applications
    (SPAs) became viable, the role of routing had to move fully into the browser,
    by allowing JavaScript to manipulate the current URL in the browser to maintain
    the current location within the application, even if the application runs entirely
    in the browser.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 互联网已经形成了一种使用URL来维护用户当前位置的成熟模式。这传统上是通过浏览器从服务器请求页面，服务器响应必要的HTML、CSS和JavaScript资源来实现的。当单页应用程序（SPA）变得可行时，路由的作用必须完全转移到浏览器，通过允许JavaScript操作浏览器中的当前URL来维护应用程序内的当前位置，即使应用程序完全在浏览器中运行。
- en: Angular provides a comprehensive routing library that makes it straightforward
    to create simple and complex navigation patterns. Angular’s router library gives
    us the ability to easily define routes and replaces the need for the server to
    handle resolving what to display based on the current URL. Instead of using the
    term *page* to describe different places the user can access, I’ll use the term
    *view* to describe these different contexts, such as login view or dashboard view.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Angular提供了一个全面的路由库，使得创建简单和复杂的导航模式变得简单。Angular的路由库使我们能够轻松地定义路由，并取代了服务器处理基于当前URL显示内容的需要。我不再使用“页面”这个词来描述用户可以访问的不同位置，而是使用“视图”这个词来描述这些不同的上下文，例如登录视图或仪表板视图。
- en: You’ll see an example of how to structure your application into different feature
    modules. Thus far, we’ve only created one module for our application. When we
    introduce routing into our application, the complexity and size of our applications
    are likely to increase. We’ll see how to create different modules to keep parts
    of the application separate from one another. Although we could have done this
    in other chapters, this chapter example has the most distinct separation between
    different capabilities.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到如何将应用程序结构化为不同的功能模块的示例。到目前为止，我们只为我们的应用程序创建了一个模块。当我们引入路由到我们的应用程序中时，应用程序的复杂性和大小很可能会增加。我们将看到如何创建不同的模块，以使应用程序的不同部分相互分离。尽管我们可以在其他章节中这样做，但本章示例在不同功能之间的分离最为明显。
- en: The first thing we’ll do is get the chapter example set up.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先要做的是设置好本章的示例。
- en: 7.1 Setting up the chapter example
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.1 设置本章示例
- en: In this chapter, we’re going to set up a basic community website where the user
    can browse forums, blogs, and chat with other users ([figure 7.1](#figure7.1)).
    I’ve already created the components and services you’ll need for displaying these
    features, but I’ve left out the capabilities that will make it functional with
    routes.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将搭建一个基本的社区网站，用户可以在网站上浏览论坛、博客，并与其他用户聊天（[图7.1](#figure7.1)）。我已经创建了显示这些功能的组件和服务，但省略了使其通过路由功能化的能力。
- en: In the example, there’s a Forums section where you can view all topics in a
    forum and then view all of the posts of a particular topic. There’s also a Blogs
    section, where you can see a list of blog posts you can view individually. Lastly,
    there’s a chat feature that pops up over the rest of the content so you can chat
    with an automated robot while browsing the rest of the site. The application also
    has login ability and an error page if you navigate to an unknown URL.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例中，有一个论坛部分，您可以查看论坛中的所有主题，然后查看特定主题的所有帖子。还有一个博客部分，您可以查看可以单独查看的博客帖子列表。最后，还有一个聊天功能，它会在其他内容上方弹出，让您在浏览网站其他部分的同时与自动机器人聊天。该应用程序还具有登录功能，如果您导航到未知的URL，则会显示错误页面。
- en: 'Each of these features has at least one route, often more. Let’s look at a
    short list of routes that we’ll build in this chapter. These routes represent
    an important place inside of the application that a user can land in:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这些功能中的每一个至少有一个路由，通常更多。让我们看看本章中我们将构建的简短路由列表。这些路由代表应用程序中的重要位置，用户可以到达：
- en: List of forums, which also acts as the default view
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 论坛列表，也作为默认视图
- en: Individual forum, which shows a list of topics
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单个论坛，显示主题列表
- en: Individual topic, which shows the posts in the topic
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单个主题，显示主题中的帖子
- en: List of blog posts
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 博客帖子列表
- en: Individual blog post
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单个博客帖子
- en: Chat box for selecting another user to chat with
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择与其他用户聊天的聊天框
- en: Chat box for talking with another user
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与其他用户聊天的聊天框
- en: Login view
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 登录视图
- en: Not found error view
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未找到错误视图
- en: '![c07-1.png](image_fi/293313c07/c07-1.png)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![c07-1.png](image_fi/293313c07/c07-1.png)'
- en: '[**Figure 7.1**](#figureanchor7.1) Community application with forums, blogs,
    and chat chapter example'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '[**图7.1**](#figureanchor7.1) 具有论坛、博客和聊天章节的社区应用程序示例'
- en: 'Because I’ve already created much of the application, we’ll start by downloading
    the existing code either with Git or by downloading the archive from GitHub. This
    helps us focus on adding only the necessary pieces for routing. If you’re using
    Git, then you can run the following command:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我已经创建了应用程序的大部分内容，我们将从下载现有代码开始，无论是使用Git还是从GitHub下载存档。这有助于我们专注于仅添加路由所需的必要部分。如果您使用Git，则可以运行以下命令：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Otherwise, you should download and unzip the project from GitHub: [https://github.com/angular-in-action/community/archive/start.zip](https://github.com/angular-in-action/community/archive/start.zip).
    You should now have a copy of the code on your computer. You’ll need to also install
    the node modules for the project. Navigate to the directory and run the following
    to install the modules and then preview the project:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，您应该从GitHub下载并解压项目：[https://github.com/angular-in-action/community/archive/start.zip](https://github.com/angular-in-action/community/archive/start.zip)。现在您应该在您的计算机上有一个代码副本。您还需要安装项目的node模块。导航到目录并运行以下命令以安装模块并预览项目：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Initially, the application looks empty, but when we start to set up routes,
    pages will begin to function. It should appear as you see in [figure 7.2](#figure7.2).
    The data for this application is stored in a couple of static TypeScript files
    (named data.ts), just to avoid having to build an API for this demo and keep it
    fast. I’ve also kept the application simpler by avoiding the complexities of allowing
    users to create new forum posts or blog posts. The routing knowledge you gain
    from this chapter will help you to easily add those abilities after we cover the
    forms in the next chapter.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，应用程序看起来是空的，但当我们开始设置路由时，页面将开始工作。它应该看起来像您在[图7.2](#figure7.2)中看到的那样。该应用程序的数据存储在几个静态TypeScript文件（命名为data.ts）中，只是为了避免为这个演示构建API并保持其快速。我还通过避免允许用户创建新的论坛帖子或博客帖子的复杂性来简化了应用程序。您从本章中获得的路由知识将帮助您在下一章介绍表单后轻松添加这些功能。
- en: '![c07-2.png](image_fi/293313c07/c07-2.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![c07-2.png](image_fi/293313c07/c07-2.png)'
- en: '[**Figure 7.2**](#figureanchor7.2) What the application should look like based
    on the starting point'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '[**图7.2**](#figureanchor7.2) 基于起点应用应呈现的样子'
- en: Now that you’ve got the files and everything set up, let’s get to creating our
    first set of routes!
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经获得了文件和所有设置，让我们开始创建我们的第一组路由！
- en: 7.2 Route definitions and router setup
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.2 路由定义和路由设置
- en: There are a few basic concepts that the Angular router leans on, but it’s very
    flexible, and you can create many combinations of various types of navigation
    experiences. A router is responsible for coordinating the navigation options for
    a user as they click and interact with your application.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Angular路由器依赖于几个基本概念，但它非常灵活，你可以创建许多不同类型的导航体验的组合。路由器负责协调用户在点击和与应用程序交互时的导航选项。
- en: At its most basic, the router handles rendering a component based on the current
    URL, such as having a Home component render on the main view. It also allows you
    to create child routes, where only inside portions of a component change based
    on the route, such as when you have commonly shared portions of the page that
    always exist, but the inner content swaps based on the URL. It also can support
    auxiliary routes that sit “above” the current route and have a separate routing
    history entirely, like live support chat boxes.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在最基本的情况下，路由器根据当前URL渲染组件，例如，让主视图上的Home组件渲染。它还允许你创建子路由，其中只有组件的内部部分根据路由而改变，例如，当页面上有始终存在的常用部分，但内部内容根据URL交换时。它还可以支持位于当前路由“之上”的辅助路由，并且具有完全独立的路由历史，如实时支持聊天框。
- en: 'Our first step is to get the router included in the project, and then we’ll
    get to create our first couple of routes, as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一步是将路由器包含到项目中，然后我们将创建我们的第一个几个路由，如下所示：
- en: '`/login` —Displays the login page'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/login` — 显示登录页面'
- en: '`/` —Redirects to the default /forums page in case they load the root page'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/` — 如果加载根页面，则重定向到默认的/forums页面'
- en: '`**` —Fallback for matching any route that isn’t defined, like a 404 page'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**` — 匹配任何未定义的路由的回退，如404页面'
- en: Our goal in this section is to get the router set up, to set up a default route,
    and to define a fallback route. You’ll likely follow these steps for each of your
    projects in which you use a router.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的目标是设置好路由器，设置默认路由，并定义一个回退路由。你可能会在所有使用路由器的项目中遵循这些步骤。
- en: 'The Angular router is included as a separate package (@angular/router), which
    the CLI includes as part of the npm packages, but doesn’t actually load into the
    Application module. If you have a project that doesn’t have the module package,
    you can install it via npm like so:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Angular路由器作为一个单独的包（@angular/router）被包含，CLI将其作为npm包的一部分包含，但实际上并没有将其加载到应用程序模块中。如果你有一个没有模块包的项目，你可以通过npm像这样安装它：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: When we include the router, we’ll also need to define a set of routes that are
    valid for our application. To start off, we’ll have two routes. The first is a
    login screen, and you should notice the corresponding Login component in the app.
    The second is a 404 not found page, which also has a corresponding NotFound component
    in the app.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们包含路由器时，我们还需要定义一组适用于我们应用程序的路由。首先，我们将有两个路由。第一个是登录界面，你应该注意到应用中相应的登录组件。第二个是404未找到页面，该页面在应用中也有相应的NotFound组件。
- en: All routes have to be defined, and a definition is only a basic object with
    at least one property. There are more than a dozen properties you can use to define
    a route, but a typical route contains a path (or the URL) and a component (the
    component to display based on the path). We’ll see some other properties in action
    in this chapter as well, but we’ll focus first on these two.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 所有路由都必须定义，定义仅是一个具有至少一个属性的基本对象。你可以使用十几个属性来定义路由，但典型的路由包含一个路径（或URL）和一个组件（根据路径显示的组件）。我们将在本章中看到一些其他属性的应用，但首先我们将关注这两个。
- en: 'Let’s define the login route first as we set up the router in the app. Open
    the src/app/app.module.ts file and add the following imports to the file—this
    includes the Router module and an interface that describes how routes should be
    defined:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在设置应用程序中的路由器时首先定义登录路由。打开src/app/app.module.ts文件，并将以下导入添加到文件中——这包括路由器模块和一个描述如何定义路由的接口：
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can now define our first routes. Create a new variable with the following
    values, and then we’ll look at both to understand the type of route they define.
    You can place this right after the last `import` statement:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以定义我们的第一个路由了。创建一个包含以下值的新变量，然后我们将查看这两个变量以了解它们定义的路由类型。你可以在最后一个`import`语句之后放置这个变量：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `appRoutes` variable, which is typed to `Routes`, is an array of simple
    objects. These objects can have different properties, and we’ll use many of them
    in this chapter. You can see all the properties here: [https://angular.io/api/router/Routes](https://angular.io/api/router/Routes).
    Table 7.1 lists the properties we’ll use in this chapter, which is most of them.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`appRoutes`变量，它被类型化为`Routes`，是一个简单对象的数组。这些对象可以有不同的属性，我们将在本章中使用其中许多属性。你可以在这里看到所有属性：[https://angular.io/api/router/Routes](https://angular.io/api/router/Routes)。表7.1列出了本章中我们将使用的属性，其中大部分。'
- en: '**Table 7.1** Route properties used in this chapter and their purposes'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**表7.1** 本章中使用的路由属性及其用途'
- en: '| **Property** | **Accepted values** | **Purpose** |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| **属性** | **可接受值** | **用途** |'
- en: '| --- | --- | --- |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `path` | A string, or wildcard matcher ** | Defines the URL path to use for
    a route; it’s appended to any parent paths if routes are nested |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `path` | 字符串，或通配符匹配器** | 定义用于路由的URL路径；如果路由嵌套，则附加到任何父路径上 |'
- en: '| `component` | Reference to a component | Identifies which component is tied
    to a particular route |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `component` | 组件的引用 | 识别与特定路由相关联的组件 |'
- en: '| `redirectTo` | A string of another valid route | Redirects a user from one
    route (the path) to the route defined in `redirectTo` |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `redirectTo` | 另一个有效路由的字符串 | 从一个路由（路径）重定向用户到`redirectTo`中定义的路由 |'
- en: '| `pathMatch` | ‘full’, ‘prefix’ | Determines the matching strategy, whether
    to match a partial or full URL for a route |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| `pathMatch` | ‘full’，‘prefix’ | 确定匹配策略，是否匹配路由的完整或部分URL |'
- en: '| `children` | An array of routes | List of routes that are loaded as children
    of this route |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `children` | 路由数组 | 列出作为此路由子路由加载的路由 |'
- en: '| `outlet` | String of a named outlet | Tells the route to load in a specific
    router outlet |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `outlet` | 命名出口的字符串 | 告诉路由在特定的路由出口中加载 |'
- en: '| `loadChildren` | A string with a path to a module | Allows you to lazy load
    a new module when a particular route is requested |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `loadChildren` | 模块的路径字符串 | 允许你在请求特定路由时懒加载新的模块 |'
- en: '| `canActivate` | Array of references to guards | Allows you to prevent a route
    from being used under certain conditions, such as not being logged in |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `canActivate` | 守卫引用的数组 | 允许你在某些条件下防止使用路由，例如未登录 |'
- en: The first route is the most basic and probably most common type of route. It
    defines that when a certain path is found in the URL, Angular should render the
    specified component. The path can’t start with the backslash. This route means
    that if the browser is at the URL http://localhost:4200/login, it will render
    the Login component.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个路由是最基本的，也可能是最常见的路由类型。它定义了当在URL中找到某个路径时，Angular应该渲染指定的组件。路径不能以反斜杠开头。此路由意味着如果浏览器位于URL
    http://localhost:4200/login，它将渲染Login组件。
- en: The second route is a redirect route. Angular allows you to redirect paths to
    other URLs, just as you might with your back end server. The `redirectTo` property
    defines the new URL to navigate to, and the `pathMatch` property declares that
    the path must match exactly before the redirect will trigger. If you want to redirect
    a path and all its children, you could set the `pathMatch` to the value `'prefix'`.
    In this case, the root path http://localhost:4200/ will redirect to http://localhost:4200/forums.
    We haven’t implemented the forums link yet, so it will render the third route.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种路由是一个重定向路由。Angular允许你将路径重定向到其他URL，就像你可能在你后端服务器上做的那样。`redirectTo`属性定义了要导航的新URL，而`pathMatch`属性声明在重定向触发之前路径必须完全匹配。如果你想重定向一个路径及其所有子路径，可以将`pathMatch`设置为`'prefix'`值。在这种情况下，根路径http://localhost:4200/将重定向到http://localhost:4200/forums。我们还没有实现论坛链接，所以它将渲染第三种路由。
- en: The third route is similar to the first in that it defines a path and a component,
    but the path with two asterisks makes this a wildcard, catch-all type route. If
    you go to any route that isn’t known by Angular, such as http://localhost:4200/not-a-route,
    it will render the NotFound component.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种路由与第一种类似，因为它定义了一个路径和一个组件，但带有两个星号的路径使其成为一个通配符、捕获所有类型的路由。如果你访问Angular不知道的任何路由，例如http://localhost:4200/not-a-route，它将渲染NotFound组件。
- en: You’ll want to have a wildcard route in your application to prevent navigational
    errors. I recommend setting up a component like the NotFound component in all
    your applications from the start.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想在应用程序中有一个通配符路由来防止导航错误。我建议从一开始就在所有应用程序中设置一个类似于NotFound组件的组件。
- en: 'We’ve defined our routes. Now we need to set up the router to use them. Inside
    of the `imports` section of the module, you need to add the Router module, as
    you see here. I’ve bolded the new line to add:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经定义了我们的路由。现在我们需要设置路由以使用它们。在模块的 `imports` 部分中，你需要添加路由模块，就像你在这里看到的那样。我已经加粗了添加的新行：
- en: '[PRE5]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: What we’ve done is include the router in our application, and we’ve used the
    `forRoot()` method to declare that we’re using the router in the main App module.
    It also takes a parameter, which should be an array of routes declared by this
    module. If you don’t pass anything here, the router won’t know about any of your
    routes, so it’s the way to pass configuration into the router.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所做的是在我们的应用程序中包含了路由，并使用 `forRoot()` 方法声明我们在主 App 模块中使用路由。它还接受一个参数，这个参数应该是该模块声明的路由数组。如果你在这里不传递任何内容，路由将不知道任何你的路由，所以这是将配置传递给路由的方式。
- en: The last step is to make sure there’s a Router Outlet component somewhere in
    your application. You may have been wondering where exactly it will render these
    components. If you recall from chapter 2, the router needs to know where to render
    the content for a given route, and the router outlet is the location marker. You’ll
    need at least one router outlet in your application.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是确保你的应用程序中某个地方有一个路由出口组件。你可能想知道这些组件将渲染在哪个地方。如果你还记得第2章的内容，路由需要知道为给定路由渲染内容的地点，而路由出口就是标记位置。你的应用程序中至少需要一个路由出口。
- en: Open the src/app/app.component.html file and note that it contains markup for
    a header and navigation, as well as a content area, which right now contains a
    single header element. Because the navigation will remain consistent between all
    routes, it exists outside of the router outlet. This means we don’t have to redefine
    the navigation in every route, and I like to think of this as a “global template”
    that’s always active. Often global navigation or footers are good candidates,
    but anything that you would have to copy and paste into every component is likely
    best in the global template.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `src/app/app.component.html` 文件，你会注意到它包含用于标题和导航的标记，以及一个内容区域，目前该区域只包含一个标题元素。由于导航将在所有路由之间保持一致，它存在于路由出口之外。这意味着我们不需要在每个路由中重新定义导航，我倾向于将其视为一个始终处于活动状态的“全局模板”。通常，全局导航或页脚是很好的候选者，但任何你需要复制粘贴到每个组件中的内容可能最好放在全局模板中。
- en: 'Replace the header element with the following element to define the router
    outlet. I’ve bolded the change for you:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 将标题元素替换为以下元素以定义路由出口。我已经为你加粗了更改：
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: When you run the application, go to http://localhost:4200 and you should see
    the NotFound component rendered in the screen. Type into the address bar *http://localhost:4200/login*
    and navigate to the page, and you should see the Login component render.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行应用程序时，访问 `http://localhost:4200`，你应该在屏幕上看到 NotFound 组件被渲染。在地址栏中输入 *http://localhost:4200/login*
    并导航到该页面，你应该看到 Login 组件被渲染。
- en: So far, we’ve seen a basic route definition, the wildcard matcher, and how to
    set up the router library with an outlet. You’ll go through these basic steps
    anytime you use the router. In some applications, you might not even need it to
    get more complex than this!
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了基本的路由定义、通配符匹配器以及如何设置带有出口的路由库。每次使用路由时，你都会经历这些基本步骤。在某些应用程序中，你可能甚至不需要它就变得比这更复杂！
- en: But most of the time you’ll need to navigate to different URLs and pass in information
    such as IDs for navigating to specific items. Let’s look at this now and see how
    we can build routes that have parameters as we look at how to use a feature module
    with our application.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 但大多数时候，你需要导航到不同的URL并传递信息，如ID以导航到特定项目。现在让我们看看如何构建具有参数的路由，同时查看如何使用功能模块与我们的应用程序一起使用。
- en: 7.3 Feature modules and routing
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.3 功能模块和路由
- en: The intention of Angular feature modules is to create isolated code that’s easier
    to maintain and that keeps things together that are logically connected. This
    is considered a best practice to implement when you have distinct parts of your
    application that can be split. I think the most important benefit is the isolation
    of code, but it also can help with creating tests, optimizing the build process,
    and implementing lazy loading of routes (which we’re more interested in right
    now).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Angular功能模块的目的是创建易于维护的隔离代码，并将逻辑上相关的内容放在一起。当你有可以分割的应用程序的不同部分时，这被认为是一种最佳实践。我认为最重要的好处是代码的隔离，但它还可以帮助创建测试、优化构建过程以及实现路由的懒加载（这是我们目前更感兴趣的）。
- en: A feature module can include the route definitions for the feature set (see
    figure 7.3). For example, our Forums section of the application should be its
    own feature module, and all routes that are related to the forum can be defined
    inside of it. This is best for decoupling, so we don’t have to define routes for
    a feature module outside of the feature module.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 功能模块可以包含功能集的路由定义（见图7.3）。例如，我们的应用论坛部分应该是一个独立的功能模块，所有与论坛相关的路由都可以在其中定义。这样最好地实现了解耦，因此我们不需要在功能模块外部定义路由。
- en: '![c07-3.png](image_fi/293313c07/c07-3.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![c07-3.png](image_fi/293313c07/c07-3.png)'
- en: '**Figure 7.3** Routes are defined by different modules.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '**图7.3** 路由由不同的模块定义。'
- en: 'This chapter example has two additional modules: the Forums module and the
    Blogs module. The Forums module has components and services for the Forums section
    of the site, and the Blogs Module has its own components and services to render
    the Blogs section. They’re already created in the repo, and if you’ve not spent
    time with feature modules before, you can take a look at them in the src/app/forums
    and src/app/blogs directories.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 本章示例有两个额外的模块：论坛模块和博客模块。论坛模块包含网站论坛部分的组件和服务，而博客模块有自己的组件和服务来渲染博客部分。它们已经在仓库中创建好了，如果你之前没有花时间研究功能模块，你可以查看src/app/forums和src/app/blogs目录中的它们。
- en: 'We can declare some routes in our feature modules, but we’ll have to include
    the router and define routes similarly to the previous step. There’s one key difference
    we’ll cover, but to get started, open the src/app/forums/forums.module.ts file
    and import the Router module:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在我们的功能模块中声明一些路由，但我们必须像上一步一样包含路由器并定义路由。我们将介绍一个关键的区别，但为了开始，打开src/app/forums/forums.module.ts文件并导入路由器模块：
- en: '[PRE7]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now we’ll create another array with route definitions. After the last `import`
    statement, create the following route definition variable:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将创建另一个包含路由定义的数组。在最后的`import`语句之后，创建以下路由定义变量：
- en: '[PRE8]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This will define a route to display a list of the available forums on the site
    by rendering out the Forums component. Now we need to register this list of routes
    with the router, but we need to use a slightly different syntax to make it work
    for feature modules. In the `imports` section of the Forums module, add the Router
    module like you see in bold here:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这将定义一个路由，通过渲染论坛组件来显示网站上可用的论坛列表。现在我们需要将这个路由列表注册到路由器中，但我们需要使用稍微不同的语法来使其适用于功能模块。在论坛模块的`imports`部分，添加与加粗部分相同的路由器模块：
- en: '[PRE9]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here we use `forChild()` instead of `forRoot()`, because we’re declaring routes
    that belong to an imported module instead of the main App module. Otherwise, the
    process is the same, and the route definitions follow the same rules.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`forChild()`而不是`forRoot()`，因为我们正在声明属于导入模块的路由，而不是主App模块的路由。否则，过程是相同的，路由定义遵循相同的规则。
- en: The feature module is already included in the App module as one of the imports.
    You must import a feature module into the main App module for it to be activated.
    Once you save these changes, you can view the forums page by going to http://localhost:4200/forums.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 功能模块已经作为导入之一包含在App模块中。你必须将功能模块导入主App模块才能激活它。一旦保存这些更改，你就可以通过访问http://localhost:4200/forums来查看论坛页面。
- en: When you’re planning your application, I’ve found it best to look for opportunities
    to organize features into separate modules. It’s always possible to move things
    into feature modules later, but if you know that you’ll have several key features
    that can be organized, you can set up modules early in development.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当你规划你的应用程序时，我发现最好的做法是寻找将功能组织到单独模块的机会。总是有可能在以后将事物移动到功能模块中，但如果你知道你将会有几个可以组织的关键功能，你可以在开发早期设置模块。
- en: When trying to determine what kinds of things belong together, I often look
    at the URL structures I expect my application to have. In this chapter example,
    I expect to put functionality under /forums and /blogs as two separate root paths,
    so these are good candidates for their own modules.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当尝试确定哪些事物属于一起时，我经常查看我期望我的应用程序拥有的URL结构。在本章示例中，我期望将功能放在/forums和/blogs作为两个独立的根路径下，因此它们是它们自己模块的好候选者。
- en: 7.4 Route parameters
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.4 路由参数
- en: URLs are designed to hold information, and sometimes that information tells
    you important details such as the ID of a resource to load or other stateful data.
    Depending on how you want to structure your URLs, values might be part of the
    path or the query.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: URL被设计用来存储信息，有时这些信息会告诉你重要的细节，例如要加载的资源ID或其他状态数据。根据你想要如何结构化你的URL，值可能是路径的一部分或查询的一部分。
- en: 'We’ll look at how to use query variables later; right now let’s focus on how
    to use a URL parameter to indicate a record ID. In our example, we have a list
    of forums displayed and we will want to click on a forum to see the threads inside
    it. The URL for these routes will be something like this:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在稍后查看如何使用查询变量；现在让我们专注于如何使用URL参数来指示记录ID。在我们的示例中，我们有一个论坛列表显示，我们希望点击一个论坛来查看其中的帖子。这些路由的URL可能如下所示：
- en: '[PRE10]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The difference here is that the second part of this URL will change depending
    on the forum we want to view, because it contains the alias (which is the ID and
    title together). Angular supports this with route parameters, which are straightforward
    to implement. First let’s add a new route to our Forums module that will denote
    the path with a parameter. Open the src/app/forums/forums.module.ts file and add
    a new route to the `forumsRoutes` array, as you see here in bold:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的不同之处在于，这个URL的第二部分将根据我们想要查看的论坛而变化，因为它包含别名（即ID和标题的组合）。Angular通过路由参数支持这一点，这些参数易于实现。首先，让我们向我们的论坛模块添加一个新的路由，以表示带有参数的路径。打开`src/app/forums/forums.module.ts`文件，并将一个新的路由添加到`forumsRoutes`数组中，正如你在这里加粗看到的那样：
- en: '[PRE11]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here we’ve defined a path with a parameter, which is any name we want to declare
    preceded by the colon (`:`) symbol. This will try to match any route that starts
    with *forums* and has a second part of the path, which could be any value, but
    if there’s a third segment to the path, the router wouldn’t match to this route.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个带有参数的路径，这个参数是我们想声明的任何名称，前面跟着冒号（`:`）符号。这将尝试匹配以*forums*开头的任何路由，并且路径的第二部分可以是任何值，但如果路径有第三个部分，路由器就不会匹配到这个路由。
- en: 7.4.1 Creating links in templates with routerLink
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.4.1 使用routerLink在模板中创建链接
- en: In order to allow users to navigate in the application, we need to create links
    that work with the Angular router. The way to do that is by using the special
    `routerLink` directive from Angular on an element that you want to be a clickable
    link.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许用户在应用程序中导航，我们需要创建与Angular路由器协同工作的链接。实现这一点的办法是使用Angular在你想成为可点击链接的元素上使用的特殊`routerLink`指令。
- en: 'Let’s add one `routerLink` to the top header bar to link to the forums page
    and see how to create a link using the basic implementation. Open src/app/app.component.html
    and update the line that contains the currently dead link to the forums with a
    `routerLink`, as you see in bold here:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在顶部导航栏中添加一个`routerLink`来链接到论坛页面，并查看如何使用基本实现创建链接。打开`src/app/app.component.html`并更新包含当前无效链接到论坛的行，使用`routerLink`，正如你在这里加粗看到的那样：
- en: '[PRE12]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this use of `routerLink`, it accepts the string with the appropriate path
    to use. If the path starts with a forward slash, it will treat the URL as an absolute
    path from the domain. It could also be a relative path without the slash. This
    is probably the most common way to use `routerLink`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个`routerLink`的使用中，它接受一个包含适当路径的字符串。如果路径以正斜杠开头，它将把URL视为从域名开始的绝对路径。它也可以是一个不带斜杠的相对路径。这可能是使用`routerLink`最常见的方式。
- en: We saw `routerLink` in chapter 2, but let’s take a moment and talk about why
    it exists and what it does. In order to facilitate navigating around, links must
    know which URL to go to, and typically `href` is the attribute for an anchor tag
    that gives the browser that information. When you use `href` with links, the browser
    will request a new URL from the server, which isn’t what we want. With Angular,
    `routerLink` is the attribute directive that denotes the expected route to navigate
    to and allows the Angular router to handle the actual navigation. In short, if
    you use `href` to link to a page, it will trigger a page load from the server,
    even if it’s a valid Angular route, and that’s much slower than using the router.
    This is a primary tenet of client-side routing.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在第二章中看到了 `routerLink`，但让我们花点时间来谈谈它为什么存在以及它做了什么。为了方便导航，链接必须知道要访问哪个 URL，通常 `href`
    是一个锚标签的属性，它向浏览器提供这个信息。当你使用 `href` 与链接一起时，浏览器将从服务器请求一个新的 URL，这不是我们想要的。在 Angular
    中，`routerLink` 是一个属性指令，表示预期的导航路由，并允许 Angular 路由器处理实际的导航。简而言之，如果你使用 `href` 来链接到一个页面，即使它是一个有效的
    Angular 路由，它也会触发从服务器加载页面，这比使用路由要慢得多。这是客户端路由的一个主要原则。
- en: 'That’s all it takes to create a link, but you can also bind an expression with
    `routerLink` for more dynamic links. To demonstrate this, we’ll add a link from
    the forums list to load the individual forum page. Open src/forums/forums/forums.component.html
    (yes, I know the file path is a bit redundant) and update the table row with the
    `NgFor` to include a `routerLink` to link to the forum:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 创建链接只需要这些，但你也可以使用 `routerLink` 绑定一个表达式来创建更动态的链接。为了演示这一点，我们将从论坛列表添加一个链接来加载单个论坛页面。打开
    src/forums/forums/forums.component.html（是的，我知道文件路径有点冗余）并更新表格行中的 `NgFor` 以包含一个
    `routerLink` 来链接到论坛：
- en: '[PRE13]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You’ll notice in this case we’re binding a value to it (by wrapping it with
    the `[]` notation). When you bind a value, it expects an array of path segments
    that it will use to construct the complete URL. In this case, we’re setting the
    forum alias value in this array. By default, it will treat routes as relative
    to the current URL, which means it will append to the current route. On this page,
    the URL is /forums, and each link will be routed to the forum by alias, like /forums/1-announcements.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到在这种情况下，我们正在绑定一个值到它（通过使用 `[]` 符号包裹）。当你绑定一个值时，它期望一个路径段数组，它将使用这个数组来构造完整的 URL。在这种情况下，我们在这个数组中设置了论坛别名值。默认情况下，它将路由视为相对于当前
    URL 的相对路径，这意味着它将附加到当前路由。在这个页面上，URL 是 /forums，每个链接将通过别名路由到论坛，例如 /forums/1-announcements。
- en: I like to use `routerLink` in this manner for any paths that don’t have any
    parameters, and I like to bind an array of values to `routerLink` when there are
    params. I find it easier to read this way, but you can settle on your own approach.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我喜欢用这种方式使用 `routerLink`，对于没有参数的任何路径，当有参数时，我喜欢将值数组绑定到 `routerLink`。我发现这样更容易阅读，但你可以根据自己的方法来决定。
- en: Notice that we also put a `routerLink` on a table row element, which is traditionally
    not a link. Angular is smart enough to add the correct click event listeners on
    any element with a `routerLink` to handle navigation, so you’re free to use it
    anywhere. Just be aware that it won’t add an `href` attribute to any element that
    isn’t an anchor tag.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们还在表格行元素上放置了一个 `routerLink`，这在传统上不是一个链接。Angular 足够智能，可以在任何带有 `routerLink`
    的元素上添加正确的点击事件监听器来处理导航，所以你可以自由地使用它。但请注意，它不会向任何非锚标签的元素添加 `href` 属性。
- en: 7.4.2 Accessing the route parameters in a component
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.4.2 在组件中访问路由参数
- en: Now we need to get the route parameter information into our Forum component
    so it knows which forum to display. Often, you’ll use this route parameter information
    to call one of your services to load data, and we’ll do that here.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要将路由参数信息传递到我们的论坛组件中，以便它知道要显示哪个论坛。通常，你会使用这个路由参数信息来调用你的某个服务来加载数据，我们在这里也会这样做。
- en: Angular provides a service that contains the currently active route metadata.
    It gives you access to a wealth of information, described at [https://angular.io/api/router/ActivatedRoute](https://angular.io/api/router/ActivatedRoute).
    It contains details such as the current URL, query or router parameters (and their
    current values), information about any children or parent routes, and more.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 提供了一个包含当前活动路由元数据的服务的功能。它为你提供了丰富的信息，详情请参阅 [https://angular.io/api/router/ActivatedRoute](https://angular.io/api/router/ActivatedRoute)。它包含诸如当前
    URL、查询或路由参数（及其当前值）、任何子路由或父路由的信息等详细信息。
- en: Using this service, we’ll access the current parameter information. Open src/app/forums/forum/forum.component.ts
    and update the class as you see in the following listing. It will inject new services
    and handle getting access to the route parameters.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此服务，我们将访问当前的参数信息。打开src/app/forums/forum/forum.component.ts，并按以下列表更新类。它将注入新的服务并处理获取路由参数的访问。
- en: '**Listing 7.1** Forum component getting access to route parameters'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表7.1** 论坛组件获取路由参数'
- en: '[PRE14]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This component is activated when the user navigates to a page like /forums/1-announcements.
    We start off by injecting the active route into the `route` property, and the
    router service into the `router` property. You’d normally need to import them
    into the file at the top, but that should already be done for you.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户导航到如/forums/1-announcements之类的页面时，该组件会被激活。我们首先将活动路由注入到`route`属性中，将路由服务注入到`router`属性中。您通常需要在文件顶部导入它们，但应该已经为您完成了。
- en: Inside of OnInit, we then create a subscription to listen for when the parameters
    change. Many of the values returned by `ActivatedRoute` are exposed as observables,
    so you’ll have to subscribe to get the values. The primary reason why is that
    when you have nested routes where a parent and child route are active at the same
    time, a parent component can subscribe to get updates as any child routes are
    loaded.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在`OnInit`内部，我们创建了一个订阅来监听参数何时发生变化。`ActivatedRoute`返回的许多值都作为可观察对象公开，因此您需要订阅以获取值。主要原因是当您有嵌套路由，其中父路由和子路由同时激活时，父组件可以订阅以获取任何子路由加载时的更新。
- en: The `params` observable you subscribe to will return a `Params` object type,
    which allows you to access the properties like `params['forum_alias']`. We then
    use our service to get the requested forum by passing in the forum alias from
    the params, and set that to the `forum` property.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 您订阅的`params`可观察对象将返回一个`Params`对象类型，这允许您访问诸如`params['forum_alias']`之类的属性。然后我们使用我们的服务通过传递params中的论坛别名来获取请求的论坛，并将其设置为`forum`属性。
- en: Just because a parameter is provided to a component doesn’t guarantee that the
    alias provided is a valid one, which is a case we should handle. Therefore, if
    the forum doesn’t exist, we’ll redirect the user to a not found page.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 仅因为向组件提供了参数，并不能保证提供的别名是有效的，这是我们应处理的情况。因此，如果论坛不存在，我们将用户重定向到未找到页面。
- en: Throughout the rest of the chapter we’ll write this same basic active route
    observable anytime we need access to the parameters. There are other ways to access
    the current parameters on the page, but they have some weaknesses and aren’t typically
    used or recommended. One example is being able to get the values one time using
    a promise instead of an observable, but the drawback there is that you’d only
    get the parameters one time, and the component wouldn’t know about new parameters
    if the route changed without the component being recreated.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的其余部分，我们将在需要访问参数时随时编写相同的基基本活动路由可观察对象。还有其他方法可以访问页面上的当前参数，但它们有一些弱点，通常不使用或推荐。一个例子是使用promise而不是可观察对象一次性获取值，但缺点是您只会得到一次参数，如果路由改变而没有重新创建组件，组件就不会知道新的参数。
- en: If you’re familiar with observables, you may have noticed we didn’t unsubscribe
    from the `params` observable, because an observable typically persists after a
    component is destroyed, as an event listener can do. Typically, you should manually
    unsubscribe or you’ll end up with memory leaks, but in this case it’s allowed
    because Angular will destroy this observable as soon as the active route is no
    longer active. You could unsubscribe in the component’s OnDestroy hook if you
    prefer.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您熟悉可观察对象，您可能已经注意到我们没有从`params`可观察对象中取消订阅，因为可观察对象通常在组件被销毁后持续存在，就像事件监听器一样。通常，您应该手动取消订阅，否则您最终会得到内存泄漏，但在这个情况下这是允许的，因为Angular会在活动路由不再活动时立即销毁此可观察对象。如果您愿意，您可以在组件的`OnDestroy`钩子中取消订阅。
- en: At this point, if you go to http://localhost:4200/forums, you should be able
    to click a forum and see the title of that forum appear in a new page with the
    URL changing. Try a few forums to make sure the values change depending on the
    forum you view.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，如果您访问http://localhost:4200/forums，您应该能够点击一个论坛，并看到该论坛的标题出现在一个新页面中，URL也会改变。尝试几个论坛以确保值根据您查看的论坛而变化。
- en: Now we need to see the threads in a single forum, and we’ll use child routes
    to help us define these routes that are organizationally linked to the specific
    forum.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要查看单个论坛中的线程，我们将使用子路由来帮助我们定义这些与特定论坛组织上相关的路由。
- en: 7.5 Child routes
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.5 子路由
- en: Having just one component per route can be somewhat limiting and could cause
    additional complexity in having to re-declare commonly used pieces across multiple
    components. We talked about how the top navbar remains active and visible across
    all routes, because it exists outside of the router outlet. We can apply this
    same principle to our routes so a portion of the route remains active even while
    you navigate between child routes.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 每个路由只有一个组件可能会有些限制，并且可能会在多个组件之间重新声明常用部分，从而增加额外的复杂性。我们讨论了顶级导航栏如何在所有路由中保持活跃和可见，因为它存在于路由出口之外。我们可以将这个相同的原理应用到我们的路由上，这样路由的一部分即使在您在子路由之间导航时也会保持活跃。
- en: For example, in our application there is a Forum component that contains a header
    with the forum title ([figure 7.4](#figure7.4)). This will remain active regardless
    of whether you’re looking at the list of threads or at a specific thread. You
    could imagine that this header bar could also contain common features, such as
    buttons for creating a new thread in this forum or a button to report spam.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在我们的应用程序中有一个包含论坛标题头部的 Forum 组件（[图7.4](#figure7.4)）。无论您是在查看线程列表还是在查看特定线程，它都将保持活跃。您可以想象这个头部栏也可以包含常见功能，例如在此论坛中创建新线程的按钮或报告垃圾邮件的按钮。
- en: '![c07-4.png](image_fi/293313c07/c07-4.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![c07-4.png](image_fi/293313c07/c07-4.png)'
- en: '[**Figure 7.4**](#figureanchor7.4) A child route renders inside of the parent
    component, as you see here with the Forums component hosting the Forum component.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '[**图7.4**](#figureanchor7.4) — 子路由在父组件内部渲染，正如您在这里看到的，Forums组件托管着Forum组件。'
- en: 'We just defined a route with the path /forums/:forum_alias. We will continue
    to use this path base when we start to view a specific thread inside of our forum,
    and we want it to be like this: /forums/:forum_alias/:thread_alias. When you look
    at the URL structure here, it shows that you expect both a forum and thread alias
    to correctly navigate, and that’s an indication of a good place to use child routes.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚定义了一条路径，路径为 /forums/:forum_alias。当我们开始查看我们论坛中的特定线程时，我们将继续使用这个路径基础，并且我们希望它看起来像这样：/forums/:forum_alias/:thread_alias。当你查看这里的URL结构时，它显示你期望论坛别名和线程别名都能正确导航，这是一个使用子路由的好地方。
- en: 'Based on this, you can see that child routes always share their parent route’s
    path and extend it for a new child route. Here is a basic list showing the relationship
    of these various routes:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 基于此，您可以看到子路由始终共享其父路由的路径，并为新的子路由扩展它。以下是一个基本列表，显示了这些不同路由之间的关系：
- en: '*/forums —* Forums component, top-level route'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*/forums* — 论坛组件，顶级路由'
- en: '*/forums/:forum_alias —* Child route to show a specific forum'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*/forums/:forum_alias* — 子路由，用于显示特定的论坛'
- en: '*/forums/:forum_alias/:thread_alias —* Also a child route of a specific forum,
    showing a particular thread'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*/forums/:forum_alias/:thread_alias* — 也是特定论坛的子路由，显示特定的线程'
- en: Child routes work by creating another router outlet that’s localized to the
    parent component, and then all child routes will render inside of this new router
    outlet. Figure 7.4 shows how nested router outlets will work in our example, by
    having two routes and components active. There’s no limit to how many nested router
    outlets you could have, though in my experience I recommend no more than three,
    because it gets more challenging to define the correct routes with more children.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 子路由通过创建另一个本地化的父组件的路由出口来工作，然后所有子路由都将在这个新的路由出口内部渲染。图7.4展示了在我们的例子中嵌套路由出口将如何工作，通过有两个路由和组件同时活跃。尽管没有限制您可以有嵌套路由出口的数量，但根据我的经验，我建议不要超过三个，因为定义更多子路由的正确路由会变得更加具有挑战性。
- en: 'Let’s start by adding this new router outlet, which should help you see where
    the child routes will go, and then we’ll define these routes. Open src/app/forums/forum/forum.component.html,
    and add a new router outlet to the bottom of the file:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从添加这个新的路由出口开始，这应该有助于您看到子路由将去哪里，然后我们将定义这些路由。打开 src/app/forums/forum/forum.component.html，并在文件底部添加一个新的路由出口：
- en: '[PRE19]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This defines where any children will be rendered, so the header will always
    remain rendered even when the child component routes are active. Now you can think
    of our routing as two levels: the router outlet in the App component and this
    localized router outlet.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这定义了任何子组件将被渲染的位置，所以即使在子组件路由活跃时，标题也会始终被渲染。现在你可以将我们的路由视为两个级别：App 组件中的路由出口和这个本地化的路由出口。
- en: Next we’ll define our routes, and then we can step back and see how it all comes
    together. Open src/app/forums/forums.module.ts and update the `forumsRoutes` to
    match the following listing.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将定义我们的路由，然后我们可以退后一步，看看一切是如何结合在一起的。打开 src/app/forums/forums.module.ts 并更新
    `forumsRoutes` 以匹配以下列表。
- en: '**Listing 7.2** Forums module routes with children'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 7.2** 带有子路由的论坛模块路由'
- en: '[PRE20]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here we’ve added a new `children` property to the forums/:forum_alias route.
    This is how we denote which routes we want to load into the new router outlet
    of the Forum component.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们为 forums/:forum_alias 路由添加了一个新的 `children` 属性。这就是我们表示我们想要加载到论坛组件的新路由出口中的路由的方式。
- en: We’ve added two routes. The first has an empty path, and will render when we
    are on the parent route. That will display the list of threads that belong to
    the forum. The second is to display a single thread by accepting a thread alias
    parameter. These two routes are now child routes for the forum route.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了两个路由。第一个有一个空路径，当我们在父路由上时将渲染。这将显示属于论坛的线程列表。第二个是通过接受线程别名参数来显示单个线程。这两个路由现在是论坛路由的子路由。
- en: Child routes also help demonstrate how important it is to use observables when
    getting route parameters. Parent components remain active and onscreen even as
    the child components may be destroyed.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 子路由也有助于说明在获取路由参数时使用可观察对象的重要性。父组件即使在子组件可能被销毁的情况下仍然保持活跃和可见。
- en: Now we can round off the Thread and Threads component capabilities to load the
    correct data and link to threads. We’ll start by helping the Threads component
    load the correct list of threads to display. Open src/app/forums/threads/threads.component.ts
    and update it as you see in the following listing.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以完善 Thread 和 Threads 组件的功能，以便加载正确的数据并链接到线程。我们首先帮助 Threads 组件加载要显示的正确线程列表。打开
    src/app/forums/threads/threads.component.ts 并按照以下列表进行更新。
- en: '**Listing 7.3** Threads component getting list of threads'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 7.3** 线程组件获取线程列表'
- en: '[PRE24]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This is nearly identical to the way we got parameters and loaded the forum data
    from the Forum component. The only real difference is that we’re grabbing the
    threads instead of the forum data from the service. This pattern will repeat,
    and I won’t belabor the details.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这几乎与我们从 Forum 组件获取参数和加载数据的方式相同。唯一的真正区别是我们从服务中获取线程而不是论坛数据。这种模式将会重复，我不会过多地详细说明。
- en: 'Next open the src/app/forums/threads/threads.component.html file and we’ll
    add a `routerLink` to individual thread routes. Replace the existing table row
    with this:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，打开 src/app/forums/threads/threads.component.html 文件，我们将为单个线程路由添加一个 `routerLink`。用以下内容替换现有的表格行：
- en: '[PRE26]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Notice again this is a relative link, so it will append the thread alias to
    the current URL, which would be like /forums/:forum_alias/:thread_alias. That
    will activate the correct route.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这又是一个相对链接，所以它将线程别名附加到当前 URL 上，就像 /forums/:forum_alias/:thread_alias。这将激活正确的路由。
- en: Now that we can navigate to a specific thread, we just need to update the Thread
    component to grab the active route to have access to the parameters. This will
    be slightly different due to the way routes are activated, so let’s take a look.
    Open src/app/forums/thread/thread.component.ts and update as you see in the following
    listing.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够导航到特定的线程，我们只需更新 Thread 组件以获取活动路由，以便访问参数。由于路由的激活方式，这会有所不同，让我们看看。打开 src/app/forums/thread/thread.component.ts
    并按照以下列表进行更新。
- en: '**Listing 7.4** Thread component loading a thread and accessing parent route'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 7.4** 线程组件加载线程并访问父路由'
- en: '[PRE27]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As usual, we inject the active route and subscribe to `params`. But in this
    route we have access to the parent route information, because the currently active
    route information doesn’t contain all the parameters we need. The active route
    information contains that information, so we look at the `snapshot` property to
    dig into the parent route. Once we get it, we then use the service to load data
    for the thread.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如往常一样，我们注入活动路由并订阅 `params`。但在本路由中，我们有访问父路由信息的能力，因为当前活动路由信息不包含我们需要的所有参数。活动路由信息包含这些信息，所以我们查看
    `snapshot` 属性以深入了解父路由。一旦我们得到它，我们就使用服务来加载线程的数据。
- en: You may wonder why we didn’t have to do this with the other child route. Since
    this child route has no path (remember we defined the path as ''), it will share
    the `params` and the path with the parent route. You will need to keep that in
    mind as you design URLs.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道为什么我们不需要对其他子路由做同样的事情。因为这个子路由没有路径（记住我们定义的路径为 ''），它将与父路由共享 `params` 和路径。在设计
    URL 时，你需要记住这一点。
- en: Make sure you’ve saved the changes and preview the application again. At this
    point, you should be able to click the Forum link in the top navbar to see forums,
    select a forum to view, and then select a specific thread. We’ve created two child
    routes by adding a new router outlet and defining them as children of that same
    route.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你已经保存了更改并再次预览应用程序。在这个时候，你应该能够点击顶部导航栏中的论坛链接来查看论坛，选择一个论坛进行查看，然后选择一个特定的线程。我们已经通过添加一个新的路由出口并将它们定义为该路由的子路由来创建了两个子路由。
- en: Sometimes you need something that’s like a child route but that’s disconnected
    from a specific parent route. Let’s dive into secondary routes, talk about what
    they are, and see how you can use them.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你需要的东西类似于子路由，但又与特定的父路由断开连接。让我们深入了解二级路由，讨论它们是什么，以及如何使用它们。
- en: 7.6 Secondary routes
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.6 二级路由
- en: In desktop applications, email applications (such as Outlook or Apple Mail)
    often will open a new window for composing a new email, and the user can flip
    between the windows to continue their work. Gmail has a feature that allows you
    to create a new email in a little window inside the application while you continue
    to navigate around the rest of the application—which is the same concept as a
    secondary route. *Secondary routes* are designed to allow the user to draft an
    email while continuing to use the email application.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在桌面应用程序中，电子邮件应用程序（如 Outlook 或 Apple Mail）通常会打开一个新窗口来编写新电子邮件，用户可以在窗口之间切换以继续工作。Gmail
    有一个功能允许你在应用程序内部的一个小窗口中创建新电子邮件，同时继续在应用程序的其他部分导航——这与二级路由的概念相同。*二级路由*旨在允许用户在继续使用电子邮件应用程序的同时草拟电子邮件。
- en: These are examples of secondary routes, sometimes also called *auxiliary* routes,
    where some part of the application appears but maintains a different state from
    the main application. Chat, help, or documentation windows are also examples of
    secondary routes.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是二级路由的例子，有时也称为 *辅助* 路由，其中应用程序的一部分出现，但保持与主应用程序不同的状态。聊天、帮助或文档窗口也是二级路由的例子。
- en: Angular supports these types of routes, and they behave like having a new root-level
    router outlet for a set of routes. You can create multiple secondary router outlets,
    though typically one is enough to satisfy most use cases. The rules for secondary
    routes are mostly the same as other routes, except sometimes we’ll have to specify
    additional details to ensure the correct router outlet is used, as shown in [figure
    7.5](#figure7.5).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: Angular 支持这些类型的路由，它们的行为就像为一系列路由有一个新的根级路由出口。虽然通常一个就足够满足大多数用例，但你仍然可以创建多个二级路由出口。二级路由的规则基本上与其他路由相同，但有时我们可能需要指定额外的细节以确保使用正确的路由出口，如图
    7.5 所示。
- en: '![c07-5.png](image_fi/293313c07/c07-5.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![c07-5.png](image_fi/293313c07/c07-5.png)'
- en: '[**Figure 7.5**](#figureanchor7.5) The main outlet and the secondary router
    outlet can be active at the same, and can change their routing states independently
    of each other.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '[**图 7.5**](#figureanchor7.5) 主出口和二级路由出口可以同时激活，并且可以独立于彼此改变它们的路由状态。'
- en: In this example, we want to have a chat feature that would allow any user to
    open a chat box with another user, as you see in [figure 7.5](#figure7.5). This
    will sit atop the current page so the user can continue to browse the site and
    read forum or blog posts.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们想要有一个聊天功能，允许任何用户打开一个与另一个用户的聊天框，就像你在图 7.5 中看到的那样。这将位于当前页面的顶部，以便用户可以继续浏览网站并阅读论坛或博客文章。
- en: 7.6.1 Defining a secondary route
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.6.1 定义二级路由
- en: 'Open src/app/app.component.html and at the bottom of the file add a new line
    with another router outlet. This outlet has a name attribute to allow us to target
    loading routes into this outlet instead of the primary outlet:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `src/app/app.component.html` 并在文件底部添加一行，包含另一个路由出口。这个出口有一个 `name` 属性，允许我们将加载的路线目标到这个出口而不是主出口：
- en: '[PRE31]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Next we need to define some routes that will be attached to this route. They
    are as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要定义一些将附加到这个路由的路线。它们如下所示：
- en: '*/users —*This will show a list of the users you can chat with.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*/users* 这将显示你可以与之聊天的用户列表。'
- en: '*/users/:username —*This will be the chat experience with another user.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*/users/:username —*` 这将是与其他用户聊天的体验。'
- en: 'Open src/app/app.module.ts and update the `appRoutes` to contain these two
    new routes, as you see here in bold:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `src/app/app.module.ts` 并更新 `appRoutes` 以包含这两个新路由，正如你在这里加粗看到的那样：
- en: '[PRE32]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Notice they have a path and component like other routes, but we also declare
    the `outlet` property. This is how we’ll tell the router to render this component
    inside of the new router outlet with the name `chat`. Notice we can use route
    params in secondary routes as well, so we’ll be able to access those params in
    the same way we have elsewhere. I also placed these routes before the redirect
    and wildcard routes, because those are meant to act like fallback routes.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 注意它们有一个路径和组件，就像其他路由一样，但我们还声明了 `outlet` 属性。这就是我们告诉路由器在名为 `chat` 的新路由出口中渲染此组件的方式。注意我们也可以在二级路由中使用路由参数，因此我们将能够以相同的方式访问这些参数。我还将这些路由放在重定向和通配符路由之前，因为那些路由旨在充当后备路由。
- en: 'The top right of the application has two buttons: a speech bubble button for
    the chat and a logout button (which we’ll implement soon). We want to add a `routerLink`
    to the speech bubble button to open this chat box. Go back to the app.component.html
    file and update the link surrounding the icon like you see here in bold:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序右上角有两个按钮：一个用于聊天的语音气泡按钮和一个注销按钮（我们很快将实现）。我们想在语音气泡按钮上添加一个 `routerLink` 以打开这个聊天框。回到
    `app.component.html` 文件并更新围绕图标的链接，正如你在这里加粗看到的那样：
- en: '[PRE33]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Here we use the binding version of the attribute on the `routerLink` and we
    pass in an array with an object. The syntax here is more verbose, because we have
    to pass in additional data for the router to understand that this is meant to
    be a secondary route. The object contains the `outlets` property, which then has
    an object that maps the name of the outlet to the specific route requested. In
    this case, we’re passing `{chat: [''users'']}`, which tells it to use the chat
    outlet, and then go to the path users. This pattern will repeat for using the
    secondary routes, so you’ll get to see a couple more examples of the structure.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '在这里，我们使用 `routerLink` 属性的绑定版本，并传递一个包含对象的数组。这里的语法更冗长，因为我们必须传递额外的数据以便路由器理解这是一个二级路由。该对象包含
    `outlets` 属性，它然后有一个将出口名称映射到特定路由请求的对象。在这种情况下，我们传递 `{chat: [''users'']}`，这告诉它使用聊天出口，然后转到用户路径。这种模式将重复用于使用二级路由，因此你将看到更多结构示例。'
- en: At this point, we’ve got a secondary route and a way to trigger it. View the
    application and click the speech bubble icon in the top right to open a new window
    with a list of users. It allows you to select a user to talk to but doesn’t navigate
    to the chat window with that user. Let’s add the ability to navigate within a
    secondary route now.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们有一个二级路由和触发它的方法。查看应用程序并点击右上角的语音气泡图标以打开一个包含用户列表的新窗口。它允许你选择一个要交谈的用户，但不会导航到与该用户的聊天窗口。现在让我们添加在二级路由内导航的能力。
- en: 7.6.2 Navigating between secondary routes
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.6.2 在二级路由之间导航
- en: Once you’re rendering a component inside of a secondary route, you still link
    different routes together using the same rules. You don’t have to specify the
    outlet as long as you use relative links. The context of the route will be understood
    by the router, so this will help simplify your links.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你在二级路由中渲染组件，你仍然可以使用相同的规则将不同的路由链接在一起。只要使用相对链接，你就不必指定出口。路由的上下文将由路由器理解，这将有助于简化你的链接。
- en: You can change the primary route from a secondary route as long as you provide
    an absolute path (such as /forums). Using an absolute path from a secondary route
    will change the primary outlet, but the secondary route will remain at the same
    route.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 只要提供绝对路径（例如 /forums），你就可以将主路由从二级路由更改。从二级路由使用绝对路径将更改主出口，但二级路由将保持在同一路由上。
- en: 'To get this working, let’s open src/app/chat-list/chat-list.component.html
    and update the link to start a chat. When you click a username, it sets a property
    called `talkTo` with the username. We then want to navigate to a relative path
    with this username, because we defined the secondary route to be /users/:username.
    Add the bolded `routerLink` to the link:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 要使这个功能正常工作，让我们打开 `src/app/chat-list/chat-list.component.html` 并更新链接以启动聊天。当你点击一个用户名时，它会设置一个名为
    `talkTo` 的属性，并带有该用户名。然后我们希望导航到一个带有该用户名的相对路径，因为我们定义了二级路由为 `/users/:username`。向链接中添加加粗的
    `routerLink`：
- en: '[PRE34]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The binding will now navigate the user to the Chat component to engage in a
    fun discussion with that user. But the Chat component doesn’t yet get access to
    the route params to know which user to talk to, so we need to add that to our
    Chat component.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定现在将用户导航到聊天组件，与该用户进行有趣的讨论。但聊天组件还没有访问路由参数来知道与哪个用户交谈，因此我们需要将其添加到我们的聊天组件中。
- en: Open src/app/chat/chat.component.ts and update the constructor and `ngOnInit`,
    as you see in the following listing. The rest of the controller is focused on
    handling the chat experience.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `src/app/chat/chat.component.ts` 并更新构造函数和 `ngOnInit`，如下所示。控制器的其余部分专注于处理聊天体验。
- en: '**Listing 7.5** Chat component accessing route params'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 7.5**  聊天组件访问路由参数'
- en: '[PRE35]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: There is nothing new about this, except it sets up the component model to have
    a new chat experience. You can review the remainder of the component controller
    to see how it behaves, but at this point the chat box will start to work correctly.
    You can type a message and hit Enter, and after three seconds the other “user”
    will reply with some anecdote. This is obviously not a real chat experience, but
    I wanted to make it realistic.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这并没有什么新奇的，除了它设置了组件模型以拥有新的聊天体验。你可以查看组件控制器的其余部分以了解其行为，但在这个阶段，聊天框将开始正常工作。你可以输入一条消息并按
    Enter，然后三秒钟后，另一个“用户”将回复一些轶事。这显然不是一个真实的聊天体验，但我想要让它更真实。
- en: 7.6.3 Closing a secondary route and programmatic routing
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 7.6.3 关闭次要路由和程序化路由
- en: All good things come to an end, and at some point you’ll need to exit this secondary
    route. For example, you’ll likely want to end the chat session at some point.
    We can close a secondary route, and if we ever need it back we just open it up
    again. To close a secondary route, you set the current route to null and that
    will remove it.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 所有美好的事物都有结束的时候，在某个时候你将需要退出这个次要路由。例如，你可能会在某个时候结束聊天会话。我们可以关闭次要路由，如果我们需要它回来，我们只需再次打开它。要关闭次要路由，你只需将当前路由设置为
    null，这样就会将其移除。
- en: I’d also like to show you how to use programmatic (or imperative) routing. Sometimes
    you’ll need to have your controller or services change the route for you instead
    of always waiting for a user to click an element with a `routerLink`.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我还想向你展示如何使用程序化（或命令式）路由。有时你可能需要控制器或服务为你更改路由，而不是总是等待用户点击带有 `routerLink` 的元素。
- en: If you look at the Chat and ChatList component templates, you’ll notice there
    is a close button near the top of the file. Right now it has a click handler to
    call the `close()` method, which is currently empty. Although you could use a
    `routerLink`, I wanted to demonstrate programmatic navigation here.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看聊天和聊天列表组件模板，你会注意到文件顶部附近有一个关闭按钮。目前它有一个点击处理程序来调用 `close()` 方法，该方法目前是空的。虽然你可以使用
    `routerLink`，但我想在这里演示程序化导航。
- en: 'Open the src/app/chat/chat.component.ts and src/app/chat-list/chat-list.component.ts
    files and update the `close` method to be the following. You will need to ensure
    that the router is properly injected in the constructor as well (hint: the Chat
    component already has it, but ChatList does not):'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `src/app/chat/chat.component.ts` 和 `src/app/chat-list/chat-list.component.ts`
    文件，并更新 `close` 方法，如下所示。你还需要确保在构造函数中正确注入路由（提示：聊天组件已经有了，但聊天列表没有）：
- en: '[PRE38]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The router service provides a `navigate` method that takes the exact same syntax
    as `routerLink`. In this case, we’re declaring that the chat outlet should navigate
    to null, which tells Angular to remove the secondary route. We’ll see another
    use case for programmatic routing next, but I usually find it best to use `routerLink`
    whenever possible over programmatic routing.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 路由服务提供了一个 `navigate` 方法，其语法与 `routerLink` 完全相同。在这种情况下，我们声明聊天出口应导航到 null，这告诉
    Angular 移除次要路由。我们将在下一个程序化路由用例中看到，但我通常发现尽可能使用 `routerLink` 而不是程序化路由是最好的。
- en: Now that the secondary route is cleared, there’s no other cleanup. It will be
    removed from the application, and to open it again you just have to reactivate
    it with a new valid route.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在次要路由已被清除，没有其他清理工作。它将从应用程序中移除，要再次打开它，只需用一个新的有效路由重新激活即可。
- en: I suggest that you limit using secondary routes to when they provide the most
    value. They’re very useful in the right situations, but it’s best to keep it simple.
    Similar to avoiding too many nested child routes, adding a lot of secondary routes
    will add complexity that can probably be avoided.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议你在它们提供最大价值时才使用二级路由。在正确的情况下，它们非常有用，但最好保持简单。类似于避免过多的嵌套子路由，添加过多的二级路由会增加可以避免的复杂性。
- en: We have a bit of a problem now. We’re allowing any user to open a chat window
    with other users regardless of whether they’re logged in. Using routes, we can
    guard our routes from being activated unless certain conditions are met, to secure
    them from unauthorized access.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有点问题。我们允许任何用户无论是否登录都可以打开与其他用户的聊天窗口。使用路由，我们可以通过满足某些条件来保护路由不被激活，从而防止未经授权的访问。
- en: 7.7 Route guards to limit access
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.7 路由守卫以限制访问
- en: Angular allows you to control the conditions that allow a route to render, which
    usually is done to prevent the application from going into a bad state. For example,
    you shouldn’t allow an unauthenticated user to view portions of the application
    that require them to be logged in or they will likely get a lot of errors.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: Angular允许你控制允许路由渲染的条件，这通常是为了防止应用程序进入不良状态。例如，你不应该允许未经认证的用户查看需要他们登录的应用程序部分，否则他们可能会遇到很多错误。
- en: A *guard* is like a lifecycle hook for route changes that allows an application
    to verify certain conditions or load data before a change occurs, as you see in
    [figure 7.6](#figure7.6). When a route change is triggered (either by the user
    clicking a link or the app programmatically changing routes), Angular will check
    to see whether any guards are registered. For example, if an unauthenticated user
    tries to load the page that displays a logged in user’s account details, the application
    should implement a guard that checks the user’s logged in state before activating
    the route. The term *activate* is used to describe if a route is allowed to be
    loaded.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '*守卫*就像路由更改的生命周期钩子，允许应用程序在更改发生之前验证某些条件或加载数据，正如你在[图7.6](#figure7.6)中看到的那样。当触发路由更改（无论是用户点击链接还是应用程序程序化更改路由）时，Angular将检查是否注册了任何守卫。例如，如果未经认证的用户尝试加载显示已登录用户账户详情的页面，应用程序应实现一个守卫来在激活路由之前检查用户的登录状态。术语*激活*用来描述路由是否允许加载。'
- en: '![c07-6.png](image_fi/293313c07/c07-6.png)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![c07-6.png](image_fi/293313c07/c07-6.png)'
- en: '[**Figure 7.6**](#figureanchor7.6) Guards run before a route is activated and
    can prevent access.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '[**图7.6**](#figureanchor7.6) 守卫在路由激活之前运行，可以阻止访问。'
- en: 'There are several types of guards that give you different options when managing
    how routes are activated. They’re defined as a service and then linked to a particular
    route to take effect. This allows you to use the same guard multiple times. Here
    are the five types of guards and their basic roles:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种类型的守卫，在管理路由激活时提供了不同的选项。它们被定义为服务，然后链接到特定的路由以生效。这允许你多次使用相同的守卫。以下是五种类型的守卫及其基本角色：
- en: '*CanActivate —*Used to determine whether the route can be activated (such as
    user validation)'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*CanActivate*—用于确定路由是否可以被激活（例如用户验证）'
- en: '*CanActivateChild —*Same as CanActivate, but specifically for child routes'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*CanActivateChild*—与CanActivate相同，但专门用于子路由'
- en: '*CanDeactivate —*Used to determine whether the current route can be deactivated
    (such as preventing leaving an unsaved form without confirmation)'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*CanDeactivate*—用于确定当前路由是否可以被停用（例如，防止在不确认的情况下离开未保存的表单）'
- en: '*CanLoad —*Used to determine whether the user can navigate to a lazy loaded
    module prior to loading it'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*CanLoad*—用于在加载之前确定用户是否可以导航到懒加载的模块'
- en: '*Resolve —*Used to access route data and pass data to the component’s list
    of providers'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Resolve*—用于访问路由数据并将数据传递给组件的提供者列表'
- en: We’re going to implement a guard for the chat routes so that the user is forced
    to log in first. From that list, the `CanActivate` guard is the best option for
    us to accomplish this.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现一个针对聊天路由的守卫，以便用户必须先登录。从该列表中，`CanActivate`守卫是我们完成此任务的最佳选择。
- en: 'We’ll generate a new service to solve this problem, so run the following command
    to set up the `AuthGuard` service:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将生成一个新的服务来解决此问题，因此运行以下命令来设置`AuthGuard`服务：
- en: '[PRE39]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Now open the src/app/services/auth-guard.service.ts file and replace its contents
    with the code from the following listing.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开`src/app/services/auth-guard.service.ts`文件，并用以下列表中的代码替换其内容。
- en: '**Listing 7.6** AuthGuard service for limiting access to routes'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表 7.6** 限制路由访问的 `AuthGuard` 服务'
- en: '[PRE40]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: It starts like a normal service by importing dependencies, and we want to implement
    the `CanActivate` interface to make sure we correctly set up our service. The
    constructor injects the `UserService` and `Router` into the object, which allows
    us access to the router inside of the service.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 它就像一个正常的服务一样开始，通过导入依赖项，我们想要实现 `CanActivate` 接口以确保我们正确设置了我们的服务。构造函数将 `UserService`
    和 `Router` 注入到对象中，这允许我们在服务内部访问路由器。
- en: 'The `canActivate` method must be implemented with this name, because Angular
    is expecting it that way. That’s why the interface is useful to implement; it
    will warn you if you didn’t set it up correctly. It receives two parameters: first
    the snapshot of the current route activated, and second the new route the application
    is trying to activate. I only use the new route metadata in this example, but
    they allow you to inspect the current route and requested route details.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`canActivate` 方法必须使用此名称实现，因为 Angular 正在期待这种方式。这就是为什么接口实现是有用的；如果设置不正确，它将警告你。它接收两个参数：首先是当前激活路由的快照，其次是应用程序尝试激活的新路由。在这个例子中，我只使用了新路由的元数据，但它们允许你检查当前路由和请求的路由详细信息。'
- en: Once inside the method, we check our `UserService` to see if the user is logged
    in or not. If they are, we return `true` to tell the guard that it’s acceptable
    to allow the route to be activated. Otherwise, we tell the route to navigate to
    the login route, and we also pass an object that contains some metadata. We’ll
    look at this more closely in a moment.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦进入方法内部，我们检查 `UserService` 以查看用户是否已登录。如果是，我们返回 `true` 告诉守卫允许激活路由是可接受的。否则，我们告诉路由导航到登录路由，并且我们还传递一个包含一些元数据的对象。我们稍后会更详细地查看它。
- en: 'At this point, we’ve implemented the guard to return `true` or `false`, depending
    on whether the user is valid. If they’re not, it redirects to the login screen.
    After the login process, we want to redirect them back to the page they attempted
    to view, which is where the metadata object comes into play. Let’s look at it
    again:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经实现了守卫以返回 `true` 或 `false`，这取决于用户是否有效。如果不是，它将重定向到登录屏幕。在登录过程之后，我们希望将他们重定向回他们尝试查看的页面，这就是元数据对象发挥作用的地方。让我们再次看看它：
- en: '[PRE47]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The router takes an optional object as a second parameter, and here we’re using
    it to set a query parameter. These are variables that are found in the URL after
    a question mark, like you see here in bold:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 路由器接受一个可选对象作为第二个参数，在这里我们使用它来设置一个查询参数。这些变量位于问号之后的 URL 中，就像这里加粗显示的那样：
- en: '[PRE48]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: We’re using this to remember the URL that the user attempted to navigate to
    by looking at the `state.url` property (which is the route that the router attempted
    to activate but couldn’t). This is a common pattern in login flows, and you can
    certainly use query parameters for many other reasons as well in the same way.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用它来记住用户尝试导航到的 URL，通过查看 `state.url` 属性（这是路由器尝试激活但未能激活的路由）。这是登录流程中的常见模式，你当然也可以以相同的方式使用查询参数来处理许多其他原因。
- en: 'That’s our guard; now we need to apply it to some routes. To do this, we’ll
    update our `appRoutes` from the src/app/app.module.ts file; add the following
    in bold. We need to first import the new `AuthGuardService` and then add a new
    `canActivate` property to the routes to secure:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的守卫；现在我们需要将其应用到一些路由上。为此，我们将更新 `src/app/app.module.ts` 文件中的 `appRoutes`；以下内容需要加粗。我们需要首先导入新的
    `AuthGuardService`，然后为路由添加一个新的 `canActivate` 属性以进行安全保护：
- en: '[PRE49]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We also need to add the `AuthGuardService` to our list of providers for the
    application to know it exists. Add it in the module providers array like this:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要将 `AuthGuardService` 添加到我们的应用程序提供者列表中，以便应用程序知道它的存在。像这样在模块提供者数组中添加它：
- en: '[PRE50]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: We’ve now attached the service as a guard to our chat routes. If you preview
    the application and attempt to open the chat, it will redirect you to the login
    screen. The guard fires prior to the chat route being completely activated, and
    therefore the component will never render, so you don’t have to worry about that
    component having an unauthenticated user.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已将服务作为守卫附加到我们的聊天路由上。如果你预览应用程序并尝试打开聊天，它将重定向你到登录屏幕。守卫在聊天路由完全激活之前触发，因此组件永远不会渲染，所以你不必担心该组件有未经认证的用户。
- en: We want to update the Login component to help with the redirect back to the
    requested URL once the user logs in. For this login form you can use any values.
    It’s happy as long as you input any random username and password. It also persists
    the login into localStorage, so it will remember you. Update the src/app/login/login.component.ts
    file with the contents from the following listing.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望更新登录组件，以帮助用户在登录后重定向回请求的URL。对于这个登录表单，你可以使用任何值。只要输入任何随机的用户名和密码，它就高兴。它还会将登录持久化到localStorage中，所以它会记住你。使用以下列表中的内容更新`src/app/login/login.component.ts`文件。
- en: '**Listing 7.7** Login component with redirect after login'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表7.7** 登录组件，登录后重定向'
- en: '[PRE51]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: After you import the dependencies and inject the services into the component,
    you will implement another observable to get the `queryParams` just like you would
    for getting the route `params`. Because this is a different type of value, you
    have to subscribe on a different property of the activated route.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在导入依赖项并将服务注入到组件中之后，你将实现另一个可观察对象来获取`queryParams`，就像你获取路由`params`一样。因为这是一个不同类型的值，你必须订阅激活路由的不同属性。
- en: Inside of the callback, the return URL is grabbed from the URL (or if it doesn’t
    exist, it sets it to /forums). Then it checks whether the user is already logged
    in and redirects immediately to the page. This is to help the situation where
    someone is already logged in but somehow lands on the login page erroneously.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在回调内部，从URL（或如果不存在，则设置为/forums）获取返回URL。然后它检查用户是否已经登录，并立即重定向到页面。这是为了帮助那些已经登录但意外地
    landed on the login page 的人。
- en: The `login()` method is called by the component when the user clicks the Login
    button, and handles logging in the user by calling the user service and redirecting.
    Then the `go()` method calls the `router.navigateByUrl()` method, which is different
    from the typical `router.navigate()` method in that it takes a string. Because
    we’re getting a return path from the URL, it will rely on the route to parse the
    URL and determine the correct URL.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击登录按钮时，组件会调用`login()`方法，并通过调用用户服务和重定向来处理用户登录。然后`go()`方法调用`router.navigateByUrl()`方法，这与典型的`router.navigate()`方法不同，因为它接受一个字符串。因为我们从URL获取返回路径，所以它将依赖于路由来解析URL并确定正确的URL。
- en: We now need to update the logout feature, which will remove the current user
    state from the `UserService`. The service is already there to handle this, but
    we need to enable the button to call the service.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要更新注销功能，这将从`UserService`中移除当前用户状态。服务已经存在来处理这个问题，但我们需要启用按钮以调用该服务。
- en: 'First open src/app/app.component.ts and update the link to the Logout button
    like you see bolded here:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 首先打开`src/app/app.component.ts`并更新注销按钮的链接，就像这里加粗显示的那样：
- en: '[PRE57]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: This will disable the Logout button if the user is a guest, and also call the
    `logout` method to handle the logout. The issue that we might run into is that
    if you have the chat outlet activated and then you click Logout, it doesn’t close
    the secondary chat outlet. That’s because it’s only checked on route activation,
    so we need to manually check whether it’s open and close it.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户是访客，这将禁用注销按钮，并调用`logout`方法来处理注销。我们可能遇到的问题是，如果你已经激活了聊天出口，然后点击注销，它不会关闭次要聊天出口。那是因为它只在路由激活时进行检查，所以我们需要手动检查它是否打开并关闭它。
- en: 'In order to solve this, we need to make a few small changes to the `UserService`.
    Open src/app/services/user.service.ts. First make sure to import the Router and
    Activated­Route services:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们需要对`UserService`进行一些小的修改。打开`src/app/services/user.service.ts`。首先确保导入Router和ActivatedRoute服务：
- en: '[PRE58]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Then we want to inject those dependencies into the constructor like you see
    here:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们想要像这里看到的那样将这些依赖注入到构造函数中：
- en: '[PRE59]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Finally we need to update the `logout` method with the bold parts, which will
    always ensure the router outlet is closed on logout:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要更新带有加粗部分的`logout`方法，这将始终确保在注销时关闭路由出口：
- en: '[PRE60]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: This is the same code we used earlier to close the chat outlet, and here we
    run it to ensure that the outlet is closed. If it’s not currently active, nothing
    will happen.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这是之前用来关闭聊天出口的相同代码，我们在这里运行它以确保出口被关闭。如果它目前不活跃，则不会发生任何事情。
- en: You’ll likely need guards anytime you have to deal with application state, such
    as logged in users or forms. They’re very helpful, but like most things they’re
    best used sparingly. You can have multiple guards on the same route, but the more
    you have, the more difficult it is to keep track of application logic.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 当你必须处理应用程序状态，如已登录用户或表单时，你很可能会需要守卫。它们非常有帮助，但像大多数事情一样，最好适量使用。你可以在同一路由上拥有多个守卫，但守卫越多，跟踪应用程序逻辑就越困难。
- en: On the other hand, you should be sure to use guards instead of relying on adding
    logic into a component controller directly to check whether the user can activate
    a route. Components shouldn’t be concerned about router configurations as much
    as possible (with the obvious exception of getting parameter information from
    URLs).
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，你应该确保使用守卫而不是直接在组件控制器中添加逻辑来检查用户是否可以激活路由。组件应尽可能少地关注路由配置（显然的例外是从URL中获取参数信息）。
- en: Our last major feature is to lazy load Angular modules into the application
    only when they’re needed, which can be a boost to initial load time for large
    applications.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后一个主要功能是将Angular模块仅在需要时懒加载到应用程序中，这可以提升大型应用程序的初始加载时间。
- en: 7.8 Lazy loading
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.8 懒加载
- en: If you’re building your application and using feature modules to organize code,
    then you can use *lazy loading* (or *asynchronous loading*) with the router ([figure
    7.7](#figure7.7)). Doing so will allow an entire module to load only when required,
    which can save on file size of the core bundles, perhaps even limiting access
    to bundles for only those who are authorized to use it (like administrative modules).
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在构建应用程序并使用功能模块来组织代码，那么你可以使用*懒加载*（或*异步加载*）与路由([图7.7](#figure7.7))。这样做将允许整个模块仅在需要时加载，这可以节省核心包的文件大小，甚至可能限制只有有权使用它的人（如管理模块）的访问。
- en: If you haven’t organized your application into different modules, then lazy
    loading them into the application isn’t possible, because there’s no logical isolation.
    The basic idea is that the Angular build process can analyze the code paths and
    optimize the code based on how it’s used to generate different files, but it depends
    on Angular modules as the primary way to determine how code is related.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有将你的应用程序组织成不同的模块，那么将它们懒加载到应用程序中是不可能的，因为没有逻辑隔离。基本思想是Angular构建过程可以分析代码路径并根据其使用情况优化代码，以生成不同的文件，但它依赖于Angular模块作为确定代码关系的主要方式。
- en: '![c07-7.png](image_fi/293313c07/c07-7.png)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![c07-7.png](image_fi/293313c07/c07-7.png)'
- en: '[**Figure 7.7**](#figureanchor7.7) Lazy loading a module happens only when
    the route is requested and must be loaded before the route can activate.'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '[**图7.7**](#figureanchor7.7) 懒加载模块仅在请求路由时发生，并且必须在路由激活之前加载。'
- en: 'In our chapter example, we have three modules (excluding Angular or third-party
    modules):'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的章节示例中，我们有三个模块（不包括Angular或第三方模块）：
- en: AppModule
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AppModule
- en: ForumsModule
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ForumsModule
- en: BlogsModule
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: BlogsModule
- en: The AppModule is our primary application, and the ForumsModule is directly imported
    into the AppModule. But we haven’t imported the BlogsModule yet, and when we want
    to lazy load, we don’t want to import the module into our application directly.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: AppModule是我们的主要应用程序，ForumsModule直接导入到AppModule中。但我们还没有导入BlogsModule，当我们想要懒加载时，我们不想直接将模块导入到我们的应用程序中。
- en: 'Let’s see this in action by setting it up ourselves with the BlogsModule. Open
    src/app/app.module.ts and update the routes as you see here in bold:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过设置BlogsModule来自行查看这个功能。打开src/app/app.module.ts并更新路由，如下所示（加粗）：
- en: '[PRE61]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The new route contains a path and blogs, and the `loadChildren` property is
    used to define a path to the module that should be lazy loaded when the browser
    tries to access any URLs starting with /blogs. The `loadChildren` property takes
    a file path pointing to the actual module file, starting from the src directory
    and excluding the .ts extension. It then has a hash (#) symbol, followed by the
    module name. This special syntax lets Angular know both the location of this module
    and the name so it can properly create it.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 新的路由包含一个路径和博客，`loadChildren`属性用于定义当浏览器尝试访问以/blogs开头的任何URL时应该懒加载的模块的路径。`loadChildren`属性接受一个指向实际模块文件的文件路径，从src目录开始，不包括.ts扩展名。然后有一个哈希(#)符号，后面跟着模块名称。这种特殊语法让Angular知道该模块的位置和名称，以便它可以正确地创建它。
- en: This is all the configuration you need to do to enable lazy loading of a module,
    but we still have a little bit of work to do to the BlogsModule for it to function
    as expected. So far, it doesn’t have any routes declared, which means this won’t
    work just yet.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 这是你需要做的所有配置，以启用模块的懒加载，但我们还需要对BlogsModule做一些工作，以便它按预期工作。到目前为止，它还没有声明任何路由，这意味着这还不能工作。
- en: In the AppModule and ForumsModule, we created a variable in the file and stored
    the routes in the same file. But you can also create what’s called a *router module*
    to store this configuration. This may be favorable if your configuration is complex
    and you want to keep your module files cleaner.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在`AppModule`和`ForumsModule`中，我们在文件中创建了一个变量，并将路由存储在同一个文件中。但你也可以创建一个所谓的*路由模块*来存储这个配置。如果你的配置很复杂，并且你想要保持你的模块文件更干净，这可能是有利的。
- en: I personally have found that routing modules are just extra files if my application
    is small, but they’re more meaningful as my application gets larger. I think it’s
    more important to be consistent in how you declare your routes rather than which
    you choose. But if you need a generic guideline, then I suggest that if you have
    more than three modules, you use a routing module. The choice is yours.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 我个人发现，如果我的应用程序很小，路由模块只是额外的文件，但当我的应用程序变大时，它们就更有意义了。我认为保持声明路由的一致性比选择哪种路由更重要。但如果你需要一个通用的指南，那么我建议如果你有超过三个模块，就使用路由模块。选择权在你。
- en: 'When you create modules with the Angular CLI, you can have it generate a routing
    module for you by adding the `--routing` flag:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用Angular CLI创建模块时，你可以通过添加`--routing`标志来让它为你生成一个路由模块：
- en: '[PRE62]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Because the BlogsModule already exists, we’ll need to manually create the routing
    module for the Blogs module. Create a new file at src/app/blogs/blogs-routing.module.ts
    and add the contents from the following listing.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 由于BlogsModule已经存在，我们需要手动为博客模块创建路由模块。在`src/app/blogs`下创建一个新的文件`blogs-routing.module.ts`，并添加以下列表中的内容。
- en: '**Listing 7.8** Routing module for blogs'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表7.8**　博客路由模块'
- en: '[PRE63]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: This module is a bit different from normal modules, as it’s focused only on
    setting up the necessary pieces for routing. After you import all the dependencies,
    you still declare a variable with the routes as we have in the other examples.
    Notice that these paths don’t contain a prefix of blogs, because we already defined
    that prefix in our lazy load route definition. These routes are simple in that
    they map to a component to render.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模块与普通模块有点不同，因为它只专注于设置路由所需的必要部分。在你导入所有依赖项之后，你仍然会声明一个包含路由的变量，就像在其他示例中那样。注意，这些路径不包含blogs前缀，因为我们已经在我们的懒加载路由定义中定义了该前缀。这些路由很简单，因为它们映射到一个要渲染的组件。
- en: Finally we declare the `RouterModule.forChild()` method in the module `imports`,
    just as we did with the ForumsModule. Then we also add the RouterModule in the
    `exports`, which makes the router directives available to this module’s templates.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在模块的`imports`中声明了`RouterModule.forChild()`方法，就像我们在`ForumsModule`中做的那样。然后我们也在`exports`中添加了RouterModule，这使得路由指令可以用于这个模块的模板。
- en: We didn’t declare any redirect or fallback routes here. That’s because the one
    we defined in the AppModule will still catch any unknown URLs. Routes can be declared
    anywhere in the application, and Angular will try to match to the best URL, which
    demonstrates the importance of good URL planning.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里没有声明任何重定向或回退路由。那是因为我们在`AppModule`中定义的那个仍然会捕获任何未知的URL。路由可以在应用程序的任何地方声明，Angular会尝试匹配到最佳的URL，这展示了良好URL规划的重要性。
- en: 'To consume the router module, we need to import it into our BlogsModule. Open
    src/app/blogs/blogs.module.ts and add the new import line here:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用路由模块，我们需要将其导入到我们的BlogsModule中。打开`src/app/blogs/blogs.module.ts`并在此处添加新的导入行：
- en: '[PRE67]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Then we need to add it to the imports for the module like this:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们需要像这样将其添加到模块的导入中：
- en: '[PRE68]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'That completes the routing module setup, and if you had generated it with the
    CLI, the files would already exist for you to add your routes. Now we want to
    make use of the BlogsModule by adding a link to the Blogs section in the navbar.
    There’s already a link for it, so we’ll just need to add `routerLink`. Open src/app/app.component.html
    and update the link to the blogs:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就完成了路由模块的设置，如果你是用CLI生成的，那么文件已经为你准备好了，你可以添加你的路由。现在我们想要通过在导航栏的博客部分添加一个链接来使用BlogsModule。已经有一个链接了，所以我们只需要添加`routerLink`。打开`src/app/app.component.html`并更新链接到博客：
- en: '[PRE69]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Now when you run the application and click Blogs in the navbar, it will take
    you to the Blogs section. If you open the developer tools, you can also watch
    the HTTP requests to see that the Blogs module is loaded asynchronously on demand.
    It happens so fast when you work locally that there shouldn’t be any lag, but
    there would be a slight lag for that file to download from a remote server.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当你运行应用程序并点击导航栏中的“博客”时，它将带你进入“博客”部分。如果你打开开发者工具，你还可以观察 HTTP 请求，以查看博客模块是按需异步加载的。当你本地工作时，这发生得非常快，所以不应该有任何延迟，但从远程服务器下载该文件会有轻微的延迟。
- en: The rest of the blog components already have `routerLink`s set up for you, but
    you can stop and review them if you like. There’s nothing new in there that we
    haven’t already done a few times already.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 博客组件的其他部分已经为你设置了 `routerLink`，但如果你愿意，可以停下来回顾一下。那里没有我们之前没有做过几次的新内容。
- en: That wraps up the primary Angular routing capabilities you’ll likely need to
    use in most of your applications. Although there are some features that I wasn’t
    able to cover, I haven’t had many occasions to use capabilities that aren’t outlined
    in this chapter.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 这就总结了你可能需要在大多数应用程序中使用的主要 Angular 路由功能。尽管有一些功能我没有涵盖到，但我很少有机会使用本章未详细说明的功能。
- en: Before closing out this chapter, I’d like to review a few best practices from
    my experience for crafting good routes and using the Angular router.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在结束这一章之前，我想回顾一下我从经验中总结的一些关于构建良好路由和使用 Angular 路由的最佳实践。
- en: 7.9 Routing best practices
  id: totrans-311
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 7.9 路由最佳实践
- en: There have been a lot of debates around how to design your application URL structures,
    and I have some particularly strong opinions about what constitutes good design.
    There are also debates about whether URL design is really all that important,
    because most of the time users don’t type URLs into the address bar, anyway.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 关于如何设计应用程序的 URL 结构，已经有很多争论，我对构成良好设计的一些方面有特别强烈的看法。也有人争论 URL 设计是否真的那么重要，因为大多数时候用户不会在地址栏中输入
    URL。
- en: I can’t force you to follow any specific rules, but I do want to share my beliefs
    and experiences with you. I believe that URL design is essential to quality applications.
    Good URL structure makes applications easier to maintain, can help users navigate
    your website, and should help maintain navigational state. Just as you might spend
    time planning a page’s layout, you should take time to plan your application’s
    URL structure.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 我不能强迫你遵循任何特定的规则，但我确实想与你分享我的信念和经验。我相信 URL 设计对于优质应用程序至关重要。良好的 URL 结构使应用程序更容易维护，可以帮助用户导航你的网站，并应有助于维护导航状态。就像你可能花时间规划页面布局一样，你也应该花时间规划应用程序的
    URL 结构。
- en: 'I would like to suggest the following as best practices, which I put into practice
    with my applications and believe are the most likely to provide you with a solid
    foundation:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议以下作为最佳实践，这些实践我已经在我的应用程序中实施，并相信它们最有可能为你提供一个坚实的基础：
- en: '*Keep URLs short —*When possible, URLs should be only as long as they need
    to be. This can be tricky as your application grows, so being vigilant from the
    start is the best way to keep on track. There may be some SEO considerations for
    your URLs, for which I suggest you just keep it simple.'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*保持 URL 短小* — 当可能时，URL 应该只长到需要那么长。随着应用程序的增长，这可能有点棘手，所以从一开始就保持警惕是保持进度最佳的方式。你的
    URL 可能需要考虑一些 SEO 因素，我建议你保持简单。'
- en: '*Favor* *path parameters over query variables —*The use of query variables
    should be limited to transient stateful data, such as search filter variables.
    When you use IDs or resource aliases in the URL, they should almost always be
    path parameters.'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*优先使用路径参数* — 查询变量的使用应限制于短暂的状态数据，例如搜索过滤器变量。当你使用 URL 中的 ID 或资源别名时，它们几乎总是路径参数。'
- en: '*Prefer to spell out words —*I have a strong preference for not abbreviating
    variables or paths, because it’s harder to read and some abbreviations are not
    always clear. Although you should keep URLs short, you shouldn’t shortcut the
    words you use.'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*倾向于拼写单词* — 我强烈倾向于不缩写变量或路径，因为这更难阅读，而且一些缩写并不总是清晰易懂。尽管你应该保持 URL 短小，但你不应该缩短你使用的单词。'
- en: '*Use hyphens when using multiple words —*The readability of a URL is important,
    and if you have multiple words together (like /forums/2-introductions/89-cloned-didactic-knowledge-user),
    using hyphens between words is the easiest way to read. It’s also easy to parse.'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用连字符来分隔多词—*URL的可读性很重要，如果你将多个单词放在一起（例如 /forums/2-introductions/89-cloned-didactic-knowledge-user），在单词之间使用连字符是最容易阅读的方式。这也便于解析。'
- en: '*Limit the use of secondary routes —*As fun as secondary routes can be, they
    add complexity. If a secondary route is contextual to only some of the application
    routes, then you’d have to keep track of when to enable or disable that secondary
    route. For example, if you have an application for a bank and there is a secondary
    route for opening a new account, you would need to pay attention to what the user
    does and determine when it might be appropriate to close it.'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*限制使用二级路由—*虽然二级路由很有趣，但它们增加了复杂性。如果一个二级路由只与某些应用程序路由相关，那么你就需要跟踪何时启用或禁用该二级路由。例如，如果你有一个银行应用程序，并且有一个用于开设新账户的二级路由，你需要注意用户的行为，并确定何时可能适合关闭它。'
- en: '*Carefully consider the correct guard to use for your use case —*There are
    five types of guards, and sometimes they can be bent to do different tasks. Be
    aware of the purpose of your guard and use the correct one.'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*仔细考虑为你的用例选择正确的守卫—*有五种类型的守卫，有时它们可以弯曲以执行不同的任务。要清楚你的守卫的目的，并使用正确的守卫。'
- en: '*Use feature modules so you can use lazy loading —*Feature modules are helpful
    for code isolation, but being able to lazy load modules is extremely useful. It’s
    much easier to start with feature modules and not use lazy loading than it is
    to later have to refactor to feature modules to use lazy loading.'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用功能模块以便可以使用懒加载—*功能模块对于代码隔离很有帮助，但能够懒加载模块非常有用。与后来不得不重构以使用懒加载相比，从功能模块开始而不使用懒加载要容易得多。'
- en: '*Keep it simple —*This is true of all things, but I think it’s the most important
    underlying principle in routing. Things can quickly get out of hand if you have
    100 routes when you only needed 10 that had better parameters. Look for ways to
    simplify all the time!'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*保持简单—*这一点适用于所有事物，但我认为这是路由中最重要的基本原则。如果你只需要10条具有更好参数的路由，而你却有了100条路由，事情会迅速失控。时刻寻找简化所有事物的途径！'
- en: The rules for the Angular router are fairly straightforward, and most of the
    complexity comes from combining these features. That’s the inherent power of the
    Angular router and its design. It’s simultaneously simple and capable of complex
    scenarios. I caution against making a simple scenario into a complex one unnecessarily,
    but given some mastery of the router you’ll be able to craft routes to handle
    any use case.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: Angular路由器的规则相当直接，大部分复杂性都来自于这些功能的组合。这就是Angular路由器及其设计的内在力量。它既简单又能够处理复杂场景。我警告不要无谓地将简单场景变得复杂，但一旦你对路由器有所掌握，你将能够构建处理任何用例的路由。
- en: Summary
  id: totrans-324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: 'The Angular router is quite powerful, and yet the basic principles are easy
    enough to pick up quickly and put into practice. We’ve gone through a lot of capabilities
    for services and how they work. Services are fundamental for Angular applications,
    and you’ll be building or using many of them. Here’s a quick recap of what you
    learned:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: Angular路由器非常强大，但其基本原理足够简单，可以快速掌握并付诸实践。我们已经讨论了服务的大量功能及其工作方式。服务对于Angular应用程序是基本的，你将构建或使用许多服务。以下是你学到的快速回顾：
- en: The RouterModule needs to be included in any module that uses routing. When
    you set it up in the AppModule, you call the `forRoot()` method to set it up for
    the application.
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RouterModule需要包含在任何使用路由的模块中。当你将其设置在AppModule中时，你调用`forRoot()`方法来为应用程序设置它。
- en: Routes are defined as arrays of objects that contain properties applicable for
    those routes, such as a path, a component to render, and/or child routes.
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由定义为包含适用于这些路由的属性的数组，例如路径、要渲染的组件和/或子路由。
- en: Routes can accept parameters, both in the path or as query variables, to allow
    you to reuse a route with different parameters. These parameters are made available
    to the component controller through the activate route details.
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由可以接受参数，无论是路径还是作为查询变量，这样你就可以使用不同参数重用路由。这些参数通过激活路由详情提供给组件控制器。
- en: Using `routerLink` you can link any element to a particular route. It can be
    given a basic string with a valid path, or you could also use the binding syntax
    to pass in additional data as an array.
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `routerLink`，你可以将任何元素链接到特定的路由。它可以提供一个包含有效路径的基本字符串，或者你也可以使用绑定语法来传递作为数组的额外数据。
- en: Child routes render inside of a parent component and allow you to reuse code,
    such as sharing common navigation or resolving data.
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子路由在父组件内部渲染，并允许你重用代码，例如共享通用导航或解析数据。
- en: Secondary routes are useful to create routes that are standalone and detached
    from the primary routes. This can be useful for experiences that are active regardless
    of which page you are on, such as documentation windows.
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 次级路由对于创建独立且与主路由分离的路由很有用。这对于无论你在哪个页面上都活跃的体验很有用，例如文档窗口。
- en: Use guards to limit access to routes, resolve data prior to activating a route,
    or prevent a route from being deactivated. You’ll have to create a service to
    include in the route definition to enable the guard.
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用守卫来限制对路由的访问，在激活路由之前解析数据，或防止路由被停用。你必须创建一个服务并将其包含在路由定义中，以启用守卫。
- en: Feature modules can be lazy loaded into the application, giving you the ability
    to reduce the file size of the code that’s initially downloaded to users. It only
    loads the module when the user navigates to a route that’s part of the feature
    module.
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 功能模块可以被懒加载到应用程序中，这让你能够减少最初下载给用户的代码文件大小。它仅在用户导航到属于功能模块的路由时才加载模块。
- en: In the next chapter, we’re going to look at forms in depth and make it easy
    to capture user input.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入探讨表单，并使其易于捕获用户输入。
