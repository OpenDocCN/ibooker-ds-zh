- en: appendix C. Loading and rendering 3D Models with OpenGL and PyGame
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附录 C：使用 OpenGL 和 PyGame 加载和渲染 3D 模型
- en: Beyond chapter 3, when we start writing programs that transform and animate
    graphics, I use OpenGL and PyGame instead of Matplotlib. This appendix provides
    an overview of how to set up a game loop in PyGame and render 3D models in successive
    frames. The culmination is an implementation of a `draw_model` function that renders
    a single image of a 3D model like the teapot we used in chapter 4.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 3 章之后，当我们开始编写转换和动画图形的程序时，我使用 OpenGL 和 PyGame 而不是 Matplotlib。本附录概述了如何在 PyGame
    中设置游戏循环并在连续帧中渲染 3D 模型。最终，我们实现了一个 `draw_model` 函数，用于渲染一个 3D 模型的单张图像，就像我们在第 4 章中使用的水壶一样。
- en: The goal of `draw_model` is to encapsulate the library-specific work, so you
    don’t have to spend a lot of time wrestling with OpenGL. But if you want to understand
    how the function works, feel free to follow along in this appendix and play with
    the code yourself. Let’s start with our octahedron from chapter 3 and recreate
    it with PyOpenGL, an OpenGL binding for Python and PyGame.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '`draw_model` 函数的目标是封装特定库的工作，这样你就不必花费大量时间与 OpenGL 斗争。但如果你想知道这个函数是如何工作的，请随时跟随本附录并亲自尝试代码。让我们从第
    3 章中的八面体开始，使用 PyOpenGL（Python 和 PyGame 的 OpenGL 绑定）重新创建它。'
- en: C.1 Recreating the octahedron from chapter 3
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C.1 重新创建第 3 章中的八面体
- en: 'To begin working with the PyOpenGL and PyGame libraries, you need to install
    them. I recommend using pip as follows:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用 PyOpenGL 和 PyGame 库，你需要安装它们。我建议使用以下 pip 命令：
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first thing I’ll show you is how to use these libraries to recreate work
    we’ve already done, rendering a simple 3D object.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我将首先向你展示如何使用这些库来重新创建我们已经完成的工作，渲染一个简单的 3D 对象。
- en: 'In a new Python file called octahedron.py (which you can find in the source
    code for appendix C), we start with a bunch of imports. The first few come from
    the two new libraries, PyGame and PyOpenGL, and the rest should be familiar from
    chapter 3\. In particular, we’ll continue to use all of the 3D vector arithmetic
    functions we already built, organized in the file vectors.py in the source code
    for this book. Here are the import statements:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个名为 octahedron.py 的新 Python 文件中（你可以在附录 C 的源代码中找到它），我们开始导入一些模块。前几个来自两个新的库，PyGame
    和 PyOpenGL，其余的应该与第 3 章中熟悉的内容相同。特别是，我们将继续使用我们已构建的所有 3D 向量算术函数，这些函数组织在本书源代码中的 vectors.py
    文件中。以下是导入语句：
- en: '[PRE1]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'While OpenGL has automatic shading capabilities, let’s continue to use our
    shading mechanism from chapter 3\. We can use a blue color map from Matplotlib
    to compute colors for the shaded sides of the octahedron:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 OpenGL 具有自动着色功能，但让我们继续使用第 3 章中提到的着色机制。我们可以使用 Matplotlib 的蓝色颜色图来计算八面体的着色面的颜色：
- en: '[PRE2]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, we have to specify the geometry of the octahedron and the light source.
    Again, this is the same as in chapter 3:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须指定八面体的几何形状和光源。这和第 3 章中一样：
- en: '[PRE3]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now it’s time for some unfamiliar territory. We’re going to show the octahedron
    as a PyGame game window, which requires a few lines of boilerplate. Here, we start
    the game, set the window size in pixels, and tell PyGame to use OpenGL as the
    graphics engine:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是进入一些不熟悉的领域的时候了。我们将以 PyGame 游戏窗口的形式展示八面体，这需要几行样板代码。在这里，我们启动游戏，设置窗口的像素大小，并告诉
    PyGame 使用 OpenGL 作为图形引擎：
- en: '[PRE4]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ❶ Asks PyGame to show our graphics in a 400 × 400 pixel window
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 请求 PyGame 在一个 400 × 400 像素的窗口中显示我们的图形
- en: ❷ Lets PyGame know that we’re using OpenGL for our graphics and indicates that
    we want to use a built-in optimization called double-buffering, which isn’t important
    to understand for our purposes
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 让 PyGame 知道我们正在使用 OpenGL 进行图形处理，并指出我们想要使用一个名为双缓冲的内置优化，这对于我们的目的来说并不重要
- en: 'In our simplified example in section 3.5, we drew the octahedron from the perspective
    of someone looking from a point far up the z-axis. We computed which triangles
    should be visible to such an observer and projected them to 2D by removing the
    z-axis. OpenGL has built-in functions to configure our perspective even more precisely:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 3.5 节的简化示例中，我们从 z 轴上方的某一点观察者的视角绘制了八面体。我们计算了哪些三角形对这样的观察者是可见的，并通过移除 z 轴将它们投影到
    2D。OpenGL 内置了更精确地配置我们视角的函数：
- en: '[PRE5]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'For the purpose of learning math, you don’t really need to know what these
    functions do, but I’ll give you a short overview in case you are curious. The
    call to `gluPerspective` describes our perspective looking at the scene, where
    we have a 45° viewing angle and an aspect ratio of 1\. This means the vertical
    units and the horizontal units display as the same size. As a performance optimization,
    the numbers 0.1 and 50.0 put limits on the *z* -coordinates that are rendered:
    no objects further than 50.0 units from the observer or closer than 0.1 units
    will show up. Our use of `glTranslatef` indicates that we’ll observe the scene
    from 5 units up the z-axis, meaning we move the scene down by vector (0, 0, -5).
    Calling `glEnable(GL_CULL _FACE)` turns on an OpenGL option that automatically
    hides polygons oriented away from the viewer, saving us some work we already did
    in chapter 3, and `glEnable (GL_DEPTH_TEST)` ensures that we render polygons closer
    to us on top of those further from us. Finally, `glCullFace(GL_BACK)` enables
    an OpenGL option that automatically hides polygons that are facing us but that
    are behind other polygons. For the sphere, this wasn’t a problem, but for more
    complex shapes it can be.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了学习数学，你实际上并不需要知道这些函数具体做什么，但我还是会给你一个简要的概述，以防你感兴趣。对`gluPerspective`的调用描述了我们观察场景的视角，其中我们有一个45°的观察角度和宽高比为1。这意味着垂直单位和水平单位显示为相同的大小。作为一个性能优化，数字0.1和50.0限制了渲染的*z*坐标：没有物体距离观察者超过50.0个单位或小于0.1个单位将显示出来。我们使用`glTranslatef`表明我们将从z轴上的5个单位处观察场景，这意味着我们通过向量(0,
    0, -5)将场景向下移动。调用`glEnable(GL_CULL_FACE)`打开了一个OpenGL选项，该选项会自动隐藏面向观察者之外的多边形，这节省了我们已经在第3章中完成的一些工作，而`glEnable(GL_DEPTH_TEST)`确保我们渲染距离我们更近的多边形在距离我们更远的多边形之上。最后，`glCullFace(GL_BACK)`打开了一个OpenGL选项，该选项会自动隐藏面向我们但位于其他多边形后面的多边形。对于球体来说，这不是问题，但对于更复杂的形状来说，可能会有问题。
- en: Finally, we can implement the main code that draws our octahedron. Because our
    eventual goal is to animate objects, we’ll actually write code that draws the
    object over and over repeatedly. These successive drawings, like frames of a movie,
    show the same octahedron over time. And, like any video of any stationary object,
    the result is indistinguishable from a static picture.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以实现绘制我们的八面体的主要代码。因为我们的最终目标是动画化物体，所以我们将编写重复绘制物体的代码。这些连续的绘制，就像电影的一帧，随着时间的推移显示了相同的八面体。而且，就像任何静止物体的视频一样，结果是和静态图片无法区分的。
- en: 'To render a single frame, we loop through the vectors, decide how to shade
    them, draw them with OpenGL, and update the frame with PyGame. Inside of an infinite
    `while` loop, this process can be automatically repeated as fast as possible as
    long as the program runs:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要渲染单个帧，我们遍历向量，决定如何着色它们，使用OpenGL绘制它们，并使用PyGame更新帧。在一个无限`while`循环中，只要程序运行，这个过程可以尽可能快地自动重复：
- en: '[PRE6]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ❶ Initializes a clock to measure the advancement of time for PyGame
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 初始化一个时钟来测量PyGame的时间推进
- en: ❷ In each iteration, checks the events PyGame receives and quits if the user
    closes the window
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 在每次迭代中，检查PyGame接收的事件，如果用户关闭窗口则退出
- en: ❸ Indicates to the clock that time should elapse
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 指示时钟时间应该流逝
- en: ❹ Instructs OpenGL that we are about to draw triangles
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 指示OpenGL我们即将绘制三角形
- en: ❺ For each vertex of each face (triangle), sets the color based on the shading
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: ❺ 对于每个面的每个顶点（三角形），根据着色设置颜色
- en: ❻ Specifies the next vertex of the current triangle
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: ❻ 指定当前三角形的下一个顶点
- en: ❼ Indicates to PyGame that the newest frame of the animation is ready and makes
    it visible
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: ❼ 指示PyGame最新的动画帧已准备好并使其可见
- en: Running this code, we see a 400 £ 400 pixel PyGame window appear, containing
    an image that looks like the one from chapter 3 (figure C.1).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码，我们会看到一个400 × 400像素的PyGame窗口出现，其中包含看起来像第3章（图C.1）中的图像。
- en: '![](../Images/APPC_F01_Orland.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/APPC_F01_Orland.png)'
- en: Figure C.1 The octahedron rendered in a PyGame window
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图C.1 在PyGame窗口中渲染的八面体
- en: 'If you want to prove that something more interesting is happening, you can
    include the following line at the end of the `while True` loop:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要证明有更有趣的事情发生，你可以在`while True`循环的末尾包含以下行：
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This prints instantaneous quotes of the rate (in frames per second, or fps)
    at which PyGame is rendering and re-rendering the octahedron. For a simple animation
    like this, PyGame should reach or exceed its default maximum frame rate of 60
    fps.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这打印出PyGame渲染和重新渲染八面体的速率（每秒帧数，或fps）的瞬时值。对于这样的简单动画，PyGame应该达到或超过其默认的最大帧率60 fps。
- en: But what’s the point of rendering so many frames if nothing changes? Once we
    include a vector transformation with each frame, we see the octahedron move in
    various ways. For now, we can cheat by moving the “camera” with each frame instead
    of actually moving the octahedron.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果没有任何变化，渲染这么多帧又有什么意义呢？一旦我们为每一帧加入一个矢量变换，我们就能看到八面体以各种方式移动。目前，我们可以通过移动“相机”来欺骗，而不是真正移动八面体。
- en: C.2 Changing our perspective
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C.2 改变我们的视角
- en: The `glTranslatef` function in the previous section tells OpenGL the position
    from which we want to see the 3D scene we’re rendering. Similarly, there is a
    `glRotatef` function that lets us change the angle at which we observe the scene.
    Calling `glRotatef (theta,` `x,` `y,` `z)` rotates the whole scene by the angle
    `theta` about an axis specified by the vector (*x*, *y*, *z*).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 上一节中的`glTranslatef`函数告诉OpenGL我们想要从哪个位置查看我们正在渲染的3D场景。同样，还有一个`glRotatef`函数允许我们改变观察场景的角度。调用`glRotatef
    (theta, x, y, z)`将整个场景绕由向量(*x*, *y*, *z*)指定的轴旋转角度`theta`。
- en: Let me clarify what I mean by “rotating by an angle about an axis.” You can
    think of the familiar example of the Earth rotating in space. The Earth rotates
    by 360° every day or 15° every hour. The *axis* is the invisible line that the
    Earth rotates around; it passes through the North and South poles−the only two
    points that aren’t rotating. For the Earth, the axis of rotation is not directly
    upright, rather it is tilted by 23.5° (figure C.2).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我澄清一下“绕轴旋转一个角度”的意思。你可以想想地球在空间中旋转的熟悉例子。地球每天旋转360°或每小时旋转15°。*轴*是地球围绕旋转的看不见的线；它穿过北极和南极−这是唯一两个不旋转的点。对于地球来说，旋转轴并不是直接垂直的，而是倾斜了23.5°（图C.2）。
- en: '![](../Images/APPC_F02_Orland.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/APPC_F02_Orland.png)'
- en: Figure C.2 A familiar example of an object rotating about an axis. The Earth’s
    axis of rotation is tilted at 23.5° relative to its orbital plane.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图C.2 一个绕轴旋转的物体的熟悉例子。地球的旋转轴相对于其轨道平面倾斜了23.5°。
- en: The vector (0, 0, 1) points along the z-axis, so calling `glRotatef(30,0,0,1)`
    rotates the scene by 30° about the z-axis. Likewise, `glRotatef(30,0,1,1)` rotates
    the scene by 30° but, instead, about the axis (0, 1, 1), which is 45° tilted between
    the y- and z-axes. If we call `glRotatef (30,0,0,1)` or `glRotatef(30,0,1,1)`
    after `glTranslatef(...)` in the octahedron code, we see the octahedron rotated
    (figure C.3).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 向量(0, 0, 1)沿着z轴，所以调用`glRotatef(30,0,0,1)`将场景绕z轴旋转30°。同样，`glRotatef(30,0,1,1)`将场景绕30°旋转，但绕的是轴(0,
    1, 1)，它在y轴和z轴之间倾斜45°。如果我们调用`glRotatef (30,0,0,1)`或`glRotatef(30,0,1,1)`在八面体代码中的`glTranslatef(...)`之后，我们会看到八面体旋转（图C.3）。
- en: Notice that the shading of the four visible sides of the octahedron in figure
    C.3 has not changed. This is because none of the vectors change; the vertices
    of the octahedron and the light source are all the same! We have only changed
    the position of the “camera” relative to the octahedron. When we actually change
    the position of the octahedron, we’ll see the shading change too.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到图C.3中八面体四个可见面的阴影没有改变。这是因为没有任何向量发生变化；八面体的顶点和光源都是相同的！我们只是改变了“相机”相对于八面体的位置。当我们实际改变八面体的位置时，我们也会看到阴影的变化。
- en: '![](../Images/APPC_F03_Orland.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/APPC_F03_Orland.png)'
- en: Figure C3\. The octahedron as seen from three different rotated perspectives
    using the `glRotatef` function from OpenGL
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图C3. 使用OpenGL的`glRotatef`函数从三个不同的旋转视角看到的八面体
- en: To animate the rotation of the cube, we can call `glRotate` with a small angle
    in every frame. For instance, if PyGame draws the octahedron at about 60 fps,
    and we call `glRotatef(1,x,y,z)` in every frame, the octahedron rotates about
    60° every second about the axis (*x*, *y*, *z*). Adding `glRotatef(1,1,1,1)` within
    the infinite `while` loop before `glBegin` causes the octahedron to rotate by
    1° per frame about an axis in the direction (1, 1, 1) as shown in figure C.4.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使立方体的旋转动画化，我们可以在每一帧调用`glRotate`一个小角度。例如，如果PyGame以大约60 fps的速度绘制八面体，并且我们在每一帧调用`glRotatef(1,x,y,z)`，那么八面体将绕(*x*,
    *y*, *z*)轴每秒旋转60°。在`glBegin`之前无限循环中添加`glRotatef(1,1,1,1)`会导致八面体绕方向(1, 1, 1)的轴每帧旋转1°，如图C.4所示。
- en: '![](../Images/APPC_F04_Orland.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](../Images/APPC_F04_Orland.png)'
- en: Figure C.4 Every tenth frame of our octahedron rotating at 1° per frame. After
    36 frames, the octahedron completes a full rotation.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图C.4 我们八面体每帧旋转1°。经过36帧后，八面体完成了一次完整的旋转。
- en: This rotation rate is only accurate if PyGame draws exactly 60 fps. In the long
    run, this may not be true; if a complex scene requires more than a sixtieth of
    a second to compute all vectors and draw all polygons, the motion actually slows
    down. To keep the motion of the scene constant regardless of the frame rate, we
    can use PyGame’s clock.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这个旋转速率只有在 PyGame 精确绘制 60 fps 时才是准确的。从长远来看，这可能并不成立；如果复杂场景需要超过六十分之一秒来计算所有向量和绘制所有多边形，实际的运动速度会减慢。为了使场景的运动不受帧率影响而保持恒定，我们可以使用
    PyGame 的时钟。
- en: 'Let’s say we want our scene to rotate by a full rotation (360°) every 5 seconds.
    PyGame’s clock thinks in milliseconds, which are thousandths of a second. For
    a thousandth of a second, the angle rotated is divided by 1,000:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想让场景每 5 秒旋转一周（360°）。PyGame 的时钟以毫秒为单位思考，即千分之一秒。对于千分之一秒，旋转的角度被除以 1,000：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The PyGame clock we created has a `tick()` method that both advances the clock
    and returns the number of milliseconds since `tick()` was last called. This gives
    us a reliable number of milliseconds since the last frame was rendered, and lets
    us compute the angle that the scene should be rotated in that time:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的 PyGame 时钟有一个 `tick()` 方法，它既推进时钟又返回自上次调用 `tick()` 以来经过的毫秒数。这为我们提供了一个自上次渲染帧以来可靠的毫秒数，并允许我们计算场景在此时间内应该旋转的角度：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Calling `glRotatef` like this every frame guarantees that the scene rotates
    exactly 360° every 5 seconds. In the file rotate_octahedron.py in the appendix
    C source code, you can see exactly how this code is inserted.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 每帧调用 `glRotatef` 如此保证场景每 5 秒旋转正好 360°。在附录 C 的源代码文件 rotate_octahedron.py 中，你可以看到这段代码是如何插入的。
- en: With the ability to move our perspective over time, we already have better rendering
    capabilities than we developed in chapter 3\. Now, we can turn our attention to
    drawing a more interesting shape than an octahedron or a sphere.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 通过能够在时间上移动我们的视角，我们已经拥有了比第 3 章中开发的更好的渲染能力。现在，我们可以将注意力转向绘制比八面体或球体更有趣的形状。
- en: C.3 Loading and rendering the Utah teapot
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C.3 加载和渲染犹他茶壶
- en: 'As we manually identified the vectors outlining a 2D dinosaur in chapter 2,
    we could manually identify the vertices of any 3D object, organize them into triples
    representing triangles, and build the surface as a list of triangles. Artists
    who design 3D models have specialized interfaces for positioning vertices in space
    and then saving them to files. In this section, we use a famous pre-built 3D model:
    the *Utah teapot*. The rendering of this teapot is the Hello World program for
    graphics programmers: a simple, recognizable example for testing.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在第 2 章中手动识别描绘 2D 恐龙的向量一样，我们可以手动识别任何 3D 对象的顶点，将它们组织成代表三角形的三个一组的顶点，并构建一个由三角形组成的表面列表。设计
    3D 模型的艺术家有专门的空间定位顶点和将它们保存到文件中的界面。在本节中，我们使用一个著名的预构建 3D 模型：犹他茶壶。这个茶壶的渲染是图形程序员的 Hello
    World 程序：一个简单、可识别的示例，用于测试。
- en: The teapot model is saved in the file teapot.off in the source code, where the
    .off filename extension stands for Object File Format. This is a plaintext format,
    specifying the polygons that make up the surface of a 3D object and the 3D vectors
    that are vertices of the polygon. The teapot.off file looks something like what
    is shown in this listing.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 茶壶模型保存在源代码中的 teapot.off 文件中，其中 .off 文件扩展名代表对象文件格式。这是一种纯文本格式，指定组成 3D 对象表面的多边形以及构成多边形顶点的
    3D 向量。teapot.off 文件看起来就像这个列表中所示的那样。
- en: Listing C.1 A schematic of the teapot.off file
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 C.1 teapot.off 文件的示意图
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ❶ Indicates that this file follows the Object File Format
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: ❶ 表示此文件遵循对象文件格式
- en: ❷ Contains the number of vertices, faces, and edges of the 3D model in that
    order
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: ❷ 按顺序包含 3D 模型的顶点数、面数和边数
- en: ❸ Specifies 3D vectors for each of the vertices, as x-, y-, and z-coordinate
    values
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: ❸ 指定每个顶点的 3D 向量，作为 x、y 和 z 坐标值
- en: ❹ Specifies the 448 faces of the model
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: ❹ 指定模型的 448 个面
- en: For the last lines of this file, specifying the faces, the first number of each
    line tells us what kind of polygon the face is. The number 3 indicates a triangle,
    4 a quadrilateral, 5 a pentagon, and so on. Most of the teapot’s faces turn out
    to be quadrilaterals. The next numbers on each line tell us the indices of the
    vertices from the previous lines that form the corners of the given polygon.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此文件的最后几行，指定面时，每行的第一个数字告诉我们该面是何种多边形。数字 3 表示三角形，4 表示四边形，5 表示五边形，依此类推。茶壶的大部分面都是四边形。每行接下来的数字告诉我们构成给定多边形顶点的索引，这些索引来自前面的行。
- en: In the file teapot.py in the appendix C source code, you’ll find the functions
    `load_vertices()` and `load_polygons()` that load the vertices and faces (polygons)
    from the teapot.off file. The first function returns a list of 440 vectors, which
    are all the vertices for the model. The second returns a list of 448 lists, each
    one containing vectors that are the vertices of one of the 448 polygons making
    up the model. Finally, I included a third function, `load_triangles()`, that breaks
    up the polygons with four or more vertices so that our entire model is built out
    of triangles.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在附录 C 的源代码文件 teapot.py 中，你会找到 `load_vertices()` 和 `load_polygons()` 函数，它们从 teapot.off
    文件中加载顶点和面（多边形）。第一个函数返回一个包含 440 个向量的列表，这些向量是模型的全部顶点。第二个返回一个包含 448 个列表的列表，每个列表包含构成模型中
    448 个多边形之一的顶点向量。最后，我还包括了一个第三个函数 `load_triangles()`，它将具有四个或更多顶点的多边形分解，这样我们的整个模型就由三角形组成。
- en: 'I’ve left it as a mini-project for you to dig deeper into my code or to try
    to load the teapot.off file as well. For now, I’ll continue with the triangles
    loaded by teapot.py, so we can get to drawing and playing with our teapot more
    quickly. The other step I skip is organizing the PyGame and OpenGL initialization
    into a function so that we don’t have to repeat it every time we draw a model.
    In draw_model.py, you’ll find the following function:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我把它留作一个迷你项目，让你更深入地挖掘我的代码，或者尝试加载 teapot.off 文件。现在，我将继续使用 teapot.py 加载的三角形，这样我们可以更快地进入绘制和玩茶壶的阶段。我跳过的另一个步骤是将
    PyGame 和 OpenGL 的初始化组织到一个函数中，这样我们就不必每次绘制模型时都重复它。在 draw_model.py 中，你会找到一个以下函数：
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: It takes the faces of a 3D model (assumed to be correctly oriented triangles),
    a color map for shading, and a vector for the light source, and draws the model
    accordingly. There are also a few more keyword arguments that we introduced in
    chapters 4 and 5\. Like our code to draw the octahedron, it draws whatever model
    is passed in, over and over in a loop. This listing shows how I put these together
    in draw_teapot.py.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 它接受一个 3D 模型的面（假设是正确方向的三角形），一个用于着色的颜色图，以及一个表示光源的向量，并据此绘制模型。还有一些我们在第 4 章和第 5 章中介绍的关键字参数。就像我们用来绘制八面体的代码一样，它反复循环地绘制传入的任何模型。这个列表展示了我在
    draw_teapot.py 中如何将这些组合在一起。
- en: Listing C.2 Loading the teapot triangles and passing those to `draw_model`
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 列表 C.2 加载茶壶三角形并将其传递给 `draw_model`
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The result is an overhead view of a teapot. You can see the circular lid, the
    handle on the left, and the spout on the right (figure C.5).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个茶壶的俯视图。你可以看到圆形的盖子，左侧的把手和右侧的壶嘴（图 C.5）。
- en: '![](../Images/APPC_F05_Orland.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图片](../Images/APPC_F05_Orland.png)'
- en: Figure C.5 Rendering the teapot
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图 C.5 渲染茶壶
- en: Now that we can render a shape that’s more interesting than a simple geometric
    figure, it’s time to play! If you read chapter 4, you learned about the mathematical
    transformations that you can do on all of the vertices of the teapot to move and
    distort it in 3D space. Here, I’ve also left you some exercises if you want to
    do some guided exploration of the rendering code.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够渲染比简单几何图形更有趣的形状，是时候玩耍了！如果你阅读了第 4 章，你学习了可以对茶壶的所有顶点执行数学变换，以在 3D 空间中移动和扭曲它。这里，我也为你留下了一些练习，如果你想要对渲染代码进行一些有指导的探索。
- en: C.4 Exercises
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C.4 练习
- en: '| **Exercise C.1**: Modify the `draw_model` function to display the input figure
    from any rotated perspective. Specifically, give the `draw_model` function a keyword
    argument `glRotatefArgs` that provides a tuple of four numbers corresponding to
    the four arguments of `glRotatef`. With this extra information, add an appropriate
    call to `glRotatef` within the body of `draw_model` to execute the rotation.**Solution**:
    In the source code for this book, see draw_model.py for the solution and draw_teapot_glrotatef.py
    for an example usage. |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| **练习 C.1**: 修改 `draw_model` 函数以从任何旋转视角显示输入的图形。具体来说，给 `draw_model` 函数一个关键字参数
    `glRotatefArgs`，它提供一个包含四个数字的元组，对应于 `glRotatef` 的四个参数。有了这些额外信息，在 `draw_model` 函数体中添加一个适当的
    `glRotatef` 调用来执行旋转。**解决方案**: 在本书的源代码中，请参阅 draw_model.py 以获取解决方案，以及 draw_teapot_glrotatef.py
    以获取示例用法。|'
- en: '| **Exercise C.2**: If we call `glRotatef(1,1,1,1)` in every frame, how many
    seconds does it take for the scene to complete a full revolution?**Solution**:
    The answer depends on the frame rate. This call to `glRotatef` rotates the perspective
    by 1° each frame. At 60 fps, it would rotate 60° per second and complete a full
    rotation of 360° in 6 seconds. |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| **练习 C.2**: 如果我们每帧调用 `glRotatef(1,1,1,1)`，场景完成一次完整旋转需要多少秒？**解决方案**: 答案取决于帧率。这个
    `glRotatef` 调用每帧旋转视角 1°。在 60 fps 下，它每秒旋转 60°，并在 6 秒内完成 360° 的完整旋转。|'
- en: '| **Exercise C.3−Mini Project**: Implement the `load_triangles()` function
    shown previously, which loads the teapot from the teapot.off file and produces
    a list of triangles in Python. Each triangle should be specified by three 3D vectors.
    Then, pass your result to `draw_model()` and confirm that you see the same result.**Solution**:
    In the source code, you can find `load _triangles()` implemented in the file teapot.py.**Hint**:
    You can turn the quadrilaterals into pairs of triangles by connecting their opposite
    vertices.![](../Images/APPC_UN01_Orland.png)Indexing four vertices of a quadrilateral,
    two triangles are formed by vertices 0, 1, 2 and 0, 2, 3, respectively. |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| **练习 C.3-迷你项目**: 实现之前展示的 `load_triangles()` 函数，该函数从 teapot.off 文件中加载茶壶，并生成一个包含三角形的
    Python 列表。每个三角形应由三个 3D 向量指定。然后，将你的结果传递给 `draw_model()` 并确认你是否看到了相同的结果。**解决方案**:
    在源代码中，你可以在文件 teapot.py 中找到 `load_triangles()` 的实现。**提示**: 你可以通过连接它们的对顶点将四边形转换为两个三角形！![图片](../Images/APPC_UN01_Orland.png)四边形的四个顶点索引，通过顶点
    0, 1, 2 和 0, 2, 3 分别形成两个三角形。|'
- en: '| **Exercise C.4−Mini Project**: Animate the teapot by changing the arguments
    to `gluPerspective` and `glTranslatef`. This will help you visualize the effects
    of each of the parameters.**Solution**: In the file animated_octahedron.py in
    the source code, an example is given for rotating the octahedron by 360 / 5 =
    72° per second by updating the `angle` parameter of `glRotatef` every frame. You
    can try similar modifications yourself with either the teapot or the octahedron.
    |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| **练习 C.4-迷你项目**: 通过改变 `gluPerspective` 和 `glTranslatef` 的参数来动画化茶壶。这将帮助你可视化每个参数的效果。**解决方案**:
    在源代码中的文件 animated_octahedron.py 中，给出了一个通过每帧更新 `glRotatef` 的 `angle` 参数来使八面体每秒旋转
    360 / 5 = 72° 的示例。你可以尝试对茶壶或八面体进行类似的修改。|'
