- en: Chapter 18\. Packages
  id: totrans-0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第18章. 包
- en: '*This chapter covers*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章涵盖*'
- en: Defining a package
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义一个包
- en: Creating a simple package
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个简单的包
- en: Exploring a concrete example
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索一个具体例子
- en: Using the `__all__` attribute
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `__all__` 属性
- en: Using packages properly
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正确使用包
- en: Modules make reusing small chunks of code easy. The problem comes when the project
    grows and the code you want to reload outgrows, either physically or logically,
    what would fit into a single file. If having one giant module file is an unsatisfactory
    solution, having a host of little unconnected modules isn’t much better. The answer
    to this problem is to combine related modules into a package.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 模块使得重用小块代码变得容易。但当项目增长，你想要重新加载的代码在物理上或逻辑上超出了单个文件所能容纳的范围时，问题就出现了。如果有一个巨大的模块文件不是一个令人满意的解决方案，那么有一堆没有连接的小模块也不会好多少。这个问题的答案是，将相关的模块组合成一个包。
- en: 18.1\. What is a package?
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 18.1. 什么是包？
- en: A *module* is a file containing code. A module defines a group of usually related
    Python functions or other objects. The name of the module is derived from the
    name of the file.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*模块* 是包含代码的文件。模块定义了一组通常相关的 Python 函数或其他对象。模块的名称来源于文件的名称。'
- en: When you understand modules, packages are easy, because a package is a directory
    containing code and possibly further subdirectories. A package contains a group
    of usually related code files (modules). The name of the package is derived from
    the name of the main package directory.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当你理解了模块，包就变得容易了，因为包是一个包含代码和可能进一步子目录的目录。包包含一组通常相关的代码文件（模块）。包的名称来源于主包目录的名称。
- en: Packages are a natural extension of the module concept and are designed to handle
    very large projects. Just as modules group related functions, classes, and variables,
    packages group related modules.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 包是模块概念的天然扩展，旨在处理非常大的项目。就像模块将相关的函数、类和变量分组一样，包将相关的模块分组。
- en: 18.2\. A first example
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 18.2. 第一个例子
- en: 'To see how packages might work in practice, consider a design layout for a
    type of project that by nature is very large: a generalized mathematics package
    along the lines of Mathematica, Maple, or MATLAB. Maple, for example, consists
    of thousands of files, and some sort of hierarchical structure is vital to keeping
    such a project ordered. Call your project as a whole `mathproj`.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了了解包在实际中可能如何工作，考虑一个设计布局，这种项目在本质上是非常大的：类似于 Mathematica、Maple 或 MATLAB 的一般数学包。例如，Maple
    由数千个文件组成，某种层次结构对于保持此类项目的有序性至关重要。将你的整个项目称为 `mathproj`。
- en: 'You can organize such a project in many ways, but a reasonable design splits
    the project into two parts: `ui`, consisting of the UI elements, and `comp`, the
    computational elements. Within `comp`, it may make sense to further segment the
    computational aspect into `symbolic` (real and complex symbolic computation, such
    as high school algebra) and `numeric` (real and complex numerical computation,
    such as numerical integration). Then it may make sense to have a constants.py
    file in both the `symbolic` and `numeric` parts of the project.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以用许多方式组织这样的项目，但一个合理的设计是将项目分为两部分：`ui`，包含 UI 元素，和 `comp`，包含计算元素。在 `comp` 中，进一步将计算方面分割成
    `symbolic`（实数和复数符号计算，如高中代数）和 `numeric`（实数和复数数值计算，如数值积分）可能是有意义的。然后，在项目的 `symbolic`
    和 `numeric` 部分都可能有 constants.py 文件。
- en: The constants.py file in the numeric part of the project defines pi as
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 项目数值部分中的 constants.py 文件将 π 定义为
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: whereas the constants.py file in the symbolic part of the project defines pi
    as
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 而项目符号部分的 constants.py 文件将 π 定义为
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This means that a name like `pi` can be used in (and imported from) two different
    files named constants.py, as shown in [figure 18.1](#ch18fig01).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着像 `pi` 这样的名称可以在（并从）两个不同的名为 constants.py 的文件中使用（导入），如图18.1所示。
- en: Figure 18.1\. Organizing a math package
  id: totrans-20
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图18.1. 组织数学包
- en: '![](images/18fig01.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](images/18fig01.jpg)'
- en: The symbolic constants.py file defines `pi` as an abstract Python object, the
    sole instance of the `PiClass` class. As the system is developed, various operations
    can be implemented in this class, which return symbolic rather than numeric results.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 符号常数 constants.py 文件将 `pi` 定义为一个抽象的 Python 对象，`PiClass` 类的唯一实例。随着系统的开发，可以在该类中实现各种操作，这些操作返回符号结果而不是数值结果。
- en: There’s a natural mapping from this design structure to a directory structure.
    The top-level directory of the project, called `mathproj`, contains subdirectories
    `ui` and `comp`; `comp` in turn contains subdirectories `symbolic` and `numeric`;
    and each of `symbolic` and `numeric` contains its own `constants.pi` file.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个设计结构到目录结构有一个自然的映射。项目顶层目录，称为 `mathproj`，包含子目录 `ui` 和 `comp`；`comp` 又包含子目录
    `symbolic` 和 `numeric`；而 `symbolic` 和 `numeric` 各自都包含自己的 `constants.pi` 文件。
- en: Given this directory structure, and assuming that the root mathproj directory
    is installed somewhere in the Python search path, Python code both inside and
    outside the `mathproj` package can access the two variants of `pi` as `mathproj.symbolic.constants.pi`
    and `mathproj.numeric.constants.pi`. In other words, the Python name for an item
    in the package is a reflection of the directory pathname to the file containing
    that item.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 给定这种目录结构，假设根目录mathproj安装在了Python搜索路径的某个位置，Python代码无论是`mathproj`包内部还是外部都可以访问`pi`的两个变体，即`mathproj.symbolic.constants.pi`和`mathproj.numeric.constants.pi`。换句话说，包中项目的Python名称反映了包含该项目的文件路径名。
- en: That’s what packages are all about. They’re ways of organizing very large collections
    of Python code into coherent wholes, by allowing the code to be split among different
    files and directories and imposing a module/submodule naming scheme based on the
    directory structure of the package files. Unfortunately, packages aren’t this
    simple in practice because details intrude to make their use more complex than
    their theory. The practical aspects of packages are the basis for the remainder
    of this chapter.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是包的全部内容。它们是将大量Python代码组织成连贯整体的方法，通过允许代码在不同的文件和目录之间分割，并基于包文件的目录结构实施模块/子模块命名方案。不幸的是，在实践中包并不这么简单，因为细节的干扰使得它们的使用比理论更复杂。包的实用方面是本章其余部分的基础。
- en: 18.3\. A concrete example
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 18.3\. 一个具体示例
- en: The rest of this chapter uses a running example to illustrate the inner workings
    of the package mechanism (see [figure 18.2](#ch18fig02)). Filenames and paths
    are shown in plain text to clarify whether I’m talking about a file/directory
    or the module/package defined by that file/directory. The files you’ll be using
    in your example package are shown in [listings 18.1](#ch18ex01) through [18.6](#ch18ex06).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的其余部分使用一个运行示例来说明包机制的内部工作原理（见[图18.2](#ch18fig02)）。文件名和路径以纯文本形式显示，以明确我是在谈论文件/目录，还是由该文件/目录定义的模块/包。你将在示例包中使用的文件显示在[列表18.1](#ch18ex01)到[18.6](#ch18ex06)中。
- en: Listing 18.1\. File mathproj/__init__.py
  id: totrans-28
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表18.1\. 文件 mathproj/__init__.py
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Figure 18.2\. Example package
  id: totrans-30
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 图18.2\. 示例包
- en: '![](images/18fig02_alt.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](images/18fig02_alt.jpg)'
- en: Listing 18.2\. File mathproj/comp/__init__.py
  id: totrans-32
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表18.2\. 文件 mathproj/comp/__init__.py
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Listing 18.3\. File mathproj/comp/c1.py
  id: totrans-34
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表18.3\. 文件 mathproj/comp/c1.py
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Listing 18.4\. File mathproj/comp/numeric/__init__.py
  id: totrans-36
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表18.4\. 文件 mathproj/comp/numeric/__init__.py
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Listing 18.5\. File mathproj/comp/numeric/n1.py
  id: totrans-38
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表18.5\. 文件 mathproj/comp/numeric/n1.py
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Listing 18.6\. File mathproj/comp/numeric/n2.py
  id: totrans-40
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 列表18.6\. 文件 mathproj/comp/numeric/n2.py
- en: '[PRE7]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: For the purposes of the examples in this chapter, assume that you’ve created
    these files in a mathproj directory that’s on the Python search path. (It’s sufficient
    to ensure that the current working directory for Python is the directory containing
    mathproj when executing these examples.)
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 为了本章示例的目的，假设你已经在Python搜索路径上的mathproj目录中创建了这些文件。（当执行这些示例时，确保Python的当前工作目录是包含mathproj的目录就足够了。）
- en: '|  |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Note
  id: totrans-44
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 注意
- en: In most of the examples in this book, it’s not necessary to start up a new Python
    shell for each example. You can usually execute the examples in a Python shell
    that you’ve used for previous examples and still get the results shown. *This
    isn’t true for the examples in this chapter*, however, because the Python namespace
    must be clean (unmodified by previous `import` statements) for the examples to
    work properly. If you do run the examples that follow, *please ensure that you
    run each separate example in its own shell.* In IDLE, this requires exiting and
    restarting the program, not just closing and reopening its Shell window.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的大多数示例中，不需要为每个示例启动一个新的Python shell。你通常可以在之前示例使用的Python shell中执行示例，并仍然得到显示的结果。然而，*本章的示例并非如此*，因为为了示例能够正常工作，Python命名空间必须保持干净（未被之前的`import`语句修改）。如果你运行以下示例，*请确保你在自己的shell中运行每个单独的示例。*
    在IDLE中，这需要退出并重新启动程序，而不仅仅是关闭和重新打开其Shell窗口。
- en: '|  |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 18.3.1\. __init__.py files in packages
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 18.3.1\. 包中的`__init__.py`文件
- en: 'You’ll have noticed that all the directories in your package—mathproj, mathproj/comp,
    and mathproj/numeric—contain a file called `__init__.py`. An `__init__.py` file
    serves two purposes:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，你包中的所有目录——mathproj、mathproj/comp和mathproj/numeric——都包含一个名为`__init__.py`的文件。`__init__.py`文件有两个作用：
- en: Python requires that a directory contain an `__init__.py` file before it can
    be recognized as a package. This requirement prevents directories containing miscellaneous
    Python code from being accidentally imported as though they defined a package.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python要求一个目录在被视为包之前必须包含一个`__init__.py`文件。这个要求防止了包含杂乱Python代码的目录被意外导入，好像它们定义了一个包一样。
- en: The `__init__.py` file is automatically executed by Python the first time a
    package or subpackage is loaded. This execution permits whatever package initialization
    you desire.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python在第一次加载包或子包时会自动执行`__init__.py`文件。这次执行允许你进行任何想要的包初始化。
- en: The first point is usually more important. For many packages, you won’t need
    to put anything in the package’s `__init__.py` file; just make sure that an empty
    `__init__.py` file is present.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 第一点通常更重要。对于许多包，你不需要在包的`__init__.py`文件中放置任何内容；只需确保存在一个空的`__init__.py`文件。
- en: 18.3.2\. Basic use of the mathproj package
  id: totrans-52
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 18.3.2\. mathproj包的基本使用
- en: 'Before getting into the details of packages, look at accessing items contained
    in the `mathproj` package. Start a new Python shell, and do the following:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入了解包的细节之前，看看如何访问`mathproj`包中包含的项目。启动一个新的Python shell，并执行以下操作：
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: If all goes well, you should get another input prompt and no error messages.
    Also, the message `"Hello from mathproj init"` should be printed to the screen
    by code in the `mathproj/__init__.py` file. I talk more about `__init__.py` files
    soon; for now, all you need to know is that the files run automatically whenever
    a package is first loaded.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，你应该会得到另一个输入提示，没有错误信息。此外，屏幕上应该通过`mathproj/__init__.py`文件中的代码打印出消息`"Hello
    from mathproj init"`。我很快会更多地讨论`__init__.py`文件；现在，你需要知道的是，文件在包首次加载时自动运行。
- en: 'The `mathproj/__init__.py` file assigns 1.03 to the variable `version`. `version`
    is in the scope of the `mathproj` package namespace, and after it’s created, you
    can see it via `mathproj`, even from outside the `mathproj/__init__.py` file:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`mathproj/__init__.py`文件将1.03赋值给变量`version`。`version`在`mathproj`包命名空间的作用域内，创建后，你可以通过`mathproj`看到它，即使是从`mathproj/__init__.py`文件外部也可以：'
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In use, packages can look a lot like modules; they can provide access to objects
    defined within them via attributes. This fact isn’t surprising, because packages
    are a generalization of modules.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用中，包可以看起来很像模块；它们可以通过属性提供对它们内部定义的对象的访问。这个事实并不令人惊讶，因为包是模块的泛化。
- en: 18.3.3\. Loading subpackages and submodules
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 18.3.3\. 加载子包和子模块
- en: Now start looking at how the various files defined in the `mathproj` package
    interact with one another. To do so, invoke the function `g` defined in the file
    `mathproj/comp/numeric/n1.py`. The first obvious question is whether this module
    has been loaded. You’ve already loaded `mathproj`, but what about its subpackage?
    To see whether it’s known to Python, type
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在开始查看`mathproj`包中定义的各种文件是如何相互交互的。要做到这一点，调用在`mathproj/comp/numeric/n1.py`文件中定义的函数`g`。第一个明显的问题是这个模块是否已经被加载。你已经加载了`mathproj`，但它的子包呢？为了查看它是否为Python所知，输入
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In other words, loading the top-level module of a package isn’t enough to load
    all the submodules, which is in keeping with Python’s philosophy that it shouldn’t
    do things behind your back. Clarity is more important than conciseness.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，加载包的顶级模块并不足以加载所有子模块，这与Python的哲学相符，即它不应该在你背后做事情。清晰比简洁更重要。
- en: 'This restriction is simple enough to overcome. You import the module of interest
    and then execute the function `g` in that module:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这个限制足够简单，可以克服。你导入感兴趣的模块，然后在该模块中执行函数`g`：
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Notice, however, that the lines beginning with `Hello` are printed out as a
    side effect of loading `mathproj.comp.numeric.n1`. These two lines are printed
    out by `print` statements in the `__init__.py` files in mathproj/comp and mathproj/comp/numeric.
    In other words, before Python can import `mathproj.comp.numeric.n1`, it has to
    import `mathproj.comp` and then `mathproj.comp.numeric`. Whenever a package is
    first imported, its associated `__init__.py` file is executed, resulting in the
    `Hello` lines. To confirm that both `mathproj.comp` and `mathproj.comp.numeric`
    are imported as part of the process of importing `mathproj.comp.numeric.n1`, you
    can check to see that `mathproj.comp` and `mathproj.comp.numeric` are now known
    to the Python session:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，然而，以`Hello`开头的行是在加载`mathproj.comp.numeric.n1`时作为副作用打印出来的。这两行是由mathproj/comp和mathproj/comp/numeric中的`__init__.py`文件中的`print`语句打印出来的。换句话说，在Python能够导入`mathproj.comp.numeric.n1`之前，它必须先导入`mathproj.comp`，然后是`mathproj.comp.numeric`。每当包首次导入时，其关联的`__init__.py`文件就会被执行，从而产生`Hello`行。为了确认`mathproj.comp`和`mathproj.comp.numeric`都是作为导入`mathproj.comp.numeric.n1`过程的一部分被导入的，你可以检查以确认`mathproj.comp`和`mathproj.comp.numeric`现在被Python会话所知：
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 18.3.4\. import statements within packages
  id: totrans-67
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 18.3.4\. import statements within packages
- en: Files within a package don’t automatically have access to objects defined in
    other files in the same package. As in outside modules, you must use `import`
    statements to explicitly access objects from other package files. To see how this
    use of `import` works in practice, look back at the `n1` subpackage. The code
    contained in `n1.py` is
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 包内的文件默认情况下无法自动访问同一包内其他文件中定义的对象。就像在外部模块中一样，你必须使用`import`语句来显式访问其他包文件中的对象。为了了解这种`import`的使用在实际中是如何工作的，回顾一下`n1`子包。`n1.py`中包含的代码
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`g` makes use of both `version` from the top-level `mathproj` package and the
    function `h` from the `n2` module; hence, the module containing `g` must import
    both `version` and `h` to make them accessible. You import `version` as you would
    in an `import` statement from outside the `mathproj` package: by saying `from
    mathproj import version`. In this example, you explicitly import `h` into the
    code by saying `from mathproj.comp.numeric.n2 import h`, and this technique works
    in any file; explicit imports of package files are always allowed. But because
    `n2.py` is in the same directory as `n1.py`, you can also use a relative import
    by prepending a single dot to the submodule name. In other words, you can say'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`g`使用了顶级`mathproj`包中的`version`以及`n2`模块中的函数`h`；因此，包含`g`的模块必须导入`version`和`h`以使它们可访问。你像在`mathproj`包外部使用`import`语句一样导入`version`：通过说`from
    mathproj import version`。在这个例子中，你通过说`from mathproj.comp.numeric.n2 import h`显式地将`h`导入到代码中，这种技术在任何文件中都可以使用；包文件的显式导入总是允许的。但是，因为`n2.py`与`n1.py`在同一个目录下，你也可以使用相对导入，通过在子模块名称前添加一个点。换句话说，你可以这样写'
- en: '[PRE14]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: as the third line in `n1.py`, and it works fine.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如`n1.py`中的第三行所示，并且运行正常。
- en: You can add more dots to move up more levels in the package hierarchy, and you
    can add module names. Instead of writing
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以添加更多的点来在包层次结构中向上移动更多层级，并且可以添加模块名称。而不是写成
- en: '[PRE15]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: you could have written the imports of n1.py as
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你原本可以将n1.py的导入写成
- en: '[PRE16]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Relative imports can be handy and quick to type, but be aware that they’re *relative*
    to the module’s `__name__` property. Therefore, any module being executed as the
    main module and thus having `__main__` as its `__name__` can’t use relative imports.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 相对导入既方便又快捷，但请注意，它们是相对于模块的`__name__`属性的。因此，任何作为主模块执行并因此具有`__main__`作为其`__name__`的模块都不能使用相对导入。
- en: 18.4\. The __all__ attribute
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 18.4\. The __all__ attribute
- en: If you look back at the various `__init__.py` files defined in `mathproj`, you’ll
    notice that some of them define an attribute called `__all__`. This attribute
    has to do with execution of statements of the form `from ... import *`, and it
    requires explanation.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你回顾一下在`mathproj`中定义的各种`__init__.py`文件，你会注意到其中一些定义了一个名为`__all__`的属性。这个属性与`from
    ... import *`形式的语句的执行有关，需要解释。
- en: Generally speaking, you’d hope that if outside code executed the statement `from
    mathproj import *`, it would import all nonprivate names from `mathproj`. In practice,
    life is more difficult. The primary problem is that some operating systems have
    an ambiguous definition of case when it comes to filenames. Because objects in
    packages can be defined by files or directories, this situation leads to ambiguity
    as to the exact name under which a subpackage might be imported. If you say `from
    mathproj import *`, will `comp` be imported as `comp`, `Comp`, or `COMP`? If you
    were to rely only on the name as reported by the operating system, the results
    might be unpredictable.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 通常来说，你希望如果外部代码执行了`from mathproj import *`这个语句，它将导入`mathproj`中所有非私有名称。但在实践中，事情要复杂得多。主要问题是某些操作系统在文件名方面对大小写有模糊的定义。由于包中的对象可以由文件或目录定义，这种情况导致了对子包可能导入的确切名称存在歧义。如果你说`from
    mathproj import *`，`comp`会被导入为`comp`、`Comp`还是`COMP`？如果你仅仅依赖于操作系统报告的名称，结果可能是不可预测的。
- en: There’s no good solution to this problem, which is an inherent one caused by
    poor OS design. As the best possible fix, the `__all__` attribute was introduced.
    If present in an `__init__.py` file, `__all__` should give a list of strings,
    defining those names that are to be imported when a `from ... import *` is executed
    on that particular package. If `__all__` isn’t present, `from ... import *` on
    the given package does nothing. Because case in a text file is always meaningful,
    the names under which objects are imported aren’t ambiguous, and if the operating
    system thinks that `comp` is the same as `COMP`, that’s its problem.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个问题，没有好的解决方案，这是由糟糕的操作系统设计导致的固有问题。作为最好的解决方案，引入了`__all__`属性。如果存在于`__init__.py`文件中，`__all__`应该提供一个字符串列表，定义了在执行特定包上的`from
    ... import *`时应该导入的名称。如果没有`__all__`，给定包上的`from ... import *`将不起作用。因为文本文件中的大小写总是有意义的，所以导入的对象的名称不会产生歧义，如果操作系统认为`comp`和`COMP`是相同的，那是它的问题。
- en: 'Fire up Python again, and try the following:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 再次启动Python，尝试以下操作：
- en: '[PRE17]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `__all__` attribute in `mathproj/__init__.py` contains a single entry,
    `comp`, and the `import` statement imports only `comp`. It’s easy enough to check
    whether `comp` is now known to the Python session:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`mathproj/__init__.py`中的`__all__`属性包含单个条目`comp`，而`import`语句只导入`comp`。检查`comp`现在是否被Python会话所知是很容易的：'
- en: '[PRE18]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'But note that there’s no recursive importing of names with a `from ... import
    *` statement. The `__all__` attribute for the `comp` package contains `c1`, but
    `c1` isn’t magically loaded by your `from mathproj import *` statement:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 但请注意，使用`from ... import *`语句没有递归导入名称。`comp`包的`__all__`属性包含`c1`，但`c1`并不会因为你的`from
    mathproj import *`语句而神奇地被加载：
- en: '[PRE19]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To insert names from `mathproj.comp`, you must again do an explicit import:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 要插入`mathproj.comp`中的名称，你必须再次进行显式导入：
- en: '[PRE20]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 18.5\. Proper use of packages
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 18.5. 正确使用包
- en: Most of your packages shouldn’t be as structurally complex as these examples
    imply. The package mechanism allows wide latitude in the complexity and nesting
    of your package design. It’s obvious that very complex packages *can* be built,
    but it isn’t obvious that they *should* be built.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数包的结构不应该像这些例子所暗示的那样复杂。包机制允许你在包设计中的复杂性和嵌套方面有很大的灵活性。很明显，可以构建非常复杂的包，但并不明显的是它们应该被构建。
- en: 'Here are a couple of suggestions that are appropriate in most circumstances:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些在大多数情况下都适用的建议：
- en: Packages shouldn’t use deeply nested directory structures. Except for absolutely
    huge collections of code, there should be no need to do so. For most packages,
    a single top-level directory is all that’s needed. A two-level hierarchy should
    be able to effectively handle all but a few of the rest. As written in *The* *Zen
    of Python*, by Tim Peters (see [appendix A](kindle_split_039.html#app02)), “Flat
    is better than nested.”
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包不应该使用深度嵌套的目录结构。除了绝对巨大的代码集合外，通常不需要这样做。对于大多数包来说，一个单独的顶层目录就足够了。两层层次结构应该能够有效地处理除了少数情况之外的所有情况。正如Tim
    Peters在*Python之禅*（见[附录A](kindle_split_039.html#app02)）中所写的那样，“扁平优于嵌套。”
- en: Although you can use the `__all__` attribute to hide names from `from ... import
    *` by not listing those names, doing so probably is *not* a good idea, because
    it’s inconsistent. If you want to hide names, make them private by prefacing them
    with an underscore.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然你可以使用`__all__`属性通过不列出这些名称来隐藏`from ... import *`中的名称，但这样做可能并不是一个好主意，因为它不一致。如果你想隐藏名称，通过在名称前加上下划线使其成为私有名称。
- en: '|  |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Quick Check: Packages'
  id: totrans-96
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 快速检查：包
- en: Suppose that you’re writing a package that takes a URL, retrieves all images
    on the page pointed to by that URL, resizes them to a standard size, and stores
    them. Leaving aside the exact details of how each of these functions will be coded,
    how would you organize those features into a package?
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在编写一个包，该包接受一个 URL，检索该 URL 指向的页面上的所有图像，将它们调整到标准尺寸，并将它们存储起来。不考虑每个函数的确切编码细节，你将如何将这些功能组织到一个包中？
- en: '|  |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: '|  |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: 'Lab 18: Create a package'
  id: totrans-100
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 实验室 18：创建一个包
- en: In [chapter 14](kindle_split_025.html#ch14), you added error handling to the
    text cleaning and word frequency counting module that you created in [chapter
    11](kindle_split_022.html#ch11). Refactor that code into a package containing
    one module for the cleaning functions, one for the processing functions, and one
    for the custom exceptions. Then write a simple main function that uses all three.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 14 章（kindle_split_025.html#ch14）中，你为你在第 11 章（kindle_split_022.html#ch11）中创建的文本清理和单词频率统计模块添加了错误处理。将此代码重构为一个包含一个用于清理函数的模块、一个用于处理函数的模块和一个用于自定义异常的模块的包。然后编写一个简单的
    main 函数，使用这三个模块。
- en: '|  |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '|'
- en: Summary
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 摘要
- en: Packages let you create libraries of code that span multiple files and directories.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包让你能够创建跨越多个文件和目录的代码库。
- en: Using packages allows better organization of large collections of code than
    single modules would allow.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用包比使用单个模块更好地组织大量代码。
- en: You should be wary of nesting directories in your packages more than one or
    two levels deep unless you have a very large and complex library.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你应该小心不要在包中嵌套超过一两个级别的目录，除非你有一个非常大且复杂的库。
