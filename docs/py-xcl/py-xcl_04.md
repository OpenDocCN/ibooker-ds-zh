第三章。开始学习Python

安装了Anaconda并且Jupyter笔记本已经运行起来后，你就准备好开始使用Python了。虽然本章不会深入探讨基础之外的内容，但它仍然涵盖了很多内容。如果你刚开始学习编程，可能需要消化的内容很多。然而，大多数概念在后面的章节中通过实际示例使用后会变得更加清晰，因此如果第一次理解不完全，也不用担心。每当Python和VBA有显著区别时，我会指出来，以确保你能够顺利从VBA过渡到Python，并了解显而易见的陷阱。如果你以前没有接触过VBA，可以忽略这些部分。

我将从Python的基本数据类型开始，比如整数和字符串。接下来，我会介绍索引和切片，这是Python中的核心概念，它让你可以访问序列的特定元素。接着是像列表和字典这样可以容纳多个对象的数据结构。我会继续介绍`if`语句以及`for`和`while`循环，然后介绍允许你组织和结构化代码的函数和模块。最后，我会展示如何正确格式化你的Python代码。到目前为止，你可能已经猜到，这一章的技术性非常强。在Jupyter笔记本中运行示例对于使一切更加互动和有趣是个不错的主意。你可以自己输入示例，也可以使用伴随存储库中提供的笔记本来运行它们。

数据类型

Python和其他编程语言一样，通过为它们分配不同的数据类型来区分数字、文本、布尔值等。我们经常使用的数据类型包括整数、浮点数、布尔值和字符串。在这一部分，我将逐个介绍它们，并举几个例子。然而，要理解数据类型，首先需要解释对象是什么。

对象

在Python中，一切都是对象，包括数字、字符串、函数以及我们在本章中将遇到的所有内容。通过提供对一组变量和函数的访问，对象可以通过使复杂的事情变得简单和直观来帮助你。因此，在任何其他事情之前，让我先介绍一些关于变量和函数的内容！

变量

在Python中，变量是通过使用等号将名称分配给对象来定义的。在以下示例的第一行中，名称`a`被分配给对象`3`：

> `In``[``1``]:``a``=``3``b``=``4``a``+``b`
> 
> `Out[1]: 7`

对于所有对象来说，这在Python中都是相同的，相比之下，VBA更简单，你可以使用等号表示数字和字符串等数据类型，使用`Set`语句表示像工作簿或工作表这样的对象。在Python中，你可以通过将变量分配给一个新对象来简单地改变变量的类型。这被称为动态类型：

> `In``[``2``]:``a``=``3``print``(``a``)``a``=``"three"``print``(``a``)`
> 
> `3 three`

与VBA不同，Python是区分大小写的，所以`a`和`A`是两个不同的变量。变量名必须遵循某些规则：

+   > > > > 它们必须以字母或下划线开头
+   > > > > 
+   > > > > 它们必须由字母、数字和下划线组成

在这个关于变量的简短介绍之后，让我们看看如何进行函数调用！

函数

我将在本章后面更详细地介绍函数。现在，你只需要知道如何调用内置函数，比如我们在前面代码示例中使用的`print`。要调用函数，你需要在函数名后加上括号，并在括号内提供参数，这几乎相当于数学表示法：

> `function_name``(``argument1``,``argument2``,``...``)`

现在让我们看看在对象的上下文中变量和函数是如何工作的！

属性和方法

在对象的上下文中，变量被称为属性，函数被称为方法：属性允许你访问对象的数据，而方法允许你执行操作。要访问属性和方法，你可以使用点号表示法，如`myobject.attribute`和`myobject.method()`。

让我们具体化一下：如果你编写了一个汽车赛车游戏，你很可能会使用一个表示汽车的对象。`car`对象可能有一个`speed`属性，通过`car.speed`可以获取当前速度，并且你可以通过调用`car.accelerate(10)`方法来加速汽车，这将使速度增加十英里每小时。

对象的类型及其行为由类定义，因此前面的例子需要你编写一个`Car`类。从`Car`类获取一个`car`对象的过程称为实例化，你可以通过调用类来实例化对象，就像调用函数一样：`car = Car()`。我们不会在本书中编写自己的类，但如果你对其工作原理感兴趣，请查看[附录 C](index_split_031.html#filepos1832059)。

在接下来的一节中，我们将使用第一个对象方法使文本字符串变为大写，并且当我们讨论本章末尾关于`datetime`对象时，我们将回到对象和类的主题。现在，让我们继续讨论具有数值数据类型的对象！

数值类型

数据类型`int`和`float`分别表示整数和浮点数。要找出给定对象的数据类型，使用内置的`type`函数：

> `In``[``3``]:``type``(``4``)`
> 
> `Out[3]: int`
> 
> `In``[``4``]:``type``(``4.4``)`
> 
> `Out[4]: float`

如果你想将数字强制转换为`float`而不是`int`，只需使用尾部的小数点或`float`构造函数即可：

> `In``[``5``]:``type``(``4.``)`
> 
> `Out[5]: float`
> 
> `In``[``6``]:``float``(``4``)`
> 
> `Out[6]: 4.0`

最后一个示例也可以反过来使用：使用 `int` 构造函数，你可以将 `float` 转换为 `int`。如果小数部分不为零，它将被截断：

> `In``[``7``]:``int``(``4.9``)`
> 
> `Out[7]: 4`
> 
> EXCEL 单元格始终存储浮点数
> 
> 当你需要从 Excel 单元格中读取一个数，并将其作为整数传递给 Python 函数时，可能需要将 `float` 转换为 `int`。原因是，Excel 单元格中的数字始终以浮点数形式存储，即使 Excel 显示的是整数也是如此。

Python 还有一些数值类型，本书不会使用或讨论：有 `decimal`、`fraction` 和 `complex` 数据类型。如果浮点数不准确是个问题（参见侧边栏），可以使用 `decimal` 类型获得精确的结果。不过，这类情况非常罕见。作为一个经验法则：如果 Excel 的计算结果已经足够，那就使用浮点数。

> 浮点数不准确
> 
> 默认情况下，Excel 经常显示四舍五入的数字：在单元格中输入 `=1.125-1.1`，你会看到 `0.025`。虽然这可能是你期望的结果，但这不是 Excel 内部存储的内容。将显示格式更改为至少显示 16 位小数，结果将变为 `0.0249999999999999`。这是浮点数不准确的影响：计算机生活在一个二进制世界中，即它们只能使用 0 和 1 进行计算。某些十进制分数如 `0.1` 无法作为有限的二进制浮点数存储，这解释了减法的结果。在 Python 中，你会看到相同的效果，但 Python 不会隐藏小数部分：
> 
> `In``[``8``]:``1.125``-``1.1`
> 
> `Out[8]: 0.02499999999999991`

数学运算符

使用数值计算需要使用加号或减号等数学运算符。除了幂运算符外，如果你来自 Excel 的话，不应该有任何意外：

> `In``[``9``]:``3``+``4``# 求和`
> 
> `Out[9]: 7`
> 
> `In``[``10``]:``3``-``4``# 减法`
> 
> `Out[10]: -1`
> 
> `In``[``11``]:``3``/``4``# 除法`
> 
> `Out[11]: 0.75`
> 
> `In``[``12``]:``3``*``4``# 乘法`
> 
> `Out[12]: 12`
> 
> `In``[``13``]:``3``**``4``# 幂运算符（Excel 使用 3^4）`
> 
> `Out[13]: 81`
> 
> `In``[``14``]:``3``*``(``3``+``4``)``# 使用括号`
> 
> `Out[14]: 21`
> 
> 注释
> 
> 在前面的例子中，我用注释描述了示例的操作（例如 `# 求和`）。注释有助于其他人（以及你在编写代码后的几周内）理解程序中的运行情况。最好的做法是只注释那些从代码阅读中不明显的事物：如果不确定，最好不要有注释，而不是有一个过时的注释与代码相矛盾。在 Python 中，任何以井号开头的内容都是注释，运行代码时会被忽略：
> 
> `In``[``15``]:``# 这是我们之前见过的示例。``# 每行注释都必须以 # 开头``3``+``4`
> 
> `Out[15]: 7`
> 
> `In``[``16``]:``3``+``4``# 这是内联注释`
> 
> `Out[16]: 7`
> 
> 大多数编辑器都有快捷键可以注释或取消注释行。在 Jupyter 笔记本和 VS Code 中，Windows 下是 Ctrl+/，macOS 下是 Command-/。请注意，在 Jupyter 笔记本的 Markdown 单元格中不接受注释——如果您以 `#` 开头，Markdown 将把它解释为标题。

现在我们已经涵盖了整数和浮点数，让我们直接转到关于布尔值的下一节！

布尔值

Python 中的布尔类型为 `True` 或 `False`，与 VBA 完全相同。然而，布尔运算符 `and`、`or` 和 `not` 全部小写，而 VBA 则大写显示。布尔表达式类似于 Excel 中的工作方式，但等式和不等式运算符有所不同：

> `In``[``17``]:``3``==``4``# Equality (Excel uses 3 = 4)`
> 
> `Out[17]: False`
> 
> `In``[``18``]:``3``!=``4``# Inequality (Excel uses 3 <> 4)`
> 
> `Out[18]: True`
> 
> `In``[``19``]:``3``<``4``# Smaller than. Use > for bigger than.`
> 
> `Out[19]: True`
> 
> `In``[``20``]:``3``<=``4``# Smaller or equal. Use >= for bigger or equal.`
> 
> `Out[20]: True`
> 
> `In``[``21``]:``# You can chain logical expressions``# In VBA, this would be: 10 < 12 And 12 < 17``# In Excel formulas, this would be: =AND(10 < 12, 12 < 17)``10``<``12``<``17`
> 
> `Out[21]: True`
> 
> `In``[``22``]:``not``True``# "not" operator`
> 
> `Out[22]: False`
> 
> `In``[``23``]:``False``and``True``# "and" operator`
> 
> `Out[23]: False`
> 
> `In``[``24``]:``False``or``True``# "or" operator`
> 
> `Out[24]: True`

每个 Python 对象都会评估为 `True` 或 `False`。大多数对象为 `True`，但有一些会评估为 `False`，包括 `None`（见侧边栏），`False`，`0` 或空数据类型，例如空字符串（我将在下一节介绍字符串）。

> NONE
> 
> `None` 是一个内置常量，代表“没有值”，根据官方文档。例如，如果函数没有显式返回任何内容，它将返回 `None`。它还是在 Excel 中表示空单元格的良好选择，我们将在 [第 III 部分](index_split_018.html#filepos863198) 和 [第 IV 部分](index_split_023.html#filepos1235617) 中看到。

若要双重检查对象是否为 `True` 或 `False`，请使用 `bool` 构造函数：

> `In``[``25``]:``bool``(``2``)`
> 
> `Out[25]: True`
> 
> `In``[``26``]:``bool``(``0``)`
> 
> `Out[26]: False`
> 
> `In``[``27``]:``bool``(``"some text"``)``# We'll get to strings in a moment`
> 
> `Out[27]: True`
> 
> `In``[``28``]:``bool``(``""``)`
> 
> `Out[28]: False`
> 
> `In``[``29``]:``bool``(``None``)`
> 
> `Out[29]: False`

有了布尔值的支持，我们还剩下一种基本数据类型：文本数据，通常称为字符串。

字符串

如果你曾经在VBA中使用过超过一行的字符串，并且包含变量和文字引号，你可能希望它更加简单。幸运的是，Python在这方面表现特别出色。字符串可以用双引号(`"`)或单引号(`'`)表示。唯一的条件是你必须用相同类型的引号开始和结束字符串。你可以使用 `+` 连接字符串或 `*` 重复字符串。既然我已经在前一章节的Python REPL中展示了重复的情况，这里是使用加号的示例：

> `In``[``30``]:``"一个双引号字符串。 "``+``'一个单引号字符串。'`
> 
> `Out[30]: '一个双引号字符串。一个单引号字符串。'`

根据你想要写的内容，使用单引号或双引号可以帮助你轻松地打印文字引号，而不需要转义它们。如果你仍然需要转义字符，可以在其前面加上反斜杠：

> `In``[``31``]:``print``(``"不要等待！ "``+``'学习如何 "说" Python。'``)`
> 
> `Don't wait! 学会如何 "说" Python。`
> 
> `In``[``32``]:``print``(``"It's easy to` `\"``escape``\"` `characters with a leading` `\\``."``)`
> 
> `It's easy to "escape" characters with a leading \.`

当你将字符串与变量混合使用时，通常使用格式化字符串字面量，即f字符串。只需在字符串前加上 `f`，并在大括号中使用变量：

> `In``[``33``]:``# 请注意Python如何让你方便地在一行中为多个变量赋值``#``first_adjective``,``second_adjective``=``"free"``,``"开源的"`f``"Python是{first_adjective}和{second_adjective}。"`
> 
> `Out[33]: 'Python是免费和开源的。'`

正如我在本节开头提到的，字符串与其他一切一样，它们提供一些方法（即函数）来对字符串执行操作。例如，这是如何在大写和小写字母之间转换的示例：

> `In``[``34``]:``"PYTHON"``.``lower``()`
> 
> `Out[34]: 'python'`
> 
> `In``[``35``]:``"python"``.``upper``()`
> 
> `Out[35]: 'PYTHON'`
> 
> 获取帮助
> 
> 你如何知道某些对象（如字符串）提供哪些属性以及它们的方法接受什么参数？答案有点依赖于你使用的工具：在Jupyter笔记本中，在输入对象后面的点后按Tab键，例如`"python".` `<Tab>`。这将显示一个下拉菜单，其中包含此对象提供的所有属性和方法。如果你的光标在方法中，例如在`"python".upper()`的括号内部，按Shift+Tab可以获取该函数的描述。VS Code会自动显示此信息作为工具提示。如果在Anaconda Prompt上运行Python REPL，使用`dir("python")`获取可用属性，并使用`help("python".upper)`打印`upper`方法的描述。除此之外，随时查阅Python的[在线文档](https://docs.python.org)总是一个好主意。如果你正在寻找像pandas这样的第三方包的文档，建议在[PyPI](https://pypi.org)上搜索它们，Python的包索引，你将找到相应主页和文档的链接。

在处理字符串时，常见的任务是选择字符串的部分：例如，你可能想从`EURUSD`的汇率符号中提取`USD`部分。接下来的部分将展示Python强大的索引和切片机制，使你能够精确做到这一点。

索引和切片

索引和切片让你可以访问序列的特定元素。由于字符串是字符序列，我们可以利用它们来学习它是如何工作的。在接下来的部分中，我们将遇到额外的序列，如列表和元组，它们也支持索引和切片。

索引

[图 3-1](#filepos228355)介绍了索引的概念。Python是从零开始索引的，这意味着序列中的第一个元素由索引`0`引用。负索引从`-1`允许你从序列的末尾引用元素。

![](images/00023.jpg)

图 3-1\. 从序列的开始和结尾进行索引

> VBA开发人员的常见错误陷阱
> 
> 如果你来自VBA，索引是一个常见的错误陷阱。VBA对于大多数集合（如`Sheets(1)`）使用基于一的索引，但对于数组（`MyArray(0)`）使用基于零的索引，尽管该默认值可以更改。另一个不同之处在于，VBA使用括号进行索引，而Python使用方括号。

索引的语法如下：

> `sequence``[``index``]`

因此，你可以像这样访问字符串的特定元素：

> `In``[``36``]:``language``=``"PYTHON"`
> 
> `In``[``37``]:``language``[``0``]`
> 
> `Out[37]: 'P'`
> 
> `In``[``38``]:``language``[``1``]`
> 
> `Out[38]: 'Y'`
> 
> `In``[``39``]:``language``[``-``1``]`
> 
> `Out[39]: 'N'`
> 
> `In``[``40``]:``language``[``-``2``]`
> 
> `Out[40]: 'O'`

你经常需要提取不止一个字符——这就是切片发挥作用的地方。

切片

如果你想从序列中获取多个元素，你可以使用切片语法，其工作方式如下：

> `sequence``[``start``:``stop``:``step``]`

Python使用半开区间：`start`索引包含在内，`stop`索引不包含在内。如果省略`start`或`stop`参数，它将分别包括从序列开始到结尾的所有内容。`step`确定方向和步长：例如，`2`将从左到右返回每第二个元素，`-3`将从右到左返回每第三个元素。默认步长为一：

> `In``[``41``]:``language``[:``3``]``# 同`language[0:3]`
> 
> `Out[41]: 'PYT'`
> 
> `In``[``42``]:``language``[``1``:``3``]`
> 
> `Out[42]: 'YT'`
> 
> `In``[``43``]:``language``[``-``3``:]``# 同`language[-3:6]`
> 
> `Out[43]: 'HON'`
> 
> `In``[``44``]:``language``[``-``3``:``-``1``]`
> 
> `Out[44]: 'HO'`
> 
> `In``[``45``]:``language``[::``2``]``# 每第二个元素`
> 
> `Out[45]: 'PTO'`
> 
> `In``[``46``]:``language``[``-``1``:``-``4``:``-``1``]``# 负步长从右向左移动`
> 
> `Out[46]: 'NOH'`

到目前为止，我们只看过单个索引或切片操作，但Python还允许您将多个索引和切片操作链接在一起。例如，如果要从最后三个字符中获取第二个字符，可以像这样做：

> `In``[``47``]:``language``[``-``3``:][``1``]`
> 
> `Out[47]: 'O'`

这与`language[-2]`相同，因此在这种情况下，使用链接并没有太多意义，但在下一节将介绍的列表中使用索引和切片将更有意义。

数据结构

Python提供了强大的数据结构，使得处理对象集合非常容易。在本节中，我将介绍列表、字典、元组和集合。尽管这些数据结构各有些许不同的特性，但它们都能够容纳多个对象。在VBA中，您可能已经使用过集合或数组来保存多个值。VBA甚至提供了一个名为字典的数据结构，其概念上与Python的字典相同。但是，它仅在Excel的Windows版本中默认可用。让我们从列表开始，这是您可能会经常使用的数据结构。

列表

列表能够容纳多个不同数据类型的对象。它们非常灵活，您会经常使用它们。您可以按以下方式创建列表：

> `[``element1``,``element2``,``...``]`

这里有两个列表，一个是Excel文件名，另一个是一些数字：

> `In``[``48``]:``file_names``=``[``"one.xlsx"``,``"two.xlsx"``,``"three.xlsx"``]``numbers``=``[``1``,``2``,``3``]`

像字符串一样，列表可以使用加号轻松连接。这也表明列表可以容纳不同类型的对象：

> `In``[``49``]:``file_names``+``numbers`
> 
> `Out[49]: ['one.xlsx', 'two.xlsx', 'three.xlsx', 1, 2, 3]`

由于列表和其他所有东西一样都是对象，列表也可以将其他列表作为它们的元素。我将它们称为嵌套列表：

> `In``[``50``]:``nested_list``=``[[``1``,``2``,``3``],``[``4``,``5``,``6``],``[``7``,``8``,``9``]]`

如果你重新排列它跨越多行，你可以轻松地识别出这是一个矩阵的非常好的表示，或者一个范围的电子表格单元格。请注意，方括号隐含允许你断开行（参见侧边栏）。通过索引和切片，你可以得到想要的元素：

> `In``[``51``]:``cells``=``[[``1``,``2``,``3``],``[``4``,``5``,``6``],``[``7``,``8``,``9``]]`
> 
> `In``[``52``]:``cells``[``1``]``# 第二行`
> 
> `Out[52]: [4, 5, 6]`
> 
> `In``[``53``]:``cells``[``1``][``1``:]``# 第二行，第二和第三列`
> 
> `Out[53]: [5, 6]`
> 
> LINE CONTINUATION
> 
> 有时，一行代码可能会变得如此之长，以至于你需要将其分成两行或更多行以保持代码可读性。从技术上讲，你可以使用括号或反斜杠来断开行：
> 
> `In``[``54``]:``a``=``(``1``+``2``+``3``)`
> 
> `In``[``55``]:``a``=``1``+``2` `\` `+``3`
> 
> 然而，Python 的风格指南更喜欢你尽可能使用隐式换行：每当你使用包含括号、方括号或大括号的表达式时，使用它们来引入换行，而无需引入额外的字符。我将在本章末尾详细介绍 Python 的风格指南。

你可以更改列表中的元素：

> `In``[``56``]:``users``=``[``"Linda"``,``"Brian"``]`
> 
> `In``[``57``]:``users``.``append``(``"Jennifer"``)``# 通常在末尾添加``users`
> 
> `Out[57]: ['Linda', 'Brian', 'Jennifer']`
> 
> `In``[``58``]:``users``.``insert``(``0``,``"Kim"``)``# 在索引 0 处插入 "Kim"``users`
> 
> `Out[58]: ['Kim', 'Linda', 'Brian', 'Jennifer']`

要删除一个元素，可以使用 `pop` 或 `del`。虽然 `pop` 是一个方法，但 `del` 在 Python 中实现为语句：

> `In``[``59``]:``users``.``pop``()``# 默认移除并返回最后一个元素`
> 
> `Out[59]: 'Jennifer'`
> 
> `In``[``60``]:``users`
> 
> `Out[60]: ['Kim', 'Linda', 'Brian']`
> 
> `In``[``61``]:``del``users``[``0``]``# del 删除指定索引处的元素`

其他一些你可以使用列表做的有用的事情是：

> `In``[``62``]:``len``(``users``)``# 长度`
> 
> `Out[62]: 2`
> 
> `In``[``63``]:``"Linda"``in``users``# 检查 users 是否包含 "Linda"`
> 
> `Out[63]: True`
> 
> `In``[``64``]:``print``(``sorted``(``users``))``# 返回一个新的排序列表``print``(``users``)``# 原始列表不变`
> 
> `['Brian', 'Linda'] ['Linda', 'Brian']`
> 
> `In``[``65``]:``users``.``sort``()``# 对原始列表进行排序``users`
> 
> `Out[65]: ['Brian', 'Linda']`

请注意，你也可以在字符串中使用 `len` 和 `in`：

> `In``[``66``]:``len``(``"Python"``)`
> 
> `Out[66]: 6`
> 
> `In``[``67``]:``"free"``in``"Python is free and open source."`
> 
> `Out[67]: True`

要访问列表中的元素，你可以按它们的位置或索引引用它们——这并不总是实际可行的。下一节将讨论的字典允许你通过键（通常是名称）访问元素。

字典

字典将键映射到值。您将经常遇到键/值组合。创建字典的最简单方法如下：

> `{``key1``:``value1``,``key2``:``value2``,``...``}`

虽然列表允许您按索引，即位置，访问元素，但字典允许您按键访问元素。与索引一样，键是通过方括号访问的。以下代码示例将使用货币对（键）映射到汇率（值）：

> `In``[``68``]:``exchange_rates``=``{``"EURUSD"``:``1.1152``,``"GBPUSD"``:``1.2454``,``"AUDUSD"``:``0.6161``}`
> 
> `In``[``69``]:``exchange_rates``[``"EURUSD"``]``# 访问EURUSD汇率`
> 
> `Out[69]: 1.1152`

下面的示例向您展示如何更改现有值并添加新的键值对：

> `In``[``70``]:``exchange_rates``[``"EURUSD"``]``=``1.2``# 更改现有值``exchange_rates`
> 
> `Out[70]: {'EURUSD': 1.2, 'GBPUSD': 1.2454, 'AUDUSD': 0.6161}`
> 
> `In``[``71``]:``exchange_rates``[``"CADUSD"``]``=``0.714``# 添加一个新的键值对``exchange_rates`
> 
> `Out[71]: {'EURUSD': 1.2, 'GBPUSD': 1.2454, 'AUDUSD': 0.6161, 'CADUSD': 0.714}`

合并两个或更多字典的最简单方法是将它们解压到一个新字典中。您通过使用两个前导星号来解压字典。如果第二个字典包含来自第一个字典的键，则将从第一个字典中覆盖值。您可以通过查看`GBPUSD`汇率来看到这种情况发生：

> `In``[``72``]:``{``**``exchange_rates``,``**``{``"SGDUSD"``:``0.7004``,``"GBPUSD"``:``1.2222``}}`
> 
> `Out[72]: {'EURUSD': 1.2,           'GBPUSD': 1.2222,           'AUDUSD': 0.6161,           'CADUSD': 0.714,           'SGDUSD': 0.7004}`

Python 3.9引入了管道字符作为字典的专用合并操作符，这使得您可以简化先前的表达式为：

> `exchange_rates``|``{``"SGDUSD"``:``0.7004``,``"GBPUSD"``:``1.2222``}`

许多对象都可以作为键；以下是一个带整数的示例：

> `In``[``73``]:``currencies``=``{``1``:``"EUR"``,``2``:``"USD"``,``3``:``"AUD"``}`
> 
> `In``[``74``]:``currencies``[``1``]`
> 
> `Out[74]: 'EUR'`

通过使用`get`方法，字典允许您在键不存在的情况下使用默认值：

> `In``[``75``]:``# currencies[100]会引发异常。您可以使用任何其他不存在的键。``# 代替100，也是一样的。``currencies``.``get``(``100``,``"N/A"``)`
> 
> `Out[75]: 'N/A'`

在VBA中，字典通常可以用作`Case`语句的替代。前面的示例可以在VBA中这样写：

> `Select``Case``x``Case``1``Debug``.``Print``"EUR"``Case``2``Debug``.``Print``"USD"``Case``3``Debug``.``Print``"AUD"``Case``Else``Debug``.``Print``"N/A"``End``Select`

现在您知道如何使用字典了，让我们继续下一个数据结构：元组。它们与列表类似，但有一个重大区别，我们将在下一节中看到。

元组

元组与列表类似，区别在于它们是不可变的：一旦创建，它们的元素就不能更改。虽然您通常可以互换使用元组和列表，但元组是在整个程序中从不更改的集合的明显选择。通过用逗号分隔值来创建元组：

> `mytuple``=``element1``,``element2``,``...`

使用括号通常使其更易读：

> `In``[``76``]:``currencies``=``(``"EUR"``,``"GBP"``,``"AUD"``)`

元组允许您以与列表相同的方式访问元素，但不允许更改元素。相反，连接元组将在幕后创建一个新元组，然后将您的变量绑定到此新元组：

> `In``[``77``]:``currencies``[``0``]``# 访问第一个元素`
> 
> `Out[77]: 'EUR'`
> 
> `In``[``78``]:``# 连接元组将返回一个新的元组。``currencies``+``(``"SGD"``,)`
> 
> `Out[78]: ('EUR', 'GBP', 'AUD', 'SGD')`

我在[附录 C](index_split_031.html#filepos1832059)中详细解释了可变对象与不可变对象的区别，但现在让我们来看看本节的最后一个数据结构：集合。

集合

集合是没有重复元素的集合。虽然您可以用它们进行集合理论运算，在实践中它们经常帮助您获取列表或元组的唯一值。通过使用大括号来创建集合：

> `{``element1``,``element2``,``...``}`

要获取列表或元组中的唯一对象，请使用`set`构造函数，如下所示：

> `In``[``79``]:``set``([``"USD"``,``"USD"``,``"SGD"``,``"EUR"``,``"USD"``,``"EUR"``])`
> 
> `Out[79]: {'EUR', 'SGD', 'USD'}`

除此之外，您还可以应用集合理论操作，如交集和并集：

> `In``[``80``]:``portfolio1``=``{``"USD"``,``"EUR"``,``"SGD"``,``"CHF"``}``portfolio2``=``{``"EUR"``,``"SGD"``,``"CAD"``}`
> 
> `In``[``81``]:``# 等同于 portfolio2.union(portfolio1)``portfolio1``.``union``(``portfolio2``)`
> 
> `Out[81]: {'CAD', 'CHF', 'EUR', 'SGD', 'USD'}`
> 
> `In``[``82``]:``# 等同于 portfolio2.intersection(portfolio1)``portfolio1``.``intersection``(``portfolio2``)`
> 
> `Out[82]: {'EUR', 'SGD'}`

要获取有关集合操作的完整概述，请参阅[官方文档](https://oreil.ly/ju4ed)。在继续之前，让我们快速复习我们刚刚在[表 3-1](#filepos299969)中见过的四种数据结构。它展示了每种数据结构的一个示例，采用了我在前面段落中使用的符号，即所谓的字面量。此外，我还列出了它们的构造函数，这些构造函数提供了一种将一种数据结构转换为另一种的替代方法。例如，要将元组转换为列表，请执行以下操作：

> `In``[``83``]:``currencies``=``"USD"``,``"EUR"``,``"CHF"``currencies`
> 
> `Out[83]: ('USD', 'EUR', 'CHF')`
> 
> `In``[``84``]:``list``(``currencies``)`
> 
> `Out[84]: ['USD', 'EUR', 'CHF']`

表格 3-1\. 数据结构

|  数据结构  |  字面量  |  构造函数  |
| --- | --- | --- |
|  列表  |   `[1, 2, 3]` |   `list((1, 2, 3))` |
|  字典  |   `{"a": 1, "b": 2}` |   `dict(a=1, b=2)` |
|  Tuple  |   `(1, 2, 3)` |   `tuple([1, 2, 3])` |
|  Set  |   `{1, 2, 3}` |   `set((1, 2, 3))` |

到目前为止，你已经了解了所有重要的数据类型，包括基本类型如浮点数和字符串，以及数据结构如列表和字典。在下一节中，我们将继续学习控制流。

控制流

本节将介绍`if`语句以及`for`和`while`循环。`if`语句允许你仅在满足条件时执行某些代码行，而`for`和`while`循环将重复执行一段代码。在本节末尾，我还将介绍列表推导式，这是构建列表的一种方式，可以作为`for`循环的替代方式。我将从代码块的定义开始本节，这也是需要介绍Python最显著的特殊之一：显著的空白。

代码块和`pass`语句

代码块定义了你源代码中用于特殊用途的部分。例如，你可以使用代码块来定义程序循环的行或者它构成函数的定义。在Python中，你通过缩进而不是使用关键字（如VBA中）或者花括号（大多数其他语言中）来定义代码块。这被称为显著的空白。Python社区已经约定使用四个空格作为缩进，但你通常会通过按Tab键来输入它们：Jupyter笔记本和VS Code会自动将你的Tab键转换为四个空格。让我演示一下如何使用`if`语句来正式定义代码块：

> `if``condition``:``pass``# 什么都不做`

代码块前面的行总是以冒号结束。当你不再缩进行时，代码块结束。如果你想创建一个什么都不做的虚拟代码块，你需要使用`pass`语句。在VBA中，这对应以下内容：

> `If``condition``Then``' 什么都不做``End``If`

现在你知道如何定义代码块了，让我们在下一节开始使用它们，我将在那里适当地介绍`if`语句。

`if`语句和条件表达式

要介绍`if`语句，让我来重现[“可读性和可维护性”](index_split_007.html#filepos64265)中的示例，在[第1章](index_split_007.html#filepos32075)中，但这次是用Python：

> `In``[``85``]:``i``=``20``if``i``<``5``:``print``(``"i is smaller than 5"``)``elif``i``<=``10``:``print``(``"i is between 5 and 10"``)``else``:``print``(``"i is bigger than 10"``)`
> 
> `i is bigger than 10`

如果你想做和我们在[第一章](index_split_007.html#filepos32075)里做的一样，即缩进`elif`和`else`语句，你会得到`SyntaxError`。Python不允许你的代码缩进与逻辑不同。与VBA不同的是，Python的关键词是小写的，而不是VBA中的`ElseIf`，Python使用`elif`。`if`语句是判断一个程序员是否新手或者已经采用Python风格的简单方法：在Python中，一个简单的`if`语句不需要括号，而测试一个值是否为`True`，你不需要显式地这样做。这就是我的意思：

> `In``[``86``]:``is_important``=``True``if``is_important``:``print``(``"这很重要。"``)``else``:``print``(``"这不重要。"``)`
> 
> `这很重要。`

要检查类似列表这样的序列是否为空，使用相同的方法：

> `In``[``87``]:``values``=``[]``如果``values``:``print``(``f``"提供了以下数值：{values}"``)``else``:``print``(``"未提供数值。"``)`
> 
> `未提供数值。`

来自其他语言的程序员通常会写类似`if (is_important == True)`或者`if len(values) > 0`的代码。

条件表达式，也称为三元运算符，允许你在简单的`if`/`else`语句中使用更紧凑的风格：

> `In``[``88``]:``is_important``=``False``print``(``"重要"``)``if``is_important``else``print``(``"不重要"``)`
> 
> `不重要`

有了`if`语句和条件表达式，让我们在下一节转向`for`和`while`循环。

`for`和`while`循环

如果你需要重复做一些像打印十个不同变量的值这样的事情，最好不要把打印语句复制/粘贴十次。而是使用`for`循环为你做这些工作。`for`循环遍历序列的项目，比如列表、元组或者字符串（记住，字符串是字符序列）。作为一个介绍性的例子，让我们创建一个`for`循环，它将`currencies`列表的每个元素赋值给变量`currency`，然后逐个打印出来，直到列表中没有更多的元素：

> `In``[``89``]:``currencies``=``[``"USD"``,``"HKD"``,``"AUD"``]``for``currency``in``currencies``:``print``(``currency``)`
> 
> `USD HKD AUD`

顺便提一下，VBA的`For Each`语句与Python的`for`循环工作方式相似。前面的例子在VBA中可以这样写：

> `Dim``currencies``As``Variant``Dim``curr``As``Variant``'currency is a reserved word in VBA``currencies``=``Array``(``"USD"``,``"HKD"``,``"AUD"``)`
> 
> `For``Each``curr``In``currencies``Debug``.``Print``curr``Next`

在 Python 中，如果你需要在 `for` 循环中一个计数变量，`range` 或 `enumerate` 内置函数可以帮助你。让我们先看看 `range`，它提供一系列数字：你可以通过提供单个 `stop` 参数或提供 `start` 和 `stop` 参数（带有可选的 `step` 参数）来调用它。与切片一样，`start` 包含在内，`stop` 是排外的，`step` 决定步长，其中 `1` 是默认值：

> `range``(``stop``)``range``(``start``,``stop``,``step``)`

`range` 评估是懒惰的，这意味着如果不明确要求，你看不到它生成的序列：

> `In``[``90``]:``range``(``5``)`
> 
> `Out[90]: range(0, 5)`

将 range 转换为列表可以解决这个问题：

> `In``[``91``]:``list``(``range``(``5``))``# stop argument`
> 
> `Out[91]: [0, 1, 2, 3, 4]`
> 
> `In``[``92``]:``list``(``range``(``2``,``5``,``2``))``# start, stop, step arguments`
> 
> `Out[92]: [2, 4]`

大多数情况下，不需要用 `list` 包装 `range`：

> `In``[``93``]:``for``i``in``range``(``3``):``print``(``i``)`
> 
> `0 1 2`

如果你在遍历序列时需要一个计数器变量，请使用 `enumerate`。它返回一个 `(索引, 元素)` 元组序列。默认情况下，索引从零开始，逐一递增。你可以像这样在循环中使用 `enumerate`：

> `In``[``94``]:``for``i``,``currency``in``enumerate``(``currencies``):``print``(``i``,``currency``)`
> 
> `0 美元 1 港币 2 澳大利亚元`

遍历元组和集合的方式与列表相同。当你遍历字典时，Python 会遍历键：

> `In``[``95``]:``exchange_rates``=``{``"EURUSD"``:``1.1152``,``"GBPUSD"``:``1.2454``,``"AUDUSD"``:``0.6161``}``for``currency_pair``in``exchange_rates``:``print``(``currency_pair``)`
> 
> `EURUSD GBPUSD AUDUSD`

使用 `items` 方法，你可以同时获取键和值作为元组：

> `In``[``96``]:``for``currency_pair``,``exchange_rate``in``exchange_rates``.``items``():``print``(``currency_pair``,``exchange_rate``)`
> 
> `EURUSD 1.1152 GBPUSD 1.2454 AUDUSD 0.6161`

要退出循环，使用 `break` 语句：

> `In``[``97``]:``for``i``in``range``(``15``):``if``i``==``2``:``break``else``:``print``(``i``)`
> 
> `0 1`

你可以使用 `continue` 语句跳过循环的剩余部分，这意味着执行将继续新的循环和下一个元素：

> `In``[``98``]:``for``i``in``range``(``4``):``if``i``==``2``:``continue``else``:``print``(``i``)`
> 
> `0 1 3`

在比较 VBA 中的 for 循环与 Python 时，有一个微妙的区别：在 VBA 中，计数器变量在完成循环后会超出你的上限：

> `For``i``=``1``To``3``Debug``.``Print``i``Next``i``Debug``.``Print``i`

这会打印：

> `1 2 3 4`

在 Python 中，它的行为就像你可能期望的那样：

> `In``[``99``]:``for``i``in``range``(``1``,``4``):``print``(``i``)``print``(``i``)`
> 
> `1 2 3 3`

要遍历序列而不是使用 `for` 循环，你也可以使用 while 循环在满足某个条件时运行循环：

> `In``[``100``]:``n``=``0``while``n``<=``2``:``print``(``n``)``n``+=``1`
> 
> `0 1 2`
> 
> 增强赋值
> 
> 在上一个例子中，我使用了增强赋值符号：`n += 1`。这与您写`n = n + 1`是一样的。它也适用于我之前介绍的所有其他数学运算符；例如，减法您可以写`n -= 1`。

经常需要收集列表中的某些元素进行进一步处理。在这种情况下，Python 提供了一种替代循环的方式：列表、字典和集合推导式。

列表、字典和集合推导式

列表、字典和集合推导式技术上是创建相应数据结构的一种方式，但它们经常替代`for`循环，这就是我在这里介绍它们的原因。假设在以下USD货币对的列表中，您想挑选出USD作为第二个货币报价的那些货币。您可以写以下`for`循环：

> `In``[``101``]:``currency_pairs``=``[``"USDJPY"``,``"USDGBP"``,``"USDCHF"``,``"USDCAD"``,``"AUDUSD"``,``"NZDUSD"``]`
> 
> `In``[``102``]:``usd_quote``=``[]``for``pair``in``currency_pairs``:``if``pair``[``3``:]``==``"USD"``:``usd_quote``.``append``(``pair``[:``3``])``usd_quote`
> 
> `Out[102]: ['AUD', 'NZD']`

使用列表推导式通常更容易编写。列表推导式是创建列表的简洁方式。您可以从这个示例中获取其语法，它与前面的`for`循环做的事情是一样的：

> `In``[``103``]:``[``pair``[:``3``]``for``pair``in``currency_pairs``if``pair``[``3``:]``==``"USD"``]`
> 
> `Out[103]: ['AUD', 'NZD']`

如果没有任何条件需要满足，可以简单地省略`if`部分。例如，要颠倒所有货币对，使第一个货币变成第二个货币，反之亦然，可以这样做：

> `In``[``104``]:``[``pair``[``3``:]``+``pair``[:``3``]``for``pair``in``currency_pairs``]`
> 
> `Out[104]: ['JPYUSD', 'GBPUSD', 'CHFUSD', 'CADUSD', 'USDAUD', 'USDNZD']`

对于字典，还有字典推导式：

> `In``[``105``]:``exchange_rates``=``{``"EURUSD"``:``1.1152``,``"GBPUSD"``:``1.2454``,``"AUDUSD"``:``0.6161``}``{``k``:``v``*``100``for``(``k``,``v``)``in``exchange_rates``.``items``()}`
> 
> `Out[105]: {'EURUSD': 111.52, 'GBPUSD': 124.54, 'AUDUSD': 61.61}`

而对于集合，有集合推导式：

> `In``[``106``]:``{``s``+``"USD"``for``s``in``[``"EUR"``,``"GBP"``,``"EUR"``,``"HKD"``,``"HKD"``]}`
> 
> `Out[106]: {'EURUSD', 'GBPUSD', 'HKDUSD'}`

到目前为止，您已经能够编写简单的脚本，因为您已经了解了大多数Python的基本构建块。在下一节中，当您的脚本开始变得更大时，您将学习如何组织您的代码以保持可维护性。

代码组织

在本节中，我们将了解如何将代码组织成可维护的结构：我将首先介绍你通常需要的所有函数细节，然后展示如何将代码分割成不同的Python模块。关于模块的知识将使我们能够在本节结束时研究标准库中的`datetime`模块。

函数

即使你只会在Python中写简单脚本，你仍然会经常编写函数：它们是每种编程语言中最重要的结构之一，允许你从程序的任何地方重用相同的代码行。在我们看如何调用它之前，我们将在本节开始时定义一个函数！

定义函数

要在Python中编写自己的函数，你必须使用关键字`def`，它代表函数定义。与VBA不同，Python不区分函数和子程序。在Python中，子程序的等价物就是一个不返回任何东西的函数。Python中的函数遵循代码块的语法，即你用冒号结束第一行，然后缩进函数体：

> `def``function_name``(``required_argument``,``optional_argument``=``default_value``,``...``):``return``value1``,``value2``,``...`

必需参数

> > 必需参数没有默认值。多个参数用逗号分隔。

可选参数

> > 通过提供默认值来使参数可选。如果没有有意义的默认值，通常使用`None`来使参数可选。

返回值

> > `return`语句定义函数返回的值。如果省略它，函数将自动返回`None`。Python方便地允许你返回多个用逗号分隔的值。

为了能够操作一个函数，让我们定义一个能够将温度从华氏度或开尔文转换为摄氏度的函数：

> `In``[``107``]:``def``convert_to_celsius``(``degrees``,``source``=``"fahrenheit"``):``if``source``.``lower``()``==``"fahrenheit"``:``return``(``degrees``-``32``)``*``(``5``/``9``)``elif``source``.``lower``()``==``"kelvin"``:``return``degrees``-``273.15``else``:``return``f``"不知道如何从 {source} 转换"`

我使用了字符串方法`lower`，它将提供的字符串转换为小写。这允许我们接受带有任何大小写的`source`字符串，而比较仍然有效。有了`convert_to_celsius`函数的定义，让我们看看如何调用它！

调用函数

正如本章开头简要提到的，通过在函数名后面添加括号并包围函数参数来调用函数：

> `value1``,``value2``,``...``=``function_name``(``positional_arg``,``arg_name``=``value``,``...``)`

位置参数

> > 如果你把一个值作为位置参数（`positional_arg`）提供，这些值将根据它们在函数定义中的位置进行匹配。

关键字参数

> > 通过以`arg_name=value`的形式提供参数，您提供了一个关键字参数。这样做的好处是可以任意顺序提供参数。对于读者来说更加明确，有助于理解。例如，如果函数定义为`f(a, b)`，您可以像这样调用函数：`f(b=1, a=2)`。这个概念在VBA中也存在，您可以通过像这样调用函数来使用关键字参数：`f(b:=1, a:=1)`。

让我们玩转`convert_to_celsius`函数，看看实际操作中的运作方式：

> `In``[``108``]:``convert_to_celsius``(``100``,``"fahrenheit"``)``# 位置参数`
> 
> `Out[108]: 37.77777777777778`
> 
> `In``[``109``]:``convert_to_celsius``(``50``)``# 将使用默认来源（fahrenheit）`
> 
> `Out[109]: 10.0`
> 
> `In``[``110``]:``convert_to_celsius``(``source``=``"kelvin"``,``degrees``=``0``)``# 关键字参数`
> 
> `Out[110]: -273.15`

现在您已经知道如何定义和调用函数，让我们看看如何借助模块组织它们。

模块和导入语句

当您为更大的项目编写代码时，最终必须将其拆分为不同的文件，以便能够将其组织成可维护的结构。正如我们在前一章中已经看到的，Python文件的扩展名为`.py`，通常将主文件称为脚本。如果您现在希望您的主脚本能够访问其他文件中的功能，首先需要导入该功能。在此上下文中，Python源文件称为模块。要更好地了解其工作原理以及不同的导入选项，请查看伴随存储库中的文件temperature.py，并使用VS Code打开它（[示例 3-1](#filepos377335)）。如果您需要再次了解如何在VS Code中打开文件，请再次查看[第2章](index_split_008.html#filepos96824)。

示例 3-1\. temperature.py

`TEMPERATURE_SCALES``=``(``"fahrenheit"``,``"kelvin"``,``"celsius"``)``def``convert_to_celsius``(``degrees``,``source``=``"fahrenheit"``):``if``source``.``lower``()``==``"fahrenheit"``:``return``(``degrees``-``32``)``*``(``5``/``9``)``elif``source``.``lower``()``==``"kelvin"``:``return``degrees``-``273.15``else``:``return``f``"无法从 {source} 转换"``print``(``"这是温度模块。"``)`

要能够从您的Jupyter笔记本中导入`temperature`模块，您需要确保Jupyter笔记本和`temperature`模块在同一个目录中——就像伴随存储库的情况一样。要导入，只需使用模块的名称，不需要`.py`扩展名。运行`import`语句后，您将能够通过点符号访问该Python模块中的所有对象。例如，使用`temperature.convert_to_celsius()`执行您的转换操作：

> `In``[``111``]:``import``temperature
> 
> `这是温度模块。`
> 
> `In``[``112``]:``temperature``.``TEMPERATURE_SCALES`
> 
> `Out[112]: ('fahrenheit', 'kelvin', 'celsius')`
> 
> `In``[``113``]:` `temperature``.``convert_to_celsius``(``120``,``"fahrenheit"``)`
> 
> `Out[113]:` `48.88888888888889`

请注意，我在`TEMPERATURE_SCALES`中使用了大写字母来表示它是一个常量——我将在本章末尾进一步讨论这一点。当你执行带有`import temperature`的单元格时，Python将从上到下运行temperature.py文件。你可以很容易地看到这一点，因为导入模块将触发temperature.py底部的打印函数。

> 模块只被导入一次
> 
> 如果你再次运行`import temperature`单元格，你会注意到它不再打印任何东西。这是因为Python模块在会话中只被导入一次。如果你更改了导入模块中的代码，你需要重新启动Python解释器才能应用所有更改，即在Jupyter笔记本中，你需要点击Kernel > Restart。

实际上，通常你不会在模块中打印任何东西。这只是为了向你展示多次导入模块的效果。通常情况下，你会在模块中放置函数和类（有关类的更多信息，请参见[附录 C](index_split_031.html#filepos1832059)）。如果你不想每次使用`temperature`模块中的对象时都输入`temperature`，可以像这样更改`import`语句：

> `In``[``114``]:` `import``temperature``as``tp`
> 
> `In``[``115``]:` `tp``.``TEMPERATURE_SCALES`
> 
> `Out[115]:` (`fahrenheit`, `kelvin`, `celsius`)`

给你的模块分配一个短的别名`tp`可以使其在使用时更容易，但仍然清楚对象来自哪里。许多第三方包在使用别名时建议使用特定的约定。例如，pandas使用`import pandas as pd`。还有一种从另一个模块导入对象的选项：

> `In``[``116``]:` `from``temperature``import``TEMPERATURE_SCALES`,``convert_to_celsius`
> 
> `In``[``117``]:` `TEMPERATURE_SCALES`
> 
> `Out[117]:` (`fahrenheit`, `kelvin`, `celsius`)`
> 
> `__PYCACHE__`文件夹
> 
> 当你导入`temperature`模块时，你会发现Python创建了一个名为`__pycache__`的文件夹，其中的文件扩展名为`.pyc`。这些是Python解释器在导入模块时创建的字节编译文件。对于我们的目的，我们可以简单地忽略这个文件夹，因为这是Python运行代码的技术细节。

当使用`from x import y`语法时，你仅导入特定的对象。通过这样做，你将它们直接导入到你主脚本的命名空间中：也就是说，如果没有查看`import`语句，你无法知道导入的对象是在你当前的Python脚本还是Jupyter笔记本中定义的，还是来自另一个模块。这可能会导致冲突：如果你的主脚本有一个名为`convert_to_celsius`的函数，它会覆盖从`temperature`模块导入的函数。然而，如果你使用前面两种方法之一，你的本地函数和导入模块中的函数可以像`convert_to_celsius`和`temperature.convert_to_celsius`这样共存。

> 不要将脚本命名为现有的包名
> 
> 命名Python文件与现有的Python包或模块相同是常见的错误源。如果你创建一个文件来测试一些pandas功能，请不要将该文件命名为pandas.py，因为这可能会导致冲突。

现在你了解了导入机制的工作原理，让我们立即使用它来导入`datetime`模块！这也将使你能够学习关于对象和类的一些更多内容。

datetime类

在Excel中，处理日期和时间是一种常见的操作，但它带有一些限制：例如，Excel的时间单元格格式不支持比毫秒更小的单位，时间区域也完全不支持。在Excel中，日期和时间存储为称为日期序列号的简单浮点数。然后，Excel单元格被格式化为显示日期和/或时间。例如，1900年1月1日的日期序列号为1，这意味着这也是你可以在Excel中使用的最早日期。时间被转换为浮点数的小数部分，例如，`01/01/1900 10:10:00`被表示为`1.4236111111`。

在Python中，要处理日期和时间，你需要导入标准库中的`datetime`模块。`datetime`模块包含同名的类，允许我们创建`datetime`对象。由于模块和类的名称相同可能会导致混淆，我将在本书中使用以下导入约定：`import datetime as dt`。这样可以很容易区分模块（`dt`）和类（`datetime`）。

到目前为止，我们大部分时间都在使用字面值来创建列表或字典等对象。字面值是指Python识别为特定对象类型的语法—例如列表的情况下，这可能是像`[1, 2, 3]`这样的东西。然而，大多数对象必须通过调用它们的类来创建：这个过程称为实例化，因此对象也称为类实例。调用一个类的方式与调用函数的方式相同，即你需要在类名后加上括号，并以与我们在函数中所做的方式相同的方式提供参数。要实例化一个`datetime`对象，你需要像这样调用类：

> `import``datetime``as``dt``dt``.``datetime``(``year``,``month``,``day``,``hour``,``minute``,``second``,``microsecond``,``timezone``)`

让我们通过几个例子看看如何在 Python 中处理 `datetime` 对象。为了本次介绍的目的，让我们忽略时区并使用没有时区信息的 `datetime` 对象工作：

> `In``[``118``]:``# 将 datetime 模块导入为 "dt"``import``datetime``as``dt`
> 
> `In``[``119``]:``# 实例化一个名为 "timestamp" 的 datetime 对象``timestamp``=``dt``.``datetime``(``2020``,``1``,``31``,``14``,``30``)``timestamp`
> 
> `Out[119]: datetime.datetime(2020, 1, 31, 14, 30)`
> 
> `In``[``120``]:``# Datetime objects offer various attributes, e.g., to get the day``timestamp``.``day`
> 
> `Out[120]: 31`
> 
> `In``[``121``]:``# 两个 datetime 对象的差返回一个 timedelta 对象``timestamp``-``dt``.``datetime``(``2020``,``1``,``14``,``12``,``0``)`
> 
> `Out[121]: datetime.timedelta(days=17, seconds=9000)`
> 
> `In``[``122``]:``# 相应地，您还可以使用 timedelta 对象``timestamp``+``dt``.``timedelta``(``days``=``1``,``hours``=``4``,``minutes``=``11``)`
> 
> `Out[122]: datetime.datetime(2020, 2, 1, 18, 41)`

要将 `datetime` 对象格式化为字符串，请使用 `strftime` 方法；要解析字符串并将其转换为 `datetime` 对象，请使用 `strptime` 函数（您可以在 [datetime 文档](https://oreil.ly/gXOts) 中找到接受的格式代码的概述）：

> `In``[``123``]:``# 以特定方式格式化 datetime 对象``# 您也可以使用 f-string：f"{timestamp:%d/%m/%Y %H:%M}"``timestamp``.``strftime``(``"``%d``/``%m``/``%Y``%H``:``%M``"``)`
> 
> `Out[123]: '31/01/2020 14:30'`
> 
> `In``[``124``]:``# 将字符串解析为 datetime 对象``dt``.``datetime``.``strptime``(``"12.1.2020"``,``"``%d``.``%m``.``%Y``"``)`
> 
> `Out[124]: datetime.datetime(2020, 1, 12, 0, 0)`

在这个对 `datetime` 模块的简短介绍之后，让我们继续本章的最后一个主题，即如何正确格式化代码。

PEP 8：Python 代码风格指南

也许你一直在想，为什么有时我会用带有下划线或全大写的变量名。这一节将通过介绍 Python 的官方风格指南来解释我的格式选择。Python 使用所谓的 Python Enhancement Proposals（PEP）来讨论引入新语言特性。其中之一，Python 代码风格指南通常用其编号来指代：PEP 8\. PEP 8 是 Python 社区的一套风格建议；如果所有在同一代码上工作的人都遵循相同的风格指南，代码会变得更加可读。在开源世界尤为重要，因为许多程序员在同一项目上工作，通常彼此并不认识。[Example 3-2](#filepos410016) 展示了一个简短的 Python 文件，介绍了最重要的惯例。

Example 3-2\. pep8_sample.py

`"""这个脚本展示了一些 PEP 8 规则。` ![](images/00031.jpg) `"""``import``datetime``as``dt`![](images/00039.jpg)`TEMPERATURE_SCALES``=``(``"fahrenheit"``,``"kelvin"``,``"celsius"``)`![](images/00050.jpg)![](images/00067.jpg)`class``TemperatureConverter``:`![](images/00058.jpg)`pass``# 目前什么也不做` ![](images/00082.jpg)`def``convert_to_celsius``(``degrees``,``source``=``"fahrenheit"``):`![](images/00076.jpg)`"""这个函数将华氏度或开尔文转换为摄氏度。` ![](images/00007.jpg) `"""``if``source``.``lower``()``==``"fahrenheit"``:`![](images/00015.jpg)`return``(``degrees``-``32``)``*``(``5``/``9``)`![](images/00020.jpg)`elif``source``.``lower``()``==``"kelvin"``:``return``degrees``-``273.15``else``:``return``f``"不知道如何从 {source} 转换"`celsius``=``convert_to_celsius``(``44``,``source``=``"fahrenheit"``)`![](images/00025.jpg)`non_celsius_scales``=``TEMPERATURE_SCALES``[:``-``1``]`![](images/00034.jpg)`print``(``"当前时间： "``+``dt``.``datetime``.``now``()``.``isoformat``())``print``(``f``"摄氏度温度为： {celsius}"``)`

![](images/00031.jpg)

> > 使用顶部的文档字符串解释脚本/模块的功能。文档字符串是一种特殊类型的字符串，用三个引号括起来。除了作为代码文档的字符串外，文档字符串还使得可以轻松地编写多行字符串，特别是在文本包含大量双引号或单引号时，不需要转义它们。如果您的文本包含大量的多行 SQL 查询，文档字符串非常有用，正如我们将在 [第 11 章](index_split_027.html#filepos1487255) 中看到的。

![](images/00039.jpg)

> > 所有导入语句都位于文件顶部，每行一个。首先列出标准库的导入，然后是第三方包的导入，最后是自己模块的导入。本示例仅使用标准库。

![](images/00050.jpg)

> > 使用大写字母和下划线表示常量。每行最大长度为 79 个字符。如果可能，利用括号、方括号或大括号进行隐式换行。

![](images/00067.jpg)

> > 将类和函数与代码其余部分用两个空行分开。

![](images/00058.jpg)

> > 尽管像 `datetime` 这样的许多类都是小写的，但您自己的类应使用 `CapitalizedWords` 作为名称。有关类的更多信息，请参阅 [附录 C](index_split_031.html#filepos1832059)。

![](images/00082.jpg)

> > 行内注释应与代码至少用两个空格分开。代码块应缩进四个空格。

![](images/00076.jpg)

> > 函数和函数参数应使用小写名称，并在提高可读性时使用下划线。不要在参数名和其默认值之间使用空格。

![](images/00007.jpg)

> > 函数的文档字符串还应列出并解释函数参数。为了使示例简短，我没有在此处执行此操作，但在伴随存储库中包含的 excel.py 文件中，您将找到完整的文档字符串，并且我们将在[第 8 章](index_split_020.html#filepos959867)中遇到它。

![](images/00015.jpg)

> > 在冒号周围不要使用空格。

![](images/00020.jpg)

> > 在数学运算符周围使用空格。如果使用不同优先级的运算符，可以考虑只在优先级最低的运算符周围添加空格。因为本例中的乘法优先级最低，所以我已经在其周围添加了空格。

![](images/00025.jpg)

> > 对变量使用小写名称。如果使用下划线可以提高可读性，则使用下划线。在赋值变量名时，使用等号周围的空格。但是，在调用带有关键字参数的函数时，不要在等号周围使用空格。

![](images/00034.jpg)

> > 在索引和切片时，不要在方括号周围使用空格。

这是对 PEP 8 的简化总结，因此当你开始更认真地学习 Python 时，建议查看原始的 [PEP 8](https://oreil.ly/3fTTZ)。PEP 8 明确指出它是一种推荐，并且你自己的风格指南将优先。毕竟，一致性是最重要的因素。如果你对其他公开可用的指南感兴趣，可以看一下 [Google 的 Python 风格指南](https://oreil.ly/6sYSa)，它与 PEP 8 非常接近。在实践中，大多数 Python 程序员宽松遵守 PEP 8，而忽略最大行长度 79 字符可能是最常见的错误。

由于在编写代码时可能难以正确格式化代码，因此可以自动检查代码风格。下一节将向您展示如何在 VS Code 中进行此操作。

PEP 8 和 VS Code

当使用 VS Code 时，确保你的代码符合 PEP 8 的一种简单方法是使用代码检查工具（linter）。代码检查工具会检查你的源代码是否存在语法和风格错误。在命令面板中启动（Windows 上为 Ctrl+Shift+P，macOS 上为 Command-Shift-P），搜索 Python: Select Linter。一个常用的选项是 flake8，这是 Anaconda 预装的一个包。如果启用了代码检查工具，在保存文件时，VS Code 会用波浪线下划线标出问题。将鼠标悬停在波浪线下划线上时，会显示工具提示来解释问题。你可以通过在命令面板中搜索 “Python: Enable Linting”，选择 “Disable Linting” 来关闭代码检查工具。如果你愿意，也可以在 Anaconda Prompt 上运行 `flake8` 命令以获取打印的报告（该命令仅在违反 PEP 8 规范时才会打印输出，因此在 pep8_sample.py 上运行时除非引入违规，否则不会打印任何内容）：

> `(base)>` `cd C:\Users\``username``\python-for-excel` `(base)>` `flake8 pep8_sample.py`

Python最近通过添加对类型提示的支持，将静态代码分析推进了一步。接下来的部分将解释它们是如何工作的。

类型提示

在VBA中，你经常会看到每个变量都用数据类型的缩写作为前缀，比如`strEmployeeName`或`wbWorkbookName`。虽然在Python中没有人会阻止你这样做，但这并不常见。你也不会找到类似于VBA的`Option Explicit`或`Dim`语句来声明变量的类型。相反，Python 3.5引入了一种称为类型提示的功能。类型提示也被称为类型注解，允许你声明变量的数据类型。它们是完全可选的，并不影响Python解释器运行代码的方式（不过，有第三方包如[pydantic](https://oreil.ly/J9W8h)可以在运行时强制执行类型提示）。类型提示的主要目的是允许像VS Code这样的文本编辑器在运行代码之前捕捉更多的错误，而且还可以改善VS Code和其他编辑器的代码自动完成功能。用于类型注解代码的最流行类型检查器是mypy，它作为VS Code的一个代码检查工具提供。为了感受类型注解在Python中的工作原理，这里有一个短小的示例，没有类型提示：

> `x``=``1``def``hello``(``name``):``return``f``"Hello {name}!"`

再次来看类型提示：

> `x``:``int``=``1``def``hello``(``name``:``str``)``->``str``:``return``f``"Hello {name}!"`

类型提示通常在更大的代码库中更有意义，因此在本书的剩余部分我将不会使用它们。

结论

本章是对Python的一个紧凑介绍。我们了解了语言的最重要的构建块，包括数据结构、函数和模块。我们还触及了Python的一些特殊之处，如有意义的空白和代码格式化准则，更为人熟知的是PEP 8。作为初学者，为了继续学习这本书，你不需要了解所有细节：只需了解列表和字典、索引和切片，以及如何使用函数、模块、`for`循环和`if`语句就可以走得很远。

与VBA相比，我发现Python更一致和更强大，但同时也更容易学习。如果你是VBA的铁杆粉丝，并且这一章还没能说服你，那么下一部分肯定会：在那里，我将为你介绍基于数组的计算，在我们开始使用pandas库进行数据分析之前。让我们通过学习关于NumPy的一些基础知识来开始[第二部分](index_split_013.html#filepos433190)！
