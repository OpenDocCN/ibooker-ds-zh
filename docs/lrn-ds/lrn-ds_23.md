# 第18章：案例研究：如何称量一只驴

驴子在肯尼亚农村扮演着重要角色。人们需要它们来运输作物、水和人，以及耕种田地。当一只驴子生病时，兽医需要知道它的体重以便开对量的药物。但是在肯尼亚农村，许多兽医没有称重器，因此他们需要猜测驴子的体重。药物用量过少可能会导致感染再次发作；药物过多则可能导致有害的过量。肯尼亚有超过180万头驴子，因此估算驴子体重的方法简单而准确非常重要。

在这个案例研究中，我们追随[凯特·米尔纳和乔纳森·鲁吉尔](https://doi.org/10.1111/j.1740-9713.2014.00768.x) 的工作，创建一个模型，供肯尼亚农村的兽医使用，以准确估计驴子的体重。像往常一样，我们遵循数据科学生命周期的步骤，但这次我们的工作偏离了这本书迄今为止涵盖的基础知识。您可以把这个案例研究看作是反思许多数据处理核心原则的机会，并理解如何扩展这些原则以应对具体情况。我们直接评估测量误差的来源，设计一个反映对过量用药关注的特殊损失函数，构建一个以适用性为重点的模型，并使用相对于驴子大小的特殊标准评估模型预测。

我们从数据的范围开始。

# 驴子研究问题与范围

我们的动力问题是：在没有称重器的情况下，兽医如何准确估算驴子的体重？让我们考虑一下他们更容易得到的信息。他们可以携带卷尺，并找出驴子在其他尺寸上的大小，比如它的高度。他们可以观察动物的性别，评估其一般状态，并询问驴子的年龄。因此，我们可以将我们的问题进一步细化为：兽医如何从易于获取的测量数据中准确预测驴子的体重？

为了解决这个更精确的问题，[驴避难所](https://oreil.ly/uUyZj) 在肯尼亚农村的17个移动驱虫点进行了研究。

在范围方面（[第2章](ch02.html#ch-data-scope)），目标人群是肯尼亚农村的驴群。访问框架是所有被带到驱虫点的驴子。样本包括2010年7月23日至8月11日被带到这些点的所有驴子，但有一些注意事项：如果在一个地点有太多的驴子需要测量，科学家们会选择一部分来测量，并且任何怀孕或明显生病的驴子都被排除在研究之外。

为了避免不小心对同一只驴进行两次称重，每只驴在称重后都会标记。为了量化测量误差并评估称重过程的重复性，我们对31只驴进行了两次测量，而工作人员并不知道这是一只已经被重新称重的驴。

考虑到这一抽样过程，此数据的潜在偏差源包括：

覆盖偏差

这17个地点位于肯尼亚东部雅塔区和大裂谷内纳瓦沙区周围的地区。

选择偏差

只有被送往庇护所的驴才能参加这项研究，当一个地点有太多的驴时，会选择一个非随机样本。

测量偏差

除了测量误差外，称可能存在偏差。理想情况下，在使用场地之前和之后，天平应该校准（[第12章](ch12.html#ch-pa)）。

尽管存在这些潜在的偏差源，但从肯尼亚农村地区拥有关心动物健康的主人那里获取驴的访问框架似乎是合理的。

我们的下一步是清理数据。

# 数据整理和转换

我们首先看一下数据文件的内容。为此，我们打开文件并检查前几行（[第8章](ch08.html#ch-files)）：

```py
`from` `pathlib` `import` `Path`

`# Create a Path pointing to our datafile`
`insp_path` `=` `Path``(``'``data/donkeys.csv``'``)`

`with` `insp_path``.``open``(``)` `as` `f``:`
    `# Display first five lines of file`
    `for` `_` `in` `range``(``5``)``:`
        `print``(``f``.``readline``(``)``,` `end``=``'``'``)`

```

```py
BCS,Age,Sex,Length,Girth,Height,Weight,WeightAlt
3,<2,stallion,78,90,90,77,NA
2.5,<2,stallion,91,97,94,100,NA
1.5,<2,stallion,74,93,95,74,NA
3,<2,female,87,109,96,116,NA

```

由于文件是CSV格式的，我们可以轻松地将其读入数据框架：

```py
`donkeys` `=` `pd``.``read_csv``(``"``data/donkeys.csv``"``)`
`donkeys`

```

|   | BCS | 年龄 | 性别 | 长度 | 胸围 | 身高 | 体重 | WeightAlt |
| --- | --- | --- | --- | --- | --- | --- | --- | --- |
| **0** | 3.0 | <2 | 种马 | 78 | 90 | 90 | 77 | NaN |
| **1** | 2.5 | <2 | 种马 | 91 | 97 | 94 | 100 | NaN |
| **2** | 1.5 | <2 | 种马 | 74 | 93 | 95 | 74 | NaN |
| **...** | ... | ... | ... | ... | ... | ... | ... | ... |
| **541** | 2.5 | 10-15 | 种马 | 103 | 118 | 103 | 174 | NaN |
| **542** | 3.0 | 2-5 | 种马 | 91 | 112 | 100 | 139 | NaN |
| **543** | 3.0 | 5-10 | 种马 | 104 | 124 | 110 | 189 | NaN |

```py
544 rows × 8 columns
```

超过五百只驴参与了调查，每只驴进行了八次测量。根据文档，粒度是单个驴（[第9章](ch09.html#ch-wrangling)）。[表18-1](#tbl-donkey-codebook)提供了这八个特征的描述。

表18-1\. 驴研究代码手册

| 特征 | 数据类型 | 特征类型 | 描述 |
| --- | --- | --- | --- |
| BCS | float64 | 有序 | 身体条件评分：从1（消瘦）到3（健康）到5（肥胖），每0.5单位增加。 |
| 年龄 | string | 有序 | 年龄（年），小于2岁、2-5岁、5-10岁、10-15岁、15-20岁和20岁以上 |
| 性别 | string | 名义 | 性别类别：种马、阉马、母驴 |
| 长度 | int64 | 数值 | 体长（厘米），从前腿肘到骨盆后部 |
| 胸围 | int64 | 数值 | 身体围长（厘米），在前腿后面测量 |
| 身高 | int64 | 数值 | 身体高度（厘米），到颈部连接背部的点 |
| 体重 | int64 | 数值 | 体重（千克） |
| WeightAlt | float64 | 数值 | 在一部分驴身上进行的第二次称重测量 |

[图18-1](#fig-donkeydiagram)是将驴子理想化为带有颈部和附加的腿的圆柱体的图示。身高是从地面到肩膀上方的颈部底部的测量；胸围是围绕身体，就在后腿后面；长度是从前肘到骨盆后部。

![](assets/leds_1801.png)

###### 图18-1。驴的胸围、长度和高度的图示，被描述为对圆柱体上的测量

我们的下一步是对数据进行一些质量检查。在上一节中，我们基于范围列出了一些潜在的质量问题。接下来，我们检查测量和它们的分布的质量。

让我们首先比较对一小部分驴子进行的两次体重测量，以检查秤的一致性。我们为这31只被称重两次的驴子制作了这两个测量值之间的差异的直方图：

```py
`donkeys` `=` `donkeys``.``assign``(``difference``=``donkeys``[``"``WeightAlt``"``]` `-` `donkeys``[``"``Weight``"``]``)`

`px``.``histogram``(``donkeys``,` `x``=``"``difference``"``,` `nbins``=``15``,`
    `labels``=``dict``(`
        `difference``=``"``Differences of two weighings (kg)<br>on the same donkey``"`
    `)``,`
    `width``=``350``,` `height``=``250``,`
`)`

```

![](assets/leds_18in01.png)

这些测量值彼此之间都在1公斤以内，大部分都是完全相同的（四舍五入到最接近的公斤）。这让我们对测量的准确性有信心。

接下来，我们寻找体况评分中的异常值：

```py
`donkeys``[``'``BCS``'``]``.``value_counts``(``)`

```

```py
BCS
3.0    307
2.5    135
3.5     55
      ... 
1.5      5
4.5      1
1.0      1
Name: count, Length: 8, dtype: int64

```

从这个输出中，我们看到只有一个消瘦的（BCS = 1）和一个肥胖的（BCS = 4.5）驴子。让我们看看这两只驴子的完整记录：

```py
`donkeys``[``(``donkeys``[``'``BCS``'``]` `==` `1.0``)` `|` `(``donkeys``[``'``BCS``'``]` `==` `4.5``)``]`

```

|   | BCS | 年龄 | 性别 | 长度 | 胸围 | 身高 | 体重 | 体重备用 |
| --- | --- | --- | --- | --- | --- | --- | --- | --- |
| **291** | 4.5 | 10-15 | 女性 | 107 | 130 | 106 | 227 | NaN |
| **445** | 1.0 | >20 | 女性 | 97 | 109 | 102 | 115 | NaN |

由于这些BCS值非常极端，我们要谨慎考虑将这两只驴子纳入我们的分析范围。在这两个极端类别中，我们每个类别只有一只驴子，因此我们的模型可能无法延伸到BCS为1或4.5的驴子。我们将这两条记录从数据框中删除，并注意到我们的分析可能不适用于消瘦或肥胖的驴子。总的来说，我们在删除数据框中的记录时要小心。稍后，如果这五只BCS为1.5的驴子在我们的分析中看起来不正常，我们也可能决定将它们删除，但目前，我们将它们保留在我们的数据框中。一般来说，我们需要一个充分的理由来排除数据，并且我们应该记录这些操作，因为它们可能会影响我们的发现。如果我们删除与模型不符的任何记录，可能会导致过度拟合。

我们接下来删除这两个异常值：

```py
`def` `remove_bcs_outliers``(``donkeys``)``:`
    `return` `donkeys``[``(``donkeys``[``'``BCS``'``]` `>``=` `1.5``)` `&` `(``donkeys``[``'``BCS``'``]` `<``=` `4``)``]` 

`donkeys` `=` `(``pd``.``read_csv``(``'``data/donkeys.csv``'``)`
           `.``pipe``(``remove_bcs_outliers``)``)`

```

现在，我们检查体重值的分布，以查看是否存在任何质量问题：

```py
`px``.``histogram``(``donkeys``,` `x``=``'``Weight``'``,` `nbins``=``40``,` `width``=``350``,` `height``=``250``,`
            `labels``=``{``'``Weight``'``:``'``Weight (kg)``'``}``)`

```

![](assets/leds_18in02.png)

看起来有一只非常轻的驴子，体重不到30公斤。接下来，我们检查体重和身高之间的关系，以评估用于分析的数据质量。

```py
`px``.``scatter``(``donkeys``,` `x``=``'``Height``'``,` `y``=``'``Weight``'``,` `width``=``350``,` `height``=``250``,`
          `labels``=``{``'``Weight``'``:``'``Weight (kg)``'``,` `'``Height``'``:``'``Height (cm)``'``}``)`

```

![](assets/leds_18in03.png)

小驴离主要驴群较远，会对我们的模型产生过大影响，因此我们将其排除。同样，我们要注意，如果有一两匹重驴对我们未来的模型拟合产生过大影响，我们也可能要将它们排除：

```py
`def` `remove_weight_outliers``(``donkeys``)``:`
    `return` `donkeys``[``(``donkeys``[``'``Weight``'``]` `>``=` `40``)``]`

`donkeys` `=` `(``pd``.``read_csv``(``'``data/donkeys.csv``'``)`
           `.``pipe``(``remove_bcs_outliers``)`
           `.``pipe``(``remove_weight_outliers``)``)`

`donkeys``.``shape`

```

```py
(541, 8)

```

总之，根据我们的清理和质量检查，我们从数据框中删除了三个异常观测。现在我们几乎可以开始我们的探索性分析了。在继续之前，我们将一些数据设置为测试集。

我们讨论了在[第16章](ch16.html#ch-risk)中将测试集与训练集分开的重要性。最佳实践是在分析早期就将测试集分开，这样我们在详细探索数据之前就开始做出关于适合哪种模型以及在模型中使用哪些变量的决定。很重要的一点是，我们的测试集不参与这些决策，以便模拟我们的模型在全新数据上的表现。

我们将数据分成80/20的比例，其中80%用于探索和建模。然后，我们用设置的20%来评估模型。我们使用简单随机抽样将数据框分为测试集和训练集。首先，我们随机打乱数据框的索引：

```py
`np``.``random``.``seed``(``42``)`
`n` `=` `len``(``donkeys``)`
`indices` `=` `np``.``arange``(``n``)`
`np``.``random``.``shuffle``(``indices``)`
`n_train` `=` `int``(``np``.``round``(``(``0.8` `*` `n``)``)``)`

```

接下来，我们将数据框的前80%分配给训练集，剩余的20%分配给测试集：

```py
`train_set` `=` `donkeys``.``iloc``[``indices``[``:``n_train``]``]`
`test_set` `=` `donkeys``.``iloc``[``indices``[``n_train``:``]``]`

```

现在我们准备探索训练数据，寻找有用的关系和分布，为我们的建模提供信息。

# 探索中

我们查看数据框中的形状和关系特征，以便进行转换和模型制作（[第10章](ch10.html#ch-eda)）。我们首先看看年龄、性别和体况这些分类特征如何与体重相关联：

```py
`f1` `=` `px``.``box``(``train_set``,` `x``=``"``Age``"``,` `y``=``"``Weight``"``,` 
            `category_orders` `=` `{``"``Age``"``:``[``'``<2``'``,` `'``2-5``'``,` `'``5-10``'``,` 
                                      `'``10-15``'``,` `'``15-20``'``,` `'``>20``'``]``}``)`
`f2` `=` `px``.``box``(``train_set``,` `x``=``"``Sex``"``,` `y``=``"``Weight``"``)`

`# We wrote the left_right function as a shorthand for plotly's make_subplots`
`fig` `=` `left_right``(``f1``,` `f2``,` `column_widths``=``[``0.7``,` `0.3``]``)`

`fig``.``update_xaxes``(``title``=``'``Age (yr)``'``,` `row``=``1``,` `col``=``1``)`
`fig``.``update_xaxes``(``title``=``'``Sex``'``,` `row``=``1``,` `col``=``2``)`
`fig``.``update_yaxes``(``title``=``'``Weight (kg)``'``,` `row``=``1``,` `col``=``1``)`

```

![](assets/leds_18in04.png)

```py
`fig` `=` `px``.``box``(``train_set``,` `x``=``"``BCS``"``,` `y``=``"``Weight``"``,` `points``=``"``all``"``,`
             `labels``=``{``'``Weight``'``:``'``Weight (kg)``'``,` `'``BCS``'``:``'``Body condition score``'``}``,`
             `width``=``550``,` `height``=``250``)`
`fig`

```

![](assets/leds_18in05.png)

注意，我们绘制了身体状况评分的点和箱线图，因为我们之前看到评分为1.5的观测值只有少数几个，所以我们不希望过多解读仅有少量数据点的箱线图（[第11章](ch11.html#ch-viz)）。看起来，体重中位数随着体况评分增加而增加，但增长并非简单线性。另一方面，三种性别类别的体重分布看起来大致相同。至于年龄，一旦一匹驴达到五岁，其体重分布似乎不会有太大变化。但两岁以下的驴和两至五岁的驴的体重普遍较低。

接下来，让我们检查定量变量。我们在散点图矩阵中绘制所有定量变量的成对关系：

![](assets/leds_18in06.png)

骡子的身高、长度和腰围都与体重以及彼此之间线性相关。这并不太令人惊讶；只要知道骡子的一个维度，我们就可以大致猜测其他维度。腰围与体重的相关性最高，这在相关系数矩阵中得到了验证：

```py
`train_numeric``.``corr``(``)`

```

|   | 权重 | 长度 | 腰围 | 身高 |
| --- | --- | --- | --- | --- |
| **体重** | 1.00 | 0.78 | 0.90 | 0.71 |
| **长度** | 0.78 | 1.00 | 0.66 | 0.58 |
| **腰围** | 0.90 | 0.66 | 1.00 | 0.70 |
| **身高** | 0.71 | 0.58 | 0.70 | 1.00 |

我们的探索揭示了数据的几个可能与建模相关的方面。我们发现骡子的腰围、长度和身高都与体重以及彼此之间线性相关，腰围与体重的线性关系最强。我们还观察到，体况评分与体重呈正相关；骡子的性别似乎与体重无关；对于5岁以上的骡子，年龄也与体重无关。在下一节中，我们将利用这些发现来构建我们的模型。

# 模拟骡子的体重

我们想建立一个简单的模型来预测骡子的体重。这个模型应该易于兽医在现场仅使用手算器时实现。模型也应该易于解释。

我们还希望模型能够依赖于兽医的情况——例如，他们是否正在开具抗生素或麻醉药。为了简洁起见，我们只考虑开具麻醉药的情况。我们第一步是选择一个反映这种情况的损失函数。

## 麻醉药开具的损失函数

麻醉药的过量可能比不足更糟。兽医很容易看出骡子麻醉药不足（它会抱怨），并且兽医可以给骡子再多点。但另一方面，麻醉药过多可能会有严重后果，甚至可能致命。因此，我们需要一个非对称的损失函数：对于体重的过高估计，它的损失应该大于对低估的损失。这与我们到目前为止在本书中使用的其他所有损失函数不同，它们都是对称的。

为了这个目的，我们创建了一个损失函数 `anes_loss(x)`：

```py
`def` `anes_loss``(``x``)``:`
    `w` `=` `(``x` `>``=` `0``)` `+` `3` `*` `(``x` `<` `0``)`
    `return` `np``.``square``(``x``)` `*` `w`

```

相对误差为 <math><mn>100</mn> <mo stretchy="false">(</mo> <mi>y</mi> <mo>−</mo> <mrow><mover><mi>y</mi> <mo stretchy="false">^</mo></mover></mrow> <mo stretchy="false">)</mo> <mrow><mo>/</mo></mrow> <mrow><mover><mi>y</mi> <mo stretchy="false">^</mo></mover></mrow></math> ，其中 <math><mi>y</mi></math> 为真实值，<math><mrow><mover><mi>y</mi> <mo stretchy="false">^</mo></mrow></math> 为预测值。我们可以通过一个图示来展示损失函数的非对称性：

![](assets/leds_18in07.png)

请注意，x轴上值为-10反映了10%的过高估计。

接下来，让我们使用这个损失函数拟合一个简单   接下来，让我们使用这个损失函数拟合一个简单的线性模型。

## 拟合一个简单的线性模型

我们发现，腰围在我们的训练集中与体重的相关性最高。所以我们拟合了一个形式为的模型：

<math display="block"><msub><mi>θ</mi> <mn>0</mn></msub> <mo>+</mo> <msub><mi>θ</mi> <mn>1</mn></msub> <mtext>Girth</mtext></math>

要找到数据的最佳拟合<math><msub><mi>θ</mi> <mn>0</mn></msub></math>和<math><msub><mi>θ</mi> <mn>1</mn></msub></math>，我们首先创建一个具有腰围和截距项的设计矩阵。我们还创建了观察到的驴子体重的<math><mi>y</mi></math>向量：

```py
`X` `=` `train_set``.``assign``(``intr``=``1``)``[``[``'``intr``'``,` `'``Girth``'``]``]`
`y` `=` `train_set``[``'``Weight``'``]`
`X`

```

|   | intr | Girth |
| --- | --- | --- |
| **230** | 1 | 116 |
| **74** | 1 | 117 |
| **354** | 1 | 123 |
| **...** | ... | ... |
| **157** | 1 | 123 |
| **41** | 1 | 103 |
| **381** | 1 | 106 |

```py
433 rows × 2 columns
```

现在我们想要找到最小化数据上平均麻醉损失的<math><msub><mi>θ</mi> <mn>0</mn></msub></math>和<math><msub><mi>θ</mi> <mn>1</mn></msub></math>。为此，我们可以像在[第15章](ch15.html#ch-linear)中一样使用微积分，但在这里我们将使用`scipy`包中的`minimize`方法，该方法执行数值优化（见[第20章](ch20.html#ch-gd)）：

```py
`from` `scipy``.``optimize` `import` `minimize`

`def` `training_loss``(``X``,` `y``)``:`
    `def` `loss``(``theta``)``:`
        `predicted` `=` `X` `@` `theta`
        `return` `np``.``mean``(``anes_loss``(``100` `*` `(``y` `-` `predicted``)` `/` `predicted``)``)`
    `return` `loss`

`results` `=` `minimize``(``training_loss``(``X``,` `y``)``,` `np``.``ones``(``2``)``)`
`theta_hat` `=` `results``[``'``x``'``]`

```

```py
After fitting:
θ₀ = -218.51
θ₁ =    3.16

```

让我们看看这个简单模型的效果如何。我们可以使用模型来预测训练集上的驴子体重，然后找到预测中的误差。接下来的残差图显示了模型误差占预测值的百分比。相对于驴子的大小来说，预测误差较小更为重要，因为对于100公斤的驴子来说，10公斤的误差比对于200公斤的驴子来说要糟糕得多。因此，我们计算每个预测的相对误差：

```py
predicted = X @ theta_hat
resids = 100 * (y - predicted) / predicted

```

让我们来检查一下相对误差的散点图：

```py
resid = pd.DataFrame({
    'Predicted weight (kg)': predicted, 'Percent error': resids})
px.scatter(resid, x='Predicted weight (kg)', y='Percent error',
           width=350, height=250)

```

![](assets/leds_18in08.png)

使用最简单的模型，一些预测偏差达到了20%至30%。让我们看看稍微复杂一点的模型是否改善了预测。

## 拟合多元线性模型

让我们考虑进一步的模型，将其他数字变量纳入考虑。我们有三个数字变量来衡量驴子的腰围、长度和高度，有七种组合这些变量的模型：

```py
[['Girth'],
 ['Length'],
 ['Height'],
 ['Girth', 'Length'],
 ['Girth', 'Height'],
 ['Length', 'Height'],
 ['Girth', 'Length', 'Height']]

```

对于这些变量组合中的每一个，我们可以使用我们的特殊损失函数来拟合一个模型。然后我们可以查看每个模型在训练集上的表现：

```py
`def` `training_error``(``model``)``:`
    `X` `=` `train_set``.``assign``(``intr``=``1``)``[``[``'``intr``'``,` `*``model``]``]`
    `theta_hat` `=` `minimize``(``training_loss``(``X``,` `y``)``,` `np``.``ones``(``X``.``shape``[``1``]``)``)``[``'``x``'``]`
    `predicted` `=` `X` `@` `theta_hat`
    `return` `np``.``mean``(``anes_loss``(``100` `*` `(``y` `-` `predicted``)``/` `predicted``)``)`

`model_risks` `=` `[`
    `training_error``(``model``)`
    `for` `model` `in` `models`
`]`

```

|   | model | mean_training_error |
| --- | --- | --- |
| **0** | [Girth] | 94.36 |
| **1** | [Length] | 200.55 |
| **2** | [Height] | 268.88 |
| **3** | [Girth, Length] | 65.65 |
| **4** | [Girth, Height] | 86.18 |
| **5** | [Length, Height] | 151.15 |
| **6** | [Girth, Length, Height] | 63.44 |

正如我们之前所述，驴子的腰围是体重的最佳单一预测因子。然而，腰围和长度的组合的平均损失要比仅有腰围的损失要小得多，而且这个特定的双变量模型几乎和包含所有三个变量的模型一样好。由于我们想要一个简单的模型，我们选择了双变量模型而不是三变量模型。

接下来，我们使用特征工程将分类变量纳入模型中，这将改善我们的模型。

## 将定性特征纳入模型

在我们的探索性分析中，我们发现驴体条件和年龄的箱线图可能包含有助于预测体重的信息。由于这些是分类特征，我们可以将它们转换为0-1变量，采用独热编码，如[第15章](ch15.html#ch-linear)所述。

独热编码允许我们调整模型中每个类别组合的截距项。我们当前的模型包括数值变量周长和长度：

<math display="block"><msub><mi>θ</mi> <mn>0</mn></msub> <mo>+</mo> <msub><mi>θ</mi> <mn>1</mn></msub> <mtext>Girth</mtext> <mo>+</mo> <msub><mi>θ</mi> <mn>2</mn></msub> <mtext>Length</mtext></math>

如果我们将年龄特征清理为三个类别——`年龄<2`、`年龄2-5`和`年龄>5`——年龄的独热编码将创建三个0-1特征，每个类别一个。将独热编码特征包括在模型中得到：

<math display="block"><mtable columnalign="right" columnspacing="0em" displaystyle="true" rowspacing="3pt"><mtr><mtd><mtable columnalign="right left" columnspacing="0em" displaystyle="true" rowspacing="3pt"><mtr><mtd><msub><mi>θ</mi> <mn>0</mn></msub></mtd> <mtd><mo>+</mo> <msub><mi>θ</mi> <mn>1</mn></msub> <mtext>Girth </mtext> <mo>+</mo> <msub><mi>θ</mi> <mn>2</mn></msub> <mtext>Length </mtext></mtd></mtr> <mtr><mtd><mo>+</mo> <msub><mi>θ</mi> <mn>3</mn></msub> <mtext>Age<2 </mtext> <mo>+</mo> <msub><mi>θ</mi> <mn>4</mn></msub> <mtext>Age2-5 </mtext></mtd></mtr></mtable></mtd></mtr></mtable></math>

在这个模型中，`年龄<2`表示小于2岁的驴为1，否则为0。类似地，`年龄2-5`表示2至5岁的驴为1，否则为0。

我们可以将这个模型看作适合三个相同的线性模型，唯一不同的是常数的大小，因为该模型等同于：

<math display="block"><mtable columnalign="right" columnspacing="0em" displaystyle="true" rowspacing="3pt"><mtr><mtd><mtable columnalign="right left" columnspacing="0em" displaystyle="true" rowspacing="3pt"><mtr><mtd><mo stretchy="false">(</mo> <msub><mi>θ</mi> <mn>0</mn></msub> <mo>+</mo> <msub><mi>θ</mi> <mn>3</mn></msub> <mo stretchy="false">)</mo> <mo>+</mo> <msub><mi>θ</mi> <mn>1</mn></msub> <mtext>Girth</mtext> <mo>+</mo> <msub><mi>θ</mi> <mn>2</mn></msub> <mtext>Length</mtext></mtd> <mtd><mtext>for a donkey under 2</mtext></mtd></mtr> <mtr><mtd><mo stretchy="false">(</mo> <msub><mi>θ</mi> <mn>0</mn></msub> <mo>+</mo> <msub><mi>θ</mi> <mn>4</mn></msub> <mo stretchy="false">)</mo> <mo>+</mo> <msub><mi>θ</mi> <mn>1</mn></msub> <mtext>Girth</mtext> <mo>+</mo> <msub><mi>θ</mi> <mn>2</mn></msub> <mtext>Length</mtext></mtd> <mtd><mtext>for a donkey between 2 and 4</mtext></mtd></mtr> <mtr><mtd><msub><mi>θ</mi> <mn>0</mn></msub> <mo>+</mo> <msub><mi>θ</mi> <mn>1</mn></msub> <mtext>Girth</mtext> <mo>+</mo> <msub><mi>θ</mi> <mn>2</mn></msub> <mtext>Length</mtext></mtd> <mtd>          <mtext>for a donkey over 5</mtext></mtd></mtr></mtable></mtd></mtr></mtable></math>

现在让我们对我们的三个分类变量（体质、年龄和性别）都应用独热编码：

```py
`X_one_hot` `=` `(`
    `train_set``.``assign``(``intr``=``1``)`
    `[``[``'``intr``'``,` `'``Length``'``,` `'``Girth``'``,` `'``BCS``'``,` `'``Age``'``,` `'``Sex``'``]``]`
    `.``pipe``(``pd``.``get_dummies``,` `columns``=``[``'``BCS``'``,` `'``Age``'``,` `'``Sex``'``]``)`
    `.``drop``(``columns``=``[``'``BCS_3.0``'``,` `'``Age_5-10``'``,` `'``Sex_female``'``]``)`
`)`
`X_one_hot`

```

|   | intr | 长度 | 周长 | BCS_1.5 | ... | 年龄_<2 | 年龄_>20 | 性别_阉割 | 性别_种马 |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| **230** | 1 | 101 | 116 | 0 | ... | 0 | 0 | 0 | 1 |
| **74** | 1 | 92 | 117 | 0 | ... | 0 | 0 | 0 | 1 |
| **354** | 1 | 103 | 123 | 0 | ... | 0 | 1 | 0 | 0 |
| **...** | ... | ... | ... | ... | ... | ... | ... | ... | ... |
| **157** | 1 | 93 | 123 | 0 | ... | 0 | 0 | 0 | 1 |
| **41** | 1 | 89 | 103 | 0 | ... | 1 | 0 | 0 | 0 |
| **381** | 1 | 86 | 106 | 0 | ... | 0 | 0 | 0 | 0 |

```py
433 rows × 15 columns
```

对于每个分类特征，我们删除了一个虚拟变量。由于`BCS`、`Age`和`Sex`分别有六、六和三个类别，因此我们为设计矩阵添加了12个虚拟变量，总计15列，包括截距项、周长和长度。

让我们看看哪些分类变量，如果有的话，能够改进我们的双变量模型。为此，我们可以拟合包括所有三个分类特征的模型，以及周长和长度的模型：

```py
`results` `=` `minimize``(``training_loss``(``X_one_hot``,` `y``)``,` `np``.``ones``(``X_one_hot``.``shape``[``1``]``)``)`

`theta_hat` `=` `results``[``'``x``'``]`

`y_pred` `=` `X_one_hot` `@` `theta_hat`
`training_error` `=` `(``np``.``mean``(``anes_loss``(``100` `*` `(``y` `-` `y_pred``)``/` `y_pred``)``)``)`

`print``(``f``'``Training error:` `{``training_error``:``.2f``}``'``)`

```

```py
Training error: 51.47

```

根据平均损失，这个模型比只包括`周长`和`长度`的先前模型表现更好。但是让我们试着简化这个模型，同时保持其准确性。为此，我们查看每个虚拟变量的系数，看看它们是否接近0，以及彼此之间的情况。换句话说，我们想看到如果将系数包括在模型中会如何改变截距。系数的图表可以轻松地进行比较：

![](assets/leds_18in09.png)

系数证实了我们在箱线图中看到的情况。驴子性别的系数接近零，这意味着知道性别并不真正改变体重预测。我们还看到，将超过5岁的驴子的年龄类别合并起来将简化模型而不会损失太多。最后，由于体况评分为1.5的驴子数量很少，其系数接近2的体况评分，我们倾向于将这两个类别合并。

鉴于这些发现，我们更新设计矩阵：

```py
`def` `combine_bcs``(``X``)``:`
    `new_bcs_2` `=` `X``[``'``BCS_2.0``'``]` `+` `X``[``'``BCS_1.5``'``]`
    `return` `X``.``assign``(``*``*``{``'``BCS_2.0``'``:` `new_bcs_2``}``)``.``drop``(``columns``=``[``'``BCS_1.5``'``]``)`

`def` `combine_age_and_sex``(``X``)``:`
    `return` `X``.``drop``(``columns``=``[``'``Age_10-15``'``,` `'``Age_15-20``'``,` `'``Age_>20``'``,`
                           `'``Sex_gelding``'``,` `'``Sex_stallion``'``]``)`

`X_one_hot_simple` `=` `(`
    `X_one_hot``.``pipe``(``combine_bcs``)`
    `.``pipe``(``combine_age_and_sex``)`
`)`

```

然后我们拟合更简单的模型：

```py
`results` `=` `minimize``(``training_loss``(``X_one_hot_simple``,` `y``)``,`
                   `np``.``ones``(``X_one_hot_simple``.``shape``[``1``]``)``)`
`theta_hat` `=` `results``[``'``x``'``]`
`y_pred` `=` `X_one_hot_simple` `@` `theta_hat`
`training_error` `=` `(``np``.``mean``(``anes_loss``(``100` `*` `(``y` `-` `y_pred``)``/` `y_pred``)``)``)`
`print``(``f``'``Training error:` `{``training_error``:``.2f``}``'``)`

```

```py
Training error: 53.20

```

平均误差与更复杂的模型接近，因此我们决定采用这个更简单的模型。让我们显示系数并总结模型：

|   | var | theta_hat |
| --- | --- | --- |
| **0** | intr | -175.25 |
| **1** | 长度 | 1.01 |
| **2** | 腹围 | 1.97 |
| **3** | BCS_2.0 | -6.33 |
| **4** | BCS_2.5 | -5.11 |
| **5** | BCS_3.5 | 7.36 |
| **6** | BCS_4.0 | 20.05 |
| **7** | 年龄_2-5 | -3.47 |
| **8** | 年龄_<2 | -6.49 |

我们的模型大致是：

<math display="block"><mtext>Weight</mtext> <mo>≈</mo> <mo>−</mo> <mn>175</mn> <mo>+</mo> <mtext>Length</mtext> <mo>+</mo> <mn>2</mn> <mtext>Girth</mtext></math>

在这个初步的近似之后，我们使用分类特征进行一些调整：

+   BCS 2或更低？减去6.5公斤。

+   BCS 2.5？减去5.1公斤。

+   BCS 3.5？增加7.4公斤。

+   BCS 4？增加20公斤。

+   年龄小于2岁？减去6.5公斤。

+   年龄在2到5岁之间？减去3.5公斤。

这个模型似乎相当简单易行，因为在我们根据驴子的长度和腹围进行初始估计之后，我们根据几个是/否问题的答案添加或减少一些数字。让我们看看这个模型在预测测试集中驴子的体重方面表现如何。

## 模型评估

记住，在探索和建模剩余的80%数据之前，我们将20%的数据搁置。现在，我们已经准备好将我们从训练集中学到的应用到测试集中。也就是说，我们拿出我们拟合的模型，并用它来预测测试集中驴子的体重。为此，我们需要准备测试集。我们的模型使用驴子的腹围和长度，以及驴子年龄和体况评分的虚拟变量。我们将我们在训练集上的所有转换应用到我们的测试集上：

```py
`y_test` `=` `test_set``[``'``Weight``'``]`

`X_test` `=` `(`
    `test_set``.``assign``(``intr``=``1``)`
    `[``[``'``intr``'``,` `'``Length``'``,` `'``Girth``'``,` `'``BCS``'``,` `'``Age``'``,` `'``Sex``'``]``]`
    `.``pipe``(``pd``.``get_dummies``,` `columns``=``[``'``BCS``'``,` `'``Age``'``,` `'``Sex``'``]``)`
    `.``drop``(``columns``=``[``'``BCS_3.0``'``,` `'``Age_5-10``'``,` `'``Sex_female``'``]``)`
    `.``pipe``(``combine_bcs``)`
    `.``pipe``(``combine_age_and_sex``)`
`)`

```

我们将我们对设计矩阵的所有操作汇总到我们在训练集建模中确定的最终版本中。现在我们准备使用我们在训练集上拟合的<math><mi>θ</mi></math>来为测试集中的那些驴子进行体重预测：

```py
`y_pred_test` `=` `X_test` `@` `theta_hat`
`test_set_error` `=` `100` `*` `(``y_test` `-` `y_pred_test``)` `/` `y_pred_test`

```

然后我们可以绘制相对预测误差：

![](assets/leds_18in10.png)

记住，正的相对误差意味着低估重量，这并不像高估重量那样严重。从这个残差图中，我们看到几乎所有的测试集重量都在预测的10%之内，只有一个超过10%的误差是在高估的一侧。鉴于我们的损失函数更严厉地惩罚了高估，这是合理的。

另一种散点图显示了实际值和预测值，同时标出了10%误差线，提供了不同的视角：

![](assets/leds_18in11.png)

对于较大重量的预测线，10%的误差线距离预测线更远。

我们已经实现了我们的目标！我们有一个使用易于获取的测量数据的模型，简单到可以在说明书上解释，并且可以在实际驴重量的预测中保持在10%范围内。接下来，我们总结这个案例研究并反思我们的模型。

# 总结

在这个案例研究中，我们展示了建模的不同目的：描述、推理和预测。对于描述，我们寻求一个简单易懂的模型。我们手工制作了这个模型，从分析探索阶段的发现开始。我们每采取一项行动来包含一个特征在模型中，折叠类别或转换特征，都是我们在调查数据时做出的决策。

在对象模拟自然现象如驴的重量时，我们理想地会使用物理模型和统计模型。在这种情况下，物理模型是用圆柱体表示驴的形象。一个好奇的读者可能会指出，我们可以直接使用这个表示来估算驴（圆柱体）的重量，通过其长度和围长（因为围长是 <math><mn>2</mn> <mi>π</mi> <mi>r</mi></math> ）：

<math display="block"><mi>w</mi> <mi>e</mi> <mi>i</mi> <mi>g</mi> <mi>h</mi> <mi>t</mi> <mo>∝</mo> <mi>g</mi> <mi>i</mi> <mi>r</mi> <mi>t</mi> <msup><mi>h</mi> <mn>2</mn></msup> <mo>×</mo> <mi>l</mi> <mi>e</mi> <mi>n</mi> <mi>g</mi> <mi>t</mi> <mi>h</mi></math>

这个物理模型表明，对数转换的重量大致上是围长和长度的线性函数：

<math display="block"><mi>log</mi> <mo>⁡</mo> <mo stretchy="false">(</mo> <mi>w</mi> <mi>e</mi> <mi>i</mi> <mi>g</mi> <mi>h</mi> <mi>t</mi> <mo stretchy="false">)</mo> <mo>∝</mo> <mn>2</mn> <mi>log</mi> <mo>⁡</mo> <mo stretchy="false">(</mo> <mi>g</mi> <mi>i</mi> <mi>r</mi> <mi>t</mi> <mi>h</mi> <mo stretchy="false">)</mo> <mo>+</mo> <mi>log</mi> <mo>⁡</mo> <mo stretchy="false">(</mo> <mi>l</mi> <mi>e</mi> <mi>n</mi> <mi>g</mi> <mi>t</mi> <mi>h</mi> <mo stretchy="false">)</mo></math>

鉴于这个物理模型，您可能会想知道为什么我们没有在拟合模型时使用对数或平方变换。我们留给您去更详细地探讨这样的模型。但总的来说，如果测量值的范围较小，那么对数函数大致上是线性的。为了保持我们的模型简单，鉴于围长和重量之间的高相关性，我们选择不进行这些转换。

在这个建模过程中，我们进行了大量的*数据挖掘*。我们检查了所有可能的模型，这些模型由数值特征的线性组合构建，并检查了虚拟变量的系数，以决定是否合并类别。当我们使用这种迭代方法创建模型时，非常重要的是我们留出数据来评估模型。在新数据上评估模型可以让我们放心地知道我们选择的模型效果如何。我们留出的数据在建模时没有参与任何决策，因此它能很好地帮助我们了解模型在预测上的表现。

我们应该记住之前描述的数据范围及其潜在偏见。我们的模型在测试集上表现良好，但测试集和训练集来自同一数据收集过程。只要新数据的范围保持不变，我们期望我们的模型在实践中表现良好。

最后，这个案例研究展示了模型拟合通常是在简单与复杂之间、物理与统计模型之间取得平衡的过程。物理模型可以作为建模的良好起点，而统计模型则可以为物理模型提供信息。作为数据科学家，我们需要在分析的每一步都做出判断。建模既是艺术又是科学。

本案例研究及其前面几章集中讨论了拟合线性模型的问题。接下来，我们考虑一种不同类型的建模方法，用于解释或预测的响应变量是定性而非定量的情况。
