## 第七章\. 图数据库的兴起

*本章涵盖*

+   介绍连接数据及其与图和图数据库的关系

+   学习图数据库与关系数据库的不同之处

+   发现图数据库 Neo4j

+   将数据科学流程应用于使用图数据库 Neo4j 的推荐引擎项目

一方面，我们在大规模地产生数据，促使谷歌、亚马逊和 Facebook 等公司想出智能的方法来处理这个问题，另一方面，我们面临着比以往任何时候都更加互联的数据。图和网络在我们的生活中无处不在。通过展示几个激励性的例子，我们希望教会读者如何在数据揭示自身时识别图问题。在本章中，我们将探讨如何利用图数据库中的这些连接，充分利用其价值，并演示如何使用流行的图数据库 Neo4j。

### 7.1\. 介绍连接数据和图数据库

让我们先熟悉一下连接数据及其作为图数据表示的概念。

+   ***连接数据*** —正如其名所示，连接数据的特点是手头的数据具有使其连接的关系。

+   ***图*** —经常与连接数据一起在同一个句子中提到。图非常适合以有意义的方式表示数据的连接性。

+   ***图数据库*** —在第六章中介绍。这个主题值得特别注意的原因是，除了数据量不断增加之外，它还变得更加互联。不需要太多努力就能找到连接数据的知名例子。

数据以网络形式存在的一个突出例子是社交媒体数据。社交媒体使我们能够在网络中分享和交换数据，从而生成大量连接数据。我们可以用一个简单的例子来说明这一点。假设我们的数据中有两个人，User1 和 User2。此外，我们还知道 User1（名字：Paul，姓氏：Beun）和 User2（名字：Jelme 和姓氏：Ragnar）的名字和姓氏。表示这种关系的一种自然方式是在白板上绘制出来，如图图 7.1 所示。

##### 图 7.1\. 一个简单的连接数据示例：两个实体或节点（User1，User2），每个实体或节点都有属性（名字，姓氏），通过一个关系（认识）连接

![图片](img/07fig01.jpg)

下面描述了图 7.1 的术语：

+   ***实体*** —我们有两个实体代表人物（User1 和 User2）。这些实体具有“name”和“lastname”属性。

+   ***属性*** —属性由键值对定义。从这个图中，我们还可以推断出具有“*name*”属性 Paul 的 User1 认识具有“*name*”属性 Jelme 的 User2。

+   ***关系*** —这是保罗和 Jelme 之间的关系。请注意，关系有一个方向：是保罗“*认识*”Jelme，而不是反过来。User1 和 User2 都代表人物，因此可以被分组。

+   ***标签*** —在图数据库中，可以通过标签对节点进行分组。在这种情况下，User1 和 User2 都可以被标记为“User”。

连接数据通常包含更多的实体和连接。在图 7.2 中，我们可以看到一个更广泛的图。包括了两个更多的实体：名为柬埔寨的 Country1 和名为瑞典的 Country2。存在两个更多的关系：“Has_been_in”和“Is_born_in”。在前一个图中，只有包含属性的实体，现在关系也包含了属性。这种图被称为属性图。连接节点 User1 和 Country1 的关系类型为“Has_been_in”，并具有一个表示数据值的属性“Date”。同样，User2 连接到 Country2，但通过不同类型的关系，即“Is_born_in”类型的关系。请注意，关系的类型为我们提供了节点之间关系的环境。节点可以有多个关系。

##### 图 7.2\. 包含了两个更多实体（Country1 和 Country2）和两个新关系（“Has_been_in”和“Is_born_in”）的更复杂的连接数据示例

![图片](img/07fig02_alt.jpg)

这种表示我们数据的方式为我们存储连接数据提供了一种直观的方法。为了探索我们的数据，我们需要沿着预定义的路径遍历图以找到我们正在寻找的模式。如果有人想知道保罗去过哪里？用图数据库术语来说，我们想找到“保罗去过”的模式。为了回答这个问题，我们会从名为“保罗”的节点开始，通过“Has_been_in”关系遍历到柬埔寨。因此，一个图遍历，对应于数据库查询，会是以下这样的：

> **1**.  *起始节点*—在这种情况下，具有名称属性“Paul”的节点
> 
> **2**.  *遍历路径*—在这种情况下，从节点保罗开始到柬埔寨的路径
> 
> **3**.  *结束节点*—具有名称属性“柬埔寨”的国家节点

为了更好地理解图数据库如何处理连接数据，适当地对图的一般概念进行更多扩展是合适的。图在计算机科学和数学的图论领域中得到了广泛的研究。图论是研究图的一门学科，其中图代表用于模型化对象之间成对关系的数学结构，如图图 7.3 所示。它们之所以如此吸引人，是因为它们具有适合可视化连接数据的结构。图由顶点（在图数据库世界中也称为节点）和边（也称为关系）定义。这些概念构成了图数据结构的基本基础。

##### 图 7.3。从数学定义的图来看，图的核心由节点（也称为顶点）和边（连接顶点的边）组成。这些对象的集合代表了图。

![图 7.3](img/07fig03.jpg)

与其他数据结构相比，连接数据的独特特征是其非线性性质：任何实体都可以通过各种关系类型、中间实体和路径与其他任何实体相连。在图中，你可以区分有向图和无向图。有向图的边有——怎么可能不是这样——方向。尽管有人可能会争辩说每个问题都可以以某种方式表示为图问题，但了解何时这样做是理想的，何时不是，是很重要的。

#### 7.1.1。我应该在何时以及为什么使用图数据库？

确定应该使用哪种图数据库的过程可能是一个复杂的过程。在这个决策过程中，一个重要的方面是找到适合您数据的确切表示。自从 20 世纪 70 年代初以来，人们必须依赖的最常见的数据库类型是关系型数据库。后来，其他类型出现了，例如层次数据库（例如，IMS），以及图数据库最接近的亲属：网络数据库（例如，IDMS）。但在过去几十年里，这个领域变得更加多样化，为最终用户提供了更多选择，这取决于他们的具体需求。考虑到最近可用的数据的发展，有两个特点在这里值得强调。第一个是数据的大小，另一个是数据的复杂性，如图 7.4 所示。

##### 图 7.4。此图说明了图数据库在二维空间中的定位，其中一条维度代表处理的数据的大小，另一条维度代表数据的复杂性。当关系数据库由于数据的连接性而无法处理数据集的复杂性，但不是其大小时，图数据库可能是你的最佳选择。

![图 7.4](img/07fig04_alt.jpg)

如图 7.4 所示，当数据复杂但仍然较小时，我们需要依赖图数据库。虽然这里的“小”是一个相对的概念，但我们仍在谈论数亿个节点。处理复杂性是图数据库的主要优势，也是你使用它的最终“原因”。为了解释这里所说的“复杂性”是什么，首先考虑一下传统的数据库是如何工作的。

与关系型数据库的名称所暗示的相反，它们之间并没有多少关系，除了外键和主键是连接表的关系。相比之下，图数据库中的关系是一等公民。通过这一方面，它们非常适合建模和查询关联数据。关系型数据库更倾向于努力最小化数据冗余。这个过程被称为数据库规范化，其中表被分解成更小（更少冗余）的表，同时保持所有信息完整。在规范化的数据库中，只需要在一个表中执行属性的变化。这个过程的目标是将数据变化隔离在一个表中。关系型数据库管理系统（RDBMS）是作为适合表格格式的数据的数据库的一个好选择。数据中的关系可以通过连接表来表示。当连接变得更为复杂时，尤其是成为多对多连接时，它们的适用性开始下降。当你的数据量开始增加时，查询时间也会增加，维护数据库将更具挑战性。这些因素将阻碍数据库的性能。另一方面，图数据库本质上以节点和关系存储数据。尽管图数据库被归类为 NoSQL 类型数据库，但将它们作为一个独立类别呈现的趋势正在出现。人们通过注意到其他类型的 NoSQL 数据库是面向聚合的，而图数据库则不是来寻求这种分类的合理性。

例如，一个关系型数据库可能有一个表示“人”及其属性的表。任何人都通过血缘关系（以及友谊等）与其他人相关联；每一行可能代表一个人，但将它们连接到“人”表中的其他行将是一项极其困难的工作。你是否添加一个变量来持有第一个孩子的唯一标识符，并添加另一个来持有第二个孩子的 ID？你在哪里停止？第十个孩子？

另一种选择是使用中间表来表示父子关系，但你将需要一个单独的表来表示其他关系类型，如友谊。在这种情况下，你不会得到列的激增，但会得到表的激增：每种关系类型一个关系表。即使你设法以这种方式建模数据，使得所有家庭关系都存在，你也需要复杂的查询来回答简单的问题，例如“我想知道 John McBain 的孙子们。”首先，你需要找到 John McBain 的孩子。一旦找到他的孩子，你需要找到他们的孩子。当你找到所有孙子时，你已经击中了“人”表三次：

> **1**.  找到 McBain 并获取他的孩子。
> 
> **2**.  查找您获得的 ID 对应的儿童，并获取他们孩子的 ID。
> 
> **3**.  找到 McBain 的孙子们。

图 7.5 展示了在关系数据库中递归查找的必要步骤，以便从约翰·麦克拜恩找到他的孙子们，如果所有内容都在一个表中。

##### 图 7.5\. 递归查找版本 1：所有数据在一个表中

![](img/07fig05_alt.jpg)

图 7.6 是另一种建模数据的方式：父子关系是一个单独的表。

##### 图 7.6\. 递归查找版本 2：使用父子关系表

![](img/07fig06_alt.jpg)

至少可以说，这种递归查找是不高效的。

当出现这种*复杂性*时，图数据库表现出色。让我们看看其中最受欢迎的。

### 7.2\. 介绍 Neo4j：一个图数据库

连接数据通常存储在图数据库中。这些数据库专门设计来处理连接数据的结构。如今可用的图数据库种类繁多。按流行度递减的顺序，最知名的三个是 Neo4j、OrientDb 和 Titan。为了展示我们的案例研究，我们将选择在撰写本文时的最受欢迎的一个（参见[`db-engines.com/en/ranking/graph+dbms`](http://db-engines.com/en/ranking/graph+dbms)，2015 年 9 月）。

Neo4j 是一个图数据库，它将数据存储在包含节点和关系的图中（两者都可以包含属性）。这种类型的图数据库被称为属性图，非常适合存储连接数据。它具有灵活的模式，如果需要，将给我们改变数据结构的自由，提供我们添加新数据和新的关系的能力。它是一个开源项目，成熟的技术，易于安装，用户友好，并且有良好的文档。Neo4j 还有一个基于浏览器的界面，便于创建用于可视化的图。为了跟上，现在安装 Neo4j 将是正确的时机。Neo4j 可以从[`neo4j.com/download/`](http://neo4j.com/download/)下载。成功安装的所有必要步骤总结在附录 C 中。

现在让我们介绍 Neo4j 中的四个基本结构：

+   ***节点*** —代表实体，如文档、用户、食谱等。可以分配给节点某些属性。

+   ***关系*** —存在于不同的节点之间。它们可以通过独立访问或通过它们所附加的节点来访问。关系也可以包含属性，因此得名属性图模型。每个关系都有一个名称和方向，这两个属性共同为通过关系连接的节点提供语义上下文。

+   ***属性*** —节点和关系都可以有属性。属性由键值对定义。

+   ***标签*** —可以用来将相似的节点分组，以便更快地遍历图。

在进行数据分析之前，一个好的习惯是仔细设计你的数据库，以便它适合你在分析过程中想要运行的查询。图数据库有一个令人愉悦的特性，即它们适合在白板上绘制。如果尝试在白板上绘制问题设置，这个绘制将非常接近定义问题的数据库设计。因此，这样的白板绘制将是一个很好的起点，用于设计我们的数据库。

现在如何检索数据？为了探索我们的数据，我们需要通过预定义的路径在图中遍历，以找到我们正在寻找的模式。Neo4j 浏览器是一个理想的环境，可以创建和操作你的连接数据，直到你得到适合最佳查询的表示，如图 7.7 所示。图数据库的灵活模式非常适合这里。在这个浏览器中，你可以以行或图的形式检索你的数据。Neo4j 有自己的查询语言，以简化图创建和查询功能。

##### 图 7.7\. Neo4j 2.2.5 界面，已解析章节案例研究中的查询

![](img/07fig07_alt.jpg)

Cypher 是一种高度表达的语言，与 SQL 有足够的相似性，可以增强语言的学习过程。在下一节中，我们将使用 Cypher 创建自己的数据并将其插入 Neo4j。然后我们可以围绕这些数据进行操作。

#### 7.2.1\. Cypher：图查询语言

让我们介绍 Cypher 及其基本的图操作语法。本节的目标是介绍足够多的关于 Cypher 的内容，以便我们能够开始使用 Neo4j 浏览器。在本节结束时，你应该能够使用 Cypher 在 Neo4j 浏览器中创建自己的连接数据，并运行基本的查询以检索查询结果。要获取 Cypher 的更详细介绍，请访问[`neo4j.com/docs/stable/cypher-query-lang.html`](http://neo4j.com/docs/stable/cypher-query-lang.html)。我们将从绘制一个简单的社交图并附带一个基本查询以检索预定义模式为例开始。在下一步中，我们将绘制一个更复杂的图，这将允许我们在 Cypher 中使用更复杂的查询。这将帮助我们熟悉 Cypher，并使我们能够将我们的用例带入现实。此外，我们将展示如何使用 Cypher 创建我们自己的模拟连接数据。

图 7.8 展示了两个节点之间的简单社交图，这两个节点通过“认识”类型的关系连接。节点同时具有“姓名”和“姓氏”属性。

##### 图 7.8\. 具有两个用户和一个关系的简单社交图示例

![](img/07fig08.jpg)

现在，如果我们想找出以下模式，“保罗认识谁？”我们可以使用 Cypher 进行查询。在 Cypher 中查找模式时，我们将从`Match`子句开始。在这个查询中，我们将从具有名称属性“Paul”的节点 User 开始搜索。注意节点被括号包围，如以下代码片段所示，关系被方括号包围。关系以冒号（:）前缀命名，方向使用箭头描述。占位符 p2 将包含所有具有类型“knows”关系作为入边关系的 User 节点。通过`return`子句，我们可以检索查询结果。

```
Match(p1:User { name: 'Paul' } )-[:knows]->(p2:User)
 Return p2.name
```

注意我们如何用口头方式表达问题与图数据库如何将其转换为遍历之间的紧密关系。在 Neo4j 中，这种令人印象深刻的表达能力是通过其图查询语言 Cypher 实现的。

为了使示例更有趣，让我们假设我们的数据由图 7.9 中的图形表示。

##### 图 7.9. 一个更复杂的连接数据示例，包含不同类型节点的多个相互连接的节点

![图片 7.9 的替代文本](img/07fig09_alt.jpg)

我们可以使用 Cypher 将图 7.9 中的连接数据插入到 Neo4j 中。我们可以在 Neo4j 基于浏览器的界面中直接编写 Cypher 命令，或者通过 Python 驱动程序（参见[`neo4j.com/developer/python/`](http://neo4j.com/developer/python/)以获取概述）。这是了解连接数据和图数据库的好方法。

要在 Cypher 中编写适当的创建语句，首先我们应该很好地理解我们想将哪些数据存储为节点，哪些作为关系，它们的属性应该是什么，以及标签是否有用。第一个决定是决定哪些数据应被视为节点，哪些作为关系，为这些节点提供语义上下文。在图 7.9 中，我们选择将用户和他们访问过的国家表示为节点。提供特定节点信息的数据，例如与节点关联的名称，可以表示为属性。所有提供两个或多个节点上下文的数据都将被视为关系。具有共同特征的节点，例如柬埔寨和瑞典都是国家，也将通过标签分组。在图 7.9 中，这已经完成。

在以下列表中，我们演示了如何通过一个大的创建语句在 Cypher 中编码不同的对象。*请注意，Cypher 区分大小写*。

##### 列表 7.1. Cypher 数据创建语句

```
CREATE (user1:User {name :'Annelies'}),
 (user2:User {name :'Paul' , LastName: 'Beun'}),
 (user3:User {name :'Muhuba'}),
 (user4:User {name : 'Jelme' , LastName: 'Ragnar'}),
 (country1:Country { name:'Mongolia'}),
 (country2:Country { name:'Cambodia'}),
 (country3:Country { name:'New Zealand'}),
 (country4:Country { name:'Sweden'}),
 (food1:Food { name:'Sushi' }),
 (hobby1:Hobby { name:'Travelling'}),
 (user1)-[:Has_been_in]->(country1),
 (user1)-[: Has_been_in]->(country2),
 (user1)-[: Has_been_in]->(country3),
 (user2)-[: Has_been_in]->(country2),
 (user1)-[: Is_mother_of]->(user4),
 (user2)-[: knows]->(user4),
 (user1)-[: Is_friend_of]->(user3),
 (user2)-[: Likes]->( food1),
 (user3)-[: Likes]->( food1),
 (user4)-[: Is_born_in]->(country4)
```

一次性运行这个创建语句的优点是，这个执行的成败将确保我们图数据库已成功创建。如果存在错误，图将不会被创建。

在实际场景中，还应该定义索引和约束以确保快速查找，而不是搜索整个数据库。我们没有在这里这样做，因为我们的模拟数据集很小。然而，这可以通过 Cypher 轻松完成。查阅 Cypher 文档以了解更多关于索引和约束的信息（[`neo4j.com/docs/stable/cypherdoc-labels-constraints-and-indexes.html`](http://neo4j.com/docs/stable/cypherdoc-labels-constraints-and-indexes.html)）。现在我们已经创建了数据，我们可以查询它。以下查询将返回数据库中的所有节点和关系：

![](img/201fig01.jpg)

图 7.10 显示了我们所创建的数据库。我们可以将这个图与我们白板上构思的图进行比较。在我们的白板上，我们将人的节点分组为“用户”标签，将国家的节点分组为“国家”标签。尽管这个图中的节点没有用它们的标签表示，但标签确实存在于我们的数据库中。此外，我们还缺少一个节点（爱好）和类型为“喜爱”的关系。这些可以通过一个合并语句轻松添加，如果它们还不存在的话：

##### 图 7.10\. 图 7.9 中绘制的图现在已经在 Neo4j 网络界面中创建。节点不是通过它们的标签，而是通过它们的名称来表示。我们可以从图中推断出我们缺少名为*Traveling*的*爱好*标签。原因是我们在创建语句中忘记包含这个节点及其对应的关系。

![](img/07fig10_alt.jpg)

```
Merge (user3)-[: Loves]->( hobby1)
```

我们可以提出很多问题。例如：

+   问题 1：安奈莉丝访问过哪些国家？创建答案的 Cypher 代码（如图 7.11 所示）是

    ##### 图 7.11\. 问题 1 的结果：安奈莉丝访问过哪些国家？我们可以通过 Neo4j 的行表示看到安奈莉丝曾去过三个国家。这次遍历只用了 97 毫秒。

    ![](img/07fig11_alt.jpg)

    ```
    Match(u:User{name:'Annelies'}) – [:Has_been_in]-> (c:Country)
    Return u.name, c.name
    ```

+   问题 2：人在哪里？Cypher 代码（如图 7.12 所示）是

    ##### 图 7.12\. 人在哪里？查询构建解释。

    ![](img/07fig12.jpg)

    ```
    Match ()-[r: Has_been_in]->()
    Return r LIMIT 25
    ```

当我们运行这个查询时，我们得到图 7.13 中显示的答案。

##### 图 7.13\. 问题 2 的结果：人在哪里？我们的遍历结果现在以 Neo4j 的图表示形式显示。现在我们可以看到，除了安奈莉丝之外，保罗也去过柬埔寨。

![](img/07fig13.jpg)

在问题 2 中，我们没有指定起始节点。因此，Cypher 将遍历数据库中所有存在的节点，以找到具有类型“Has_been_in”的出向关系的节点。应该避免不指定起始节点，因为，根据数据库的大小，这样的查询可能需要很长时间才能收敛。在数据上玩来玩去以获得正确的图数据库也意味着大量的数据删除。Cypher 有一个适合删除少量数据的删除语句。以下查询演示了如何删除数据库中的所有节点和关系：

```
MATCH(n)
Optional MATCH (n)-[r]-()
Delete n,r
```

现在我们已经熟悉了连接数据，并了解了如何在图数据库中管理它，我们可以更进一步，看看连接数据的实际应用。例如，社交图可以用来在图社区内找到紧密连接的节点簇。簇中彼此不认识的人可以相互介绍。寻找紧密连接的节点，即具有大量共同特征的节点，是一个广泛使用的概念。在下一节中，我们将使用这个想法，目标是找到成分网络内的簇。

### 7.3\. 连接数据示例：食谱推荐引擎

图数据库最流行的用例之一是推荐引擎的开发。推荐引擎因其承诺创建相关内容而得到广泛应用。生活在这样一个数据丰富的时代，对许多消费者来说可能会感到不知所措。企业看到了通过个性化内容吸引客户的明确需求，因此利用推荐引擎的优势。

在我们的案例研究中，我们将根据用户的菜品偏好和成分网络推荐食谱。在数据准备过程中，我们将使用 Elasticsearch 来加速流程，并使我们能够更多地关注实际的图数据库。在这里，它的主要目的将是用我们自己的“干净”列表中的成分替换“脏”下载数据的成分列表。

如果您跳过了前面的章节直接来到这里，至少应该阅读附录 A 关于安装 Elasticsearch 的内容，这样您就可以在您的电脑上运行它。如果您不想处理第六章的案例研究，您可以从本章的下载页面下载我们将使用的索引，并将其粘贴到您本地的 Elasticsearch 数据目录中。

您可以从 Manning 网站下载本章的相关信息：

三个 .py 代码文件及其 .ipynb 对应文件

+   ***数据准备第一部分*** — 将数据上传到 Elasticsearch（或者您可以将可下载的索引粘贴到您本地的 Elasticsearch 数据文件夹中）

+   ***数据准备第二部分*** — 将数据从 Elasticsearch 移动到 Neo4j

+   探索与推荐系统

三个数据文件

+   ***食材 (.txt)*** —自行编译的食材文件

+   ***食谱 (.json)*** —包含所有食材

+   ***Elasticsearch 索引 (.zip)*** —包含“美食”Elasticsearch 索引，您可以使用它跳过数据准备的第一部分

现在我们已经拥有了所有需要的东西，让我们看看研究目标和我们需要采取的步骤来实现它。

#### 7.3.1\. 第 1 步：设定研究目标

让我们看看遵循数据科学流程（图 7.14）时会出现什么情况。

##### 图 7.14\. 将数据科学流程概述应用于连接数据推荐模型

![](img/07fig14_alt.jpg)

我们的主要目标是建立一个推荐引擎，帮助烹饪网站的用户找到合适的食谱。用户可以喜欢几个食谱，我们将根据食谱网络中食材的重叠来制定菜肴推荐。这是一个简单直观的方法，但已经产生了相当准确的结果。让我们看看我们需要的三个数据元素。

#### 7.3.2\. 第 2 步：数据检索

对于这个练习，我们需要三种类型的数据：

+   食谱及其相应的食材

+   我们想要建模的不同食材列表

+   至少一个用户及其对某些菜肴的偏好

和往常一样，我们可以将其分为内部可用或创建的数据和外部获取的数据。

+   ***内部数据*** —我们没有任何*用户偏好*或食材，但这些只是我们数据的一小部分，并且很容易创建。一些手动输入的偏好应该足以创建一个推荐。用户给出的反馈越多，他得到的结果就越有趣、越准确。我们将在案例研究中稍后输入用户偏好。*食材列表*可以手动编制，并将在未来几年内保持相关性，因此请随意使用下载材料中的列表，无论是商业用途还是其他用途。

+   ***外部数据*** —*食谱*是另一回事。有成千上万的食材存在，但它们可以组合成数百万道菜肴。然而，我们很幸运，因为有一个相当大的列表在[`github.com/fictivekin/openrecipes`](https://github.com/fictivekin/openrecipes)上免费提供。非常感谢 Fictive Kin 为我们提供了这个包含超过十万道食谱的宝贵数据集。当然，这里有一些重复项，但它们对我们的用例影响不大。

现在我们有可用的两个数据文件：一个包含 800 多个食材的列表（ingredients.txt）和超过十万道食谱的 recipes.json 文件。以下是一个食材列表的示例。

##### 列表 7.2\. 食材列表文本文件示例

```
Ditalini
Egg Noodles
Farfalle
Fettuccine
Fusilli
Lasagna
Linguine
Macaroni
Orzo
```

“openrecipes” JSON 文件包含超过十万道食谱，具有多个属性，如发布日期、来源位置、准备时间、描述等。我们只对名称和食材列表感兴趣。以下是一个示例食谱。

##### 列表 7.3\. 一个示例 JSON 食谱

```
{ "_id" : { "$oid" : "5160756b96cc62079cc2db15" },
    "name" : "Drop Biscuits and Sausage Gravy",
    "ingredients" : "Biscuits\n3 cups All-purpose Flour\n2 Tablespoons Baking
     Powder\n1/2 teaspoon Salt\n1-1/2 stick (3/4 Cup) Cold Butter, Cut Into
     Pieces\n1-1/4 cup Butermilk\n SAUSAGE GRAVY\n1 pound Breakfast Sausage,
     Hot Or Mild\n1/3 cup All-purpose Flour\n4 cups Whole Milk\n1/2 teaspoon
     Seasoned Salt\n2 teaspoons Black Pepper, More To Taste",
    "url" : "http://thepioneerwoman.com/cooking/2013/03/drop-biscuits-and-
     sausage-gravy/",
    "image" : "http://static.thepioneerwoman.com/cooking/files/2013/03/
     bisgrav.jpg",
    "ts" : { "$date" : 1365276011104 },
    "cookTime" : "PT30M",
    "source" : "thepioneerwoman",
    "recipeYield" : "12",
    "datePublished" : "2013-03-11",
    "prepTime" : "PT10M",
    "description" : "Late Saturday afternoon, after Marlboro Man had returned home
     with the soccer-playing girls, and I had returned home with the..."
}
```

因为在这里我们处理的是文本数据，问题有两个方面：首先，按照文本挖掘章节中描述的准备工作准备文本数据。然后，一旦数据被彻底清理，就可以用来根据成分网络生成食谱推荐。本章不专注于文本数据准备，因为这部分在其他地方已有描述，所以我们将允许自己在即将到来的数据准备阶段使用捷径。

#### 7.3.3\. 第 3 步：数据准备

现在我们有两组数据文件可供使用，我们需要将它们合并成一个图数据库。未清理的食谱数据存在一个问题，我们可以通过使用我们的清洁成分列表和搜索引擎以及 NoSQL 数据库 Elasticsearch 来解决。我们已经在之前的章节中依赖过 Elasticsearch，现在它将在创建索引时隐式地清理食谱数据。然后我们可以搜索这些数据，将每个成分与其出现的每个食谱联系起来。我们可以像在文本挖掘章节中做的那样，使用纯 Python 清理文本数据，但这表明了解每个 NoSQL 数据库的强点是很好的；不要局限于单一技术，而是将它们结合起来，以利于项目。

让我们从将我们的食谱数据输入到 Elasticsearch 开始。如果你不明白发生了什么，请再次查看第六章的案例研究[kindle_split_014.xhtml#ch06]，它应该会变得清晰。确保在运行以下列表中的代码片段之前，打开你的本地 Elasticsearch 实例并激活一个已安装 Elasticsearch 模块的 Python 环境。建议不要直接在 Ipython（或 Jupyter）中运行此代码，因为它会将每个食谱键打印到屏幕上，而你的浏览器只能处理这么多输出。要么关闭打印语句，要么在另一个 Python IDE 中运行。此代码片段中的代码可以在“Data Preparation Part 1.py”中找到。

##### 列表 7.4\. 将食谱数据导入 Elasticsearch

![](img/ch07ex04-0.jpg)

![](img/ch07ex04-1.jpg)

如果一切顺利，我们现在已经有一个名为“gastronomical”的 Elasticsearch 索引，其中包含数千个食谱。请注意，我们没有将食谱名称指定为文档键，因此允许了相同食谱的重复。例如，如果食谱名称为“lasagna”，那么这可能是一个三文鱼 lasagna、牛肉 lasagna、鸡肉 lasagna 或任何其他类型的 lasagna。没有单个食谱被选为原型 lasagna；它们都使用相同的名称“lasagna”上传到 Elasticsearch。这是一个选择，所以请随意决定是否不同。这将产生重大影响，正如我们稍后将会看到的。现在，我们可以系统地上传到我们的本地图数据库。在应用以下代码时，请确保您的本地图数据库实例已开启。我们在这个数据库上的用户名是默认的 Neo4j，密码是 Neo4ja；请确保根据您的本地设置进行调整。为此，我们还需要一个名为 py2neo 的特定于 Neo4j 的 Python 库。如果您还没有安装，现在就是时候使用`pip install py2neo`或使用 Anaconda 时使用`conda install py2neo`将其安装到您的虚拟环境中。再次提醒，直接在 Ipython 或 Jupiter 中运行此代码将导致浏览器崩溃。此列表中的代码可以在“Data Preparation Part 2.py”中找到。

##### 列表 7.5. 使用 Elasticsearch 索引填充图数据库

![图片](img/ch07ex05-0.jpg)

![图片](img/ch07ex05-1.jpg)

太好了，我们现在自豪地拥有了一个充满食谱的图数据库！现在是时候进行连接数据探索了。

#### 7.3.4. 步骤 4：数据探索

现在我们已经将数据放在了我们想要的位置，我们可以使用 Neo4j 界面在 http://localhost:7474/browser/上手动探索它。

在这个环境中运行您的 Cypher 代码没有任何阻碍，但 Cypher 也可以通过 py2neo 库来执行。我们可以提出一个有趣的问题：在所有食谱中，哪些成分出现的频率最高？如果我们随机选择并食用这个数据库中的菜肴，我们最有可能摄入消化系统的是什么？

```
from py2neo import Graph, authenticate, Node, Relationship
authenticate("localhost:7474", "user", "password")
graph_db = Graph("http://localhost:7474/db/data/")graph_db.cypher.execute("
   MATCH (REC:Recipe)-[r:Contains]->(ING:Ingredient) WITH ING, count(r) AS num
   RETURN ING.Name as Name, num ORDER BY num DESC LIMIT 10;")
```

查询是用 Cypher 创建的，内容如下：对于所有食谱及其成分，计算每个成分的关系数量，并返回关系数量最多的十个成分及其相应的计数。结果如图 7.15 所示。

##### 图 7.15. 在最多食谱中出现的最常见前 10 个成分

![图片](img/07fig15.jpg)

图 7.15 中的前 10 名列表中的大多数内容可能不会令人惊讶。鉴于盐在我们的列表中高居榜首，我们不应该对在大多数西方国家血管疾病成为头号杀手感到震惊。现在，另一个有趣的问题浮现在脑海中：从不同角度来看，哪些食谱需要最多的成分？

```
from py2neo import Graph, Node, Relationship
graph_db = Graph("http://neo4j:neo4ja@localhost:7474/db/data/")
graph_db.cypher.execute("
    MATCH (REC:Recipe)-[r:Contains]->(ING:Ingredient) WITH REC, count(r) AS num
    RETURN REC.Name as Name, num ORDER BY num DESC LIMIT 10;")
```

查询几乎与之前相同，但我们不是返回成分，而是要求食谱。结果如图 7.16 所示。

##### 图 7.16. 可以使用最多不同成分制作的前 10 道菜

![图片 7.16](img/07fig16.jpg)

现在这可能是一个令人惊讶的景象。意大利面肉酱听起来几乎不像需要 59 种配料的菜品。让我们仔细看看为意大利面肉酱列出的配料。

```
from py2neo import Graph, Node, Relationship
graph_db = Graph("http://neo4j:neo4ja@localhost:7474/db/data/")
graph_db.cypher.execute("MATCH (REC1:Recipe{Name:'Spaghetti Bolognese'})-
     [r:Contains]->(ING:Ingredient) RETURN REC1.Name, ING.Name;")
```

Cypher 查询只是列出了与意大利面肉酱链接的配料。图 7.17 显示了在 Neo4j 网络界面中的结果。

##### 图 7.17\. 意大利面肉酱可能的配料

![图片 7.17](img/07fig17_alt.jpg)

让我们回忆一下在 Elasticsearch 中索引数据时我们做出的评论。对意大利面肉酱的快速 Elasticsearch 搜索显示它出现了多次，所有这些实例都被用来将配料与意大利面肉酱作为食谱链接起来。我们不必将意大利面肉酱视为单一的食谱，而更多地将其视为人们创造自己的“意大利面肉酱”的方式集合。这为查看这些数据提供了一种有趣的方法。人们可以用番茄酱、红酒和鸡肉来制作自己的版本，甚至可能加入汤。由于“意大利面肉酱”这道菜如此开放，难怪这么多人喜欢它。

意大利面肉酱故事是一个有趣的分心点，但并非我们此行的目的。现在是时候向我们的美食家“Ragnar”推荐菜品了。

#### 7.3.5\. 第 5 步：数据建模

在我们对数据的了解略有丰富之后，我们达到了这个练习的目标：推荐。

为了这个目的，我们引入了一个我们称之为“Ragnar”的用户，他喜欢几道菜品。在我们期望它建议新菜品之前，我们需要让我们的图数据库吸收这些新信息。因此，现在让我们创建 Ragnar 的用户节点和一些食谱偏好。

##### 列表 7.6\. 在 Neo4j 图数据库中创建喜欢某些食谱的用户节点

![图片 7.18](img/ch07ex06-0.jpg)

![图片 7.6](img/ch07ex06-1.jpg)

在列表 7.6 中，我们的美食家 Ragnar 及其对几道菜品的偏好被添加到数据库中。如果我们选择 Ragnar 在 Neo4j 界面中，我们会得到图 7.18。这个 Cypher 查询如下：

##### 图 7.18\. 用户 Ragnar 喜欢几道菜品

![图片 7.18](img/07fig18.jpg)

```
MATCH (U:User)-[r:Likes]->(REC:Recipe) RETURN U,REC LIMIT 25
```

图 7.18 中没有惊喜：很多人喜欢意大利面肉酱，我们的斯堪的纳维亚美食家 Ragnar 也是如此。

对于我们想要构建的简单推荐引擎，我们剩下要做的就是请求图数据库给出基于配料的最近似菜品。这再次是一个基本的推荐系统方法，因为它没有考虑到诸如

+   对某种配料或菜品的厌恶。

+   喜欢或不喜欢程度。10 分制的评分而不是简单的喜欢或不喜欢可能更有区别。

+   菜品中某种配料的含量。

+   某种配料在味道中显现的阈值。某些配料，如辣椒，在较小剂量下对味道的影响比其他配料要大。

+   食物过敏。虽然这将在带有某些成分的菜肴的喜欢或不喜欢中隐式建模，但食物过敏可能非常重要，以至于一次错误可能导致致命。应避免过敏原，以覆盖整个推荐系统。

+   还有更多的事情值得你思考。

可能会有些惊讶，但一个单一的 Cypher 命令就足够了。

```
from py2neo import Graph, Node, Relationship
graph_db = Graph("http://neo4j:neo4ja@localhost:7474/db/data/")
graph_db.cypher.execute("
   MATCH (USR1:User{Name:'Ragnar'})-[l1:Likes]->(REC1:Recipe),
         (REC1)-[c1:Contains]->(ING1:Ingredient)
      WITH  ING1,REC1 MATCH (REC2:Recipe)-[c2:Contains]->(ING1:Ingredient)
      WHERE REC1 <> REC2
   RETURN REC2.Name,count(ING1) AS IngCount ORDER BY IngCount DESC LIMIT 20;")
```

首先收集 Ragnar 喜欢的所有食谱。然后使用它们的成分来检索共享这些成分的所有其他菜肴。接着对每个关联菜肴的成分进行计数并按从许多常见成分到较少成分的顺序进行排名。只保留前 20 道菜肴；这导致了图 7.19 的表格。

##### 图 7.19\. 食谱推荐的输出；用户可能喜欢的顶级 20 道菜肴

![](img/07fig19_alt.jpg)

从图 7.19 我们可以推断，是时候让 Ragnar 尝试意大利面和肉丸了，这是一道由迪士尼动画电影《小姐与流浪汉》使不朽的菜肴。这听起来确实是为那些喜欢含有面条和肉丸的菜肴的人的一个很好的推荐，但正如我们可以通过成分计数看到的那样，还有更多成分支持这个建议。为了给我们一点提示，我们可以通过一个总结的图形图像展示偏好的菜肴、顶级推荐以及它们重叠的一些成分。

#### 7.3.6\. 步骤 6：展示

Neo4j 的 Web 界面允许我们运行模型并检索一个漂亮的图形，该图形总结了推荐背后的部分逻辑。它显示了推荐菜肴如何通过成分与偏好菜肴相连接。这显示在图 7.20 中，并且是我们案例研究的最终输出。

##### 图 7.20\. 用户偏好的菜肴与基于重叠成分子集推荐的顶级 10 道菜肴之间的相互关联

![](img/07fig20_alt.jpg)

通过这张美丽的图形图像，我们可以得出结论，Ragnar 有一些美味的菜肴可以期待。别忘了亲自尝试推荐系统，通过插入你自己的偏好来体验。

### 7.4\. 总结

在本章中，你学习了

+   图数据库在遇到实体之间的关系与实体本身一样重要的数据时特别有用。与其他 NoSQL 数据库相比，它们可以处理最大的复杂性，但数据量最少。

+   图形数据结构由两个主要组件组成：

    +   ***节点*** —这些是实体本身。在我们的案例研究中，这些是食谱和成分。

    +   ***边*** —实体之间的关系。关系，像节点一样，可以是各种类型（例如“包含”、“喜欢”、“去过”）并且可以有自己的特定属性，如名称、权重或其他度量。

+   我们研究了目前最受欢迎的图数据库 Neo4j。有关如何安装它的说明，您可以参考附录 B。我们还研究了如何向 Neo4j 添加数据，如何使用 Cypher 查询它，以及如何访问其 Web 界面。

+   Cypher 是 Neo4j 数据库特定的查询语言，我们查看了一些示例。我们还在案例研究中将其作为我们菜谱推荐系统的一部分使用。

+   在本章的案例研究中，我们使用了 Elasticsearch 来清理大量的食谱数据。然后我们将这些数据转换成包含食谱和成分的 Neo4j 数据库。案例研究的目标是根据用户之前对其他菜谱的兴趣来推荐菜谱。为此，我们利用了通过成分连接的食谱。py2neo 库使我们能够从 Python 与 Neo4j 服务器进行通信。

+   结果表明，图数据库不仅对实现推荐系统很有用，而且对于数据探索也非常有用。我们发现的一件事是，Spaghetti Bolognese 食谱的多样性（从成分角度来看）。

+   我们使用 Neo4j 的 Web 界面来创建了一个可视化表示，展示了我们如何通过成分节点从菜谱偏好到菜谱推荐的转换过程。
