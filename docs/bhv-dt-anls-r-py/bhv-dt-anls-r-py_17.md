# 第12章 调解和工具变量

在上一章中，我们看到调节能够通过揭示特定群体中关系更强或更弱的特征，打开因果关系的黑匣子。*调解*指的是链条中两个变量之间存在中介变量的情况；它通过理解起作用的因果机制——因果效应的“如何”，提供了另一种探索黑匣子的方式。

这对我们框架中因果和行为两方面都有多重好处。从因果角度看，调解减少了误报的风险，如果不充分考虑它可能会使我们的分析产生偏差。从行为角度看，调解帮助我们更好地设计和理解实验。在某种程度上，调解并不新鲜，本章中的大多数论点都可以总结为“尽可能扩展您的CD链，至少在开始时如此”。但我认为这样的简化会对你不利，因为寻找调解因素是许多科学发现的根源之一。“但为什么？”是确认两个变量之间因果关系后最好的后续问题之一。客户满意度增加了留存率，*但为什么*？是因为它减少了寻找替代品的可能性，还是因为它提高了客户对公司的看法？

调解还为本书中最后一个工具，即工具变量（IVs），提供了一个很好的过渡。IVs可以像激素一样增强调解，使我们能够回答否则难以解决的问题。正如本书开头所承诺的，我们将获得关于客户满意度对后续购买行为影响的无偏估计，而IVs使这成为可能。

在接下来的部分，我将在C-Mart商店游乐区示例（来自[第11章](ch11.xhtml#introduction_to_moderation)）的背景下向你介绍调解，并展示调解如何使因果行为分析更加有效。然后在第二部分，我们将进入盛大结局：工具变量。

# 调解

让我们继续使用上一章的C-Mart示例，假设C-Mart现在有兴趣测量游乐区对杂货购买的影响（[图12-1](#our_relationship_of_interest)）。

![我们感兴趣的关系](Images/BEDA_1201.png)

###### 图12-1\. 我们感兴趣的关系

根据先前的分析，C-Mart的管理层认为访问持续时间是这种关系的关键因果机制。也就是说，他们认为*PlayArea*导致*VisitDuration*，进而导致*GroceryPurchases*。显然，我们可以忽略这一假设，并直接分析[图12-1](#our_relationship_of_interest)中显示的关系，建立相应的回归、置信区间等。然而，我们将确认并测量这一因果机制，因为考虑它具有多重好处：

+   通过调解，我们可以理解其中的机制，并生成可操作的见解。

+   在某些情况下，不考虑调解可能会导致因果估计的偏误。

让我们在接下来的两个小节中更详细地回顾这些好处，然后我将进入测量调解的技术考虑。

## 理解因果机制

辨识和测量调解的首个好处是提供所涉因果机制的解释。相关性并非总是因果关系，但从行为角度理解实际发生的事情是对虚假相关的强有力保护。如果你有两个相关的变量，但不确定这种相关是否是因果关系，找到并验证其间的中介者提供了非常强有力的证据表明这种关系是因果的。此时，错误的最可能来源是逆向因果关系——因果性的方向相反。 （另一种可能性是这三个变量恰好分别与其他两个存在虚假相关性；这是三个与随机事件的虚假相关性，而不是一个，这是一个极不可能发生的事件。）

调解在发现和设计阶段都是很有效的补充。在发现阶段（我在上一章中称之为“钓鱼远征”），识别可能的中介者可以帮助头脑风暴过程。即使中介者不可观察（例如信念或情感），仅仅考虑它可能会导致找到可测量的调节因素，并为其提供合理性。我们在[第11章](ch11.xhtml#introduction_to_moderation)中看到，*PlayArea*和*GroceryPurchases*之间的关系受*Children*的调节，这在直觉上是立即理解的。然而，认识到这种关系是通过*VisitDuration*调解的可以给我们提供其他可能的调节因素的线索。例如，如果调解是完全的，那么在接近闭店时间的访问中，总体效果可能会较弱，这是如果我们忽视*VisitDuration*的角色将不会立即显现的事情（[图12-2](#the_relationship_between_playarea_and_g)）。

![PlayArea和GroceryPurchases之间的关系](Images/BEDA_1202.png)

###### 图12-2. PlayArea和GroceryPurchases之间的关系

我们可以通过检查*PlayArea*对*GroceryPurchases*的影响在接近闭店时间开始的访问中是否较弱来探索这一假设，这将进一步提供关于效果性质的信息。

仲裁也可用于设计或改进业务流程和信息传递。太多时候，分割练习以“A段显示比B段更强烈的效果”而告终。这只在更好地定位预先存在的治疗方法（如营销活动）方面有用。理解调节作用的机制为构思提供了有用的见解。确认*儿童*对*游乐区*的调节效应由*访问持续时间*中介，我们可以通过提供额外的停车验证或靠近游乐区的小吃站等福利来支持它。我们还可以用（可能更便宜的）迷你电影院替换游乐区，放映卡通片。

## 因果偏差

仲裁不仅仅是一个“好用”的工具。在某些情况下，不考虑它可能会引入我们因果估计中的偏差。

最简单的情况是，当我们试图衡量一个变量对另一个变量（总体）的影响时，但在回归中无意中包括一个中介作为控制变量时，就会发生这种情况。假设我们已经在个体水平上测量了在[第2章](ch02.xhtml#understanding_behavioral_data)建议的方向上，在超市购买的影响。可以想象，游乐区不仅影响了无论如何都会来的客户的访问时间，还吸引了新的客户。为了考虑这种因果路径，我们需要重新设计我们在商店水平上的CD（[图12-3](#cd_recast_at_the_store_level)）。

![在商店水平上重新设计CD](Images/BEDA_1203.png)

###### 图12-3\. 在商店水平上重新设计CD

注意，尽管顾客水平上的平均购物金额完全由平均访问持续时间中介，但在商店水平上的总杂货销售情况并非如此。您测量行为的级别是有影响的！

在[图12-3](#cd_recast_at_the_store_level)中，很明显*顾客数*是*游乐区*对*杂货销售*影响的中介。然而，我们很容易想象，调查这种效果的人会决定在回归中包括*顾客数*作为控制变量：*杂货销售* = *β[p].游乐区* + *β[c].顾客数*。毕竟，商店的顾客基数大小肯定会影响其总杂货销售量，并且可能会影响选择建立游乐区的商店（[图12-4](#the_storeapostrophes_customer_base_is_a)）。

![商店的顾客基数是混杂因素](Images/BEDA_1204.png)

###### 图12-4\. 商店的顾客基数是混杂因素

[图 12-4](#the_storeapostrophes_customer_base_is_a) 提出了一个因果难题：商店的顾客基数，即那些离商店购物距离内的潜在顾客数量，可能是 *PlayArea* 与 *GrocerySales* 之间关系的混杂变量。但与此同时，*CustomersNumber* 是这种关系的一个介导变量。这种情况需要对相关的回归进行深思熟虑的控制——也就是说，所有依赖变量为 *CustomersNumber* 或 *GrocerySales* 的回归。

可以通过在这些回归中添加周到的控制变量来实现这一点。例如，安装游乐区前一年的顾客数量是顾客基数的一个很好的代理变量，并且根据定义不会捕捉到安装游乐区的任何影响。或者，我们可以选择另一个代理变量，比如 *Rural/Urban* 的分类变量。

再次说明“包罗万象”方法对变量包含的危险性：仅仅因为当前顾客数量在我们的情况下可用且相关，并不意味着它应自动包含为控制变量。

## 识别介导作用

当我在 [第 3 章](ch03.xhtml#introduction_to_causal_diagrams) 中介绍 CD 的基本组成部分时，我提到 *mediator* 是一个链条中连接两个其他变量的变量，如 [图 12-5](#the_effect_of_having_a_play_area_on_gro) 中所示。

![有游乐区对杂货购买的影响通过访问持续时间介导](Images/BEDA_1205.png)

###### 图 12-5\. 有游乐区对杂货购买的影响通过访问持续时间介导

*VisitDuration* 是 *PlayArea* 的效应，也是 *GroceryPurchases* 的原因。因此，在这个 CD 中，它是 *PlayArea* 对 *GroceryPurchases* 的影响的介导变量。

假设 [图 12-5](#the_effect_of_having_a_play_area_on_gro) 中的 CD 完全揭示了整个故事，*PlayArea* 对 *GroceryPurchases* 没有其他影响，除了通过 *VisitDuration* 的路径；在保持 *VisitDuration* 恒定的情况下改变 *PlayArea* 不会改变 *GroceryPurchases*。*PlayArea* 对 *GroceryPurchases* 的影响被称为“完全”或“完全介导”。或者，我们可以想象 *PlayArea* 除了通过 *VisitDuration* 路径之外，对 *GroceryPurchases* 还有直接影响的情况（[图 12-6](#partial_mediation)）。

![部分介导](Images/BEDA_1206.png)

###### 图 12-6\. 部分介导

这被称为“部分”介导。即使 *VisitDuration* 不能完全解释 *PlayArea* 对 *GroceryPurchases* 的总效应，它仍然是一个介导变量。从 *PlayArea* 到 *GroceryPurchases* 的直接效应可能是真正的直接效应——没有中介变量参与——或者它可能代表我们不知道或不感兴趣分析的一个或多个其他介导变量（在这种情况下，我们已经合并了相应的链条）。

就像寻找潜在的调节变量一样，寻找中介者也是一个试探性和试错性的寻找过程，但是搜索范围（因此误报风险）要小得多。由于只有在行为上有强有力的理由支持时，才应该调查潜在的中介者，因此候选者的数量是明显受限的。此外，确认中介者涉及多次回归分析，这也降低了误报的风险。

鉴于考虑到中介者的好处和不考虑中介者的风险，您应该始终在分析中至少作为第一步包括相关的中介者。一旦确定了要分析的链条和要忽略的链条，您就可以安全地折叠后者（例如，在分析中只起次要作用的变量之间的中介者）。

与调节变量类似，搜索过程包括找到一个潜在的候选项，然后通过Bootstrap置信区间来验证它。在我们的例子中，*VisitDuration*是一个明显的候选项，因此让我们看看我们如何确认和测量其中介作用。

## 测量中介

测量中介是直接的但有点繁琐。它归结为运行多次回归分析来估计以下内容：

+   *PlayArea*对*GroceryPurchases*的总效应

+   *PlayArea*对*GroceryPurchases*的效应，即通过*VisitDuration*介导的间接效应

+   *PlayArea*对*GroceryPurchases*的效应，即不通过*VisitDuration*介导的直接效应

如果我们找不到间接、介导的路径的证据，我们应该否定我们的暂定中介者。相反，如果我们找不到直接路径的证据，那么效应就是完全通过中介实现的。*百分之百的总效应通过中介实现* 是总结这些证据的常见和有用方式。我们将通过考虑中介者是一个二元变量的特殊情况来结束这一部分。

### 总效应

我们首先通过在回归中不包括*VisitDuration*的情况下对*PlayArea*和*GroceryPurchases*进行回归来确定总效应：

```py
## R (output not shown)
summary(lm(grocery_purchases~play_area, data=hist_data))
```

```py
## Python
ols("grocery_purchases~play_area", data=hist_data_df).fit().summary()
...
          coef       std err    t           P>|t|   [0.025  0.975]
Intercept 49.1421    0.047      1036.494    0.000   49.049  49.235
play_area 27.6200    0.079      349.485     0.000   27.465  27.775
...
```

总效应约为27.6，这意味着增加游乐区平均会使购物支出增加27.6美元，*不持续访问时长恒定*。

### 中介效应

*PlayArea*对*GroceryPurchases*的影响，通过*VisitDuration*介导，可以通过将*PlayArea*对*VisitDuration*的影响和*VisitDuration*对*GroceryPurchases*的影响相乘得到。这是直观的：如果游乐区增加了平均访问时间X分钟，并且每增加一分钟的访问时间就会使购物支出增加Y美元，那么增加游乐区将使购物支出增加X * Y美元。

第一个回归分析是关于*PlayArea*和*VisitDuration*之间的箭头。它产生的系数约为12.6（增加游乐区大约会使平均访问时长增加约12.6分钟）：

```py
## R (output not shown)
summary(lm(duration~play_area, data=hist_data))
```

```py
## Python
ols("duration~play_area", data=hist_data_df).fit().summary()
...
    coef  std err    t    P>|t| [0.025      0.975]
Intercept 23.8039    0.018 1287.327   0.000  23.768  23.840
play_area 12.5570    0.031 407.397    0.000  12.497  12.617
...
```

第二个回归是针对 *VisitDuration* 和 *GroceryPurchases* 之间的箭头。然而，在这个回归中，我也会包括 *PlayArea*。回顾一下 [图 12-6](#partial_mediation) 并记住混淆变量的定义，我们可以看到如果中介仅为部分中介（即，从 *PlayArea* 到 *GroceryPurchases* 存在直接箭头），那么 *PlayArea* 是 *VisitDuration* 和 *GroceryPurchases* 之间关系的一个混淆变量。因此，它必须被默认包含在回归中。运行一个回归，将我们的主要原因和中介变量作为解释变量，分别得到系数为 0.16（增加一个游戏区域会使每次访问的平均杂货购买额增加约 $0.16，保持访问持续时间恒定）和 2.2（将访问持续时间增加一分钟会使每次访问的平均杂货购买额增加约 $2.20）：

```py
## Python (output not shown)
ols("grocery_purchases~duration+play_area", data=hist_data_df).fit().summary()
```

```py
## R
summary(lm(grocery_purchases~duration+play_area, data=hist_data))
...
Coefficients:
             Estimate Std. Error  t value Pr(>|t|)    
(Intercept) -2.917728   0.047329  -61.647  < 2e-16 ***
duration     2.187025   0.001695 1290.410  < 2e-16 ***
play_area1   0.157477   0.046419    3.393 0.000693 ***
...
```

###### 注

在这个非常简单的例子中，这三个是唯一涉及的变量，但在现实生活中，你还必须在每个回归中包括任何向因变量的箭头的其他变量。

我之前提到，主要原因应该“默认情况下”包含在回归中。然而，有时主要原因和中介变量可能相关性非常密切，以至于在回归中同时包含它们会产生多重共线性。这通常是由于完全中介引起的，表现为系数方向相反（即，主要原因和中介大多相互抵消）且 p 值很大的可疑大系数。在最糟糕的情况下，你的分析软件甚至可能放弃并返回一个错误消息，而不是完成回归。每当将主要原因包含在回归中会使中介变量的系数变得混乱时，请不要包含主要原因。

最后，你可能还会遇到更复杂的情况，比如两个中介之间有额外的箭头，即，其中一个中介也是另一个中介的原因（[图 12-7](#one_of_the_mediators_affects_the_other)）。这不仅仅是一个理论上的可能性；这实际上时有发生，特别是在行为数据中。像那样的情况无法使用捷径，你需要记住我们在 [第二部分](part02.xhtml#causal_diagrams_and_deconfounding) 学到的内容：解决混淆的背门标准和其他因果图规则仍然适用，并会告诉你应该包括和不应该包括在回归中的变量。

![其中一个中介影响另一个中介](Images/BEDA_1207.png)

###### 图 12-7\. 其中一个中介影响另一个中介

被中介的效应等于沿着中介链的两个系数的乘积（即，*VisitDuration* 对 *PlayArea* 回归的系数和 *GroceryPurchases* 对 *VisitDuration* 回归的系数）：

*MediatedEffect* ≈ 12.6 * 2.2 ≈ 27.5

从那里，我们可以计算出被中介的总效应的百分比：

*中介百分比 = 中介效应 / 总效应 ≈ 27.5 / 27.6 ≈ 99.5%*

这个百分比的自举90%置信区间大约是[0.9933; 0.9975]。

### 直接效应

直接、未中介效应等于在*GroceryPurchases*回归中*PlayArea*和*VisitDuration*的系数：*未中介效应* ≈ 0.16。通过这种方法，我们可以计算未中介的总效应百分比：

*未中介百分比* = *未中介效应 / 总效应* ≈ 0.16 / 27.6 ≈ 0.5%

换句话说，从技术上讲，总效应并没有完全中介。然而，出于实际目的，我们可以忽略未中介的效应。请注意，“未中介效应”始终是与特定中介物相关联的。如果您有两个中介者共同完全中介了总效应，第一个的中介效应将等于第二个的未中介效应，反之亦然。

在遇到多重共线性情况并且无法像前文描述那样将主要原因包含在回归中时，效应很可能是完全中介的。您可以通过计算未中介的总效应百分比来确认这一点：

*未中介百分比* = (*总效应 - 中介效应*) / *总效应*

如果您通过这种方法获得了经济上显著的未中介效应，这意味着您手头的因果结构比您想象的更加复杂。那么是时候以批判的眼光重新审视您的CD了。也许您的主要原因和中介者有进一步的共同原因？或者可能存在几个中介者之间的相互关系？

###### 注意

在这个例子中，中介者与其原因和效应都呈正相关。如果沿链的两个系数中有一个是负的，中介者也可能产生负效应。如果发生这种情况，并且我们的原因和感兴趣的效应之间有另一个中介者或直接效应，那么中介者将*减少*总效应。在这种情况下，您的第一个中介者可能代表总效应的-25%，而直接效应（或另一个中介者）将代表总效应的125%，但效应比例的总和仍将是100%。这是完全正常和预期的，所以不要让它困扰你。

如果你觉得这很令人困惑，那你不是一个人。社会科学家们几十年来一直在辩论是否将显著总效应作为中介分析的先决条件。但有许多完全合法的调节或自我调节现象，中介物可以补偿直接效应。例如，C-Mart可能发现其价格变动并未像预期那样影响其销量，因为这些变动引起了竞争对手的相应价格变动。

### 当中介物是二元变量时

在这个例子中，中介是一个数值变量，所以我们可以通过乘以涉及的两个箭头的系数来轻松获得中介效应。当中介是一个二元变量时，仍然可以通过分析量化中介效应，即通过使用方程，但公式变得更加复杂。

如果我们称兴趣的原因为 *X*，中介为 *M*，感兴趣的效果为 *Y*，则中介和最终效果的回归方程变为：

*P(M* = 1) = logistic(*α[0]* + *α[X].X*)

*Y* = *β*[0] + *β[X].X* + *β[M].M*

请注意，第一个方程现在是一个逻辑回归，适用于二元变量。与线性回归预测 M 的值不同，我们现在预测它将取值 1 的概率，P(M = 1)。我们可以在第二个方程中替换该概率：

*Y* = *β*[0] + *β[X].X* + *β[M].P*(*M* = *1*)

直接影响仍然很容易计算：如果 X 增加 1，直接效应增加 *β[X]* 的 Y。但是间接效应现在面临额外挑战，因为 X 对 M 的影响不是线性的。因此，必须确定 X 对 M 的影响*在某个 X 的值*上。这个问题类似于我们在[第 11 章](ch11.xhtml#introduction_to_moderation)中遇到的调节问题，可能的解决方案也是相同的：

+   定义一个全局参考点，例如我们数据中 X 的平均值。

+   或者计算我们数据中每一行的中介效应和中介百分比，然后计算它们各自的平均值。

如同在[第 11 章](ch11.xhtml#introduction_to_moderation)中的情况一样，我推荐第二种方法，根据需要修改以适应手头的业务决策。

# 工具变量

中介本身代表了行为数据分析工具箱的重要补充，但它也是通向另一个强大工具称为工具变量（IVs）的基石。简而言之，IVs 利用已知的中介关系来减少我们系数中的混杂偏倚。

最强大的用例之一是使用实验来回答更广泛，通常更难的问题。我将通过一个涉及顾客满意度的例子来说明这个应用，这是最受关注的业务指标之一，但也公认是最难测量的。

正如在[第2章](ch02.xhtml#understanding_behavioral_data)中首次提到的，AirCnC的领导希望了解客户满意度（*CSAT*）对其关键绩效指标之一——预订后六个月内支出金额（*M6Spend*）的影响。我们将重复使用[第10章](ch10.xhtml#cluster_randomization_and_hierarchical)中的实验数据，该实验探讨了呼叫中心程序变更对客户满意度的影响：“与其在出现问题时反复道歉，呼叫中心代表应在互动开始时道歉，然后进入‘解决问题模式’，最后提供多个选择给客户。”

## 数据

本章的[GitHub文件夹](https://oreil.ly/BehavioralDataAnalysisCh12)包含了[第10章](ch10.xhtml#cluster_randomization_and_hierarchical)中实验数据的副本。这次我们将在分析中包含*M6Spend*变量。[表12-1](#variables_in_our_data-id00085)概述了本章数据中的变量。

表12-1\. 我们数据中的变量

|   | 变量描述 | chap10-experimental_data.csv |
| --- | --- | --- |
| *Center_ID* | 10个呼叫中心的分类变量 | ✓ |
| *Rep_ID* | 193名呼叫中心代表的分类变量 | ✓ |
| *Age* | 客户呼叫时的年龄，20-60 | ✓ |
| *Reason* | 呼叫原因，“付款”/“物业” | ✓ |
| *Call_CSAT* | 客户对通话的满意度，0-10 | ✓ |
| *Group* | 实验分配，“ctrl”/“treat” | ✓ |
| *M6Spend* | 预订后六个月内的支出金额 | ✓ |

## 软件包

在本节中，我们将使用以下特定软件包进行工具变量：

```py
## Python
from linearmodels.iv import IV2SLS
```

```py
## R
library(ivreg)
```

## 理解和应用IV

一旦您熟悉了CD和中介，理解IV背后的思想就变得相对简单了：

> 假设两个变量之间存在完全中介关系，并且中介与最终变量之间的关系存在混杂因素。那么，您可以通过将总效应的系数除以第一个中介的系数（即第一个变量与中介之间的关系）来获得该关系的无偏估计。

看看我们的示例是什么样子，让我们首先绘制我们感兴趣的变量的CD。我们想要衡量*CSAT*与*M6Spend*之间的因果关系。高CSAT可能会增加接下来几个月内的预订金额，但这种关系也受到未测量的混杂因素的影响，包括个性特征如开放性。最后，我们有关于我们的实验处理的数据，我们知道这影响了*CSAT*，感谢我们在[第10章](ch10.xhtml#cluster_randomization_and_hierarchical)的实验（[图12-8](#the_cd_for_our_variables_of_interest)）。

![我们感兴趣的变量的CD](Images/BEDA_1208.png)

###### 图12-8\. 我们感兴趣的变量的CD

正如您所看到的，在这个 CD 中，*CSAT* 是 *Group* 和 *M6Spend* 之间的一个中介，但 *CSAT* 和 *M6Spend* 之间的关系被 *Openness* 的混杂效应上升偏置。

在理想的情况下，我们会有关于 *开放性* 变量的数据，并且能够运行两个真实的回归（[方程12-1](#12eqtn1) 和 [方程12-2](#12eqtn2)）。

##### 方程 12-1.

*CSAT* = *β[g]*[1].*Group* + *β*[o1].*Openness*

##### 方程 12-2.

*M6Spend* = *β[c]*[2].*CSAT* + *β[o]*[2].*Openness*

但是，即使我们确实获得了有关开放性的数据（例如，通过调查），我们怎么能确定是否有另一个混杂因素潜伏在角落里呢？

从数学上稍微退后一步，这个问题将我们带到了行为分析的核心：客户满意度是业务成功的重要标准，但由于它受到影响个体行为的无数未观察到的个人特征的强烈影响，我们无法希望识别和控制所有这些特征。这个问题在因果行为框架之外无法令人满意地解决，但在其中处理起来很简单。

回到数学上——让我们按照之前阐述的直觉进行思考：

1.  计算最左边关系的系数，即 *Group* 和 *CSAT* 之间的关系。

1.  计算 *Group* 对 *M6Spend* 的总效应的系数。

1.  通过将步骤 2 的总效应除以步骤 1 的最左边关系的系数，计算 *CSAT* 对 *M6Spend* 的效应的系数。

### 步骤 1：最左边关系

因为 *Group* 是随机分配的，与 *Openness* 不相关，所以我们可以运行以下回归而不是 [方程12-1](#12eqtn1)：

*CSAT* = *β[g]*[1].*Group*

我们对 *β[g]*[1] 的估计是无偏的，并且可以根据需要插入到 [方程12-1](#12eqtn1) 中，因为它是真正的因果系数。

### 步骤 2：总效应

总效应的方程（[方程12-3](#eqtnR)）被称为 *简化* 回归（我们将其索引为“r”），因为它折叠了变量之间的链条。

##### 方程 12-3. 方程 R

*M6Spend* = *β[gr].Group* (Eq. R)

对于调解的第一个臂的同样原因，我们对 *β[gr]* 的估计是无偏的。

### 步骤 3：感兴趣的关系

这就是魔术发生的地方：正如在关于调解的前一部分讨论的那样，*β[gr]* = *β[c]*[2] * *β[g]*[1]。我们可以将这个方程重写为 *β[c]*[2] = *β[gr]* / *β[g]*[1]。因为等号右边的所有变量都是无偏的，左边的一个也是无偏的。对于 *β[c]*[2] 的这个估计是无偏的。

换句话说，如果我们能找到一个（称为 *工具*）的变量，它是我们感兴趣的原因的原因，但与混杂因素和感兴趣的效应无关，我们可以消除两个变量之间的关系：

+   第一个条件（称为 *独立性假设*）是为了使简化后的回归不受偏斜，但幸运的是，对于随机分配，它总是成立的。

+   第二个条件（称为 *排除限制*）可以重新表述为说仪器与感兴趣的效果之间的关系必须完全由感兴趣的原因进行中介。它对于方程 *β[gr]* = *β[c]*[2] * *β[g]*[1] 必须成立。不幸的是，这不能在数学上证明（这将需要知道第二个中介系数，这就是我们要找的！）必须基于定性因果考虑进行假设——例如，在这种情况下，实验组分配不太可能影响 *M6Spend* 除了 *CSAT* 链以外的任何因素。

## 测量

那就是直觉。我们当然可以手工计算所有相应的回归，但正如我们这些被宠坏了的二十一世纪的数据分析师所期望的那样，有一个包可以做到这一点。

首先，我们将通过运行第一中介的线性回归和总效应的线性回归来进行两项合理性检查（即，简化方程）。如果其中任何一个的系数非常接近零（由 Bootstrap CI 决定），那么这将危及我们的 IV 回归。在大多数情况下，您将希望包括一些其他与您感兴趣的变量有因果关系的协变量。在我们来自[第 10 章](ch10.xhtml#cluster_randomization_and_hierarchical)的例子中，*Age*（呼叫者的年龄）和 *Reason*（呼叫原因）预测了 *CSAT* 并与 *Group* 一起包括。我们也应该在这里包括它们：

```py
## Python (output not shown)
ols("call_CSAT~group+age+reason", data=exp_data_df).fit(disp=0).summary()
ols("M6Spend~group+age+reason", data=exp_data_df).fit(disp=0).summary()
```

```py
## R
summary(lm(call_CSAT~group+age+reason, data=exp_data))
summary(lm(M6Spend~group+age+reason, data=exp_data))
..
Coefficients:
               Estimate Std. Error t value Pr(>|t|)    
(Intercept)    4.103826   0.011790  348.07   <2e-16 ***
grouptreat     0.540633   0.006291   85.94   <2e-16 ***
age            0.020202   0.000280   72.14   <2e-16 ***
reasonproperty 0.200590   0.006600   30.39   <2e-16 ***
...
Coefficients:
               Estimate Std. Error  t value         Pr(>|t|)    
(Intercept)    99.93195    0.43976  227.242          < 2e-16 ***
grouptreat      1.61687    0.23465    6.891 0.00000000000557 ***
age            -1.46785    0.01044 -140.536          < 2e-16 ***
reasonproperty  0.44458    0.24615    1.806           0.0709 . 
...
```

幸运的是，两个系数都与零安全地不同，因此我们可以转向我们的 IV 回归。

### Python 代码

在 Python 中，我们将使用 `linearmodels` 包：

```py
## Python 
iv_mod = IV2SLS.from_formula('M6Spend ~ 1 + age + reason + [call_CSAT ~ group]', 
                             exp_data_df).fit()
iv_mod.params
Out[8]: 
Intercept             87.658610
reason[T.property]    -0.155326
age                   -1.528264
call_CSAT              2.990706
Name: parameter, dtype: float64
```

`IV2SLS.from_formula()` 函数的语法与 `ols()` 几乎相同。预测变量，我们感兴趣的效果，位于波浪号（“~”）的左侧，预测变量位于右侧，第一阶段回归写在括号中。有两件事需要注意：

+   您需要明确地在预测变量中包括一个常数（“1”）。

+   与您感兴趣的变量相关的其他协变量（在这里，*Age* 和 *Reason*）也应在此处包括在外，而不是在括号内。请注意，它们将自动包括在第一阶段回归中。您的第一阶段回归公式只需要包括介质，也就是我们感兴趣的原因，以及仪器。

Python 函数的输出是有限的，但这就是我们所需要的。*call_CSAT* 对 *M6Spend* 的影响约为每单位 $2.99，比 *M6Spend* 对 *call_CSAT* 的天真、有偏回归少约 $1：

```py
## Python
ols("M6Spend~call_CSAT+age+reason", data=exp_data_df).fit(disp=0).summary()
...
                     coef    std err      t     P>|t| [0.025  0.975]
Intercept           83.2283   0.536    155.302   0.000   82.178  84.279
reason[T.property]  -0.3582   0.245     -1.461   0.144   -0.839   0.122
call_CSAT            4.0019   0.076     52.767   0.000    3.853   4.151
age                 -1.5488   0.010   -147.549   0.000   -1.569  -1.528
...
```

无偏效果的 Bootstrap 90% CI 约为 [2.26; 3.89]。

### R 代码

在 R 中，我们将使用 `ivreg` 包：

```py
## R
> iv_mod <- ivreg::ivreg(M6Spend~call_CSAT + age + reason | group + age + reason, 
    data=exp_data)
> summary(iv_mod)

Call:
ivreg::ivreg(formula = M6Spend ~ call_CSAT + age + reason | group + 
    age + reason, data = exp_data)

Residuals:
   Min     1Q Median     3Q    Max 
-86.82 -35.01 -17.94  19.92 706.58 

Coefficients:
               Estimate Std. Error  t value         Pr(>|t|)    
(Intercept)    87.65861    1.93745   45.244          < 2e-16 ***
call_CSAT       2.99071    0.43165    6.929 0.00000000000426 ***
age            -1.52826    0.01358 -112.540          < 2e-16 ***
reasonproperty -0.15533    0.25968   -0.598             0.55    

Diagnostic tests:
                    df1    df2 statistic p-value    
Weak instruments      1 231655  7384.847  <2e-16 ***
Wu-Hausman            1 231654     5.667  0.0173 *  
Sargan                0     NA        NA      NA    
---
Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1

Residual standard error: 56.12 on 231655 degrees of freedom
Multiple R-Squared: 0.0925,	Adjusted R-squared: 0.09249 
Wald test:  7019 on 3 and 231655 DF,  p-value: < 2.2e-16
```

幸运的是，`ivreg`软件包的作者们努力使`ivreg()`函数尽可能地与`lm()`相似，无论是在语法还是输出上。公式中唯一的区别在于现在有两个回归器的列表，用竖线“|”分隔。变量应放置在这里：

+   感兴趣的原因，这里的*call_CSAT*，只出现在条的左侧。

+   仪器（这里的*Group*）仅出现在条的右侧。

+   其他解释变量对我们感兴趣的因果关系的贡献，这里的*Age*和*Reason*，都出现在条中。

`ivreg()`的输出也与`lm()`的输出非常相似。我们感兴趣的值是*call_CSAT*的系数。`ivreg()`还返回IV的几个诊断结果，这些诊断结果测试我们模型中各种关系的强度。在这里，*call_CSAT*对*M6Spend*的影响约为每单位2.99美元。相应的Bootstrap 90%置信区间约为[2.26; 3.89]。

###### 注意

在我们的简单例子中，这两个估计之间的差异来自*Openness*。在现实生活中，我们不太可能能够自信地识别所有起作用的混杂因素，我们可以将其标记为“未知的心理因素”。然而，即使没有测量这些混杂因素，我们也可以通过*CSAT*来测量它们对*M6Spend*的影响：这些混杂因素的变化导致*CSAT*增加1分，也会导致*M6Spend*增加约1美元。现在我们可以进行调查来衡量开放性或任何其他未知的心理因素，有了这个知识，我们可以说，每点*CSAT*对*M6Spend*的混杂效应大约值得1美元。我们知道我们不知道什么，如果你问我的话，这挺酷的。

## 应用IV：常见问题解答

在前面的例子中，我们利用IV来分析实验数据：利用实验数据去除因果关系中的混杂因素。这是它们最直接和有效的用途之一，但不是唯一的用途。一旦你熟悉了IV，你会开始问自己：“还有什么其他的...？”为每种潜在用例构建完整的例子会显得多余，但指出最常见的用法是值得的：

我能在纯观察数据下使用IV吗？

是的，过程与实验数据完全相同，但因为独立性假设在这种情况下并不是确定的，所以你需要确保它成立。我经常想出一个潜在的仪器，稍后才意识到它与最终效应之间还有另一个潜在联系隐藏在背后。

我能在具有二进制最终效应的情况下使用IV吗？

在这种情况下，系数之间的关系比线性回归复杂得多。R包`ivprobit()`允许您使用工具变量进行概率回归，但据我所知，对于逻辑回归却没有这样的解决方案。

# 结论

我们到此为止。在本书的开头，我承诺我们将衡量客户满意度对业务指标的因果影响，我们也确实做到了：“客户满意度的每增加一单位，接下来六个月的支出增加 $2.99。”没有冗长的警示和脚注，没有“相关性不等于因果关系”的波折——这是一个清晰明了的结果。希望在你的思想中打开了一个全新的机会世界。客户满意度、忠诚计划会员、品牌认知度：衡量所有这些模糊和偏见概念对业务的影响已经在您的掌握之中。而且很可能，您已经拥有所需的数据。两年前市场营销部门是否进行了一个试验，给客户提供折扣，如果他们加入您的忠诚计划？那么只需提取相应的数据并应用一行公式进行 IV 回归。当然，这种简单性并非凭空而来。这是经过长时间的发展，因为它需要：

+   对客户满意度和支出的明确定义和理解的变量，正如我们在[第 I 部分](part01.xhtml#understanding_behaviors)中所见

+   正确的因果图，正如我们在[第 II 部分](part02.xhtml#causal_diagrams_and_deconfounding)中发现的

+   工具让我们能够处理不确定性，而无需记住一堆统计测试，正如我们在[第 III 部分](part03.xhtml#robust_data_analysis)中所见

+   精心设计和深入分析的实验，正如我们在[第 IV 部分](part04.xhtml#designing_and_analyzing_experiments)中所探讨的

+   最后，对中介和调节的理解，正如我们在[第 V 部分](part05.xhtml#advanced_tools_in_behavioral_data_analy)中所学

最后说一些稍微不那么正式的话：人们经常注意到，儿童对世界有着无穷的好奇心（“为什么天空是蓝色的？”）。当然，这种好奇心实际上并不是无限的，在某个时刻大多数孩子会停止问这么多问题。我真诚地希望这本书能在你心中重新点燃一些孩子般的好奇心——让你被世界（特别是人们）所迷惑，并且你会思考，“但为什么呢？”当然，在声称任何功劳之前，我必须认真考虑到我可能弄错了因果关系，而你可能从一开始就拥有这一切（[图 12-9](#did_i_mention_that_correlation_is_not_c)）。

![我提到过相关性不等于因果关系吗？](Images/BEDA_1209.png)

###### 图 12-9\. 我提到过相关性不等于因果关系吗？
